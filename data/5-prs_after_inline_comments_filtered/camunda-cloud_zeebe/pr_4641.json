{"pr_number": 4641, "pr_title": "Rewrite Snapshotting", "pr_createdAt": "2020-06-01T06:42:55Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4641", "timeline": [{"oid": "d8305007cabd6805a69bd70f4b6930dba77b959f", "url": "https://github.com/camunda-cloud/zeebe/commit/d8305007cabd6805a69bd70f4b6930dba77b959f", "message": "chore(logstreams): remove takeSnapshot", "committedDate": "2020-06-01T06:45:05Z", "type": "commit"}, {"oid": "93d121352ee07af5e0a104e410880bc9486cca6a", "url": "https://github.com/camunda-cloud/zeebe/commit/93d121352ee07af5e0a104e410880bc9486cca6a", "message": "chore(atomix): rewrite snapshotting\n\n Description:\n\n Introduces new interfaces for Snapshotting.\n\n PersistedSnapshotStore can be used to take snapshots and receive\n snapshot chunks. After all chunks are received or the snapshot is taken\n the volatile snapshot can be persisted. It is always possible\n to abort an snapshot, before persisting. The store can also be used\n to get the latest snapshot which was persisted. The store allows\n to register listeners, which are called on new persisted snapshots.\n\n On receiving snapshot chunks and consuming them, checksums of the chunks\n are verified. On persisting an received snapshot the complete snapshot\n checksum is verified.\n\n An persisted snapshot can be read from it persisted storage via a\n snapshot reader and will be chunked in several snapshot chunks, which\n then can be transmitted and consumed again by the store.\n\n The StateSnapshotController use by the AsyncSnapshotDirector and is the\n only one which takes a snapshot. The ReplicationController is\n registered at the SnapshotStore as listener to replicate new persisted\n snapshots. The replication will send all chunks over the network.\n\n The ReplicationController will receive the chunks on the follower side and will use\n the newReceviedSnapshot method of the store to consume the SnapshotChunks.\n\n On the LeaderRole (in the AbstractAppender) the last snapshot can also\n be replicated. This is done via the SnapshotChunkReader, which\n reads the chunks from ther persisted store.\n\n The Follower (in PassiveRole) will consume the replicated chunks and\n will store it similar to the ReplicationController.\n\n On both ReplicationController and PassiveRole the checksum of the\n snapshot chunks but also of the complete snapshot is verified before\n the received snapshot is persisted.\n\n Related work:\n\n  * Most implemation details are now in Atomix\n  * Zeebe related snapshoting like replication and taking of snapshot is\n    part of Broker\n  * Use sbe for snapshot chunk replication/consumption\n  * StreamProcessorTests moved again to engine module - removed snapshot\n    related tests, dont need to be part of that\n  * clean up managment schema file in broker\n\n  * Wrote a bunch of new unit tests for snapshot implementation", "committedDate": "2020-06-01T06:52:37Z", "type": "forcePushed"}, {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "url": "https://github.com/camunda-cloud/zeebe/commit/f89f99c64572bf1aa4b363b69c096660b3fbaffb", "message": "chore(atomix): rewrite snapshotting\n\n Description:\n\n Introduces new interfaces for Snapshotting.\n\n PersistedSnapshotStore can be used to take snapshots and receive\n snapshot chunks. After all chunks are received or the snapshot is taken\n the volatile snapshot can be persisted. It is always possible\n to abort an snapshot, before persisting. The store can also be used\n to get the latest snapshot which was persisted. The store allows\n to register listeners, which are called on new persisted snapshots.\n\n On receiving snapshot chunks and consuming them, checksums of the chunks\n are verified. On persisting an received snapshot the complete snapshot\n checksum is verified.\n\n An persisted snapshot can be read from it persisted storage via a\n snapshot reader and will be chunked in several snapshot chunks, which\n then can be transmitted and consumed again by the store.\n\n The StateSnapshotController use by the AsyncSnapshotDirector and is the\n only one which takes a snapshot. The ReplicationController is\n registered at the SnapshotStore as listener to replicate new persisted\n snapshots. The replication will send all chunks over the network.\n\n The ReplicationController will receive the chunks on the follower side and will use\n the newReceviedSnapshot method of the store to consume the SnapshotChunks.\n\n On the LeaderRole (in the AbstractAppender) the last snapshot can also\n be replicated. This is done via the SnapshotChunkReader, which\n reads the chunks from ther persisted store.\n\n The Follower (in PassiveRole) will consume the replicated chunks and\n will store it similar to the ReplicationController.\n\n On both ReplicationController and PassiveRole the checksum of the\n snapshot chunks but also of the complete snapshot is verified before\n the received snapshot is persisted.\n\n Related work:\n\n  * Most implemation details are now in Atomix\n  * Zeebe related snapshoting like replication and taking of snapshot is\n    part of Broker\n  * Use sbe for snapshot chunk replication/consumption\n  * StreamProcessorTests moved again to engine module - removed snapshot\n    related tests, dont need to be part of that\n  * clean up managment schema file in broker\n\n  * Wrote a bunch of new unit tests for snapshot implementation", "committedDate": "2020-06-02T05:13:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyMzk4NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433723984", "bodyText": "This method is hard to understand without context.\n\nNot sure why sending append requests fulfills the task to replicate a snapshot.\nNot sure the method does what it claims to do; in the caller there is a condition \"If there's a snapshot at the member's nextIndex, replicate the snapshot.\" but it is not clear whether this conidtion is checked in the caller or in the method itself", "author": "pihme", "createdAt": "2020-06-02T08:56:18Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/LeaderAppender.java", "diffHunk": "@@ -277,26 +276,47 @@ else if (member.getConfigTerm() < raft.getTerm()\n     else if (member.getMember().getType() == RaftMember.Type.ACTIVE\n         || member.getMember().getType() == RaftMember.Type.PROMOTABLE\n         || member.getMember().getType() == RaftMember.Type.PASSIVE) {\n-      final Snapshot snapshot = raft.getSnapshotStore().getCurrentSnapshot();\n-      if (snapshot != null\n-          && member.getSnapshotIndex() < snapshot.index()\n-          && snapshot.index() >= member.getLogReader().getCurrentIndex()) {\n-        if (!member.canInstall()) {\n-          return;\n-        }\n-\n-        log.debug(\"Replicating snapshot {} to {}\", snapshot.index(), member.getMember().memberId());\n-        sendInstallRequest(member, buildInstallRequest(member, snapshot));\n-      } else if (member.canAppend()) {\n-        sendAppendRequest(member, buildAppendRequest(member, -1));\n-      }\n+      replicateSnapshot(member);\n     }\n     // If no AppendRequest is already being sent, send an AppendRequest.\n     else if (member.canAppend()) {\n       sendAppendRequest(member, buildAppendRequest(member, -1));\n     }\n   }\n \n+  private void replicateSnapshot(final RaftMemberContext member) {", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwMjA4NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435002085", "bodyText": "I agree with Peter here.", "author": "deepthidevaki", "createdAt": "2020-06-04T05:34:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyMzk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4Mzk5Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435683996", "bodyText": "One thing to note that this is Atomix code and I haven't wrote that, if we talking about the general append stuff \ud83d\ude05 I just extracted the code and  tried to strech/pull out the conditional branches, because before I felt it was even worse. I wanted to extract it to a separate method to make clear that this part replicates the snapshot.  Maybe I rename it to try to replicate \ud83d\ude05\nNot 100% sure what do you mean with the second point.", "author": "Zelldon", "createdAt": "2020-06-05T04:30:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyMzk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2NDQ3MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435764471", "bodyText": "Agreed on :\n\nwe use the old if statements\nrename it to tryReplicateSnapshot", "author": "Zelldon", "createdAt": "2020-06-05T08:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyMzk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyNjkyMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433726921", "bodyText": "Can we assume single threaded execution or do we need to synchronize access to this property?", "author": "pihme", "createdAt": "2020-06-02T09:01:11Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java", "diffHunk": "@@ -35,27 +35,27 @@\n import io.atomix.raft.protocol.ReconfigureResponse;\n import io.atomix.raft.protocol.VoteRequest;\n import io.atomix.raft.protocol.VoteResponse;\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.impl.SnapshotChunkImpl;\n import io.atomix.raft.storage.log.RaftLogReader;\n import io.atomix.raft.storage.log.RaftLogWriter;\n import io.atomix.raft.storage.log.entry.RaftLogEntry;\n-import io.atomix.raft.storage.snapshot.PendingSnapshot;\n-import io.atomix.raft.storage.snapshot.Snapshot;\n-import io.atomix.raft.storage.snapshot.SnapshotListener;\n-import io.atomix.raft.storage.snapshot.SnapshotStore;\n import io.atomix.storage.StorageException;\n import io.atomix.storage.journal.Indexed;\n import io.atomix.utils.concurrent.ThreadContext;\n-import io.atomix.utils.time.WallClockTimestamp;\n import java.io.IOException;\n import java.util.concurrent.CompletableFuture;\n+import org.agrona.concurrent.UnsafeBuffer;\n import org.slf4j.Logger;\n \n /** Passive state. */\n public class PassiveRole extends InactiveRole {\n   private final SnapshotReplicationMetrics snapshotReplicationMetrics;\n \n   private long pendingSnapshotStartTimestamp;\n-  private PendingSnapshot pendingSnapshot;\n+  private ReceivedSnapshot pendingSnapshot;", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NDA2OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435684068", "bodyText": "raft runs in one thread", "author": "Zelldon", "createdAt": "2020-06-05T04:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyNjkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyNzM4NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433727385", "bodyText": "typo \"Represents a snapshot\"", "author": "pihme", "createdAt": "2020-06-02T09:01:57Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/PersistedSnapshot.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.CloseableSilently;\n+import java.nio.file.Path;\n+import java.util.Comparator;\n+\n+/** Represents an snapshot, which was persisted at the {@link PersistedSnapshotStore}. */", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyNzcxNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433727717", "bodyText": "How is time synchronized between nodes?", "author": "pihme", "createdAt": "2020-06-02T09:02:32Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/PersistedSnapshot.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.CloseableSilently;\n+import java.nio.file.Path;\n+import java.util.Comparator;\n+\n+/** Represents an snapshot, which was persisted at the {@link PersistedSnapshotStore}. */\n+public interface PersistedSnapshot extends CloseableSilently, Comparable<PersistedSnapshot> {\n+\n+  /**\n+   * Returns the snapshot timestamp.\n+   *\n+   * <p>The timestamp is the wall clock time at the {@link #getIndex()} at which the snapshot was", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NDQwNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435684404", "bodyText": "it isn't", "author": "Zelldon", "createdAt": "2020-06-05T04:32:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyNzcxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkyNDM3OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435924378", "bodyText": "#4676", "author": "Zelldon", "createdAt": "2020-06-05T13:34:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyNzcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyODUzNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433728534", "bodyText": "\"Written\" is maybe a little ambiguous. Written to disk? Written to the state machine?", "author": "pihme", "createdAt": "2020-06-02T09:03:56Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/PersistedSnapshot.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.CloseableSilently;\n+import java.nio.file.Path;\n+import java.util.Comparator;\n+\n+/** Represents an snapshot, which was persisted at the {@link PersistedSnapshotStore}. */\n+public interface PersistedSnapshot extends CloseableSilently, Comparable<PersistedSnapshot> {\n+\n+  /**\n+   * Returns the snapshot timestamp.\n+   *\n+   * <p>The timestamp is the wall clock time at the {@link #getIndex()} at which the snapshot was\n+   * taken.\n+   *\n+   * @return The snapshot timestamp.\n+   */\n+  WallClockTimestamp getTimestamp();\n+\n+  /**\n+   * Returns the snapshot format version.\n+   *\n+   * @return the snapshot format version\n+   */\n+  int version();\n+\n+  /**\n+   * Returns the snapshot index.\n+   *\n+   * <p>The snapshot index is the index of the state machine at the point at which the snapshot was\n+   * written.", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyOTU1MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433729551", "bodyText": "type \"a listener\"", "author": "pihme", "createdAt": "2020-06-02T09:05:32Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/PersistedSnapshotListener.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package io.atomix.raft.snapshot;\n+\n+/**\n+ * Represents an listener which can be added to the {@link PersistedSnapshotStore} to be notified", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyOTg4NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433729885", "bodyText": "typo \"a store\"", "author": "pihme", "createdAt": "2020-06-02T09:06:03Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/PersistedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.CloseableSilently;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * Represents an store, which allows to persist snapshots on a storage, which is implementation", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzczMTU2OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433731568", "bodyText": "Again typo \"a registered\" I guess I will stop pointing these out from now on", "author": "pihme", "createdAt": "2020-06-02T09:08:52Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/PersistedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.CloseableSilently;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * Represents an store, which allows to persist snapshots on a storage, which is implementation\n+ * dependent. It is possible to take a transient snapshot, which means you can start taking an\n+ * snapshot and can persist it later or abort it. Furthermore it is possible to persist/receive\n+ * {@link SnapshotChunk}'s from an already {@link PersistedSnapshot} and persist them in this\n+ * current store.\n+ *\n+ * <p>Only one {@link PersistedSnapshot} at a time is stored in the {@link PersistedSnapshotStore}\n+ * and can be received via {@link PersistedSnapshotStore#getLatestSnapshot()}.\n+ */\n+public interface PersistedSnapshotStore extends CloseableSilently {\n+\n+  /**\n+   * Returns true if a snapshot with the given identifier exists already, false otherwise.\n+   *\n+   * @param id the snapshot ID to look for\n+   * @return true if there is a committed snapshot with this ID, false otherwise\n+   * @see SnapshotId\n+   */\n+  boolean exists(String id);\n+\n+  /**\n+   * Starts a new transient snapshot which can be persisted after the snapshot was taken.\n+   *\n+   * @param index the index to which the snapshot corresponds to\n+   * @param term the term to which the snapshots corresponds to\n+   * @param timestamp the time to which the snapshots corresponds to\n+   * @return the new transient snapshot\n+   */\n+  TransientSnapshot newTransientSnapshot(\n+      final long index, final long term, final WallClockTimestamp timestamp);\n+\n+  /**\n+   * Starts a new received volatile snapshot which can be persisted later.\n+   *\n+   * @param snapshotId the snapshot id which is defined as {@code index-term-timestamp}\n+   * @return the new volatile received snapshot\n+   */\n+  ReceivedSnapshot newReceivedSnapshot(String snapshotId);\n+\n+  /** @return the latest {@link PersistedSnapshot} if exists */\n+  Optional<PersistedSnapshot> getLatestSnapshot();\n+\n+  /**\n+   * Purges all ongoing pending/transient/volatile snapshots.\n+   *\n+   * @throws IOException when there was an unexpected IO issue\n+   */\n+  void purgePendingSnapshots() throws IOException;\n+\n+  /**\n+   * Adds an {@link PersistedSnapshotListener} to the store, which is notified when a new {@link\n+   * PersistedSnapshot} is persisted at this store.\n+   *\n+   * @param listener the listener which should be added and notified later\n+   */\n+  void addSnapshotListener(PersistedSnapshotListener listener);\n+\n+  /**\n+   * Removes an registered {@link PersistedSnapshotListener} from the store. The listener will no", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MDQ5OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435690498", "bodyText": "sorry \ud83d\ude06", "author": "Zelldon", "createdAt": "2020-06-05T04:59:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzczMTU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzczMzM1Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433733353", "bodyText": "I find the method name confusing. Currently it only checks whether the one snapshot which is kept has this ID. But the method sounds as if it would know whether any snapshot with that id exists globally.", "author": "pihme", "createdAt": "2020-06-02T09:11:55Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/PersistedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.CloseableSilently;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * Represents an store, which allows to persist snapshots on a storage, which is implementation\n+ * dependent. It is possible to take a transient snapshot, which means you can start taking an\n+ * snapshot and can persist it later or abort it. Furthermore it is possible to persist/receive\n+ * {@link SnapshotChunk}'s from an already {@link PersistedSnapshot} and persist them in this\n+ * current store.\n+ *\n+ * <p>Only one {@link PersistedSnapshot} at a time is stored in the {@link PersistedSnapshotStore}\n+ * and can be received via {@link PersistedSnapshotStore#getLatestSnapshot()}.\n+ */\n+public interface PersistedSnapshotStore extends CloseableSilently {\n+\n+  /**\n+   * Returns true if a snapshot with the given identifier exists already, false otherwise.\n+   *\n+   * @param id the snapshot ID to look for\n+   * @return true if there is a committed snapshot with this ID, false otherwise\n+   * @see SnapshotId\n+   */\n+  boolean exists(String id);", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NDc4Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435684786", "bodyText": "before we had more snapshots so it derived from there. So maybe hasSnapshotId?", "author": "Zelldon", "createdAt": "2020-06-05T04:34:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzczMzM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzczOTIwNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433739205", "bodyText": "Personally, I would prefer to separate the storing interface from the \"snapshot replication\" interface. This means, I would move\n\nnewTransientSnapshot(...)\nnewReceivedSnapshot(...)\npurgePendingSnapshots(...)\n\nInto one or two distinct interfaces. Two interfaces to separate the creating of new transient snapshots (which I see as the \"sending part\" and the receiving of snapshots (receiving part)\nNote that separating on an interface level does not prohibit to implement all interfaces in the same class,\nAlso don't udnerstand why newSnapshot(...) is not exposed in the interface. In fact, I would understand the design better, if the persist(..) method of \"PersistableSnapshot\" was in this interface and then you could document that it will only be persisted, if it is newer than the current snapshot and that the snapshot returned might be a a different snapshot altogether (i.e. the new snapshot will be returned if the snapshot to be persisted is older)", "author": "pihme", "createdAt": "2020-06-02T09:21:45Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/PersistedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.CloseableSilently;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * Represents an store, which allows to persist snapshots on a storage, which is implementation\n+ * dependent. It is possible to take a transient snapshot, which means you can start taking an\n+ * snapshot and can persist it later or abort it. Furthermore it is possible to persist/receive\n+ * {@link SnapshotChunk}'s from an already {@link PersistedSnapshot} and persist them in this\n+ * current store.\n+ *\n+ * <p>Only one {@link PersistedSnapshot} at a time is stored in the {@link PersistedSnapshotStore}\n+ * and can be received via {@link PersistedSnapshotStore#getLatestSnapshot()}.\n+ */\n+public interface PersistedSnapshotStore extends CloseableSilently {\n+\n+  /**\n+   * Returns true if a snapshot with the given identifier exists already, false otherwise.\n+   *\n+   * @param id the snapshot ID to look for\n+   * @return true if there is a committed snapshot with this ID, false otherwise\n+   * @see SnapshotId\n+   */\n+  boolean exists(String id);\n+\n+  /**\n+   * Starts a new transient snapshot which can be persisted after the snapshot was taken.\n+   *\n+   * @param index the index to which the snapshot corresponds to\n+   * @param term the term to which the snapshots corresponds to\n+   * @param timestamp the time to which the snapshots corresponds to\n+   * @return the new transient snapshot\n+   */\n+  TransientSnapshot newTransientSnapshot(", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NjkzOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435686939", "bodyText": "I have already two interfaces for receiving and sending for the snapshots, but you want to have two for the store as well to separate it better. Do I get that right?\nI like when I can work with just one object and for me it was clean to say \"ok I now persist this transient snapshot\", which is why the persist is on this interface. The store just keeps the persisted ones and allows to create new transient ones, which can be persisted. But I get that point of having the persist on the store. I have to think about that.", "author": "Zelldon", "createdAt": "2020-06-05T04:44:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzczOTIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwOTA4NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435909084", "bodyText": "I tried it out. I have the feeling that this makes it much more complicated than it needs to be, since I have to maintain also these different types then in raft context. Where it sometimes read only and just wants to check whether there is a snapshot or not, then It needs a storage to receive stuff.", "author": "Zelldon", "createdAt": "2020-06-05T13:08:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzczOTIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkxMTA5NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435911094", "bodyText": "You can check this branch if you want https://github.com/zeebe-io/zeebe/tree/zell-multiple-factories", "author": "Zelldon", "createdAt": "2020-06-05T13:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzczOTIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyNDc4MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433924780", "bodyText": "Isn't there a name pattern or something to disambiguate the files we want to count from potential files just lying around?", "author": "pihme", "createdAt": "2020-06-02T14:33:59Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotChunkReader.java", "diffHunk": "@@ -28,19 +40,39 @@\n  * ordered lexicographically, and the files are assumed to be immutable, i.e. no more are added to\n  * the directory once this is created.\n  */\n-public final class DbSnapshotChunkReader implements SnapshotChunkReader {\n-  public static final Charset ID_CHARSET = StandardCharsets.US_ASCII;\n+public final class FileBasedSnapshotChunkReader implements SnapshotChunkReader {\n+  static final Charset ID_CHARSET = StandardCharsets.US_ASCII;\n+\n   private final Path directory;\n   private final NavigableSet<CharSequence> chunks;\n   private final CharSequenceView chunkIdView;\n \n   private NavigableSet<CharSequence> chunksView;\n+  private final int totalCount;\n+  private final long snapshotChecksum;\n+  private final String snapshotID;\n \n-  public DbSnapshotChunkReader(final Path directory, final NavigableSet<CharSequence> chunks) {\n+  FileBasedSnapshotChunkReader(final Path directory) throws IOException {\n     this.directory = directory;\n-    this.chunks = chunks;\n+    this.chunks = collectChunks(directory);\n+    this.totalCount = chunks.size();\n     this.chunksView = this.chunks;\n     this.chunkIdView = new CharSequenceView();\n+\n+    try (final var fileStream = Files.list(directory).sorted()) {\n+      this.snapshotChecksum =\n+          ChecksumUtil.createCombinedChecksum(fileStream.collect(Collectors.toList()));\n+    }\n+\n+    this.snapshotID = directory.getFileName().toString();\n+  }\n+\n+  private NavigableSet<CharSequence> collectChunks(final Path directory) throws IOException {\n+    final var set = new TreeSet<>(CharSequence::compare);\n+    try (final var stream = Files.list(directory).sorted()) {", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NzI1NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435687255", "bodyText": "depends on the db implementation or for what you take snapshot I would say", "author": "Zelldon", "createdAt": "2020-06-05T04:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyNDc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyODE1Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433928152", "bodyText": "Single threaded of need for synchronization?", "author": "pihme", "createdAt": "2020-06-02T14:38:46Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import org.slf4j.Logger;\n+\n+public final class FileBasedSnapshotStore implements PersistedSnapshotStore {\n+\n+  private static final Logger LOGGER = new ZbLogger(FileBasedSnapshotStore.class);\n+\n+  // the root snapshotsDirectory where all snapshots should be stored\n+  private final Path snapshotsDirectory;\n+  // the root snapshotsDirectory when pending snapshots should be stored\n+  private final Path pendingDirectory;\n+  // keeps track of all snapshot modification listeners\n+  private final Set<PersistedSnapshotListener> listeners;\n+\n+  private final SnapshotMetrics snapshotMetrics;\n+\n+  private PersistedSnapshot currentPersistedSnapshot;", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MjAzNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435692035", "bodyText": "Good point probably we need a atomic reference here", "author": "Zelldon", "createdAt": "2020-06-05T05:06:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyODE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkzMDA3MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433930070", "bodyText": "Why error?", "author": "pihme", "createdAt": "2020-06-02T14:41:30Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import org.slf4j.Logger;\n+\n+public final class FileBasedSnapshotStore implements PersistedSnapshotStore {\n+\n+  private static final Logger LOGGER = new ZbLogger(FileBasedSnapshotStore.class);\n+\n+  // the root snapshotsDirectory where all snapshots should be stored\n+  private final Path snapshotsDirectory;\n+  // the root snapshotsDirectory when pending snapshots should be stored\n+  private final Path pendingDirectory;\n+  // keeps track of all snapshot modification listeners\n+  private final Set<PersistedSnapshotListener> listeners;\n+\n+  private final SnapshotMetrics snapshotMetrics;\n+\n+  private PersistedSnapshot currentPersistedSnapshot;\n+\n+  public FileBasedSnapshotStore(\n+      final SnapshotMetrics snapshotMetrics,\n+      final Path snapshotsDirectory,\n+      final Path pendingDirectory) {\n+    this.snapshotsDirectory = snapshotsDirectory;\n+    this.pendingDirectory = pendingDirectory;\n+    this.snapshotMetrics = snapshotMetrics;\n+\n+    this.listeners = new CopyOnWriteArraySet<>();\n+\n+    // load previous snapshots\n+    currentPersistedSnapshot = loadLatestSnapshot(snapshotsDirectory);\n+  }\n+\n+  private PersistedSnapshot loadLatestSnapshot(final Path snapshotDirectory) {\n+    PersistedSnapshot latestPersistedSnapshot = null;\n+    try (final var stream = Files.newDirectoryStream(snapshotDirectory)) {\n+      for (final var path : stream) {\n+        latestPersistedSnapshot = collectSnapshot(path);\n+      }\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+    return latestPersistedSnapshot;\n+  }\n+\n+  private PersistedSnapshot collectSnapshot(final Path path) {\n+    final var optionalMeta = FileBasedSnapshotMetadata.ofPath(path);\n+    if (optionalMeta.isPresent()) {\n+      final var metadata = optionalMeta.get();\n+      return new FileBasedSnapshot(path, metadata);\n+    } else {\n+      LOGGER.warn(\"Expected snapshot file format to be %d-%d-%d-%d, but was {}\", path);\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean exists(final String id) {\n+    final var optLatestSnapshot = getLatestSnapshot();\n+\n+    if (optLatestSnapshot.isPresent()) {\n+      final var snapshot = optLatestSnapshot.get();\n+      return snapshot.getPath().getFileName().toString().equals(id);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public TransientSnapshot newTransientSnapshot(\n+      final long index, final long term, final WallClockTimestamp timestamp) {\n+    final var directory = buildPendingSnapshotDirectory(index, term, timestamp);\n+    final var fileBasedSnapshotMetadata = new FileBasedSnapshotMetadata(index, term, timestamp);\n+    return new FileBasedTransientSnapshot(fileBasedSnapshotMetadata, directory, this);\n+  }\n+\n+  @Override\n+  public ReceivedSnapshot newReceivedSnapshot(final String snapshotId) {\n+    final var optMetadata = FileBasedSnapshotMetadata.ofFileName(snapshotId);\n+    final var metadata =\n+        optMetadata.orElseThrow(\n+            () ->\n+                new IllegalArgumentException(\n+                    \"Expected snapshot id in a format like 'index-term-timestamp', got '\"\n+                        + snapshotId\n+                        + \"'.\"));\n+\n+    final var pendingSnapshotDir = pendingDirectory.resolve(metadata.getSnapshotIdAsString());\n+    return new FileBasedReceivedSnapshot(metadata, pendingSnapshotDir, this);\n+  }\n+\n+  @Override\n+  public Optional<PersistedSnapshot> getLatestSnapshot() {\n+    return Optional.ofNullable(currentPersistedSnapshot);\n+  }\n+\n+  @Override\n+  public void purgePendingSnapshots() throws IOException {\n+    try (final var files = Files.list(pendingDirectory)) {\n+      files.filter(Files::isDirectory).forEach(this::purgePendingSnapshot);\n+    }\n+  }\n+\n+  @Override\n+  public void addSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.add(listener);\n+  }\n+\n+  @Override\n+  public void removeSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.remove(listener);\n+  }\n+\n+  @Override\n+  public long getCurrentSnapshotIndex() {\n+    return getLatestSnapshot().map(PersistedSnapshot::getIndex).orElse(0L);\n+  }\n+\n+  @Override\n+  public void delete() {\n+    currentPersistedSnapshot = null;\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(snapshotsDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(pendingDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private void observeSnapshotSize(final PersistedSnapshot persistedSnapshot) {\n+    try (final var contents = Files.newDirectoryStream(persistedSnapshot.getPath())) {\n+      var totalSize = 0L;\n+\n+      for (final var path : contents) {\n+        if (Files.isRegularFile(path)) {\n+          final var size = Files.size(path);\n+          snapshotMetrics.observeSnapshotFileSize(size);\n+          totalSize += size;\n+        }\n+      }\n+\n+      snapshotMetrics.observeSnapshotSize(totalSize);\n+    } catch (final IOException e) {\n+      LOGGER.warn(\"Failed to observe size for snapshot {}\", persistedSnapshot, e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshots(final long cutoffIndex) {\n+    LOGGER.debug(\n+        \"Search for orphaned snapshots below oldest valid snapshot with index {} in {}\",\n+        cutoffIndex,\n+        pendingDirectory);\n+\n+    try (final var pendingSnapshots = Files.newDirectoryStream(pendingDirectory)) {\n+      for (final var pendingSnapshot : pendingSnapshots) {\n+        purgePendingSnapshot(cutoffIndex, pendingSnapshot);\n+      }\n+    } catch (final IOException e) {\n+      LOGGER.warn(\n+          \"Failed to delete orphaned snapshots, could not list pending directory {}\",\n+          pendingDirectory,\n+          e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshot(final long cutoffIndex, final Path pendingSnapshot) {\n+    final var optionalMetadata = FileBasedSnapshotMetadata.ofPath(pendingSnapshot);\n+    if (optionalMetadata.isPresent() && optionalMetadata.get().getIndex() < cutoffIndex) {\n+      try {\n+        LOGGER.error(\"Deleted orphaned snapshot {}\", pendingSnapshot);", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NzYyMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435687623", "bodyText": "sorry this was probably because I wanted to see the logs in a test and atomix has per default warn level - I will fix it", "author": "Zelldon", "createdAt": "2020-06-05T04:47:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkzMDA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkzMDQ2Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433930467", "bodyText": "Why error?", "author": "pihme", "createdAt": "2020-06-02T14:42:04Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import org.slf4j.Logger;\n+\n+public final class FileBasedSnapshotStore implements PersistedSnapshotStore {\n+\n+  private static final Logger LOGGER = new ZbLogger(FileBasedSnapshotStore.class);\n+\n+  // the root snapshotsDirectory where all snapshots should be stored\n+  private final Path snapshotsDirectory;\n+  // the root snapshotsDirectory when pending snapshots should be stored\n+  private final Path pendingDirectory;\n+  // keeps track of all snapshot modification listeners\n+  private final Set<PersistedSnapshotListener> listeners;\n+\n+  private final SnapshotMetrics snapshotMetrics;\n+\n+  private PersistedSnapshot currentPersistedSnapshot;\n+\n+  public FileBasedSnapshotStore(\n+      final SnapshotMetrics snapshotMetrics,\n+      final Path snapshotsDirectory,\n+      final Path pendingDirectory) {\n+    this.snapshotsDirectory = snapshotsDirectory;\n+    this.pendingDirectory = pendingDirectory;\n+    this.snapshotMetrics = snapshotMetrics;\n+\n+    this.listeners = new CopyOnWriteArraySet<>();\n+\n+    // load previous snapshots\n+    currentPersistedSnapshot = loadLatestSnapshot(snapshotsDirectory);\n+  }\n+\n+  private PersistedSnapshot loadLatestSnapshot(final Path snapshotDirectory) {\n+    PersistedSnapshot latestPersistedSnapshot = null;\n+    try (final var stream = Files.newDirectoryStream(snapshotDirectory)) {\n+      for (final var path : stream) {\n+        latestPersistedSnapshot = collectSnapshot(path);\n+      }\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+    return latestPersistedSnapshot;\n+  }\n+\n+  private PersistedSnapshot collectSnapshot(final Path path) {\n+    final var optionalMeta = FileBasedSnapshotMetadata.ofPath(path);\n+    if (optionalMeta.isPresent()) {\n+      final var metadata = optionalMeta.get();\n+      return new FileBasedSnapshot(path, metadata);\n+    } else {\n+      LOGGER.warn(\"Expected snapshot file format to be %d-%d-%d-%d, but was {}\", path);\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean exists(final String id) {\n+    final var optLatestSnapshot = getLatestSnapshot();\n+\n+    if (optLatestSnapshot.isPresent()) {\n+      final var snapshot = optLatestSnapshot.get();\n+      return snapshot.getPath().getFileName().toString().equals(id);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public TransientSnapshot newTransientSnapshot(\n+      final long index, final long term, final WallClockTimestamp timestamp) {\n+    final var directory = buildPendingSnapshotDirectory(index, term, timestamp);\n+    final var fileBasedSnapshotMetadata = new FileBasedSnapshotMetadata(index, term, timestamp);\n+    return new FileBasedTransientSnapshot(fileBasedSnapshotMetadata, directory, this);\n+  }\n+\n+  @Override\n+  public ReceivedSnapshot newReceivedSnapshot(final String snapshotId) {\n+    final var optMetadata = FileBasedSnapshotMetadata.ofFileName(snapshotId);\n+    final var metadata =\n+        optMetadata.orElseThrow(\n+            () ->\n+                new IllegalArgumentException(\n+                    \"Expected snapshot id in a format like 'index-term-timestamp', got '\"\n+                        + snapshotId\n+                        + \"'.\"));\n+\n+    final var pendingSnapshotDir = pendingDirectory.resolve(metadata.getSnapshotIdAsString());\n+    return new FileBasedReceivedSnapshot(metadata, pendingSnapshotDir, this);\n+  }\n+\n+  @Override\n+  public Optional<PersistedSnapshot> getLatestSnapshot() {\n+    return Optional.ofNullable(currentPersistedSnapshot);\n+  }\n+\n+  @Override\n+  public void purgePendingSnapshots() throws IOException {\n+    try (final var files = Files.list(pendingDirectory)) {\n+      files.filter(Files::isDirectory).forEach(this::purgePendingSnapshot);\n+    }\n+  }\n+\n+  @Override\n+  public void addSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.add(listener);\n+  }\n+\n+  @Override\n+  public void removeSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.remove(listener);\n+  }\n+\n+  @Override\n+  public long getCurrentSnapshotIndex() {\n+    return getLatestSnapshot().map(PersistedSnapshot::getIndex).orElse(0L);\n+  }\n+\n+  @Override\n+  public void delete() {\n+    currentPersistedSnapshot = null;\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(snapshotsDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(pendingDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private void observeSnapshotSize(final PersistedSnapshot persistedSnapshot) {\n+    try (final var contents = Files.newDirectoryStream(persistedSnapshot.getPath())) {\n+      var totalSize = 0L;\n+\n+      for (final var path : contents) {\n+        if (Files.isRegularFile(path)) {\n+          final var size = Files.size(path);\n+          snapshotMetrics.observeSnapshotFileSize(size);\n+          totalSize += size;\n+        }\n+      }\n+\n+      snapshotMetrics.observeSnapshotSize(totalSize);\n+    } catch (final IOException e) {\n+      LOGGER.warn(\"Failed to observe size for snapshot {}\", persistedSnapshot, e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshots(final long cutoffIndex) {\n+    LOGGER.debug(\n+        \"Search for orphaned snapshots below oldest valid snapshot with index {} in {}\",\n+        cutoffIndex,\n+        pendingDirectory);\n+\n+    try (final var pendingSnapshots = Files.newDirectoryStream(pendingDirectory)) {\n+      for (final var pendingSnapshot : pendingSnapshots) {\n+        purgePendingSnapshot(cutoffIndex, pendingSnapshot);\n+      }\n+    } catch (final IOException e) {\n+      LOGGER.warn(\n+          \"Failed to delete orphaned snapshots, could not list pending directory {}\",\n+          pendingDirectory,\n+          e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshot(final long cutoffIndex, final Path pendingSnapshot) {\n+    final var optionalMetadata = FileBasedSnapshotMetadata.ofPath(pendingSnapshot);\n+    if (optionalMetadata.isPresent() && optionalMetadata.get().getIndex() < cutoffIndex) {\n+      try {\n+        LOGGER.error(\"Deleted orphaned snapshot {}\", pendingSnapshot);\n+        FileUtil.deleteFolder(pendingSnapshot);\n+        LOGGER.debug(\"Deleted orphaned snapshot {}\", pendingSnapshot);\n+      } catch (final IOException e) {\n+        LOGGER.warn(\n+            \"Failed to delete orphaned snapshot {}, risk using unnecessary disk space\",\n+            pendingSnapshot,\n+            e);\n+      }\n+    }\n+  }\n+\n+  public Path getPath() {\n+    return snapshotsDirectory;\n+  }\n+\n+  @Override\n+  public void close() {\n+    listeners.clear();\n+  }\n+\n+  private boolean isCurrentSnapshotNewer(final FileBasedSnapshotMetadata metadata) {\n+    return (currentPersistedSnapshot != null\n+        && currentPersistedSnapshot.getId().compareTo(metadata) >= 0);\n+  }\n+\n+  PersistedSnapshot newSnapshot(final FileBasedSnapshotMetadata metadata, final Path directory) {\n+\n+    if (isCurrentSnapshotNewer(metadata)) {\n+      LOGGER.debug(\"Snapshot is older then {} already exists\", currentPersistedSnapshot);\n+      purgePendingSnapshots(metadata.getIndex() + 1);\n+      return currentPersistedSnapshot;\n+    }\n+\n+    final var destination = buildSnapshotDirectory(metadata);\n+    try {\n+      tryAtomicDirectoryMove(directory, destination);\n+    } catch (final FileAlreadyExistsException e) {\n+      LOGGER.debug(\n+          \"Expected to move snapshot from {} to {}, but it already exists\",\n+          directory,\n+          destination,\n+          e);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+\n+    final var previousSnapshot = currentPersistedSnapshot;\n+\n+    currentPersistedSnapshot = new FileBasedSnapshot(destination, metadata);\n+    snapshotMetrics.incrementSnapshotCount();\n+    observeSnapshotSize(currentPersistedSnapshot);\n+\n+    LOGGER.debug(\"Purging snapshots older than {}\", currentPersistedSnapshot);\n+    if (previousSnapshot != null) {\n+      LOGGER.error(\"Deleting snapshot {}\", previousSnapshot);", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkzMDU5OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433930598", "bodyText": "Why error?", "author": "pihme", "createdAt": "2020-06-02T14:42:15Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import org.slf4j.Logger;\n+\n+public final class FileBasedSnapshotStore implements PersistedSnapshotStore {\n+\n+  private static final Logger LOGGER = new ZbLogger(FileBasedSnapshotStore.class);\n+\n+  // the root snapshotsDirectory where all snapshots should be stored\n+  private final Path snapshotsDirectory;\n+  // the root snapshotsDirectory when pending snapshots should be stored\n+  private final Path pendingDirectory;\n+  // keeps track of all snapshot modification listeners\n+  private final Set<PersistedSnapshotListener> listeners;\n+\n+  private final SnapshotMetrics snapshotMetrics;\n+\n+  private PersistedSnapshot currentPersistedSnapshot;\n+\n+  public FileBasedSnapshotStore(\n+      final SnapshotMetrics snapshotMetrics,\n+      final Path snapshotsDirectory,\n+      final Path pendingDirectory) {\n+    this.snapshotsDirectory = snapshotsDirectory;\n+    this.pendingDirectory = pendingDirectory;\n+    this.snapshotMetrics = snapshotMetrics;\n+\n+    this.listeners = new CopyOnWriteArraySet<>();\n+\n+    // load previous snapshots\n+    currentPersistedSnapshot = loadLatestSnapshot(snapshotsDirectory);\n+  }\n+\n+  private PersistedSnapshot loadLatestSnapshot(final Path snapshotDirectory) {\n+    PersistedSnapshot latestPersistedSnapshot = null;\n+    try (final var stream = Files.newDirectoryStream(snapshotDirectory)) {\n+      for (final var path : stream) {\n+        latestPersistedSnapshot = collectSnapshot(path);\n+      }\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+    return latestPersistedSnapshot;\n+  }\n+\n+  private PersistedSnapshot collectSnapshot(final Path path) {\n+    final var optionalMeta = FileBasedSnapshotMetadata.ofPath(path);\n+    if (optionalMeta.isPresent()) {\n+      final var metadata = optionalMeta.get();\n+      return new FileBasedSnapshot(path, metadata);\n+    } else {\n+      LOGGER.warn(\"Expected snapshot file format to be %d-%d-%d-%d, but was {}\", path);\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean exists(final String id) {\n+    final var optLatestSnapshot = getLatestSnapshot();\n+\n+    if (optLatestSnapshot.isPresent()) {\n+      final var snapshot = optLatestSnapshot.get();\n+      return snapshot.getPath().getFileName().toString().equals(id);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public TransientSnapshot newTransientSnapshot(\n+      final long index, final long term, final WallClockTimestamp timestamp) {\n+    final var directory = buildPendingSnapshotDirectory(index, term, timestamp);\n+    final var fileBasedSnapshotMetadata = new FileBasedSnapshotMetadata(index, term, timestamp);\n+    return new FileBasedTransientSnapshot(fileBasedSnapshotMetadata, directory, this);\n+  }\n+\n+  @Override\n+  public ReceivedSnapshot newReceivedSnapshot(final String snapshotId) {\n+    final var optMetadata = FileBasedSnapshotMetadata.ofFileName(snapshotId);\n+    final var metadata =\n+        optMetadata.orElseThrow(\n+            () ->\n+                new IllegalArgumentException(\n+                    \"Expected snapshot id in a format like 'index-term-timestamp', got '\"\n+                        + snapshotId\n+                        + \"'.\"));\n+\n+    final var pendingSnapshotDir = pendingDirectory.resolve(metadata.getSnapshotIdAsString());\n+    return new FileBasedReceivedSnapshot(metadata, pendingSnapshotDir, this);\n+  }\n+\n+  @Override\n+  public Optional<PersistedSnapshot> getLatestSnapshot() {\n+    return Optional.ofNullable(currentPersistedSnapshot);\n+  }\n+\n+  @Override\n+  public void purgePendingSnapshots() throws IOException {\n+    try (final var files = Files.list(pendingDirectory)) {\n+      files.filter(Files::isDirectory).forEach(this::purgePendingSnapshot);\n+    }\n+  }\n+\n+  @Override\n+  public void addSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.add(listener);\n+  }\n+\n+  @Override\n+  public void removeSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.remove(listener);\n+  }\n+\n+  @Override\n+  public long getCurrentSnapshotIndex() {\n+    return getLatestSnapshot().map(PersistedSnapshot::getIndex).orElse(0L);\n+  }\n+\n+  @Override\n+  public void delete() {\n+    currentPersistedSnapshot = null;\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(snapshotsDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(pendingDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private void observeSnapshotSize(final PersistedSnapshot persistedSnapshot) {\n+    try (final var contents = Files.newDirectoryStream(persistedSnapshot.getPath())) {\n+      var totalSize = 0L;\n+\n+      for (final var path : contents) {\n+        if (Files.isRegularFile(path)) {\n+          final var size = Files.size(path);\n+          snapshotMetrics.observeSnapshotFileSize(size);\n+          totalSize += size;\n+        }\n+      }\n+\n+      snapshotMetrics.observeSnapshotSize(totalSize);\n+    } catch (final IOException e) {\n+      LOGGER.warn(\"Failed to observe size for snapshot {}\", persistedSnapshot, e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshots(final long cutoffIndex) {\n+    LOGGER.debug(\n+        \"Search for orphaned snapshots below oldest valid snapshot with index {} in {}\",\n+        cutoffIndex,\n+        pendingDirectory);\n+\n+    try (final var pendingSnapshots = Files.newDirectoryStream(pendingDirectory)) {\n+      for (final var pendingSnapshot : pendingSnapshots) {\n+        purgePendingSnapshot(cutoffIndex, pendingSnapshot);\n+      }\n+    } catch (final IOException e) {\n+      LOGGER.warn(\n+          \"Failed to delete orphaned snapshots, could not list pending directory {}\",\n+          pendingDirectory,\n+          e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshot(final long cutoffIndex, final Path pendingSnapshot) {\n+    final var optionalMetadata = FileBasedSnapshotMetadata.ofPath(pendingSnapshot);\n+    if (optionalMetadata.isPresent() && optionalMetadata.get().getIndex() < cutoffIndex) {\n+      try {\n+        LOGGER.error(\"Deleted orphaned snapshot {}\", pendingSnapshot);\n+        FileUtil.deleteFolder(pendingSnapshot);\n+        LOGGER.debug(\"Deleted orphaned snapshot {}\", pendingSnapshot);\n+      } catch (final IOException e) {\n+        LOGGER.warn(\n+            \"Failed to delete orphaned snapshot {}, risk using unnecessary disk space\",\n+            pendingSnapshot,\n+            e);\n+      }\n+    }\n+  }\n+\n+  public Path getPath() {\n+    return snapshotsDirectory;\n+  }\n+\n+  @Override\n+  public void close() {\n+    listeners.clear();\n+  }\n+\n+  private boolean isCurrentSnapshotNewer(final FileBasedSnapshotMetadata metadata) {\n+    return (currentPersistedSnapshot != null\n+        && currentPersistedSnapshot.getId().compareTo(metadata) >= 0);\n+  }\n+\n+  PersistedSnapshot newSnapshot(final FileBasedSnapshotMetadata metadata, final Path directory) {\n+\n+    if (isCurrentSnapshotNewer(metadata)) {\n+      LOGGER.debug(\"Snapshot is older then {} already exists\", currentPersistedSnapshot);\n+      purgePendingSnapshots(metadata.getIndex() + 1);\n+      return currentPersistedSnapshot;\n+    }\n+\n+    final var destination = buildSnapshotDirectory(metadata);\n+    try {\n+      tryAtomicDirectoryMove(directory, destination);\n+    } catch (final FileAlreadyExistsException e) {\n+      LOGGER.debug(\n+          \"Expected to move snapshot from {} to {}, but it already exists\",\n+          directory,\n+          destination,\n+          e);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+\n+    final var previousSnapshot = currentPersistedSnapshot;\n+\n+    currentPersistedSnapshot = new FileBasedSnapshot(destination, metadata);\n+    snapshotMetrics.incrementSnapshotCount();\n+    observeSnapshotSize(currentPersistedSnapshot);\n+\n+    LOGGER.debug(\"Purging snapshots older than {}\", currentPersistedSnapshot);\n+    if (previousSnapshot != null) {\n+      LOGGER.error(\"Deleting snapshot {}\", previousSnapshot);\n+      previousSnapshot.delete();\n+    }\n+    purgePendingSnapshots(currentPersistedSnapshot.getIndex());\n+\n+    listeners.forEach(listener -> listener.onNewSnapshot(currentPersistedSnapshot));\n+\n+    LOGGER.debug(\"Created new snapshot {}\", currentPersistedSnapshot);\n+    return currentPersistedSnapshot;\n+  }\n+\n+  private void purgePendingSnapshot(final Path pendingSnapshot) {\n+    try {\n+      FileUtil.deleteFolder(pendingSnapshot);\n+      LOGGER.error(\"Delete not completed (orphaned) snapshot {}\", pendingSnapshot);", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkzMDk2MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433930960", "bodyText": "Why error?", "author": "pihme", "createdAt": "2020-06-02T14:42:42Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import org.slf4j.Logger;\n+\n+public final class FileBasedSnapshotStore implements PersistedSnapshotStore {\n+\n+  private static final Logger LOGGER = new ZbLogger(FileBasedSnapshotStore.class);\n+\n+  // the root snapshotsDirectory where all snapshots should be stored\n+  private final Path snapshotsDirectory;\n+  // the root snapshotsDirectory when pending snapshots should be stored\n+  private final Path pendingDirectory;\n+  // keeps track of all snapshot modification listeners\n+  private final Set<PersistedSnapshotListener> listeners;\n+\n+  private final SnapshotMetrics snapshotMetrics;\n+\n+  private PersistedSnapshot currentPersistedSnapshot;\n+\n+  public FileBasedSnapshotStore(\n+      final SnapshotMetrics snapshotMetrics,\n+      final Path snapshotsDirectory,\n+      final Path pendingDirectory) {\n+    this.snapshotsDirectory = snapshotsDirectory;\n+    this.pendingDirectory = pendingDirectory;\n+    this.snapshotMetrics = snapshotMetrics;\n+\n+    this.listeners = new CopyOnWriteArraySet<>();\n+\n+    // load previous snapshots\n+    currentPersistedSnapshot = loadLatestSnapshot(snapshotsDirectory);\n+  }\n+\n+  private PersistedSnapshot loadLatestSnapshot(final Path snapshotDirectory) {\n+    PersistedSnapshot latestPersistedSnapshot = null;\n+    try (final var stream = Files.newDirectoryStream(snapshotDirectory)) {\n+      for (final var path : stream) {\n+        latestPersistedSnapshot = collectSnapshot(path);\n+      }\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+    return latestPersistedSnapshot;\n+  }\n+\n+  private PersistedSnapshot collectSnapshot(final Path path) {\n+    final var optionalMeta = FileBasedSnapshotMetadata.ofPath(path);\n+    if (optionalMeta.isPresent()) {\n+      final var metadata = optionalMeta.get();\n+      return new FileBasedSnapshot(path, metadata);\n+    } else {\n+      LOGGER.warn(\"Expected snapshot file format to be %d-%d-%d-%d, but was {}\", path);\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean exists(final String id) {\n+    final var optLatestSnapshot = getLatestSnapshot();\n+\n+    if (optLatestSnapshot.isPresent()) {\n+      final var snapshot = optLatestSnapshot.get();\n+      return snapshot.getPath().getFileName().toString().equals(id);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public TransientSnapshot newTransientSnapshot(\n+      final long index, final long term, final WallClockTimestamp timestamp) {\n+    final var directory = buildPendingSnapshotDirectory(index, term, timestamp);\n+    final var fileBasedSnapshotMetadata = new FileBasedSnapshotMetadata(index, term, timestamp);\n+    return new FileBasedTransientSnapshot(fileBasedSnapshotMetadata, directory, this);\n+  }\n+\n+  @Override\n+  public ReceivedSnapshot newReceivedSnapshot(final String snapshotId) {\n+    final var optMetadata = FileBasedSnapshotMetadata.ofFileName(snapshotId);\n+    final var metadata =\n+        optMetadata.orElseThrow(\n+            () ->\n+                new IllegalArgumentException(\n+                    \"Expected snapshot id in a format like 'index-term-timestamp', got '\"\n+                        + snapshotId\n+                        + \"'.\"));\n+\n+    final var pendingSnapshotDir = pendingDirectory.resolve(metadata.getSnapshotIdAsString());\n+    return new FileBasedReceivedSnapshot(metadata, pendingSnapshotDir, this);\n+  }\n+\n+  @Override\n+  public Optional<PersistedSnapshot> getLatestSnapshot() {\n+    return Optional.ofNullable(currentPersistedSnapshot);\n+  }\n+\n+  @Override\n+  public void purgePendingSnapshots() throws IOException {\n+    try (final var files = Files.list(pendingDirectory)) {\n+      files.filter(Files::isDirectory).forEach(this::purgePendingSnapshot);\n+    }\n+  }\n+\n+  @Override\n+  public void addSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.add(listener);\n+  }\n+\n+  @Override\n+  public void removeSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.remove(listener);\n+  }\n+\n+  @Override\n+  public long getCurrentSnapshotIndex() {\n+    return getLatestSnapshot().map(PersistedSnapshot::getIndex).orElse(0L);\n+  }\n+\n+  @Override\n+  public void delete() {\n+    currentPersistedSnapshot = null;\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkzMTA2MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433931060", "bodyText": "Why error?", "author": "pihme", "createdAt": "2020-06-02T14:42:51Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import org.slf4j.Logger;\n+\n+public final class FileBasedSnapshotStore implements PersistedSnapshotStore {\n+\n+  private static final Logger LOGGER = new ZbLogger(FileBasedSnapshotStore.class);\n+\n+  // the root snapshotsDirectory where all snapshots should be stored\n+  private final Path snapshotsDirectory;\n+  // the root snapshotsDirectory when pending snapshots should be stored\n+  private final Path pendingDirectory;\n+  // keeps track of all snapshot modification listeners\n+  private final Set<PersistedSnapshotListener> listeners;\n+\n+  private final SnapshotMetrics snapshotMetrics;\n+\n+  private PersistedSnapshot currentPersistedSnapshot;\n+\n+  public FileBasedSnapshotStore(\n+      final SnapshotMetrics snapshotMetrics,\n+      final Path snapshotsDirectory,\n+      final Path pendingDirectory) {\n+    this.snapshotsDirectory = snapshotsDirectory;\n+    this.pendingDirectory = pendingDirectory;\n+    this.snapshotMetrics = snapshotMetrics;\n+\n+    this.listeners = new CopyOnWriteArraySet<>();\n+\n+    // load previous snapshots\n+    currentPersistedSnapshot = loadLatestSnapshot(snapshotsDirectory);\n+  }\n+\n+  private PersistedSnapshot loadLatestSnapshot(final Path snapshotDirectory) {\n+    PersistedSnapshot latestPersistedSnapshot = null;\n+    try (final var stream = Files.newDirectoryStream(snapshotDirectory)) {\n+      for (final var path : stream) {\n+        latestPersistedSnapshot = collectSnapshot(path);\n+      }\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+    return latestPersistedSnapshot;\n+  }\n+\n+  private PersistedSnapshot collectSnapshot(final Path path) {\n+    final var optionalMeta = FileBasedSnapshotMetadata.ofPath(path);\n+    if (optionalMeta.isPresent()) {\n+      final var metadata = optionalMeta.get();\n+      return new FileBasedSnapshot(path, metadata);\n+    } else {\n+      LOGGER.warn(\"Expected snapshot file format to be %d-%d-%d-%d, but was {}\", path);\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean exists(final String id) {\n+    final var optLatestSnapshot = getLatestSnapshot();\n+\n+    if (optLatestSnapshot.isPresent()) {\n+      final var snapshot = optLatestSnapshot.get();\n+      return snapshot.getPath().getFileName().toString().equals(id);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public TransientSnapshot newTransientSnapshot(\n+      final long index, final long term, final WallClockTimestamp timestamp) {\n+    final var directory = buildPendingSnapshotDirectory(index, term, timestamp);\n+    final var fileBasedSnapshotMetadata = new FileBasedSnapshotMetadata(index, term, timestamp);\n+    return new FileBasedTransientSnapshot(fileBasedSnapshotMetadata, directory, this);\n+  }\n+\n+  @Override\n+  public ReceivedSnapshot newReceivedSnapshot(final String snapshotId) {\n+    final var optMetadata = FileBasedSnapshotMetadata.ofFileName(snapshotId);\n+    final var metadata =\n+        optMetadata.orElseThrow(\n+            () ->\n+                new IllegalArgumentException(\n+                    \"Expected snapshot id in a format like 'index-term-timestamp', got '\"\n+                        + snapshotId\n+                        + \"'.\"));\n+\n+    final var pendingSnapshotDir = pendingDirectory.resolve(metadata.getSnapshotIdAsString());\n+    return new FileBasedReceivedSnapshot(metadata, pendingSnapshotDir, this);\n+  }\n+\n+  @Override\n+  public Optional<PersistedSnapshot> getLatestSnapshot() {\n+    return Optional.ofNullable(currentPersistedSnapshot);\n+  }\n+\n+  @Override\n+  public void purgePendingSnapshots() throws IOException {\n+    try (final var files = Files.list(pendingDirectory)) {\n+      files.filter(Files::isDirectory).forEach(this::purgePendingSnapshot);\n+    }\n+  }\n+\n+  @Override\n+  public void addSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.add(listener);\n+  }\n+\n+  @Override\n+  public void removeSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.remove(listener);\n+  }\n+\n+  @Override\n+  public long getCurrentSnapshotIndex() {\n+    return getLatestSnapshot().map(PersistedSnapshot::getIndex).orElse(0L);\n+  }\n+\n+  @Override\n+  public void delete() {\n+    currentPersistedSnapshot = null;\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(snapshotsDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkzNDAzOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433934038", "bodyText": "That is a strange use of predicate. Maybe better use Function<Path, Boolean>", "author": "pihme", "createdAt": "2020-06-02T14:46:44Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedTransientSnapshot.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+import org.slf4j.Logger;\n+\n+/**\n+ * Represents a pending snapshot, that is a snapshot in the process of being written and has not yet\n+ * been committed to the store.\n+ */\n+public final class FileBasedTransientSnapshot implements TransientSnapshot {\n+  private static final Logger LOGGER = new ZbLogger(FileBasedTransientSnapshot.class);\n+\n+  private final Path directory;\n+  private final FileBasedSnapshotStore snapshotStore;\n+  private final FileBasedSnapshotMetadata metadata;\n+\n+  FileBasedTransientSnapshot(\n+      final FileBasedSnapshotMetadata metadata,\n+      final Path directory,\n+      final FileBasedSnapshotStore snapshotStore) {\n+    this.metadata = metadata;\n+    this.snapshotStore = snapshotStore;\n+    this.directory = directory;\n+  }\n+\n+  @Override\n+  public boolean take(final Predicate<Path> takeSnapshot) {", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NzA0NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435697045", "bodyText": "This is actually what a predicate is takes one thing and returns an boolean  \ud83d\ude05 But I get what you mean that is usually used to test a value. If I change it to function then sonar tells me to use a Predicate, so probably I would need then to create an own function interface.", "author": "Zelldon", "createdAt": "2020-06-05T05:26:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkzNDAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkzOTc1Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433939756", "bodyText": "Optional: Not sure if you made changes here. Personally I am not a fan of using lambdas this way. It makes debugging more complicated. Instead I like the auto closeable style:\ntry (Timer timer = snapshotMetrics. createTimer()) { // SNAPSHOT_DURATION.labels(partitionId).startTimer()\n  // your code goes here\n}", "author": "pihme", "createdAt": "2020-06-02T14:54:38Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedTransientSnapshot.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+import org.slf4j.Logger;\n+\n+/**\n+ * Represents a pending snapshot, that is a snapshot in the process of being written and has not yet\n+ * been committed to the store.\n+ */\n+public final class FileBasedTransientSnapshot implements TransientSnapshot {\n+  private static final Logger LOGGER = new ZbLogger(FileBasedTransientSnapshot.class);\n+\n+  private final Path directory;\n+  private final FileBasedSnapshotStore snapshotStore;\n+  private final FileBasedSnapshotMetadata metadata;\n+\n+  FileBasedTransientSnapshot(\n+      final FileBasedSnapshotMetadata metadata,\n+      final Path directory,\n+      final FileBasedSnapshotStore snapshotStore) {\n+    this.metadata = metadata;\n+    this.snapshotStore = snapshotStore;\n+    this.directory = directory;\n+  }\n+\n+  @Override\n+  public boolean take(final Predicate<Path> takeSnapshot) {\n+    final var snapshotMetrics = snapshotStore.getSnapshotMetrics();\n+\n+    return snapshotMetrics.observeSnapshotOperation(", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5ODA0OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435698049", "bodyText": "I changed it. I like it thanks", "author": "Zelldon", "createdAt": "2020-06-05T05:31:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkzOTc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk0MTI4Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433941286", "bodyText": "This could be simplified with return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE)", "author": "pihme", "createdAt": "2020-06-02T14:56:28Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedTransientSnapshot.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+import org.slf4j.Logger;\n+\n+/**\n+ * Represents a pending snapshot, that is a snapshot in the process of being written and has not yet\n+ * been committed to the store.\n+ */\n+public final class FileBasedTransientSnapshot implements TransientSnapshot {\n+  private static final Logger LOGGER = new ZbLogger(FileBasedTransientSnapshot.class);\n+\n+  private final Path directory;\n+  private final FileBasedSnapshotStore snapshotStore;\n+  private final FileBasedSnapshotMetadata metadata;\n+\n+  FileBasedTransientSnapshot(\n+      final FileBasedSnapshotMetadata metadata,\n+      final Path directory,\n+      final FileBasedSnapshotStore snapshotStore) {\n+    this.metadata = metadata;\n+    this.snapshotStore = snapshotStore;\n+    this.directory = directory;\n+  }\n+\n+  @Override\n+  public boolean take(final Predicate<Path> takeSnapshot) {\n+    final var snapshotMetrics = snapshotStore.getSnapshotMetrics();\n+\n+    return snapshotMetrics.observeSnapshotOperation(\n+        () -> {\n+          boolean failed;\n+\n+          try {\n+            failed = !takeSnapshot.test(getPath());\n+          } catch (final Exception exception) {\n+            LOGGER.warn(\n+                \"Catched unexpected exception on taking snapshot ({})\", metadata, exception);\n+            failed = true;\n+          }\n+\n+          if (failed) {\n+            abort();\n+          }\n+\n+          return !failed;\n+        });\n+  }\n+\n+  @Override\n+  public PersistedSnapshot persist() {\n+    return snapshotStore.newSnapshot(metadata, directory);\n+  }\n+\n+  @Override\n+  public void abort() {\n+    try {\n+      LOGGER.error(\"DELETE dir {}\", directory);\n+      FileUtil.deleteFolder(directory);\n+    } catch (final IOException e) {\n+      LOGGER.warn(\"Failed to delete pending snapshot {}\", this, e);\n+    }\n+  }\n+\n+  public Path getPath() {\n+    return directory;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"FileBasedTransientSnapshot{\"", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NTY0Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435695643", "bodyText": "this is intellij generated", "author": "Zelldon", "createdAt": "2020-06-05T05:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk0MTI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk0NDc2NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433944765", "bodyText": "That doesn't feel right. Don't we have a logger somewhere?", "author": "pihme", "createdAt": "2020-06-02T15:01:05Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -280,43 +282,50 @@ public void doSnapshot(final long index) throws Exception {\n   public boolean allNodesHaveSnapshotWithIndex(final long index) {\n     return servers.values().stream()\n             .map(RaftServer::getContext)\n-            .map(RaftContext::getSnapshotStore)\n-            .map(SnapshotStore::getCurrentSnapshotIndex)\n+            .map(RaftContext::getPersistedSnapshotStore)\n+            .map(PersistedSnapshotStore::getCurrentSnapshotIndex)\n             .filter(idx -> idx == index)\n             .count()\n         == servers.values().size();\n   }\n \n-  public Snapshot getSnapshotFromLeader() {\n+  public PersistedSnapshot getSnapshotFromLeader() {\n     final var leader = getLeader().orElseThrow();\n     final var context = leader.getContext();\n-    final var snapshotStore = context.getSnapshotStore();\n-    return snapshotStore.getCurrentSnapshot();\n+    final var snapshotStore = context.getPersistedSnapshotStore();\n+    return snapshotStore.getLatestSnapshot().orElseThrow();\n   }\n \n-  public Snapshot getSnapshotOnNode(final String nodeId) {\n+  public PersistedSnapshot getSnapshotOnNode(final String nodeId) {\n     final var raftServer = servers.get(nodeId);\n     final var context = raftServer.getContext();\n-    final var snapshotStore = context.getSnapshotStore();\n-    return snapshotStore.getCurrentSnapshot();\n-  }\n-\n-  private void writeSnapshot(final long index, final long term, final SnapshotStore snapshotStore)\n-      throws IOException {\n-    final var dirName = index + \"-snapshot\";\n-    final var snapshotDir = new File(snapshotStore.getPath().toFile(), dirName);\n-    if (!snapshotDir.mkdirs()) {\n-      throw new IllegalStateException(\"Was not able to create directory: \" + snapshotDir.getName());\n-    }\n-\n-    final var snapshotFile = new File(snapshotDir, \"snapshot.file\");\n-    Files.write(\n-        snapshotFile.toPath(),\n-        RandomStringUtils.random(128).getBytes(),\n-        StandardOpenOption.CREATE_NEW,\n-        StandardOpenOption.WRITE);\n-\n-    snapshotStore.newSnapshot(index, term, new WallClockTimestamp(), snapshotDir.toPath());\n+    final var snapshotStore = context.getPersistedSnapshotStore();\n+    return snapshotStore.getLatestSnapshot().orElseThrow();\n+  }\n+\n+  private void writeSnapshot(\n+      final long index, final long term, final PersistedSnapshotStore persistedSnapshotStore) {\n+\n+    final var transientSnapshot =\n+        persistedSnapshotStore.newTransientSnapshot(index, term, new WallClockTimestamp());\n+    transientSnapshot.take(\n+        path -> {\n+          IoUtil.ensureDirectoryExists(path.toFile(), \"snapshot dir should exist\");\n+          final var snapshotFile = path.resolve(\"snapshot.file\");\n+          try {\n+            Files.write(\n+                snapshotFile,\n+                RandomStringUtils.random(128).getBytes(),\n+                StandardOpenOption.CREATE_NEW,\n+                StandardOpenOption.WRITE);\n+          } catch (final IOException e) {\n+            e.printStackTrace();", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5ODQ0Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435698446", "bodyText": "Be aware that this is in a test", "author": "Zelldon", "createdAt": "2020-06-05T05:32:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk0NDc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk2NTk4MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433965980", "bodyText": "Single threaded or need for synchronization?", "author": "pihme", "createdAt": "2020-06-02T15:30:19Z", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/StateControllerImpl.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.system.partitions.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.SnapshotChunk;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.broker.system.partitions.AtomixRecordEntrySupplier;\n+import io.zeebe.broker.system.partitions.SnapshotReplication;\n+import io.zeebe.broker.system.partitions.StateController;\n+import io.zeebe.db.ZeebeDb;\n+import io.zeebe.db.ZeebeDbFactory;\n+import io.zeebe.logstreams.impl.Loggers;\n+import io.zeebe.util.FileUtil;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.ToLongFunction;\n+import org.agrona.collections.Object2NullableObjectHashMap;\n+import org.slf4j.Logger;\n+\n+/** Controls how snapshot/recovery operations are performed */\n+public class StateControllerImpl implements StateController, PersistedSnapshotListener {\n+\n+  private static final ReplicationContext INVALID_SNAPSHOT = new ReplicationContext(-1, null);\n+  private static final Logger LOG = Loggers.SNAPSHOT_LOGGER;\n+\n+  private final SnapshotReplication replication;\n+  private final Map<String, ReplicationContext> receivedSnapshots =", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3MTE2Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433971163", "bodyText": "It looks like there might be a memory leak here.\n\nentries which are marked as INVALID_SNAPSHOT will never be evicted from the map\nentries which never receive the last chunk will never be evicted from the map.\n\nI think it would make sense to evict entries more aggressively, either by looking at the start time of the replication context or by looking at the index of the snapshot and removing all entries of snapshots which are older than the last successfully replicated snapshot.", "author": "pihme", "createdAt": "2020-06-02T15:37:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk2NTk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwMjAxNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435702015", "bodyText": "Ok lets do an follow up on this since this was also the case before the refactoring. I created an issue for it #4671", "author": "Zelldon", "createdAt": "2020-06-05T05:46:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk2NTk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3NjcyNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433976724", "bodyText": "Optional: There is an implicit assumption here, that all chunks return the same total count. This might not be the case if an attacker / non compliant broker modifies a snapshot chunk. You could capture the total count of the first chunk and then compare it on each subsequent chunk as an additional sanity check.", "author": "pihme", "createdAt": "2020-06-02T15:44:16Z", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/StateControllerImpl.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.system.partitions.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.SnapshotChunk;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.broker.system.partitions.AtomixRecordEntrySupplier;\n+import io.zeebe.broker.system.partitions.SnapshotReplication;\n+import io.zeebe.broker.system.partitions.StateController;\n+import io.zeebe.db.ZeebeDb;\n+import io.zeebe.db.ZeebeDbFactory;\n+import io.zeebe.logstreams.impl.Loggers;\n+import io.zeebe.util.FileUtil;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.ToLongFunction;\n+import org.agrona.collections.Object2NullableObjectHashMap;\n+import org.slf4j.Logger;\n+\n+/** Controls how snapshot/recovery operations are performed */\n+public class StateControllerImpl implements StateController, PersistedSnapshotListener {\n+\n+  private static final ReplicationContext INVALID_SNAPSHOT = new ReplicationContext(-1, null);\n+  private static final Logger LOG = Loggers.SNAPSHOT_LOGGER;\n+\n+  private final SnapshotReplication replication;\n+  private final Map<String, ReplicationContext> receivedSnapshots =\n+      new Object2NullableObjectHashMap<>();\n+\n+  private final PersistedSnapshotStore store;\n+\n+  private final Path runtimeDirectory;\n+  private final ZeebeDbFactory zeebeDbFactory;\n+  private final ToLongFunction<ZeebeDb> exporterPositionSupplier;\n+  private final AtomixRecordEntrySupplier entrySupplier;\n+\n+  private final SnapshotReplicationMetrics metrics;\n+\n+  private ZeebeDb db;\n+\n+  public StateControllerImpl(\n+      final int partitionId,\n+      final ZeebeDbFactory zeebeDbFactory,\n+      final PersistedSnapshotStore store,\n+      final Path runtimeDirectory,\n+      final SnapshotReplication replication,\n+      final AtomixRecordEntrySupplier entrySupplier,\n+      final ToLongFunction<ZeebeDb> exporterPositionSupplier) {\n+    this.store = store;\n+    this.runtimeDirectory = runtimeDirectory;\n+    this.zeebeDbFactory = zeebeDbFactory;\n+    this.exporterPositionSupplier = exporterPositionSupplier;\n+    this.entrySupplier = entrySupplier;\n+    this.replication = replication;\n+    this.metrics = new SnapshotReplicationMetrics(Integer.toString(partitionId));\n+    store.addSnapshotListener(this);\n+  }\n+\n+  @Override\n+  public Optional<TransientSnapshot> takeTransientSnapshot(final long lowerBoundSnapshotPosition) {\n+    if (!isDbOpened()) {\n+      return Optional.empty();\n+    }\n+\n+    final long exportedPosition = exporterPositionSupplier.applyAsLong(openDb());\n+    final long snapshotPosition = Math.min(exportedPosition, lowerBoundSnapshotPosition);\n+\n+    final var optionalIndexed = entrySupplier.getIndexedEntry(snapshotPosition);\n+\n+    final Long previousSnapshotIndex =\n+        store.getLatestSnapshot().map(PersistedSnapshot::getCompactionBound).orElse(-1L);\n+\n+    final var optTransientSnapshot =\n+        optionalIndexed\n+            .filter(indexed -> indexed.index() != previousSnapshotIndex)\n+            .map(\n+                indexed ->\n+                    store.newTransientSnapshot(\n+                        indexed.index(),\n+                        indexed.entry().term(),\n+                        WallClockTimestamp.from(System.currentTimeMillis())));\n+\n+    optTransientSnapshot.ifPresent(this::createSnapshot);\n+    return optTransientSnapshot;\n+  }\n+\n+  @Override\n+  public void consumeReplicatedSnapshots() {\n+    replication.consume(this::consumeSnapshotChunk);\n+  }\n+\n+  @Override\n+  public void recover() throws Exception {\n+\n+    if (Files.exists(runtimeDirectory)) {\n+      FileUtil.deleteFolder(runtimeDirectory);\n+    }\n+\n+    final var optLatestSnapshot = store.getLatestSnapshot();\n+    if (optLatestSnapshot.isPresent()) {\n+      final var snapshot = optLatestSnapshot.get();\n+      LOG.debug(\"Available snapshot: {}\", snapshot);\n+\n+      FileUtil.copySnapshot(runtimeDirectory, snapshot.getPath());\n+\n+      try {\n+        // open database to verify that the snapshot is recoverable\n+        openDb();\n+        LOG.debug(\"Recovered state from snapshot '{}'\", snapshot);\n+      } catch (final Exception exception) {\n+        LOG.error(\n+            \"Failed to open snapshot '{}'. No snapshots available to recover from. Manual action is required.\",\n+            snapshot,\n+            exception);\n+\n+        FileUtil.deleteFolder(runtimeDirectory);\n+        throw new IllegalStateException(\"Failed to recover from snapshots\", exception);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public ZeebeDb openDb() {\n+    if (db == null) {\n+      db = zeebeDbFactory.createDb(runtimeDirectory.toFile());\n+      LOG.debug(\"Opened database from '{}'.\", runtimeDirectory);\n+    }\n+\n+    return db;\n+  }\n+\n+  @Override\n+  public int getValidSnapshotsCount() {\n+    return store.getLatestSnapshot().isPresent() ? 1 : 0;\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    if (db != null) {\n+      db.close();\n+      LOG.debug(\"Closed database from '{}'.\", runtimeDirectory);\n+      db = null;\n+    }\n+  }\n+\n+  boolean isDbOpened() {\n+    return db != null;\n+  }\n+\n+  private void createSnapshot(final TransientSnapshot snapshot) {\n+    snapshot.take(\n+        snapshotDir -> {\n+          if (db == null) {\n+            LOG.error(\"Expected to take a snapshot, but no database was opened\");\n+            return false;\n+          }\n+\n+          LOG.debug(\"Taking temporary snapshot into {}.\", snapshotDir);\n+          try {\n+            db.createSnapshot(snapshotDir.toFile());\n+          } catch (final Exception e) {\n+            LOG.error(\"Failed to create snapshot of runtime database\", e);\n+            return false;\n+          }\n+\n+          return true;\n+        });\n+  }\n+\n+  @Override\n+  public void onNewSnapshot(final PersistedSnapshot newPersistedSnapshot) {\n+    // replicate snapshots when new snapshot was committed\n+    try (final var snapshotChunkReader = newPersistedSnapshot.newChunkReader()) {\n+      while (snapshotChunkReader.hasNext()) {\n+        final var snapshotChunk = snapshotChunkReader.next();\n+        replication.replicate(snapshotChunk);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This is called by the snapshot replication implementation on each snapshot chunk\n+   *\n+   * @param snapshotChunk the chunk to consume\n+   */\n+  private void consumeSnapshotChunk(final SnapshotChunk snapshotChunk) {\n+    final String snapshotId = snapshotChunk.getSnapshotId();\n+    final String chunkName = snapshotChunk.getChunkName();\n+\n+    final ReplicationContext context =\n+        receivedSnapshots.computeIfAbsent(\n+            snapshotId,\n+            id -> {\n+              final var startTimestamp = System.currentTimeMillis();\n+              final ReceivedSnapshot transientSnapshot =\n+                  store.newReceivedSnapshot(snapshotChunk.getSnapshotId());\n+              return newReplication(startTimestamp, transientSnapshot);\n+            });\n+    if (context == INVALID_SNAPSHOT) {\n+      LOG.trace(\n+          \"Ignore snapshot chunk {}, because snapshot {} is marked as invalid.\",\n+          chunkName,\n+          snapshotId);\n+      return;\n+    }\n+\n+    final var receivedSnapshot = context.getReceivedSnapshot();\n+    try {\n+      if (receivedSnapshot.apply(snapshotChunk)) {\n+        validateWhenReceivedAllChunks(snapshotChunk, context);\n+      } else {\n+        markSnapshotAsInvalid(context, snapshotChunk);\n+      }\n+    } catch (final IOException e) {\n+      LOG.error(\"Unexepected error on writing the received snapshot chunk {}\", snapshotChunk, e);\n+      markSnapshotAsInvalid(context, snapshotChunk);\n+    }\n+  }\n+\n+  private void markSnapshotAsInvalid(\n+      final ReplicationContext replicationContext, final SnapshotChunk chunk) {\n+    replicationContext.getReceivedSnapshot().abort();\n+    receivedSnapshots.put(chunk.getSnapshotId(), INVALID_SNAPSHOT);\n+    metrics.decrementCount();\n+  }\n+\n+  private void validateWhenReceivedAllChunks(\n+      final SnapshotChunk snapshotChunk, final ReplicationContext context) {\n+    final int totalChunkCount = snapshotChunk.getTotalCount();\n+\n+    if (context.incrementCount() == totalChunkCount) {", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwMjMzNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435702337", "bodyText": "Ok so like we do with the snapshot checksum", "author": "Zelldon", "createdAt": "2020-06-05T05:47:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3NjcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk4NDY3NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433984675", "bodyText": "In case of an exception, the decrement already happened as part of markSnapshotAsInvalid(...) In general I am not sure whether the increments and decrements in this class will always balance out perfectly. Maybe they do now, but it is fragile.\nI think it would be better to add a destroy()/deactivate() method to the ReplicationContext which counts the metric down when it is first called, and does nothing when it is called multiple times.", "author": "pihme", "createdAt": "2020-06-02T15:52:10Z", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/StateControllerImpl.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.system.partitions.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.SnapshotChunk;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.broker.system.partitions.AtomixRecordEntrySupplier;\n+import io.zeebe.broker.system.partitions.SnapshotReplication;\n+import io.zeebe.broker.system.partitions.StateController;\n+import io.zeebe.db.ZeebeDb;\n+import io.zeebe.db.ZeebeDbFactory;\n+import io.zeebe.logstreams.impl.Loggers;\n+import io.zeebe.util.FileUtil;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.ToLongFunction;\n+import org.agrona.collections.Object2NullableObjectHashMap;\n+import org.slf4j.Logger;\n+\n+/** Controls how snapshot/recovery operations are performed */\n+public class StateControllerImpl implements StateController, PersistedSnapshotListener {\n+\n+  private static final ReplicationContext INVALID_SNAPSHOT = new ReplicationContext(-1, null);\n+  private static final Logger LOG = Loggers.SNAPSHOT_LOGGER;\n+\n+  private final SnapshotReplication replication;\n+  private final Map<String, ReplicationContext> receivedSnapshots =\n+      new Object2NullableObjectHashMap<>();\n+\n+  private final PersistedSnapshotStore store;\n+\n+  private final Path runtimeDirectory;\n+  private final ZeebeDbFactory zeebeDbFactory;\n+  private final ToLongFunction<ZeebeDb> exporterPositionSupplier;\n+  private final AtomixRecordEntrySupplier entrySupplier;\n+\n+  private final SnapshotReplicationMetrics metrics;\n+\n+  private ZeebeDb db;\n+\n+  public StateControllerImpl(\n+      final int partitionId,\n+      final ZeebeDbFactory zeebeDbFactory,\n+      final PersistedSnapshotStore store,\n+      final Path runtimeDirectory,\n+      final SnapshotReplication replication,\n+      final AtomixRecordEntrySupplier entrySupplier,\n+      final ToLongFunction<ZeebeDb> exporterPositionSupplier) {\n+    this.store = store;\n+    this.runtimeDirectory = runtimeDirectory;\n+    this.zeebeDbFactory = zeebeDbFactory;\n+    this.exporterPositionSupplier = exporterPositionSupplier;\n+    this.entrySupplier = entrySupplier;\n+    this.replication = replication;\n+    this.metrics = new SnapshotReplicationMetrics(Integer.toString(partitionId));\n+    store.addSnapshotListener(this);\n+  }\n+\n+  @Override\n+  public Optional<TransientSnapshot> takeTransientSnapshot(final long lowerBoundSnapshotPosition) {\n+    if (!isDbOpened()) {\n+      return Optional.empty();\n+    }\n+\n+    final long exportedPosition = exporterPositionSupplier.applyAsLong(openDb());\n+    final long snapshotPosition = Math.min(exportedPosition, lowerBoundSnapshotPosition);\n+\n+    final var optionalIndexed = entrySupplier.getIndexedEntry(snapshotPosition);\n+\n+    final Long previousSnapshotIndex =\n+        store.getLatestSnapshot().map(PersistedSnapshot::getCompactionBound).orElse(-1L);\n+\n+    final var optTransientSnapshot =\n+        optionalIndexed\n+            .filter(indexed -> indexed.index() != previousSnapshotIndex)\n+            .map(\n+                indexed ->\n+                    store.newTransientSnapshot(\n+                        indexed.index(),\n+                        indexed.entry().term(),\n+                        WallClockTimestamp.from(System.currentTimeMillis())));\n+\n+    optTransientSnapshot.ifPresent(this::createSnapshot);\n+    return optTransientSnapshot;\n+  }\n+\n+  @Override\n+  public void consumeReplicatedSnapshots() {\n+    replication.consume(this::consumeSnapshotChunk);\n+  }\n+\n+  @Override\n+  public void recover() throws Exception {\n+\n+    if (Files.exists(runtimeDirectory)) {\n+      FileUtil.deleteFolder(runtimeDirectory);\n+    }\n+\n+    final var optLatestSnapshot = store.getLatestSnapshot();\n+    if (optLatestSnapshot.isPresent()) {\n+      final var snapshot = optLatestSnapshot.get();\n+      LOG.debug(\"Available snapshot: {}\", snapshot);\n+\n+      FileUtil.copySnapshot(runtimeDirectory, snapshot.getPath());\n+\n+      try {\n+        // open database to verify that the snapshot is recoverable\n+        openDb();\n+        LOG.debug(\"Recovered state from snapshot '{}'\", snapshot);\n+      } catch (final Exception exception) {\n+        LOG.error(\n+            \"Failed to open snapshot '{}'. No snapshots available to recover from. Manual action is required.\",\n+            snapshot,\n+            exception);\n+\n+        FileUtil.deleteFolder(runtimeDirectory);\n+        throw new IllegalStateException(\"Failed to recover from snapshots\", exception);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public ZeebeDb openDb() {\n+    if (db == null) {\n+      db = zeebeDbFactory.createDb(runtimeDirectory.toFile());\n+      LOG.debug(\"Opened database from '{}'.\", runtimeDirectory);\n+    }\n+\n+    return db;\n+  }\n+\n+  @Override\n+  public int getValidSnapshotsCount() {\n+    return store.getLatestSnapshot().isPresent() ? 1 : 0;\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    if (db != null) {\n+      db.close();\n+      LOG.debug(\"Closed database from '{}'.\", runtimeDirectory);\n+      db = null;\n+    }\n+  }\n+\n+  boolean isDbOpened() {\n+    return db != null;\n+  }\n+\n+  private void createSnapshot(final TransientSnapshot snapshot) {\n+    snapshot.take(\n+        snapshotDir -> {\n+          if (db == null) {\n+            LOG.error(\"Expected to take a snapshot, but no database was opened\");\n+            return false;\n+          }\n+\n+          LOG.debug(\"Taking temporary snapshot into {}.\", snapshotDir);\n+          try {\n+            db.createSnapshot(snapshotDir.toFile());\n+          } catch (final Exception e) {\n+            LOG.error(\"Failed to create snapshot of runtime database\", e);\n+            return false;\n+          }\n+\n+          return true;\n+        });\n+  }\n+\n+  @Override\n+  public void onNewSnapshot(final PersistedSnapshot newPersistedSnapshot) {\n+    // replicate snapshots when new snapshot was committed\n+    try (final var snapshotChunkReader = newPersistedSnapshot.newChunkReader()) {\n+      while (snapshotChunkReader.hasNext()) {\n+        final var snapshotChunk = snapshotChunkReader.next();\n+        replication.replicate(snapshotChunk);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This is called by the snapshot replication implementation on each snapshot chunk\n+   *\n+   * @param snapshotChunk the chunk to consume\n+   */\n+  private void consumeSnapshotChunk(final SnapshotChunk snapshotChunk) {\n+    final String snapshotId = snapshotChunk.getSnapshotId();\n+    final String chunkName = snapshotChunk.getChunkName();\n+\n+    final ReplicationContext context =\n+        receivedSnapshots.computeIfAbsent(\n+            snapshotId,\n+            id -> {\n+              final var startTimestamp = System.currentTimeMillis();\n+              final ReceivedSnapshot transientSnapshot =\n+                  store.newReceivedSnapshot(snapshotChunk.getSnapshotId());\n+              return newReplication(startTimestamp, transientSnapshot);\n+            });\n+    if (context == INVALID_SNAPSHOT) {\n+      LOG.trace(\n+          \"Ignore snapshot chunk {}, because snapshot {} is marked as invalid.\",\n+          chunkName,\n+          snapshotId);\n+      return;\n+    }\n+\n+    final var receivedSnapshot = context.getReceivedSnapshot();\n+    try {\n+      if (receivedSnapshot.apply(snapshotChunk)) {\n+        validateWhenReceivedAllChunks(snapshotChunk, context);\n+      } else {\n+        markSnapshotAsInvalid(context, snapshotChunk);\n+      }\n+    } catch (final IOException e) {\n+      LOG.error(\"Unexepected error on writing the received snapshot chunk {}\", snapshotChunk, e);\n+      markSnapshotAsInvalid(context, snapshotChunk);\n+    }\n+  }\n+\n+  private void markSnapshotAsInvalid(\n+      final ReplicationContext replicationContext, final SnapshotChunk chunk) {\n+    replicationContext.getReceivedSnapshot().abort();\n+    receivedSnapshots.put(chunk.getSnapshotId(), INVALID_SNAPSHOT);\n+    metrics.decrementCount();\n+  }\n+\n+  private void validateWhenReceivedAllChunks(\n+      final SnapshotChunk snapshotChunk, final ReplicationContext context) {\n+    final int totalChunkCount = snapshotChunk.getTotalCount();\n+\n+    if (context.incrementCount() == totalChunkCount) {\n+      LOG.debug(\n+          \"Received all snapshot chunks ({}/{}), snapshot is valid\",\n+          context.getChunkCount(),\n+          totalChunkCount);\n+      if (!tryToMarkSnapshotAsValid(snapshotChunk, context)) {\n+        LOG.debug(\"Failed to mark snapshot {} as valid\", snapshotChunk.getSnapshotId());\n+      }\n+    } else {\n+      LOG.debug(\n+          \"Waiting for more snapshot chunks, currently have {}/{}\",\n+          context.getChunkCount(),\n+          totalChunkCount);\n+    }\n+  }\n+\n+  private boolean tryToMarkSnapshotAsValid(\n+      final SnapshotChunk snapshotChunk, final ReplicationContext context) {\n+    try {\n+      context.getReceivedSnapshot().persist();\n+    } catch (final Exception exception) {\n+      markSnapshotAsInvalid(context, snapshotChunk);\n+      LOG.warn(\"Unexpected error on persisting received snapshot.\", exception);\n+      return false;\n+    } finally {\n+      final var elapsed = System.currentTimeMillis() - context.getStartTimestamp();\n+      receivedSnapshots.remove(snapshotChunk.getSnapshotId());\n+      metrics.decrementCount();", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNjk0Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435726946", "bodyText": "\ud83d\udc4d yes I also didn't liked this approach", "author": "Zelldon", "createdAt": "2020-06-05T07:02:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk4NDY3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwMDUxOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435000518", "bodyText": "Nit: Why PersistedSnapshot? Why not just Snapshot?", "author": "deepthidevaki", "createdAt": "2020-06-04T05:28:54Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/impl/RaftContext.java", "diffHunk": "@@ -162,7 +162,7 @@ public RaftContext(\n     this.logReader = raftLog.openReader(1, RaftLogReader.Mode.ALL);\n \n     // Open the snapshot store.\n-    this.snapshotStore = storage.getSnapshotStore();\n+    this.persistedSnapshotStore = storage.getPersistedSnapshotStore();", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwMjYyNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435702625", "bodyText": "I had before Snapshot but I just wanted to make it clear that this is a persisted snapshot on using it otherwise we might could also have implementations we do in memory snapshots", "author": "Zelldon", "createdAt": "2020-06-05T05:48:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwMDUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwNDQyMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435004421", "bodyText": "Why do you compare with compactionBound instead of  index?", "author": "deepthidevaki", "createdAt": "2020-06-04T05:42:26Z", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/StateControllerImpl.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.system.partitions.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.SnapshotChunk;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.broker.system.partitions.AtomixRecordEntrySupplier;\n+import io.zeebe.broker.system.partitions.SnapshotReplication;\n+import io.zeebe.broker.system.partitions.StateController;\n+import io.zeebe.db.ZeebeDb;\n+import io.zeebe.db.ZeebeDbFactory;\n+import io.zeebe.logstreams.impl.Loggers;\n+import io.zeebe.util.FileUtil;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.ToLongFunction;\n+import org.agrona.collections.Object2NullableObjectHashMap;\n+import org.slf4j.Logger;\n+\n+/** Controls how snapshot/recovery operations are performed */\n+public class StateControllerImpl implements StateController, PersistedSnapshotListener {\n+\n+  private static final ReplicationContext INVALID_SNAPSHOT = new ReplicationContext(-1, null);\n+  private static final Logger LOG = Loggers.SNAPSHOT_LOGGER;\n+\n+  private final SnapshotReplication replication;\n+  private final Map<String, ReplicationContext> receivedSnapshots =\n+      new Object2NullableObjectHashMap<>();\n+\n+  private final PersistedSnapshotStore store;\n+\n+  private final Path runtimeDirectory;\n+  private final ZeebeDbFactory zeebeDbFactory;\n+  private final ToLongFunction<ZeebeDb> exporterPositionSupplier;\n+  private final AtomixRecordEntrySupplier entrySupplier;\n+\n+  private final SnapshotReplicationMetrics metrics;\n+\n+  private ZeebeDb db;\n+\n+  public StateControllerImpl(\n+      final int partitionId,\n+      final ZeebeDbFactory zeebeDbFactory,\n+      final PersistedSnapshotStore store,\n+      final Path runtimeDirectory,\n+      final SnapshotReplication replication,\n+      final AtomixRecordEntrySupplier entrySupplier,\n+      final ToLongFunction<ZeebeDb> exporterPositionSupplier) {\n+    this.store = store;\n+    this.runtimeDirectory = runtimeDirectory;\n+    this.zeebeDbFactory = zeebeDbFactory;\n+    this.exporterPositionSupplier = exporterPositionSupplier;\n+    this.entrySupplier = entrySupplier;\n+    this.replication = replication;\n+    this.metrics = new SnapshotReplicationMetrics(Integer.toString(partitionId));\n+    store.addSnapshotListener(this);\n+  }\n+\n+  @Override\n+  public Optional<TransientSnapshot> takeTransientSnapshot(final long lowerBoundSnapshotPosition) {\n+    if (!isDbOpened()) {\n+      return Optional.empty();\n+    }\n+\n+    final long exportedPosition = exporterPositionSupplier.applyAsLong(openDb());\n+    final long snapshotPosition = Math.min(exportedPosition, lowerBoundSnapshotPosition);\n+\n+    final var optionalIndexed = entrySupplier.getIndexedEntry(snapshotPosition);\n+\n+    final Long previousSnapshotIndex =\n+        store.getLatestSnapshot().map(PersistedSnapshot::getCompactionBound).orElse(-1L);", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwMzc3NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435703774", "bodyText": "This is actually from here https://github.com/zeebe-io/zeebe/blob/develop/atomix/cluster/src/main/java/io/atomix/raft/impl/zeebe/snapshot/AtomixSnapshotStorage.java#L59 and I think because it is the compaction bound you compare here but yes in the end it is the index", "author": "Zelldon", "createdAt": "2020-06-05T05:52:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwNDQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwNTkyMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435005921", "bodyText": "Are we comparing snapshots anywhere?", "author": "deepthidevaki", "createdAt": "2020-06-04T05:47:30Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/PersistedSnapshot.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.CloseableSilently;\n+import java.nio.file.Path;\n+import java.util.Comparator;\n+\n+/** Represents an snapshot, which was persisted at the {@link PersistedSnapshotStore}. */\n+public interface PersistedSnapshot extends CloseableSilently, Comparable<PersistedSnapshot> {\n+\n+  /**\n+   * Returns the snapshot timestamp.\n+   *\n+   * <p>The timestamp is the wall clock time at the {@link #getIndex()} at which the snapshot was\n+   * taken.\n+   *\n+   * @return The snapshot timestamp.\n+   */\n+  WallClockTimestamp getTimestamp();\n+\n+  /**\n+   * Returns the snapshot format version.\n+   *\n+   * @return the snapshot format version\n+   */\n+  int version();\n+\n+  /**\n+   * Returns the snapshot index.\n+   *\n+   * <p>The snapshot index is the index of the state machine at the point at which the snapshot was\n+   * written.\n+   *\n+   * @return The snapshot index.\n+   */\n+  long getIndex();\n+\n+  /**\n+   * Returns the snapshot term.\n+   *\n+   * <p>The snapshot term is the term of the state machine at the point at which the snapshot was\n+   * written.\n+   *\n+   * @return The snapshot term.\n+   */\n+  long getTerm();\n+\n+  /**\n+   * Returns a new snapshot chunk reader for this snapshot. Chunk readers are meant to be one-time\n+   * use and as such don't have to be thread-safe.\n+   *\n+   * @return a new snapshot chunk reader\n+   */\n+  SnapshotChunkReader newChunkReader();\n+\n+  /** Deletes the snapshot. */\n+  void delete();\n+\n+  /** @return a path to the snapshot location */\n+  Path getPath();\n+\n+  @Override\n+  default int compareTo(final PersistedSnapshot other) {\n+    return Comparator.comparingLong(PersistedSnapshot::getIndex)", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwNDIzMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435704231", "bodyText": "Maybe not anymore, should I remove it?", "author": "Zelldon", "createdAt": "2020-06-05T05:54:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwNTkyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2OTk2Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435769963", "bodyText": "Remove", "author": "Zelldon", "createdAt": "2020-06-05T08:31:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwNTkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwODkyMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435008922", "bodyText": "There is a chance that raft snapshot receiver and broker snapshot receiver are both trying to write the same snapshot to the same pending directory.", "author": "deepthidevaki", "createdAt": "2020-06-04T05:57:17Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStoreFactory.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.PersistedSnapshotStoreFactory;\n+import java.nio.file.Path;\n+import org.agrona.IoUtil;\n+\n+/**\n+ * Loads existing snapshots in memory, cleaning out old and/or invalid snapshots if present.\n+ *\n+ * <p>The current load strategy is to lookup all files directly under the {@code\n+ * SNAPSHOTS_DIRECTORY}, try to extract {@link FileBasedSnapshotMetadata} from them, and if not\n+ * possible skip them (and print out a warning).\n+ *\n+ * <p>The metadata extraction is done by parsing the directory name using '%d-%d-%d-%d', where in\n+ * order we expect: index, term, timestamp, and position.\n+ */\n+public final class FileBasedSnapshotStoreFactory implements PersistedSnapshotStoreFactory {\n+  public static final String SNAPSHOTS_DIRECTORY = \"snapshots\";\n+  public static final String PENDING_DIRECTORY = \"pending\";", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwNDg2MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435704861", "bodyText": "this would mean that directly after taking the snapshot the LEader starts to also send the newest snapshot right? How high are these chances? On receiving chunk already stored chunks are also ignored so might not be a problem? In the end we should have an persisted snapshot right?", "author": "Zelldon", "createdAt": "2020-06-05T05:56:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwODkyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwNTAwMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435705001", "bodyText": "Isn't this the case also right now with our current impl or did I removed something?", "author": "Zelldon", "createdAt": "2020-06-05T05:57:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwODkyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4MDQ1Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435780452", "bodyText": "we add a label for the pending dir", "author": "Zelldon", "createdAt": "2020-06-05T08:49:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwODkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxOTQxOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435019419", "bodyText": "Not sure if timestamp should be part of SnapshotId. In my opinion index is the snapshot id. term and timestamp are part of snapshot's metadata.", "author": "deepthidevaki", "createdAt": "2020-06-04T06:28:08Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/SnapshotId.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import java.util.Comparator;\n+\n+/** Represents an identifier of an {@link PersistedSnapshot}. */\n+public interface SnapshotId extends Comparable<SnapshotId> {\n+\n+  /** @return the index of the snapshot */\n+  long getIndex();\n+\n+  /** @return the term when the snapshot was taken */\n+  long getTerm();\n+\n+  /** @return the timestamp when the snapshot was taken */\n+  WallClockTimestamp getTimestamp();", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwNTU3OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435705579", "bodyText": "Agree but this is how it currently also is used on develop, don't wanted to change that in this PR.", "author": "Zelldon", "createdAt": "2020-06-05T05:59:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxOTQxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkyNDg4Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435924882", "bodyText": "#4676", "author": "Zelldon", "createdAt": "2020-06-05T13:35:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxOTQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAyNjM4MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435026381", "bodyText": "Would this be a problem when both broker replication and raft replication runs concurrently?", "author": "deepthidevaki", "createdAt": "2020-06-04T06:45:16Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import org.slf4j.Logger;\n+\n+public final class FileBasedSnapshotStore implements PersistedSnapshotStore {\n+\n+  private static final Logger LOGGER = new ZbLogger(FileBasedSnapshotStore.class);\n+\n+  // the root snapshotsDirectory where all snapshots should be stored\n+  private final Path snapshotsDirectory;\n+  // the root snapshotsDirectory when pending snapshots should be stored\n+  private final Path pendingDirectory;\n+  // keeps track of all snapshot modification listeners\n+  private final Set<PersistedSnapshotListener> listeners;\n+\n+  private final SnapshotMetrics snapshotMetrics;\n+\n+  private PersistedSnapshot currentPersistedSnapshot;\n+\n+  public FileBasedSnapshotStore(\n+      final SnapshotMetrics snapshotMetrics,\n+      final Path snapshotsDirectory,\n+      final Path pendingDirectory) {\n+    this.snapshotsDirectory = snapshotsDirectory;\n+    this.pendingDirectory = pendingDirectory;\n+    this.snapshotMetrics = snapshotMetrics;\n+\n+    this.listeners = new CopyOnWriteArraySet<>();\n+\n+    // load previous snapshots\n+    currentPersistedSnapshot = loadLatestSnapshot(snapshotsDirectory);\n+  }\n+\n+  private PersistedSnapshot loadLatestSnapshot(final Path snapshotDirectory) {\n+    PersistedSnapshot latestPersistedSnapshot = null;\n+    try (final var stream = Files.newDirectoryStream(snapshotDirectory)) {\n+      for (final var path : stream) {\n+        latestPersistedSnapshot = collectSnapshot(path);\n+      }\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+    return latestPersistedSnapshot;\n+  }\n+\n+  private PersistedSnapshot collectSnapshot(final Path path) {\n+    final var optionalMeta = FileBasedSnapshotMetadata.ofPath(path);\n+    if (optionalMeta.isPresent()) {\n+      final var metadata = optionalMeta.get();\n+      return new FileBasedSnapshot(path, metadata);\n+    } else {\n+      LOGGER.warn(\"Expected snapshot file format to be %d-%d-%d-%d, but was {}\", path);\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean exists(final String id) {\n+    final var optLatestSnapshot = getLatestSnapshot();\n+\n+    if (optLatestSnapshot.isPresent()) {\n+      final var snapshot = optLatestSnapshot.get();\n+      return snapshot.getPath().getFileName().toString().equals(id);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public TransientSnapshot newTransientSnapshot(\n+      final long index, final long term, final WallClockTimestamp timestamp) {\n+    final var directory = buildPendingSnapshotDirectory(index, term, timestamp);\n+    final var fileBasedSnapshotMetadata = new FileBasedSnapshotMetadata(index, term, timestamp);\n+    return new FileBasedTransientSnapshot(fileBasedSnapshotMetadata, directory, this);\n+  }\n+\n+  @Override\n+  public ReceivedSnapshot newReceivedSnapshot(final String snapshotId) {\n+    final var optMetadata = FileBasedSnapshotMetadata.ofFileName(snapshotId);\n+    final var metadata =\n+        optMetadata.orElseThrow(\n+            () ->\n+                new IllegalArgumentException(\n+                    \"Expected snapshot id in a format like 'index-term-timestamp', got '\"\n+                        + snapshotId\n+                        + \"'.\"));\n+\n+    final var pendingSnapshotDir = pendingDirectory.resolve(metadata.getSnapshotIdAsString());\n+    return new FileBasedReceivedSnapshot(metadata, pendingSnapshotDir, this);\n+  }\n+\n+  @Override\n+  public Optional<PersistedSnapshot> getLatestSnapshot() {\n+    return Optional.ofNullable(currentPersistedSnapshot);\n+  }\n+\n+  @Override\n+  public void purgePendingSnapshots() throws IOException {\n+    try (final var files = Files.list(pendingDirectory)) {\n+      files.filter(Files::isDirectory).forEach(this::purgePendingSnapshot);\n+    }\n+  }\n+\n+  @Override\n+  public void addSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.add(listener);\n+  }\n+\n+  @Override\n+  public void removeSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.remove(listener);\n+  }\n+\n+  @Override\n+  public long getCurrentSnapshotIndex() {\n+    return getLatestSnapshot().map(PersistedSnapshot::getIndex).orElse(0L);\n+  }\n+\n+  @Override\n+  public void delete() {\n+    currentPersistedSnapshot = null;\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(snapshotsDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(pendingDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private void observeSnapshotSize(final PersistedSnapshot persistedSnapshot) {\n+    try (final var contents = Files.newDirectoryStream(persistedSnapshot.getPath())) {\n+      var totalSize = 0L;\n+\n+      for (final var path : contents) {\n+        if (Files.isRegularFile(path)) {\n+          final var size = Files.size(path);\n+          snapshotMetrics.observeSnapshotFileSize(size);\n+          totalSize += size;\n+        }\n+      }\n+\n+      snapshotMetrics.observeSnapshotSize(totalSize);\n+    } catch (final IOException e) {\n+      LOGGER.warn(\"Failed to observe size for snapshot {}\", persistedSnapshot, e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshots(final long cutoffIndex) {\n+    LOGGER.debug(\n+        \"Search for orphaned snapshots below oldest valid snapshot with index {} in {}\",\n+        cutoffIndex,\n+        pendingDirectory);\n+\n+    try (final var pendingSnapshots = Files.newDirectoryStream(pendingDirectory)) {\n+      for (final var pendingSnapshot : pendingSnapshots) {\n+        purgePendingSnapshot(cutoffIndex, pendingSnapshot);\n+      }\n+    } catch (final IOException e) {\n+      LOGGER.warn(\n+          \"Failed to delete orphaned snapshots, could not list pending directory {}\",\n+          pendingDirectory,\n+          e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshot(final long cutoffIndex, final Path pendingSnapshot) {\n+    final var optionalMetadata = FileBasedSnapshotMetadata.ofPath(pendingSnapshot);\n+    if (optionalMetadata.isPresent() && optionalMetadata.get().getIndex() < cutoffIndex) {\n+      try {\n+        LOGGER.error(\"Deleted orphaned snapshot {}\", pendingSnapshot);\n+        FileUtil.deleteFolder(pendingSnapshot);\n+        LOGGER.debug(\"Deleted orphaned snapshot {}\", pendingSnapshot);\n+      } catch (final IOException e) {\n+        LOGGER.warn(\n+            \"Failed to delete orphaned snapshot {}, risk using unnecessary disk space\",\n+            pendingSnapshot,\n+            e);\n+      }\n+    }\n+  }\n+\n+  public Path getPath() {\n+    return snapshotsDirectory;\n+  }\n+\n+  @Override\n+  public void close() {\n+    listeners.clear();\n+  }\n+\n+  private boolean isCurrentSnapshotNewer(final FileBasedSnapshotMetadata metadata) {\n+    return (currentPersistedSnapshot != null\n+        && currentPersistedSnapshot.getId().compareTo(metadata) >= 0);\n+  }\n+\n+  PersistedSnapshot newSnapshot(final FileBasedSnapshotMetadata metadata, final Path directory) {\n+\n+    if (isCurrentSnapshotNewer(metadata)) {\n+      LOGGER.debug(\"Snapshot is older then {} already exists\", currentPersistedSnapshot);\n+      purgePendingSnapshots(metadata.getIndex() + 1);\n+      return currentPersistedSnapshot;\n+    }\n+\n+    final var destination = buildSnapshotDirectory(metadata);\n+    try {\n+      tryAtomicDirectoryMove(directory, destination);\n+    } catch (final FileAlreadyExistsException e) {\n+      LOGGER.debug(\n+          \"Expected to move snapshot from {} to {}, but it already exists\",\n+          directory,\n+          destination,\n+          e);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+\n+    final var previousSnapshot = currentPersistedSnapshot;\n+\n+    currentPersistedSnapshot = new FileBasedSnapshot(destination, metadata);", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwNTk3Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435705973", "bodyText": "I changed this to an atomic reference and see above for the other discussion", "author": "Zelldon", "createdAt": "2020-06-05T06:00:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAyNjM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwMzgzMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435703832", "bodyText": "Unused field.", "author": "deepthidevaki", "createdAt": "2020-06-05T05:53:05Z", "path": "broker/src/test/java/io/zeebe/broker/system/partitions/AsyncSnapshotingTest.java", "diffHunk": "@@ -52,22 +59,36 @@\n   public final RuleChain chain =\n       RuleChain.outerRule(autoCloseableRule).around(tempFolderRule).around(actorSchedulerRule);\n \n-  private StateSnapshotController snapshotController;\n+  private StateControllerImpl snapshotController;\n   private LogStream logStream;\n   private AsyncSnapshotDirector asyncSnapshotDirector;\n   private StreamProcessor mockStreamProcessor;\n   private List<ActorCondition> conditionList;\n+  private PersistedSnapshotStore persistedSnapshotStore;\n+  private final AtomicReference<Indexed> indexedAtomicReference = new AtomicReference<>();", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwNTEzMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435705133", "bodyText": "Was this class supposed to be deleted?", "author": "deepthidevaki", "createdAt": "2020-06-05T05:57:37Z", "path": "broker/src/test/java/io/zeebe/broker/system/partitions/AtomixSnapshotStorageTest.java", "diffHunk": "@@ -5,265 +5,273 @@\n  * Licensed under the Zeebe Community License 1.0. You may not use this file\n  * except in compliance with the Zeebe Community License 1.0.\n  */\n+/// *\n+// * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+// * one or more contributor license agreements. See the NOTICE file distributed\n+// * with this work for additional information regarding copyright ownership.\n+// * Licensed under the Zeebe Community License 1.0. You may not use this file\n+// * except in compliance with the Zeebe Community License 1.0.\n+// */\n package io.zeebe.broker.system.partitions;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.mockito.ArgumentMatchers.eq;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.verify;\n-\n-import io.atomix.raft.impl.zeebe.snapshot.AtomixRecordEntrySupplier;\n-import io.atomix.raft.impl.zeebe.snapshot.AtomixSnapshotStorage;\n-import io.atomix.raft.impl.zeebe.snapshot.DbSnapshotStore;\n-import io.atomix.raft.impl.zeebe.snapshot.Snapshot;\n-import io.atomix.raft.impl.zeebe.snapshot.SnapshotDeletionListener;\n-import io.atomix.raft.impl.zeebe.snapshot.SnapshotMetrics;\n-import io.atomix.raft.impl.zeebe.snapshot.SnapshotStorage;\n-import io.atomix.raft.storage.snapshot.SnapshotStore;\n-import io.atomix.storage.journal.JournalReader.Mode;\n-import io.zeebe.logstreams.storage.atomix.AtomixRecordEntrySupplierImpl;\n-import io.zeebe.logstreams.util.AtomixLogStorageRule;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.concurrent.ConcurrentSkipListMap;\n-import org.agrona.IoUtil;\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.RuleChain;\n-import org.junit.rules.TemporaryFolder;\n-\n-public final class AtomixSnapshotStorageTest {\n-\n-  private final TemporaryFolder temporaryFolder = new TemporaryFolder();\n-  private final AtomixLogStorageRule logStorageRule = new AtomixLogStorageRule(temporaryFolder);\n-  @Rule public final RuleChain chain = RuleChain.outerRule(temporaryFolder).around(logStorageRule);\n-\n-  private Path pendingDirectory;\n-  private SnapshotStore store;\n-  private AtomixSnapshotStorage snapshotStorage;\n-  private AtomixRecordEntrySupplier entrySupplier;\n-\n-  @Before\n-  public void setUp() throws Exception {\n-    final var snapshotsDirectory = temporaryFolder.newFolder(\"snapshots\").toPath();\n-    final var raftPendingDirectory = temporaryFolder.getRoot().toPath().resolve(\"pending\");\n-    pendingDirectory = temporaryFolder.newFolder(\"pushed-pending\").toPath();\n-    entrySupplier =\n-        new AtomixRecordEntrySupplierImpl(\n-            logStorageRule.getIndexMapping(),\n-            logStorageRule.getRaftLog().openReader(-1, Mode.COMMITS));\n-    store =\n-        new DbSnapshotStore(\n-            snapshotsDirectory, raftPendingDirectory, new ConcurrentSkipListMap<>());\n-  }\n-\n-  @After\n-  public void tearDown() {\n-    Optional.ofNullable(snapshotStorage).ifPresent(SnapshotStorage::close);\n-    Optional.ofNullable(store).ifPresent(SnapshotStore::close);\n-  }\n-\n-  @Test\n-  public void shouldNotGetPendingSnapshotForNegativePosition() {\n-    // given\n-    final var storage = newStorage();\n-    logStorageRule.appendEntry(1, 1, ByteBuffer.allocate(1));\n-\n-    // when\n-    final var snapshot = storage.getPendingSnapshotFor(-1);\n-    // then\n-    assertThat(snapshot).isEmpty();\n-  }\n-\n-  @Test\n-  public void shouldGetPendingSnapshotForPositions() {\n-    // given\n-    final var storage = newStorage();\n-    logStorageRule.appendEntry(1, 1, ByteBuffer.allocate(1));\n-    logStorageRule.appendEntry(2, 2, ByteBuffer.allocate(1));\n-    logStorageRule.appendEntry(3, 3, ByteBuffer.allocate(1));\n-\n-    // when\n-    final var first = storage.getPendingSnapshotFor(2).orElseThrow();\n-    final var second = storage.getPendingSnapshotFor(3).orElseThrow();\n-\n-    // then\n-    assertThat(first.getPath()).doesNotExist().hasParentRaw(pendingDirectory);\n-    assertThat(second.getPath()).doesNotExist().hasParentRaw(pendingDirectory);\n-    assertThat(first.getPath()).isNotEqualTo(second.getPath());\n-  }\n-\n-  @Test\n-  public void shouldReturnNullIfNoEntryForPosition() {\n-    // given\n-    final var storage = newStorage();\n-    logStorageRule.appendEntry(3, 3, ByteBuffer.allocate(1));\n-\n-    // when\n-    final var snapshot = storage.getPendingSnapshotFor(1);\n-\n-    // then\n-    assertThat(snapshot).isEmpty();\n-  }\n-\n-  @Test\n-  public void shouldGetPendingDirectoryForId() {\n-    // given\n-    final var id = \"1-1-1\";\n-    final var storage = newStorage();\n-\n-    // when\n-    final var directory = storage.getPendingDirectoryFor(id).orElseThrow();\n-\n-    // then\n-    assertThat(directory).doesNotExist().hasParentRaw(pendingDirectory);\n-    assertThat(directory.getFileName()).hasToString(id);\n-  }\n-\n-  @Test\n-  public void shouldDeleteOrphanedPendingSnapshotsOnNewSnapshot() {\n-    // given\n-    final var storage = newStorage();\n-    final var toDelete = pendingDirectory.resolve(\"1-1-1\");\n-    final var snapshotDirectory = pendingDirectory.resolve(\"2-2-2\");\n-    final var toKeep = pendingDirectory.resolve(\"3-3-3\");\n-    IoUtil.ensureDirectoryExists(toDelete.toFile(), \"to delete directory\");\n-    IoUtil.ensureDirectoryExists(snapshotDirectory.toFile(), \"snapshot directory\");\n-    IoUtil.ensureDirectoryExists(toKeep.toFile(), \"to keep directory\");\n-\n-    // when\n-    storage.commitSnapshot(snapshotDirectory);\n-\n-    // then\n-    assertThat(toDelete).doesNotExist();\n-    assertThat(toKeep).exists();\n-  }\n-\n-  @Test\n-  public void shouldDeleteOrphanedPendingSnapshotsEvenIfOneIsNotASnapshot() {\n-    // given\n-    final var storage = newStorage();\n-    // given\n-    final var orphanedSnapshots =\n-        List.of(pendingDirectory.resolve(\"1-1-1\"), pendingDirectory.resolve(\"2-2-2\"));\n-    final var snapshotDirectory = pendingDirectory.resolve(\"3-3-3\");\n-    final var evilFolder = pendingDirectory.resolve(\"not a snapshot\");\n-    orphanedSnapshots.forEach(p -> IoUtil.ensureDirectoryExists(p.toFile(), \"\"));\n-    IoUtil.ensureDirectoryExists(evilFolder.toFile(), \"not a snapshot folder\");\n-    IoUtil.ensureDirectoryExists(snapshotDirectory.toFile(), \"to keep directory\");\n-\n-    // when\n-    storage.commitSnapshot(snapshotDirectory);\n-\n-    // then\n-    orphanedSnapshots.forEach(s -> assertThat(s).doesNotExist());\n-    assertThat(evilFolder).exists();\n-  }\n-\n-  @Test\n-  public void shouldReturnEmptyIfIdIsNotMetadata() {\n-    // given\n-    final var id = \"foo\";\n-    final var storage = newStorage();\n-\n-    // when\n-    final var directory = storage.getPendingDirectoryFor(id);\n-\n-    // then\n-    assertThat(directory).isEmpty();\n-  }\n-\n-  @Test\n-  public void shouldCommitPendingSnapshot() throws IOException {\n-    // given\n-    final var storage = newStorage();\n-\n-    // when\n-    final var snapshot = newPendingSnapshot(2);\n-    Files.createDirectories(snapshot.getPath());\n-    storage.commitSnapshot(snapshot.getPath());\n-\n-    // then\n-    assertThat(store.getSnapshots()).hasSize(1);\n-    assertThat(store.getCurrentSnapshotIndex()).isEqualTo(1);\n-    assertThat(store.getSnapshot(1))\n-        .extracting(s -> s.getPath().getFileName())\n-        .isEqualTo(snapshot.getPath().getFileName());\n-  }\n-\n-  @Test\n-  public void shouldGetLatestSnapshot() throws IOException {\n-    // given\n-    final var storage = newStorage();\n-\n-    // when\n-    final var snapshot = newCommittedSnapshot(1);\n-\n-    // then\n-    assertThat(storage.getLatestSnapshot())\n-        .map(Snapshot::getCompactionBound)\n-        .hasValue(snapshot.getCompactionBound());\n-  }\n-\n-  @Test\n-  public void shouldNotifyDeletionListenersOnMaxSnapshotCount() throws IOException {\n-    // given\n-    final var listener = mock(SnapshotDeletionListener.class);\n-    final var storage = newStorage();\n-    storage.addDeletionListener(listener);\n-\n-    // when the first snapshot then try to delete snapshots older than first\n-    final var first = newCommittedSnapshot(1);\n-    verify(listener).onSnapshotsDeleted(eq(first));\n-\n-    // when the second snapshot then all snapshots up to that snapshot are deleted\n-    final var second = newCommittedSnapshot(2);\n-    verify(listener).onSnapshotsDeleted(eq(second));\n-    assertThat(storage.getSnapshots()).hasSize(1).containsExactly(second);\n-  }\n-\n-  @Test\n-  public void shouldNotCreatePendingSnapshotIfSnapshotExistsForIndex() throws IOException {\n-    // given\n-    final var storage = newStorage();\n-    logStorageRule.appendEntry(2, 2, ByteBuffer.allocate(1));\n-    logStorageRule.appendEntry(3, 3, ByteBuffer.allocate(1));\n-    final var snapshot = storage.getPendingSnapshotFor(3).orElseThrow();\n-    Files.createDirectories(snapshot.getPath());\n-    storage.commitSnapshot(snapshot.getPath()).orElseThrow();\n-\n-    // when\n-    final var newSnapshot = storage.getPendingSnapshotFor(3);\n-\n-    // then\n-    assertThat(newSnapshot).isEmpty();\n-  }\n-\n-  private Snapshot newPendingSnapshot(final long position) {\n-    logStorageRule.appendEntry(position - 1, position - 1, ByteBuffer.allocate(1));\n-    logStorageRule.appendEntry(position, position, ByteBuffer.allocate(1));\n-    return snapshotStorage.getPendingSnapshotFor(position).orElseThrow();\n-  }\n-\n-  private Snapshot newCommittedSnapshot(final long position) throws IOException {\n-    final var snapshot = newPendingSnapshot(position);\n-    Files.createDirectories(snapshot.getPath());\n-    snapshotStorage.commitSnapshot(snapshot.getPath());\n-\n-    return snapshotStorage.getLatestSnapshot().orElseThrow();\n-  }\n-\n-  private AtomixSnapshotStorage newStorage() {\n-    final var runtimeDirectory = temporaryFolder.getRoot().toPath().resolve(\"runtime\");\n-    snapshotStorage =\n-        new AtomixSnapshotStorage(\n-            runtimeDirectory, pendingDirectory, store, entrySupplier, new SnapshotMetrics(0));\n-    return snapshotStorage;\n-  }\n-}\n+//", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcxOTIyNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435719225", "bodyText": "Oh yes thanks", "author": "Zelldon", "createdAt": "2020-06-05T06:42:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwNTEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwOTkzMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435709933", "bodyText": "Do we have another test that verifies processor does not reprocess event at the last processed position in snapshot?", "author": "deepthidevaki", "createdAt": "2020-06-05T06:14:15Z", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -395,8 +390,10 @@ public void processRecord(\n     streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n     final long snapshotPosition =\n         streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    // we write three event to make sure that the second event was committed and is part of the\n+    // state (lastProcessedEvent)\n     processingLatch.await();\n-    streamProcessorRule.waitForNextSnapshot();", "originalCommit": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcxODkzMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435718933", "bodyText": "I thought but I can check", "author": "Zelldon", "createdAt": "2020-06-05T06:41:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwOTkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ2NDk5NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r436464995", "bodyText": "Ok I remember I rewrote the test that such that the event is part of the state/db because this is the only thing what matters. Here we verify that we dont reprocess again the events, which we already saw and part of the db. This is unrelated of how and when we take snapshot since this is no longer part of the stream processor. It only matters what is part of the db.", "author": "Zelldon", "createdAt": "2020-06-08T05:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwOTkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyMTE0Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r436621142", "bodyText": "How are we ensuring that the event is part of the state and the reprocessor is reading the position from the state instead of reading the log from the beginning?", "author": "deepthidevaki", "createdAt": "2020-06-08T11:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwOTkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY0Nzk5NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r436647995", "bodyText": "How are we ensuring that the event is part of the state and the reprocessor is reading the position from the state instead of reading the log from the beginning?\n\nWe write three events. Await processing of the third, which means second needs to be committed and written to the DB. On restart we check the processed events and check that the second, which should be part of the db is not part of the processed list.", "author": "Zelldon", "createdAt": "2020-06-08T12:13:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwOTkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyNDk0Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r436624942", "bodyText": "Shouldn't we synchronize access to this method?. There is a potential race condition between comparing current snapshot and assigning the new one when concurrent replication is in progress. Alternative use currentPersistedSnapshotRef.compareAndSet.", "author": "deepthidevaki", "createdAt": "2020-06-08T11:23:06Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Logger;\n+\n+public final class FileBasedSnapshotStore implements PersistedSnapshotStore {\n+  // first is the metadata and the second the the received snapshot count\n+  private static final String RECEIVING_DIR_FORMAT = \"%s-%d\";\n+\n+  private static final Logger LOGGER = new ZbLogger(FileBasedSnapshotStore.class);\n+\n+  // the root snapshotsDirectory where all snapshots should be stored\n+  private final Path snapshotsDirectory;\n+  // the root snapshotsDirectory when pending snapshots should be stored\n+  private final Path pendingDirectory;\n+  // keeps track of all snapshot modification listeners\n+  private final Set<PersistedSnapshotListener> listeners;\n+\n+  private final SnapshotMetrics snapshotMetrics;\n+\n+  private final AtomicReference<PersistedSnapshot> currentPersistedSnapshotRef;\n+  // used to write concurrently received snapshots in different pending directories\n+  private final AtomicLong receivingSnapshotStartCount;\n+\n+  public FileBasedSnapshotStore(\n+      final SnapshotMetrics snapshotMetrics,\n+      final Path snapshotsDirectory,\n+      final Path pendingDirectory) {\n+    this.snapshotsDirectory = snapshotsDirectory;\n+    this.pendingDirectory = pendingDirectory;\n+    this.snapshotMetrics = snapshotMetrics;\n+    this.receivingSnapshotStartCount = new AtomicLong();\n+\n+    this.listeners = new CopyOnWriteArraySet<>();\n+\n+    // load previous snapshots\n+    currentPersistedSnapshotRef = new AtomicReference<>(loadLatestSnapshot(snapshotsDirectory));\n+  }\n+\n+  private PersistedSnapshot loadLatestSnapshot(final Path snapshotDirectory) {\n+    PersistedSnapshot latestPersistedSnapshot = null;\n+    try (final var stream = Files.newDirectoryStream(snapshotDirectory)) {\n+      for (final var path : stream) {\n+        latestPersistedSnapshot = collectSnapshot(path);\n+      }\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+    return latestPersistedSnapshot;\n+  }\n+\n+  private PersistedSnapshot collectSnapshot(final Path path) {\n+    final var optionalMeta = FileBasedSnapshotMetadata.ofPath(path);\n+    if (optionalMeta.isPresent()) {\n+      final var metadata = optionalMeta.get();\n+      return new FileBasedSnapshot(path, metadata);\n+    } else {\n+      LOGGER.warn(\"Expected snapshot file format to be %d-%d-%d-%d, but was {}\", path);\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean hasSnapshotId(final String id) {\n+    final var optLatestSnapshot = getLatestSnapshot();\n+\n+    if (optLatestSnapshot.isPresent()) {\n+      final var snapshot = optLatestSnapshot.get();\n+      return snapshot.getPath().getFileName().toString().equals(id);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public TransientSnapshot newTransientSnapshot(\n+      final long index, final long term, final WallClockTimestamp timestamp) {\n+    final var directory = buildPendingSnapshotDirectory(index, term, timestamp);\n+    final var fileBasedSnapshotMetadata = new FileBasedSnapshotMetadata(index, term, timestamp);\n+    return new FileBasedTransientSnapshot(fileBasedSnapshotMetadata, directory, this);\n+  }\n+\n+  @Override\n+  public ReceivedSnapshot newReceivedSnapshot(final String snapshotId) {\n+    final var optMetadata = FileBasedSnapshotMetadata.ofFileName(snapshotId);\n+    final var metadata =\n+        optMetadata.orElseThrow(\n+            () ->\n+                new IllegalArgumentException(\n+                    \"Expected snapshot id in a format like 'index-term-timestamp', got '\"\n+                        + snapshotId\n+                        + \"'.\"));\n+\n+    // to make the pending dir unique\n+    final var nextStartCount = receivingSnapshotStartCount.incrementAndGet();\n+    final var pendingDirectoryName =\n+        String.format(RECEIVING_DIR_FORMAT, metadata.getSnapshotIdAsString(), nextStartCount);\n+    final var pendingSnapshotDir = pendingDirectory.resolve(pendingDirectoryName);\n+    return new FileBasedReceivedSnapshot(metadata, pendingSnapshotDir, this);\n+  }\n+\n+  @Override\n+  public Optional<PersistedSnapshot> getLatestSnapshot() {\n+    return Optional.ofNullable(currentPersistedSnapshotRef.get());\n+  }\n+\n+  @Override\n+  public void purgePendingSnapshots() throws IOException {\n+    try (final var files = Files.list(pendingDirectory)) {\n+      files.filter(Files::isDirectory).forEach(this::purgePendingSnapshot);\n+    }\n+  }\n+\n+  @Override\n+  public void addSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.add(listener);\n+  }\n+\n+  @Override\n+  public void removeSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.remove(listener);\n+  }\n+\n+  @Override\n+  public long getCurrentSnapshotIndex() {\n+    return getLatestSnapshot().map(PersistedSnapshot::getIndex).orElse(0L);\n+  }\n+\n+  @Override\n+  public void delete() {\n+    currentPersistedSnapshotRef.set(null);\n+\n+    try {\n+      LOGGER.debug(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(snapshotsDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+\n+    try {\n+      LOGGER.debug(\"DELETE FOLDER {}\", pendingDirectory);\n+      FileUtil.deleteFolder(pendingDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private void observeSnapshotSize(final PersistedSnapshot persistedSnapshot) {\n+    try (final var contents = Files.newDirectoryStream(persistedSnapshot.getPath())) {\n+      var totalSize = 0L;\n+\n+      for (final var path : contents) {\n+        if (Files.isRegularFile(path)) {\n+          final var size = Files.size(path);\n+          snapshotMetrics.observeSnapshotFileSize(size);\n+          totalSize += size;\n+        }\n+      }\n+\n+      snapshotMetrics.observeSnapshotSize(totalSize);\n+    } catch (final IOException e) {\n+      LOGGER.warn(\"Failed to observe size for snapshot {}\", persistedSnapshot, e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshots(final long cutoffIndex) {\n+    LOGGER.debug(\n+        \"Search for orphaned snapshots below oldest valid snapshot with index {} in {}\",\n+        cutoffIndex,\n+        pendingDirectory);\n+\n+    try (final var pendingSnapshots = Files.newDirectoryStream(pendingDirectory)) {\n+      for (final var pendingSnapshot : pendingSnapshots) {\n+        purgePendingSnapshot(cutoffIndex, pendingSnapshot);\n+      }\n+    } catch (final IOException e) {\n+      LOGGER.warn(\n+          \"Failed to delete orphaned snapshots, could not list pending directory {}\",\n+          pendingDirectory,\n+          e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshot(final long cutoffIndex, final Path pendingSnapshot) {\n+    final var optionalMetadata = FileBasedSnapshotMetadata.ofPath(pendingSnapshot);\n+    if (optionalMetadata.isPresent() && optionalMetadata.get().getIndex() < cutoffIndex) {\n+      try {\n+        FileUtil.deleteFolder(pendingSnapshot);\n+        LOGGER.debug(\"Deleted orphaned snapshot {}\", pendingSnapshot);\n+      } catch (final IOException e) {\n+        LOGGER.warn(\n+            \"Failed to delete orphaned snapshot {}, risk using unnecessary disk space\",\n+            pendingSnapshot,\n+            e);\n+      }\n+    }\n+  }\n+\n+  public Path getPath() {\n+    return snapshotsDirectory;\n+  }\n+\n+  @Override\n+  public void close() {\n+    listeners.clear();\n+  }\n+\n+  private boolean isCurrentSnapshotNewer(final FileBasedSnapshotMetadata metadata) {\n+    final var persistedSnapshot = currentPersistedSnapshotRef.get();\n+    return (persistedSnapshot != null && persistedSnapshot.getId().compareTo(metadata) >= 0);\n+  }\n+\n+  PersistedSnapshot newSnapshot(final FileBasedSnapshotMetadata metadata, final Path directory) {", "originalCommit": "2702a11c3aa0337cd64802339b472fa0b6f8aba1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY0Njk3NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r436646974", "bodyText": "You mean because raft leader-follower repl- and our zeebe replication?", "author": "Zelldon", "createdAt": "2020-06-08T12:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyNDk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY2NDEzMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r436664130", "bodyText": "Lets shortly think about it and discuss it/\nThis can only happen for the same snapshot, right? Because we just have one snapshot at a time and this only happens when raft replicate for a slow follower AND our snapshot replication replicates the snapshot.\nIf slow follower replication start for an old it would fail if we replace it in the meantime with a different one.\nSay we have two calls which calling concurrently this method.  I would expect that one of the moves will fail because the snapshot dir already exists. In all cases the result is the same that the snapshot references the right snapshot or do I miss something?", "author": "Zelldon", "createdAt": "2020-06-08T12:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyNDk0Mg=="}], "type": "inlineReview"}, {"oid": "ca3eb0b48eec08621a43b11d5a6f809d3b3cb202", "url": "https://github.com/camunda-cloud/zeebe/commit/ca3eb0b48eec08621a43b11d5a6f809d3b3cb202", "message": "chore(atomix): rewrite snapshotting\n\n Description:\n\n Introduces new interfaces for Snapshotting.\n\n PersistedSnapshotStore can be used to take snapshots and receive\n snapshot chunks. After all chunks are received or the snapshot is taken\n the volatile snapshot can be persisted. It is always possible\n to abort an snapshot, before persisting. The store can also be used\n to get the latest snapshot which was persisted. The store allows\n to register listeners, which are called on new persisted snapshots.\n\n On receiving snapshot chunks and consuming them, checksums of the chunks\n are verified. On persisting an received snapshot the complete snapshot\n checksum is verified.\n\n An persisted snapshot can be read from it persisted storage via a\n snapshot reader and will be chunked in several snapshot chunks, which\n then can be transmitted and consumed again by the store.\n\n The StateSnapshotController use by the AsyncSnapshotDirector and is the\n only one which takes a snapshot. The ReplicationController is\n registered at the SnapshotStore as listener to replicate new persisted\n snapshots. The replication will send all chunks over the network.\n\n The ReplicationController will receive the chunks on the follower side and will use\n the newReceviedSnapshot method of the store to consume the SnapshotChunks.\n\n On the LeaderRole (in the AbstractAppender) the last snapshot can also\n be replicated. This is done via the SnapshotChunkReader, which\n reads the chunks from ther persisted store.\n\n The Follower (in PassiveRole) will consume the replicated chunks and\n will store it similar to the ReplicationController.\n\n On both ReplicationController and PassiveRole the checksum of the\n snapshot chunks but also of the complete snapshot is verified before\n the received snapshot is persisted.\n\n Related work:\n\n  * Most implemation details are now in Atomix\n  * Zeebe related snapshoting like replication and taking of snapshot is\n    part of Broker\n  * Use sbe for snapshot chunk replication/consumption\n  * StreamProcessorTests moved again to engine module - removed snapshot\n    related tests, dont need to be part of that\n  * clean up managment schema file in broker\n\n  * Wrote a bunch of new unit tests for snapshot implementation", "committedDate": "2020-06-08T14:40:37Z", "type": "commit"}, {"oid": "ca3eb0b48eec08621a43b11d5a6f809d3b3cb202", "url": "https://github.com/camunda-cloud/zeebe/commit/ca3eb0b48eec08621a43b11d5a6f809d3b3cb202", "message": "chore(atomix): rewrite snapshotting\n\n Description:\n\n Introduces new interfaces for Snapshotting.\n\n PersistedSnapshotStore can be used to take snapshots and receive\n snapshot chunks. After all chunks are received or the snapshot is taken\n the volatile snapshot can be persisted. It is always possible\n to abort an snapshot, before persisting. The store can also be used\n to get the latest snapshot which was persisted. The store allows\n to register listeners, which are called on new persisted snapshots.\n\n On receiving snapshot chunks and consuming them, checksums of the chunks\n are verified. On persisting an received snapshot the complete snapshot\n checksum is verified.\n\n An persisted snapshot can be read from it persisted storage via a\n snapshot reader and will be chunked in several snapshot chunks, which\n then can be transmitted and consumed again by the store.\n\n The StateSnapshotController use by the AsyncSnapshotDirector and is the\n only one which takes a snapshot. The ReplicationController is\n registered at the SnapshotStore as listener to replicate new persisted\n snapshots. The replication will send all chunks over the network.\n\n The ReplicationController will receive the chunks on the follower side and will use\n the newReceviedSnapshot method of the store to consume the SnapshotChunks.\n\n On the LeaderRole (in the AbstractAppender) the last snapshot can also\n be replicated. This is done via the SnapshotChunkReader, which\n reads the chunks from ther persisted store.\n\n The Follower (in PassiveRole) will consume the replicated chunks and\n will store it similar to the ReplicationController.\n\n On both ReplicationController and PassiveRole the checksum of the\n snapshot chunks but also of the complete snapshot is verified before\n the received snapshot is persisted.\n\n Related work:\n\n  * Most implemation details are now in Atomix\n  * Zeebe related snapshoting like replication and taking of snapshot is\n    part of Broker\n  * Use sbe for snapshot chunk replication/consumption\n  * StreamProcessorTests moved again to engine module - removed snapshot\n    related tests, dont need to be part of that\n  * clean up managment schema file in broker\n\n  * Wrote a bunch of new unit tests for snapshot implementation", "committedDate": "2020-06-08T14:40:37Z", "type": "forcePushed"}]}