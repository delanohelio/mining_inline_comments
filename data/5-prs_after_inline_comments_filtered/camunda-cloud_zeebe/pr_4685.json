{"pr_number": 4685, "pr_title": "chore(util): introduce spec-compliant Stackdriver Log4J2 layout", "pr_createdAt": "2020-06-09T07:24:27Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4685", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3NTA2Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437275067", "bodyText": "What does FQCN stand for?", "author": "korthout", "createdAt": "2020-06-09T09:33:47Z", "path": "atomix/utils/src/main/java/io/atomix/utils/logging/ContextualLogger.java", "diffHunk": "@@ -16,16 +16,18 @@\n  */\n package io.atomix.utils.logging;\n \n+import io.zeebe.util.ZbLogger;\n import org.slf4j.Logger;\n import org.slf4j.Marker;\n \n /** Contextual logger. */\n-public class ContextualLogger extends DelegatingLogger {\n+public class ContextualLogger extends ZbLogger {\n   private static final String SEPARATOR = \" - \";\n+  private static final String FQCN = ContextualLogger.class.getName();", "originalCommit": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNDgxNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437604817", "bodyText": "Fully Qualified Class Name; comes directly from Log4J, where you can get logger.getLoggerFcqn() for example, so I went with the same name they use for their own stuff.", "author": "npepinpe", "createdAt": "2020-06-09T17:38:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3NTA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA0MjI4Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r438042283", "bodyText": "Cool. Learned something new", "author": "korthout", "createdAt": "2020-06-10T11:08:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3NTA2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4NjUyOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437286528", "bodyText": "These should write message at level tests would be a good case for parameterized. But since you also have other tests you'd need to use junit5 I think. If you want to have a go at junit5, this could be a good chance. Otherwise, I can also see why you wouldn't want to spend more time on this. In any case, the behaviour is already tested.", "author": "korthout", "createdAt": "2020-06-09T09:52:40Z", "path": "util/src/test/java/io/zeebe/util/logging/StackdriverLayoutTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.logging;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import io.zeebe.util.LogUtil;\n+import io.zeebe.util.logging.stackdriver.Severity;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntry;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntryBuilder;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.core.Layout;\n+import org.apache.logging.log4j.core.Logger;\n+import org.apache.logging.log4j.core.appender.OutputStreamAppender;\n+import org.apache.logging.log4j.core.impl.ThrowableProxy;\n+import org.assertj.core.api.InstanceOfAssertFactories;\n+import org.assertj.core.api.JUnitSoftAssertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.slf4j.LoggerFactory;\n+\n+public final class StackdriverLayoutTest {\n+  private static final org.slf4j.Logger LOGGER =\n+      LoggerFactory.getLogger(StackdriverLayoutTest.class);\n+  private static final ObjectReader OBJECT_READER = new ObjectMapper().reader();\n+  private static final String SERVICE = \"test-service\";\n+  private static final String VERSION = \"test-version\";\n+\n+  @Rule public JUnitSoftAssertions softly = new JUnitSoftAssertions();\n+\n+  private Logger logger;\n+  private PipedInputStream source;\n+  private PipedOutputStream sink;\n+  private OutputStreamAppender appender;\n+\n+  @Before\n+  public void before() throws IOException {\n+    sink = new PipedOutputStream();\n+    source = new PipedInputStream(512 * 1024);\n+    logger = (Logger) LogManager.getLogger();\n+\n+    final var layout =\n+        StackdriverLayout.newBuilder().setServiceName(SERVICE).setServiceVersion(VERSION).build();\n+    appender = createAndStartAppender(layout, sink);\n+    logger.addAppender(appender);\n+\n+    sink.connect(source);\n+    logger.setLevel(Level.DEBUG);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    try {\n+      source.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close source input stream\", e);\n+    }\n+\n+    try {\n+      sink.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close sink output stream\", e);\n+    }\n+\n+    logger.removeAppender(appender);\n+  }\n+\n+  @Test\n+  public void shouldWriteTraceMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.TRACE);\n+\n+    // when\n+    logger.trace(\"Trace message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteDebugMessages() throws IOException {\n+    // given\n+    logger.setLevel(Level.DEBUG);\n+\n+    // when\n+    logger.debug(\"Debug message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteInfoMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.INFO.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteWarningMessage() throws IOException {", "originalCommit": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNjUxMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437606510", "bodyText": "Good point. I could make them as nested, I guess? Or a separate test suite, why not?\nActually, the whole thing here is a good use case for testing with golden files. We don't do this so I wasn't sure if I should introduce this kind of tests, but we still could.", "author": "npepinpe", "createdAt": "2020-06-09T17:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4NjUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA0NTAyMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r438045022", "bodyText": "Yeah, that would be a tighter test, but I also kinda like that each of these tests specific parts (much like TDD tests are written). If something fails, you immediately know what went wrong. Having said that, that might as well be true for golden files.\nAgain, I can also see why you wouldn't want to spend more time on this. So I'm fine either way", "author": "korthout", "createdAt": "2020-06-10T11:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4NjUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4Njg4Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437286886", "bodyText": "why -1?", "author": "korthout", "createdAt": "2020-06-09T09:53:18Z", "path": "util/src/test/java/io/zeebe/util/logging/StackdriverLayoutTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.logging;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import io.zeebe.util.LogUtil;\n+import io.zeebe.util.logging.stackdriver.Severity;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntry;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntryBuilder;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.core.Layout;\n+import org.apache.logging.log4j.core.Logger;\n+import org.apache.logging.log4j.core.appender.OutputStreamAppender;\n+import org.apache.logging.log4j.core.impl.ThrowableProxy;\n+import org.assertj.core.api.InstanceOfAssertFactories;\n+import org.assertj.core.api.JUnitSoftAssertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.slf4j.LoggerFactory;\n+\n+public final class StackdriverLayoutTest {\n+  private static final org.slf4j.Logger LOGGER =\n+      LoggerFactory.getLogger(StackdriverLayoutTest.class);\n+  private static final ObjectReader OBJECT_READER = new ObjectMapper().reader();\n+  private static final String SERVICE = \"test-service\";\n+  private static final String VERSION = \"test-version\";\n+\n+  @Rule public JUnitSoftAssertions softly = new JUnitSoftAssertions();\n+\n+  private Logger logger;\n+  private PipedInputStream source;\n+  private PipedOutputStream sink;\n+  private OutputStreamAppender appender;\n+\n+  @Before\n+  public void before() throws IOException {\n+    sink = new PipedOutputStream();\n+    source = new PipedInputStream(512 * 1024);\n+    logger = (Logger) LogManager.getLogger();\n+\n+    final var layout =\n+        StackdriverLayout.newBuilder().setServiceName(SERVICE).setServiceVersion(VERSION).build();\n+    appender = createAndStartAppender(layout, sink);\n+    logger.addAppender(appender);\n+\n+    sink.connect(source);\n+    logger.setLevel(Level.DEBUG);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    try {\n+      source.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close source input stream\", e);\n+    }\n+\n+    try {\n+      sink.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close sink output stream\", e);\n+    }\n+\n+    logger.removeAppender(appender);\n+  }\n+\n+  @Test\n+  public void shouldWriteTraceMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.TRACE);\n+\n+    // when\n+    logger.trace(\"Trace message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteDebugMessages() throws IOException {\n+    // given\n+    logger.setLevel(Level.DEBUG);\n+\n+    // when\n+    logger.debug(\"Debug message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteInfoMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.INFO.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteWarningMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.WARN);\n+\n+    // when\n+    logger.warn(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.WARNING.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteErrorMessageWithoutException() throws IOException {\n+    // given\n+    logger.setLevel(Level.ERROR);\n+\n+    // when\n+    logger.error(\"Error message {}\", 1);\n+    final var stackTrace = new IllegalStateException(\"\").getStackTrace();\n+    final var source = stackTrace[0];\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .containsEntry(\"severity\", Severity.ERROR.name())\n+        .containsEntry(\"message\", \"Error message 1\")\n+        .containsEntry(\"@type\", StackdriverLogEntry.ERROR_REPORT_TYPE)\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .hasEntrySatisfying(\n+                        StackdriverLogEntryBuilder.ERROR_REPORT_LOCATION_CONTEXT_KEY,\n+                        reportLocation ->\n+                            softly\n+                                .assertThat(reportLocation)\n+                                .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                                .containsEntry(\"file\", source.getFileName())\n+                                .containsEntry(\"function\", source.getMethodName())\n+                                .containsEntry(\"line\", source.getLineNumber() - 1)))", "originalCommit": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNzY1NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437607655", "bodyText": "The source location is the file, method, and line at which the logging statement was called (e.g. logger.info). Since I don't want to hard code the line (so when you add code above you need to update this test), but I also don't know how to get the stack trace other than through an exception (\ud83d\ude48), I ended up creating an exception right after the logging statement, and using its stack trace to figure out the line of my logging statement \ud83d\ude05\nIf you know how to get the line of the logging statement programmatically I'm all ears \ud83d\ude42", "author": "npepinpe", "createdAt": "2020-06-09T17:43:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4Njg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA0NjkyOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r438046929", "bodyText": "I had to use my duckduckgo-foo here, but I found this: https://stackoverflow.com/a/25552778 Thread.currentThread().getStackTrace().", "author": "korthout", "createdAt": "2020-06-10T11:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4Njg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4NzQyOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437287428", "bodyText": "I like that you test for this! \ud83d\udc4d", "author": "korthout", "createdAt": "2020-06-09T09:54:16Z", "path": "util/src/test/java/io/zeebe/util/logging/StackdriverLayoutTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.logging;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import io.zeebe.util.LogUtil;\n+import io.zeebe.util.logging.stackdriver.Severity;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntry;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntryBuilder;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.core.Layout;\n+import org.apache.logging.log4j.core.Logger;\n+import org.apache.logging.log4j.core.appender.OutputStreamAppender;\n+import org.apache.logging.log4j.core.impl.ThrowableProxy;\n+import org.assertj.core.api.InstanceOfAssertFactories;\n+import org.assertj.core.api.JUnitSoftAssertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.slf4j.LoggerFactory;\n+\n+public final class StackdriverLayoutTest {\n+  private static final org.slf4j.Logger LOGGER =\n+      LoggerFactory.getLogger(StackdriverLayoutTest.class);\n+  private static final ObjectReader OBJECT_READER = new ObjectMapper().reader();\n+  private static final String SERVICE = \"test-service\";\n+  private static final String VERSION = \"test-version\";\n+\n+  @Rule public JUnitSoftAssertions softly = new JUnitSoftAssertions();\n+\n+  private Logger logger;\n+  private PipedInputStream source;\n+  private PipedOutputStream sink;\n+  private OutputStreamAppender appender;\n+\n+  @Before\n+  public void before() throws IOException {\n+    sink = new PipedOutputStream();\n+    source = new PipedInputStream(512 * 1024);\n+    logger = (Logger) LogManager.getLogger();\n+\n+    final var layout =\n+        StackdriverLayout.newBuilder().setServiceName(SERVICE).setServiceVersion(VERSION).build();\n+    appender = createAndStartAppender(layout, sink);\n+    logger.addAppender(appender);\n+\n+    sink.connect(source);\n+    logger.setLevel(Level.DEBUG);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    try {\n+      source.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close source input stream\", e);\n+    }\n+\n+    try {\n+      sink.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close sink output stream\", e);\n+    }\n+\n+    logger.removeAppender(appender);\n+  }\n+\n+  @Test\n+  public void shouldWriteTraceMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.TRACE);\n+\n+    // when\n+    logger.trace(\"Trace message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteDebugMessages() throws IOException {\n+    // given\n+    logger.setLevel(Level.DEBUG);\n+\n+    // when\n+    logger.debug(\"Debug message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteInfoMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.INFO.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteWarningMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.WARN);\n+\n+    // when\n+    logger.warn(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.WARNING.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteErrorMessageWithoutException() throws IOException {\n+    // given\n+    logger.setLevel(Level.ERROR);\n+\n+    // when\n+    logger.error(\"Error message {}\", 1);\n+    final var stackTrace = new IllegalStateException(\"\").getStackTrace();\n+    final var source = stackTrace[0];\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .containsEntry(\"severity\", Severity.ERROR.name())\n+        .containsEntry(\"message\", \"Error message 1\")\n+        .containsEntry(\"@type\", StackdriverLogEntry.ERROR_REPORT_TYPE)\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .hasEntrySatisfying(\n+                        StackdriverLogEntryBuilder.ERROR_REPORT_LOCATION_CONTEXT_KEY,\n+                        reportLocation ->\n+                            softly\n+                                .assertThat(reportLocation)\n+                                .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                                .containsEntry(\"file\", source.getFileName())\n+                                .containsEntry(\"function\", source.getMethodName())\n+                                .containsEntry(\"line\", source.getLineNumber() - 1)))\n+        .doesNotContainKey(\"exception\");\n+  }\n+\n+  @Test\n+  public void shouldWriteErrorMessageWithException() throws IOException {\n+    // given\n+    logger.setLevel(Level.ERROR);\n+\n+    // when\n+    final var exception = new ThrowableProxy(new IllegalStateException(\"Failed\"));\n+    logger.error(\"Error message\", exception.getThrowable());\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .containsEntry(\"severity\", Severity.ERROR.name())\n+        .containsEntry(\"message\", \"Error message\")\n+        .containsEntry(\"@type\", StackdriverLogEntry.ERROR_REPORT_TYPE)\n+        .containsEntry(\"exception\", exception.getExtendedStackTraceAsString())\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .doesNotContainKey(\n+                        StackdriverLogEntryBuilder.ERROR_REPORT_LOCATION_CONTEXT_KEY));\n+  }\n+\n+  @Test\n+  public void shouldContainFormattedMessage() throws IOException {\n+    // given\n+    final var expectedMessage = \"This is an ultra message\";\n+\n+    // when\n+    logger.info(\"This is an {} message\", \"ultra\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"message\", expectedMessage);\n+  }\n+\n+  @Test\n+  public void shouldContainTime() throws IOException {\n+    // given\n+    final var lowerBound = Instant.now();\n+\n+    // when\n+    logger.info(\"This is a message\");\n+\n+    // then\n+    final var upperBound = Instant.now();\n+    final var jsonMap = readLoggedEvent();\n+    final var timestampSeconds = ((Number) jsonMap.get(\"timestampSeconds\")).longValue();\n+    final var timestampNanos = ((Number) jsonMap.get(\"timestampNanos\")).longValue();\n+\n+    softly\n+        .assertThat(timestampSeconds)\n+        .isBetween(lowerBound.getEpochSecond(), upperBound.getEpochSecond());\n+    softly\n+        .assertThat(timestampNanos)\n+        .isBetween((long) lowerBound.getNano(), (long) upperBound.getNano());\n+  }\n+\n+  @Test\n+  public void shouldTerminateAllEntriesWithALineSeparator() throws IOException {\n+    // given\n+    final var lineSeparator = System.lineSeparator();\n+\n+    // when\n+    logger.info(\"Should be terminated with a line separator\");\n+\n+    // then\n+    final var rawOutput = source.readNBytes(source.available());\n+    softly.assertThat(new String(rawOutput)).endsWith(lineSeparator);\n+  }\n+\n+  @Test\n+  public void shouldContainSourceLocation() throws IOException {\n+    // when\n+    logger.info(\"Message\");\n+    final var stackTrace = new IllegalStateException(\"\").getStackTrace();\n+    final var source = stackTrace[0];\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .hasEntrySatisfying(\n+            \"logging.googleapis.com/sourceLocation\",\n+            sourceLocation ->\n+                softly\n+                    .assertThat(sourceLocation)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .containsEntry(\"file\", source.getFileName())\n+                    .containsEntry(\"function\", source.getMethodName())\n+                    .containsEntry(\"line\", source.getLineNumber() - 1));\n+  }\n+\n+  @Test\n+  public void shouldContainServiceContext() throws IOException {\n+    // when\n+    logger.info(\"Message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .hasEntrySatisfying(\n+            \"serviceContext\",\n+            serviceContext ->\n+                softly\n+                    .assertThat(serviceContext)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .containsEntry(\"service\", SERVICE)\n+                    .containsEntry(\"version\", VERSION));\n+  }\n+\n+  @Test\n+  public void shouldContainContext() throws IOException {\n+    // given\n+    final var expectedContext = Map.of(\"foo\", \"bar\", \"baz\", \"boz\");\n+\n+    // when\n+    LogUtil.doWithMDC(expectedContext, () -> logger.info(\"Message\"));\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .containsAllEntriesOf(expectedContext));\n+  }\n+\n+  @Test\n+  public void shouldContainThreadInfo() throws IOException {\n+    // given\n+    final var currentThread = Thread.currentThread();\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .containsEntry(\"thread\", currentThread.getName())\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .containsEntry(\"threadName\", currentThread.getName())\n+                    .containsEntry(\n+                        \"threadId\",\n+                        (int) currentThread.getId()) // Jackson will parse small numbers as integers\n+                    .containsEntry(\"threadPriority\", currentThread.getPriority()));\n+  }\n+\n+  @Test\n+  public void shouldContainLogger() throws IOException {\n+    // given\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .containsEntry(\"logger\", logger.getName())\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .containsEntry(\"loggerName\", logger.getName()));\n+  }\n+\n+  @Deprecated(since = \"0.24.0\", forRemoval = true)\n+  @Test\n+  public void shouldBeBackwardsCompatibleWithStackdriverJSONLayout() throws IOException {", "originalCommit": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3e6a6840c64c6f8be279268d4a871e8288d19b19", "url": "https://github.com/camunda-cloud/zeebe/commit/3e6a6840c64c6f8be279268d4a871e8288d19b19", "message": "chore(util): introduce StackdriverLayout\n\n- adds a Stackdriver log4j2 layout, configurable via a layout plugin\n  builder\n- supports setting severity, context, source location, and the error\n  report type format\n- make ZbLogger location aware; if the delegate logger given to ZbLogger\n  is location aware, then ZbLogger will properly pass the correct logger\n  FQCN (itself) to ensure that the LogEvent source location is properly\n  computed", "committedDate": "2020-06-10T15:04:17Z", "type": "commit"}, {"oid": "3e6a6840c64c6f8be279268d4a871e8288d19b19", "url": "https://github.com/camunda-cloud/zeebe/commit/3e6a6840c64c6f8be279268d4a871e8288d19b19", "message": "chore(util): introduce StackdriverLayout\n\n- adds a Stackdriver log4j2 layout, configurable via a layout plugin\n  builder\n- supports setting severity, context, source location, and the error\n  report type format\n- make ZbLogger location aware; if the delegate logger given to ZbLogger\n  is location aware, then ZbLogger will properly pass the correct logger\n  FQCN (itself) to ensure that the LogEvent source location is properly\n  computed", "committedDate": "2020-06-10T15:04:17Z", "type": "forcePushed"}]}