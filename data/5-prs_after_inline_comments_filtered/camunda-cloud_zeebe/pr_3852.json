{"pr_number": 3852, "pr_title": "chore(broker): add top level health monitor", "pr_createdAt": "2020-02-17T08:34:52Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/3852", "timeline": [{"oid": "5a3ce739e6afb47107b821aaa1f8d624c83ea573", "url": "https://github.com/camunda-cloud/zeebe/commit/5a3ce739e6afb47107b821aaa1f8d624c83ea573", "message": "chore(broker): add top level health monitor", "committedDate": "2020-02-17T09:14:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzNDk3OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380934979", "bodyText": "Let's maybe rename this to monitoring server now that we do a bunch of things here?", "author": "npepinpe", "createdAt": "2020-02-18T21:07:14Z", "path": "broker/src/main/java/io/zeebe/broker/Broker.java", "diffHunk": "@@ -257,8 +258,7 @@ private AutoCloseable topologyManagerStep(\n \n   private AutoCloseable metricsServerStep(", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzNTI5Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380935296", "bodyText": "Can this be private?", "author": "npepinpe", "createdAt": "2020-02-18T21:08:00Z", "path": "broker/src/main/java/io/zeebe/broker/system/monitoring/BrokerHealthCheckService.java", "diffHunk": "@@ -24,18 +28,36 @@\n \n public final class BrokerHealthCheckService extends Actor implements PartitionListener {\n \n+  public static final String PARTITION_COMPONENT_NAME_FORMAT = \"Partition-%d\";", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzNjY4Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380936683", "bodyText": "I think this can be private as well", "author": "npepinpe", "createdAt": "2020-02-18T21:10:38Z", "path": "broker/src/main/java/io/zeebe/broker/system/monitoring/BrokerHealthCheckService.java", "diffHunk": "@@ -83,4 +105,28 @@ private void initializePartitionInstallStatus() {\n   public String getName() {\n     return actorName;\n   }\n+\n+  @Override\n+  protected void onActorStarted() {\n+    healthMonitor.startMonitoring();\n+  }\n+\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzNzA0OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380937048", "bodyText": "Let's use the expression lambda syntax where possible (e.g. if a single line, no need to use brackets {)", "author": "npepinpe", "createdAt": "2020-02-18T21:11:18Z", "path": "broker/src/main/java/io/zeebe/broker/system/monitoring/BrokerHealthCheckService.java", "diffHunk": "@@ -83,4 +105,28 @@ private void initializePartitionInstallStatus() {\n   public String getName() {\n     return actorName;\n   }\n+\n+  @Override\n+  protected void onActorStarted() {\n+    healthMonitor.startMonitoring();\n+  }\n+\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.call(\n+        () -> {", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzNzMzMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380937331", "bodyText": "Since we don't expect any results, we can use actor.run", "author": "npepinpe", "createdAt": "2020-02-18T21:11:48Z", "path": "broker/src/main/java/io/zeebe/broker/system/monitoring/BrokerHealthCheckService.java", "diffHunk": "@@ -83,4 +105,28 @@ private void initializePartitionInstallStatus() {\n   public String getName() {\n     return actorName;\n   }\n+\n+  @Override\n+  protected void onActorStarted() {\n+    healthMonitor.startMonitoring();\n+  }\n+\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.call(", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzNzQ0MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380937441", "bodyText": "I think this isn't called?", "author": "npepinpe", "createdAt": "2020-02-18T21:12:01Z", "path": "broker/src/main/java/io/zeebe/broker/system/monitoring/BrokerHealthCheckService.java", "diffHunk": "@@ -83,4 +105,28 @@ private void initializePartitionInstallStatus() {\n   public String getName() {\n     return actorName;\n   }\n+\n+  @Override\n+  protected void onActorStarted() {\n+    healthMonitor.startMonitoring();\n+  }\n+\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.call(\n+        () -> {\n+          healthMonitor.registerComponent(componentName, component);\n+        });\n+  }\n+\n+  public void registerMonitoredPartition(final int partitionId, final HealthMonitorable partition) {\n+    final String componentName = String.format(PARTITION_COMPONENT_NAME_FORMAT, partitionId);\n+    registerComponent(componentName, partition);\n+  }\n+\n+  public HealthStatus getBrokerHealth() {", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzNzU2NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380937564", "bodyText": "I think this can be package-private, as it's only called by a sibling class?", "author": "npepinpe", "createdAt": "2020-02-18T21:12:19Z", "path": "broker/src/main/java/io/zeebe/broker/system/monitoring/BrokerHealthCheckService.java", "diffHunk": "@@ -24,18 +28,36 @@\n \n public final class BrokerHealthCheckService extends Actor implements PartitionListener {\n \n+  public static final String PARTITION_COMPONENT_NAME_FORMAT = \"Partition-%d\";\n   private static final Logger LOG = Loggers.SYSTEM_LOGGER;\n   private final Atomix atomix;\n   private final String actorName;\n   private Map<Integer, Boolean> partitionInstallStatus;\n   /* set to true when all partitions are installed. Once set to true, it is never\n   changed. */\n   private volatile boolean brokerStarted = false;\n+  private final HealthMonitor healthMonitor;\n \n   public BrokerHealthCheckService(final BrokerInfo localBroker, final Atomix atomix) {\n     this.atomix = atomix;\n     this.actorName = buildActorName(localBroker.getNodeId(), \"HealthCheckService\");\n+    this.healthMonitor = new CriticalComponentsHealthMonitor(actor, LOG);\n     initializePartitionInstallStatus();\n+    initializePartitionHealthStatus();\n+  }\n+\n+  private void initializePartitionHealthStatus() {\n+    final RaftPartitionGroup partitionGroup =\n+        (RaftPartitionGroup) atomix.getPartitionService().getPartitionGroup(GROUP_NAME);\n+    final MemberId nodeId = atomix.getMembershipService().getLocalMember().id();\n+\n+    partitionGroup.getPartitions().stream()\n+        .filter(partition -> partition.members().contains(nodeId))\n+        .map(partition -> partition.id().id())\n+        .forEach(\n+            partitionId ->\n+                healthMonitor.monitorComponent(\n+                    String.format(PARTITION_COMPONENT_NAME_FORMAT, partitionId)));\n   }\n \n   public boolean isBrokerReady() {", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzODM0NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380938344", "bodyText": "Can you elaborate on why the partition itself does not implement FailureListener?", "author": "npepinpe", "createdAt": "2020-02-18T21:13:42Z", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -533,17 +547,27 @@ public void onActorStarting() {\n                 this.logStream = log;\n                 atomixRaftPartition.getServer().addCommitListener(this);\n                 atomixRaftPartition.addRoleChangeListener(this);\n+                onRecovered();\n                 onRoleChange(atomixRaftPartition.getRole(), atomixRaftPartition.term());\n               } else {\n                 LOG.error(\n                     \"Failed to install log stream service for partition {}\",\n                     atomixRaftPartition.id().id(),\n                     error);\n                 actor.close();\n+                onFailure();\n               }\n             });\n   }\n \n+  @Override\n+  protected void onActorStarted() {\n+    criticalComponentsHealthMonitor.startMonitoring();\n+    criticalComponentsHealthMonitor.addFailureListener(\n+        FailureListener.withListeners(", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE1NjYxOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r381156618", "bodyText": "That is actually better. Will update.", "author": "deepthidevaki", "createdAt": "2020-02-19T09:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzODM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzODczMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380938733", "bodyText": "Same, as we expect no return value we can use actor.run", "author": "npepinpe", "createdAt": "2020-02-18T21:14:38Z", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -569,4 +593,28 @@ public void close() {\n \n     super.close();\n   }\n+\n+  private void onFailure() {\n+    healthStatus.set(HealthStatus.UNHEALTHY);\n+    if (failureListener != null) {\n+      failureListener.onFailure();\n+    }\n+  }\n+\n+  private void onRecovered() {\n+    healthStatus.set(HealthStatus.HEALTHY);\n+    if (failureListener != null) {\n+      failureListener.onRecovered();\n+    }\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus.get();\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.call(() -> this.failureListener = failureListener);", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzOTQ2Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380939467", "bodyText": "Do we expect this to be called from a non-actor? If no then we can get rid of the AtomicReference and simply use actor.call and return an ActorFuture<HealthStatus>.", "author": "npepinpe", "createdAt": "2020-02-18T21:16:13Z", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -569,4 +593,28 @@ public void close() {\n \n     super.close();\n   }\n+\n+  private void onFailure() {\n+    healthStatus.set(HealthStatus.UNHEALTHY);\n+    if (failureListener != null) {\n+      failureListener.onFailure();\n+    }\n+  }\n+\n+  private void onRecovered() {\n+    healthStatus.set(HealthStatus.HEALTHY);\n+    if (failureListener != null) {\n+      failureListener.onRecovered();\n+    }\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus.get();", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTEzOTA2MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r381139060", "bodyText": "For the first iteration, I thought it was easier to implement sync api so that implementation of health monitors is straight forward. But I also think that we would need async calls in future, especially for some modules to detect if they are stuck. Do you think we should immediately go with async api for getHealthStatus?", "author": "deepthidevaki", "createdAt": "2020-02-19T08:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzOTQ2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE0OTE4Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r381149183", "bodyText": "We could keep it sync and join against the result for now as well, e.g.\nreturn actor.call(() -> healthStatus).join();\nThis means that we can't call this when the actor is shutting down/shut down, not sure about the impact", "author": "npepinpe", "createdAt": "2020-02-19T08:49:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzOTQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MDE3Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380940177", "bodyText": "Could it be an issue to run the monitor in the same an actor which is also doing something else (considering we have no supervisor actors yet)? I guess the ZeebePartition one doesn't really do much so it's probably safe there, but could it be an issue later?", "author": "npepinpe", "createdAt": "2020-02-18T21:17:39Z", "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private final AtomicReference<HealthStatus> healthStatus = new AtomicReference<>();\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTEzOTk3Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r381139972", "bodyText": "I think it won't be an issue. Because this health monitor is monitoring sub components of this actor not the actor itself. And there is another monitor monitoring this actor. Do you see any problems?", "author": "deepthidevaki", "createdAt": "2020-02-19T08:30:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MDE3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE1MDE5MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r381150191", "bodyText": "I was thinking, if we have a bad/slow actor, and it has to monitor/poll itself as well, then perhaps the \"poll\" never happens (e.g. the actor is stuck in a run-until-done loop)?", "author": "npepinpe", "createdAt": "2020-02-19T08:52:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MDE3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MDM0Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380940343", "bodyText": "I think null is the default value so it's not necessary to initialize it.", "author": "npepinpe", "createdAt": "2020-02-18T21:18:00Z", "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private final AtomicReference<HealthStatus> healthStatus = new AtomicReference<>();\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;\n+    this.log = log;\n+    this.failureListener = null;", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MDk2Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380940963", "bodyText": "Same as others (and below), we can probably use actor.run", "author": "npepinpe", "createdAt": "2020-02-18T21:19:16Z", "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private final AtomicReference<HealthStatus> healthStatus = new AtomicReference<>();\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;\n+    this.log = log;\n+    this.failureListener = null;\n+  }\n+\n+  public void startMonitoring() {\n+    actor.runAtFixedRate(HEALTH_MONITORING_PERIOD, this::updateHealth);\n+  }\n+\n+  @Override\n+  public void monitorComponent(final String componentName) {\n+    actor.run(() -> componentHealth.put(componentName, HealthStatus.UNHEALTHY));\n+  }\n+\n+  @Override\n+  public void removeComponent(final String componentName) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.remove(componentName);\n+          componentHealth.remove(componentName);\n+        });\n+  }\n+\n+  @Override\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.put(componentName, component);\n+          component.addFailureListener(\n+              FailureListener.withListeners(\n+                  () -> onComponentFailure(componentName),\n+                  () -> onComponentRecovered(componentName)));\n+          componentHealth.put(componentName, component.getHealthStatus());\n+        });\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus.get();\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.run(() -> this.failureListener = failureListener);\n+  }\n+\n+  private void onComponentFailure(final String componentName) {\n+    actor.call(", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MTI2Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380941267", "bodyText": "You can call forEach directly on a set, e.g. componentHealth.keySet().forEach(", "author": "npepinpe", "createdAt": "2020-02-18T21:19:58Z", "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private final AtomicReference<HealthStatus> healthStatus = new AtomicReference<>();\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;\n+    this.log = log;\n+    this.failureListener = null;\n+  }\n+\n+  public void startMonitoring() {\n+    actor.runAtFixedRate(HEALTH_MONITORING_PERIOD, this::updateHealth);\n+  }\n+\n+  @Override\n+  public void monitorComponent(final String componentName) {\n+    actor.run(() -> componentHealth.put(componentName, HealthStatus.UNHEALTHY));\n+  }\n+\n+  @Override\n+  public void removeComponent(final String componentName) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.remove(componentName);\n+          componentHealth.remove(componentName);\n+        });\n+  }\n+\n+  @Override\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.put(componentName, component);\n+          component.addFailureListener(\n+              FailureListener.withListeners(\n+                  () -> onComponentFailure(componentName),\n+                  () -> onComponentRecovered(componentName)));\n+          componentHealth.put(componentName, component.getHealthStatus());\n+        });\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus.get();\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.run(() -> this.failureListener = failureListener);\n+  }\n+\n+  private void onComponentFailure(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+          reCalculateHealth();\n+        });\n+  }\n+\n+  private void onComponentRecovered(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+        });\n+  }\n+\n+  private void updateHealth() {\n+    componentHealth.keySet().stream()", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MTYzMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380941630", "bodyText": "Not sure if the re is necessary, it's the same behaviour whether we calculate for the first time or not?", "author": "npepinpe", "createdAt": "2020-02-18T21:20:46Z", "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private final AtomicReference<HealthStatus> healthStatus = new AtomicReference<>();\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;\n+    this.log = log;\n+    this.failureListener = null;\n+  }\n+\n+  public void startMonitoring() {\n+    actor.runAtFixedRate(HEALTH_MONITORING_PERIOD, this::updateHealth);\n+  }\n+\n+  @Override\n+  public void monitorComponent(final String componentName) {\n+    actor.run(() -> componentHealth.put(componentName, HealthStatus.UNHEALTHY));\n+  }\n+\n+  @Override\n+  public void removeComponent(final String componentName) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.remove(componentName);\n+          componentHealth.remove(componentName);\n+        });\n+  }\n+\n+  @Override\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.put(componentName, component);\n+          component.addFailureListener(\n+              FailureListener.withListeners(\n+                  () -> onComponentFailure(componentName),\n+                  () -> onComponentRecovered(componentName)));\n+          componentHealth.put(componentName, component.getHealthStatus());\n+        });\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus.get();\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.run(() -> this.failureListener = failureListener);\n+  }\n+\n+  private void onComponentFailure(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+          reCalculateHealth();\n+        });\n+  }\n+\n+  private void onComponentRecovered(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+        });\n+  }\n+\n+  private void updateHealth() {\n+    componentHealth.keySet().stream()\n+        .forEach(component -> componentHealth.put(component, getHealth(component)));\n+    reCalculateHealth();\n+  }\n+\n+  private void reCalculateHealth() {", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NDU5Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380944597", "bodyText": "Should we notify the listener if we go from UNHEALTHY to UNHEALTHY again? Not saying we shouldn't, I'm simply not sure what we want to do - notify of every new failure, notify only of status changes?\nShould we notify that we recovered?", "author": "npepinpe", "createdAt": "2020-02-18T21:26:57Z", "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private final AtomicReference<HealthStatus> healthStatus = new AtomicReference<>();\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;\n+    this.log = log;\n+    this.failureListener = null;\n+  }\n+\n+  public void startMonitoring() {\n+    actor.runAtFixedRate(HEALTH_MONITORING_PERIOD, this::updateHealth);\n+  }\n+\n+  @Override\n+  public void monitorComponent(final String componentName) {\n+    actor.run(() -> componentHealth.put(componentName, HealthStatus.UNHEALTHY));\n+  }\n+\n+  @Override\n+  public void removeComponent(final String componentName) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.remove(componentName);\n+          componentHealth.remove(componentName);\n+        });\n+  }\n+\n+  @Override\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.put(componentName, component);\n+          component.addFailureListener(\n+              FailureListener.withListeners(\n+                  () -> onComponentFailure(componentName),\n+                  () -> onComponentRecovered(componentName)));\n+          componentHealth.put(componentName, component.getHealthStatus());\n+        });\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus.get();\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.run(() -> this.failureListener = failureListener);\n+  }\n+\n+  private void onComponentFailure(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+          reCalculateHealth();\n+        });\n+  }\n+\n+  private void onComponentRecovered(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+        });\n+  }\n+\n+  private void updateHealth() {\n+    componentHealth.keySet().stream()\n+        .forEach(component -> componentHealth.put(component, getHealth(component)));\n+    reCalculateHealth();\n+  }\n+\n+  private void reCalculateHealth() {\n+    final boolean healthy =\n+        componentHealth.values().stream()\n+            .allMatch(healthStatus -> healthStatus == HealthStatus.HEALTHY);\n+    healthStatus.set(healthy ? HealthStatus.HEALTHY : HealthStatus.UNHEALTHY);\n+    if (!healthy) {", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE1NTcxNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r381155715", "bodyText": "You are right. We should notify when the status changes.", "author": "deepthidevaki", "createdAt": "2020-02-19T09:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NDU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NDc2MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380944760", "bodyText": "Alternative impl:\nfinal var status = componentHealth.containsValue(HealthStatus.UNHEALTHY) ? HealthStatus.UNHEALTHY : HealthStatus.HEALTHY;\n    final var previousStatus = healthStatus.getAndSet(status);\n\n    if (failureListener != null && previousStatus != status) {\n      switch (status) {\n        case HEALTHY:\n          failureListener.onRecovered();\n          break;\n        case UNHEALTHY:\n          failureListener.onFailure();\n          break;\n      }\n    }", "author": "npepinpe", "createdAt": "2020-02-18T21:27:17Z", "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private final AtomicReference<HealthStatus> healthStatus = new AtomicReference<>();\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;\n+    this.log = log;\n+    this.failureListener = null;\n+  }\n+\n+  public void startMonitoring() {\n+    actor.runAtFixedRate(HEALTH_MONITORING_PERIOD, this::updateHealth);\n+  }\n+\n+  @Override\n+  public void monitorComponent(final String componentName) {\n+    actor.run(() -> componentHealth.put(componentName, HealthStatus.UNHEALTHY));\n+  }\n+\n+  @Override\n+  public void removeComponent(final String componentName) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.remove(componentName);\n+          componentHealth.remove(componentName);\n+        });\n+  }\n+\n+  @Override\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.put(componentName, component);\n+          component.addFailureListener(\n+              FailureListener.withListeners(\n+                  () -> onComponentFailure(componentName),\n+                  () -> onComponentRecovered(componentName)));\n+          componentHealth.put(componentName, component.getHealthStatus());\n+        });\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus.get();\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.run(() -> this.failureListener = failureListener);\n+  }\n+\n+  private void onComponentFailure(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+          reCalculateHealth();\n+        });\n+  }\n+\n+  private void onComponentRecovered(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+        });\n+  }\n+\n+  private void updateHealth() {\n+    componentHealth.keySet().stream()\n+        .forEach(component -> componentHealth.put(component, getHealth(component)));\n+    reCalculateHealth();\n+  }\n+\n+  private void reCalculateHealth() {", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NTg0NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380945845", "bodyText": "Is this possible? It would be a bug if it happened, no? Then we probably want to log when it is actually null.", "author": "npepinpe", "createdAt": "2020-02-18T21:29:28Z", "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private final AtomicReference<HealthStatus> healthStatus = new AtomicReference<>();\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;\n+    this.log = log;\n+    this.failureListener = null;\n+  }\n+\n+  public void startMonitoring() {\n+    actor.runAtFixedRate(HEALTH_MONITORING_PERIOD, this::updateHealth);\n+  }\n+\n+  @Override\n+  public void monitorComponent(final String componentName) {\n+    actor.run(() -> componentHealth.put(componentName, HealthStatus.UNHEALTHY));\n+  }\n+\n+  @Override\n+  public void removeComponent(final String componentName) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.remove(componentName);\n+          componentHealth.remove(componentName);\n+        });\n+  }\n+\n+  @Override\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.put(componentName, component);\n+          component.addFailureListener(\n+              FailureListener.withListeners(\n+                  () -> onComponentFailure(componentName),\n+                  () -> onComponentRecovered(componentName)));\n+          componentHealth.put(componentName, component.getHealthStatus());\n+        });\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus.get();\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.run(() -> this.failureListener = failureListener);\n+  }\n+\n+  private void onComponentFailure(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+          reCalculateHealth();\n+        });\n+  }\n+\n+  private void onComponentRecovered(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+        });\n+  }\n+\n+  private void updateHealth() {\n+    componentHealth.keySet().stream()\n+        .forEach(component -> componentHealth.put(component, getHealth(component)));\n+    reCalculateHealth();\n+  }\n+\n+  private void reCalculateHealth() {\n+    final boolean healthy =\n+        componentHealth.values().stream()\n+            .allMatch(healthStatus -> healthStatus == HealthStatus.HEALTHY);\n+    healthStatus.set(healthy ? HealthStatus.HEALTHY : HealthStatus.UNHEALTHY);\n+    if (!healthy) {\n+      notifyFailureListener();\n+    }\n+  }\n+\n+  private void notifyFailureListener() {\n+    if (this.failureListener != null) {\n+      failureListener.onFailure();\n+    }\n+  }\n+\n+  private HealthStatus getHealth(final String componentName) {\n+    final HealthMonitorable component = monitoredComponents.get(componentName);\n+    if (component != null) {", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE1MjkxNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r381152915", "bodyText": "You can add the name of the component to monitor before the component is available. For eg:- BrokerHealthCheckService knows about all partitions before the partitions are registered and ready to monitor.", "author": "deepthidevaki", "createdAt": "2020-02-19T08:57:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NTg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NjI1Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380946252", "bodyText": "Considering this is a public interface that might be implemented by others, it might make sense to document the intent and its contract(s).", "author": "npepinpe", "createdAt": "2020-02-18T21:30:17Z", "path": "util/src/main/java/io/zeebe/util/health/FailureListener.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+public interface FailureListener {", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NzY1Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380947652", "bodyText": "What is the advantage of creating an anonymous class from two runnables over a class implementing this interface?\npublic class MySuperListener implements FailureListener {\n  @Override\n  public void onFailure() {\n    // do stuff\n  }\n  \n  @Override\n  public void onRecovered() {\n    // do other stuff\n  }\n}\nIf the issue is with name collisions, we can make the name more specific - call the interface HealthMonitorableListener and have the method be onHealthMonitorableFailure() and onHealthMonitorableRecovery().", "author": "npepinpe", "createdAt": "2020-02-18T21:33:07Z", "path": "util/src/main/java/io/zeebe/util/health/FailureListener.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+public interface FailureListener {\n+  void onFailure();\n+\n+  void onRecovered();\n+\n+  static FailureListener withListeners(final Runnable onFailure, final Runnable onRecovered) {", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0ODA2NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380948064", "bodyText": "Could it make sense to pass the failure itself (e.g. Throwable I guess?), and the component which triggered this? That way implementations can be react on different failures, and also be reused for different components.", "author": "npepinpe", "createdAt": "2020-02-18T21:33:53Z", "path": "util/src/main/java/io/zeebe/util/health/FailureListener.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+public interface FailureListener {\n+  void onFailure();", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE1NDkyMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r381154922", "bodyText": "Since we use this only to report failures, I think this is enough for now. It would be useful if we are reacting to failures. But now I am not sure what information is needed or how we will react to them. I believe the interface will change anyway in future.", "author": "deepthidevaki", "createdAt": "2020-02-19T09:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0ODA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0ODQ1Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380948453", "bodyText": "I like this - however it seems some of the documentation is missing?", "author": "npepinpe", "createdAt": "2020-02-18T21:34:40Z", "path": "util/src/main/java/io/zeebe/util/health/HealthMonitor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+/**\n+ * A HealthMonitor keeps tracks of all components it should monitor and calculates aggregate health\n+ * status.\n+ */\n+public interface HealthMonitor extends HealthMonitorable {", "originalCommit": "79989c8c3a2fc8b0365ee393458d582cf2b74849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e52e2a93f74698ce549fe5e952866f3f224965e7", "url": "https://github.com/camunda-cloud/zeebe/commit/e52e2a93f74698ce549fe5e952866f3f224965e7", "message": "chore(broker): review comment", "committedDate": "2020-02-19T12:05:09Z", "type": "forcePushed"}, {"oid": "5f8d8d3972db5e3484e23a07f374957daa88bd6b", "url": "https://github.com/camunda-cloud/zeebe/commit/5f8d8d3972db5e3484e23a07f374957daa88bd6b", "message": "chore(broker): review comments", "committedDate": "2020-02-19T13:29:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkxMTYxMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r381911613", "bodyText": "Can we also add the TODO comment pointing to the follow up issue where we can remove this (since we will use the HTTP endpoint?).", "author": "npepinpe", "createdAt": "2020-02-20T10:28:03Z", "path": "broker/src/main/java/io/zeebe/broker/Broker.java", "diffHunk": "@@ -117,6 +118,13 @@ public void addPartitionListener(final PartitionListener listener) {\n     return startFuture;\n   }\n \n+  public boolean isHealthy() {", "originalCommit": "5f8d8d3972db5e3484e23a07f374957daa88bd6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkxMTkwNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r381911907", "bodyText": "Or would it make sense for the Broker to also be HealthMonitorable? \ud83e\udd14", "author": "npepinpe", "createdAt": "2020-02-20T10:28:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkxMTYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkyMjQ0OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r381922448", "bodyText": "Nit: it's maybe more read-able to express this as a guard clause, in which case you'd want to have the branch for the invariant and not the \"common\" case.\ne.g.\nif (!isBrokerReady()) {\n  return HealthStatus.UNHEALTHY;\n}\n\nreturn healthMonitor.getHealthStatus();", "author": "npepinpe", "createdAt": "2020-02-20T10:48:29Z", "path": "broker/src/main/java/io/zeebe/broker/system/monitoring/BrokerHealthCheckService.java", "diffHunk": "@@ -83,4 +105,29 @@ private void initializePartitionInstallStatus() {\n   public String getName() {\n     return actorName;\n   }\n+\n+  @Override\n+  protected void onActorStarted() {\n+    healthMonitor.startMonitoring();\n+  }\n+\n+  private void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.run(() -> healthMonitor.registerComponent(componentName, component));\n+  }\n+\n+  public void registerMonitoredPartition(final int partitionId, final HealthMonitorable partition) {\n+    final String componentName = String.format(PARTITION_COMPONENT_NAME_FORMAT, partitionId);\n+    registerComponent(componentName, partition);\n+  }\n+\n+  public boolean isBrokerHealthy() {\n+    return !actor.isClosed() && getBrokerHealth() == HealthStatus.HEALTHY;\n+  }\n+\n+  private HealthStatus getBrokerHealth() {\n+    if (isBrokerReady()) {", "originalCommit": "5f8d8d3972db5e3484e23a07f374957daa88bd6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkyMzcxMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r381923712", "bodyText": "Here and above, I would add a warn logging - in the case we ever add more health statuses, then we'd immediately be aware of it.", "author": "npepinpe", "createdAt": "2020-02-20T10:50:53Z", "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private volatile HealthStatus healthStatus = HealthStatus.UNHEALTHY;\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;\n+    this.log = log;\n+  }\n+\n+  public void startMonitoring() {\n+    actor.runAtFixedRate(HEALTH_MONITORING_PERIOD, this::updateHealth);\n+  }\n+\n+  @Override\n+  public void monitorComponent(final String componentName) {\n+    actor.run(() -> componentHealth.put(componentName, HealthStatus.UNHEALTHY));\n+  }\n+\n+  @Override\n+  public void removeComponent(final String componentName) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.remove(componentName);\n+          componentHealth.remove(componentName);\n+        });\n+  }\n+\n+  @Override\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.put(componentName, component);\n+          component.addFailureListener(new ComponentFailureListener(componentName));\n+          componentHealth.put(componentName, component.getHealthStatus());\n+          calculateHealth();\n+        });\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus;\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.run(() -> this.failureListener = failureListener);\n+  }\n+\n+  private void onComponentFailure(final String componentName) {\n+    actor.run(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+          calculateHealth();\n+        });\n+  }\n+\n+  private void onComponentRecovered(final String componentName) {\n+    actor.run(\n+        () -> {\n+          log.error(\"{} recovered, marking it as healthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.HEALTHY);\n+        });\n+  }\n+\n+  private void updateHealth() {\n+    componentHealth\n+        .keySet()\n+        .forEach(component -> componentHealth.put(component, getHealth(component)));\n+    calculateHealth();\n+  }\n+\n+  private void calculateHealth() {\n+    final var status =\n+        componentHealth.containsValue(HealthStatus.UNHEALTHY)\n+            ? HealthStatus.UNHEALTHY\n+            : HealthStatus.HEALTHY;\n+    final var previousStatus = healthStatus;\n+    healthStatus = status;\n+\n+    if (failureListener != null && previousStatus != status) {\n+      switch (status) {\n+        case HEALTHY:\n+          failureListener.onRecovered();\n+          break;\n+        case UNHEALTHY:\n+          failureListener.onFailure();\n+          break;\n+        default:", "originalCommit": "5f8d8d3972db5e3484e23a07f374957daa88bd6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkyNDUwMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r381924501", "bodyText": "I guess here would have been a good case for us to actually have the failure listener propagate the component has argument on failure and on recovered. What do you think? Then you don't need a component listener for each component, the monitor can be a single listener.\nI'm fine with this implementation for the first iteration, but we could think about it.", "author": "npepinpe", "createdAt": "2020-02-20T10:52:27Z", "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private volatile HealthStatus healthStatus = HealthStatus.UNHEALTHY;\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;\n+    this.log = log;\n+  }\n+\n+  public void startMonitoring() {\n+    actor.runAtFixedRate(HEALTH_MONITORING_PERIOD, this::updateHealth);\n+  }\n+\n+  @Override\n+  public void monitorComponent(final String componentName) {\n+    actor.run(() -> componentHealth.put(componentName, HealthStatus.UNHEALTHY));\n+  }\n+\n+  @Override\n+  public void removeComponent(final String componentName) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.remove(componentName);\n+          componentHealth.remove(componentName);\n+        });\n+  }\n+\n+  @Override\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.put(componentName, component);\n+          component.addFailureListener(new ComponentFailureListener(componentName));\n+          componentHealth.put(componentName, component.getHealthStatus());\n+          calculateHealth();\n+        });\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus;\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.run(() -> this.failureListener = failureListener);\n+  }\n+\n+  private void onComponentFailure(final String componentName) {\n+    actor.run(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+          calculateHealth();\n+        });\n+  }\n+\n+  private void onComponentRecovered(final String componentName) {\n+    actor.run(\n+        () -> {\n+          log.error(\"{} recovered, marking it as healthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.HEALTHY);\n+        });\n+  }\n+\n+  private void updateHealth() {\n+    componentHealth\n+        .keySet()\n+        .forEach(component -> componentHealth.put(component, getHealth(component)));\n+    calculateHealth();\n+  }\n+\n+  private void calculateHealth() {\n+    final var status =\n+        componentHealth.containsValue(HealthStatus.UNHEALTHY)\n+            ? HealthStatus.UNHEALTHY\n+            : HealthStatus.HEALTHY;\n+    final var previousStatus = healthStatus;\n+    healthStatus = status;\n+\n+    if (failureListener != null && previousStatus != status) {\n+      switch (status) {\n+        case HEALTHY:\n+          failureListener.onRecovered();\n+          break;\n+        case UNHEALTHY:\n+          failureListener.onFailure();\n+          break;\n+        default:\n+          break;\n+      }\n+    }\n+  }\n+\n+  private HealthStatus getHealth(final String componentName) {\n+    final HealthMonitorable component = monitoredComponents.get(componentName);\n+    if (component != null) {\n+      return component.getHealthStatus();\n+    }\n+    return HealthStatus.UNHEALTHY;\n+  }\n+\n+  class ComponentFailureListener implements FailureListener {", "originalCommit": "5f8d8d3972db5e3484e23a07f374957daa88bd6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "efef34a467d82adeca68ce2003d6a081502576a6", "url": "https://github.com/camunda-cloud/zeebe/commit/efef34a467d82adeca68ce2003d6a081502576a6", "message": "chore(broker): add top level health monitor", "committedDate": "2020-02-24T09:15:44Z", "type": "commit"}, {"oid": "efef34a467d82adeca68ce2003d6a081502576a6", "url": "https://github.com/camunda-cloud/zeebe/commit/efef34a467d82adeca68ce2003d6a081502576a6", "message": "chore(broker): add top level health monitor", "committedDate": "2020-02-24T09:15:44Z", "type": "forcePushed"}]}