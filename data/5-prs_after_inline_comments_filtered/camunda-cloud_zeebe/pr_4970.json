{"pr_number": 4970, "pr_title": "Introduces a basic rolling upgrade integration test", "pr_createdAt": "2020-07-14T16:37:19Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4970", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU0MzgxMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4970#discussion_r454543813", "bodyText": "We probably also want to assert the version right?", "author": "Zelldon", "createdAt": "2020-07-14T18:02:49Z", "path": "upgrade-tests/src/test/java/io/zeebe/test/RollingUpdateTest.java", "diffHunk": "@@ -47,47 +52,128 @@ public void setup() {\n \n     containers =\n         Arrays.asList(\n-            manageClosable(new ZeebeBrokerContainer(OLD_VERSION)),\n-            manageClosable(new ZeebeBrokerContainer(OLD_VERSION)),\n-            manageClosable(new ZeebeBrokerContainer(OLD_VERSION)));\n+            new ZeebeBrokerContainer(OLD_VERSION),\n+            new ZeebeBrokerContainer(OLD_VERSION),\n+            new ZeebeBrokerContainer(OLD_VERSION));\n \n     configureBrokerContainer(0, containers);\n     configureBrokerContainer(1, containers);\n     configureBrokerContainer(2, containers);\n   }\n \n+  @After\n+  public void tearDown() {\n+    containers.parallelStream().forEach(Startable::stop);\n+  }\n+\n   @Test\n-  public void shouldBeAbleToRestartContainerWithSameVersion() {\n+  public void shouldBeAbleToRestartContainerWithNewVersion() {\n     // given\n     final var index = 0;\n-    final var sameVersion = OLD_VERSION;\n     Startables.deepStart(containers).join();\n     containers.get(index).shutdownGracefully(Duration.ofSeconds(30));\n \n     // when\n-    final var zeebeBrokerContainer = replaceBrokerContainer(index, sameVersion);\n+    final var zeebeBrokerContainer = upgradeBroker(index);\n \n     // then\n-    zeebeBrokerContainer.start();\n+    try (final var client = newZeebeClient(containers.get(1))) {\n+      waitUntilBrokerIsRemovedFromTopology(client);\n+      zeebeBrokerContainer.start();\n+      waitUntilTopologyIsComplete(client);\n+    }\n   }\n \n   @Test\n-  public void shouldBeAbleToRestartContainerWithNewVersion() {\n+  public void shouldPerformRollingUpgrade() throws InterruptedException {\n     // given\n-    final var index = 0;\n-    final var newVersion = CURRENT_VERSION;\n+    final var process =\n+        Bpmn.createExecutableProcess(\"process\")\n+            .startEvent()\n+            .serviceTask(\"task\", s -> s.zeebeJobType(\"type\"))\n+            .endEvent()\n+            .done();\n     Startables.deepStart(containers).join();\n-    containers.get(index).shutdownGracefully(Duration.ofSeconds(30));\n \n     // when\n-    final var zeebeBrokerContainer = replaceBrokerContainer(index, newVersion);\n+    createProcessInstance(process);\n+    performRollingUpgrade();\n \n     // then\n-    zeebeBrokerContainer.start();\n+    final var latch = new CountDownLatch(1);\n+    try (final var client = newZeebeClient(containers.get(0))) {\n+      client.newWorker().jobType(\"type\").handler((jobClient, job) -> latch.countDown()).open();\n+      assertThat(latch.await(5, TimeUnit.SECONDS)).isTrue();\n+    }\n+  }\n+\n+  /**\n+   * This method will simulate a rolling upgrade in the same Kubernetes would. It traverses the list\n+   * of brokers in reverse order, and shuts them down one by one. After shutting down one node, it\n+   * will restart it with the new version, then query another broker's embedded gateway until the\n+   * topology is complete. This ensures the restarted broker has not only started but has properly\n+   * joined the cluster.\n+   */\n+  private void performRollingUpgrade() {\n+    var availableBroker = containers.get(0);\n+    for (int i = containers.size() - 1; i >= 0; i--) {\n+      try (final var client = newZeebeClient(availableBroker)) {\n+        var container = containers.get(i);\n+        container.shutdownGracefully(Duration.ofSeconds(30));\n+        waitUntilBrokerIsRemovedFromTopology(client);\n+\n+        container = upgradeBroker(i);\n+        container.start();\n+        waitUntilTopologyIsComplete(client);\n+\n+        availableBroker = container;\n+      }\n+    }\n+  }\n+\n+  private void createProcessInstance(final BpmnModelInstance process) {\n+    try (final var client = newZeebeClient(containers.get(0))) {\n+      client\n+          .newDeployCommand()\n+          .addWorkflowModel(process, \"process.bpmn\")\n+          .send()\n+          .join(5, TimeUnit.SECONDS);\n+      client\n+          .newCreateInstanceCommand()\n+          .bpmnProcessId(\"process\")\n+          .latestVersion()\n+          .variables(Map.of(\"foo\", \"bar\"))\n+          .send()\n+          .join();\n+    }\n+  }\n+\n+  private void assertTopologyIsComplete(final ZeebeClient zeebeClient, final int clusterSize) {\n+    final var topology = zeebeClient.newTopologyRequest().send().join();\n+    TopologyAssert.assertThat(topology).isComplete(clusterSize, 1);", "originalCommit": "b410d6fef57a0e5d0f7843615dbd68c2d27a95fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgzNTU4NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4970#discussion_r454835584", "bodyText": "That's a good idea, yeah \ud83d\udc4d", "author": "npepinpe", "createdAt": "2020-07-15T07:03:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU0MzgxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUxODQ4OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4970#discussion_r455518488", "bodyText": "It seems that the condition is inversed.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (!brokers.contains(nodeId)) {\n          \n          \n            \n                  failWithMessage(\n          \n          \n            \n                      \"Expected topology not to contain broker with ID %d, but found the following: [%s]\",\n          \n          \n            \n                      nodeId, brokers);\n          \n          \n            \n                if (brokers.contains(nodeId)) {\n          \n          \n            \n                  failWithMessage(\n          \n          \n            \n                      \"Expected topology not to contain broker with ID %d, but found the following: [%s]\",\n          \n          \n            \n                      nodeId, brokers);", "author": "saig0", "createdAt": "2020-07-16T05:28:58Z", "path": "test-util/src/main/java/io/zeebe/test/util/asserts/TopologyAssert.java", "diffHunk": "@@ -45,4 +46,27 @@ public final TopologyAssert isComplete(final int clusterSize, final int partitio\n \n     return this;\n   }\n+\n+  public final TopologyAssert doesNotContainBroker(final int nodeId) {\n+    isNotNull();\n+\n+    final List<Integer> brokers =\n+        actual.getBrokers().stream().map(BrokerInfo::getNodeId).collect(Collectors.toList());\n+    if (!brokers.contains(nodeId)) {\n+      failWithMessage(\n+          \"Expected topology not to contain broker with ID %d, but found the following: [%s]\",\n+          nodeId, brokers);", "originalCommit": "fd07f98ed492dbac5f75d0a49ec61a736ae62470", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUyNTE1OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4970#discussion_r455525158", "bodyText": "Usually, we use the term workflow instance.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private WorkflowInstanceEvent createProcessInstance(final ZeebeClient client) {\n          \n          \n            \n              private WorkflowInstanceEvent createWorkflowInstance(final ZeebeClient client) {", "author": "saig0", "createdAt": "2020-07-16T05:51:58Z", "path": "upgrade-tests/src/test/java/io/zeebe/test/RollingUpdateTest.java", "diffHunk": "@@ -78,91 +91,130 @@ public void shouldBeAbleToRestartContainerWithNewVersion() {\n \n     // then\n     try (final var client = newZeebeClient(containers.get(1))) {\n-      waitUntilBrokerIsRemovedFromTopology(client);\n+      Awaitility.await()\n+          .atMost(Duration.ofSeconds(5))\n+          .pollInterval(Duration.ofMillis(100))\n+          .untilAsserted(() -> assertTopologyDoesNotContainerBroker(client, index));\n+\n       zeebeBrokerContainer.start();\n-      waitUntilTopologyIsComplete(client);\n+\n+      Awaitility.await()\n+          .atMost(Duration.ofSeconds(5))\n+          .pollInterval(Duration.ofMillis(100))\n+          .untilAsserted(() -> assertTopologyContainsUpgradedBroker(client, index));\n     }\n   }\n \n   @Test\n-  public void shouldPerformRollingUpgrade() throws InterruptedException {\n+  public void shouldPerformRollingUpgrade() {\n     // given\n-    final var process =\n-        Bpmn.createExecutableProcess(\"process\")\n-            .startEvent()\n-            .serviceTask(\"task\", s -> s.zeebeJobType(\"type\"))\n-            .endEvent()\n-            .done();\n     Startables.deepStart(containers).join();\n \n     // when\n-    createProcessInstance(process);\n-    performRollingUpgrade();\n-\n-    // then\n-    final var latch = new CountDownLatch(1);\n-    try (final var client = newZeebeClient(containers.get(0))) {\n-      client.newWorker().jobType(\"type\").handler((jobClient, job) -> latch.countDown()).open();\n-      assertThat(latch.await(5, TimeUnit.SECONDS)).isTrue();\n+    final long firstWorkflowInstanceKey;\n+    var availableBroker = containers.get(0);\n+    try (final var client = newZeebeClient(availableBroker)) {\n+      deployProcess(client);\n+\n+      // potentially retry in case we're faster than the deployment distribution\n+      firstWorkflowInstanceKey =\n+          Awaitility.await(\"process instance creation\")\n+              .atMost(Duration.ofSeconds(5))\n+              .pollInterval(Duration.ofMillis(100))\n+              .ignoreExceptions()\n+              .until(() -> createProcessInstance(client), Objects::nonNull)\n+              .getWorkflowInstanceKey();\n     }\n-  }\n \n-  /**\n-   * This method will simulate a rolling upgrade in the same Kubernetes would. It traverses the list\n-   * of brokers in reverse order, and shuts them down one by one. After shutting down one node, it\n-   * will restart it with the new version, then query another broker's embedded gateway until the\n-   * topology is complete. This ensures the restarted broker has not only started but has properly\n-   * joined the cluster.\n-   */\n-  private void performRollingUpgrade() {\n-    var availableBroker = containers.get(0);\n     for (int i = containers.size() - 1; i >= 0; i--) {\n       try (final var client = newZeebeClient(availableBroker)) {\n+        final var brokerId = i;\n         var container = containers.get(i);\n+\n         container.shutdownGracefully(Duration.ofSeconds(30));\n-        waitUntilBrokerIsRemovedFromTopology(client);\n+        Awaitility.await(\"broker is removed from topology\")\n+            .atMost(Duration.ofSeconds(5))\n+            .pollInterval(Duration.ofMillis(100))\n+            .untilAsserted(() -> assertTopologyDoesNotContainerBroker(client, brokerId));\n \n         container = upgradeBroker(i);\n         container.start();\n-        waitUntilTopologyIsComplete(client);\n+        Awaitility.await(\"upgraded broker is added to topology\")\n+            .atMost(Duration.ofSeconds(5))\n+            .pollInterval(Duration.ofMillis(100))\n+            .untilAsserted(() -> assertTopologyContainsUpgradedBroker(client, brokerId));\n \n         availableBroker = container;\n       }\n     }\n-  }\n \n-  private void createProcessInstance(final BpmnModelInstance process) {\n-    try (final var client = newZeebeClient(containers.get(0))) {\n-      client\n-          .newDeployCommand()\n-          .addWorkflowModel(process, \"process.bpmn\")\n-          .send()\n-          .join(5, TimeUnit.SECONDS);\n-      client\n-          .newCreateInstanceCommand()\n-          .bpmnProcessId(\"process\")\n-          .latestVersion()\n-          .variables(Map.of(\"foo\", \"bar\"))\n-          .send()\n-          .join();\n+    // then\n+    final Map<Long, List<String>> activatedJobs = new HashMap<>();\n+    final var expectedOrderedJobs = List.of(\"firstTask\", \"secondTask\");\n+    final JobHandler jobHandler =\n+        (jobClient, job) -> {\n+          jobClient.newCompleteCommand(job.getKey()).send().join();\n+          activatedJobs.compute(\n+              job.getWorkflowInstanceKey(),\n+              (ignored, list) -> {\n+                final var appendedList = Optional.ofNullable(list).orElse(new ArrayList<>());\n+                appendedList.add(job.getType());\n+                return appendedList;\n+              });\n+        };\n+\n+    try (final var client = newZeebeClient(availableBroker)) {\n+      final var secondWorkflowInstanceKey = createProcessInstance(client).getWorkflowInstanceKey();\n+      final var expectedActivatedJobs =\n+          Map.of(\n+              firstWorkflowInstanceKey,\n+              expectedOrderedJobs,\n+              secondWorkflowInstanceKey,\n+              expectedOrderedJobs);\n+      client.newWorker().jobType(\"firstTask\").handler(jobHandler).open();\n+      client.newWorker().jobType(\"secondTask\").handler(jobHandler).open();\n+\n+      Awaitility.await(\"all jobs have been activated\")\n+          .atMost(Duration.ofSeconds(5))\n+          .untilAsserted(() -> assertThat(activatedJobs).isEqualTo(expectedActivatedJobs));\n     }\n   }\n \n-  private void assertTopologyIsComplete(final ZeebeClient zeebeClient, final int clusterSize) {\n-    final var topology = zeebeClient.newTopologyRequest().send().join();\n-    TopologyAssert.assertThat(topology).isComplete(clusterSize, 1);\n+  private WorkflowInstanceEvent createProcessInstance(final ZeebeClient client) {", "originalCommit": "8d48840a4cd47f49812d23ee4d6841d12fa6ca02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cc1b14e61295c24af8d90eb01163d5d3ca4c0b7a", "url": "https://github.com/camunda-cloud/zeebe/commit/cc1b14e61295c24af8d90eb01163d5d3ca4c0b7a", "message": "chore(upgrade-tests): add rolling upgrade tests\n\n- removes specific log segment size and snapshot period as we're not\n  testing compaction in any form; add these back if we ever do\n- lowers the maxMessageSize to lower the memory footprint used by Atomix\n  which is directly proportional to number of segments * maxMessageSize\n- document the rolling upgrade simulation and why it's done like this\n- simplify handling of closeable resources\n- assert topology is complete on single node upgrade to check that the\n  new container correctly rejoined the cluster/raft\n- removes unnecessary smoke test covered by other integration tests", "committedDate": "2020-07-17T06:49:10Z", "type": "commit"}, {"oid": "cc1b14e61295c24af8d90eb01163d5d3ca4c0b7a", "url": "https://github.com/camunda-cloud/zeebe/commit/cc1b14e61295c24af8d90eb01163d5d3ca4c0b7a", "message": "chore(upgrade-tests): add rolling upgrade tests\n\n- removes specific log segment size and snapshot period as we're not\n  testing compaction in any form; add these back if we ever do\n- lowers the maxMessageSize to lower the memory footprint used by Atomix\n  which is directly proportional to number of segments * maxMessageSize\n- document the rolling upgrade simulation and why it's done like this\n- simplify handling of closeable resources\n- assert topology is complete on single node upgrade to check that the\n  new container correctly rejoined the cluster/raft\n- removes unnecessary smoke test covered by other integration tests", "committedDate": "2020-07-17T06:49:10Z", "type": "forcePushed"}]}