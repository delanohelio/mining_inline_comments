{"pr_number": 5255, "pr_title": "Take snapshots at same index if either exporter or processor position changed", "pr_createdAt": "2020-08-28T09:17:18Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/5255", "timeline": [{"oid": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "url": "https://github.com/camunda-cloud/zeebe/commit/5e18ceedb01ec29e99d2ca819e1e17565a891c59", "message": "chore(snapshots): fix for backward compatibility", "committedDate": "2020-08-28T12:01:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTE1NDUzMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479154531", "bodyText": "Should be assertAllNodesHaveSnapshotWithIndex", "author": "Zelldon", "createdAt": "2020-08-28T11:22:47Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -347,7 +343,7 @@ public void shouldReplicateSnapshotToOldLeaderAfterRestart() throws Exception {\n     raftRule.joinCluster(leader);\n \n     // then\n-    assertThat(raftRule.allNodesHaveSnapshotWithIndex(200)).isTrue();\n+    raftRule.assertallNodesHaveSnapshotWithIndex(200);", "originalCommit": "9f7ec170282b71f2528e586a6e32c49476500bb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTE1Nzk0Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479157947", "bodyText": "I assume this can be removed ? :D", "author": "Zelldon", "createdAt": "2020-08-28T11:25:53Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/snapshot/InMemorySnapshot.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.snapshots.raft.PersistedSnapshot;\n+import io.zeebe.snapshots.raft.ReceivedSnapshot;\n+import io.zeebe.snapshots.raft.SnapshotChunk;\n+import io.zeebe.snapshots.raft.SnapshotChunkReader;\n+import io.zeebe.util.StringUtil;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import org.agrona.concurrent.UnsafeBuffer;\n+import org.slf4j.LoggerFactory;\n+\n+public class InMemorySnapshot implements PersistedSnapshot, ReceivedSnapshot {\n+\n+  private final TestSnapshotStore testSnapshotStore;\n+  private final long index;\n+  private final long term;\n+  private final WallClockTimestamp timestamp;\n+  private final String id;\n+  private final NavigableMap<String, String> chunks = new TreeMap<>();\n+  private ByteBuffer nextExpected;\n+\n+  InMemorySnapshot(final TestSnapshotStore testSnapshotStore, final String snapshotId) {\n+    this.testSnapshotStore = testSnapshotStore;\n+    id = snapshotId;\n+    final var parts = snapshotId.split(\"-\");\n+    index = Long.parseLong(parts[0]);\n+    term = Long.parseLong(parts[1]);\n+    timestamp = WallClockTimestamp.from(Long.parseLong(parts[2]));\n+  }\n+\n+  InMemorySnapshot(\n+      final TestSnapshotStore testSnapshotStore,\n+      final long index,\n+      final long term,\n+      final WallClockTimestamp timestamp) {\n+    this.testSnapshotStore = testSnapshotStore;\n+    this.index = index;\n+    this.term = term;\n+    this.timestamp = timestamp;\n+    this.id = String.format(\"%d-%d-%d\", index, term, timestamp.unixTimestamp());\n+  }\n+\n+  public static InMemorySnapshot newPersistedSnapshot(\n+      final long index, final long term, final int size, final TestSnapshotStore snapshotStore) {\n+    final var snapshot = new InMemorySnapshot(snapshotStore, index, term, new WallClockTimestamp());\n+    for (int i = 0; i < size; i++) {\n+      snapshot.writeChunks(\"chunk-\" + i, \"test\".getBytes());\n+    }\n+    snapshot.persist();\n+    return snapshot;\n+  }\n+\n+  void writeChunks(final String id, final byte[] chunk) {\n+    chunks.put(id, StringUtil.fromBytes(chunk));\n+  }\n+\n+  @Override\n+  public WallClockTimestamp getTimestamp() {\n+    return timestamp;\n+  }\n+\n+  @Override\n+  public int version() {\n+    return 1;\n+  }\n+\n+  @Override\n+  public long getIndex() {\n+    return index;\n+  }\n+\n+  @Override\n+  public long getTerm() {\n+    return term;\n+  }\n+\n+  @Override\n+  public SnapshotChunkReader newChunkReader() {\n+    return new SnapshotChunkReader() {\n+      private NavigableMap<String, String> iterator = chunks;\n+\n+      @Override\n+      public void seek(final ByteBuffer id) {\n+        final var chunkId = byteBufferToString(id);\n+        iterator = chunks.tailMap(chunkId, true);\n+      }\n+\n+      @Override\n+      public ByteBuffer nextId() {\n+        if (!hasNext()) {\n+          return null;\n+        }\n+        return ByteBuffer.wrap(iterator.firstEntry().getKey().getBytes());\n+      }\n+\n+      @Override\n+      public void close() {\n+        iterator = null;\n+      }\n+\n+      @Override\n+      public boolean hasNext() {\n+        return !iterator.isEmpty();\n+      }\n+\n+      @Override\n+      public SnapshotChunk next() {\n+        final var nextEntry = iterator.firstEntry();\n+        LoggerFactory.getLogger(\"FINDME\").info(\"Returning next chunk Id = {}\", nextEntry.getKey());", "originalCommit": "9f7ec170282b71f2528e586a6e32c49476500bb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTE1ODY1NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479158654", "bodyText": "Maybe we have something like that already in io.zeebe.util.BufferUtil", "author": "Zelldon", "createdAt": "2020-08-28T11:26:32Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/snapshot/InMemorySnapshot.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.snapshots.raft.PersistedSnapshot;\n+import io.zeebe.snapshots.raft.ReceivedSnapshot;\n+import io.zeebe.snapshots.raft.SnapshotChunk;\n+import io.zeebe.snapshots.raft.SnapshotChunkReader;\n+import io.zeebe.util.StringUtil;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import org.agrona.concurrent.UnsafeBuffer;\n+import org.slf4j.LoggerFactory;\n+\n+public class InMemorySnapshot implements PersistedSnapshot, ReceivedSnapshot {\n+\n+  private final TestSnapshotStore testSnapshotStore;\n+  private final long index;\n+  private final long term;\n+  private final WallClockTimestamp timestamp;\n+  private final String id;\n+  private final NavigableMap<String, String> chunks = new TreeMap<>();\n+  private ByteBuffer nextExpected;\n+\n+  InMemorySnapshot(final TestSnapshotStore testSnapshotStore, final String snapshotId) {\n+    this.testSnapshotStore = testSnapshotStore;\n+    id = snapshotId;\n+    final var parts = snapshotId.split(\"-\");\n+    index = Long.parseLong(parts[0]);\n+    term = Long.parseLong(parts[1]);\n+    timestamp = WallClockTimestamp.from(Long.parseLong(parts[2]));\n+  }\n+\n+  InMemorySnapshot(\n+      final TestSnapshotStore testSnapshotStore,\n+      final long index,\n+      final long term,\n+      final WallClockTimestamp timestamp) {\n+    this.testSnapshotStore = testSnapshotStore;\n+    this.index = index;\n+    this.term = term;\n+    this.timestamp = timestamp;\n+    this.id = String.format(\"%d-%d-%d\", index, term, timestamp.unixTimestamp());\n+  }\n+\n+  public static InMemorySnapshot newPersistedSnapshot(\n+      final long index, final long term, final int size, final TestSnapshotStore snapshotStore) {\n+    final var snapshot = new InMemorySnapshot(snapshotStore, index, term, new WallClockTimestamp());\n+    for (int i = 0; i < size; i++) {\n+      snapshot.writeChunks(\"chunk-\" + i, \"test\".getBytes());\n+    }\n+    snapshot.persist();\n+    return snapshot;\n+  }\n+\n+  void writeChunks(final String id, final byte[] chunk) {\n+    chunks.put(id, StringUtil.fromBytes(chunk));\n+  }\n+\n+  @Override\n+  public WallClockTimestamp getTimestamp() {\n+    return timestamp;\n+  }\n+\n+  @Override\n+  public int version() {\n+    return 1;\n+  }\n+\n+  @Override\n+  public long getIndex() {\n+    return index;\n+  }\n+\n+  @Override\n+  public long getTerm() {\n+    return term;\n+  }\n+\n+  @Override\n+  public SnapshotChunkReader newChunkReader() {\n+    return new SnapshotChunkReader() {\n+      private NavigableMap<String, String> iterator = chunks;\n+\n+      @Override\n+      public void seek(final ByteBuffer id) {\n+        final var chunkId = byteBufferToString(id);\n+        iterator = chunks.tailMap(chunkId, true);\n+      }\n+\n+      @Override\n+      public ByteBuffer nextId() {\n+        if (!hasNext()) {\n+          return null;\n+        }\n+        return ByteBuffer.wrap(iterator.firstEntry().getKey().getBytes());\n+      }\n+\n+      @Override\n+      public void close() {\n+        iterator = null;\n+      }\n+\n+      @Override\n+      public boolean hasNext() {\n+        return !iterator.isEmpty();\n+      }\n+\n+      @Override\n+      public SnapshotChunk next() {\n+        final var nextEntry = iterator.firstEntry();\n+        LoggerFactory.getLogger(\"FINDME\").info(\"Returning next chunk Id = {}\", nextEntry.getKey());\n+        iterator = chunks.tailMap(nextEntry.getKey(), false);\n+        return new TestSnapshotChunkImpl(\n+            id, nextEntry.getKey(), StringUtil.getBytes(nextEntry.getValue()), chunks.size());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public void delete() {}\n+\n+  @Override\n+  public Path getPath() {\n+    return null;\n+  }\n+\n+  @Override\n+  public long getCompactionBound() {\n+    return index;\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return id;\n+  }\n+\n+  private String byteBufferToString(final ByteBuffer buf) {\n+    final var view = new UnsafeBuffer(buf);", "originalCommit": "9f7ec170282b71f2528e586a6e32c49476500bb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIyNzkwMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479227900", "bodyText": "Why is this called active? I assume because you can actively create a snapshot ? :D", "author": "Zelldon", "createdAt": "2020-08-28T12:25:11Z", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -89,7 +89,7 @@\n   private LogStream logStream;\n   private Role raftRole;\n   private SnapshotReplication stateReplication;\n-  private PersistedSnapshotStore persistedSnapshotStore;\n+  private final ActivePersistedSnapshotStore persistedSnapshotStore;", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk1MDY1Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479950653", "bodyText": "We agreed on ConstructableSnapshotStore, if someone has a better name feel free to propose.", "author": "Zelldon", "createdAt": "2020-08-31T07:36:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIyNzkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzMTA1Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479231056", "bodyText": "Why we not using the interface?", "author": "Zelldon", "createdAt": "2020-08-28T12:27:48Z", "path": "broker/src/test/java/io/zeebe/broker/system/partitions/AsyncSnapshotingTest.java", "diffHunk": "@@ -63,13 +63,14 @@\n   private AsyncSnapshotDirector asyncSnapshotDirector;\n   private StreamProcessor mockStreamProcessor;\n   private List<ActorCondition> conditionList;\n-  private PersistedSnapshotStore persistedSnapshotStore;\n+  private FileBasedSnapshotStore persistedSnapshotStore;", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzMzUyOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479233529", "bodyText": "Why we are not using the interface?", "author": "Zelldon", "createdAt": "2020-08-28T12:29:54Z", "path": "logstreams/src/test/java/io/zeebe/logstreams/util/AtomixLogStorageRule.java", "diffHunk": "@@ -51,13 +51,13 @@\n   private ZeebeIndexAdapter indexMapping;\n   private RaftStorage raftStorage;\n   private RaftLog raftLog;\n-  private PersistedSnapshotStore persistedSnapshotStore;\n+  private NoopSnapshotStore persistedSnapshotStore;", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzODY3NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479238675", "bodyText": "Active sounds a bit odd to me. Maybe WritableSnapshotStore or PersistableSnapshotStore", "author": "Zelldon", "createdAt": "2020-08-28T12:34:10Z", "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/ActivePersistedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.snapshots.broker;\n+\n+import io.zeebe.snapshots.raft.PersistedSnapshotStore;\n+import io.zeebe.snapshots.raft.TransientSnapshot;\n+import java.util.Optional;\n+\n+/** A persisted snapshot store than can create a new snapshot and persists it. */\n+public interface ActivePersistedSnapshotStore extends PersistedSnapshotStore {", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzOTgyMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479239820", "bodyText": "Maybe we implemented here a fallback to accept also old snapshot id's?", "author": "Zelldon", "createdAt": "2020-08-28T12:35:06Z", "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedReceivedSnapshot.java", "diffHunk": "@@ -171,8 +163,11 @@ private boolean isTotalCountInvalid(final int currentTotalCount) {\n   }\n \n   private boolean isSnapshotIdInvalid(final String snapshotId) {\n-    final var expectedSnapshotId = metadata.getSnapshotIdAsString();\n-    return !expectedSnapshotId.equals(snapshotId);\n+    final var receivedSnapshotId = FileBasedSnapshotMetadata.ofFileName(snapshotId);", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0MTQ1Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479241452", "bodyText": "Ah cool so we can already receive old snapshots.", "author": "Zelldon", "createdAt": "2020-08-28T12:36:30Z", "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotMetadata.java", "diffHunk": "@@ -42,15 +53,34 @@\n         final var index = Long.parseLong(parts[0]);\n         final var term = Long.parseLong(parts[1]);\n         final var timestamp = Long.parseLong(parts[2]);\n+        final var processedPosition = Long.parseLong(parts[3]);\n+        final var exporterPosition = Long.parseLong(parts[4]);\n \n         metadata =\n             Optional.of(\n-                new FileBasedSnapshotMetadata(index, term, WallClockTimestamp.from(timestamp)));\n+                new FileBasedSnapshotMetadata(\n+                    index,\n+                    term,\n+                    WallClockTimestamp.from(timestamp),\n+                    processedPosition,\n+                    exporterPosition));\n       } catch (final NumberFormatException e) {\n         LOGGER.warn(\"Failed to parse part of snapshot metadata\", e);\n       }\n-    }\n+    } else if (parts.length >= METADATA_PARTS_OLD_VERSION) {", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0Mzg4Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479243887", "bodyText": "Is the timestamp also used? Can this ever happen then ? \ud83d\ude05", "author": "Zelldon", "createdAt": "2020-08-28T12:38:30Z", "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -180,6 +164,28 @@ public void delete() {\n     }\n   }\n \n+  @Override\n+  public Optional<TransientSnapshot> newTransientSnapshot(\n+      final long index,\n+      final long term,\n+      final long processedPosition,\n+      final long exportedPosition) {\n+\n+    final WallClockTimestamp timestamp = WallClockTimestamp.from(System.currentTimeMillis());\n+    final var newSnapshotId =\n+        new FileBasedSnapshotMetadata(index, term, timestamp, processedPosition, exportedPosition);\n+    final FileBasedSnapshot currentSnapshot = currentPersistedSnapshotRef.get();\n+    if (currentSnapshot != null && currentSnapshot.getMetadata().compareTo(newSnapshotId) == 0) {", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0NzQyMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479247422", "bodyText": "Please always try to return the interfaces", "author": "Zelldon", "createdAt": "2020-08-28T12:41:27Z", "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStoreFactory.java", "diffHunk": "@@ -43,7 +38,14 @@ public PersistedSnapshotStore createSnapshotStore(final Path root, final String\n     IoUtil.ensureDirectoryExists(snapshotDirectory.toFile(), \"Snapshot directory\");\n     IoUtil.ensureDirectoryExists(pendingDirectory.toFile(), \"Pending snapshot directory\");\n \n-    return new FileBasedSnapshotStore(\n-        new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory);\n+    return partitionSnapshotStores.computeIfAbsent(\n+        partitionName,\n+        p ->\n+            new FileBasedSnapshotStore(\n+                new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory));\n+  }\n+\n+  public FileBasedSnapshotStore getSnapshotStore(final String partitionName) {", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0ODY5NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479248695", "bodyText": "Why was this necessary? To get the same store in the ZeebePartition as in the journal?", "author": "Zelldon", "createdAt": "2020-08-28T12:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0NzQyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0OTUwMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479249502", "bodyText": "Is is problematic if we never really recreate the store when we had a leader change?", "author": "Zelldon", "createdAt": "2020-08-28T12:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0NzQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI1MjQ5OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479252498", "bodyText": "I thought we want to have two factory methods in this factory one to create a store which can receive chunks and one which can be used to take snapshots?", "author": "Zelldon", "createdAt": "2020-08-28T12:47:07Z", "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStoreFactory.java", "diffHunk": "@@ -43,7 +38,14 @@ public PersistedSnapshotStore createSnapshotStore(final Path root, final String\n     IoUtil.ensureDirectoryExists(snapshotDirectory.toFile(), \"Snapshot directory\");\n     IoUtil.ensureDirectoryExists(pendingDirectory.toFile(), \"Pending snapshot directory\");\n \n-    return new FileBasedSnapshotStore(\n-        new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory);\n+    return partitionSnapshotStores.computeIfAbsent(\n+        partitionName,\n+        p ->\n+            new FileBasedSnapshotStore(\n+                new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory));\n+  }\n+\n+  public FileBasedSnapshotStore getSnapshotStore(final String partitionName) {", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk3MzYxNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479973616", "bodyText": "We will create two factory Interfaces  - ConstructableStoreFactory and ReceivableStoreFactory", "author": "deepthidevaki", "createdAt": "2020-08-31T08:22:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI1MjQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI1MzI0NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479253245", "bodyText": "We we need to cast this everywhere ?", "author": "Zelldon", "createdAt": "2020-08-28T12:48:00Z", "path": "snapshot/src/test/java/io/zeebe/snapshots/broker/impl/FileBasedReceivedSnapshotTest.java", "diffHunk": "@@ -50,22 +37,26 @@\n public class FileBasedReceivedSnapshotTest {\n \n   @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-  private PersistedSnapshotStore senderSnapshotStore;\n-  private PersistedSnapshotStore receiverSnapshotStore;\n+  private FileBasedSnapshotStore senderSnapshotStore;\n+  private FileBasedSnapshotStore receiverSnapshotStore;\n   private Path receiverSnapshotsDir;\n   private Path receiverPendingSnapshotsDir;\n-  private FileBasedSnapshotStoreFactory factory;\n \n   @Before\n   public void before() throws Exception {\n-    factory = new FileBasedSnapshotStoreFactory();\n     final String partitionName = \"1\";\n     final File senderRoot = temporaryFolder.newFolder(\"sender\");\n \n-    senderSnapshotStore = factory.createSnapshotStore(senderRoot.toPath(), partitionName);\n+    senderSnapshotStore =\n+        (FileBasedSnapshotStore)\n+            new FileBasedSnapshotStoreFactory()\n+                .createSnapshotStore(senderRoot.toPath(), partitionName);\n \n     final var receiverRoot = temporaryFolder.newFolder(\"received\");\n-    receiverSnapshotStore = factory.createSnapshotStore(receiverRoot.toPath(), partitionName);\n+    receiverSnapshotStore =\n+        (FileBasedSnapshotStore)", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI1NDA2NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479254064", "bodyText": "i would expect that we still can use the interfaces otherwise we did something wrong in our api", "author": "Zelldon", "createdAt": "2020-08-28T12:49:00Z", "path": "snapshot/src/test/java/io/zeebe/snapshots/broker/impl/FileBasedTransientSnapshotTest.java", "diffHunk": "@@ -40,7 +30,7 @@\n public class FileBasedTransientSnapshotTest {\n \n   @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-  private PersistedSnapshotStore persistedSnapshotStore;\n+  private FileBasedSnapshotStore persistedSnapshotStore;", "originalCommit": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5NTk3MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480095970", "bodyText": "could we rename it to supplier? Or just use the supplier once to get the store?", "author": "Zelldon", "createdAt": "2020-08-31T12:27:36Z", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -113,13 +113,13 @@ public ZeebePartition(\n       final BrokerCfg brokerCfg,\n       final CommandApiService commandApiService,\n       final ZeebeIndexMapping zeebeIndexMapping,\n-      final ActivePersistedSnapshotStore persistedSnapshotStore,\n+      final SnapshotStoreSupplier snapshotStoreFactory,\n       final TypedRecordProcessorsFactory typedRecordProcessorsFactory) {\n     this.localBroker = localBroker;\n     this.atomixRaftPartition = atomixRaftPartition;\n     this.messagingService = messagingService;\n     this.brokerCfg = brokerCfg;\n-    this.persistedSnapshotStore = persistedSnapshotStore;\n+    this.snapshotStoreFactory = snapshotStoreFactory;", "originalCommit": "cfad20ed0e36d403c5771f3209f1b52ef5e06713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5OTgyOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480099828", "bodyText": "Ah this is already outdated nevermind", "author": "Zelldon", "createdAt": "2020-08-31T12:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5NTk3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODE0Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480098142", "bodyText": "Would be cool if we can adjust the docs then", "author": "Zelldon", "createdAt": "2020-08-31T12:31:45Z", "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/ConstructableSnapshotStore.java", "diffHunk": "@@ -12,7 +12,7 @@\n import java.util.Optional;\n \n /** A persisted snapshot store than can create a new snapshot and persists it. */", "originalCommit": "cfad20ed0e36d403c5771f3209f1b52ef5e06713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDExODMzMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480118330", "bodyText": "Isn't the doc already up-to-date?", "author": "deepthidevaki", "createdAt": "2020-08-31T13:09:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEyMTAwMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480121002", "bodyText": "Hm ok maybe you're right. I thought maybe using this word 'constructing' in the doc would fit here as well. But feel free to reject this comment", "author": "Zelldon", "createdAt": "2020-08-31T13:14:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEyMTkzOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480121939", "bodyText": "Ah.. ok. Let me see if I can improve it. Thanks.", "author": "deepthidevaki", "createdAt": "2020-08-31T13:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODM4Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480098387", "bodyText": "Do we need that?", "author": "Zelldon", "createdAt": "2020-08-31T12:32:13Z", "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/SnapshotStoreSupplier.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.snapshots.broker;\n+\n+import io.zeebe.snapshots.raft.PersistedSnapshotStore;\n+import io.zeebe.snapshots.raft.ReceivableSnapshotStore;\n+\n+public interface SnapshotStoreSupplier {\n+\n+  /**\n+   * Returns a partition's {@link ConstructableSnapshotStore}\n+   *\n+   * @param partitionName\n+   * @return a ConstructableSnapshotStore\n+   */\n+  ConstructableSnapshotStore getConstructableSnapshotStore(String partitionName);\n+\n+  /**\n+   * Returns a partition's {@link ReceivableSnapshotStore}\n+   *\n+   * @param partitionName\n+   * @return a ReceivableSnapshotStore\n+   */\n+  ReceivableSnapshotStore getReceivableSnapshotStore(final String partitionName);\n+\n+  /**\n+   * Returns a partition's {@link PersistedSnapshotStore}\n+   *\n+   * @param partitionName\n+   * @return a ConstructableSnapshotStore\n+   */\n+  PersistedSnapshotStore getPersistedSnapshotStore(String partitionName);", "originalCommit": "cfad20ed0e36d403c5771f3209f1b52ef5e06713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDExNzQ2OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480117468", "bodyText": "LogDeletionService expects only PersistedSnapshotStore. It doesn't care if it is Receivable or Constructable.", "author": "deepthidevaki", "createdAt": "2020-08-31T13:07:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDExODIwNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480118206", "bodyText": "But the other interfaces extend this one right? So you can just give one of them? Not sure whether it makes sense to have this getter", "author": "Zelldon", "createdAt": "2020-08-31T13:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEyMDkwMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480120902", "bodyText": "Then the question is which one to use. Both would pass the compiler. But conceptually, on the leader it does not make sense  to use RecievableStore and on the follower to use ConstructableStore.", "author": "deepthidevaki", "createdAt": "2020-08-31T13:13:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzNjg3Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480136872", "bodyText": "sounds not ideal but ok should be fine for now", "author": "Zelldon", "createdAt": "2020-08-31T13:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE2NTkxMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480165912", "bodyText": "Thanks. I don't like it either. But could not find a better way. :)  Any other comments?", "author": "deepthidevaki", "createdAt": "2020-08-31T14:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODM4Nw=="}], "type": "inlineReview"}, {"oid": "218e93b1d671776c2143a8fc2a37b499017e2b12", "url": "https://github.com/camunda-cloud/zeebe/commit/218e93b1d671776c2143a8fc2a37b499017e2b12", "message": "chore(atomix): use mock implementation of snapshot store in tests\nThis is in preparation for refactoring snapshot implementations and moving the concrete implementation out of atomix.", "committedDate": "2020-09-01T08:20:51Z", "type": "commit"}, {"oid": "8609cfca1a9e15d87704684f5f7444f41497a84f", "url": "https://github.com/camunda-cloud/zeebe/commit/8609cfca1a9e15d87704684f5f7444f41497a84f", "message": "chore(atomix): remove snapshot listener when closing a role", "committedDate": "2020-09-01T08:20:52Z", "type": "commit"}, {"oid": "1a6bf99473aad6c331bc94a0735c843b6a711885", "url": "https://github.com/camunda-cloud/zeebe/commit/1a6bf99473aad6c331bc94a0735c843b6a711885", "message": "chore(broker): use exporter and processor positions in snapshot id\n* move snapshot interfaces and clases to new module\n* take snapshot at same index if either exporter or processor position is changed\n* snapshot is uniquely identified by index,term,processedposition,exporterposition", "committedDate": "2020-09-01T08:20:52Z", "type": "commit"}, {"oid": "1a6bf99473aad6c331bc94a0735c843b6a711885", "url": "https://github.com/camunda-cloud/zeebe/commit/1a6bf99473aad6c331bc94a0735c843b6a711885", "message": "chore(broker): use exporter and processor positions in snapshot id\n* move snapshot interfaces and clases to new module\n* take snapshot at same index if either exporter or processor position is changed\n* snapshot is uniquely identified by index,term,processedposition,exporterposition", "committedDate": "2020-09-01T08:20:52Z", "type": "forcePushed"}]}