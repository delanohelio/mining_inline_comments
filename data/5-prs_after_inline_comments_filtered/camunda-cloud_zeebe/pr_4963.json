{"pr_number": 4963, "pr_title": "Remove workflow related data from state when it is not used ", "pr_createdAt": "2020-07-14T12:15:00Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4963", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwOTMxMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r454809312", "bodyText": "Do we want to have an interface for it?", "author": "Zelldon", "createdAt": "2020-07-15T05:56:11Z", "path": "engine/src/main/java/io/zeebe/engine/state/message/MessageStartEventSubscriptionState.java", "diffHunk": "@@ -93,6 +93,10 @@ public void visitSubscriptionsByMessageName(\n         });\n   }\n \n+  public boolean isEmpty() {", "originalCommit": "b8efca7db81189178e4968b25f85221aa2d36fc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkxMDQ5Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r454910493", "bodyText": "Currently, I don't see a need to introduce an interface only for the isEmpty() method.", "author": "saig0", "createdAt": "2020-07-15T09:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwOTMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwOTUxOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r454809518", "bodyText": "Actually we added these things only for tests right? Do you see any possibility to do it differently without adding stuff to the production code?", "author": "Zelldon", "createdAt": "2020-07-15T05:56:48Z", "path": "engine/src/main/java/io/zeebe/engine/state/message/MessageState.java", "diffHunk": "@@ -319,6 +319,16 @@ public void remove(final long key) {\n         }));\n   }\n \n+  public boolean isEmpty() {", "originalCommit": "b8efca7db81189178e4968b25f85221aa2d36fc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkxMTg3MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r454911871", "bodyText": "Yes. The isEmtpy() methods are used in tests only. I think it's ok because it is simple and doesn't expose some internals of the class. I see no other ways to verify that the state is empty.", "author": "saig0", "createdAt": "2020-07-15T09:18:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwOTUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxMDE1NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r454810155", "bodyText": "no should prefix anymore \ud83d\udc40 \ud83d\ude31 what with our values and consistency \ud83d\ude04\nI would suggest that we change it to something like shouldEndWithCleanStateOnWorkflowWithServiceTask", "author": "Zelldon", "createdAt": "2020-07-15T05:58:54Z", "path": "engine/src/test/java/io/zeebe/engine/state/WorkflowExecutionCleanZeebeStateTest.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.state;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.zeebe.engine.processing.message.MessageObserver;\n+import io.zeebe.engine.state.instance.ElementInstanceState;\n+import io.zeebe.engine.state.instance.EventScopeInstanceState;\n+import io.zeebe.engine.state.instance.IncidentState;\n+import io.zeebe.engine.state.instance.JobState;\n+import io.zeebe.engine.state.instance.TimerInstanceState;\n+import io.zeebe.engine.state.instance.VariablesState;\n+import io.zeebe.engine.state.message.MessageStartEventSubscriptionState;\n+import io.zeebe.engine.state.message.MessageState;\n+import io.zeebe.engine.state.message.MessageSubscriptionState;\n+import io.zeebe.engine.state.message.WorkflowInstanceSubscriptionState;\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.protocol.record.intent.IncidentIntent;\n+import io.zeebe.protocol.record.intent.JobIntent;\n+import io.zeebe.protocol.record.intent.MessageStartEventSubscriptionIntent;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import org.awaitility.Awaitility;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public final class WorkflowExecutionCleanZeebeStateTest {\n+\n+  private static final String PROCESS_ID = \"workflow\";\n+\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  private ElementInstanceState elementInstanceState;\n+  private TimerInstanceState timerState;\n+  private EventScopeInstanceState eventScopeInstanceState;\n+  private JobState jobState;\n+  private IncidentState incidentState;\n+  private MessageState messageState;\n+  private MessageSubscriptionState messageSubscriptionState;\n+  private WorkflowInstanceSubscriptionState workflowInstanceSubscriptionState;\n+  private MessageStartEventSubscriptionState messageStartEventSubscriptionState;\n+  private VariablesState variablesState;\n+\n+  @Before\n+  public void init() {\n+    final var zeebeState = engineRule.getZeebeState();\n+\n+    final var workflowState = zeebeState.getWorkflowState();\n+    elementInstanceState = workflowState.getElementInstanceState();\n+    variablesState = elementInstanceState.getVariablesState();\n+    timerState = workflowState.getTimerState();\n+    eventScopeInstanceState = workflowState.getEventScopeInstanceState();\n+\n+    jobState = zeebeState.getJobState();\n+    incidentState = zeebeState.getIncidentState();\n+    messageState = zeebeState.getMessageState();\n+    messageSubscriptionState = zeebeState.getMessageSubscriptionState();\n+    workflowInstanceSubscriptionState = zeebeState.getWorkflowInstanceSubscriptionState();\n+    messageStartEventSubscriptionState = zeebeState.getMessageStartEventSubscriptionState();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithServiceTask() {", "originalCommit": "b8efca7db81189178e4968b25f85221aa2d36fc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxODk3Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r454818973", "bodyText": "Can we have one test with input mapping? Does it make a difference?", "author": "Zelldon", "createdAt": "2020-07-15T06:24:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxMDE1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkxNzU3MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r454917570", "bodyText": "Can we have one test with input mapping? Does it make a difference?\n\nThere is one test case with input and output mappings. It should cover the cases.\n\nI would suggest that we change it to something like shouldEndWithCleanStateOnWorkflowWithServiceTask\n\nUsually, I would agree. But in this case, all tests verify that the state is empty at the end - just with different parameters. It could be a ParameterizedTest but the workflow and steps are too different.\nIf we're using shouldEndWithCleanStateOnWorkflowWithServiceTask then the major part shouldEndWithCleanStateOnWorkflowWith is equal to all tests. So, I would like to shrink the name to what is different.\nDo you agree with it?", "author": "saig0", "createdAt": "2020-07-15T09:28:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxMDE1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5MzE3Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r464193176", "bodyText": "What I normally then do is to name the Test as the common thing and as you meant use the difference as test method name, but still with should prefix.\nFor example AlwaysCleanStateTest #shouldBeTrueWithWorkflowServiceTask, #shouldBeTrueWithTimerEvent etc.", "author": "Zelldon", "createdAt": "2020-08-03T04:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxMDE1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg0OTY4NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r464849684", "bodyText": "I did not find a better way for the naming. Also, a parameterized test doesn't work nicely here.", "author": "saig0", "createdAt": "2020-08-04T07:20:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxMDE1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg1MDMzMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r464850330", "bodyText": "ok thanks for trying it", "author": "Zelldon", "createdAt": "2020-08-04T07:21:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxMDE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxMDU0Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r454810547", "bodyText": "no given, when then comments anymore ?", "author": "Zelldon", "createdAt": "2020-07-15T06:00:05Z", "path": "engine/src/test/java/io/zeebe/engine/state/WorkflowExecutionCleanZeebeStateTest.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.state;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.zeebe.engine.processing.message.MessageObserver;\n+import io.zeebe.engine.state.instance.ElementInstanceState;\n+import io.zeebe.engine.state.instance.EventScopeInstanceState;\n+import io.zeebe.engine.state.instance.IncidentState;\n+import io.zeebe.engine.state.instance.JobState;\n+import io.zeebe.engine.state.instance.TimerInstanceState;\n+import io.zeebe.engine.state.instance.VariablesState;\n+import io.zeebe.engine.state.message.MessageStartEventSubscriptionState;\n+import io.zeebe.engine.state.message.MessageState;\n+import io.zeebe.engine.state.message.MessageSubscriptionState;\n+import io.zeebe.engine.state.message.WorkflowInstanceSubscriptionState;\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.protocol.record.intent.IncidentIntent;\n+import io.zeebe.protocol.record.intent.JobIntent;\n+import io.zeebe.protocol.record.intent.MessageStartEventSubscriptionIntent;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import org.awaitility.Awaitility;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public final class WorkflowExecutionCleanZeebeStateTest {\n+\n+  private static final String PROCESS_ID = \"workflow\";\n+\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  private ElementInstanceState elementInstanceState;\n+  private TimerInstanceState timerState;\n+  private EventScopeInstanceState eventScopeInstanceState;\n+  private JobState jobState;\n+  private IncidentState incidentState;\n+  private MessageState messageState;\n+  private MessageSubscriptionState messageSubscriptionState;\n+  private WorkflowInstanceSubscriptionState workflowInstanceSubscriptionState;\n+  private MessageStartEventSubscriptionState messageStartEventSubscriptionState;\n+  private VariablesState variablesState;\n+\n+  @Before\n+  public void init() {\n+    final var zeebeState = engineRule.getZeebeState();\n+\n+    final var workflowState = zeebeState.getWorkflowState();\n+    elementInstanceState = workflowState.getElementInstanceState();\n+    variablesState = elementInstanceState.getVariablesState();\n+    timerState = workflowState.getTimerState();\n+    eventScopeInstanceState = workflowState.getEventScopeInstanceState();\n+\n+    jobState = zeebeState.getJobState();\n+    incidentState = zeebeState.getIncidentState();\n+    messageState = zeebeState.getMessageState();\n+    messageSubscriptionState = zeebeState.getMessageSubscriptionState();\n+    workflowInstanceSubscriptionState = zeebeState.getWorkflowInstanceSubscriptionState();\n+    messageStartEventSubscriptionState = zeebeState.getMessageStartEventSubscriptionState();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithServiceTask() {\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .serviceTask(\"task\", t -> t.zeebeJobType(\"test\"))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).withVariable(\"x\", 1).create();\n+\n+    engineRule\n+        .job()\n+        .ofInstance(workflowInstanceKey)\n+        .withType(\"test\")\n+        .withVariable(\"y\", 2)\n+        .complete();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithSubprocess() {\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .subProcess(\n+                    \"subprocess\",\n+                    subProcess ->\n+                        subProcess\n+                            .zeebeInputExpression(\"x\", \"y\")\n+                            .zeebeOutputExpression(\"y\", \"z\")\n+                            .embeddedSubProcess()\n+                            .startEvent()\n+                            .endEvent())\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).withVariable(\"x\", 1).create();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithMultiInstance() {\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .serviceTask(\n+                    \"task\",\n+                    t ->\n+                        t.zeebeJobType(\"test\")\n+                            .multiInstance(\n+                                m ->\n+                                    m.zeebeInputCollectionExpression(\"items\")\n+                                        .zeebeInputElement(\"item\")\n+                                        .zeebeOutputCollection(\"results\")\n+                                        .zeebeOutputElementExpression(\"result\")))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+", "originalCommit": "b8efca7db81189178e4968b25f85221aa2d36fc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMTE1NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r454921155", "bodyText": "Nope, but I have no strong option in this case \ud83d\ude05\nFor you, what is the value of this comments here?", "author": "saig0", "createdAt": "2020-07-15T09:34:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxMDU0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MDUyNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r456270527", "bodyText": "It makes it more clear and is easier to read if you have the separators you can clearly see the sections. For me it is often that I can easier/faster understand the test.", "author": "Zelldon", "createdAt": "2020-07-17T07:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxMDU0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA4NTMwNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r457085307", "bodyText": "\ud83d\udc4d", "author": "saig0", "createdAt": "2020-07-20T06:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxMDU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxOTk3OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r454819978", "bodyText": "Can we somehow just check whether the db is empty? I have the feeling this is a bit unstable if we miss to add a state here", "author": "Zelldon", "createdAt": "2020-07-15T06:26:48Z", "path": "engine/src/test/java/io/zeebe/engine/state/WorkflowExecutionCleanZeebeStateTest.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.state;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.zeebe.engine.processing.message.MessageObserver;\n+import io.zeebe.engine.state.instance.ElementInstanceState;\n+import io.zeebe.engine.state.instance.EventScopeInstanceState;\n+import io.zeebe.engine.state.instance.IncidentState;\n+import io.zeebe.engine.state.instance.JobState;\n+import io.zeebe.engine.state.instance.TimerInstanceState;\n+import io.zeebe.engine.state.instance.VariablesState;\n+import io.zeebe.engine.state.message.MessageStartEventSubscriptionState;\n+import io.zeebe.engine.state.message.MessageState;\n+import io.zeebe.engine.state.message.MessageSubscriptionState;\n+import io.zeebe.engine.state.message.WorkflowInstanceSubscriptionState;\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.protocol.record.intent.IncidentIntent;\n+import io.zeebe.protocol.record.intent.JobIntent;\n+import io.zeebe.protocol.record.intent.MessageStartEventSubscriptionIntent;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import org.awaitility.Awaitility;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public final class WorkflowExecutionCleanZeebeStateTest {\n+\n+  private static final String PROCESS_ID = \"workflow\";\n+\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  private ElementInstanceState elementInstanceState;\n+  private TimerInstanceState timerState;\n+  private EventScopeInstanceState eventScopeInstanceState;\n+  private JobState jobState;\n+  private IncidentState incidentState;\n+  private MessageState messageState;\n+  private MessageSubscriptionState messageSubscriptionState;\n+  private WorkflowInstanceSubscriptionState workflowInstanceSubscriptionState;\n+  private MessageStartEventSubscriptionState messageStartEventSubscriptionState;\n+  private VariablesState variablesState;\n+\n+  @Before\n+  public void init() {\n+    final var zeebeState = engineRule.getZeebeState();\n+\n+    final var workflowState = zeebeState.getWorkflowState();\n+    elementInstanceState = workflowState.getElementInstanceState();\n+    variablesState = elementInstanceState.getVariablesState();\n+    timerState = workflowState.getTimerState();\n+    eventScopeInstanceState = workflowState.getEventScopeInstanceState();\n+\n+    jobState = zeebeState.getJobState();\n+    incidentState = zeebeState.getIncidentState();\n+    messageState = zeebeState.getMessageState();\n+    messageSubscriptionState = zeebeState.getMessageSubscriptionState();\n+    workflowInstanceSubscriptionState = zeebeState.getWorkflowInstanceSubscriptionState();\n+    messageStartEventSubscriptionState = zeebeState.getMessageStartEventSubscriptionState();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithServiceTask() {\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .serviceTask(\"task\", t -> t.zeebeJobType(\"test\"))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).withVariable(\"x\", 1).create();\n+\n+    engineRule\n+        .job()\n+        .ofInstance(workflowInstanceKey)\n+        .withType(\"test\")\n+        .withVariable(\"y\", 2)\n+        .complete();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithSubprocess() {\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .subProcess(\n+                    \"subprocess\",\n+                    subProcess ->\n+                        subProcess\n+                            .zeebeInputExpression(\"x\", \"y\")\n+                            .zeebeOutputExpression(\"y\", \"z\")\n+                            .embeddedSubProcess()\n+                            .startEvent()\n+                            .endEvent())\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).withVariable(\"x\", 1).create();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithMultiInstance() {\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .serviceTask(\n+                    \"task\",\n+                    t ->\n+                        t.zeebeJobType(\"test\")\n+                            .multiInstance(\n+                                m ->\n+                                    m.zeebeInputCollectionExpression(\"items\")\n+                                        .zeebeInputElement(\"item\")\n+                                        .zeebeOutputCollection(\"results\")\n+                                        .zeebeOutputElementExpression(\"result\")))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule\n+            .workflowInstance()\n+            .ofBpmnProcessId(PROCESS_ID)\n+            .withVariable(\"items\", List.of(1))\n+            .create();\n+\n+    engineRule\n+        .job()\n+        .ofInstance(workflowInstanceKey)\n+        .withType(\"test\")\n+        .withVariable(\"result\", 2)\n+        .complete();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithTimerEvent() {\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .intermediateCatchEvent(\"timer\", e -> e.timerWithDuration(\"PT0S\"))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithMessageEvent() {\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .intermediateCatchEvent(\n+                    \"message\",\n+                    e ->\n+                        e.message(m -> m.name(\"message\").zeebeCorrelationKeyExpression(\"key\"))\n+                            .zeebeOutputExpression(\"x\", \"y\"))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule\n+            .workflowInstance()\n+            .ofBpmnProcessId(PROCESS_ID)\n+            .withVariable(\"key\", \"key-1\")\n+            .create();\n+\n+    final var timeToLive = Duration.ofSeconds(10);\n+    engineRule\n+        .message()\n+        .withName(\"message\")\n+        .withCorrelationKey(\"key-1\")\n+        .withTimeToLive(timeToLive)\n+        .withVariables(Map.of(\"x\", 1))\n+        .publish();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    engineRule.increaseTime(timeToLive.plus(MessageObserver.MESSAGE_TIME_TO_LIVE_CHECK_INTERVAL));\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithMessageStartEvent() {\n+    final var deployment =\n+        engineRule\n+            .deployment()\n+            .withXmlResource(\n+                Bpmn.createExecutableProcess(PROCESS_ID)\n+                    .startEvent()\n+                    .message(m -> m.name(\"message\").zeebeCorrelationKeyExpression(\"key\"))\n+                    .zeebeOutputExpression(\"x\", \"y\")\n+                    .endEvent()\n+                    .done())\n+            .deploy();\n+\n+    final var workflowKey = deployment.getValue().getDeployedWorkflows().get(0).getWorkflowKey();\n+\n+    final var timeToLive = Duration.ofSeconds(10);\n+    final var messagePublished =\n+        engineRule\n+            .message()\n+            .withName(\"message\")\n+            .withCorrelationKey(\"key-1\")\n+            .withTimeToLive(timeToLive)\n+            .withVariables(Map.of(\"x\", 1))\n+            .publish();\n+\n+    final var workflowInstanceKey =\n+        RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_ACTIVATING)\n+            .withWorkflowKey(workflowKey)\n+            .withElementType(BpmnElementType.PROCESS)\n+            .getFirst()\n+            .getKey();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    engineRule.increaseTime(timeToLive.plus(MessageObserver.MESSAGE_TIME_TO_LIVE_CHECK_INTERVAL));\n+\n+    // deploy new workflow without message start event to close the open subscription\n+    engineRule\n+        .deployment()\n+        .withXmlResource(Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done())\n+        .deploy();\n+\n+    RecordingExporter.messageStartEventSubscriptionRecords(\n+            MessageStartEventSubscriptionIntent.CLOSED)\n+        .withWorkfloKey(workflowKey)\n+        .await();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithErrorEvent() {\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .serviceTask(\"task\", t -> t.zeebeJobType(\"test\"))\n+                .boundaryEvent(\"error\", b -> b.error(\"ERROR\"))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).withVariable(\"x\", 1).create();\n+\n+    engineRule\n+        .job()\n+        .ofInstance(workflowInstanceKey)\n+        .withType(\"test\")\n+        .withErrorCode(\"ERROR\")\n+        .throwError();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithIncident() {\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .serviceTask(\"task\", t -> t.zeebeJobType(\"test\"))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).withVariable(\"x\", 1).create();\n+\n+    engineRule.job().ofInstance(workflowInstanceKey).withType(\"test\").withRetries(0).fail();\n+\n+    final var incidentCreated =\n+        RecordingExporter.incidentRecords(IncidentIntent.CREATED)\n+            .withWorkflowInstanceKey(workflowInstanceKey)\n+            .getFirst();\n+\n+    engineRule.job().withKey(incidentCreated.getValue().getJobKey()).withRetries(1).updateRetries();\n+\n+    engineRule\n+        .incident()\n+        .ofInstance(workflowInstanceKey)\n+        .withKey(incidentCreated.getKey())\n+        .resolve();\n+\n+    engineRule\n+        .job()\n+        .ofInstance(workflowInstanceKey)\n+        .withType(\"test\")\n+        .withVariable(\"y\", 2)\n+        .complete();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithExclusiveGateway() {\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .exclusiveGateway()\n+                .sequenceFlowId(\"s1\")\n+                .conditionExpression(\"x > 10\")\n+                .endEvent()\n+                .moveToLastGateway()\n+                .sequenceFlowId(\"s2\")\n+                .conditionExpression(\"x <= 10\")\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).withVariable(\"x\", 1).create();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithParallelGateway() {\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .parallelGateway(\"fork\")\n+                .endEvent()\n+                .moveToNode(\"fork\")\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithEventBasedGateway() {\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .eventBasedGateway()\n+                .intermediateCatchEvent(\"timer\", e -> e.timerWithDuration(\"PT0S\"))\n+                .endEvent()\n+                .moveToLastGateway()\n+                .intermediateCatchEvent(\n+                    \"message\",\n+                    e -> e.message(m -> m.name(\"message\").zeebeCorrelationKeyExpression(\"key\")))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule\n+            .workflowInstance()\n+            .ofBpmnProcessId(PROCESS_ID)\n+            .withVariable(\"key\", \"key-1\")\n+            .create();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithEventSubprocess() {\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .eventSubProcess(\n+                    \"event-subprocess\",\n+                    subprocess ->\n+                        subprocess\n+                            .startEvent()\n+                            .interrupting(true)\n+                            .timerWithDuration(\"PT0.1S\")\n+                            .endEvent())\n+                .startEvent()\n+                .serviceTask(\"task\", t -> t.zeebeJobType(\"test\"))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithCallActivity() {\n+    final var childWorkflow = Bpmn.createExecutableProcess(\"child\").startEvent().endEvent().done();\n+    final var parentWorkflow =\n+        Bpmn.createExecutableProcess(PROCESS_ID)\n+            .startEvent()\n+            .callActivity(\"call\", c -> c.zeebeProcessId(\"child\"))\n+            .endEvent()\n+            .done();\n+\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\"child.bpmn\", childWorkflow)\n+        .withXmlResource(\"parent.bpmn\", parentWorkflow)\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowCreatedWithResult() {\n+    engineRule\n+        .deployment()\n+        .withXmlResource(Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule\n+            .workflowInstance()\n+            .ofBpmnProcessId(PROCESS_ID)\n+            .withVariable(\"x\", 1)\n+            .withResult()\n+            .create();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowCanceled() {\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .serviceTask(\"task\", t -> t.zeebeJobType(\"test\"))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).withVariable(\"x\", 1).create();\n+\n+    RecordingExporter.jobRecords(JobIntent.CREATED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .await();\n+\n+    engineRule.workflowInstance().withInstanceKey(workflowInstanceKey).cancel();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_TERMINATED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  private void assertThatStateIsEmpty() {\n+    // sometimes the state takes few moments until is is empty\n+    Awaitility.await()\n+        .untilAsserted(\n+            () -> {\n+              assertThat(variablesState.isEmpty())", "originalCommit": "b8efca7db81189178e4968b25f85221aa2d36fc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkxOTcyMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r454919720", "bodyText": "Yes. The tests depend on the fact that all states are checked and isEmpty() is correct. I don't see how to enforce it.\nAt least for now, we can not check if the whole RocksDB is empty because the deployments are not removed.", "author": "saig0", "createdAt": "2020-07-15T09:31:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxOTk3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI4MDM1OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r456280358", "bodyText": "hmpf..\nWhat I would like to have is to check all column families and be able to exclude column families which should not be check like workflow column family. In that way we would find issues even if we add new column families, where resources are not cleaned up.", "author": "Zelldon", "createdAt": "2020-07-17T07:54:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxOTk3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA4Njg1MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r457086850", "bodyText": "Agree. Do you have an idea how we could do this?", "author": "saig0", "createdAt": "2020-07-20T06:15:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxOTk3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5MjM3MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r464192370", "bodyText": "I have one. We can have something like this at the ZeebeDB impl.\n  public boolean isEmpty(DbContext dbContext) {\n    var isEmpty = false;\n    for(var handle : columnFamilyMap.values()) {\n      isEmpty &= isEmpty(handle, dbContext);\n    }\n    return isEmpty;\n  }\n\nBut then you have the issue you meant before, with the column families where it is ok to contain values. I think we can modify the method in such a way that we ask for column families which contain values, like findNonEmptyColumnFamilies.  This method returns a list of column families which contain values. In the ZeebeState you can then check whether these families are the expected ones.", "author": "Zelldon", "createdAt": "2020-08-03T04:48:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxOTk3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg1MDE0OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r464850148", "bodyText": "Good idea. I introduced a new method in ZeebeDb to check if a column is empty.", "author": "saig0", "createdAt": "2020-08-04T07:21:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxOTk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2OTM5NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r465469394", "bodyText": "What is the default awaiting max time?", "author": "Zelldon", "createdAt": "2020-08-05T04:45:29Z", "path": "engine/src/test/java/io/zeebe/engine/state/WorkflowExecutionCleanStateTest.java", "diffHunk": "@@ -0,0 +1,612 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.state;\n+\n+import static java.util.function.Predicate.not;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.zeebe.engine.processing.message.MessageObserver;\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.protocol.record.intent.IncidentIntent;\n+import io.zeebe.protocol.record.intent.JobIntent;\n+import io.zeebe.protocol.record.intent.MessageStartEventSubscriptionIntent;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import org.awaitility.Awaitility;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public final class WorkflowExecutionCleanStateTest {\n+\n+  private static final String PROCESS_ID = \"workflow\";\n+\n+  private static final List<ZbColumnFamilies> IGNORE_NON_EMPTY_COLUMNS =\n+      List.of(\n+          ZbColumnFamilies.DEFAULT,\n+          ZbColumnFamilies.KEY,\n+          ZbColumnFamilies.WORKFLOW_VERSION,\n+          ZbColumnFamilies.WORKFLOW_CACHE,\n+          ZbColumnFamilies.WORKFLOW_CACHE_BY_ID_AND_VERSION,\n+          ZbColumnFamilies.WORKFLOW_CACHE_LATEST_KEY,\n+          ZbColumnFamilies.WORKFLOW_CACHE_DIGEST_BY_ID);\n+\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  private ZeebeState zeebeState;\n+\n+  @Before\n+  public void init() {\n+    zeebeState = engineRule.getZeebeState();\n+\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithServiceTask() {\n+    // given\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .serviceTask(\"task\", t -> t.zeebeJobType(\"test\"))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    // when\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).withVariable(\"x\", 1).create();\n+\n+    engineRule\n+        .job()\n+        .ofInstance(workflowInstanceKey)\n+        .withType(\"test\")\n+        .withVariable(\"y\", 2)\n+        .complete();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    // then\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithSubprocess() {\n+    // given\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .subProcess(\n+                    \"subprocess\",\n+                    subProcess ->\n+                        subProcess\n+                            .zeebeInputExpression(\"x\", \"y\")\n+                            .zeebeOutputExpression(\"y\", \"z\")\n+                            .embeddedSubProcess()\n+                            .startEvent()\n+                            .endEvent())\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    // when\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).withVariable(\"x\", 1).create();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    // then\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithMultiInstance() {\n+    // given\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .serviceTask(\n+                    \"task\",\n+                    t ->\n+                        t.zeebeJobType(\"test\")\n+                            .multiInstance(\n+                                m ->\n+                                    m.zeebeInputCollectionExpression(\"items\")\n+                                        .zeebeInputElement(\"item\")\n+                                        .zeebeOutputCollection(\"results\")\n+                                        .zeebeOutputElementExpression(\"result\")))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    // when\n+    final var workflowInstanceKey =\n+        engineRule\n+            .workflowInstance()\n+            .ofBpmnProcessId(PROCESS_ID)\n+            .withVariable(\"items\", List.of(1))\n+            .create();\n+\n+    engineRule\n+        .job()\n+        .ofInstance(workflowInstanceKey)\n+        .withType(\"test\")\n+        .withVariable(\"result\", 2)\n+        .complete();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    // then\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithTimerEvent() {\n+    // given\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .intermediateCatchEvent(\"timer\", e -> e.timerWithDuration(\"PT0S\"))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    // when\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    // then\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithMessageEvent() {\n+    // given\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .intermediateCatchEvent(\n+                    \"message\",\n+                    e ->\n+                        e.message(m -> m.name(\"message\").zeebeCorrelationKeyExpression(\"key\"))\n+                            .zeebeOutputExpression(\"x\", \"y\"))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule\n+            .workflowInstance()\n+            .ofBpmnProcessId(PROCESS_ID)\n+            .withVariable(\"key\", \"key-1\")\n+            .create();\n+\n+    // when\n+    final var timeToLive = Duration.ofSeconds(10);\n+    engineRule\n+        .message()\n+        .withName(\"message\")\n+        .withCorrelationKey(\"key-1\")\n+        .withTimeToLive(timeToLive)\n+        .withVariables(Map.of(\"x\", 1))\n+        .publish();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    engineRule.increaseTime(timeToLive.plus(MessageObserver.MESSAGE_TIME_TO_LIVE_CHECK_INTERVAL));\n+\n+    // then\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithMessageStartEvent() {\n+    // given\n+    final var deployment =\n+        engineRule\n+            .deployment()\n+            .withXmlResource(\n+                Bpmn.createExecutableProcess(PROCESS_ID)\n+                    .startEvent()\n+                    .message(m -> m.name(\"message\").zeebeCorrelationKeyExpression(\"key\"))\n+                    .zeebeOutputExpression(\"x\", \"y\")\n+                    .endEvent()\n+                    .done())\n+            .deploy();\n+\n+    final var workflowKey = deployment.getValue().getDeployedWorkflows().get(0).getWorkflowKey();\n+\n+    // when\n+    final var timeToLive = Duration.ofSeconds(10);\n+    final var messagePublished =\n+        engineRule\n+            .message()\n+            .withName(\"message\")\n+            .withCorrelationKey(\"key-1\")\n+            .withTimeToLive(timeToLive)\n+            .withVariables(Map.of(\"x\", 1))\n+            .publish();\n+\n+    final var workflowInstanceKey =\n+        RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_ACTIVATING)\n+            .withWorkflowKey(workflowKey)\n+            .withElementType(BpmnElementType.PROCESS)\n+            .getFirst()\n+            .getKey();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    engineRule.increaseTime(timeToLive.plus(MessageObserver.MESSAGE_TIME_TO_LIVE_CHECK_INTERVAL));\n+\n+    // deploy new workflow without message start event to close the open subscription\n+    engineRule\n+        .deployment()\n+        .withXmlResource(Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done())\n+        .deploy();\n+\n+    RecordingExporter.messageStartEventSubscriptionRecords(\n+            MessageStartEventSubscriptionIntent.CLOSED)\n+        .withWorkfloKey(workflowKey)\n+        .await();\n+\n+    // then\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithErrorEvent() {\n+    // given\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .serviceTask(\"task\", t -> t.zeebeJobType(\"test\"))\n+                .boundaryEvent(\"error\", b -> b.error(\"ERROR\"))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).withVariable(\"x\", 1).create();\n+\n+    // when\n+    engineRule\n+        .job()\n+        .ofInstance(workflowInstanceKey)\n+        .withType(\"test\")\n+        .withErrorCode(\"ERROR\")\n+        .throwError();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    // then\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithIncident() {\n+    // given\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .serviceTask(\"task\", t -> t.zeebeJobType(\"test\"))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).withVariable(\"x\", 1).create();\n+\n+    // when\n+    engineRule.job().ofInstance(workflowInstanceKey).withType(\"test\").withRetries(0).fail();\n+\n+    final var incidentCreated =\n+        RecordingExporter.incidentRecords(IncidentIntent.CREATED)\n+            .withWorkflowInstanceKey(workflowInstanceKey)\n+            .getFirst();\n+\n+    engineRule.job().withKey(incidentCreated.getValue().getJobKey()).withRetries(1).updateRetries();\n+\n+    engineRule\n+        .incident()\n+        .ofInstance(workflowInstanceKey)\n+        .withKey(incidentCreated.getKey())\n+        .resolve();\n+\n+    engineRule\n+        .job()\n+        .ofInstance(workflowInstanceKey)\n+        .withType(\"test\")\n+        .withVariable(\"y\", 2)\n+        .complete();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    // then\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithExclusiveGateway() {\n+    // given\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .exclusiveGateway()\n+                .sequenceFlowId(\"s1\")\n+                .conditionExpression(\"x > 10\")\n+                .endEvent()\n+                .moveToLastGateway()\n+                .sequenceFlowId(\"s2\")\n+                .conditionExpression(\"x <= 10\")\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    // when\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).withVariable(\"x\", 1).create();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    // then\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithParallelGateway() {\n+    // given\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .parallelGateway(\"fork\")\n+                .endEvent()\n+                .moveToNode(\"fork\")\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    // when\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    // then\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithEventBasedGateway() {\n+    // given\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .eventBasedGateway()\n+                .intermediateCatchEvent(\"timer\", e -> e.timerWithDuration(\"PT0S\"))\n+                .endEvent()\n+                .moveToLastGateway()\n+                .intermediateCatchEvent(\n+                    \"message\",\n+                    e -> e.message(m -> m.name(\"message\").zeebeCorrelationKeyExpression(\"key\")))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    // when\n+    final var workflowInstanceKey =\n+        engineRule\n+            .workflowInstance()\n+            .ofBpmnProcessId(PROCESS_ID)\n+            .withVariable(\"key\", \"key-1\")\n+            .create();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    // then\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithEventSubprocess() {\n+    // given\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .eventSubProcess(\n+                    \"event-subprocess\",\n+                    subprocess ->\n+                        subprocess\n+                            .startEvent()\n+                            .interrupting(true)\n+                            .timerWithDuration(\"PT0.1S\")\n+                            .endEvent())\n+                .startEvent()\n+                .serviceTask(\"task\", t -> t.zeebeJobType(\"test\"))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    // when\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    // then\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowWithCallActivity() {\n+    // given\n+    final var childWorkflow = Bpmn.createExecutableProcess(\"child\").startEvent().endEvent().done();\n+    final var parentWorkflow =\n+        Bpmn.createExecutableProcess(PROCESS_ID)\n+            .startEvent()\n+            .callActivity(\"call\", c -> c.zeebeProcessId(\"child\"))\n+            .endEvent()\n+            .done();\n+\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\"child.bpmn\", childWorkflow)\n+        .withXmlResource(\"parent.bpmn\", parentWorkflow)\n+        .deploy();\n+\n+    // when\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    // then\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowCreatedWithResult() {\n+    // given\n+    engineRule\n+        .deployment()\n+        .withXmlResource(Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done())\n+        .deploy();\n+\n+    // when\n+    final var workflowInstanceKey =\n+        engineRule\n+            .workflowInstance()\n+            .ofBpmnProcessId(PROCESS_ID)\n+            .withVariable(\"x\", 1)\n+            .withResult()\n+            .create();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_COMPLETED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    // then\n+    assertThatStateIsEmpty();\n+  }\n+\n+  @Test\n+  public void testWorkflowCanceled() {\n+    // given\n+    engineRule\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(PROCESS_ID)\n+                .startEvent()\n+                .serviceTask(\"task\", t -> t.zeebeJobType(\"test\"))\n+                .endEvent()\n+                .done())\n+        .deploy();\n+\n+    final var workflowInstanceKey =\n+        engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).withVariable(\"x\", 1).create();\n+\n+    RecordingExporter.jobRecords(JobIntent.CREATED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .await();\n+\n+    // when\n+    engineRule.workflowInstance().withInstanceKey(workflowInstanceKey).cancel();\n+\n+    RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_TERMINATED)\n+        .withWorkflowInstanceKey(workflowInstanceKey)\n+        .withElementType(BpmnElementType.PROCESS)\n+        .await();\n+\n+    // then\n+    assertThatStateIsEmpty();\n+  }\n+\n+  private void assertThatStateIsEmpty() {\n+    // sometimes the state takes few moments until is is empty\n+    Awaitility.await()\n+        .untilAsserted(", "originalCommit": "f4c904b26a9524743b3fc79ea285dae914e5aee0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3MjM1Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r465472356", "bodyText": "By default, it waits 10 seconds.", "author": "saig0", "createdAt": "2020-08-05T04:55:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2OTM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3MjgxNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4963#discussion_r465472817", "bodyText": "ok thanks", "author": "Zelldon", "createdAt": "2020-08-05T04:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2OTM5NA=="}], "type": "inlineReview"}, {"oid": "2d4265df0eac4671cf3eb62b924e032eca9ea9eb", "url": "https://github.com/camunda-cloud/zeebe/commit/2d4265df0eac4671cf3eb62b924e032eca9ea9eb", "message": "fix(broker): clean up the workflow state\n\n* don't store event variables in the state if the event doesn't provide any variables (e.g. for timer/error events)\n* remove data from the event scope instance state when the message start event subscription is closed\n* add test case to verify that the workflow execution clean its state after the workflow instance is completed", "committedDate": "2020-08-05T05:38:06Z", "type": "commit"}, {"oid": "2d4265df0eac4671cf3eb62b924e032eca9ea9eb", "url": "https://github.com/camunda-cloud/zeebe/commit/2d4265df0eac4671cf3eb62b924e032eca9ea9eb", "message": "fix(broker): clean up the workflow state\n\n* don't store event variables in the state if the event doesn't provide any variables (e.g. for timer/error events)\n* remove data from the event scope instance state when the message start event subscription is closed\n* add test case to verify that the workflow execution clean its state after the workflow instance is completed", "committedDate": "2020-08-05T05:38:06Z", "type": "forcePushed"}]}