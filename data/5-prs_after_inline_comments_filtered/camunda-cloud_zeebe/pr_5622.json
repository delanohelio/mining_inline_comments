{"pr_number": 5622, "pr_title": "Add randomized property tests for raft", "pr_createdAt": "2020-10-19T12:37:50Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/5622", "timeline": [{"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "url": "https://github.com/camunda-cloud/zeebe/commit/cf729ba4194edfbd54351a0aea3ba9bdfb022538", "message": "chore(broker): add raft property tests", "committedDate": "2020-10-22T06:53:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkxNjI1MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509916251", "bodyText": "Didn't I reviewed that before? \ud83e\udd14", "author": "Zelldon", "createdAt": "2020-10-22T06:45:55Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java", "diffHunk": "@@ -552,20 +551,16 @@ default boolean isLeader() {\n \n     private static final Duration DEFAULT_ELECTION_TIMEOUT = Duration.ofMillis(750);\n     private static final Duration DEFAULT_HEARTBEAT_INTERVAL = Duration.ofMillis(250);\n-    private static final ThreadModel DEFAULT_THREAD_MODEL = ThreadModel.SHARED_THREAD_POOL;\n-    private static final int DEFAULT_THREAD_POOL_SIZE =\n-        Math.max(Math.min(Runtime.getRuntime().availableProcessors() * 2, 8), 4);\n \n     protected String name;\n     protected MemberId localMemberId;\n     protected ClusterMembershipService membershipService;\n     protected RaftServerProtocol protocol;\n     protected RaftStorage storage;\n+    protected RaftThreadContextFactory threadContextFactory;\n     protected Duration electionTimeout = DEFAULT_ELECTION_TIMEOUT;\n     protected Duration heartbeatInterval = DEFAULT_HEARTBEAT_INTERVAL;\n-    protected ThreadModel threadModel = DEFAULT_THREAD_MODEL;\n-    protected int threadPoolSize = DEFAULT_THREAD_POOL_SIZE;\n-    protected ThreadContextFactory threadContextFactory;\n+    protected Supplier<Random> randomFactory;", "originalCommit": "9c8d7afa4c6bfed61dc7a5f000c774dbc38c803b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkyMDgxMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509920811", "bodyText": "Could we create a follow up issue to fix this non determinism? Like introducing a clock?", "author": "Zelldon", "createdAt": "2020-10-22T06:55:21Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/ControllableRaftContexts.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.impl.RaftContext;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.protocol.ControllableRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.snapshot.TestSnapshotStore;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.zeebe.NoopEntryValidator;\n+import io.atomix.raft.zeebe.ZeebeLogAppender.AppendListener;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.JournalReader;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.zeebe.util.collection.Tuple;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Uses a DeterministicScheduler and controllable messaging layer to get a deterministic execution", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIwNjY2Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r510206662", "bodyText": "\ud83d\udc4d #5668", "author": "deepthidevaki", "createdAt": "2020-10-22T14:26:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkyMDgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkyNDQyMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509924421", "bodyText": "Couldn't we introduce in our normal code that node one for partition one does immediately a poll? Last time we had the direct transition, which was not really safe.", "author": "Zelldon", "createdAt": "2020-10-22T07:02:36Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/ControllableRaftContexts.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.impl.RaftContext;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.protocol.ControllableRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.snapshot.TestSnapshotStore;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.zeebe.NoopEntryValidator;\n+import io.atomix.raft.zeebe.ZeebeLogAppender.AppendListener;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.JournalReader;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.zeebe.util.collection.Tuple;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Uses a DeterministicScheduler and controllable messaging layer to get a deterministic execution\n+ * of raft threads. Note:- Currently there is some non-determinism hidden in the raft. Hence the\n+ * resulting execution is not fully deterministic.\n+ */\n+public class ControllableRaftContexts {\n+\n+  private final Map<MemberId, ControllableRaftServerProtocol> serverProtocols = new HashMap<>();\n+  private final Map<MemberId, Queue<Tuple<Runnable, CompletableFuture>>> messageQueue =\n+      new HashMap<>();\n+  private final Map<MemberId, DeterministicSingleThreadContext> deterministicExecutors =\n+      new HashMap<>();\n+\n+  private Path directory;\n+\n+  private final int nodeCount;\n+  private final Map<MemberId, RaftContext> raftServers = new HashMap<>();\n+  private Duration electionTimeout;\n+  private Duration hearbeatTimeout;\n+  private int nextEntry = 0;\n+\n+  // Used only for verification. Map[term -> leader]\n+  private final Map<Long, MemberId> leadersAtTerms = new HashMap<>();\n+\n+  public ControllableRaftContexts(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public Map<MemberId, RaftContext> getRaftServers() {\n+    return raftServers;\n+  }\n+\n+  public RaftContext getRaftContext(final int memberId) {\n+    return raftServers.get(MemberId.from(String.valueOf(memberId)));\n+  }\n+\n+  public RaftContext getRaftContext(final MemberId memberId) {\n+    return raftServers.get(memberId);\n+  }\n+\n+  public void setup(final Path directory, final Random random) throws Exception {\n+    this.directory = directory;\n+    if (nodeCount > 0) {\n+      createRaftContexts(nodeCount, random);\n+    }\n+    joinRaftServers();\n+    electionTimeout = getRaftContext(0).getElectionTimeout();\n+    hearbeatTimeout = getRaftContext(0).getHeartbeatInterval();\n+\n+    // expecting 0 to be the leader\n+    tickHeartbeatTimeout(0);\n+  }\n+\n+  public void shudown() throws IOException {\n+    raftServers.forEach((m, c) -> c.close());\n+    raftServers.clear();\n+    serverProtocols.clear();\n+    deterministicExecutors.forEach((m, e) -> e.close());\n+    deterministicExecutors.clear();\n+    messageQueue.clear();\n+    leadersAtTerms.clear();\n+    directory = null;\n+  }\n+\n+  private void joinRaftServers() throws InterruptedException, ExecutionException, TimeoutException {\n+    final Set<CompletableFuture<Void>> futures = new HashSet<>();\n+    final var servers = getRaftServers();\n+    final var serverIds = new ArrayList<>(servers.keySet());\n+    final long electionTimeout =\n+        servers.get(MemberId.from(String.valueOf(0))).getElectionTimeout().toMillis();\n+    Collections.sort(serverIds);\n+    servers.forEach(\n+        (memberId, raftContext) -> futures.add(raftContext.getCluster().bootstrap(serverIds)));\n+\n+    runUntilDone(0);\n+    // trigger election on 0 so that 0 is initially the leader\n+    getDeterministicScheduler(MemberId.from(String.valueOf(0)))", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4MTMwMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r510181302", "bodyText": "We can do. But that could also lead to a leader election whenever a node (re)starts. So when a leader dies, a new leader is elected, when the old leader comes back (after a few seconds/minutes) there will be an election again which may or may not result in a new leader.", "author": "deepthidevaki", "createdAt": "2020-10-22T13:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkyNDQyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc1Mzg0NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r510753845", "bodyText": "But for that we have the poll mechanism right? So first it starts a poll and this should be rejected if the other followers have received recently heart beats right?", "author": "Zelldon", "createdAt": "2020-10-23T09:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkyNDQyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDg3MDY4MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r510870680", "bodyText": "If this regarding balancing leader across replicas, can we discuss it separately?", "author": "deepthidevaki", "createdAt": "2020-10-23T13:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkyNDQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkyODIzNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509928234", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class ControllableRaftContexts {\n          \n          \n            \n            public final class ControllableRaftContexts {", "author": "Zelldon", "createdAt": "2020-10-22T07:10:32Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/ControllableRaftContexts.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.impl.RaftContext;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.protocol.ControllableRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.snapshot.TestSnapshotStore;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.zeebe.NoopEntryValidator;\n+import io.atomix.raft.zeebe.ZeebeLogAppender.AppendListener;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.JournalReader;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.zeebe.util.collection.Tuple;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Uses a DeterministicScheduler and controllable messaging layer to get a deterministic execution\n+ * of raft threads. Note:- Currently there is some non-determinism hidden in the raft. Hence the\n+ * resulting execution is not fully deterministic.\n+ */\n+public class ControllableRaftContexts {", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkyODM0Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509928343", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class DeterministicSingleThreadContext implements ThreadContext {\n          \n          \n            \n            public final class DeterministicSingleThreadContext implements ThreadContext {", "author": "Zelldon", "createdAt": "2020-10-22T07:10:43Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/DeterministicSingleThreadContext.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.fail;\n+\n+import io.atomix.utils.concurrent.Scheduled;\n+import io.atomix.utils.concurrent.ScheduledFutureImpl;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+\n+public class DeterministicSingleThreadContext implements ThreadContext {", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzMDg2Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509930866", "bodyText": "is not used", "author": "Zelldon", "createdAt": "2020-10-22T07:15:27Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/DeterministicSingleThreadContext.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.fail;\n+\n+import io.atomix.utils.concurrent.Scheduled;\n+import io.atomix.utils.concurrent.ScheduledFutureImpl;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+\n+public class DeterministicSingleThreadContext implements ThreadContext {\n+\n+  private final DeterministicScheduler deterministicScheduler;\n+  private final Consumer<Throwable> uncaughtExceptionObserver;", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzMDk2Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509930967", "bodyText": "factory is not used", "author": "Zelldon", "createdAt": "2020-10-22T07:15:37Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/DeterministicSingleThreadContext.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.fail;\n+\n+import io.atomix.utils.concurrent.Scheduled;\n+import io.atomix.utils.concurrent.ScheduledFutureImpl;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+\n+public class DeterministicSingleThreadContext implements ThreadContext {\n+\n+  private final DeterministicScheduler deterministicScheduler;\n+  private final Consumer<Throwable> uncaughtExceptionObserver;\n+\n+  public DeterministicSingleThreadContext(\n+      final DeterministicScheduler executor, final Consumer<Throwable> uncaughtExceptionObserver) {\n+    deterministicScheduler = executor;\n+    this.uncaughtExceptionObserver = uncaughtExceptionObserver;\n+  }\n+\n+  public DeterministicScheduler getDeterministicScheduler() {\n+    return deterministicScheduler;\n+  }\n+\n+  public static ThreadContext createContext(\n+      final ThreadFactory factory, final Consumer<Throwable> unCaughtExceptionHandler) {", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzMTMzMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509931330", "bodyText": "Normally if you have a static factory method I would expect you make the ctor private.", "author": "Zelldon", "createdAt": "2020-10-22T07:16:16Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/DeterministicSingleThreadContext.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.fail;\n+\n+import io.atomix.utils.concurrent.Scheduled;\n+import io.atomix.utils.concurrent.ScheduledFutureImpl;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+\n+public class DeterministicSingleThreadContext implements ThreadContext {\n+\n+  private final DeterministicScheduler deterministicScheduler;\n+  private final Consumer<Throwable> uncaughtExceptionObserver;\n+\n+  public DeterministicSingleThreadContext(\n+      final DeterministicScheduler executor, final Consumer<Throwable> uncaughtExceptionObserver) {\n+    deterministicScheduler = executor;\n+    this.uncaughtExceptionObserver = uncaughtExceptionObserver;\n+  }\n+\n+  public DeterministicScheduler getDeterministicScheduler() {\n+    return deterministicScheduler;\n+  }\n+\n+  public static ThreadContext createContext(", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzMjM2Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509932362", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  } catch (final Throwable e) {\n          \n          \n            \n                  } catch (final Exception e) {", "author": "Zelldon", "createdAt": "2020-10-22T07:18:22Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/DeterministicSingleThreadContext.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.fail;\n+\n+import io.atomix.utils.concurrent.Scheduled;\n+import io.atomix.utils.concurrent.ScheduledFutureImpl;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+\n+public class DeterministicSingleThreadContext implements ThreadContext {\n+\n+  private final DeterministicScheduler deterministicScheduler;\n+  private final Consumer<Throwable> uncaughtExceptionObserver;\n+\n+  public DeterministicSingleThreadContext(\n+      final DeterministicScheduler executor, final Consumer<Throwable> uncaughtExceptionObserver) {\n+    deterministicScheduler = executor;\n+    this.uncaughtExceptionObserver = uncaughtExceptionObserver;\n+  }\n+\n+  public DeterministicScheduler getDeterministicScheduler() {\n+    return deterministicScheduler;\n+  }\n+\n+  public static ThreadContext createContext(\n+      final ThreadFactory factory, final Consumer<Throwable> unCaughtExceptionHandler) {\n+    return new DeterministicSingleThreadContext(\n+        new DeterministicScheduler(), unCaughtExceptionHandler);\n+  }\n+\n+  @Override\n+  public Scheduled schedule(final long delay, final TimeUnit timeUnit, final Runnable command) {\n+    final var future =\n+        deterministicScheduler.schedule(new WrappedRunnable(command), delay, timeUnit);\n+    return new ScheduledFutureImpl<>(future);\n+  }\n+\n+  @Override\n+  public Scheduled schedule(final Duration delay, final Runnable command) {\n+    final var future =\n+        deterministicScheduler.schedule(\n+            new WrappedRunnable(command), delay.toMillis(), TimeUnit.MILLISECONDS);\n+    return new ScheduledFutureImpl<>(future);\n+  }\n+\n+  @Override\n+  public Scheduled schedule(\n+      final long initialDelay,\n+      final long interval,\n+      final TimeUnit timeUnit,\n+      final Runnable command) {\n+    final ScheduledFuture<?> future =\n+        deterministicScheduler.scheduleAtFixedRate(\n+            new WrappedRunnable(command), initialDelay, interval, timeUnit);\n+    return new ScheduledFutureImpl<>(future);\n+  }\n+\n+  @Override\n+  public Scheduled schedule(\n+      final Duration initialDelay, final Duration interval, final Runnable command) {\n+    final ScheduledFuture<?> future =\n+        deterministicScheduler.scheduleAtFixedRate(\n+            new WrappedRunnable(command),\n+            initialDelay.toMillis(),\n+            interval.toMillis(),\n+            TimeUnit.MILLISECONDS);\n+    return new ScheduledFutureImpl<>(future);\n+  }\n+\n+  @Override\n+  public void execute(final Runnable command) {\n+    deterministicScheduler.execute(new WrappedRunnable(command));\n+  }\n+\n+  @Override\n+  public boolean isCurrentContext() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void checkThread() {\n+    // always assume running on the right context\n+  }\n+\n+  @Override\n+  public boolean isBlocked() {\n+    return false;\n+  }\n+\n+  @Override\n+  public void block() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void unblock() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void close() {\n+    // do nothing\n+  }\n+\n+  class WrappedRunnable implements Runnable {\n+\n+    private final Runnable command;\n+\n+    WrappedRunnable(final Runnable command) {\n+      this.command = command;\n+    }\n+\n+    @Override\n+    public void run() {\n+      try {\n+        command.run();\n+      } catch (final Throwable e) {", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzMjUwOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509932509", "bodyText": "static\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              class WrappedRunnable implements Runnable {\n          \n          \n            \n            static final class WrappedRunnable implements Runnable {", "author": "Zelldon", "createdAt": "2020-10-22T07:18:38Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/DeterministicSingleThreadContext.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.fail;\n+\n+import io.atomix.utils.concurrent.Scheduled;\n+import io.atomix.utils.concurrent.ScheduledFutureImpl;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+\n+public class DeterministicSingleThreadContext implements ThreadContext {\n+\n+  private final DeterministicScheduler deterministicScheduler;\n+  private final Consumer<Throwable> uncaughtExceptionObserver;\n+\n+  public DeterministicSingleThreadContext(\n+      final DeterministicScheduler executor, final Consumer<Throwable> uncaughtExceptionObserver) {\n+    deterministicScheduler = executor;\n+    this.uncaughtExceptionObserver = uncaughtExceptionObserver;\n+  }\n+\n+  public DeterministicScheduler getDeterministicScheduler() {\n+    return deterministicScheduler;\n+  }\n+\n+  public static ThreadContext createContext(\n+      final ThreadFactory factory, final Consumer<Throwable> unCaughtExceptionHandler) {\n+    return new DeterministicSingleThreadContext(\n+        new DeterministicScheduler(), unCaughtExceptionHandler);\n+  }\n+\n+  @Override\n+  public Scheduled schedule(final long delay, final TimeUnit timeUnit, final Runnable command) {\n+    final var future =\n+        deterministicScheduler.schedule(new WrappedRunnable(command), delay, timeUnit);\n+    return new ScheduledFutureImpl<>(future);\n+  }\n+\n+  @Override\n+  public Scheduled schedule(final Duration delay, final Runnable command) {\n+    final var future =\n+        deterministicScheduler.schedule(\n+            new WrappedRunnable(command), delay.toMillis(), TimeUnit.MILLISECONDS);\n+    return new ScheduledFutureImpl<>(future);\n+  }\n+\n+  @Override\n+  public Scheduled schedule(\n+      final long initialDelay,\n+      final long interval,\n+      final TimeUnit timeUnit,\n+      final Runnable command) {\n+    final ScheduledFuture<?> future =\n+        deterministicScheduler.scheduleAtFixedRate(\n+            new WrappedRunnable(command), initialDelay, interval, timeUnit);\n+    return new ScheduledFutureImpl<>(future);\n+  }\n+\n+  @Override\n+  public Scheduled schedule(\n+      final Duration initialDelay, final Duration interval, final Runnable command) {\n+    final ScheduledFuture<?> future =\n+        deterministicScheduler.scheduleAtFixedRate(\n+            new WrappedRunnable(command),\n+            initialDelay.toMillis(),\n+            interval.toMillis(),\n+            TimeUnit.MILLISECONDS);\n+    return new ScheduledFutureImpl<>(future);\n+  }\n+\n+  @Override\n+  public void execute(final Runnable command) {\n+    deterministicScheduler.execute(new WrappedRunnable(command));\n+  }\n+\n+  @Override\n+  public boolean isCurrentContext() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void checkThread() {\n+    // always assume running on the right context\n+  }\n+\n+  @Override\n+  public boolean isBlocked() {\n+    return false;\n+  }\n+\n+  @Override\n+  public void block() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void unblock() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void close() {\n+    // do nothing\n+  }\n+\n+  class WrappedRunnable implements Runnable {", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzMjgzNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509932835", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              final BiConsumer<ControllableRaftContexts, MemberId> operation;\n          \n          \n            \n              private final BiConsumer<ControllableRaftContexts, MemberId> operation;", "author": "Zelldon", "createdAt": "2020-10-22T07:19:15Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftOperation.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import io.atomix.cluster.MemberId;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+\n+/** An operation that can be executed on a raft member */\n+public class RaftOperation {\n+\n+  final BiConsumer<ControllableRaftContexts, MemberId> operation;", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzMjk5MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509932990", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              RaftOperation(final String name, final BiConsumer<ControllableRaftContexts, MemberId> operation) {\n          \n          \n            \n              private RaftOperation(final String name, final BiConsumer<ControllableRaftContexts, MemberId> operation) {", "author": "Zelldon", "createdAt": "2020-10-22T07:19:32Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftOperation.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import io.atomix.cluster.MemberId;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+\n+/** An operation that can be executed on a raft member */\n+public class RaftOperation {\n+\n+  final BiConsumer<ControllableRaftContexts, MemberId> operation;\n+  private final String name;\n+\n+  RaftOperation(final String name, final BiConsumer<ControllableRaftContexts, MemberId> operation) {", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzNDM1OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509934358", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              List<RaftOperation> operations;\n          \n          \n            \n              List<MemberId> raftMembers;\n          \n          \n            \n              File raftDataDirectory;\n          \n          \n            \n              private List<RaftOperation> operations;\n          \n          \n            \n              private List<MemberId> raftMembers;\n          \n          \n            \n              private File raftDataDirectory;", "author": "Zelldon", "createdAt": "2020-10-22T07:21:58Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RandomizedRaftTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import com.google.common.io.Files;\n+import io.atomix.cluster.MemberId;\n+import io.zeebe.util.FileUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import net.jqwik.api.Arbitraries;\n+import net.jqwik.api.Arbitrary;\n+import net.jqwik.api.EdgeCasesMode;\n+import net.jqwik.api.ForAll;\n+import net.jqwik.api.Property;\n+import net.jqwik.api.Provide;\n+import net.jqwik.api.ShrinkingMode;\n+import net.jqwik.api.lifecycle.AfterTry;\n+import net.jqwik.api.lifecycle.BeforeProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class RandomizedRaftTest {\n+\n+  private static final int OPERATION_SIZE = 10000;\n+  private static final Logger LOG = LoggerFactory.getLogger(RandomizedRaftTest.class);\n+  public ControllableRaftContexts raftContexts;\n+  List<RaftOperation> operations;\n+  List<MemberId> raftMembers;\n+  File raftDataDirectory;", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzNDc1MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509934751", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public ControllableRaftContexts raftContexts;\n          \n          \n            \n              private ControllableRaftContexts raftContexts;", "author": "Zelldon", "createdAt": "2020-10-22T07:22:38Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RandomizedRaftTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import com.google.common.io.Files;\n+import io.atomix.cluster.MemberId;\n+import io.zeebe.util.FileUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import net.jqwik.api.Arbitraries;\n+import net.jqwik.api.Arbitrary;\n+import net.jqwik.api.EdgeCasesMode;\n+import net.jqwik.api.ForAll;\n+import net.jqwik.api.Property;\n+import net.jqwik.api.Provide;\n+import net.jqwik.api.ShrinkingMode;\n+import net.jqwik.api.lifecycle.AfterTry;\n+import net.jqwik.api.lifecycle.BeforeProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class RandomizedRaftTest {\n+\n+  private static final int OPERATION_SIZE = 10000;\n+  private static final Logger LOG = LoggerFactory.getLogger(RandomizedRaftTest.class);\n+  public ControllableRaftContexts raftContexts;", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzNTM5NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509935394", "bodyText": "why we need to copy this here?", "author": "Zelldon", "createdAt": "2020-10-22T07:23:49Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RandomizedRaftTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import com.google.common.io.Files;\n+import io.atomix.cluster.MemberId;\n+import io.zeebe.util.FileUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import net.jqwik.api.Arbitraries;\n+import net.jqwik.api.Arbitrary;\n+import net.jqwik.api.EdgeCasesMode;\n+import net.jqwik.api.ForAll;\n+import net.jqwik.api.Property;\n+import net.jqwik.api.Provide;\n+import net.jqwik.api.ShrinkingMode;\n+import net.jqwik.api.lifecycle.AfterTry;\n+import net.jqwik.api.lifecycle.BeforeProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class RandomizedRaftTest {\n+\n+  private static final int OPERATION_SIZE = 10000;\n+  private static final Logger LOG = LoggerFactory.getLogger(RandomizedRaftTest.class);\n+  public ControllableRaftContexts raftContexts;\n+  List<RaftOperation> operations;\n+  List<MemberId> raftMembers;\n+  File raftDataDirectory;\n+\n+  @BeforeProperty\n+  public void initOperations() {\n+    // Need members ids to generate pair operations\n+    final var servers =\n+        IntStream.range(0, 3)\n+            .mapToObj(String::valueOf)\n+            .map(MemberId::from)\n+            .collect(Collectors.toList());\n+    operations = RaftOperation.getDefaultRaftOperations();\n+    raftMembers = List.copyOf(servers);", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4MjA4Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r510182083", "bodyText": "Not needed. Sorry. left overs from debugging :)", "author": "deepthidevaki", "createdAt": "2020-10-22T13:56:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzNTM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzODAwNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509938004", "bodyText": "With Java 11 you can use the build in Files.createTempDirectory(null); method", "author": "Zelldon", "createdAt": "2020-10-22T07:28:38Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RandomizedRaftTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import com.google.common.io.Files;\n+import io.atomix.cluster.MemberId;\n+import io.zeebe.util.FileUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import net.jqwik.api.Arbitraries;\n+import net.jqwik.api.Arbitrary;\n+import net.jqwik.api.EdgeCasesMode;\n+import net.jqwik.api.ForAll;\n+import net.jqwik.api.Property;\n+import net.jqwik.api.Provide;\n+import net.jqwik.api.ShrinkingMode;\n+import net.jqwik.api.lifecycle.AfterTry;\n+import net.jqwik.api.lifecycle.BeforeProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class RandomizedRaftTest {\n+\n+  private static final int OPERATION_SIZE = 10000;\n+  private static final Logger LOG = LoggerFactory.getLogger(RandomizedRaftTest.class);\n+  public ControllableRaftContexts raftContexts;\n+  List<RaftOperation> operations;\n+  List<MemberId> raftMembers;\n+  File raftDataDirectory;\n+\n+  @BeforeProperty\n+  public void initOperations() {\n+    // Need members ids to generate pair operations\n+    final var servers =\n+        IntStream.range(0, 3)\n+            .mapToObj(String::valueOf)\n+            .map(MemberId::from)\n+            .collect(Collectors.toList());\n+    operations = RaftOperation.getDefaultRaftOperations();\n+    raftMembers = List.copyOf(servers);\n+  }\n+\n+  @AfterTry\n+  public void shutDownRaftNodes() throws IOException {\n+    raftContexts.shudown();\n+    FileUtil.deleteFolder(raftDataDirectory.toPath());\n+    raftDataDirectory = null;\n+  }\n+\n+  @Property(tries = 10, shrinking = ShrinkingMode.OFF, edgeCases = EdgeCasesMode.NONE)\n+  void raftProperty(\n+      @ForAll(\"raftOperations\") final List<RaftOperation> raftOperations,\n+      @ForAll(\"raftMembers\") final List<MemberId> raftMembers,\n+      @ForAll(\"seeds\") final long seed)\n+      throws Exception {\n+\n+    setUpRaftNodes(new Random(seed));\n+\n+    int step = 0;\n+    final var memberIter = raftMembers.iterator();\n+    for (final RaftOperation operation : raftOperations) {\n+      step++;\n+\n+      final MemberId member = memberIter.next();\n+      LOG.info(\"{} on {}\", operation, member);\n+      operation.run(raftContexts, member);\n+      raftContexts.assertOnlyOneLeader();\n+\n+      if (step % 100 == 0) { // reading logs after every operation can be too slow\n+        raftContexts.assertAllLogsEqual();\n+        step = 0;\n+      }\n+    }\n+\n+    raftContexts.assertAllLogsEqual();\n+  }\n+\n+  @Provide\n+  Arbitrary<List<RaftOperation>> raftOperations() {\n+    final var operation = Arbitraries.of(operations);\n+    return operation.list().ofSize(OPERATION_SIZE);\n+  }\n+\n+  @Provide\n+  Arbitrary<List<MemberId>> raftMembers() {\n+    final var members = Arbitraries.of(raftMembers);\n+    return members.list().ofSize(OPERATION_SIZE);\n+  }\n+\n+  @Provide\n+  Arbitrary<Long> seeds() {\n+    return Arbitraries.longs();\n+  }\n+\n+  private void setUpRaftNodes(final Random random) throws Exception {\n+    // Couldnot make @TempDir annotation work\n+    raftDataDirectory = Files.createTempDir();", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzODE1Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509938156", "bodyText": "Currently you use google Files class", "author": "Zelldon", "createdAt": "2020-10-22T07:28:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzODAwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzODk3NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509938974", "bodyText": "this set has no content", "author": "Zelldon", "createdAt": "2020-10-22T07:30:07Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/protocol/ControllableRaftServerProtocol.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ * Copyright 2017-present Open Networking Foundation\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft.protocol;\n+\n+import com.google.common.collect.Sets;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.utils.concurrent.Futures;\n+import io.zeebe.util.collection.Tuple;\n+import java.net.ConnectException;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Controllable raft server protocol. The messages are delivered only when explicitly instructed and\n+ * messages can be dropped.\n+ */\n+public class ControllableRaftServerProtocol implements RaftServerProtocol {\n+\n+  private Function<JoinRequest, CompletableFuture<JoinResponse>> joinHandler;\n+  private Function<LeaveRequest, CompletableFuture<LeaveResponse>> leaveHandler;\n+  private Function<ConfigureRequest, CompletableFuture<ConfigureResponse>> configureHandler;\n+  private Function<ReconfigureRequest, CompletableFuture<ReconfigureResponse>> reconfigureHandler;\n+  private Function<InstallRequest, CompletableFuture<InstallResponse>> installHandler;\n+  private Function<TransferRequest, CompletableFuture<TransferResponse>> transferHandler;\n+  private Function<PollRequest, CompletableFuture<PollResponse>> pollHandler;\n+  private Function<VoteRequest, CompletableFuture<VoteResponse>> voteHandler;\n+  private Function<AppendRequest, CompletableFuture<AppendResponse>> appendHandler;\n+  private final Set<MemberId> partitions = Sets.newCopyOnWriteArraySet();", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk0MTA1Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509941053", "bodyText": "If we just drop the message we should also receive at some point an timeout right? Is it worth to test this?", "author": "Zelldon", "createdAt": "2020-10-22T07:33:55Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/protocol/ControllableRaftServerProtocol.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ * Copyright 2017-present Open Networking Foundation\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft.protocol;\n+\n+import com.google.common.collect.Sets;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.utils.concurrent.Futures;\n+import io.zeebe.util.collection.Tuple;\n+import java.net.ConnectException;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Controllable raft server protocol. The messages are delivered only when explicitly instructed and\n+ * messages can be dropped.\n+ */\n+public class ControllableRaftServerProtocol implements RaftServerProtocol {\n+\n+  private Function<JoinRequest, CompletableFuture<JoinResponse>> joinHandler;\n+  private Function<LeaveRequest, CompletableFuture<LeaveResponse>> leaveHandler;\n+  private Function<ConfigureRequest, CompletableFuture<ConfigureResponse>> configureHandler;\n+  private Function<ReconfigureRequest, CompletableFuture<ReconfigureResponse>> reconfigureHandler;\n+  private Function<InstallRequest, CompletableFuture<InstallResponse>> installHandler;\n+  private Function<TransferRequest, CompletableFuture<TransferResponse>> transferHandler;\n+  private Function<PollRequest, CompletableFuture<PollResponse>> pollHandler;\n+  private Function<VoteRequest, CompletableFuture<VoteResponse>> voteHandler;\n+  private Function<AppendRequest, CompletableFuture<AppendResponse>> appendHandler;\n+  private final Set<MemberId> partitions = Sets.newCopyOnWriteArraySet();\n+  private final Map<MemberId, ControllableRaftServerProtocol> servers;\n+  // Incoming messages to each member\n+  private final Map<MemberId, Queue<Tuple<Runnable, CompletableFuture>>> messageQueue;\n+  private final MemberId localMemberId;\n+\n+  public ControllableRaftServerProtocol(\n+      final MemberId memberId,\n+      final Map<MemberId, ControllableRaftServerProtocol> servers,\n+      final Map<MemberId, Queue<Tuple<Runnable, CompletableFuture>>> messageQueue) {\n+    this.servers = servers;\n+    this.messageQueue = messageQueue;\n+    localMemberId = memberId;\n+    messageQueue.put(memberId, new LinkedList<>());\n+    servers.put(memberId, this);\n+  }\n+\n+  public void receiveNextMessage() {\n+    final var rcvQueue = messageQueue.get(localMemberId);\n+    if (!rcvQueue.isEmpty()) {\n+      rcvQueue.poll().getLeft().run();\n+    }\n+  }\n+\n+  public void receiveAll() {\n+    final var rcvQueue = messageQueue.get(localMemberId);\n+    while (!rcvQueue.isEmpty()) {\n+      rcvQueue.poll().getLeft().run();\n+    }\n+  }\n+\n+  // drop next message from the incoming queue\n+  public void dropNextMessage() {\n+    final var nextMessage =\n+        messageQueue.computeIfAbsent(localMemberId, t -> new LinkedList<>()).poll();\n+    if (nextMessage != null) {\n+      Optional.ofNullable(nextMessage.getRight())\n+          .ifPresent(\n+              f -> {\n+                LoggerFactory.getLogger(\"TEST:\")\n+                    .info(\"Dropped a message to {}\", localMemberId.id());\n+                // RaftServers excepts exceptions from the messaging layer to detect timeouts\n+                f.completeExceptionally(new TimeoutException());", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4MzUyMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r510183520", "bodyText": "For elections, there are timeouts inbuilt in raft roles. But for appendEntries from leader to followers, it relies on timeout from the communication layer.", "author": "deepthidevaki", "createdAt": "2020-10-22T13:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk0MTA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc1MjY0NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r510752644", "bodyText": "ah ok weird", "author": "Zelldon", "createdAt": "2020-10-23T09:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk0MTA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk0MzMwMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509943301", "bodyText": "Do you think it is problematic that we have re-implemented the network stuff?", "author": "Zelldon", "createdAt": "2020-10-22T07:37:49Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/protocol/ControllableRaftServerProtocol.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ * Copyright 2017-present Open Networking Foundation\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft.protocol;\n+\n+import com.google.common.collect.Sets;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.utils.concurrent.Futures;\n+import io.zeebe.util.collection.Tuple;\n+import java.net.ConnectException;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Controllable raft server protocol. The messages are delivered only when explicitly instructed and\n+ * messages can be dropped.\n+ */\n+public class ControllableRaftServerProtocol implements RaftServerProtocol {\n+\n+  private Function<JoinRequest, CompletableFuture<JoinResponse>> joinHandler;\n+  private Function<LeaveRequest, CompletableFuture<LeaveResponse>> leaveHandler;\n+  private Function<ConfigureRequest, CompletableFuture<ConfigureResponse>> configureHandler;\n+  private Function<ReconfigureRequest, CompletableFuture<ReconfigureResponse>> reconfigureHandler;\n+  private Function<InstallRequest, CompletableFuture<InstallResponse>> installHandler;\n+  private Function<TransferRequest, CompletableFuture<TransferResponse>> transferHandler;\n+  private Function<PollRequest, CompletableFuture<PollResponse>> pollHandler;\n+  private Function<VoteRequest, CompletableFuture<VoteResponse>> voteHandler;\n+  private Function<AppendRequest, CompletableFuture<AppendResponse>> appendHandler;\n+  private final Set<MemberId> partitions = Sets.newCopyOnWriteArraySet();\n+  private final Map<MemberId, ControllableRaftServerProtocol> servers;\n+  // Incoming messages to each member\n+  private final Map<MemberId, Queue<Tuple<Runnable, CompletableFuture>>> messageQueue;\n+  private final MemberId localMemberId;\n+\n+  public ControllableRaftServerProtocol(\n+      final MemberId memberId,\n+      final Map<MemberId, ControllableRaftServerProtocol> servers,\n+      final Map<MemberId, Queue<Tuple<Runnable, CompletableFuture>>> messageQueue) {\n+    this.servers = servers;\n+    this.messageQueue = messageQueue;\n+    localMemberId = memberId;\n+    messageQueue.put(memberId, new LinkedList<>());\n+    servers.put(memberId, this);\n+  }\n+\n+  public void receiveNextMessage() {\n+    final var rcvQueue = messageQueue.get(localMemberId);\n+    if (!rcvQueue.isEmpty()) {\n+      rcvQueue.poll().getLeft().run();\n+    }\n+  }\n+\n+  public void receiveAll() {\n+    final var rcvQueue = messageQueue.get(localMemberId);\n+    while (!rcvQueue.isEmpty()) {\n+      rcvQueue.poll().getLeft().run();\n+    }\n+  }\n+\n+  // drop next message from the incoming queue\n+  public void dropNextMessage() {\n+    final var nextMessage =\n+        messageQueue.computeIfAbsent(localMemberId, t -> new LinkedList<>()).poll();\n+    if (nextMessage != null) {\n+      Optional.ofNullable(nextMessage.getRight())\n+          .ifPresent(\n+              f -> {\n+                LoggerFactory.getLogger(\"TEST:\")\n+                    .info(\"Dropped a message to {}\", localMemberId.id());\n+                // RaftServers excepts exceptions from the messaging layer to detect timeouts\n+                f.completeExceptionally(new TimeoutException());\n+              });\n+    }\n+  }\n+\n+  ControllableRaftServerProtocol server(final MemberId memberId) {\n+    if (partitions.contains(memberId)) {\n+      return null;\n+    }\n+    return servers.get(memberId);\n+  }\n+\n+  // Add a message to the outgoing queue\n+  private void send(\n+      final MemberId memberId,\n+      final Runnable requestHandler,\n+      final CompletableFuture responseFuture) {\n+    final var message = new Tuple<>(requestHandler, responseFuture);\n+    messageQueue.computeIfAbsent(memberId, m -> new LinkedList<>()).add(message);\n+  }\n+\n+  @Override\n+  public CompletableFuture<JoinResponse> join(final MemberId memberId, final JoinRequest request) {\n+    final var responseFuture = new CompletableFuture<JoinResponse>();\n+    send(\n+        memberId,\n+        () ->\n+            getServer(memberId)\n+                .thenCompose(listener -> listener.join(request))\n+                .thenAccept(\n+                    response -> send(localMemberId, () -> responseFuture.complete(response), null)),\n+        responseFuture);\n+    return responseFuture;\n+  }\n+\n+  @Override\n+  public CompletableFuture<LeaveResponse> leave(\n+      final MemberId memberId, final LeaveRequest request) {\n+    final var responseFuture = new CompletableFuture<LeaveResponse>();\n+    send(\n+        memberId,\n+        () ->\n+            getServer(memberId)\n+                .thenCompose(listener -> listener.leave(request))\n+                .thenAccept(\n+                    response -> send(localMemberId, () -> responseFuture.complete(response), null)),\n+        responseFuture);\n+    return responseFuture;\n+  }\n+\n+  @Override\n+  public CompletableFuture<ConfigureResponse> configure(\n+      final MemberId memberId, final ConfigureRequest request) {\n+    final var responseFuture = new CompletableFuture<ConfigureResponse>();\n+    send(\n+        memberId,\n+        () ->\n+            getServer(memberId)\n+                .thenCompose(listener -> listener.configure(request))\n+                .thenAccept(\n+                    response -> send(localMemberId, () -> responseFuture.complete(response), null)),\n+        responseFuture);\n+    return responseFuture;\n+  }\n+\n+  @Override\n+  public CompletableFuture<ReconfigureResponse> reconfigure(\n+      final MemberId memberId, final ReconfigureRequest request) {\n+    final var responseFuture = new CompletableFuture<ReconfigureResponse>();\n+    send(\n+        memberId,\n+        () ->\n+            getServer(memberId)\n+                .thenCompose(listener -> listener.reconfigure(request))\n+                .thenAccept(\n+                    response -> send(localMemberId, () -> responseFuture.complete(response), null)),\n+        responseFuture);\n+    return responseFuture;\n+  }\n+\n+  @Override\n+  public CompletableFuture<InstallResponse> install(\n+      final MemberId memberId, final InstallRequest request) {\n+    final var responseFuture = new CompletableFuture<InstallResponse>();\n+    send(\n+        memberId,\n+        () ->\n+            getServer(memberId)\n+                .thenCompose(listener -> listener.install(request))\n+                .thenAccept(\n+                    response -> send(localMemberId, () -> responseFuture.complete(response), null)),\n+        responseFuture);\n+    return responseFuture;\n+  }\n+", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk0Mzk1OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509943958", "bodyText": "I have the feeling we need unit tests for that \ud83d\ude05", "author": "Zelldon", "createdAt": "2020-10-22T07:38:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk0MzMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4OTc5Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r510189796", "bodyText": "\ud83d\ude04  Well. Yes, it is complex. It is adapted from the existing TestRaftServerProtocol, which is also simulating the network stuff. We have to control the network messages. So we have to simulate or mock network somehow. Do you think we can do it in a different way?", "author": "deepthidevaki", "createdAt": "2020-10-22T14:05:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk0MzMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc1MjQwMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r510752400", "bodyText": "Maybe the real implementation ? I think it has some logic for local right?", "author": "Zelldon", "createdAt": "2020-10-23T09:21:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk0MzMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDg3NzM0Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r510877347", "bodyText": "With real implementation we won't be able to control when a message is delivered or dropped.", "author": "deepthidevaki", "createdAt": "2020-10-23T13:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk0MzMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk0NDE5MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509944190", "bodyText": "Ok. why \ud83d\ude06", "author": "Zelldon", "createdAt": "2020-10-22T07:39:19Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/snapshot/TestSnapshotStore.java", "diffHunk": "@@ -71,7 +71,7 @@ public void removeSnapshotListener(final PersistedSnapshotListener listener) {\n   @Override\n   public long getCurrentSnapshotIndex() {\n     if (currentPersistedSnapshot.get() == null) {\n-      return -1;\n+      return 0;", "originalCommit": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE5MTIyNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r510191226", "bodyText": "It is not clearly defined in the interface, but the actual implementation returns 0 when there is no snapshot. So the test implementation should also returns 0, otherwise it breaks the system. Somewhere in the code it is expecting the snapshotIndex to be non-negative.", "author": "deepthidevaki", "createdAt": "2020-10-22T14:07:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk0NDE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc1MTE2NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r510751164", "bodyText": "Ah ok thanks", "author": "Zelldon", "createdAt": "2020-10-23T09:19:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk0NDE5MA=="}], "type": "inlineReview"}, {"oid": "56e7526ac51955ca68703593154bbbc8da306147", "url": "https://github.com/camunda-cloud/zeebe/commit/56e7526ac51955ca68703593154bbbc8da306147", "message": "chore(broker): add raft property tests", "committedDate": "2020-10-23T13:21:27Z", "type": "commit"}, {"oid": "56e7526ac51955ca68703593154bbbc8da306147", "url": "https://github.com/camunda-cloud/zeebe/commit/56e7526ac51955ca68703593154bbbc8da306147", "message": "chore(broker): add raft property tests", "committedDate": "2020-10-23T13:21:27Z", "type": "forcePushed"}]}