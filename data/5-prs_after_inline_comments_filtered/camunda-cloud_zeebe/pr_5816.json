{"pr_number": 5816, "pr_title": "Fix upgrade tests with and without snapshot", "pr_createdAt": "2020-11-12T08:09:44Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/5816", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwODc1Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/5816#discussion_r522908756", "bodyText": "You said that volumes are \"properly managed by Testcontainers by adding the right labels\". Is this what you meant? I tried googling a bit on how it works but didn't find much", "author": "MiguelPires", "createdAt": "2020-11-13T12:04:48Z", "path": "test-util/src/main/java/io/zeebe/test/util/testcontainers/ManagedVolume.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.test.util.testcontainers;\n+\n+import com.github.dockerjava.api.DockerClient;\n+import com.github.dockerjava.api.command.CreateContainerCmd;\n+import com.github.dockerjava.api.command.CreateVolumeCmd;\n+import com.github.dockerjava.api.command.CreateVolumeResponse;\n+import com.github.dockerjava.api.model.Bind;\n+import com.github.dockerjava.api.model.HostConfig;\n+import java.util.Objects;\n+import org.testcontainers.DockerClientFactory;\n+\n+/**\n+ * A simple wrapper to create Docker volumes which are managed by Testcontainers. The created object\n+ * labels the volumes with {@link DockerClientFactory#DEFAULT_LABELS} so that the Ryuk container can\n+ * reap the volumes should our JVM process crash.\n+ */\n+public final class ManagedVolume {\n+\n+  @SuppressWarnings(\"java:S1075\")\n+  private static final String DEFAULT_ZEEBE_DATA_PATH = \"/usr/local/zeebe/data\";\n+\n+  private final String name;\n+\n+  /** @param name the name of the volume */\n+  public ManagedVolume(final String name) {\n+    this.name = name;\n+  }\n+\n+  /** @return the name of the volume */\n+  public String getName() {\n+    return name;\n+  }\n+\n+  /**\n+   * Returns the volume as a bind which can be used when creating new containers. For example:\n+   * <code>\n+   *   new GenericContainer(\"containerImage\").withCreatCmdModifier(cmd -> cmd.withHostConfig(\n+   *      cmd.getHostConfig().withBinds(managedVolume.asBind(\"/path/to/mount\"))));\n+   * </code>\n+   *\n+   * @param mountPath the path where to mount the volume in the container\n+   * @return a bind which can be used when creating a container\n+   */\n+  public Bind asBind(final String mountPath) {\n+    return Bind.parse(name + \":\" + mountPath);\n+  }\n+\n+  /**\n+   * @return a pre-configured {@link Bind} which mounts this volume to the data folder of a Zeebe *\n+   *     broker.\n+   */\n+  public Bind asZeebeBind() {\n+    return asBind(DEFAULT_ZEEBE_DATA_PATH);\n+  }\n+\n+  /**\n+   * Convenience method which mounts the volume to a Zeebe broker's data folder.\n+   *\n+   * @param command the create command of the Zeebe broker container\n+   */\n+  public void attachVolumeToContainer(final CreateContainerCmd command) {\n+    final HostConfig hostConfig =\n+        Objects.requireNonNull(command.getHostConfig()).withBinds(asZeebeBind());\n+    command.withHostConfig(hostConfig);\n+  }\n+\n+  /**\n+   * @return a new managed volume using the default Docker client (see {@link\n+   *     DockerClientFactory#instance()})\n+   */\n+  public static ManagedVolume newVolume() {\n+    return newVolume(DockerClientFactory.instance().client());\n+  }\n+\n+  /**\n+   * @param client the Docker client to use to create the volume\n+   * @return a new managed volume using the given Docker client to create it\n+   */\n+  public static ManagedVolume newVolume(final DockerClient client) {\n+    try (final CreateVolumeCmd command = client.createVolumeCmd()) {\n+      final CreateVolumeResponse response =\n+          command.withLabels(DockerClientFactory.DEFAULT_LABELS).exec();\n+      return new ManagedVolume(response.getName());", "originalCommit": "c7a1a9010a0b19c1f7ef7e68d2acc42955255d40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkxMjcwMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5816#discussion_r522912703", "bodyText": "Yes, this is undocumented unfortunately, but Sergei is the one who told me to use this. I imagine one downside is it's a little brittle if they ever change how Ryuk works, but I think that's a small thing. Of course it would be nice if Testcontainers already provided the feature, and maybe that's something I'll contribute at some point so we have an official, maintained API on how to do this.\nTo explain a little, my understanding is that the Ryuk container will watch Docker resources with those labels, and reap them afterwards in case our process dies or doesn't clean them up. So any resource with those labels will get cleaned up eventually.", "author": "npepinpe", "createdAt": "2020-11-13T12:13:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwODc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkxODc3Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5816#discussion_r522918777", "bodyText": "I'm not adding a change request because it's just an opinion but I don't think this is very readable. The assert isRight doesn't look good to me but I don't have a good alternative so we can leave it. Maybe hasRight would also be misleading because it sounds like it can have both right and left. I think extracting the value would make it more obvious what the assert is actually checking though:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  EitherAssert.assertThat(state.getPartitionsActuatorClient().takeSnapshot()).isRight();\n          \n          \n            \n                  Either<Throwable, Map<String, PartitionStatus>> response = state.getPartitionsActuatorClient().takeSnapshot();\n          \n          \n            \n                  EitherAssert.assertThat(response).isRight();", "author": "MiguelPires", "createdAt": "2020-11-13T12:26:47Z", "path": "upgrade-tests/src/test/java/io/zeebe/test/UpgradeTest.java", "diffHunk": "@@ -7,453 +7,134 @@\n  */\n package io.zeebe.test;\n \n+import static io.zeebe.test.UpgradeTestCaseProvider.PROCESS_ID;\n import static org.assertj.core.api.Assertions.assertThat;\n \n-import io.zeebe.client.api.response.ActivateJobsResponse;\n-import io.zeebe.model.bpmn.Bpmn;\n-import io.zeebe.model.bpmn.BpmnModelInstance;\n-import io.zeebe.test.UpgradeTestCase.TestCaseBuilder;\n-import io.zeebe.test.util.TestUtil;\n+import io.zeebe.test.PartitionsActuatorClient.PartitionStatus;\n+import io.zeebe.test.util.asserts.EitherAssert;\n+import io.zeebe.util.Either;\n import io.zeebe.util.VersionUtil;\n-import io.zeebe.util.collection.Tuple;\n-import java.io.File;\n-import java.nio.file.Paths;\n import java.time.Duration;\n-import java.util.Arrays;\n-import java.util.Collection;\n import java.util.Map;\n import java.util.Optional;\n import java.util.concurrent.TimeUnit;\n-import org.agrona.IoUtil;\n import org.awaitility.Awaitility;\n-import org.junit.Ignore;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.RuleChain;\n-import org.junit.rules.TemporaryFolder;\n-import org.junit.rules.Timeout;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-import org.junit.runners.Parameterized.Parameter;\n-import org.junit.runners.Parameterized.Parameters;\n-\n-@RunWith(Parameterized.class)\n-public class UpgradeTest {\n-\n-  public static final String PROCESS_ID = \"process\";\n-  public static final String CHILD_PROCESS_ID = \"childProc\";\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Timeout;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.api.parallel.Execution;\n+import org.junit.jupiter.api.parallel.ExecutionMode;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n+import org.testcontainers.containers.Network;\n+\n+@Execution(ExecutionMode.SAME_THREAD)\n+class UpgradeTest {\n+  private static final String LAST_VERSION = VersionUtil.getPreviousVersion();\n   private static final String CURRENT_VERSION = \"current-test\";\n-  private static final String TASK = \"task\";\n-  private static final String JOB = TASK;\n-  private static final String MESSAGE = \"message\";\n-  private static final File SHARED_DATA;\n+  private static Network network;\n \n-  private static final String LAST_VERSION = VersionUtil.getPreviousVersion();\n+  private ContainerState state = new ContainerState(network);\n+  @RegisterExtension ContainerStateExtension stateExtension = new ContainerStateExtension(state);\n \n-  static {\n-    final var sharedDataPath =\n-        Optional.ofNullable(System.getenv(\"ZEEBE_CI_SHARED_DATA\"))\n-            .map(Paths::get)\n-            .orElse(Paths.get(System.getProperty(\"tmpdir\", \"/tmp\"), \"shared\"));\n-    SHARED_DATA = sharedDataPath.toAbsolutePath().toFile();\n-    IoUtil.ensureDirectoryExists(SHARED_DATA, \"temporary folder for Docker\");\n+  @BeforeAll\n+  static void setUp() {\n+    network = Network.newNetwork();\n   }\n \n-  @Rule public TemporaryFolder tmpFolder = new TemporaryFolder(SHARED_DATA);\n-  @Rule public ContainerStateRule state = new ContainerStateRule();\n-\n-  @Rule\n-  public RuleChain chain =\n-      RuleChain.outerRule(new Timeout(5, TimeUnit.MINUTES)).around(tmpFolder).around(state);\n-\n-  @Parameter public String name;\n-\n-  @Parameter(1)\n-  public UpgradeTestCase testCase;\n-\n-  @Parameters(name = \"{0}\")\n-  public static Collection<Object[]> data() {\n-    return Arrays.asList(\n-        new Object[][] {\n-          {\n-            \"job\",\n-            scenario()\n-                .deployWorkflow(jobWorkflow())\n-                .createInstance()\n-                .beforeUpgrade(UpgradeTest::activateJob)\n-                .afterUpgrade(UpgradeTest::completeJob)\n-                .done()\n-          },\n-          {\n-            \"message subscription\",\n-            scenario()\n-                .deployWorkflow(messageWorkflow())\n-                .createInstance(Map.of(\"key\", \"123\"))\n-                .beforeUpgrade(UpgradeTest::awaitOpenMessageSubscription)\n-                .afterUpgrade(UpgradeTest::publishMessage)\n-                .done()\n-          },\n-          {\n-            \"message start event\",\n-            scenario()\n-                .deployWorkflow(msgStartWorkflow())\n-                .beforeUpgrade(UpgradeTest::awaitStartMessageSubscription)\n-                .afterUpgrade(UpgradeTest::publishMessage)\n-                .done()\n-          },\n-          // TODO (saig0): enable the test case when upgrading from 0.25.0\n-          // - an upgrade from 0.24.0 is not possible because a bug fix (#4959) causes an issue in\n-          // the reprocessing (#5268)\n-          //            {\n-          //            \"message event sub-process\",\n-          //            scenario()\n-          //                .deployWorkflow(\n-          //                    Bpmn.createExecutableProcess(PROCESS_ID)\n-          //                        .eventSubProcess(\n-          //                            \"event-subprocess\",\n-          //                            eventSubProcess ->\n-          //                                eventSubProcess\n-          //                                    .startEvent()\n-          //                                    .message(\n-          //                                        m ->\n-          // m.name(MESSAGE).zeebeCorrelationKeyExpression(\"key\"))\n-          //                                    .interrupting(false)\n-          //                                    .endEvent())\n-          //                        .startEvent()\n-          //                        .serviceTask(TASK, t -> t.zeebeJobType(TASK))\n-          //                        .endEvent()\n-          //                        .done())\n-          //                .createInstance(Map.of(\"key\", \"123\"))\n-          //                .beforeUpgrade(\n-          //                    state -> {\n-          //                      publishMessage(state, -1L, -1L);\n-          //\n-          //                      TestUtil.waitUntil(\n-          //                          () -> state.hasElementInState(\"event-subprocess\",\n-          // \"ELEMENT_COMPLETED\"));\n-          //\n-          //                      return activateJob(state);\n-          //                    })\n-          //                .afterUpgrade(UpgradeTest::completeJob)\n-          //                .done()\n-          //          },\n-          {\n-            \"timer\",\n-            scenario()\n-                .deployWorkflow(timerWorkflow())\n-                .beforeUpgrade(UpgradeTest::awaitTimerCreation)\n-                .afterUpgrade(UpgradeTest::timerTriggered)\n-                .done()\n-          },\n-          {\n-            \"incident\",\n-            scenario()\n-                .deployWorkflow(incidentWorkflow())\n-                .createInstance()\n-                .beforeUpgrade(UpgradeTest::awaitIncidentCreation)\n-                .afterUpgrade(UpgradeTest::resolveIncident)\n-                .done()\n-          },\n-          {\n-            \"publish message\",\n-            scenario()\n-                .deployWorkflow(messageWorkflow())\n-                .beforeUpgrade(\n-                    state -> {\n-                      publishMessage(state, -1L, -1L);\n-                      return -1L;\n-                    })\n-                .afterUpgrade(\n-                    (state, l1, l2) -> {\n-                      state\n-                          .client()\n-                          .newCreateInstanceCommand()\n-                          .bpmnProcessId(PROCESS_ID)\n-                          .latestVersion()\n-                          .variables(Map.of(\"key\", \"123\"))\n-                          .send();\n-                      TestUtil.waitUntil(() -> state.hasLogContaining(MESSAGE, \"CORRELATED\"));\n-                    })\n-                .done()\n-          },\n-          {\n-            \"call activity\",\n-            scenario()\n-                .deployWorkflow(\n-                    new Tuple<>(parentWorkflow(), PROCESS_ID),\n-                    new Tuple<>(childWorkflow(), CHILD_PROCESS_ID))\n-                .createInstance()\n-                .afterUpgrade(\n-                    (state, wfKey, key) -> {\n-                      TestUtil.waitUntil(() -> state.hasElementInState(JOB, \"CREATED\"));\n-\n-                      final var jobsResponse =\n-                          state\n-                              .client()\n-                              .newActivateJobsCommand()\n-                              .jobType(TASK)\n-                              .maxJobsToActivate(1)\n-                              .send()\n-                              .join();\n-                      assertThat(jobsResponse.getJobs()).hasSize(1);\n-\n-                      TestUtil.waitUntil(() -> state.hasElementInState(JOB, \"ACTIVATED\"));\n-\n-                      state\n-                          .client()\n-                          .newCompleteCommand(jobsResponse.getJobs().get(0).getKey())\n-                          .send()\n-                          .join();\n-                      TestUtil.waitUntil(\n-                          () -> state.hasLogContaining(CHILD_PROCESS_ID, \"COMPLETED\"));\n-                    })\n-                .done()\n-          },\n-          {\n-            \"parallel gateway\",\n-            scenario()\n-                .deployWorkflow(\n-                    Bpmn.createExecutableProcess(PROCESS_ID)\n-                        .startEvent()\n-                        .parallelGateway(\"fork\")\n-                        .serviceTask(TASK, t -> t.zeebeJobType(TASK))\n-                        .parallelGateway(\"join\")\n-                        .moveToNode(\"fork\")\n-                        .sequenceFlowId(\"to-join\")\n-                        .connectTo(\"join\")\n-                        .endEvent()\n-                        .done())\n-                .createInstance()\n-                .beforeUpgrade(UpgradeTest::activateJob)\n-                .afterUpgrade(UpgradeTest::completeJob)\n-                .done()\n-          },\n-          {\n-            \"exclusive gateway\",\n-            scenario()\n-                .deployWorkflow(\n-                    Bpmn.createExecutableProcess(PROCESS_ID)\n-                        .startEvent()\n-                        .exclusiveGateway()\n-                        .sequenceFlowId(\"s1\")\n-                        .conditionExpression(\"x > 5\")\n-                        .serviceTask(TASK, t -> t.zeebeJobType(TASK))\n-                        .endEvent()\n-                        .moveToLastExclusiveGateway()\n-                        .sequenceFlowId(\"s2\")\n-                        .defaultFlow()\n-                        .serviceTask(\"other-task\", t -> t.zeebeJobType(\"other-task\"))\n-                        .endEvent()\n-                        .done())\n-                .createInstance(Map.of(\"x\", 10))\n-                .beforeUpgrade(UpgradeTest::activateJob)\n-                .afterUpgrade(UpgradeTest::completeJob)\n-                .done()\n-          }\n-        });\n+  @AfterAll\n+  static void tearDown() {\n+    Optional.ofNullable(network).ifPresent(Network::close);\n   }\n \n-  @Ignore\n-  @Test\n-  public void oldGatewayWithNewBroker() {\n+  @Timeout(value = 5, unit = TimeUnit.MINUTES)\n+  @ParameterizedTest(name = \"{0}\")\n+  @ArgumentsSource(UpgradeTestCaseProvider.class)\n+  void oldGatewayWithNewBroker(final String name, final UpgradeTestCase testCase) {\n     // given\n-    state\n-        .broker(CURRENT_VERSION, tmpFolder.getRoot().getPath())\n-        .withStandaloneGateway(LAST_VERSION)\n-        .start(true);\n+    state.broker(CURRENT_VERSION).withStandaloneGateway(LAST_VERSION).start(true);\n     final long wfInstanceKey = testCase.setUp(state.client());\n \n     // when\n     final long key = testCase.runBefore(state);\n \n     // then\n     testCase.runAfter(state, wfInstanceKey, key);\n-    TestUtil.waitUntil(() -> state.hasElementInState(PROCESS_ID, \"ELEMENT_COMPLETED\"));\n+    awaitProcessCompletion();\n   }\n \n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/5385\")\n-  @Test\n-  public void upgradeWithSnapshot() {\n-    upgradeZeebe(true);\n+  @Timeout(value = 5, unit = TimeUnit.MINUTES)\n+  @ParameterizedTest(name = \"{0}\")\n+  @ArgumentsSource(UpgradeTestCaseProvider.class)\n+  void upgradeWithSnapshot(final String name, final UpgradeTestCase testCase) {\n+    upgradeZeebe(testCase, true);\n   }\n \n-  @Test\n-  public void upgradeWithoutSnapshot() {\n-    upgradeZeebe(false);\n+  @Timeout(value = 5, unit = TimeUnit.MINUTES)\n+  @ParameterizedTest(name = \"{0}\")\n+  @ArgumentsSource(UpgradeTestCaseProvider.class)\n+  void upgradeWithoutSnapshot(final String name, final UpgradeTestCase testCase) {\n+    upgradeZeebe(testCase, false);\n   }\n \n-  private void upgradeZeebe(final boolean withSnapshot) {\n+  private void upgradeZeebe(final UpgradeTestCase testCase, final boolean withSnapshot) {\n     // given\n-    state.broker(LAST_VERSION, tmpFolder.getRoot().getPath()).start(true);\n+    state.broker(LAST_VERSION).start(true);\n     final long wfInstanceKey = testCase.setUp(state.client());\n     final long key = testCase.runBefore(state);\n \n     // when\n-    final File snapshot = new File(tmpFolder.getRoot(), \"raft-partition/partitions/1/snapshots/\");\n-\n     if (withSnapshot) {\n-\n-      state.close();\n-\n-      state.broker(LAST_VERSION, tmpFolder.getRoot().getPath()).start(false);\n-\n-      // since 0.24, no snapshot is created when the broker is closed\n-      Awaitility.await()\n-          .atMost(Duration.ofMinutes(2))\n-          .untilAsserted(\n-              () ->\n-                  assertThat(snapshot)\n-                      .describedAs(\"Expected that a snapshot is created\")\n-                      .exists()\n-                      .isNotEmptyDirectory());\n-\n+      // it's necessary to restart without the debug exporter to allow snapshotting\n       state.close();\n+      state.broker(LAST_VERSION).start(false);\n+      EitherAssert.assertThat(state.getPartitionsActuatorClient().takeSnapshot()).isRight();", "originalCommit": "c7a1a9010a0b19c1f7ef7e68d2acc42955255d40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzMjEwMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5816#discussion_r523032102", "bodyText": "Hm, I think that's just a fundamental problem with a generic structure like Either =/ I admit in this case I'd rather have something like Rust's Result type, where you would then write something like isOk() (since it's either OK or failed, which is really what I use it as for the client). At the same time, I didn't feel like introducing a new type in this PR (though imo it would be a good type to have in general \ud83d\ude42)", "author": "npepinpe", "createdAt": "2020-11-13T15:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkxODc3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA1NTcwMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5816#discussion_r523055700", "bodyText": "I added a description to the assert via as() for better error message \ud83d\udc4d", "author": "npepinpe", "createdAt": "2020-11-13T16:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkxODc3Nw=="}], "type": "inlineReview"}, {"oid": "a64da891507d77907314e23588efcaf7dae75b5d", "url": "https://github.com/camunda-cloud/zeebe/commit/a64da891507d77907314e23588efcaf7dae75b5d", "message": "chore(project): rename upgrade-tests to update-tests", "committedDate": "2020-11-13T16:18:44Z", "type": "forcePushed"}, {"oid": "b98f2794463107bc003960cd93a0778617b432f3", "url": "https://github.com/camunda-cloud/zeebe/commit/b98f2794463107bc003960cd93a0778617b432f3", "message": "chore(project): rename upgrade-tests to update-tests", "committedDate": "2020-11-13T16:22:01Z", "type": "forcePushed"}, {"oid": "70843a312175daa8aee6cc07542d885bb9757759", "url": "https://github.com/camunda-cloud/zeebe/commit/70843a312175daa8aee6cc07542d885bb9757759", "message": "chore(test-util): add new utilities\n\n- adds a new AssertJ assertion for Either\n- adds a new Testcontainers utility to create volumes which get cleaned\n  up even if the process crashes", "committedDate": "2020-11-13T16:30:41Z", "type": "commit"}, {"oid": "ca37b2e0667ee476bbaba4c4549bc229d9e5ab6b", "url": "https://github.com/camunda-cloud/zeebe/commit/ca37b2e0667ee476bbaba4c4549bc229d9e5ab6b", "message": "chore(upgrade-tests): fixes tests using snapshots\n\n- rewrites tests for junit5\n- improve assertion to check for snapshots\n- introduces actuator client\n- use named Docker volumes instead of shared folder", "committedDate": "2020-11-13T16:30:42Z", "type": "commit"}, {"oid": "ca37b2e0667ee476bbaba4c4549bc229d9e5ab6b", "url": "https://github.com/camunda-cloud/zeebe/commit/ca37b2e0667ee476bbaba4c4549bc229d9e5ab6b", "message": "chore(upgrade-tests): fixes tests using snapshots\n\n- rewrites tests for junit5\n- improve assertion to check for snapshots\n- introduces actuator client\n- use named Docker volumes instead of shared folder", "committedDate": "2020-11-13T16:30:42Z", "type": "forcePushed"}]}