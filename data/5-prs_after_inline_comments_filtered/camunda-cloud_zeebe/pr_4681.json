{"pr_number": 4681, "pr_title": "4396 long polling blocked bug - target 0.23.0", "pr_createdAt": "2020-06-08T14:35:25Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4681", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE4ODA3NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r437188074", "bodyText": "Why are these methods synchronized?", "author": "Zelldon", "createdAt": "2020-06-09T07:18:55Z", "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/InFlightLongPollingActivateJobsRequestsState.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.gateway.impl.job;\n+\n+import io.zeebe.gateway.Loggers;\n+import io.zeebe.gateway.metrics.LongPollingMetrics;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import org.slf4j.Logger;\n+\n+public final class InFlightLongPollingActivateJobsRequestsState {\n+\n+  private static final Logger LOGGER = Loggers.GATEWAY_LOGGER;\n+\n+  private final String jobType;\n+  private final LongPollingMetrics metrics;\n+  private final Queue<LongPollingActivateJobsRequest> pendingRequests = new LinkedList<>();\n+  private LongPollingActivateJobsRequest activeRequest;\n+  private int failedAttempts;\n+  private long lastUpdatedTime;\n+\n+  public InFlightLongPollingActivateJobsRequestsState(\n+      final String jobType, final LongPollingMetrics metrics) {\n+    this.jobType = jobType;\n+    this.metrics = metrics;\n+  }\n+\n+  public void incrementFailedAttempts(final long lastUpdatedTime) {\n+    failedAttempts++;\n+    this.lastUpdatedTime = lastUpdatedTime;\n+  }\n+\n+  public void resetFailedAttempts(final int failedAttempts) {\n+    this.failedAttempts = failedAttempts;\n+  }\n+\n+  public int getFailedAttempts() {\n+    return failedAttempts;\n+  }\n+\n+  public long getLastUpdatedTime() {\n+    return lastUpdatedTime;\n+  }\n+\n+  public synchronized void enqueueRequest(final LongPollingActivateJobsRequest request) {\n+    pendingRequests.offer(request);\n+    removeObsoleteRequestsAndUpdateMetrics();\n+  }\n+\n+  private synchronized void removeObsoleteRequestsAndUpdateMetrics() {", "originalCommit": "6f64679a1d07de344becfd5f17f6fa0b4b1cf66b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE5MTI3NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r437191274", "bodyText": "I think this is not necessary. This class is only used in our LongPollingActivateJobsHandler, since this is an actor it can make sure that this state is only accessed in this actor.", "author": "Zelldon", "createdAt": "2020-06-09T07:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE4ODA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE5Mjk1OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r437192958", "bodyText": "this should also be not necessary", "author": "Zelldon", "createdAt": "2020-06-09T07:27:57Z", "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/LongPollingActivateJobsHandler.java", "diffHunk": "@@ -77,87 +80,110 @@ public void activateJobs(\n   public void activateJobs(final LongPollingActivateJobsRequest request) {\n     actor.run(\n         () -> {\n-          final JobTypeAvailabilityState state = jobTypeState.get(request.getType());\n-          final boolean isJobAvailable =\n-              state == null || (state.getEmptyResponses() < emptyResponseThreshold);\n-          if (isJobAvailable) {\n-            activateJobsUnchecked(request);\n+          final InFlightLongPollingActivateJobsRequestsState state =\n+              getJobTypeState(request.getType());\n+\n+          if (state.getActiveRequest() == null\n+              && (state.getFailedAttempts() < failedAttemptThreshold)) {\n+            activateJobsUnchecked(state, request);\n           } else {\n-            block(state, request);\n+            completeOrEnqueueRequest(state, request);\n           }\n         });\n   }\n \n-  private void activateJobsUnchecked(final LongPollingActivateJobsRequest request) {\n+  private InFlightLongPollingActivateJobsRequestsState getJobTypeState(String jobType) {\n+    synchronized (jobTypeState) {", "originalCommit": "6f64679a1d07de344becfd5f17f6fa0b4b1cf66b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE5NzE1MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r437197151", "bodyText": "This is not necessary", "author": "Zelldon", "createdAt": "2020-06-09T07:35:47Z", "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/LongPollingActivateJobsHandler.java", "diffHunk": "@@ -77,87 +80,110 @@ public void activateJobs(\n   public void activateJobs(final LongPollingActivateJobsRequest request) {\n     actor.run(\n         () -> {\n-          final JobTypeAvailabilityState state = jobTypeState.get(request.getType());\n-          final boolean isJobAvailable =\n-              state == null || (state.getEmptyResponses() < emptyResponseThreshold);\n-          if (isJobAvailable) {\n-            activateJobsUnchecked(request);\n+          final InFlightLongPollingActivateJobsRequestsState state =\n+              getJobTypeState(request.getType());\n+\n+          if (state.getActiveRequest() == null\n+              && (state.getFailedAttempts() < failedAttemptThreshold)) {\n+            activateJobsUnchecked(state, request);\n           } else {\n-            block(state, request);\n+            completeOrEnqueueRequest(state, request);\n           }\n         });\n   }\n \n-  private void activateJobsUnchecked(final LongPollingActivateJobsRequest request) {\n+  private InFlightLongPollingActivateJobsRequestsState getJobTypeState(String jobType) {\n+    synchronized (jobTypeState) {\n+      return jobTypeState.computeIfAbsent(\n+          jobType, type -> new InFlightLongPollingActivateJobsRequestsState(type, metrics));\n+    }\n+  }\n+\n+  private void activateJobsUnchecked(\n+      final InFlightLongPollingActivateJobsRequestsState state,\n+      final LongPollingActivateJobsRequest request) {\n+\n     final BrokerClusterState topology = brokerClient.getTopologyManager().getTopology();\n     if (topology != null) {\n+\n+      state.setActiveRequest(request);\n+\n       final int partitionsCount = topology.getPartitionsCount();\n       activateJobsHandler.activateJobs(\n           partitionsCount,\n           request.getRequest(),\n           request.getMaxJobsToActivate(),\n           request.getType(),\n           response -> onResponse(request, response),\n-          remainingAmount -> onCompleted(request, remainingAmount));\n+          (remainingAmount, containedResourceExhaustedResponse) ->\n+              onCompleted(state, request, remainingAmount, containedResourceExhaustedResponse));\n     }\n   }\n \n   private void onNotification(final String jobType) {\n     LOG.trace(\"Received jobs available notification for type {}.\", jobType);\n-    actor.call(() -> jobsAvailable(jobType));\n+    actor.run(() -> handlePendingRequests(jobType));\n   }\n \n   private void onCompleted(\n-      final LongPollingActivateJobsRequest request, final Integer remainingAmount) {\n+      final InFlightLongPollingActivateJobsRequestsState state,\n+      final LongPollingActivateJobsRequest request,\n+      final Integer remainingAmount,\n+      final Boolean containedResourceExhaustedResponse) {\n+    state.removeActiveRequest();\n     if (remainingAmount == request.getMaxJobsToActivate()) {\n-      actor.submit(() -> jobsNotAvailable(request));\n+      if (containedResourceExhaustedResponse) {\n+        actor.submit(\n+            () ->\n+                request\n+                    .getResponseObserver()\n+                    .onError(\n+                        new BrokerErrorException(\n+                            new BrokerError(\n+                                ErrorCode.RESOURCE_EXHAUSTED,\n+                                \"Some brokers returned resource exhausted\"))));\n+      } else {\n+        actor.submit(\n+            () -> {\n+              state.incrementFailedAttempts(currentTimeMillis());\n+              activateJobs(request);\n+            });\n+      }\n     } else {\n       actor.submit(request::complete);\n+      actor.submit(() -> handlePendingRequests(request.getType()));\n     }\n   }\n \n   private void onResponse(\n       final LongPollingActivateJobsRequest request,\n       final ActivateJobsResponse activateJobsResponse) {\n-    actor.submit(\n-        () -> {\n-          request.onResponse(activateJobsResponse);\n-          jobsAvailable(request.getType());\n-        });\n+    actor.submit(() -> request.onResponse(activateJobsResponse));\n   }\n \n-  private void jobsNotAvailable(final LongPollingActivateJobsRequest request) {\n-    final JobTypeAvailabilityState state =\n-        jobTypeState.computeIfAbsent(\n-            request.getType(), type -> new JobTypeAvailabilityState(type, metrics));\n-    state.incrementEmptyResponses(currentTimeMillis());\n-    block(state, request);\n-  }\n+  private void handlePendingRequests(final String jobType) {\n+    final InFlightLongPollingActivateJobsRequestsState state = getJobTypeState(jobType);\n \n-  private void jobsAvailable(final String jobType) {\n-    final JobTypeAvailabilityState removedState = jobTypeState.remove(jobType);\n-    if (removedState != null) {\n-      unblockRequests(removedState);\n-    }\n-  }\n+    state.resetFailedAttempts(0);\n \n-  private void unblockRequests(final JobTypeAvailabilityState state) {\n-    final Queue<LongPollingActivateJobsRequest> requests = state.getBlockedRequests();\n-    if (requests == null) {\n-      return;\n+    if (state.getActiveRequest() == null) {\n+\n+      final LongPollingActivateJobsRequest nextPendingRequest = state.getNextPendingRequest();\n+\n+      if (nextPendingRequest != null) {\n+        LOG.trace(\"Unblocking ActivateJobsRequest {}\", nextPendingRequest.getRequest());\n+        activateJobs(nextPendingRequest);\n+      } else {\n+        synchronized (jobTypeState) {", "originalCommit": "6f64679a1d07de344becfd5f17f6fa0b4b1cf66b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIwODYwOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r437208608", "bodyText": "This seems new right? Before we just blocked?\nBut do we still check the other brokers before we return to the client?", "author": "Zelldon", "createdAt": "2020-06-09T07:55:45Z", "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/LongPollingActivateJobsHandler.java", "diffHunk": "@@ -77,87 +80,110 @@ public void activateJobs(\n   public void activateJobs(final LongPollingActivateJobsRequest request) {\n     actor.run(\n         () -> {\n-          final JobTypeAvailabilityState state = jobTypeState.get(request.getType());\n-          final boolean isJobAvailable =\n-              state == null || (state.getEmptyResponses() < emptyResponseThreshold);\n-          if (isJobAvailable) {\n-            activateJobsUnchecked(request);\n+          final InFlightLongPollingActivateJobsRequestsState state =\n+              getJobTypeState(request.getType());\n+\n+          if (state.getActiveRequest() == null\n+              && (state.getFailedAttempts() < failedAttemptThreshold)) {\n+            activateJobsUnchecked(state, request);\n           } else {\n-            block(state, request);\n+            completeOrEnqueueRequest(state, request);\n           }\n         });\n   }\n \n-  private void activateJobsUnchecked(final LongPollingActivateJobsRequest request) {\n+  private InFlightLongPollingActivateJobsRequestsState getJobTypeState(String jobType) {\n+    synchronized (jobTypeState) {\n+      return jobTypeState.computeIfAbsent(\n+          jobType, type -> new InFlightLongPollingActivateJobsRequestsState(type, metrics));\n+    }\n+  }\n+\n+  private void activateJobsUnchecked(\n+      final InFlightLongPollingActivateJobsRequestsState state,\n+      final LongPollingActivateJobsRequest request) {\n+\n     final BrokerClusterState topology = brokerClient.getTopologyManager().getTopology();\n     if (topology != null) {\n+\n+      state.setActiveRequest(request);\n+\n       final int partitionsCount = topology.getPartitionsCount();\n       activateJobsHandler.activateJobs(\n           partitionsCount,\n           request.getRequest(),\n           request.getMaxJobsToActivate(),\n           request.getType(),\n           response -> onResponse(request, response),\n-          remainingAmount -> onCompleted(request, remainingAmount));\n+          (remainingAmount, containedResourceExhaustedResponse) ->\n+              onCompleted(state, request, remainingAmount, containedResourceExhaustedResponse));\n     }\n   }\n \n   private void onNotification(final String jobType) {\n     LOG.trace(\"Received jobs available notification for type {}.\", jobType);\n-    actor.call(() -> jobsAvailable(jobType));\n+    actor.run(() -> handlePendingRequests(jobType));\n   }\n \n   private void onCompleted(\n-      final LongPollingActivateJobsRequest request, final Integer remainingAmount) {\n+      final InFlightLongPollingActivateJobsRequestsState state,\n+      final LongPollingActivateJobsRequest request,\n+      final Integer remainingAmount,\n+      final Boolean containedResourceExhaustedResponse) {\n+    state.removeActiveRequest();\n     if (remainingAmount == request.getMaxJobsToActivate()) {\n-      actor.submit(() -> jobsNotAvailable(request));\n+      if (containedResourceExhaustedResponse) {\n+        actor.submit(\n+            () ->\n+                request\n+                    .getResponseObserver()\n+                    .onError(\n+                        new BrokerErrorException(", "originalCommit": "6f64679a1d07de344becfd5f17f6fa0b4b1cf66b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE3MDgxNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r438170816", "bodyText": "Yes, that is done internally in ActivateJobsHandler", "author": "pihme", "createdAt": "2020-06-10T14:33:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIwODYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIyMTQzMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r437221433", "bodyText": "So we just continue with sending requests?", "author": "Zelldon", "createdAt": "2020-06-09T08:17:27Z", "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/LongPollingActivateJobsHandler.java", "diffHunk": "@@ -77,87 +80,110 @@ public void activateJobs(\n   public void activateJobs(final LongPollingActivateJobsRequest request) {\n     actor.run(\n         () -> {\n-          final JobTypeAvailabilityState state = jobTypeState.get(request.getType());\n-          final boolean isJobAvailable =\n-              state == null || (state.getEmptyResponses() < emptyResponseThreshold);\n-          if (isJobAvailable) {\n-            activateJobsUnchecked(request);\n+          final InFlightLongPollingActivateJobsRequestsState state =\n+              getJobTypeState(request.getType());\n+\n+          if (state.getActiveRequest() == null\n+              && (state.getFailedAttempts() < failedAttemptThreshold)) {\n+            activateJobsUnchecked(state, request);\n           } else {\n-            block(state, request);\n+            completeOrEnqueueRequest(state, request);\n           }\n         });\n   }\n \n-  private void activateJobsUnchecked(final LongPollingActivateJobsRequest request) {\n+  private InFlightLongPollingActivateJobsRequestsState getJobTypeState(String jobType) {\n+    synchronized (jobTypeState) {\n+      return jobTypeState.computeIfAbsent(\n+          jobType, type -> new InFlightLongPollingActivateJobsRequestsState(type, metrics));\n+    }\n+  }\n+\n+  private void activateJobsUnchecked(\n+      final InFlightLongPollingActivateJobsRequestsState state,\n+      final LongPollingActivateJobsRequest request) {\n+\n     final BrokerClusterState topology = brokerClient.getTopologyManager().getTopology();\n     if (topology != null) {\n+\n+      state.setActiveRequest(request);\n+\n       final int partitionsCount = topology.getPartitionsCount();\n       activateJobsHandler.activateJobs(\n           partitionsCount,\n           request.getRequest(),\n           request.getMaxJobsToActivate(),\n           request.getType(),\n           response -> onResponse(request, response),\n-          remainingAmount -> onCompleted(request, remainingAmount));\n+          (remainingAmount, containedResourceExhaustedResponse) ->\n+              onCompleted(state, request, remainingAmount, containedResourceExhaustedResponse));\n     }\n   }\n \n   private void onNotification(final String jobType) {\n     LOG.trace(\"Received jobs available notification for type {}.\", jobType);\n-    actor.call(() -> jobsAvailable(jobType));\n+    actor.run(() -> handlePendingRequests(jobType));\n   }\n \n   private void onCompleted(\n-      final LongPollingActivateJobsRequest request, final Integer remainingAmount) {\n+      final InFlightLongPollingActivateJobsRequestsState state,\n+      final LongPollingActivateJobsRequest request,\n+      final Integer remainingAmount,\n+      final Boolean containedResourceExhaustedResponse) {\n+    state.removeActiveRequest();\n     if (remainingAmount == request.getMaxJobsToActivate()) {\n-      actor.submit(() -> jobsNotAvailable(request));\n+      if (containedResourceExhaustedResponse) {\n+        actor.submit(\n+            () ->\n+                request\n+                    .getResponseObserver()\n+                    .onError(\n+                        new BrokerErrorException(\n+                            new BrokerError(\n+                                ErrorCode.RESOURCE_EXHAUSTED,\n+                                \"Some brokers returned resource exhausted\"))));\n+      } else {\n+        actor.submit(\n+            () -> {\n+              state.incrementFailedAttempts(currentTimeMillis());\n+              activateJobs(request);\n+            });\n+      }\n     } else {\n       actor.submit(request::complete);\n+      actor.submit(() -> handlePendingRequests(request.getType()));", "originalCommit": "6f64679a1d07de344becfd5f17f6fa0b4b1cf66b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE3MDMxOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r438170319", "bodyText": "Not exactly. We stop sending requests if\n\nthe failed attempts is greater than the threshold, or\nall pending requests timed out\n\nBut as long as we are below the threshold for failed attempts and there are still request pending, we keep sending requests.", "author": "pihme", "createdAt": "2020-06-10T14:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIyMTQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU3MzMwNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r438573307", "bodyText": "This would block the second request if the first request is in-flight even if there are plenty of jobs available in broker. Isn't it? Then we won't be able to process requests from multiple job workers concurrently.", "author": "deepthidevaki", "createdAt": "2020-06-11T06:40:39Z", "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/LongPollingActivateJobsHandler.java", "diffHunk": "@@ -77,87 +80,110 @@ public void activateJobs(\n   public void activateJobs(final LongPollingActivateJobsRequest request) {\n     actor.run(\n         () -> {\n-          final JobTypeAvailabilityState state = jobTypeState.get(request.getType());\n-          final boolean isJobAvailable =\n-              state == null || (state.getEmptyResponses() < emptyResponseThreshold);\n-          if (isJobAvailable) {\n-            activateJobsUnchecked(request);\n+          final InFlightLongPollingActivateJobsRequestsState state =\n+              getJobTypeState(request.getType());\n+\n+          if (state.getActiveRequest() == null", "originalCommit": "6f64679a1d07de344becfd5f17f6fa0b4b1cf66b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgxNzg5OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r438817899", "bodyText": "You are so right. I focused so much on the edge case that I forgot the main case.", "author": "pihme", "createdAt": "2020-06-11T14:13:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU3MzMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU4MjczNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r438582736", "bodyText": "Isn't this again preventing concurrent requests?", "author": "deepthidevaki", "createdAt": "2020-06-11T07:03:42Z", "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/LongPollingActivateJobsHandler.java", "diffHunk": "@@ -77,87 +80,110 @@ public void activateJobs(\n   public void activateJobs(final LongPollingActivateJobsRequest request) {\n     actor.run(\n         () -> {\n-          final JobTypeAvailabilityState state = jobTypeState.get(request.getType());\n-          final boolean isJobAvailable =\n-              state == null || (state.getEmptyResponses() < emptyResponseThreshold);\n-          if (isJobAvailable) {\n-            activateJobsUnchecked(request);\n+          final InFlightLongPollingActivateJobsRequestsState state =\n+              getJobTypeState(request.getType());\n+\n+          if (state.getActiveRequest() == null\n+              && (state.getFailedAttempts() < failedAttemptThreshold)) {\n+            activateJobsUnchecked(state, request);\n           } else {\n-            block(state, request);\n+            completeOrEnqueueRequest(state, request);\n           }\n         });\n   }\n \n-  private void activateJobsUnchecked(final LongPollingActivateJobsRequest request) {\n+  private InFlightLongPollingActivateJobsRequestsState getJobTypeState(String jobType) {\n+    synchronized (jobTypeState) {\n+      return jobTypeState.computeIfAbsent(\n+          jobType, type -> new InFlightLongPollingActivateJobsRequestsState(type, metrics));\n+    }\n+  }\n+\n+  private void activateJobsUnchecked(\n+      final InFlightLongPollingActivateJobsRequestsState state,\n+      final LongPollingActivateJobsRequest request) {\n+\n     final BrokerClusterState topology = brokerClient.getTopologyManager().getTopology();\n     if (topology != null) {\n+\n+      state.setActiveRequest(request);\n+\n       final int partitionsCount = topology.getPartitionsCount();\n       activateJobsHandler.activateJobs(\n           partitionsCount,\n           request.getRequest(),\n           request.getMaxJobsToActivate(),\n           request.getType(),\n           response -> onResponse(request, response),\n-          remainingAmount -> onCompleted(request, remainingAmount));\n+          (remainingAmount, containedResourceExhaustedResponse) ->\n+              onCompleted(state, request, remainingAmount, containedResourceExhaustedResponse));\n     }\n   }\n \n   private void onNotification(final String jobType) {\n     LOG.trace(\"Received jobs available notification for type {}.\", jobType);\n-    actor.call(() -> jobsAvailable(jobType));\n+    actor.run(() -> handlePendingRequests(jobType));\n   }\n \n   private void onCompleted(\n-      final LongPollingActivateJobsRequest request, final Integer remainingAmount) {\n+      final InFlightLongPollingActivateJobsRequestsState state,\n+      final LongPollingActivateJobsRequest request,\n+      final Integer remainingAmount,\n+      final Boolean containedResourceExhaustedResponse) {\n+    state.removeActiveRequest();\n     if (remainingAmount == request.getMaxJobsToActivate()) {\n-      actor.submit(() -> jobsNotAvailable(request));\n+      if (containedResourceExhaustedResponse) {\n+        actor.submit(\n+            () ->\n+                request\n+                    .getResponseObserver()\n+                    .onError(\n+                        new BrokerErrorException(\n+                            new BrokerError(\n+                                ErrorCode.RESOURCE_EXHAUSTED,\n+                                \"Some brokers returned resource exhausted\"))));\n+      } else {\n+        actor.submit(\n+            () -> {\n+              state.incrementFailedAttempts(currentTimeMillis());\n+              activateJobs(request);\n+            });\n+      }\n     } else {\n       actor.submit(request::complete);\n+      actor.submit(() -> handlePendingRequests(request.getType()));\n     }\n   }\n \n   private void onResponse(\n       final LongPollingActivateJobsRequest request,\n       final ActivateJobsResponse activateJobsResponse) {\n-    actor.submit(\n-        () -> {\n-          request.onResponse(activateJobsResponse);\n-          jobsAvailable(request.getType());\n-        });\n+    actor.submit(() -> request.onResponse(activateJobsResponse));\n   }\n \n-  private void jobsNotAvailable(final LongPollingActivateJobsRequest request) {\n-    final JobTypeAvailabilityState state =\n-        jobTypeState.computeIfAbsent(\n-            request.getType(), type -> new JobTypeAvailabilityState(type, metrics));\n-    state.incrementEmptyResponses(currentTimeMillis());\n-    block(state, request);\n-  }\n+  private void handlePendingRequests(final String jobType) {\n+    final InFlightLongPollingActivateJobsRequestsState state = getJobTypeState(jobType);\n \n-  private void jobsAvailable(final String jobType) {\n-    final JobTypeAvailabilityState removedState = jobTypeState.remove(jobType);\n-    if (removedState != null) {\n-      unblockRequests(removedState);\n-    }\n-  }\n+    state.resetFailedAttempts(0);\n \n-  private void unblockRequests(final JobTypeAvailabilityState state) {\n-    final Queue<LongPollingActivateJobsRequest> requests = state.getBlockedRequests();\n-    if (requests == null) {\n-      return;\n+    if (state.getActiveRequest() == null) {", "originalCommit": "6f64679a1d07de344becfd5f17f6fa0b4b1cf66b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEwMTExMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r444101110", "bodyText": "I would like to have a refactoring of these chain of recursive calls it is really hard to understand and determine what is actually happening. Can we create an follow up issue which we can maybe prioritize.\nEspecially these boolean flags are always hard to understand I'm a fan of specific methods in these cases maybe it is possible to refactor them also then away.", "author": "Zelldon", "createdAt": "2020-06-23T09:48:37Z", "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/ActivateJobsHandler.java", "diffHunk": "@@ -50,9 +51,16 @@ private void activateJobs(\n       final int remainingAmount,\n       final String jobType,\n       final Consumer<ActivateJobsResponse> onResponse,\n-      final Consumer<Integer> onCompleted) {\n+      final BiConsumer<Integer, Boolean> onCompleted) {\n     activateJobs(\n-        request, partitionIdIterator, remainingAmount, jobType, onResponse, onCompleted, false);\n+        request,\n+        partitionIdIterator,\n+        remainingAmount,\n+        jobType,\n+        onResponse,\n+        onCompleted,\n+        false,", "originalCommit": "436aa8229d8c921f00162f3e7fb33e7d4abeff38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1MDUwMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r445650501", "bodyText": "See #4824", "author": "pihme", "createdAt": "2020-06-25T15:35:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEwMTExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEwNDg3Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r444104876", "bodyText": "should it also remove from activeRequestsToBeRepeated?", "author": "Zelldon", "createdAt": "2020-06-23T09:55:01Z", "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/InFlightLongPollingActivateJobsRequestsState.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.gateway.impl.job;\n+\n+import io.zeebe.gateway.Loggers;\n+import io.zeebe.gateway.metrics.LongPollingMetrics;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import org.slf4j.Logger;\n+\n+public final class InFlightLongPollingActivateJobsRequestsState {\n+\n+  private static final Logger LOGGER = Loggers.GATEWAY_LOGGER;\n+\n+  private final String jobType;\n+  private final LongPollingMetrics metrics;\n+  private final Queue<LongPollingActivateJobsRequest> activeRequests = new LinkedList<>();\n+  private final Queue<LongPollingActivateJobsRequest> activeRequestsToBeRepeated =\n+      new LinkedList<>();\n+  private final Queue<LongPollingActivateJobsRequest> pendingRequests = new LinkedList<>();\n+  private int failedAttempts;\n+  private long lastUpdatedTime;\n+\n+  public InFlightLongPollingActivateJobsRequestsState(\n+      final String jobType, final LongPollingMetrics metrics) {\n+    this.jobType = jobType;\n+    this.metrics = metrics;\n+  }\n+\n+  public void incrementFailedAttempts(final long lastUpdatedTime) {\n+    failedAttempts++;\n+    this.lastUpdatedTime = lastUpdatedTime;\n+  }\n+\n+  public void resetFailedAttempts(final int failedAttempts) {\n+    this.failedAttempts = failedAttempts;\n+    if (failedAttempts == 0) {\n+      activeRequestsToBeRepeated.addAll(activeRequests);\n+    }\n+  }\n+\n+  public int getFailedAttempts() {\n+    return failedAttempts;\n+  }\n+\n+  public long getLastUpdatedTime() {\n+    return lastUpdatedTime;\n+  }\n+\n+  public void enqueueRequest(final LongPollingActivateJobsRequest request) {\n+    if (!pendingRequests.contains(request)) {\n+      pendingRequests.offer(request);\n+    }\n+    removeObsoleteRequestsAndUpdateMetrics();\n+  }\n+\n+  public Queue<LongPollingActivateJobsRequest> getPendingRequests() {\n+    removeObsoleteRequestsAndUpdateMetrics();\n+    return pendingRequests;\n+  }\n+\n+  private void removeObsoleteRequestsAndUpdateMetrics() {\n+    pendingRequests.removeIf(this::isObsolete);\n+    activeRequests.removeIf(this::isObsolete);\n+    activeRequestsToBeRepeated.removeIf(this::isObsolete);\n+    metrics.setBlockedRequestsCount(jobType, pendingRequests.size());\n+  }\n+\n+  private boolean isObsolete(final LongPollingActivateJobsRequest request) {\n+    return request.isTimedOut() || request.isCanceled() || request.isCompleted();\n+  }\n+\n+  public void removeRequest(final LongPollingActivateJobsRequest request) {\n+    pendingRequests.remove(request);\n+    removeObsoleteRequestsAndUpdateMetrics();\n+  }\n+\n+  public LongPollingActivateJobsRequest getNextPendingRequest() {\n+    removeObsoleteRequestsAndUpdateMetrics();\n+    final LongPollingActivateJobsRequest request = pendingRequests.poll();\n+    metrics.setBlockedRequestsCount(jobType, pendingRequests.size());\n+    return request;\n+  }\n+\n+  public void addActiveRequest(final LongPollingActivateJobsRequest request) {\n+    activeRequests.offer(request);\n+    pendingRequests.remove(request);", "originalCommit": "436aa8229d8c921f00162f3e7fb33e7d4abeff38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEwNzIwOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r444107209", "bodyText": "Maybe we create two methods for these both cases instead of having this parameter which sometime acts as an flag and to set it to a value.\nSo like:\nstate.resetFailedAttemtps() sets to zero here then dont need the if internally.\nstate.setFailedAttempts(int) sets to value we give it to", "author": "Zelldon", "createdAt": "2020-06-23T09:58:59Z", "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/LongPollingActivateJobsHandler.java", "diffHunk": "@@ -201,15 +241,13 @@ private void probe() {\n     jobTypeState.forEach(\n         (type, state) -> {\n           if (state.getLastUpdatedTime() < (now - probeTimeoutMillis)) {\n-            state.removeCanceledRequests();\n-\n-            final LongPollingActivateJobsRequest probeRequest = state.pollBlockedRequests();\n+            final LongPollingActivateJobsRequest probeRequest = state.getNextPendingRequest();\n             if (probeRequest != null) {\n-              activateJobsUnchecked(probeRequest);\n+              activateJobsUnchecked(state, probeRequest);\n             } else {\n               // there are no blocked requests, so use next request as probe\n-              if (state.getEmptyResponses() >= emptyResponseThreshold) {\n-                state.resetEmptyResponses(emptyResponseThreshold - 1);\n+              if (state.getFailedAttempts() >= failedAttemptThreshold) {\n+                state.resetFailedAttempts(failedAttemptThreshold - 1);", "originalCommit": "436aa8229d8c921f00162f3e7fb33e7d4abeff38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e822d9596b556715d2af2e1abcaa3ab34555fece", "url": "https://github.com/camunda-cloud/zeebe/commit/e822d9596b556715d2af2e1abcaa3ab34555fece", "message": "chore(broker): Keep records of active long polling requests", "committedDate": "2020-06-26T08:48:15Z", "type": "forcePushed"}, {"oid": "e1d8cb3326f084858cfaa93dbd91c4cd6e6dbcf3", "url": "https://github.com/camunda-cloud/zeebe/commit/e1d8cb3326f084858cfaa93dbd91c4cd6e6dbcf3", "message": "chore(broker): Keep records of active long polling requests", "committedDate": "2020-06-26T10:17:06Z", "type": "commit"}, {"oid": "e1d8cb3326f084858cfaa93dbd91c4cd6e6dbcf3", "url": "https://github.com/camunda-cloud/zeebe/commit/e1d8cb3326f084858cfaa93dbd91c4cd6e6dbcf3", "message": "chore(broker): Keep records of active long polling requests", "committedDate": "2020-06-26T10:17:06Z", "type": "forcePushed"}]}