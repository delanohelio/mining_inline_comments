{"pr_number": 914, "pr_title": "Fix verification for successful staging", "pr_createdAt": "2020-07-27T08:47:56Z", "pr_url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/914", "timeline": [{"oid": "bfce13248f1276d0a454e30b139ca398a6796bf1", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/bfce13248f1276d0a454e30b139ca398a6796bf1", "message": "Fix verification for successful staging", "committedDate": "2020-07-27T08:49:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NTQxNQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/914#discussion_r460765415", "bodyText": "Some of the mockito utils are imported as static methods. Maybe you should stick with static imports and remove Mockito.", "author": "radoslav-d", "createdAt": "2020-07-27T09:32:13Z", "path": "multiapps-controller-process/src/test/java/org/cloudfoundry/multiapps/controller/process/steps/UploadAppStepTest.java", "diffHunk": "@@ -13,166 +14,86 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.nio.file.Path;\n-import java.text.ParseException;\n-import java.text.SimpleDateFormat;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Date;\n+import java.text.MessageFormat;\n import java.util.HashMap;\n-import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n import java.util.UUID;\n \n import org.apache.commons.io.FileUtils;\n import org.cloudfoundry.client.lib.CloudOperationException;\n-import org.cloudfoundry.client.lib.domain.CloudBuild;\n-import org.cloudfoundry.client.lib.domain.CloudBuild.State;\n-import org.cloudfoundry.client.lib.domain.ImmutableCloudBuild;\n-import org.cloudfoundry.client.lib.domain.ImmutableCloudBuild.ImmutableDropletInfo;\n+import org.cloudfoundry.client.lib.domain.CloudPackage;\n import org.cloudfoundry.client.lib.domain.ImmutableCloudMetadata;\n+import org.cloudfoundry.client.lib.domain.ImmutableCloudPackage;\n import org.cloudfoundry.client.lib.domain.ImmutableUploadToken;\n+import org.cloudfoundry.client.lib.domain.Status;\n import org.cloudfoundry.client.lib.domain.UploadToken;\n import org.cloudfoundry.multiapps.common.SLException;\n import org.cloudfoundry.multiapps.common.util.JsonUtil;\n import org.cloudfoundry.multiapps.common.util.MapUtil;\n import org.cloudfoundry.multiapps.controller.client.lib.domain.CloudApplicationExtended;\n import org.cloudfoundry.multiapps.controller.client.lib.domain.ImmutableCloudApplicationExtended;\n+import org.cloudfoundry.multiapps.controller.core.Constants;\n import org.cloudfoundry.multiapps.controller.core.helpers.MtaArchiveElements;\n import org.cloudfoundry.multiapps.controller.core.util.ApplicationConfiguration;\n import org.cloudfoundry.multiapps.controller.persistence.services.FileContentProcessor;\n import org.cloudfoundry.multiapps.controller.process.Messages;\n import org.cloudfoundry.multiapps.controller.process.util.ApplicationArchiveContext;\n import org.cloudfoundry.multiapps.controller.process.util.ApplicationArchiveReader;\n import org.cloudfoundry.multiapps.controller.process.util.ApplicationZipBuilder;\n+import org.cloudfoundry.multiapps.controller.process.util.CloudPackagesGetter;\n import org.cloudfoundry.multiapps.controller.process.variables.Variables;\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.experimental.runners.Enclosed;\n-import org.junit.rules.ExpectedException;\n-import org.junit.rules.TemporaryFolder;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-import org.junit.runners.Parameterized.Parameters;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n import org.mockito.Mockito;\n-import org.mockito.stubbing.Answer;\n import org.springframework.http.HttpStatus;\n \n-@RunWith(Enclosed.class)\n public class UploadAppStepTest {\n \n-    @RunWith(Parameterized.class)\n-    public static class UploadAppStepParameterizedTest extends SyncFlowableStepTest<UploadAppStep> {\n-\n-        private static final IOException IO_EXCEPTION = new IOException();\n-        private static final CloudOperationException CO_EXCEPTION = new CloudOperationException(HttpStatus.BAD_REQUEST);\n+    @Nested\n+    class UploadAppStepGeneralTest extends SyncFlowableStepTest<UploadAppStep> {\n \n         private static final String APP_NAME = \"sample-app-backend\";\n         private static final String APP_FILE = \"web.zip\";\n         private static final String SPACE = \"space\";\n         private static final String APP_ARCHIVE = \"sample-app.mtar\";\n-        private static final UploadToken UPLOAD_TOKEN = ImmutableUploadToken.builder()\n-                                                                            .packageGuid(UUID.randomUUID())\n-                                                                            .build();\n-        private static final String MODULE_DIGEST = \"439B99DFFD0583200D5D21F4CD1BF035\";\n-        private static final String DATE_PATTERN = \"dd-MM-yyyy\";\n-\n-        public final TemporaryFolder tempDir = new TemporaryFolder();\n-        @Rule\n-        public final ExpectedException expectedException = ExpectedException.none();\n-\n-        @Parameters\n-        public static Iterable<Object[]> getParameters() {\n-            return Arrays.asList(new Object[][] {\n-// @formatter:off\n-                // (00)\n-                {\n-                    null, null, true, null\n-                },\n-                // (01)\n-                {\n-                    format(Messages.ERROR_RETRIEVING_MTA_MODULE_CONTENT, APP_FILE), null, true, null\n-                },\n-                // (02)\n-                {\n-                    null, format(Messages.CF_ERROR, CO_EXCEPTION.getMessage()), true, null\n-                },\n-                // (03)\n-                {\n-                    null, null, true, Collections.emptyList()\n-                },\n-                // (04)\n-                {\n-                    null, null, true, Arrays.asList(createCloudBuild(State.STAGED, parseDate(\"20-03-2018\")),\n-                                                    createCloudBuild(State.FAILED, parseDate(\"21-03-2018\")))\n-                },\n-                // (05)\n-                {\n-                    null, null, false, Arrays.asList(createCloudBuild(State.FAILED, parseDate(\"20-03-2018\")),\n-                                                     createCloudBuild(State.STAGED, parseDate(\"21-03-2018\")))\n-                },\n-// @formatter:on\n-            });\n-        }\n-\n-        private final String expectedIOExceptionMessage;\n-        private final String expectedCFExceptionMessage;\n+        private static final String CURRENT_MODULE_DIGEST = \"439B99DFFD0583200D5D21F4CD1BF035\";\n+        private static final String NEW_MODULE_DIGEST = \"539B99DFFD0583200D5D21F4CD1BF035\";\n+        private final IOException IO_EXCEPTION = new IOException();\n+        private final CloudOperationException CO_EXCEPTION = new CloudOperationException(HttpStatus.BAD_REQUEST);\n+        private final UploadToken UPLOAD_TOKEN = ImmutableUploadToken.builder()\n+                                                                     .packageGuid(UUID.randomUUID())\n+                                                                     .build();\n+        private final UUID PACKAGE_GUID = UUID.randomUUID();\n         private final MtaArchiveElements mtaArchiveElements = new MtaArchiveElements();\n-        private final List<CloudBuild> cloudBuilds;\n-        private final boolean shouldUpload;\n-\n+        private final CloudPackagesGetter cloudPackagesGetter = Mockito.mock(CloudPackagesGetter.class);\n+        @TempDir\n+        Path tempDir;\n         private File appFile;\n \n-        public UploadAppStepParameterizedTest(String expectedIOExceptionMessage, String expectedCFExceptionMessage, boolean shouldUpload,\n-                                              List<CloudBuild> cloudBuilds) {\n-            this.expectedIOExceptionMessage = expectedIOExceptionMessage;\n-            this.expectedCFExceptionMessage = expectedCFExceptionMessage;\n-            this.shouldUpload = shouldUpload;\n-            this.cloudBuilds = cloudBuilds;\n-        }\n-\n-        @Before\n+        @BeforeEach\n         public void setUp() throws Exception {\n-            loadParameters();\n             prepareFileService();\n             prepareContext();\n-            prepareClients();\n-        }\n-\n-        @After\n-        public void tearDown() {\n-            FileUtils.deleteQuietly(appFile.getParentFile());\n-        }\n-\n-        @Test\n-        public void test() {\n-            try {\n-                step.execute(execution);\n-            } catch (Exception e) {\n-                assertFalse(appFile.exists());\n-                throw e;\n-            }\n-\n-            if (shouldUpload) {\n-                assertEquals(UPLOAD_TOKEN, context.getVariable(Variables.UPLOAD_TOKEN));\n-            } else {\n-                assertNull(context.getVariable(Variables.UPLOAD_TOKEN));\n-            }\n         }\n \n-        public void loadParameters() {\n-            if (expectedIOExceptionMessage != null) {\n-                expectedException.expectMessage(expectedIOExceptionMessage);\n-                expectedException.expect(SLException.class);\n-            }\n-            if (expectedCFExceptionMessage != null) {\n-                expectedException.expectMessage(expectedCFExceptionMessage);\n-                expectedException.expect(SLException.class);\n+        @SuppressWarnings(\"rawtypes\")\n+        private void prepareFileService() throws Exception {\n+            appFile = new File(tempDir.toString() + File.separator + APP_FILE);\n+            if (!appFile.exists()) {\n+                appFile.createNewFile();\n             }\n+            doAnswer(invocation -> {\n+                FileContentProcessor contentProcessor = invocation.getArgument(2);\n+                return contentProcessor.process(null);\n+            }).when(fileService)\n+              .processFileContent(Mockito.anyString(), Mockito.anyString(), Mockito.any());", "originalCommit": "bfce13248f1276d0a454e30b139ca398a6796bf1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5NTk0OQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/914#discussion_r460795949", "bodyText": "maybe new Date() is enough", "author": "radoslav-d", "createdAt": "2020-07-27T10:29:00Z", "path": "multiapps-controller-process/src/test/java/org/cloudfoundry/multiapps/controller/process/util/CloudPackagesGetterTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package org.cloudfoundry.multiapps.controller.process.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.cloudfoundry.client.lib.CloudControllerClient;\n+import org.cloudfoundry.client.lib.CloudControllerException;\n+import org.cloudfoundry.client.lib.CloudOperationException;\n+import org.cloudfoundry.client.lib.domain.CloudMetadata;\n+import org.cloudfoundry.client.lib.domain.CloudPackage;\n+import org.cloudfoundry.client.lib.domain.DropletInfo;\n+import org.cloudfoundry.client.lib.domain.ImmutableCloudMetadata;\n+import org.cloudfoundry.client.lib.domain.ImmutableCloudPackage;\n+import org.cloudfoundry.client.lib.domain.ImmutableDropletInfo;\n+import org.cloudfoundry.client.lib.domain.Status;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.springframework.http.HttpStatus;\n+\n+class CloudPackagesGetterTest {\n+\n+    private static final UUID APPLICATION_GUID = UUID.randomUUID();\n+    private static final UUID PACKAGE_GUID = UUID.randomUUID();\n+    private static final UUID DROPLET_GUID = UUID.randomUUID();\n+    private static final String DATE_FORMAT = \"dd-MM-yyyy\";\n+    private final CloudPackagesGetter cloudPackagesGetter = new CloudPackagesGetter();\n+    private final CloudControllerClient client = Mockito.mock(CloudControllerClient.class);\n+\n+    @Test\n+    void getLatestUnusedPackageWithNoPackagesNoDroplet() {\n+        Mockito.when(client.getCurrentDropletForApplication(APPLICATION_GUID))\n+               .thenThrow(getNotFoundCloudOperationException());\n+        Optional<CloudPackage> latestUnusedPackage = cloudPackagesGetter.getLatestUnusedPackage(client, APPLICATION_GUID);\n+        assertFalse(latestUnusedPackage.isPresent());\n+    }\n+\n+    @Test\n+    void getLatestUnusedPackageExceptionIsThrown() {\n+        Mockito.when(client.getCurrentDropletForApplication(APPLICATION_GUID))\n+               .thenThrow(getInternalServerErrorCloudOperationException());\n+        Exception exception = assertThrows(CloudOperationException.class,\n+                                           () -> cloudPackagesGetter.getLatestUnusedPackage(client, APPLICATION_GUID));\n+        assertEquals(\"500 Internal Server Error\", exception.getMessage());\n+    }\n+\n+    @Test\n+    void getLatestUnusedPackageWithOneValidPackageNoDroplet() {\n+        Mockito.when(client.getCurrentDropletForApplication(APPLICATION_GUID))\n+               .thenThrow(getNotFoundCloudOperationException());\n+        Mockito.when(client.getPackagesForApplication(APPLICATION_GUID))\n+               .thenReturn(Collections.singletonList(createCloudPackage(PACKAGE_GUID, Status.PROCESSING_UPLOAD,\n+                                                                        new Date(System.currentTimeMillis()))));", "originalCommit": "bfce13248f1276d0a454e30b139ca398a6796bf1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5NjUwMw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/914#discussion_r460796503", "bodyText": "same new Date()", "author": "radoslav-d", "createdAt": "2020-07-27T10:29:57Z", "path": "multiapps-controller-process/src/test/java/org/cloudfoundry/multiapps/controller/process/util/CloudPackagesGetterTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package org.cloudfoundry.multiapps.controller.process.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.cloudfoundry.client.lib.CloudControllerClient;\n+import org.cloudfoundry.client.lib.CloudControllerException;\n+import org.cloudfoundry.client.lib.CloudOperationException;\n+import org.cloudfoundry.client.lib.domain.CloudMetadata;\n+import org.cloudfoundry.client.lib.domain.CloudPackage;\n+import org.cloudfoundry.client.lib.domain.DropletInfo;\n+import org.cloudfoundry.client.lib.domain.ImmutableCloudMetadata;\n+import org.cloudfoundry.client.lib.domain.ImmutableCloudPackage;\n+import org.cloudfoundry.client.lib.domain.ImmutableDropletInfo;\n+import org.cloudfoundry.client.lib.domain.Status;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.springframework.http.HttpStatus;\n+\n+class CloudPackagesGetterTest {\n+\n+    private static final UUID APPLICATION_GUID = UUID.randomUUID();\n+    private static final UUID PACKAGE_GUID = UUID.randomUUID();\n+    private static final UUID DROPLET_GUID = UUID.randomUUID();\n+    private static final String DATE_FORMAT = \"dd-MM-yyyy\";\n+    private final CloudPackagesGetter cloudPackagesGetter = new CloudPackagesGetter();\n+    private final CloudControllerClient client = Mockito.mock(CloudControllerClient.class);\n+\n+    @Test\n+    void getLatestUnusedPackageWithNoPackagesNoDroplet() {\n+        Mockito.when(client.getCurrentDropletForApplication(APPLICATION_GUID))\n+               .thenThrow(getNotFoundCloudOperationException());\n+        Optional<CloudPackage> latestUnusedPackage = cloudPackagesGetter.getLatestUnusedPackage(client, APPLICATION_GUID);\n+        assertFalse(latestUnusedPackage.isPresent());\n+    }\n+\n+    @Test\n+    void getLatestUnusedPackageExceptionIsThrown() {\n+        Mockito.when(client.getCurrentDropletForApplication(APPLICATION_GUID))\n+               .thenThrow(getInternalServerErrorCloudOperationException());\n+        Exception exception = assertThrows(CloudOperationException.class,\n+                                           () -> cloudPackagesGetter.getLatestUnusedPackage(client, APPLICATION_GUID));\n+        assertEquals(\"500 Internal Server Error\", exception.getMessage());\n+    }\n+\n+    @Test\n+    void getLatestUnusedPackageWithOneValidPackageNoDroplet() {\n+        Mockito.when(client.getCurrentDropletForApplication(APPLICATION_GUID))\n+               .thenThrow(getNotFoundCloudOperationException());\n+        Mockito.when(client.getPackagesForApplication(APPLICATION_GUID))\n+               .thenReturn(Collections.singletonList(createCloudPackage(PACKAGE_GUID, Status.PROCESSING_UPLOAD,\n+                                                                        new Date(System.currentTimeMillis()))));\n+        Optional<CloudPackage> latestUnusedPackage = cloudPackagesGetter.getLatestUnusedPackage(client, APPLICATION_GUID);\n+        assertTrue(latestUnusedPackage.isPresent());\n+        assertEquals(PACKAGE_GUID, latestUnusedPackage.get()\n+                                                      .getGuid());\n+    }\n+\n+    @Test\n+    void getLatestUnusedPackageWithDropletAndWithoutPackages() {\n+        Mockito.when(client.getCurrentDropletForApplication(APPLICATION_GUID))\n+               .thenReturn(createDropletInfo(DROPLET_GUID, PACKAGE_GUID));\n+        Mockito.when(client.getPackage(PACKAGE_GUID))\n+               .thenThrow(getNotFoundCloudOperationException());\n+        Optional<CloudPackage> latestUnusedPackage = cloudPackagesGetter.getLatestUnusedPackage(client, APPLICATION_GUID);\n+        assertFalse(latestUnusedPackage.isPresent());\n+    }\n+\n+    @Test\n+    void getLatestUnusedPackageWhenCurrentPackageIsTheSameAsNewestPackage() {\n+        Mockito.when(client.getCurrentDropletForApplication(APPLICATION_GUID))\n+               .thenReturn(createDropletInfo(DROPLET_GUID, PACKAGE_GUID));\n+        CloudPackage cloudPackage = createCloudPackage(PACKAGE_GUID, Status.READY, new Date(System.currentTimeMillis()));", "originalCommit": "bfce13248f1276d0a454e30b139ca398a6796bf1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "72d698f3609a44d4ed50b11d04c2a8fc5d6c2704", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/72d698f3609a44d4ed50b11d04c2a8fc5d6c2704", "message": "Fix verification for successful staging", "committedDate": "2020-07-27T10:39:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgxMTI3Ng==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/914#discussion_r460811276", "bodyText": "Why this message was deleted?", "author": "theghost5800", "createdAt": "2020-07-27T11:00:16Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/Messages.java", "diffHunk": "@@ -168,7 +168,6 @@\n     public static final String COULD_NOT_ABORT_OPERATION_0 = \"Could not abort operation \\\"{0}\\\"\";\n     public static final String SKIP_SERVICES_DELETION = \"Skipping deletion of services, because the command line option \\\"--delete-services\\\" is not specified.\";\n     public static final String UNSUPPORTED_MINOR_VERSION = \"Used version \\\"{0}\\\" is higher than the supported ones. Some features might not be implemented.\";\n-    public static final String APPLICATION_NOT_STAGED_CORRECTLY = \"Application \\\"{0}\\\" was not staged correctly during the previous deployment\";", "originalCommit": "72d698f3609a44d4ed50b11d04c2a8fc5d6c2704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgxNjM1OA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/914#discussion_r460816358", "bodyText": "What will be happen in states AWAITING_UPLOAD, COPYING and PROCESSING_UPLOAD? Is it safe to use this package in one of these states?", "author": "theghost5800", "createdAt": "2020-07-27T11:11:21Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/UploadAppStep.java", "diffHunk": "@@ -43,52 +48,65 @@\n @Scope(BeanDefinition.SCOPE_PROTOTYPE)\n public class UploadAppStep extends TimeoutAsyncFlowableStep {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(UploadAppStep.class);\n-\n     static final int DEFAULT_APP_UPLOAD_TIMEOUT = (int) TimeUnit.HOURS.toSeconds(1);\n-\n+    private static final Logger LOGGER = LoggerFactory.getLogger(UploadAppStep.class);\n     @Inject\n     protected ApplicationArchiveReader applicationArchiveReader;\n     @Inject\n     protected ApplicationZipBuilder applicationZipBuilder;\n+    @Inject\n+    protected CloudPackagesGetter cloudPackagesGetter;\n \n     @Override\n     public StepPhase executeAsyncStep(ProcessContext context) throws FileStorageException {\n-        CloudApplicationExtended app = context.getVariable(Variables.APP_TO_PROCESS);\n-        String appName = app.getName();\n-\n-        getStepLogger().info(Messages.UPLOADING_APP, appName);\n-\n-        String appArchiveId = context.getRequiredVariable(Variables.APP_ARCHIVE_ID);\n+        CloudApplicationExtended applicationToProcess = context.getVariable(Variables.APP_TO_PROCESS);\n+        getStepLogger().info(Messages.UPLOADING_APP, applicationToProcess.getName());\n         MtaArchiveElements mtaArchiveElements = context.getVariable(Variables.MTA_ARCHIVE_ELEMENTS);\n-        String fileName = mtaArchiveElements.getModuleFileName(app.getModuleName());\n-\n-        if (fileName == null) {\n+        String moduleFileName = mtaArchiveElements.getModuleFileName(applicationToProcess.getModuleName());\n+        if (moduleFileName == null) {\n             getStepLogger().debug(Messages.NO_CONTENT_TO_UPLOAD);\n             return StepPhase.DONE;\n         }\n-\n-        String newApplicationDigest = getNewApplicationDigest(context, appArchiveId, fileName);\n+        String newApplicationDigest = getNewApplicationDigest(context, context.getRequiredVariable(Variables.APP_ARCHIVE_ID),\n+                                                              moduleFileName);\n         CloudControllerClient client = context.getControllerClient();\n-\n-        CloudApplication cloudApp = client.getApplication(appName);\n+        CloudApplication cloudApp = client.getApplication(applicationToProcess.getName());\n         boolean contentChanged = detectApplicationFileDigestChanges(context, cloudApp, client, newApplicationDigest);\n-        if (!contentChanged && isAppStagedCorrectly(context, cloudApp)) {\n-            getStepLogger().info(Messages.CONTENT_OF_APPLICATION_0_IS_NOT_CHANGED, appName);\n-            return StepPhase.DONE;\n+        if (contentChanged) {\n+            return proceedWithUpload(context, applicationToProcess, moduleFileName, client);\n         }\n+        Optional<CloudPackage> latestUnusedPackage = cloudPackagesGetter.getLatestUnusedPackage(client, cloudApp.getGuid());\n+        if (latestUnusedPackage.isPresent() && isCloudPackageInValidState(latestUnusedPackage.get())) {\n+            return useLatestPackage(context, latestUnusedPackage.get());\n+        }\n+        if (latestUnusedPackage.isPresent() && !isCloudPackageInValidState(latestUnusedPackage.get())) {\n+            return proceedWithUpload(context, applicationToProcess, moduleFileName, client);\n+        }\n+        getStepLogger().info(Messages.CONTENT_OF_APPLICATION_0_IS_NOT_CHANGED, applicationToProcess.getName());\n+        return StepPhase.DONE;\n+    }\n \n-        getStepLogger().debug(Messages.UPLOADING_FILE_0_FOR_APP_1, fileName, appName);\n-        UploadToken uploadToken = asyncUploadFiles(context, client, app, appArchiveId, fileName);\n-\n-        getStepLogger().debug(Messages.STARTED_ASYNC_UPLOAD_OF_APP_0, appName);\n+    private StepPhase proceedWithUpload(ProcessContext context, CloudApplicationExtended application, String moduleFileName,\n+                                        CloudControllerClient client)\n+        throws FileStorageException {\n+        getStepLogger().debug(Messages.UPLOADING_FILE_0_FOR_APP_1, moduleFileName, application.getName());\n+        UploadToken uploadToken = asyncUploadFiles(context, client, application, context.getRequiredVariable(Variables.APP_ARCHIVE_ID),\n+                                                   moduleFileName);\n+        getStepLogger().info(Messages.STARTED_ASYNC_UPLOAD_OF_APP_0, application.getName());\n         context.setVariable(Variables.UPLOAD_TOKEN, uploadToken);\n         return StepPhase.POLL;\n     }\n \n-    private boolean isAppStagedCorrectly(ProcessContext context, CloudApplication cloudApp) {\n-        ApplicationStager appStager = new ApplicationStager(context);\n-        return appStager.isApplicationStagedCorrectly(cloudApp);\n+    private StepPhase useLatestPackage(ProcessContext context, CloudPackage latestUnusedPackage) {\n+        getStepLogger().debug(Messages.THE_NEWEST_PACKAGE_WILL_BE_USED_0, SecureSerialization.toJson(latestUnusedPackage));\n+        context.setVariable(Variables.UPLOAD_TOKEN, ImmutableUploadToken.builder()\n+                                                                        .packageGuid(latestUnusedPackage.getGuid())\n+                                                                        .build());\n+        return StepPhase.POLL;\n+    }\n+\n+    private boolean isCloudPackageInValidState(CloudPackage cloudPackage) {\n+        return cloudPackage.getStatus() != Status.EXPIRED && cloudPackage.getStatus() != Status.FAILED;", "originalCommit": "72d698f3609a44d4ed50b11d04c2a8fc5d6c2704", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk2OTM4Mg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/914#discussion_r460969382", "bodyText": "As we discussed only COPYING and PROCESSING_UPLOAD are safe enough.", "author": "IvanBorislavovDimitrov", "createdAt": "2020-07-27T15:19:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgxNjM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUyMjg4MA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/914#discussion_r461522880", "bodyText": "Until the application binary is not fully uploaded the current status is AWAITING_UPLOAD so, it is safe to poll PROCESSING_UPLOAD and COPYING statuses.", "author": "IvanBorislavovDimitrov", "createdAt": "2020-07-28T11:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgxNjM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzNDE2Nw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/914#discussion_r460834167", "bodyText": "Is it possible to combine some tests in single parameterized test?", "author": "theghost5800", "createdAt": "2020-07-27T11:48:54Z", "path": "multiapps-controller-process/src/test/java/org/cloudfoundry/multiapps/controller/process/steps/UploadAppStepTest.java", "diffHunk": "@@ -187,72 +109,130 @@ public void prepareContext() {\n             when(configuration.getMaxResourceFileSize()).thenReturn(ApplicationConfiguration.DEFAULT_MAX_RESOURCE_FILE_SIZE);\n         }\n \n-        public void prepareClients() throws Exception {\n+        @AfterEach\n+        public void tearDown() {\n+            FileUtils.deleteQuietly(appFile.getParentFile());\n+        }\n+\n+        @Test\n+        void testSuccessfulUpload() throws Exception {\n+            prepareClients(null, null, NEW_MODULE_DIGEST);\n+            step.execute(execution);\n+            assertEquals(UPLOAD_TOKEN, context.getVariable(Variables.UPLOAD_TOKEN));\n+            assertEquals(StepPhase.POLL.toString(), getExecutionStatus());\n+        }\n+\n+        @Test\n+        void testFailedUploadWithIOException() throws Exception {\n+            String expectedIOExceptionMessage = MessageFormat.format(Messages.ERROR_RETRIEVING_MTA_MODULE_CONTENT, APP_FILE);\n+            prepareClients(expectedIOExceptionMessage, null, NEW_MODULE_DIGEST);\n+            Exception exception = assertThrows(SLException.class, () -> step.execute(execution));\n+            assertTrue(exception.getMessage()\n+                                .contains(expectedIOExceptionMessage));\n+            assertFalse(appFile.exists());\n+            assertNull(context.getVariable(Variables.UPLOAD_TOKEN));\n+            assertEquals(StepPhase.RETRY.toString(), getExecutionStatus());\n+        }\n+\n+        @Test\n+        void testFailedUploadWithCFException() throws Exception {\n+            String expectedCFExceptionMessage = MessageFormat.format(Messages.CF_ERROR, CO_EXCEPTION.getMessage());\n+            prepareClients(null, expectedCFExceptionMessage, NEW_MODULE_DIGEST);\n+            Exception exception = assertThrows(SLException.class, () -> step.execute(execution));\n+            assertTrue(exception.getMessage()\n+                                .contains(expectedCFExceptionMessage));\n+            assertFalse(appFile.exists());\n+            assertNull(context.getVariable(Variables.UPLOAD_TOKEN));\n+            assertEquals(StepPhase.RETRY.toString(), getExecutionStatus());\n+        }\n+\n+        @Test\n+        void testWithAvailableValidCloudPackage() throws Exception {\n+            prepareClients(null, null, CURRENT_MODULE_DIGEST);\n+            mockCloudPackagesGetter(createCloudPackage(Status.PROCESSING_UPLOAD));\n+            step.execute(execution);\n+            UploadToken uploadToken = context.getVariable(Variables.UPLOAD_TOKEN);\n+            assertEquals(PACKAGE_GUID, uploadToken.getPackageGuid());\n+            assertEquals(StepPhase.POLL.toString(), getExecutionStatus());\n+        }\n+\n+        @Test\n+        void testWithAvailableFailedLatestPackageAndNonChangedApplicationContent() throws Exception {\n+            prepareClients(null, null, CURRENT_MODULE_DIGEST);\n+            mockCloudPackagesGetter(createCloudPackage(Status.FAILED));\n+            step.execute(execution);\n+            assertEquals(UPLOAD_TOKEN, context.getVariable(Variables.UPLOAD_TOKEN));\n+            assertEquals(StepPhase.POLL.toString(), getExecutionStatus());\n+        }\n+\n+        @Test\n+        void testWithAvailableExpiredCloudPackageAndChangedContent() throws Exception {", "originalCommit": "72d698f3609a44d4ed50b11d04c2a8fc5d6c2704", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk2OTQ2MQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/914#discussion_r460969461", "bodyText": "Done", "author": "IvanBorislavovDimitrov", "createdAt": "2020-07-27T15:19:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzNDE2Nw=="}], "type": "inlineReview"}, {"oid": "8d320c00fd784f9da5cc0ff16aaebc9f57feab70", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/8d320c00fd784f9da5cc0ff16aaebc9f57feab70", "message": "Fix verification for successful staging", "committedDate": "2020-07-27T15:18:08Z", "type": "forcePushed"}, {"oid": "dd2832142ba90eb5ec3f63d1b2d19cad1d1b9b24", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/dd2832142ba90eb5ec3f63d1b2d19cad1d1b9b24", "message": "Fix verification for successful staging", "committedDate": "2020-07-27T17:15:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU0MTQ5Mg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/914#discussion_r461541492", "bodyText": "It looks like is not applied right formatter", "author": "theghost5800", "createdAt": "2020-07-28T12:30:25Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/util/ApplicationStager.java", "diffHunk": "@@ -36,8 +36,8 @@ public StagingState getStagingState() {\n         UUID buildGuid = context.getVariable(Variables.BUILD_GUID);\n         if (buildGuid == null) {\n             return ImmutableStagingState.builder()\n-                                        .state(PackageState.STAGED)\n-                                        .build();\n+                    .state(PackageState.STAGED)", "originalCommit": "dd2832142ba90eb5ec3f63d1b2d19cad1d1b9b24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU1MDQ2MA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/914#discussion_r461550460", "bodyText": "Fixed", "author": "IvanBorislavovDimitrov", "createdAt": "2020-07-28T12:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU0MTQ5Mg=="}], "type": "inlineReview"}, {"oid": "0be8181d192493109125afc46379064f845db0cd", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/0be8181d192493109125afc46379064f845db0cd", "message": "Fix verification for successful staging", "committedDate": "2020-07-28T12:38:03Z", "type": "forcePushed"}, {"oid": "d6ec9e52ecf01a04fe55a3389b772c7cc5c2b3ff", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/d6ec9e52ecf01a04fe55a3389b772c7cc5c2b3ff", "message": "Fix verification for successful staging", "committedDate": "2020-07-28T14:48:11Z", "type": "commit"}, {"oid": "d6ec9e52ecf01a04fe55a3389b772c7cc5c2b3ff", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/d6ec9e52ecf01a04fe55a3389b772c7cc5c2b3ff", "message": "Fix verification for successful staging", "committedDate": "2020-07-28T14:48:11Z", "type": "forcePushed"}]}