{"pr_number": 799, "pr_title": "Delete ownership validation", "pr_createdAt": "2020-03-09T14:17:43Z", "pr_url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIyODkxMA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r390228910", "bodyText": "This is not really properly parallel. It will have a maximum of 2 threads operating in parallel. You should use ForkJoinPoolUtil to ensure proper parallelism.", "author": "VaskoBozhurski", "createdAt": "2020-03-10T10:45:27Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/DeleteServicesStep.java", "diffHunk": "@@ -99,129 +86,36 @@ protected String getStepErrorMessageAdditionalDescription(DelegateExecution cont\n         return ExceptionMessageTailMapper.map(configuration, CloudComponents.SERVICE_BROKERS, offering);\r\n     }\r\n \r\n-    private List<CloudServiceExtended> getServicesData(List<String> serviceNames, ExecutionWrapper execution) {\r\n+    private List<CloudServiceInstance> getServiceInstancesData(List<String> servicesToDelete, ExecutionWrapper execution) {\r\n         CloudControllerClient client = execution.getControllerClient();\r\n \r\n-        return serviceNames.parallelStream()\r\n-                           .map(name -> client.getService(name, false))\r\n-                           .filter(Objects::nonNull)\r\n-                           .map(this::buildCloudServiceExtended)\r\n-                           .collect(Collectors.toList());\r\n-    }\r\n-\r\n-    private ImmutableCloudServiceExtended buildCloudServiceExtended(CloudService service) {\r\n-        return ImmutableCloudServiceExtended.builder()\r\n-                                            .metadata(service.getMetadata())\r\n-                                            .name(service.getName())\r\n-                                            .build();\r\n+        return servicesToDelete.parallelStream()\r", "originalCommit": "b9d3c903e95b9b5f2a66c28e2c258534a302ef26", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI0MjMxMw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r390242313", "bodyText": "can you doublecheck if this is correct? The service action should be for 1 service, but the signature of the method is a list of services.", "author": "VaskoBozhurski", "createdAt": "2020-03-10T11:11:31Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/ServiceRemovalCalculator.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.cloudfoundry.client.lib.CloudControllerClient;\n+import org.cloudfoundry.client.lib.domain.CloudServiceInstance;\n+\n+import com.sap.cloud.lm.sl.cf.core.cf.clients.ServiceGetter;\n+import com.sap.cloud.lm.sl.cf.core.model.ServiceInstanceWithServiceKeys;\n+import com.sap.cloud.lm.sl.cf.process.Messages;\n+import com.sap.cloud.lm.sl.cf.process.analytics.model.ServiceAction;\n+import com.sap.cloud.lm.sl.cf.process.steps.ExecutionWrapper;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+\n+@Named\n+public class ServiceRemovalCalculator {\n+\n+    private ServiceGetter serviceGetter;\n+\n+    @Inject\n+    public ServiceRemovalCalculator(ServiceGetter serviceGetter) {\n+        this.serviceGetter = serviceGetter;\n+    }\n+\n+    public List<ServiceInstanceWithServiceKeys> calculateServicesToDelete(ExecutionWrapper execution,\n+                                                                          List<CloudServiceInstance> serviceInstances) {\n+        List<ServiceInstanceWithServiceKeys> serviceInstancesWithServiceKeys = getServiceInstancesWithServiceKeys(execution.getControllerClient(),\n+                                                                                                                  serviceInstances);\n+        if (StepsUtil.getServiceActionsToExecute(execution.getContext())", "originalCommit": "b9d3c903e95b9b5f2a66c28e2c258534a302ef26", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI0NzAyNw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r390247027", "bodyText": "maybe extract into a method and turn the for() into a stream?", "author": "VaskoBozhurski", "createdAt": "2020-03-10T11:22:04Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/ServiceRemoval.java", "diffHunk": "@@ -0,0 +1,155 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.cloudfoundry.client.lib.CloudControllerClient;\n+import org.cloudfoundry.client.lib.CloudControllerException;\n+import org.cloudfoundry.client.lib.CloudException;\n+import org.cloudfoundry.client.lib.CloudOperationException;\n+import org.cloudfoundry.client.lib.CloudServiceBrokerException;\n+import org.cloudfoundry.client.lib.domain.CloudApplication;\n+import org.cloudfoundry.client.lib.domain.CloudService;\n+import org.cloudfoundry.client.lib.domain.CloudServiceBinding;\n+import org.cloudfoundry.client.lib.domain.CloudServiceInstance;\n+import org.cloudfoundry.client.lib.domain.CloudServiceKey;\n+import org.springframework.http.HttpStatus;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.ServiceInstanceWithServiceKeys;\n+import com.sap.cloud.lm.sl.cf.core.model.ServiceOperation;\n+import com.sap.cloud.lm.sl.cf.core.security.serialization.SecureSerializationFacade;\n+import com.sap.cloud.lm.sl.cf.core.util.ApplicationConfiguration;\n+import com.sap.cloud.lm.sl.cf.process.Constants;\n+import com.sap.cloud.lm.sl.cf.process.Messages;\n+import com.sap.cloud.lm.sl.cf.process.steps.ExecutionWrapper;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper.CloudComponents;\n+import com.sap.cloud.lm.sl.common.SLException;\n+\n+@Named\n+public class ServiceRemoval {\n+\n+    private final SecureSerializationFacade secureSerializer = new SecureSerializationFacade();\n+\n+    private ApplicationConfiguration configuration;\n+    private ServiceRemovalCalculator serviceRemovalCalculator;\n+\n+    @Inject\n+    public ServiceRemoval(ApplicationConfiguration configuration, ServiceRemovalCalculator serviceRemovalCalculator) {\n+        this.configuration = configuration;\n+        this.serviceRemovalCalculator = serviceRemovalCalculator;\n+    }\n+\n+    public Map<String, ServiceOperation.Type> deleteServices(ExecutionWrapper execution, List<CloudServiceInstance> serviceInstancesData) {\n+        Map<String, ServiceOperation.Type> triggeredServiceOperations = new HashMap<>();\n+        CloudControllerClient client = execution.getControllerClient();\n+\n+        List<ServiceInstanceWithServiceKeys> servicesToDelete = determineServiceIntancesToDelete(execution, serviceInstancesData);\n+        for (ServiceInstanceWithServiceKeys service : servicesToDelete) {\n+            try {", "originalCommit": "b9d3c903e95b9b5f2a66c28e2c258534a302ef26", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "09d9f77472258ef88b6bb4df37b0f56a5d578b7f", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/09d9f77472258ef88b6bb4df37b0f56a5d578b7f", "message": "Make delete service step to execute in parallel", "committedDate": "2020-03-12T14:33:43Z", "type": "forcePushed"}, {"oid": "69a9f8d95c2a55cb1ef3d04a998d7bc513fcfed3", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/69a9f8d95c2a55cb1ef3d04a998d7bc513fcfed3", "message": "Make delete service step to execute in parallel", "committedDate": "2020-03-12T14:43:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwMzc5MA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r391703790", "bodyText": "If buildServiceInstanceWithServiceKeys(service, client) isn't called elsewhere you can just move the code to getServiceInstancesWithServiceKeys.", "author": "VaskoBozhurski", "createdAt": "2020-03-12T15:32:21Z", "path": "com.sap.cloud.lm.sl.cf.core/src/main/java/com/sap/cloud/lm/sl/cf/core/cf/clients/ServiceGetter.java", "diffHunk": "@@ -37,24 +36,19 @@ public ServiceGetter(@Qualifier(\"serviceInstanceGetter\") AbstractServiceGetter s\n         return serviceInstance;\n     }\n \n-    public List<ServiceInstanceWithServiceKeys> getServiceInstancesWithServiceKeys(CloudControllerClient client,\n-                                                                                   List<CloudServiceInstance> services) {\n-        return services.stream()\n-                       .map(service -> buildServiceInstanceWithServiceKeys(service, client))\n-                       .collect(Collectors.toList());\n+    public ServiceInstanceWithServiceKeys getServiceInstancesWithServiceKeys(CloudControllerClient client, CloudServiceInstance service) {\n+        return buildServiceInstanceWithServiceKeys(service, client);", "originalCommit": "69a9f8d95c2a55cb1ef3d04a998d7bc513fcfed3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNzM5OQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r391707399", "bodyText": "this was a json binary before, are you sure the list will be properly serialized now with just setVariable in all cases?", "author": "VaskoBozhurski", "createdAt": "2020-03-12T15:37:43Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/StepsUtil.java", "diffHunk": "@@ -345,13 +345,19 @@ static void setAppsToUndeploy(VariableScope scope, List<CloudApplication> apps)\n     }\r\n \r\n     public static List<String> getServicesToDelete(VariableScope scope) {\r\n-        TypeReference<List<String>> type = new TypeReference<List<String>>() {\r\n-        };\r\n-        return getFromJsonBinary(scope, Constants.VAR_SERVICES_TO_DELETE, type);\r\n+        return getObject(scope, Constants.VAR_SERVICES_TO_DELETE, Collections.emptyList());\r\n     }\r\n \r\n     public static void setServicesToDelete(VariableScope scope, List<String> services) {\r\n-        setAsJsonBinary(scope, Constants.VAR_SERVICES_TO_DELETE, services);\r\n+        scope.setVariable(Constants.VAR_SERVICES_TO_DELETE, services);\r", "originalCommit": "69a9f8d95c2a55cb1ef3d04a998d7bc513fcfed3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc0MDI5Ng==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r391740296", "bodyText": "This change was necessary because Flowable engine throw exception that result from getServicesToDelete() method is not a Collection.", "author": "theghost5800", "createdAt": "2020-03-12T16:27:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNzM5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4ODE1OQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r392188159", "bodyText": "From the conversation, my understanding is that you'd want to use this variable in flowable bpmn diagram in order to parallelize the deletion of services, and you could not do that because you need the variable not to be in 'bytearray' format in the database. This is okay. However - is this backwards compatible? What would happen if I retry my deployment, that has this variable stored as 'bytearray' after the release of the diagram change happens - will the deployment fail?", "author": "valentinEmpy", "createdAt": "2020-03-13T12:05:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNzM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NzM0MA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r392187340", "bodyText": "getServiceInstance(S), plural? Furthermore, read below about the ServiceInstanceWithServiceKeys class", "author": "valentinEmpy", "createdAt": "2020-03-13T12:03:26Z", "path": "com.sap.cloud.lm.sl.cf.core/src/main/java/com/sap/cloud/lm/sl/cf/core/cf/clients/ServiceGetter.java", "diffHunk": "@@ -22,19 +28,26 @@ public ServiceGetter(@Qualifier(\"serviceInstanceGetter\") AbstractServiceGetter s\n         this.userProvidedServiceInstanceGetter = userProvidedServiceInstanceGetter;\n     }\n \n-    public Map<String, Object> getServiceInstance(CloudControllerClient client, String serviceName, String spaceId) {\n-        Map<String, Object> serviceInstance = serviceInstanceGetter.getServiceInstance(client, serviceName, spaceId);\n-        if (serviceInstance == null || serviceInstance.isEmpty()) {\n-            serviceInstance = userProvidedServiceInstanceGetter.getServiceInstance(client, serviceName, spaceId);\n-        }\n-        return serviceInstance;\n-    }\n-\n     public Map<String, Object> getServiceInstanceEntity(CloudControllerClient client, String serviceName, String spaceId) {\n         Map<String, Object> serviceInstance = serviceInstanceGetter.getServiceInstanceEntity(client, serviceName, spaceId);\n         if (serviceInstance == null || serviceInstance.isEmpty()) {\n             serviceInstance = userProvidedServiceInstanceGetter.getServiceInstanceEntity(client, serviceName, spaceId);\n         }\n         return serviceInstance;\n     }\n+\n+    public ServiceInstanceWithServiceKeys getServiceInstancesWithServiceKeys(CloudControllerClient client, CloudServiceInstance service) {", "originalCommit": "edb3e8d6a67c7ae8f7a43f9625c34af2d93872a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NzM2NA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r392187364", "bodyText": "What is the benefit of having this class? As far as I can see, it is used only in delete services step, do you think it'd be simpler to just acquire the service and the service keys as separate entities and process them accordingly. What does this 'wrapping' help with? Wouldn't the code be more understandable and explicit in DeleteServicesStep if that was applied? What do you think", "author": "valentinEmpy", "createdAt": "2020-03-13T12:03:31Z", "path": "com.sap.cloud.lm.sl.cf.core/src/main/java/com/sap/cloud/lm/sl/cf/core/model/ServiceInstanceWithServiceKeys.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package com.sap.cloud.lm.sl.cf.core.model;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.cloudfoundry.client.lib.domain.CloudServiceInstance;\n+import org.cloudfoundry.client.lib.domain.CloudServiceKey;\n+import org.immutables.value.Value;\n+\n+@Value.Immutable\n+public interface ServiceInstanceWithServiceKeys {", "originalCommit": "edb3e8d6a67c7ae8f7a43f9625c34af2d93872a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NzM5OQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r392187399", "bodyText": "Take a look at Immutables documentation. Quote:\n\"There's no need to use @Value.Default to return empty collections as collection attributes are empty by default if not initialized.\"", "author": "valentinEmpy", "createdAt": "2020-03-13T12:03:37Z", "path": "com.sap.cloud.lm.sl.cf.core/src/main/java/com/sap/cloud/lm/sl/cf/core/model/ServiceInstanceWithServiceKeys.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package com.sap.cloud.lm.sl.cf.core.model;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.cloudfoundry.client.lib.domain.CloudServiceInstance;\n+import org.cloudfoundry.client.lib.domain.CloudServiceKey;\n+import org.immutables.value.Value;\n+\n+@Value.Immutable\n+public interface ServiceInstanceWithServiceKeys {\n+\n+    CloudServiceInstance getServiceInstance();\n+\n+    @Value.Default\n+    default List<CloudServiceKey> getServiceKeys() {\n+        return Collections.emptyList();", "originalCommit": "edb3e8d6a67c7ae8f7a43f9625c34af2d93872a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NzU3Mw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r392187573", "bodyText": "What is the double ' for? I assume it is a type?", "author": "valentinEmpy", "createdAt": "2020-03-13T12:03:57Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/Messages.java", "diffHunk": "@@ -180,6 +172,7 @@\n     public static final String MISSING_SERVICE_OPERATION_STATE = \"Stopping service operation polling of \\\"{0}\\\" due to missing operation state...\";\r\n     public static final String CANNOT_GET_CONTEXT_FOR_EVENT_0_AND_PROCESS_1 = \"Could not get context for Flowable engine event (type: {0}, process ID: {1}).\";\r\n     public static final String SERVICE_0_IS_IN_STATE_1_AND_MAY_NOT_BE_OPERATIONAL = \"Service \\\"{0}\\\" is in state \\\"{1}\\\" and may not be operational. Actions like update of credentials and binding may fail! Consider recreating it by specifying the --delete-services option.\";\r\n+    public static final String SERVICE_NOT_BE_DELETED_DUE_TO_SERVICE_BINDINGS_AND_SERVICE_KEYS = \"Service \\\"{0}\\\" won''t be deleted due to existing service bindings and/or service keys\";\r", "originalCommit": "edb3e8d6a67c7ae8f7a43f9625c34af2d93872a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU0MTYxMA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r393541610", "bodyText": "It was required before to escape single quote because if you don't escape it, MessageFormatter stop to resolve placeholders after single quote, now there is not others placeholders, so I will delete it.", "author": "theghost5800", "createdAt": "2020-03-17T09:23:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NzU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NzY1Mg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r392187652", "bodyText": "Why does this method have the suffix 'Data'? Also, the variables assigned in the above methods also include the 'Data' suffix. Do we really need this method anyway, why not just call the client directly where this method is used?", "author": "valentinEmpy", "createdAt": "2020-03-13T12:04:12Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/DeleteServicesStep.java", "diffHunk": "@@ -99,129 +87,33 @@ protected String getStepErrorMessageAdditionalDescription(DelegateExecution cont\n         return ExceptionMessageTailMapper.map(configuration, CloudComponents.SERVICE_BROKERS, offering);\r\n     }\r\n \r\n-    private List<CloudServiceExtended> getServicesData(List<String> serviceNames, ExecutionWrapper execution) {\r\n-        CloudControllerClient client = execution.getControllerClient();\r\n+    private CloudServiceInstance getServiceInstanceData(String serviceToDelete, CloudControllerClient client) {\r", "originalCommit": "edb3e8d6a67c7ae8f7a43f9625c34af2d93872a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4ODIwOQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r392188209", "bodyText": "Can we rename this class? Reading it leaves me with the impression that it represents some 'operation' - the removal of the service. Perhaps - remover?", "author": "valentinEmpy", "createdAt": "2020-03-13T12:05:44Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/ServiceRemoval.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.text.MessageFormat;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.cloudfoundry.client.lib.CloudControllerClient;\n+import org.cloudfoundry.client.lib.CloudControllerException;\n+import org.cloudfoundry.client.lib.CloudException;\n+import org.cloudfoundry.client.lib.CloudOperationException;\n+import org.cloudfoundry.client.lib.CloudServiceBrokerException;\n+import org.cloudfoundry.client.lib.domain.CloudApplication;\n+import org.cloudfoundry.client.lib.domain.CloudService;\n+import org.cloudfoundry.client.lib.domain.CloudServiceBinding;\n+import org.cloudfoundry.client.lib.domain.CloudServiceInstance;\n+import org.cloudfoundry.client.lib.domain.CloudServiceKey;\n+import org.springframework.http.HttpStatus;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.ServiceInstanceWithServiceKeys;\n+import com.sap.cloud.lm.sl.cf.core.security.serialization.SecureSerializationFacade;\n+import com.sap.cloud.lm.sl.cf.core.util.ApplicationConfiguration;\n+import com.sap.cloud.lm.sl.cf.process.Constants;\n+import com.sap.cloud.lm.sl.cf.process.Messages;\n+import com.sap.cloud.lm.sl.cf.process.steps.ExecutionWrapper;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper.CloudComponents;\n+import com.sap.cloud.lm.sl.common.SLException;\n+\n+@Named\n+public class ServiceRemoval {", "originalCommit": "edb3e8d6a67c7ae8f7a43f9625c34af2d93872a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4ODIzNQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r392188235", "bodyText": "Why are those checks needed? You check for empty associations before you call deleteService. If there are no empty associations - would this ever be reached at all?", "author": "valentinEmpy", "createdAt": "2020-03-13T12:05:49Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/ServiceRemoval.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.text.MessageFormat;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.cloudfoundry.client.lib.CloudControllerClient;\n+import org.cloudfoundry.client.lib.CloudControllerException;\n+import org.cloudfoundry.client.lib.CloudException;\n+import org.cloudfoundry.client.lib.CloudOperationException;\n+import org.cloudfoundry.client.lib.CloudServiceBrokerException;\n+import org.cloudfoundry.client.lib.domain.CloudApplication;\n+import org.cloudfoundry.client.lib.domain.CloudService;\n+import org.cloudfoundry.client.lib.domain.CloudServiceBinding;\n+import org.cloudfoundry.client.lib.domain.CloudServiceInstance;\n+import org.cloudfoundry.client.lib.domain.CloudServiceKey;\n+import org.springframework.http.HttpStatus;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.ServiceInstanceWithServiceKeys;\n+import com.sap.cloud.lm.sl.cf.core.security.serialization.SecureSerializationFacade;\n+import com.sap.cloud.lm.sl.cf.core.util.ApplicationConfiguration;\n+import com.sap.cloud.lm.sl.cf.process.Constants;\n+import com.sap.cloud.lm.sl.cf.process.Messages;\n+import com.sap.cloud.lm.sl.cf.process.steps.ExecutionWrapper;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper.CloudComponents;\n+import com.sap.cloud.lm.sl.common.SLException;\n+\n+@Named\n+public class ServiceRemoval {\n+\n+    private final SecureSerializationFacade secureSerializer = new SecureSerializationFacade();\n+\n+    private ApplicationConfiguration configuration;\n+\n+    @Inject\n+    public ServiceRemoval(ApplicationConfiguration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    public void deleteService(ExecutionWrapper execution, ServiceInstanceWithServiceKeys service) {\n+        CloudControllerClient client = execution.getControllerClient();\n+\n+        try {\n+            prepareServicesToDelete(client, execution.getStepLogger(), service);\n+            deleteService(client, execution.getStepLogger(), service);\n+        } catch (CloudException e) {\n+            processException(execution, e, client.getServiceInstance(service.getServiceInstance()\n+                                                                            .getName()));\n+        }\n+\n+    }\n+\n+    private void prepareServicesToDelete(CloudControllerClient client, StepLogger stepLogger, ServiceInstanceWithServiceKeys service) {\n+        unbindService(client, stepLogger, service.getServiceInstance());\n+        deleteServiceKeys(client, stepLogger, service.getServiceKeys());\n+\n+    }\n+\n+    private void unbindService(CloudControllerClient client, StepLogger stepLogger, CloudServiceInstance serviceInstance) {\n+        List<CloudServiceBinding> bindings = serviceInstance.getBindings();\n+        if (bindings.isEmpty()) {", "originalCommit": "edb3e8d6a67c7ae8f7a43f9625c34af2d93872a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4ODI4Mg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r392188282", "bodyText": "The method name is not very descriptive. Reading it, does not point at what exception message exactly it builds, especially the 'New' keyword. I had to check in the implementation to understand that it builds an error message wen deleting a service.", "author": "valentinEmpy", "createdAt": "2020-03-13T12:05:53Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/ServiceRemoval.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.text.MessageFormat;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.cloudfoundry.client.lib.CloudControllerClient;\n+import org.cloudfoundry.client.lib.CloudControllerException;\n+import org.cloudfoundry.client.lib.CloudException;\n+import org.cloudfoundry.client.lib.CloudOperationException;\n+import org.cloudfoundry.client.lib.CloudServiceBrokerException;\n+import org.cloudfoundry.client.lib.domain.CloudApplication;\n+import org.cloudfoundry.client.lib.domain.CloudService;\n+import org.cloudfoundry.client.lib.domain.CloudServiceBinding;\n+import org.cloudfoundry.client.lib.domain.CloudServiceInstance;\n+import org.cloudfoundry.client.lib.domain.CloudServiceKey;\n+import org.springframework.http.HttpStatus;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.ServiceInstanceWithServiceKeys;\n+import com.sap.cloud.lm.sl.cf.core.security.serialization.SecureSerializationFacade;\n+import com.sap.cloud.lm.sl.cf.core.util.ApplicationConfiguration;\n+import com.sap.cloud.lm.sl.cf.process.Constants;\n+import com.sap.cloud.lm.sl.cf.process.Messages;\n+import com.sap.cloud.lm.sl.cf.process.steps.ExecutionWrapper;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper.CloudComponents;\n+import com.sap.cloud.lm.sl.common.SLException;\n+\n+@Named\n+public class ServiceRemoval {\n+\n+    private final SecureSerializationFacade secureSerializer = new SecureSerializationFacade();\n+\n+    private ApplicationConfiguration configuration;\n+\n+    @Inject\n+    public ServiceRemoval(ApplicationConfiguration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    public void deleteService(ExecutionWrapper execution, ServiceInstanceWithServiceKeys service) {\n+        CloudControllerClient client = execution.getControllerClient();\n+\n+        try {\n+            prepareServicesToDelete(client, execution.getStepLogger(), service);\n+            deleteService(client, execution.getStepLogger(), service);\n+        } catch (CloudException e) {\n+            processException(execution, e, client.getServiceInstance(service.getServiceInstance()\n+                                                                            .getName()));\n+        }\n+\n+    }\n+\n+    private void prepareServicesToDelete(CloudControllerClient client, StepLogger stepLogger, ServiceInstanceWithServiceKeys service) {\n+        unbindService(client, stepLogger, service.getServiceInstance());\n+        deleteServiceKeys(client, stepLogger, service.getServiceKeys());\n+\n+    }\n+\n+    private void unbindService(CloudControllerClient client, StepLogger stepLogger, CloudServiceInstance serviceInstance) {\n+        List<CloudServiceBinding> bindings = serviceInstance.getBindings();\n+        if (bindings.isEmpty()) {\n+            return;\n+        }\n+        logBindings(stepLogger, bindings);\n+        List<CloudApplication> applications = client.getApplications();\n+        for (CloudServiceBinding binding : bindings) {\n+            CloudApplication application = StepsUtil.getBoundApplication(applications, binding.getApplicationGuid());\n+            if (application == null) {\n+                throw new IllegalStateException(MessageFormat.format(Messages.COULD_NOT_FIND_APPLICATION_WITH_GUID_0,\n+                                                                     binding.getApplicationGuid()));\n+            }\n+            stepLogger.info(Messages.UNBINDING_SERVICE_FROM_APP, serviceInstance, application.getName());\n+            client.unbindService(application, serviceInstance.getService());\n+        }\n+    }\n+\n+    private void logBindings(StepLogger stepLogger, List<CloudServiceBinding> bindings) {\n+        stepLogger.debug(Messages.SERVICE_BINDINGS_EXISTS, secureSerializer.toJson(bindings));\n+    }\n+\n+    private void deleteServiceKeys(CloudControllerClient client, StepLogger stepLogger, List<CloudServiceKey> serviceKeys) {\n+        for (CloudServiceKey serviceKey : serviceKeys) {\n+            stepLogger.info(Messages.DELETING_SERVICE_KEY_FOR_SERVICE, serviceKey.getName(), serviceKeys);\n+            client.deleteServiceKey(serviceKey);\n+        }\n+    }\n+\n+    private void deleteService(CloudControllerClient client, StepLogger stepLogger, ServiceInstanceWithServiceKeys service) {\n+        stepLogger.info(Messages.DELETING_SERVICE, service.getServiceInstance()\n+                                                          .getName());\n+        client.deleteService(service.getServiceInstance()\n+                                    .getService());\n+        stepLogger.debug(Messages.SERVICE_DELETED, service.getServiceInstance()\n+                                                          .getName());\n+    }\n+\n+    private void processException(ExecutionWrapper execution, Exception e, CloudServiceInstance serviceInstance) {\n+        if (e instanceof CloudOperationException) {\n+            e = evaluateCloudOperationException(execution, (CloudOperationException) e, serviceInstance.getName(),\n+                                                serviceInstance.getService()\n+                                                               .getLabel());\n+            if (e == null) {\n+                return;\n+            }\n+        }\n+        wrapAndThrowException(e, serviceInstance);\n+    }\n+\n+    private CloudOperationException evaluateCloudOperationException(ExecutionWrapper execution, CloudOperationException e,\n+                                                                    String serviceName, String label) {\n+        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n+            execution.getStepLogger()\n+                     .warn(MessageFormat.format(Messages.COULD_NOT_DELETE_SERVICE, serviceName), e,\n+                           ExceptionMessageTailMapper.map(configuration, CloudComponents.SERVICE_BROKERS, label));\n+            return null;\n+        }\n+        if (e.getStatusCode() == HttpStatus.BAD_GATEWAY) {\n+            StepsUtil.setServiceOffering(execution.getContext(), Constants.VAR_SERVICE_OFFERING, label);\n+            return new CloudServiceBrokerException(e);\n+        }\n+        return new CloudControllerException(e);\n+\n+    }\n+\n+    private void wrapAndThrowException(Exception e, CloudServiceInstance serviceInstance) {\n+        String msg = buildNewExceptionMessage(e, serviceInstance.getService());\n+        throw new SLException(e, msg);\n+    }\n+\n+    private String buildNewExceptionMessage(Exception e, CloudService service) {", "originalCommit": "edb3e8d6a67c7ae8f7a43f9625c34af2d93872a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQwMzkyNw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r394403927", "bodyText": "*ProcessGetter suffix? Looking at the name, without taking a look at the implementation leaves me with the impression it returns some kind of a process (service deletion process), whereas it returns a process variable. Do you think there's a more descriptive/appropriate class name (The first part is reasonable, I am referring to the suffix here)?", "author": "valentinEmpy", "createdAt": "2020-03-18T14:49:12Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/ServicesToDeleteProcessGetter.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.util.List;\n+\n+import javax.inject.Named;\n+\n+import org.flowable.engine.delegate.DelegateExecution;\n+\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+\n+@Named(\"servicesToDeleteProcessGetter\")\n+public class ServicesToDeleteProcessGetter {", "originalCommit": "0d34c6dcf7b5f760b8ff7464d6ffd9fde50c51d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQwNzEwMw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r394407103", "bodyText": "This branch will always be taken? The 'getObject' method returns a list if it manages to find the variable and also returns a list if it does not (an empty one as you've specified), so in both cases it would result in this branch?", "author": "valentinEmpy", "createdAt": "2020-03-18T14:53:10Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/StepsUtil.java", "diffHunk": "@@ -345,7 +345,13 @@ static void setAppsToUndeploy(VariableScope scope, List<CloudApplication> apps)\n     }\r\n \r\n     public static List<String> getServicesToDelete(VariableScope scope) {\r\n-        return getObject(scope, Constants.VAR_SERVICES_TO_DELETE, Collections.emptyList());\r\n+        Object servicesToDelete = getObject(scope, Constants.VAR_SERVICES_TO_DELETE, Collections.emptyList());\r\n+        if (servicesToDelete instanceof List) {\r", "originalCommit": "0d34c6dcf7b5f760b8ff7464d6ffd9fde50c51d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQxMjUwNw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r394412507", "bodyText": "I feel like this method should only check for associations but it does more than 1 thing (what its name says it does) - it also checks for determined service actions (I miss finding any association with 'conflict' here). What do you think?", "author": "valentinEmpy", "createdAt": "2020-03-18T14:59:59Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/DeleteServiceStep.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package com.sap.cloud.lm.sl.cf.process.steps;\r\n+\r\n+import java.util.Collections;\r\n+import java.util.List;\r\n+\r\n+import javax.inject.Inject;\r\n+import javax.inject.Named;\r\n+\r\n+import org.cloudfoundry.client.lib.CloudControllerClient;\r\n+import org.cloudfoundry.client.lib.domain.CloudServiceBinding;\r\n+import org.cloudfoundry.client.lib.domain.CloudServiceInstance;\r\n+import org.cloudfoundry.client.lib.domain.CloudServiceKey;\r\n+import org.flowable.engine.delegate.DelegateExecution;\r\n+import org.springframework.beans.factory.config.BeanDefinition;\r\n+import org.springframework.context.annotation.Scope;\r\n+\r\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.CloudServiceExtended;\r\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.ImmutableCloudServiceExtended;\r\n+import com.sap.cloud.lm.sl.cf.core.model.ServiceOperation;\r\n+import com.sap.cloud.lm.sl.cf.process.Messages;\r\n+import com.sap.cloud.lm.sl.cf.process.analytics.model.ServiceAction;\r\n+import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper;\r\n+import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper.CloudComponents;\r\n+import com.sap.cloud.lm.sl.cf.process.util.ServiceOperationGetter;\r\n+import com.sap.cloud.lm.sl.cf.process.util.ServiceProgressReporter;\r\n+import com.sap.cloud.lm.sl.cf.process.util.ServiceRemover;\r\n+import com.sap.cloud.lm.sl.common.util.MapUtil;\r\n+\r\n+@Named(\"deleteServiceStep\")\r\n+@Scope(BeanDefinition.SCOPE_PROTOTYPE)\r\n+public class DeleteServiceStep extends AsyncFlowableStep {\r\n+\r\n+    private ServiceOperationGetter serviceOperationGetter;\r\n+    private ServiceProgressReporter serviceProgressReporter;\r\n+    private ServiceRemover serviceRemover;\r\n+\r\n+    @Inject\r\n+    public DeleteServiceStep(ServiceOperationGetter serviceOperationGetter, ServiceProgressReporter serviceProgressReporter,\r\n+                             ServiceRemover serviceRemover) {\r\n+        this.serviceOperationGetter = serviceOperationGetter;\r\n+        this.serviceProgressReporter = serviceProgressReporter;\r\n+        this.serviceRemover = serviceRemover;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected StepPhase executeAsyncStep(ExecutionWrapper execution) {\r\n+        String serviceToDelete = StepsUtil.getServiceToDelete(execution.getContext());\r\n+        if (serviceToDelete == null) {\r\n+            getStepLogger().debug(Messages.MISSING_SERVICE_TO_DELETE);\r\n+            return StepPhase.DONE;\r\n+        }\r\n+\r\n+        getStepLogger().debug(Messages.DELETING_DISCONTINUED_SERVICE_0, serviceToDelete);\r\n+\r\n+        CloudControllerClient client = execution.getControllerClient();\r\n+\r\n+        CloudServiceInstance serviceInstance = client.getServiceInstance(serviceToDelete, false);\r\n+        if (serviceInstance == null) {\r\n+            getStepLogger().info(Messages.SERVICE_IS_ALREADY_DELETED, serviceToDelete);\r\n+            return StepPhase.DONE;\r\n+        }\r\n+        StepsUtil.setServicesData(execution.getContext(), buildCloudServiceExtendedList(serviceInstance));\r\n+\r\n+        List<CloudServiceKey> serviceKeys = client.getServiceKeys(serviceInstance.getService());\r\n+\r\n+        if (isDeletePossible(execution.getContext(), serviceInstance.getBindings(), serviceKeys)) {\r\n+            deleteService(execution, serviceInstance, serviceKeys);\r\n+            StepsUtil.setTriggeredServiceOperations(execution.getContext(), MapUtil.asMap(serviceToDelete, ServiceOperation.Type.DELETE));\r\n+            return StepPhase.POLL;\r\n+        }\r\n+\r\n+        getStepLogger().warn(Messages.SERVICE_NOT_BE_DELETED_DUE_TO_SERVICE_BINDINGS_AND_SERVICE_KEYS, serviceToDelete);\r\n+        return StepPhase.DONE;\r\n+\r\n+    }\r\n+\r\n+    @Override\r\n+    protected String getStepErrorMessage(DelegateExecution context) {\r\n+        return Messages.ERROR_DELETING_SERVICES;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected String getStepErrorMessageAdditionalDescription(DelegateExecution context) {\r\n+        String offering = StepsUtil.getServiceOffering(context);\r\n+        return ExceptionMessageTailMapper.map(configuration, CloudComponents.SERVICE_BROKERS, offering);\r\n+    }\r\n+\r\n+    private List<CloudServiceExtended> buildCloudServiceExtendedList(CloudServiceInstance serviceInstanceData) {\r\n+        return Collections.singletonList(buildCloudServiceExtended(serviceInstanceData));\r\n+    }\r\n+\r\n+    private ImmutableCloudServiceExtended buildCloudServiceExtended(CloudServiceInstance service) {\r\n+        return ImmutableCloudServiceExtended.builder()\r\n+                                            .from(service.getService())\r\n+                                            .build();\r\n+    }\r\n+\r\n+    private boolean isDeletePossible(DelegateExecution context, List<CloudServiceBinding> serviceBindings,\r\n+                                     List<CloudServiceKey> serviceKeys) {\r\n+        return hasNoConflictWithServiceBindings(context, serviceBindings) && hasNoConflictWithServiceKeys(context, serviceKeys);\r\n+    }\r\n+\r\n+    private boolean hasNoConflictWithServiceBindings(DelegateExecution context, List<CloudServiceBinding> serviceBindings) {\r\n+        return serviceBindings.isEmpty() || StepsUtil.getServiceActionsToExecute(context)\r", "originalCommit": "0d34c6dcf7b5f760b8ff7464d6ffd9fde50c51d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQxMjk0Ng==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r394412946", "bodyText": "Same as the above comment. What do you think?", "author": "valentinEmpy", "createdAt": "2020-03-18T15:00:34Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/DeleteServiceStep.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package com.sap.cloud.lm.sl.cf.process.steps;\r\n+\r\n+import java.util.Collections;\r\n+import java.util.List;\r\n+\r\n+import javax.inject.Inject;\r\n+import javax.inject.Named;\r\n+\r\n+import org.cloudfoundry.client.lib.CloudControllerClient;\r\n+import org.cloudfoundry.client.lib.domain.CloudServiceBinding;\r\n+import org.cloudfoundry.client.lib.domain.CloudServiceInstance;\r\n+import org.cloudfoundry.client.lib.domain.CloudServiceKey;\r\n+import org.flowable.engine.delegate.DelegateExecution;\r\n+import org.springframework.beans.factory.config.BeanDefinition;\r\n+import org.springframework.context.annotation.Scope;\r\n+\r\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.CloudServiceExtended;\r\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.ImmutableCloudServiceExtended;\r\n+import com.sap.cloud.lm.sl.cf.core.model.ServiceOperation;\r\n+import com.sap.cloud.lm.sl.cf.process.Messages;\r\n+import com.sap.cloud.lm.sl.cf.process.analytics.model.ServiceAction;\r\n+import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper;\r\n+import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper.CloudComponents;\r\n+import com.sap.cloud.lm.sl.cf.process.util.ServiceOperationGetter;\r\n+import com.sap.cloud.lm.sl.cf.process.util.ServiceProgressReporter;\r\n+import com.sap.cloud.lm.sl.cf.process.util.ServiceRemover;\r\n+import com.sap.cloud.lm.sl.common.util.MapUtil;\r\n+\r\n+@Named(\"deleteServiceStep\")\r\n+@Scope(BeanDefinition.SCOPE_PROTOTYPE)\r\n+public class DeleteServiceStep extends AsyncFlowableStep {\r\n+\r\n+    private ServiceOperationGetter serviceOperationGetter;\r\n+    private ServiceProgressReporter serviceProgressReporter;\r\n+    private ServiceRemover serviceRemover;\r\n+\r\n+    @Inject\r\n+    public DeleteServiceStep(ServiceOperationGetter serviceOperationGetter, ServiceProgressReporter serviceProgressReporter,\r\n+                             ServiceRemover serviceRemover) {\r\n+        this.serviceOperationGetter = serviceOperationGetter;\r\n+        this.serviceProgressReporter = serviceProgressReporter;\r\n+        this.serviceRemover = serviceRemover;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected StepPhase executeAsyncStep(ExecutionWrapper execution) {\r\n+        String serviceToDelete = StepsUtil.getServiceToDelete(execution.getContext());\r\n+        if (serviceToDelete == null) {\r\n+            getStepLogger().debug(Messages.MISSING_SERVICE_TO_DELETE);\r\n+            return StepPhase.DONE;\r\n+        }\r\n+\r\n+        getStepLogger().debug(Messages.DELETING_DISCONTINUED_SERVICE_0, serviceToDelete);\r\n+\r\n+        CloudControllerClient client = execution.getControllerClient();\r\n+\r\n+        CloudServiceInstance serviceInstance = client.getServiceInstance(serviceToDelete, false);\r\n+        if (serviceInstance == null) {\r\n+            getStepLogger().info(Messages.SERVICE_IS_ALREADY_DELETED, serviceToDelete);\r\n+            return StepPhase.DONE;\r\n+        }\r\n+        StepsUtil.setServicesData(execution.getContext(), buildCloudServiceExtendedList(serviceInstance));\r\n+\r\n+        List<CloudServiceKey> serviceKeys = client.getServiceKeys(serviceInstance.getService());\r\n+\r\n+        if (isDeletePossible(execution.getContext(), serviceInstance.getBindings(), serviceKeys)) {\r\n+            deleteService(execution, serviceInstance, serviceKeys);\r\n+            StepsUtil.setTriggeredServiceOperations(execution.getContext(), MapUtil.asMap(serviceToDelete, ServiceOperation.Type.DELETE));\r\n+            return StepPhase.POLL;\r\n+        }\r\n+\r\n+        getStepLogger().warn(Messages.SERVICE_NOT_BE_DELETED_DUE_TO_SERVICE_BINDINGS_AND_SERVICE_KEYS, serviceToDelete);\r\n+        return StepPhase.DONE;\r\n+\r\n+    }\r\n+\r\n+    @Override\r\n+    protected String getStepErrorMessage(DelegateExecution context) {\r\n+        return Messages.ERROR_DELETING_SERVICES;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected String getStepErrorMessageAdditionalDescription(DelegateExecution context) {\r\n+        String offering = StepsUtil.getServiceOffering(context);\r\n+        return ExceptionMessageTailMapper.map(configuration, CloudComponents.SERVICE_BROKERS, offering);\r\n+    }\r\n+\r\n+    private List<CloudServiceExtended> buildCloudServiceExtendedList(CloudServiceInstance serviceInstanceData) {\r\n+        return Collections.singletonList(buildCloudServiceExtended(serviceInstanceData));\r\n+    }\r\n+\r\n+    private ImmutableCloudServiceExtended buildCloudServiceExtended(CloudServiceInstance service) {\r\n+        return ImmutableCloudServiceExtended.builder()\r\n+                                            .from(service.getService())\r\n+                                            .build();\r\n+    }\r\n+\r\n+    private boolean isDeletePossible(DelegateExecution context, List<CloudServiceBinding> serviceBindings,\r\n+                                     List<CloudServiceKey> serviceKeys) {\r\n+        return hasNoConflictWithServiceBindings(context, serviceBindings) && hasNoConflictWithServiceKeys(context, serviceKeys);\r\n+    }\r\n+\r\n+    private boolean hasNoConflictWithServiceBindings(DelegateExecution context, List<CloudServiceBinding> serviceBindings) {\r\n+        return serviceBindings.isEmpty() || StepsUtil.getServiceActionsToExecute(context)\r\n+                                                     .contains(ServiceAction.RECREATE);\r\n+    }\r\n+\r\n+    private boolean hasNoConflictWithServiceKeys(DelegateExecution context, List<CloudServiceKey> serviceKeys) {\r\n+        return serviceKeys.isEmpty() || StepsUtil.shouldDeleteServiceKeys(context);\r", "originalCommit": "0d34c6dcf7b5f760b8ff7464d6ffd9fde50c51d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQxMzM1NQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r394413355", "bodyText": "Why not just get rid of this method? It is a one-liner anyway.", "author": "valentinEmpy", "createdAt": "2020-03-18T15:01:08Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/DeleteServiceStep.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package com.sap.cloud.lm.sl.cf.process.steps;\r\n+\r\n+import java.util.Collections;\r\n+import java.util.List;\r\n+\r\n+import javax.inject.Inject;\r\n+import javax.inject.Named;\r\n+\r\n+import org.cloudfoundry.client.lib.CloudControllerClient;\r\n+import org.cloudfoundry.client.lib.domain.CloudServiceBinding;\r\n+import org.cloudfoundry.client.lib.domain.CloudServiceInstance;\r\n+import org.cloudfoundry.client.lib.domain.CloudServiceKey;\r\n+import org.flowable.engine.delegate.DelegateExecution;\r\n+import org.springframework.beans.factory.config.BeanDefinition;\r\n+import org.springframework.context.annotation.Scope;\r\n+\r\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.CloudServiceExtended;\r\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.ImmutableCloudServiceExtended;\r\n+import com.sap.cloud.lm.sl.cf.core.model.ServiceOperation;\r\n+import com.sap.cloud.lm.sl.cf.process.Messages;\r\n+import com.sap.cloud.lm.sl.cf.process.analytics.model.ServiceAction;\r\n+import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper;\r\n+import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper.CloudComponents;\r\n+import com.sap.cloud.lm.sl.cf.process.util.ServiceOperationGetter;\r\n+import com.sap.cloud.lm.sl.cf.process.util.ServiceProgressReporter;\r\n+import com.sap.cloud.lm.sl.cf.process.util.ServiceRemover;\r\n+import com.sap.cloud.lm.sl.common.util.MapUtil;\r\n+\r\n+@Named(\"deleteServiceStep\")\r\n+@Scope(BeanDefinition.SCOPE_PROTOTYPE)\r\n+public class DeleteServiceStep extends AsyncFlowableStep {\r\n+\r\n+    private ServiceOperationGetter serviceOperationGetter;\r\n+    private ServiceProgressReporter serviceProgressReporter;\r\n+    private ServiceRemover serviceRemover;\r\n+\r\n+    @Inject\r\n+    public DeleteServiceStep(ServiceOperationGetter serviceOperationGetter, ServiceProgressReporter serviceProgressReporter,\r\n+                             ServiceRemover serviceRemover) {\r\n+        this.serviceOperationGetter = serviceOperationGetter;\r\n+        this.serviceProgressReporter = serviceProgressReporter;\r\n+        this.serviceRemover = serviceRemover;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected StepPhase executeAsyncStep(ExecutionWrapper execution) {\r\n+        String serviceToDelete = StepsUtil.getServiceToDelete(execution.getContext());\r\n+        if (serviceToDelete == null) {\r\n+            getStepLogger().debug(Messages.MISSING_SERVICE_TO_DELETE);\r\n+            return StepPhase.DONE;\r\n+        }\r\n+\r\n+        getStepLogger().debug(Messages.DELETING_DISCONTINUED_SERVICE_0, serviceToDelete);\r\n+\r\n+        CloudControllerClient client = execution.getControllerClient();\r\n+\r\n+        CloudServiceInstance serviceInstance = client.getServiceInstance(serviceToDelete, false);\r\n+        if (serviceInstance == null) {\r\n+            getStepLogger().info(Messages.SERVICE_IS_ALREADY_DELETED, serviceToDelete);\r\n+            return StepPhase.DONE;\r\n+        }\r\n+        StepsUtil.setServicesData(execution.getContext(), buildCloudServiceExtendedList(serviceInstance));\r\n+\r\n+        List<CloudServiceKey> serviceKeys = client.getServiceKeys(serviceInstance.getService());\r\n+\r\n+        if (isDeletePossible(execution.getContext(), serviceInstance.getBindings(), serviceKeys)) {\r\n+            deleteService(execution, serviceInstance, serviceKeys);\r\n+            StepsUtil.setTriggeredServiceOperations(execution.getContext(), MapUtil.asMap(serviceToDelete, ServiceOperation.Type.DELETE));\r\n+            return StepPhase.POLL;\r\n+        }\r\n+\r\n+        getStepLogger().warn(Messages.SERVICE_NOT_BE_DELETED_DUE_TO_SERVICE_BINDINGS_AND_SERVICE_KEYS, serviceToDelete);\r\n+        return StepPhase.DONE;\r\n+\r\n+    }\r\n+\r\n+    @Override\r\n+    protected String getStepErrorMessage(DelegateExecution context) {\r\n+        return Messages.ERROR_DELETING_SERVICES;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected String getStepErrorMessageAdditionalDescription(DelegateExecution context) {\r\n+        String offering = StepsUtil.getServiceOffering(context);\r\n+        return ExceptionMessageTailMapper.map(configuration, CloudComponents.SERVICE_BROKERS, offering);\r\n+    }\r\n+\r\n+    private List<CloudServiceExtended> buildCloudServiceExtendedList(CloudServiceInstance serviceInstanceData) {\r\n+        return Collections.singletonList(buildCloudServiceExtended(serviceInstanceData));\r\n+    }\r\n+\r\n+    private ImmutableCloudServiceExtended buildCloudServiceExtended(CloudServiceInstance service) {\r\n+        return ImmutableCloudServiceExtended.builder()\r\n+                                            .from(service.getService())\r\n+                                            .build();\r\n+    }\r\n+\r\n+    private boolean isDeletePossible(DelegateExecution context, List<CloudServiceBinding> serviceBindings,\r\n+                                     List<CloudServiceKey> serviceKeys) {\r\n+        return hasNoConflictWithServiceBindings(context, serviceBindings) && hasNoConflictWithServiceKeys(context, serviceKeys);\r\n+    }\r\n+\r\n+    private boolean hasNoConflictWithServiceBindings(DelegateExecution context, List<CloudServiceBinding> serviceBindings) {\r\n+        return serviceBindings.isEmpty() || StepsUtil.getServiceActionsToExecute(context)\r\n+                                                     .contains(ServiceAction.RECREATE);\r\n+    }\r\n+\r\n+    private boolean hasNoConflictWithServiceKeys(DelegateExecution context, List<CloudServiceKey> serviceKeys) {\r\n+        return serviceKeys.isEmpty() || StepsUtil.shouldDeleteServiceKeys(context);\r\n+    }\r\n+\r\n+    private void deleteService(ExecutionWrapper execution, CloudServiceInstance serviceInstance, List<CloudServiceKey> serviceKeys) {\r", "originalCommit": "0d34c6dcf7b5f760b8ff7464d6ffd9fde50c51d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQxNTAzMw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r394415033", "bodyText": "As mentioned earlier - I do not understand the suffix 'Data' here. The method just retrieves Service Instances so 'getServices' seems sufficient. What purpose does the 'Data' suffix serve here?\nThis includes variables and methods. Below is another variable and method containing the 'Data' suffix again.", "author": "valentinEmpy", "createdAt": "2020-03-18T15:03:14Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/DeleteServicesStep.java", "diffHunk": "@@ -1,124 +1,232 @@\n-package com.sap.cloud.lm.sl.cf.process.steps;\r\n-\r\n-import java.util.Collections;\r\n-import java.util.List;\r\n-\r\n-import javax.inject.Inject;\r\n-import javax.inject.Named;\r\n-\r\n-import org.cloudfoundry.client.lib.CloudControllerClient;\r\n-import org.cloudfoundry.client.lib.domain.CloudServiceInstance;\r\n-import org.flowable.engine.delegate.DelegateExecution;\r\n-import org.springframework.beans.factory.config.BeanDefinition;\r\n-import org.springframework.context.annotation.Scope;\r\n-\r\n-import com.sap.cloud.lm.sl.cf.client.lib.domain.CloudServiceExtended;\r\n-import com.sap.cloud.lm.sl.cf.client.lib.domain.ImmutableCloudServiceExtended;\r\n-import com.sap.cloud.lm.sl.cf.core.cf.clients.ServiceGetter;\r\n-import com.sap.cloud.lm.sl.cf.core.model.ServiceInstanceWithServiceKeys;\r\n-import com.sap.cloud.lm.sl.cf.core.model.ServiceOperation;\r\n-import com.sap.cloud.lm.sl.cf.process.Messages;\r\n-import com.sap.cloud.lm.sl.cf.process.analytics.model.ServiceAction;\r\n-import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper;\r\n-import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper.CloudComponents;\r\n-import com.sap.cloud.lm.sl.cf.process.util.ServiceOperationGetter;\r\n-import com.sap.cloud.lm.sl.cf.process.util.ServiceProgressReporter;\r\n-import com.sap.cloud.lm.sl.cf.process.util.ServiceRemoval;\r\n-import com.sap.cloud.lm.sl.common.util.MapUtil;\r\n-\r\n-@Named(\"deleteServicesStep\")\r\n-@Scope(BeanDefinition.SCOPE_PROTOTYPE)\r\n-public class DeleteServicesStep extends AsyncFlowableStep {\r\n-\r\n-    private ServiceOperationGetter serviceOperationGetter;\r\n-    private ServiceProgressReporter serviceProgressReporter;\r\n-    private ServiceRemoval serviceRemoval;\r\n-    private ServiceGetter serviceGetter;\r\n-\r\n-    @Inject\r\n-    public DeleteServicesStep(ServiceOperationGetter serviceOperationGetter, ServiceProgressReporter serviceProgressReporter,\r\n-                              ServiceRemoval serviceRemoval, ServiceGetter serviceGetter) {\r\n-        this.serviceOperationGetter = serviceOperationGetter;\r\n-        this.serviceProgressReporter = serviceProgressReporter;\r\n-        this.serviceRemoval = serviceRemoval;\r\n-        this.serviceGetter = serviceGetter;\r\n-    }\r\n-\r\n-    @Override\r\n-    protected StepPhase executeAsyncStep(ExecutionWrapper execution) {\r\n-        String serviceToDelete = StepsUtil.getServiceToDelete(execution.getContext());\r\n-        if (serviceToDelete == null) {\r\n-            getStepLogger().debug(Messages.MISSING_SERVICE_TO_DELETE);\r\n-            return StepPhase.DONE;\r\n-        }\r\n-\r\n-        getStepLogger().debug(Messages.DELETING_DISCONTINUED_SERVICE_0, serviceToDelete);\r\n-\r\n-        CloudControllerClient client = execution.getControllerClient();\r\n-\r\n-        CloudServiceInstance serviceInstanceData = getServiceInstanceData(serviceToDelete, client);\r\n-        if (serviceInstanceData == null) {\r\n-            getStepLogger().info(Messages.SERVICE_IS_ALREADY_DELETED, serviceToDelete);\r\n-            return StepPhase.DONE;\r\n-        }\r\n-        StepsUtil.setServicesData(execution.getContext(), buildCloudServiceExtendedList(serviceInstanceData));\r\n-\r\n-        ServiceInstanceWithServiceKeys serviceInstanceWithServiceKeys = getServiceInstanceWithServiceKeys(client, serviceInstanceData);\r\n-\r\n-        if (isDeletePossible(execution.getContext(), serviceInstanceWithServiceKeys)) {\r\n-            deleteService(execution, serviceInstanceWithServiceKeys);\r\n-            StepsUtil.setTriggeredServiceOperations(execution.getContext(), MapUtil.asMap(serviceToDelete, ServiceOperation.Type.DELETE));\r\n-            return StepPhase.POLL;\r\n-        }\r\n-\r\n-        getStepLogger().warn(Messages.SERVICE_NOT_BE_DELETED_DUE_TO_SERVICE_BINDINGS_AND_SERVICE_KEYS, serviceToDelete);\r\n-        return StepPhase.DONE;\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    protected String getStepErrorMessage(DelegateExecution context) {\r\n-        return Messages.ERROR_DELETING_SERVICES;\r\n-    }\r\n-\r\n-    @Override\r\n-    protected String getStepErrorMessageAdditionalDescription(DelegateExecution context) {\r\n-        String offering = StepsUtil.getServiceOffering(context);\r\n-        return ExceptionMessageTailMapper.map(configuration, CloudComponents.SERVICE_BROKERS, offering);\r\n-    }\r\n-\r\n-    private CloudServiceInstance getServiceInstanceData(String serviceToDelete, CloudControllerClient client) {\r\n-        return client.getServiceInstance(serviceToDelete, false);\r\n-    }\r\n-\r\n-    private List<CloudServiceExtended> buildCloudServiceExtendedList(CloudServiceInstance serviceInstanceData) {\r\n-        return Collections.singletonList(buildCloudServiceExtended(serviceInstanceData));\r\n-    }\r\n-\r\n-    private ImmutableCloudServiceExtended buildCloudServiceExtended(CloudServiceInstance service) {\r\n-        return ImmutableCloudServiceExtended.builder()\r\n-                                            .from(service.getService())\r\n-                                            .build();\r\n-    }\r\n-\r\n-    private ServiceInstanceWithServiceKeys getServiceInstanceWithServiceKeys(CloudControllerClient client,\r\n-                                                                             CloudServiceInstance serviceInstanceData) {\r\n-        return serviceGetter.getServiceInstancesWithServiceKeys(client, serviceInstanceData);\r\n-    }\r\n-\r\n-    private boolean isDeletePossible(DelegateExecution context, ServiceInstanceWithServiceKeys serviceInstanceWithServiceKeys) {\r\n-        return StepsUtil.getServiceActionsToExecute(context)\r\n-                        .contains(ServiceAction.RECREATE)\r\n-            || serviceInstanceWithServiceKeys.hasEmptyAssociations();\r\n-    }\r\n-\r\n-    private void deleteService(ExecutionWrapper execution, ServiceInstanceWithServiceKeys serviceInstanceWithServiceKeys) {\r\n-        serviceRemoval.deleteService(execution, serviceInstanceWithServiceKeys);\r\n-    }\r\n-\r\n-    @Override\r\n-    protected List<AsyncExecution> getAsyncStepExecutions(ExecutionWrapper execution) {\r\n-        return Collections.singletonList(new PollServiceDeleteOperationsExecution(serviceOperationGetter, serviceProgressReporter));\r\n-    }\r\n-\r\n-}\r\n+package com.sap.cloud.lm.sl.cf.process.steps;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.commons.collections4.ListUtils;\n+import org.cloudfoundry.client.lib.CloudControllerClient;\n+import org.cloudfoundry.client.lib.CloudControllerException;\n+import org.cloudfoundry.client.lib.CloudException;\n+import org.cloudfoundry.client.lib.CloudOperationException;\n+import org.cloudfoundry.client.lib.CloudServiceBrokerException;\n+import org.cloudfoundry.client.lib.domain.CloudApplication;\n+import org.cloudfoundry.client.lib.domain.CloudService;\n+import org.cloudfoundry.client.lib.domain.CloudServiceBinding;\n+import org.cloudfoundry.client.lib.domain.CloudServiceInstance;\n+import org.cloudfoundry.client.lib.domain.CloudServiceKey;\n+import org.flowable.engine.delegate.DelegateExecution;\n+import org.springframework.beans.factory.config.BeanDefinition;\n+import org.springframework.context.annotation.Scope;\n+import org.springframework.http.HttpStatus;\n+\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.CloudServiceExtended;\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.ImmutableCloudServiceExtended;\n+import com.sap.cloud.lm.sl.cf.core.model.ServiceOperation;\n+import com.sap.cloud.lm.sl.cf.core.security.serialization.SecureSerializationFacade;\n+import com.sap.cloud.lm.sl.cf.process.Constants;\n+import com.sap.cloud.lm.sl.cf.process.Messages;\n+import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper;\n+import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper.CloudComponents;\n+import com.sap.cloud.lm.sl.cf.process.util.ServiceOperationGetter;\n+import com.sap.cloud.lm.sl.cf.process.util.ServiceProgressReporter;\n+import com.sap.cloud.lm.sl.common.SLException;\n+import com.sap.cloud.lm.sl.common.util.JsonUtil;\n+\n+@Named(\"deleteServicesStep\")\n+@Scope(BeanDefinition.SCOPE_PROTOTYPE)\n+public class DeleteServicesStep extends AsyncFlowableStep {\n+\n+    private final SecureSerializationFacade secureSerializer = new SecureSerializationFacade();\n+\n+    private ServiceOperationGetter serviceOperationGetter;\n+    private ServiceProgressReporter serviceProgressReporter;\n+\n+    @Inject\n+    public DeleteServicesStep(ServiceOperationGetter serviceOperationGetter, ServiceProgressReporter serviceProgressReporter) {\n+        this.serviceOperationGetter = serviceOperationGetter;\n+        this.serviceProgressReporter = serviceProgressReporter;\n+    }\n+\n+    @Override\n+    protected StepPhase executeAsyncStep(ExecutionWrapper execution) {\n+        getStepLogger().debug(Messages.DELETING_SERVICES);\n+\n+        CloudControllerClient client = execution.getControllerClient();\n+\n+        List<String> servicesToDelete = new ArrayList<>(StepsUtil.getServicesToDelete(execution.getContext()));\n+\n+        if (servicesToDelete.isEmpty()) {\n+            getStepLogger().debug(Messages.MISSING_SERVICES_TO_DELETE);\n+            return StepPhase.DONE;\n+        }\n+\n+        List<CloudServiceExtended> servicesData = getServicesData(servicesToDelete, execution);", "originalCommit": "0d34c6dcf7b5f760b8ff7464d6ffd9fde50c51d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQyMDY4Ng==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r394420686", "bodyText": "This class was returned as it is due backward compatability. This class will be removed after the release of these changes. I can rename this method and variable and add comment at the begging that this class will be removed.", "author": "theghost5800", "createdAt": "2020-03-18T15:10:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQxNTAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQyMzQxMw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r394423413", "bodyText": "Perhaps put the @ Deprecated annotation as well and explain why it will be removed", "author": "valentinEmpy", "createdAt": "2020-03-18T15:14:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQxNTAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQxNjI5MQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r394416291", "bodyText": "The old comment still stands.\nThe method name is not very descriptive. Reading it, does not point at what exception message exactly it builds, especially the 'New' keyword. I had to check in the implementation to understand that it builds an error message wen deleting a service.", "author": "valentinEmpy", "createdAt": "2020-03-18T15:04:54Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/DeleteServicesStep.java", "diffHunk": "@@ -1,124 +1,232 @@\n-package com.sap.cloud.lm.sl.cf.process.steps;\r\n-\r\n-import java.util.Collections;\r\n-import java.util.List;\r\n-\r\n-import javax.inject.Inject;\r\n-import javax.inject.Named;\r\n-\r\n-import org.cloudfoundry.client.lib.CloudControllerClient;\r\n-import org.cloudfoundry.client.lib.domain.CloudServiceInstance;\r\n-import org.flowable.engine.delegate.DelegateExecution;\r\n-import org.springframework.beans.factory.config.BeanDefinition;\r\n-import org.springframework.context.annotation.Scope;\r\n-\r\n-import com.sap.cloud.lm.sl.cf.client.lib.domain.CloudServiceExtended;\r\n-import com.sap.cloud.lm.sl.cf.client.lib.domain.ImmutableCloudServiceExtended;\r\n-import com.sap.cloud.lm.sl.cf.core.cf.clients.ServiceGetter;\r\n-import com.sap.cloud.lm.sl.cf.core.model.ServiceInstanceWithServiceKeys;\r\n-import com.sap.cloud.lm.sl.cf.core.model.ServiceOperation;\r\n-import com.sap.cloud.lm.sl.cf.process.Messages;\r\n-import com.sap.cloud.lm.sl.cf.process.analytics.model.ServiceAction;\r\n-import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper;\r\n-import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper.CloudComponents;\r\n-import com.sap.cloud.lm.sl.cf.process.util.ServiceOperationGetter;\r\n-import com.sap.cloud.lm.sl.cf.process.util.ServiceProgressReporter;\r\n-import com.sap.cloud.lm.sl.cf.process.util.ServiceRemoval;\r\n-import com.sap.cloud.lm.sl.common.util.MapUtil;\r\n-\r\n-@Named(\"deleteServicesStep\")\r\n-@Scope(BeanDefinition.SCOPE_PROTOTYPE)\r\n-public class DeleteServicesStep extends AsyncFlowableStep {\r\n-\r\n-    private ServiceOperationGetter serviceOperationGetter;\r\n-    private ServiceProgressReporter serviceProgressReporter;\r\n-    private ServiceRemoval serviceRemoval;\r\n-    private ServiceGetter serviceGetter;\r\n-\r\n-    @Inject\r\n-    public DeleteServicesStep(ServiceOperationGetter serviceOperationGetter, ServiceProgressReporter serviceProgressReporter,\r\n-                              ServiceRemoval serviceRemoval, ServiceGetter serviceGetter) {\r\n-        this.serviceOperationGetter = serviceOperationGetter;\r\n-        this.serviceProgressReporter = serviceProgressReporter;\r\n-        this.serviceRemoval = serviceRemoval;\r\n-        this.serviceGetter = serviceGetter;\r\n-    }\r\n-\r\n-    @Override\r\n-    protected StepPhase executeAsyncStep(ExecutionWrapper execution) {\r\n-        String serviceToDelete = StepsUtil.getServiceToDelete(execution.getContext());\r\n-        if (serviceToDelete == null) {\r\n-            getStepLogger().debug(Messages.MISSING_SERVICE_TO_DELETE);\r\n-            return StepPhase.DONE;\r\n-        }\r\n-\r\n-        getStepLogger().debug(Messages.DELETING_DISCONTINUED_SERVICE_0, serviceToDelete);\r\n-\r\n-        CloudControllerClient client = execution.getControllerClient();\r\n-\r\n-        CloudServiceInstance serviceInstanceData = getServiceInstanceData(serviceToDelete, client);\r\n-        if (serviceInstanceData == null) {\r\n-            getStepLogger().info(Messages.SERVICE_IS_ALREADY_DELETED, serviceToDelete);\r\n-            return StepPhase.DONE;\r\n-        }\r\n-        StepsUtil.setServicesData(execution.getContext(), buildCloudServiceExtendedList(serviceInstanceData));\r\n-\r\n-        ServiceInstanceWithServiceKeys serviceInstanceWithServiceKeys = getServiceInstanceWithServiceKeys(client, serviceInstanceData);\r\n-\r\n-        if (isDeletePossible(execution.getContext(), serviceInstanceWithServiceKeys)) {\r\n-            deleteService(execution, serviceInstanceWithServiceKeys);\r\n-            StepsUtil.setTriggeredServiceOperations(execution.getContext(), MapUtil.asMap(serviceToDelete, ServiceOperation.Type.DELETE));\r\n-            return StepPhase.POLL;\r\n-        }\r\n-\r\n-        getStepLogger().warn(Messages.SERVICE_NOT_BE_DELETED_DUE_TO_SERVICE_BINDINGS_AND_SERVICE_KEYS, serviceToDelete);\r\n-        return StepPhase.DONE;\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    protected String getStepErrorMessage(DelegateExecution context) {\r\n-        return Messages.ERROR_DELETING_SERVICES;\r\n-    }\r\n-\r\n-    @Override\r\n-    protected String getStepErrorMessageAdditionalDescription(DelegateExecution context) {\r\n-        String offering = StepsUtil.getServiceOffering(context);\r\n-        return ExceptionMessageTailMapper.map(configuration, CloudComponents.SERVICE_BROKERS, offering);\r\n-    }\r\n-\r\n-    private CloudServiceInstance getServiceInstanceData(String serviceToDelete, CloudControllerClient client) {\r\n-        return client.getServiceInstance(serviceToDelete, false);\r\n-    }\r\n-\r\n-    private List<CloudServiceExtended> buildCloudServiceExtendedList(CloudServiceInstance serviceInstanceData) {\r\n-        return Collections.singletonList(buildCloudServiceExtended(serviceInstanceData));\r\n-    }\r\n-\r\n-    private ImmutableCloudServiceExtended buildCloudServiceExtended(CloudServiceInstance service) {\r\n-        return ImmutableCloudServiceExtended.builder()\r\n-                                            .from(service.getService())\r\n-                                            .build();\r\n-    }\r\n-\r\n-    private ServiceInstanceWithServiceKeys getServiceInstanceWithServiceKeys(CloudControllerClient client,\r\n-                                                                             CloudServiceInstance serviceInstanceData) {\r\n-        return serviceGetter.getServiceInstancesWithServiceKeys(client, serviceInstanceData);\r\n-    }\r\n-\r\n-    private boolean isDeletePossible(DelegateExecution context, ServiceInstanceWithServiceKeys serviceInstanceWithServiceKeys) {\r\n-        return StepsUtil.getServiceActionsToExecute(context)\r\n-                        .contains(ServiceAction.RECREATE)\r\n-            || serviceInstanceWithServiceKeys.hasEmptyAssociations();\r\n-    }\r\n-\r\n-    private void deleteService(ExecutionWrapper execution, ServiceInstanceWithServiceKeys serviceInstanceWithServiceKeys) {\r\n-        serviceRemoval.deleteService(execution, serviceInstanceWithServiceKeys);\r\n-    }\r\n-\r\n-    @Override\r\n-    protected List<AsyncExecution> getAsyncStepExecutions(ExecutionWrapper execution) {\r\n-        return Collections.singletonList(new PollServiceDeleteOperationsExecution(serviceOperationGetter, serviceProgressReporter));\r\n-    }\r\n-\r\n-}\r\n+package com.sap.cloud.lm.sl.cf.process.steps;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.commons.collections4.ListUtils;\n+import org.cloudfoundry.client.lib.CloudControllerClient;\n+import org.cloudfoundry.client.lib.CloudControllerException;\n+import org.cloudfoundry.client.lib.CloudException;\n+import org.cloudfoundry.client.lib.CloudOperationException;\n+import org.cloudfoundry.client.lib.CloudServiceBrokerException;\n+import org.cloudfoundry.client.lib.domain.CloudApplication;\n+import org.cloudfoundry.client.lib.domain.CloudService;\n+import org.cloudfoundry.client.lib.domain.CloudServiceBinding;\n+import org.cloudfoundry.client.lib.domain.CloudServiceInstance;\n+import org.cloudfoundry.client.lib.domain.CloudServiceKey;\n+import org.flowable.engine.delegate.DelegateExecution;\n+import org.springframework.beans.factory.config.BeanDefinition;\n+import org.springframework.context.annotation.Scope;\n+import org.springframework.http.HttpStatus;\n+\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.CloudServiceExtended;\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.ImmutableCloudServiceExtended;\n+import com.sap.cloud.lm.sl.cf.core.model.ServiceOperation;\n+import com.sap.cloud.lm.sl.cf.core.security.serialization.SecureSerializationFacade;\n+import com.sap.cloud.lm.sl.cf.process.Constants;\n+import com.sap.cloud.lm.sl.cf.process.Messages;\n+import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper;\n+import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper.CloudComponents;\n+import com.sap.cloud.lm.sl.cf.process.util.ServiceOperationGetter;\n+import com.sap.cloud.lm.sl.cf.process.util.ServiceProgressReporter;\n+import com.sap.cloud.lm.sl.common.SLException;\n+import com.sap.cloud.lm.sl.common.util.JsonUtil;\n+\n+@Named(\"deleteServicesStep\")\n+@Scope(BeanDefinition.SCOPE_PROTOTYPE)\n+public class DeleteServicesStep extends AsyncFlowableStep {\n+\n+    private final SecureSerializationFacade secureSerializer = new SecureSerializationFacade();\n+\n+    private ServiceOperationGetter serviceOperationGetter;\n+    private ServiceProgressReporter serviceProgressReporter;\n+\n+    @Inject\n+    public DeleteServicesStep(ServiceOperationGetter serviceOperationGetter, ServiceProgressReporter serviceProgressReporter) {\n+        this.serviceOperationGetter = serviceOperationGetter;\n+        this.serviceProgressReporter = serviceProgressReporter;\n+    }\n+\n+    @Override\n+    protected StepPhase executeAsyncStep(ExecutionWrapper execution) {\n+        getStepLogger().debug(Messages.DELETING_SERVICES);\n+\n+        CloudControllerClient client = execution.getControllerClient();\n+\n+        List<String> servicesToDelete = new ArrayList<>(StepsUtil.getServicesToDelete(execution.getContext()));\n+\n+        if (servicesToDelete.isEmpty()) {\n+            getStepLogger().debug(Messages.MISSING_SERVICES_TO_DELETE);\n+            return StepPhase.DONE;\n+        }\n+\n+        List<CloudServiceExtended> servicesData = getServicesData(servicesToDelete, execution);\n+        List<String> servicesWithoutData = getServicesWithoutData(servicesToDelete, servicesData);\n+        if (!servicesWithoutData.isEmpty()) {\n+            execution.getStepLogger()\n+                     .info(Messages.SERVICES_ARE_ALREADY_DELETED, servicesWithoutData);\n+            servicesToDelete.removeAll(servicesWithoutData);\n+        }\n+        StepsUtil.setServicesData(execution.getContext(), servicesData);\n+\n+        Map<String, ServiceOperation.Type> triggeredServiceOperations = deleteServices(execution.getContext(), client, servicesToDelete);\n+\n+        execution.getStepLogger()\n+                 .debug(Messages.TRIGGERED_SERVICE_OPERATIONS, JsonUtil.toJson(triggeredServiceOperations, true));\n+        StepsUtil.setTriggeredServiceOperations(execution.getContext(), triggeredServiceOperations);\n+\n+        getStepLogger().debug(Messages.SERVICES_DELETED);\n+        return StepPhase.POLL;\n+    }\n+\n+    @Override\n+    protected String getStepErrorMessage(DelegateExecution context) {\n+        return Messages.ERROR_DELETING_SERVICES;\n+    }\n+\n+    @Override\n+    protected String getStepErrorMessageAdditionalDescription(DelegateExecution context) {\n+        String offering = StepsUtil.getServiceOffering(context);\n+        return ExceptionMessageTailMapper.map(configuration, CloudComponents.SERVICE_BROKERS, offering);\n+    }\n+\n+    private List<CloudServiceExtended> getServicesData(List<String> serviceNames, ExecutionWrapper execution) {\n+        CloudControllerClient client = execution.getControllerClient();\n+\n+        return serviceNames.parallelStream()\n+                           .map(name -> client.getService(name, false))\n+                           .filter(Objects::nonNull)\n+                           .map(this::buildCloudServiceExtended)\n+                           .collect(Collectors.toList());\n+    }\n+\n+    private ImmutableCloudServiceExtended buildCloudServiceExtended(CloudService service) {\n+        return ImmutableCloudServiceExtended.builder()\n+                                            .metadata(service.getMetadata())\n+                                            .name(service.getName())\n+                                            .build();\n+    }\n+\n+    private List<String> getServicesWithoutData(List<String> servicesToDelete, List<CloudServiceExtended> servicesData) {\n+        List<String> servicesWithDataNames = servicesData.stream()\n+                                                         .map(CloudServiceExtended::getName)\n+                                                         .collect(Collectors.toList());\n+        return ListUtils.removeAll(servicesToDelete, servicesWithDataNames);\n+    }\n+\n+    private Map<String, ServiceOperation.Type> deleteServices(DelegateExecution context, CloudControllerClient client,\n+                                                              List<String> serviceNames) {\n+        Map<String, ServiceOperation.Type> triggeredServiceOperations = new HashMap<>();\n+\n+        for (String serviceName : serviceNames) {\n+            try {\n+                prepareServicesToDelete(client, serviceName);\n+                deleteService(client, serviceName);\n+                triggeredServiceOperations.put(serviceName, ServiceOperation.Type.DELETE);\n+            } catch (CloudException e) {\n+                processException(context, e, client.getServiceInstance(serviceName), serviceName);\n+            }\n+        }\n+        return triggeredServiceOperations;\n+    }\n+\n+    private void prepareServicesToDelete(CloudControllerClient client, String serviceName) {\n+        unbindService(client, serviceName);\n+        deleteServiceKeys(client, serviceName);\n+    }\n+\n+    private void unbindService(CloudControllerClient client, String serviceName) {\n+        CloudServiceInstance serviceInstance = client.getServiceInstance(serviceName);\n+        List<CloudServiceBinding> bindings = serviceInstance.getBindings();\n+        if (bindings.isEmpty()) {\n+            return;\n+        }\n+        logBindings(bindings);\n+        for (CloudServiceBinding binding : bindings) {\n+            CloudApplication application = StepsUtil.getBoundApplication(client.getApplications(), binding.getApplicationGuid());\n+            if (application == null) {\n+                throw new IllegalStateException(MessageFormat.format(Messages.COULD_NOT_FIND_APPLICATION_WITH_GUID_0,\n+                                                                     binding.getApplicationGuid()));\n+            }\n+            getStepLogger().info(Messages.UNBINDING_SERVICE_FROM_APP, serviceName, application.getName());\n+            client.unbindService(application.getName(), serviceName);\n+        }\n+    }\n+\n+    private void deleteServiceKeys(CloudControllerClient client, String serviceName) {\n+        CloudService service = client.getService(serviceName);\n+        if (service.isUserProvided()) {\n+            return;\n+        }\n+        List<CloudServiceKey> serviceKeys = client.getServiceKeys(serviceName);\n+        for (CloudServiceKey serviceKey : serviceKeys) {\n+            getStepLogger().info(Messages.DELETING_SERVICE_KEY_FOR_SERVICE, serviceKey.getName(), serviceName);\n+            client.deleteServiceKey(serviceName, serviceKey.getName());\n+        }\n+    }\n+\n+    private void deleteService(CloudControllerClient client, String serviceName) {\n+        getStepLogger().info(Messages.DELETING_SERVICE, serviceName);\n+        client.deleteService(serviceName);\n+        getStepLogger().debug(Messages.SERVICE_DELETED, serviceName);\n+    }\n+\n+    private void processException(DelegateExecution context, Exception e, CloudServiceInstance serviceInstance, String serviceName) {\n+        if (e instanceof CloudOperationException) {\n+            e = evaluateCloudOperationException(context, (CloudOperationException) e, serviceName, serviceInstance.getService()\n+                                                                                                                  .getLabel());\n+            if (e == null) {\n+                return;\n+            }\n+        }\n+        wrapAndThrowException(e, serviceInstance, serviceName);\n+    }\n+\n+    private CloudOperationException evaluateCloudOperationException(DelegateExecution context, CloudOperationException e,\n+                                                                    String serviceName, String label) {\n+        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n+            getStepLogger().warn(MessageFormat.format(Messages.COULD_NOT_DELETE_SERVICE, serviceName), e,\n+                                 ExceptionMessageTailMapper.map(configuration, CloudComponents.SERVICE_BROKERS, label));\n+            return null;\n+        }\n+        if (e.getStatusCode() == HttpStatus.BAD_GATEWAY) {\n+            StepsUtil.setServiceOffering(context, Constants.VAR_SERVICE_OFFERING, label);\n+            return new CloudServiceBrokerException(e);\n+        }\n+        return new CloudControllerException(e);\n+\n+    }\n+\n+    private void wrapAndThrowException(Exception e, CloudServiceInstance serviceInstance, String serviceName) {\n+        String msg = buildNewExceptionMessage(e, serviceInstance, serviceName);\n+        throw new SLException(e, msg);\n+    }\n+\n+    private String buildNewExceptionMessage(Exception e, CloudServiceInstance serviceInstance, String serviceName) {", "originalCommit": "0d34c6dcf7b5f760b8ff7464d6ffd9fde50c51d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQxNjUzMw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/799#discussion_r394416533", "bodyText": "Why not just get rid of this method? It is a one-liner anyway.", "author": "valentinEmpy", "createdAt": "2020-03-18T15:05:12Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/DeleteServicesStep.java", "diffHunk": "@@ -1,124 +1,232 @@\n-package com.sap.cloud.lm.sl.cf.process.steps;\r\n-\r\n-import java.util.Collections;\r\n-import java.util.List;\r\n-\r\n-import javax.inject.Inject;\r\n-import javax.inject.Named;\r\n-\r\n-import org.cloudfoundry.client.lib.CloudControllerClient;\r\n-import org.cloudfoundry.client.lib.domain.CloudServiceInstance;\r\n-import org.flowable.engine.delegate.DelegateExecution;\r\n-import org.springframework.beans.factory.config.BeanDefinition;\r\n-import org.springframework.context.annotation.Scope;\r\n-\r\n-import com.sap.cloud.lm.sl.cf.client.lib.domain.CloudServiceExtended;\r\n-import com.sap.cloud.lm.sl.cf.client.lib.domain.ImmutableCloudServiceExtended;\r\n-import com.sap.cloud.lm.sl.cf.core.cf.clients.ServiceGetter;\r\n-import com.sap.cloud.lm.sl.cf.core.model.ServiceInstanceWithServiceKeys;\r\n-import com.sap.cloud.lm.sl.cf.core.model.ServiceOperation;\r\n-import com.sap.cloud.lm.sl.cf.process.Messages;\r\n-import com.sap.cloud.lm.sl.cf.process.analytics.model.ServiceAction;\r\n-import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper;\r\n-import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper.CloudComponents;\r\n-import com.sap.cloud.lm.sl.cf.process.util.ServiceOperationGetter;\r\n-import com.sap.cloud.lm.sl.cf.process.util.ServiceProgressReporter;\r\n-import com.sap.cloud.lm.sl.cf.process.util.ServiceRemoval;\r\n-import com.sap.cloud.lm.sl.common.util.MapUtil;\r\n-\r\n-@Named(\"deleteServicesStep\")\r\n-@Scope(BeanDefinition.SCOPE_PROTOTYPE)\r\n-public class DeleteServicesStep extends AsyncFlowableStep {\r\n-\r\n-    private ServiceOperationGetter serviceOperationGetter;\r\n-    private ServiceProgressReporter serviceProgressReporter;\r\n-    private ServiceRemoval serviceRemoval;\r\n-    private ServiceGetter serviceGetter;\r\n-\r\n-    @Inject\r\n-    public DeleteServicesStep(ServiceOperationGetter serviceOperationGetter, ServiceProgressReporter serviceProgressReporter,\r\n-                              ServiceRemoval serviceRemoval, ServiceGetter serviceGetter) {\r\n-        this.serviceOperationGetter = serviceOperationGetter;\r\n-        this.serviceProgressReporter = serviceProgressReporter;\r\n-        this.serviceRemoval = serviceRemoval;\r\n-        this.serviceGetter = serviceGetter;\r\n-    }\r\n-\r\n-    @Override\r\n-    protected StepPhase executeAsyncStep(ExecutionWrapper execution) {\r\n-        String serviceToDelete = StepsUtil.getServiceToDelete(execution.getContext());\r\n-        if (serviceToDelete == null) {\r\n-            getStepLogger().debug(Messages.MISSING_SERVICE_TO_DELETE);\r\n-            return StepPhase.DONE;\r\n-        }\r\n-\r\n-        getStepLogger().debug(Messages.DELETING_DISCONTINUED_SERVICE_0, serviceToDelete);\r\n-\r\n-        CloudControllerClient client = execution.getControllerClient();\r\n-\r\n-        CloudServiceInstance serviceInstanceData = getServiceInstanceData(serviceToDelete, client);\r\n-        if (serviceInstanceData == null) {\r\n-            getStepLogger().info(Messages.SERVICE_IS_ALREADY_DELETED, serviceToDelete);\r\n-            return StepPhase.DONE;\r\n-        }\r\n-        StepsUtil.setServicesData(execution.getContext(), buildCloudServiceExtendedList(serviceInstanceData));\r\n-\r\n-        ServiceInstanceWithServiceKeys serviceInstanceWithServiceKeys = getServiceInstanceWithServiceKeys(client, serviceInstanceData);\r\n-\r\n-        if (isDeletePossible(execution.getContext(), serviceInstanceWithServiceKeys)) {\r\n-            deleteService(execution, serviceInstanceWithServiceKeys);\r\n-            StepsUtil.setTriggeredServiceOperations(execution.getContext(), MapUtil.asMap(serviceToDelete, ServiceOperation.Type.DELETE));\r\n-            return StepPhase.POLL;\r\n-        }\r\n-\r\n-        getStepLogger().warn(Messages.SERVICE_NOT_BE_DELETED_DUE_TO_SERVICE_BINDINGS_AND_SERVICE_KEYS, serviceToDelete);\r\n-        return StepPhase.DONE;\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    protected String getStepErrorMessage(DelegateExecution context) {\r\n-        return Messages.ERROR_DELETING_SERVICES;\r\n-    }\r\n-\r\n-    @Override\r\n-    protected String getStepErrorMessageAdditionalDescription(DelegateExecution context) {\r\n-        String offering = StepsUtil.getServiceOffering(context);\r\n-        return ExceptionMessageTailMapper.map(configuration, CloudComponents.SERVICE_BROKERS, offering);\r\n-    }\r\n-\r\n-    private CloudServiceInstance getServiceInstanceData(String serviceToDelete, CloudControllerClient client) {\r\n-        return client.getServiceInstance(serviceToDelete, false);\r\n-    }\r\n-\r\n-    private List<CloudServiceExtended> buildCloudServiceExtendedList(CloudServiceInstance serviceInstanceData) {\r\n-        return Collections.singletonList(buildCloudServiceExtended(serviceInstanceData));\r\n-    }\r\n-\r\n-    private ImmutableCloudServiceExtended buildCloudServiceExtended(CloudServiceInstance service) {\r\n-        return ImmutableCloudServiceExtended.builder()\r\n-                                            .from(service.getService())\r\n-                                            .build();\r\n-    }\r\n-\r\n-    private ServiceInstanceWithServiceKeys getServiceInstanceWithServiceKeys(CloudControllerClient client,\r\n-                                                                             CloudServiceInstance serviceInstanceData) {\r\n-        return serviceGetter.getServiceInstancesWithServiceKeys(client, serviceInstanceData);\r\n-    }\r\n-\r\n-    private boolean isDeletePossible(DelegateExecution context, ServiceInstanceWithServiceKeys serviceInstanceWithServiceKeys) {\r\n-        return StepsUtil.getServiceActionsToExecute(context)\r\n-                        .contains(ServiceAction.RECREATE)\r\n-            || serviceInstanceWithServiceKeys.hasEmptyAssociations();\r\n-    }\r\n-\r\n-    private void deleteService(ExecutionWrapper execution, ServiceInstanceWithServiceKeys serviceInstanceWithServiceKeys) {\r\n-        serviceRemoval.deleteService(execution, serviceInstanceWithServiceKeys);\r\n-    }\r\n-\r\n-    @Override\r\n-    protected List<AsyncExecution> getAsyncStepExecutions(ExecutionWrapper execution) {\r\n-        return Collections.singletonList(new PollServiceDeleteOperationsExecution(serviceOperationGetter, serviceProgressReporter));\r\n-    }\r\n-\r\n-}\r\n+package com.sap.cloud.lm.sl.cf.process.steps;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.commons.collections4.ListUtils;\n+import org.cloudfoundry.client.lib.CloudControllerClient;\n+import org.cloudfoundry.client.lib.CloudControllerException;\n+import org.cloudfoundry.client.lib.CloudException;\n+import org.cloudfoundry.client.lib.CloudOperationException;\n+import org.cloudfoundry.client.lib.CloudServiceBrokerException;\n+import org.cloudfoundry.client.lib.domain.CloudApplication;\n+import org.cloudfoundry.client.lib.domain.CloudService;\n+import org.cloudfoundry.client.lib.domain.CloudServiceBinding;\n+import org.cloudfoundry.client.lib.domain.CloudServiceInstance;\n+import org.cloudfoundry.client.lib.domain.CloudServiceKey;\n+import org.flowable.engine.delegate.DelegateExecution;\n+import org.springframework.beans.factory.config.BeanDefinition;\n+import org.springframework.context.annotation.Scope;\n+import org.springframework.http.HttpStatus;\n+\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.CloudServiceExtended;\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.ImmutableCloudServiceExtended;\n+import com.sap.cloud.lm.sl.cf.core.model.ServiceOperation;\n+import com.sap.cloud.lm.sl.cf.core.security.serialization.SecureSerializationFacade;\n+import com.sap.cloud.lm.sl.cf.process.Constants;\n+import com.sap.cloud.lm.sl.cf.process.Messages;\n+import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper;\n+import com.sap.cloud.lm.sl.cf.process.util.ExceptionMessageTailMapper.CloudComponents;\n+import com.sap.cloud.lm.sl.cf.process.util.ServiceOperationGetter;\n+import com.sap.cloud.lm.sl.cf.process.util.ServiceProgressReporter;\n+import com.sap.cloud.lm.sl.common.SLException;\n+import com.sap.cloud.lm.sl.common.util.JsonUtil;\n+\n+@Named(\"deleteServicesStep\")\n+@Scope(BeanDefinition.SCOPE_PROTOTYPE)\n+public class DeleteServicesStep extends AsyncFlowableStep {\n+\n+    private final SecureSerializationFacade secureSerializer = new SecureSerializationFacade();\n+\n+    private ServiceOperationGetter serviceOperationGetter;\n+    private ServiceProgressReporter serviceProgressReporter;\n+\n+    @Inject\n+    public DeleteServicesStep(ServiceOperationGetter serviceOperationGetter, ServiceProgressReporter serviceProgressReporter) {\n+        this.serviceOperationGetter = serviceOperationGetter;\n+        this.serviceProgressReporter = serviceProgressReporter;\n+    }\n+\n+    @Override\n+    protected StepPhase executeAsyncStep(ExecutionWrapper execution) {\n+        getStepLogger().debug(Messages.DELETING_SERVICES);\n+\n+        CloudControllerClient client = execution.getControllerClient();\n+\n+        List<String> servicesToDelete = new ArrayList<>(StepsUtil.getServicesToDelete(execution.getContext()));\n+\n+        if (servicesToDelete.isEmpty()) {\n+            getStepLogger().debug(Messages.MISSING_SERVICES_TO_DELETE);\n+            return StepPhase.DONE;\n+        }\n+\n+        List<CloudServiceExtended> servicesData = getServicesData(servicesToDelete, execution);\n+        List<String> servicesWithoutData = getServicesWithoutData(servicesToDelete, servicesData);\n+        if (!servicesWithoutData.isEmpty()) {\n+            execution.getStepLogger()\n+                     .info(Messages.SERVICES_ARE_ALREADY_DELETED, servicesWithoutData);\n+            servicesToDelete.removeAll(servicesWithoutData);\n+        }\n+        StepsUtil.setServicesData(execution.getContext(), servicesData);\n+\n+        Map<String, ServiceOperation.Type> triggeredServiceOperations = deleteServices(execution.getContext(), client, servicesToDelete);\n+\n+        execution.getStepLogger()\n+                 .debug(Messages.TRIGGERED_SERVICE_OPERATIONS, JsonUtil.toJson(triggeredServiceOperations, true));\n+        StepsUtil.setTriggeredServiceOperations(execution.getContext(), triggeredServiceOperations);\n+\n+        getStepLogger().debug(Messages.SERVICES_DELETED);\n+        return StepPhase.POLL;\n+    }\n+\n+    @Override\n+    protected String getStepErrorMessage(DelegateExecution context) {\n+        return Messages.ERROR_DELETING_SERVICES;\n+    }\n+\n+    @Override\n+    protected String getStepErrorMessageAdditionalDescription(DelegateExecution context) {\n+        String offering = StepsUtil.getServiceOffering(context);\n+        return ExceptionMessageTailMapper.map(configuration, CloudComponents.SERVICE_BROKERS, offering);\n+    }\n+\n+    private List<CloudServiceExtended> getServicesData(List<String> serviceNames, ExecutionWrapper execution) {\n+        CloudControllerClient client = execution.getControllerClient();\n+\n+        return serviceNames.parallelStream()\n+                           .map(name -> client.getService(name, false))\n+                           .filter(Objects::nonNull)\n+                           .map(this::buildCloudServiceExtended)\n+                           .collect(Collectors.toList());\n+    }\n+\n+    private ImmutableCloudServiceExtended buildCloudServiceExtended(CloudService service) {\n+        return ImmutableCloudServiceExtended.builder()\n+                                            .metadata(service.getMetadata())\n+                                            .name(service.getName())\n+                                            .build();\n+    }\n+\n+    private List<String> getServicesWithoutData(List<String> servicesToDelete, List<CloudServiceExtended> servicesData) {\n+        List<String> servicesWithDataNames = servicesData.stream()\n+                                                         .map(CloudServiceExtended::getName)\n+                                                         .collect(Collectors.toList());\n+        return ListUtils.removeAll(servicesToDelete, servicesWithDataNames);\n+    }\n+\n+    private Map<String, ServiceOperation.Type> deleteServices(DelegateExecution context, CloudControllerClient client,\n+                                                              List<String> serviceNames) {\n+        Map<String, ServiceOperation.Type> triggeredServiceOperations = new HashMap<>();\n+\n+        for (String serviceName : serviceNames) {\n+            try {\n+                prepareServicesToDelete(client, serviceName);\n+                deleteService(client, serviceName);\n+                triggeredServiceOperations.put(serviceName, ServiceOperation.Type.DELETE);\n+            } catch (CloudException e) {\n+                processException(context, e, client.getServiceInstance(serviceName), serviceName);\n+            }\n+        }\n+        return triggeredServiceOperations;\n+    }\n+\n+    private void prepareServicesToDelete(CloudControllerClient client, String serviceName) {\n+        unbindService(client, serviceName);\n+        deleteServiceKeys(client, serviceName);\n+    }\n+\n+    private void unbindService(CloudControllerClient client, String serviceName) {\n+        CloudServiceInstance serviceInstance = client.getServiceInstance(serviceName);\n+        List<CloudServiceBinding> bindings = serviceInstance.getBindings();\n+        if (bindings.isEmpty()) {\n+            return;\n+        }\n+        logBindings(bindings);\n+        for (CloudServiceBinding binding : bindings) {\n+            CloudApplication application = StepsUtil.getBoundApplication(client.getApplications(), binding.getApplicationGuid());\n+            if (application == null) {\n+                throw new IllegalStateException(MessageFormat.format(Messages.COULD_NOT_FIND_APPLICATION_WITH_GUID_0,\n+                                                                     binding.getApplicationGuid()));\n+            }\n+            getStepLogger().info(Messages.UNBINDING_SERVICE_FROM_APP, serviceName, application.getName());\n+            client.unbindService(application.getName(), serviceName);\n+        }\n+    }\n+\n+    private void deleteServiceKeys(CloudControllerClient client, String serviceName) {\n+        CloudService service = client.getService(serviceName);\n+        if (service.isUserProvided()) {\n+            return;\n+        }\n+        List<CloudServiceKey> serviceKeys = client.getServiceKeys(serviceName);\n+        for (CloudServiceKey serviceKey : serviceKeys) {\n+            getStepLogger().info(Messages.DELETING_SERVICE_KEY_FOR_SERVICE, serviceKey.getName(), serviceName);\n+            client.deleteServiceKey(serviceName, serviceKey.getName());\n+        }\n+    }\n+\n+    private void deleteService(CloudControllerClient client, String serviceName) {\n+        getStepLogger().info(Messages.DELETING_SERVICE, serviceName);\n+        client.deleteService(serviceName);\n+        getStepLogger().debug(Messages.SERVICE_DELETED, serviceName);\n+    }\n+\n+    private void processException(DelegateExecution context, Exception e, CloudServiceInstance serviceInstance, String serviceName) {\n+        if (e instanceof CloudOperationException) {\n+            e = evaluateCloudOperationException(context, (CloudOperationException) e, serviceName, serviceInstance.getService()\n+                                                                                                                  .getLabel());\n+            if (e == null) {\n+                return;\n+            }\n+        }\n+        wrapAndThrowException(e, serviceInstance, serviceName);\n+    }\n+\n+    private CloudOperationException evaluateCloudOperationException(DelegateExecution context, CloudOperationException e,\n+                                                                    String serviceName, String label) {\n+        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n+            getStepLogger().warn(MessageFormat.format(Messages.COULD_NOT_DELETE_SERVICE, serviceName), e,\n+                                 ExceptionMessageTailMapper.map(configuration, CloudComponents.SERVICE_BROKERS, label));\n+            return null;\n+        }\n+        if (e.getStatusCode() == HttpStatus.BAD_GATEWAY) {\n+            StepsUtil.setServiceOffering(context, Constants.VAR_SERVICE_OFFERING, label);\n+            return new CloudServiceBrokerException(e);\n+        }\n+        return new CloudControllerException(e);\n+\n+    }\n+\n+    private void wrapAndThrowException(Exception e, CloudServiceInstance serviceInstance, String serviceName) {\n+        String msg = buildNewExceptionMessage(e, serviceInstance, serviceName);\n+        throw new SLException(e, msg);\n+    }\n+\n+    private String buildNewExceptionMessage(Exception e, CloudServiceInstance serviceInstance, String serviceName) {\n+        if (serviceInstance == null) {\n+            return MessageFormat.format(Messages.ERROR_DELETING_SERVICE_SHORT, serviceName, e.getMessage());\n+        }\n+        CloudService service = serviceInstance.getService();\n+        return MessageFormat.format(Messages.ERROR_DELETING_SERVICE, service.getName(), service.getLabel(), service.getPlan(),\n+                                    e.getMessage());\n+    }\n+\n+    private void logBindings(List<CloudServiceBinding> bindings) {", "originalCommit": "0d34c6dcf7b5f760b8ff7464d6ffd9fde50c51d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e0fbf5932f0af4a70d416ecd12a20b3634a656e0", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/e0fbf5932f0af4a70d416ecd12a20b3634a656e0", "message": "Refactor Delete Services Step\n\nSkip deletion of service if service instance has service bindings and/or\nservice keys, print warn message to user in such case. Make\ndeleteServiceStep to run in parallel", "committedDate": "2020-03-19T16:24:38Z", "type": "forcePushed"}, {"oid": "cfb699dec7653c54fbf1796105c147820f36993d", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/cfb699dec7653c54fbf1796105c147820f36993d", "message": "Delete unused methods from StepsUtil", "committedDate": "2020-03-20T09:45:04Z", "type": "forcePushed"}, {"oid": "f4d78093216e8c881186da56840c350e2954d233", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/f4d78093216e8c881186da56840c350e2954d233", "message": "Delete ownership validation\n\nDue to complex checks this leads to performance degradation. With this\ndeletion \"--skip-ownership-validation\" parameter is also removed from\nbackend side\n\nJIRA:LMCROSSITXSADEPLOY-1957", "committedDate": "2020-03-23T13:35:47Z", "type": "commit"}, {"oid": "16509a122b6427ca1466450daed4801811617b38", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/16509a122b6427ca1466450daed4801811617b38", "message": "Delete unused methods from StepsUtil", "committedDate": "2020-03-23T17:19:30Z", "type": "forcePushed"}, {"oid": "50c879e6b002331941dfb720ba8e1719c4bb4173", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/50c879e6b002331941dfb720ba8e1719c4bb4173", "message": "Refactor Delete Services Step\n\nSkip deletion of service if service instance has service bindings and/or\nservice keys, print warn message to user in such case. Make\ndeleteServiceStep to run in parallel\n\nJIRA:LMCROSSITXSADEPLOY-1957", "committedDate": "2020-03-24T11:19:49Z", "type": "commit"}, {"oid": "50c879e6b002331941dfb720ba8e1719c4bb4173", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/50c879e6b002331941dfb720ba8e1719c4bb4173", "message": "Refactor Delete Services Step\n\nSkip deletion of service if service instance has service bindings and/or\nservice keys, print warn message to user in such case. Make\ndeleteServiceStep to run in parallel\n\nJIRA:LMCROSSITXSADEPLOY-1957", "committedDate": "2020-03-24T11:19:49Z", "type": "forcePushed"}]}