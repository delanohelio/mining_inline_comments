{"pr_number": 993, "pr_title": "Fix NPE when deleting multiple services", "pr_createdAt": "2020-11-16T10:45:16Z", "pr_url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExODA0MQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993#discussion_r524118041", "bodyText": "Can extract this Math.min... to a new method:\ngetMaxParallelThreads(Collection servicesToHandle) {\nMath.min(servicesToDelete.size(), applicationConfiguration.getServiceHandlingMaxParallelThreads());\n}\nOr even add new method in ForkJoinPoolUtil that handles the collection, or refactor ParallelExecutor to not be so SLP specific", "author": "boyan-velinov", "createdAt": "2020-11-16T10:55:18Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckServicesToDeleteStep.java", "diffHunk": "@@ -15,12 +25,42 @@\n @Scope(BeanDefinition.SCOPE_PROTOTYPE)\n public class CheckServicesToDeleteStep extends CheckForOperationsInProgressStep {\n \n+    @Inject\n+    private ApplicationConfiguration applicationConfiguration;\n+\n     @Override\n-    protected List<CloudServiceInstanceExtended> getServicesToProcess(ProcessContext context) {\n+    protected Set<CloudServiceInstanceExtended> getExistingServicesToProcess(ProcessContext context) {\n         List<String> servicesToDelete = context.getVariable(Variables.SERVICES_TO_DELETE);\n-        return servicesToDelete.stream()\n-                               .map(this::buildCloudServiceExtended)\n-                               .collect(Collectors.toList());\n+        CloudControllerClient client = context.getControllerClient();\n+\n+        int maxParallelThreads = Math.min(servicesToDelete.size(), applicationConfiguration.getServiceHandlingMaxParallelThreads());", "originalCommit": "9452fe8f234b89deebc7f2c600837ad289bceab1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk0Njg1Mw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993#discussion_r524946853", "bodyText": "Instead of using a pair like this, I suggest to create the map of services to service operations first, then do\nmap.values().removeIf(this::isServiceOperationInProgress)\nThis will delete the entry for which the predicate returns true", "author": "radito3", "createdAt": "2020-11-17T07:58:15Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckServicesToDeleteStep.java", "diffHunk": "@@ -15,12 +25,42 @@\n @Scope(BeanDefinition.SCOPE_PROTOTYPE)\n public class CheckServicesToDeleteStep extends CheckForOperationsInProgressStep {\n \n+    @Inject\n+    private ApplicationConfiguration applicationConfiguration;\n+\n     @Override\n-    protected List<CloudServiceInstanceExtended> getServicesToProcess(ProcessContext context) {\n+    protected Set<CloudServiceInstanceExtended> getExistingServicesToProcess(ProcessContext context) {\n         List<String> servicesToDelete = context.getVariable(Variables.SERVICES_TO_DELETE);\n-        return servicesToDelete.stream()\n-                               .map(this::buildCloudServiceExtended)\n-                               .collect(Collectors.toList());\n+        CloudControllerClient client = context.getControllerClient();\n+\n+        int maxParallelThreads = Math.min(servicesToDelete.size(), applicationConfiguration.getServiceHandlingMaxParallelThreads());\n+\n+        return ForkJoinPoolUtil.execute(maxParallelThreads, () ->  getExistingServices(client, servicesToDelete));\n+    }\n+\n+    private Set<CloudServiceInstanceExtended> getExistingServices(CloudControllerClient client, List<String> servicesToDelete) {\n+        return servicesToDelete.parallelStream()\n+                               .map(service -> getExistingService(client, buildCloudServiceExtended(service)))\n+                               .filter(Objects::nonNull)\n+                               .collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    protected Map<CloudServiceInstanceExtended, ServiceOperation>\n+            getServicesInProgressState(ProcessContext context, Set<CloudServiceInstanceExtended> existingServices) {\n+        CloudControllerClient client = context.getControllerClient();\n+        int maxParallelThreads = Math.min(existingServices.size(), applicationConfiguration.getServiceHandlingMaxParallelThreads());\n+\n+        return ForkJoinPoolUtil.execute(maxParallelThreads, () -> getServicesInProgressStateInternal(client, existingServices));\n+    }\n+\n+    private Map<CloudServiceInstanceExtended, ServiceOperation>\n+            getServicesInProgressStateInternal(CloudControllerClient client, Set<CloudServiceInstanceExtended> existingServices) {\n+        return existingServices.parallelStream()", "originalCommit": "9452fe8f234b89deebc7f2c600837ad289bceab1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkxODEzMA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993#discussion_r525918130", "bodyText": "I am not really sure this could happen because a map would require \"collecting\" the parallel stream. However, we need the ServiceOperation object to be be calculated in the stream in order to take advantage of the parallelism.", "author": "radoslav-d", "createdAt": "2020-11-18T09:01:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk0Njg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1NjQ0NA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993#discussion_r525956444", "bodyText": "It will be collected in parallel", "author": "radito3", "createdAt": "2020-11-18T09:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk0Njg1Mw=="}], "type": "inlineReview"}, {"oid": "f503992d84d8cf859236d56b12f5f31517a746fe", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/f503992d84d8cf859236d56b12f5f31517a746fe", "message": "Fix NPE when deleting multiple services\n\nAdd new app configuration for max number of threads for service\nprocessing. Refactor CheckForOperationsInProgressStep to decouple it a\nlittle more from CheckServicesToDeleteStep. Implement parallel calls to\nCC for getting service instances as these calls might take up to 1\nminute when there are a lot of services in the space. Utilize\nForkJoinPoolUtil so that thread number can be specified.\nJIRA: LMCROSSITXSADEPLOY-2217", "committedDate": "2020-11-18T09:03:49Z", "type": "commit"}, {"oid": "f503992d84d8cf859236d56b12f5f31517a746fe", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/f503992d84d8cf859236d56b12f5f31517a746fe", "message": "Fix NPE when deleting multiple services\n\nAdd new app configuration for max number of threads for service\nprocessing. Refactor CheckForOperationsInProgressStep to decouple it a\nlittle more from CheckServicesToDeleteStep. Implement parallel calls to\nCC for getting service instances as these calls might take up to 1\nminute when there are a lot of services in the space. Utilize\nForkJoinPoolUtil so that thread number can be specified.\nJIRA: LMCROSSITXSADEPLOY-2217", "committedDate": "2020-11-18T09:03:49Z", "type": "forcePushed"}, {"oid": "85de9f5d6f39c6cfc33ea7565c032dd250ca5cea", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/85de9f5d6f39c6cfc33ea7565c032dd250ca5cea", "message": "Remove redundant call to CC for service operation status\n\nJIRA: LMCROSSITXSADEPLOY-2217", "committedDate": "2020-11-18T14:32:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjEzNTg0Nw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993#discussion_r526135847", "bodyText": "This is intended, as I want to merge the data from both the cached service object and the one coming from CC.\nThe cached one is CloudServiceInstanceExtended and might have additional information than the one returned from CC (which is only CloudServiceInstance).", "author": "radoslav-d", "createdAt": "2020-11-18T14:36:23Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckForOperationsInProgressStep.java", "diffHunk": "@@ -30,89 +28,60 @@\n public class CheckForOperationsInProgressStep extends AsyncFlowableStep {\n \n     @Inject\n-    private ServiceOperationGetter serviceOperationGetter;\n+    protected ServiceOperationGetter serviceOperationGetter;\n     @Inject\n     private ServiceProgressReporter serviceProgressReporter;\n \n     @Override\n     protected StepPhase executeAsyncStep(ProcessContext context) {\n-        List<CloudServiceInstanceExtended> servicesToProcess = getServicesToProcess(context);\n-\n-        List<CloudServiceInstanceExtended> existingServices = getExistingServices(context.getControllerClient(), servicesToProcess);\n-        if (existingServices.isEmpty()) {\n-            return StepPhase.DONE;\n-        }\n-\n-        Map<CloudServiceInstanceExtended, ServiceOperation> servicesInProgressState = getServicesInProgressState(context, existingServices);\n-        if (servicesInProgressState.isEmpty()) {\n+        List<CloudServiceInstanceExtended> existingServicesInProgress = getExistingServiceInProgress(context);\n+        if (existingServicesInProgress.isEmpty()) {\n             return StepPhase.DONE;\n         }\n \n         getStepLogger().info(Messages.WAITING_PREVIOUS_OPERATIONS_TO_FINISH);\n \n-        Map<String, ServiceOperation.Type> servicesOperationTypes = getServicesOperationTypes(servicesInProgressState);\n+        Map<String, ServiceOperation.Type> servicesOperationTypes = getServicesOperationTypes(existingServicesInProgress);\n         getStepLogger().debug(Messages.SERVICES_IN_PROGRESS, JsonUtil.toJson(servicesOperationTypes, true));\n         context.setVariable(Variables.TRIGGERED_SERVICE_OPERATIONS, servicesOperationTypes);\n \n-        List<CloudServiceInstanceExtended> servicesWithData = getListOfServicesWithData(servicesInProgressState);\n-        context.setVariable(Variables.SERVICES_DATA, servicesWithData);\n+        context.setVariable(Variables.SERVICES_DATA, existingServicesInProgress);\n \n         return StepPhase.POLL;\n     }\n \n-    protected List<CloudServiceInstanceExtended> getServicesToProcess(ProcessContext context) {\n-        return Collections.singletonList(context.getVariable(Variables.SERVICE_TO_PROCESS));\n-    }\n-\n-    private List<CloudServiceInstanceExtended> getExistingServices(CloudControllerClient cloudControllerClient,\n-                                                                   List<CloudServiceInstanceExtended> servicesToProcess) {\n-        return servicesToProcess.parallelStream()\n-                                .map(service -> getExistingService(cloudControllerClient, service))\n-                                .filter(Objects::nonNull)\n-                                .collect(Collectors.toList());\n+    protected List<CloudServiceInstanceExtended> getExistingServiceInProgress(ProcessContext context) {\n+        CloudControllerClient client = context.getControllerClient();\n+        CloudServiceInstanceExtended serviceToProcess = context.getVariable(Variables.SERVICE_TO_PROCESS);\n+        CloudServiceInstanceExtended existingServiceInstance = getExistingService(client, serviceToProcess);\n+        if (existingServiceInstance == null || !isServiceOperationInProgress(existingServiceInstance)) {\n+            return Collections.emptyList();\n+        }\n+        return List.of(existingServiceInstance);\n     }\n \n-    private CloudServiceInstanceExtended getExistingService(CloudControllerClient cloudControllerClient,\n-                                                            CloudServiceInstanceExtended service) {\n+    protected CloudServiceInstanceExtended getExistingService(CloudControllerClient cloudControllerClient,\n+                                                              CloudServiceInstanceExtended service) {\n         CloudServiceInstance existingService = cloudControllerClient.getServiceInstance(service.getName(), false);\n         if (existingService != null) {\n             return ImmutableCloudServiceInstanceExtended.builder()\n                                                         .from(service)\n+                                                        .from(existingService)", "originalCommit": "85de9f5d6f39c6cfc33ea7565c032dd250ca5cea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE2MDc2Nw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993#discussion_r526160767", "bodyText": "Won't the data from service be overwritten with the data from existingService?", "author": "radito3", "createdAt": "2020-11-18T15:08:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjEzNTg0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE2NzUyNQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993#discussion_r526167525", "bodyText": "That is what is intended", "author": "radoslav-d", "createdAt": "2020-11-18T15:16:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjEzNTg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE0OTQzMg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993#discussion_r526149432", "bodyText": "The function should be called getExistingServicesInProgress\nbecause it returns multiple services", "author": "boyan-velinov", "createdAt": "2020-11-18T14:54:12Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckForOperationsInProgressStep.java", "diffHunk": "@@ -30,89 +28,60 @@\n public class CheckForOperationsInProgressStep extends AsyncFlowableStep {\n \n     @Inject\n-    private ServiceOperationGetter serviceOperationGetter;\n+    protected ServiceOperationGetter serviceOperationGetter;\n     @Inject\n     private ServiceProgressReporter serviceProgressReporter;\n \n     @Override\n     protected StepPhase executeAsyncStep(ProcessContext context) {\n-        List<CloudServiceInstanceExtended> servicesToProcess = getServicesToProcess(context);\n-\n-        List<CloudServiceInstanceExtended> existingServices = getExistingServices(context.getControllerClient(), servicesToProcess);\n-        if (existingServices.isEmpty()) {\n-            return StepPhase.DONE;\n-        }\n-\n-        Map<CloudServiceInstanceExtended, ServiceOperation> servicesInProgressState = getServicesInProgressState(context, existingServices);\n-        if (servicesInProgressState.isEmpty()) {\n+        List<CloudServiceInstanceExtended> existingServicesInProgress = getExistingServiceInProgress(context);\n+        if (existingServicesInProgress.isEmpty()) {\n             return StepPhase.DONE;\n         }\n \n         getStepLogger().info(Messages.WAITING_PREVIOUS_OPERATIONS_TO_FINISH);\n \n-        Map<String, ServiceOperation.Type> servicesOperationTypes = getServicesOperationTypes(servicesInProgressState);\n+        Map<String, ServiceOperation.Type> servicesOperationTypes = getServicesOperationTypes(existingServicesInProgress);\n         getStepLogger().debug(Messages.SERVICES_IN_PROGRESS, JsonUtil.toJson(servicesOperationTypes, true));\n         context.setVariable(Variables.TRIGGERED_SERVICE_OPERATIONS, servicesOperationTypes);\n \n-        List<CloudServiceInstanceExtended> servicesWithData = getListOfServicesWithData(servicesInProgressState);\n-        context.setVariable(Variables.SERVICES_DATA, servicesWithData);\n+        context.setVariable(Variables.SERVICES_DATA, existingServicesInProgress);\n \n         return StepPhase.POLL;\n     }\n \n-    protected List<CloudServiceInstanceExtended> getServicesToProcess(ProcessContext context) {\n-        return Collections.singletonList(context.getVariable(Variables.SERVICE_TO_PROCESS));\n-    }\n-\n-    private List<CloudServiceInstanceExtended> getExistingServices(CloudControllerClient cloudControllerClient,\n-                                                                   List<CloudServiceInstanceExtended> servicesToProcess) {\n-        return servicesToProcess.parallelStream()\n-                                .map(service -> getExistingService(cloudControllerClient, service))\n-                                .filter(Objects::nonNull)\n-                                .collect(Collectors.toList());\n+    protected List<CloudServiceInstanceExtended> getExistingServiceInProgress(ProcessContext context) {", "originalCommit": "85de9f5d6f39c6cfc33ea7565c032dd250ca5cea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE2MjE3NQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993#discussion_r526162175", "bodyText": "Either this name or doGetExistingServicesInProgress. Both are good but since the name is already long, why make it longer :D", "author": "radito3", "createdAt": "2020-11-18T15:09:50Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckServicesToDeleteStep.java", "diffHunk": "@@ -30,35 +26,19 @@\n     private ApplicationConfiguration applicationConfiguration;\n \n     @Override\n-    protected Set<CloudServiceInstanceExtended> getExistingServicesToProcess(ProcessContext context) {\n+    protected List<CloudServiceInstanceExtended> getExistingServiceInProgress(ProcessContext context) {\n         List<String> servicesToDelete = context.getVariable(Variables.SERVICES_TO_DELETE);\n         CloudControllerClient client = context.getControllerClient();\n         int maxParallelThreads = getMaxParallelThreads(servicesToDelete);\n-        return ForkJoinPoolUtil.execute(maxParallelThreads, () ->  getExistingServices(client, servicesToDelete));\n+        return ForkJoinPoolUtil.execute(maxParallelThreads, () ->  getExistingServicesInProgressInternal(client, servicesToDelete));", "originalCommit": "85de9f5d6f39c6cfc33ea7565c032dd250ca5cea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "957f0d4df21def2f2ef880bb5b916b78ca312807", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/957f0d4df21def2f2ef880bb5b916b78ca312807", "message": "Refactor steps for better maintenance\n\nJIRA: LMCROSSITXSADEPLOY-2217", "committedDate": "2020-11-19T08:44:14Z", "type": "commit"}, {"oid": "957f0d4df21def2f2ef880bb5b916b78ca312807", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/957f0d4df21def2f2ef880bb5b916b78ca312807", "message": "Refactor steps for better maintenance\n\nJIRA: LMCROSSITXSADEPLOY-2217", "committedDate": "2020-11-19T08:44:14Z", "type": "forcePushed"}]}