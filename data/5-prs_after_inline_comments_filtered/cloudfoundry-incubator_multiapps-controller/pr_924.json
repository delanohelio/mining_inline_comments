{"pr_number": 924, "pr_title": "Fix inaccurate calculation of delay between steps", "pr_createdAt": "2020-08-07T14:12:12Z", "pr_url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc1NzAwNw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r467757007", "bodyText": "This message is a bit hard to read. I suggest:\nTime statistics for process \\\"{0}\\\" (part of operation \\\"{1}\\\"): duration \\\"{2}\\\" ms; delay between steps \\\"{3}\\\" ms\"", "author": "nictas", "createdAt": "2020-08-10T08:30:24Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/Messages.java", "diffHunk": "@@ -532,6 +532,9 @@\n     public static final String PACKAGE_STATUS_0_IS_IN_STATE_1 = \"Package status: \\\"{0}\\\" is in state: \\\"{1}\\\"\";\n     public static final String UPLOADED_PACKAGE_0 = \"Uploaded package: \\\"{0}\\\"\";\n     public static final String VERIFYING_APPLICATION_0_EXISTS = \"Verifying application: \\\"{0}\\\" exists\";\n+    public static final String PROCESS_TIME_FOR_OPERATION_0_PROCESS_1_DURATION_2_DELAY_3 = \"Process time for operation with id \\\"{0}\\\", process instance with id \\\"{1}\\\", process duration \\\"{2}\\\"ms, delay between steps \\\"{3}\\\"ms\";", "originalCommit": "090a5b1e434fe2e94b507d5089e741b72bcbfaa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM2MTcyNg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r471361726", "bodyText": "Done", "author": "radito3", "createdAt": "2020-08-17T09:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc1NzAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc1ODQzNw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r467758437", "bodyText": "Same. I suggest:\nTime statistics for operation \\\"{0}\\\": duration \\\"{1}\\\" ms; delay between steps \\\"{2}\\\" ms\"", "author": "nictas", "createdAt": "2020-08-10T08:33:09Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/Messages.java", "diffHunk": "@@ -532,6 +532,9 @@\n     public static final String PACKAGE_STATUS_0_IS_IN_STATE_1 = \"Package status: \\\"{0}\\\" is in state: \\\"{1}\\\"\";\n     public static final String UPLOADED_PACKAGE_0 = \"Uploaded package: \\\"{0}\\\"\";\n     public static final String VERIFYING_APPLICATION_0_EXISTS = \"Verifying application: \\\"{0}\\\" exists\";\n+    public static final String PROCESS_TIME_FOR_OPERATION_0_PROCESS_1_DURATION_2_DELAY_3 = \"Process time for operation with id \\\"{0}\\\", process instance with id \\\"{1}\\\", process duration \\\"{2}\\\"ms, delay between steps \\\"{3}\\\"ms\";\n+    public static final String PROCESS_TIME_FOR_OPERATION_0_DURATION_1_DELAY_2 = \"Process time for operation with id \\\"{0}\\\", operation duration \\\"{1}\\\"ms, delay between steps \\\"{2}\\\"ms\";", "originalCommit": "090a5b1e434fe2e94b507d5089e741b72bcbfaa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM2MTc3NA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r471361774", "bodyText": "Done", "author": "radito3", "createdAt": "2020-08-17T09:40:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc1ODQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2MjQ3OQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r467762479", "bodyText": "Here we're storing only clients that can be associated with some Flowable process. That's because there's a Flowable listener that removes them from this cache when the process finishes, but there's no such thing for clients that are created in our REST controllers. Theoretically, if the cache wasn't memory-sensitive they would stay in it forever, which would eventually cause an OOM error. Your change makes it so that every client is stored. This would work thanks to the memory-sensitivity, but it would still be less optimal than what we have currently, so I don't think this refactoring is a good idea.", "author": "nictas", "createdAt": "2020-08-10T08:41:49Z", "path": "multiapps-controller-core/src/main/java/org/cloudfoundry/multiapps/controller/core/cf/CloudControllerClientProvider.java", "diffHunk": "@@ -126,33 +108,16 @@ private OAuth2AccessToken getValidToken(String userName) {\n     }\n \n     private CloudControllerClient getClientFromCache(String userName, String org, String space) {\n-        return getClientFromCache(userName, org, space, null);\n-    }\n-\n-    private CloudControllerClient getClientFromCache(String userName, String org, String space, String processId) {\n-        // Get a client from the cache or create a new one if needed\n         String key = getKey(userName, org, space);\n-        CloudControllerClient client = clients.get(key);\n-        if (client == null) {\n-            client = clientFactory.createClient(getValidToken(userName), org, space);\n-            if (processId != null) {", "originalCommit": "090a5b1e434fe2e94b507d5089e741b72bcbfaa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM1NjE1NQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r471356155", "bodyText": "Reverted", "author": "radito3", "createdAt": "2020-08-17T09:30:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2MjQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2NDAyNw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r467764027", "bodyText": "The name of the method doesn't really fit with its return value IMO. Maybe it should be called collectProcessTimes? Consider renaming the entire class as well.", "author": "nictas", "createdAt": "2020-08-10T08:45:01Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/util/OperationTimeAggregator.java", "diffHunk": "@@ -9,52 +10,53 @@\n import javax.inject.Named;\n \n import org.cloudfoundry.multiapps.controller.process.flowable.FlowableFacade;\n-import org.cloudfoundry.multiapps.controller.process.util.ProcessTimeCalculator.ProcessTime;\n-import org.cloudfoundry.multiapps.controller.process.util.ProcessTimeCalculator.ProcessTimeLogger;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n @Named\n public class OperationTimeAggregator {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(OperationTimeAggregator.class);\n-\n-    private ProcessTimeCalculator processTimeCalculator;\n-    private FlowableFacade flowableFacade;\n+    private final ProcessTimeCalculator processTimeCalculator;\n+    private final FlowableFacade flowableFacade;\n \n     @Inject\n     public OperationTimeAggregator(FlowableFacade flowableFacade) {\n         this.flowableFacade = flowableFacade;\n         this.processTimeCalculator = new ProcessTimeCalculator(flowableFacade);\n     }\n \n-    public void aggregateOperationTime(String correlationId) {\n+    public Map<String, ProcessTime> aggregateOperationTime(String correlationId) {", "originalCommit": "090a5b1e434fe2e94b507d5089e741b72bcbfaa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM4NDg5MQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r471384891", "bodyText": "Renamed to collectProcessTimes", "author": "radito3", "createdAt": "2020-08-17T10:24:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2NDAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc5NDE1Mw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r467794153", "bodyText": "I agree. :D", "author": "nictas", "createdAt": "2020-08-10T09:44:44Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/util/OperationTimeAggregator.java", "diffHunk": "@@ -9,52 +10,53 @@\n import javax.inject.Named;\n \n import org.cloudfoundry.multiapps.controller.process.flowable.FlowableFacade;\n-import org.cloudfoundry.multiapps.controller.process.util.ProcessTimeCalculator.ProcessTime;\n-import org.cloudfoundry.multiapps.controller.process.util.ProcessTimeCalculator.ProcessTimeLogger;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n @Named\n public class OperationTimeAggregator {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(OperationTimeAggregator.class);\n-\n-    private ProcessTimeCalculator processTimeCalculator;\n-    private FlowableFacade flowableFacade;\n+    private final ProcessTimeCalculator processTimeCalculator;\n+    private final FlowableFacade flowableFacade;\n \n     @Inject\n     public OperationTimeAggregator(FlowableFacade flowableFacade) {\n         this.flowableFacade = flowableFacade;\n         this.processTimeCalculator = new ProcessTimeCalculator(flowableFacade);\n     }\n \n-    public void aggregateOperationTime(String correlationId) {\n+    public Map<String, ProcessTime> aggregateOperationTime(String correlationId) {\n         List<String> historicSubProcesses = flowableFacade.getHistoricSubProcessIds(correlationId);\n         historicSubProcesses.add(correlationId);\n \n-        Map<String, ProcessTime> processTimesForSubProcesses = historicSubProcesses.stream()\n-                                                                                   .collect(Collectors.toMap(processId -> processId,\n-                                                                                                             processTimeCalculator::calculate));\n-        processTimesForSubProcesses.forEach((key, value) -> logProcessTimeIndividually(value, correlationId,\n-                key));\n-\n-        ProcessTime rootProcessTime = processTimesForSubProcesses.get(correlationId);\n-        logOverallProcesstime(correlationId, rootProcessTime, processTimesForSubProcesses.values());\n+        return historicSubProcesses.stream()\n+                                   .collect(Collectors.toMap(processId -> processId, processTimeCalculator::calculate));\n     }\n \n-    private void logProcessTimeIndividually(ProcessTime processTime, String correlationId, String processInstanceId) {\n-        ProcessTimeLogger.logProcessTimeIndividually(LOGGER, processTime, correlationId, processInstanceId);\n-    }\n+    public ProcessTime computeOverallProcessTime(String correlationId, Map<String, ProcessTime> processTimes) {\n+        //may not be the best idea if this changes the input parameter", "originalCommit": "090a5b1e434fe2e94b507d5089e741b72bcbfaa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ3OTM1MA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r471479350", "bodyText": "Changed", "author": "radito3", "createdAt": "2020-08-17T13:30:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc5NDE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc5NzcwOQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r467797709", "bodyText": "What if you have a call activity within a call activity (no parallel BS)? The end time of the sub process started by the first call activity will be after the start time of the sub process started by the inner call activity. This method will return true, but that will be incorrect.", "author": "nictas", "createdAt": "2020-08-10T09:52:06Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/util/OperationTimeAggregator.java", "diffHunk": "@@ -9,52 +10,53 @@\n import javax.inject.Named;\n \n import org.cloudfoundry.multiapps.controller.process.flowable.FlowableFacade;\n-import org.cloudfoundry.multiapps.controller.process.util.ProcessTimeCalculator.ProcessTime;\n-import org.cloudfoundry.multiapps.controller.process.util.ProcessTimeCalculator.ProcessTimeLogger;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n @Named\n public class OperationTimeAggregator {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(OperationTimeAggregator.class);\n-\n-    private ProcessTimeCalculator processTimeCalculator;\n-    private FlowableFacade flowableFacade;\n+    private final ProcessTimeCalculator processTimeCalculator;\n+    private final FlowableFacade flowableFacade;\n \n     @Inject\n     public OperationTimeAggregator(FlowableFacade flowableFacade) {\n         this.flowableFacade = flowableFacade;\n         this.processTimeCalculator = new ProcessTimeCalculator(flowableFacade);\n     }\n \n-    public void aggregateOperationTime(String correlationId) {\n+    public Map<String, ProcessTime> aggregateOperationTime(String correlationId) {\n         List<String> historicSubProcesses = flowableFacade.getHistoricSubProcessIds(correlationId);\n         historicSubProcesses.add(correlationId);\n \n-        Map<String, ProcessTime> processTimesForSubProcesses = historicSubProcesses.stream()\n-                                                                                   .collect(Collectors.toMap(processId -> processId,\n-                                                                                                             processTimeCalculator::calculate));\n-        processTimesForSubProcesses.forEach((key, value) -> logProcessTimeIndividually(value, correlationId,\n-                key));\n-\n-        ProcessTime rootProcessTime = processTimesForSubProcesses.get(correlationId);\n-        logOverallProcesstime(correlationId, rootProcessTime, processTimesForSubProcesses.values());\n+        return historicSubProcesses.stream()\n+                                   .collect(Collectors.toMap(processId -> processId, processTimeCalculator::calculate));\n     }\n \n-    private void logProcessTimeIndividually(ProcessTime processTime, String correlationId, String processInstanceId) {\n-        ProcessTimeLogger.logProcessTimeIndividually(LOGGER, processTime, correlationId, processInstanceId);\n-    }\n+    public ProcessTime computeOverallProcessTime(String correlationId, Map<String, ProcessTime> processTimes) {\n+        //may not be the best idea if this changes the input parameter\n+        ProcessTime rootProcessTime = processTimes.remove(correlationId);\n \n-    private void logOverallProcesstime(String correlationId, ProcessTime rootProcessTime,\n-                                       Collection<ProcessTime> subProcessesProcessTimes) {\n-        long overallDelayBetweenSteps = subProcessesProcessTimes.stream()\n-                                                                .mapToLong(ProcessTime::getDelayBetweenSteps)\n-                                                                .sum();\n-        ProcessTime overallProcessTime = ImmutableProcessTime.copyOf(rootProcessTime)\n-                                                             .withDelayBetweenSteps(rootProcessTime.getDelayBetweenSteps()\n-                                                                 + overallDelayBetweenSteps);\n+        long overallDelayBetweenSteps = processTimes.values()\n+                                                    .stream()\n+                                                    .mapToLong(ProcessTime::getDelayBetweenSteps)\n+                                                    .sum();\n+\n+        return ImmutableProcessTime.copyOf(rootProcessTime)\n+                                   .withDelayBetweenSteps(rootProcessTime.getDelayBetweenSteps() + overallDelayBetweenSteps);\n+    }\n \n-        ProcessTimeLogger.logOverallProcessTime(LOGGER, overallProcessTime, correlationId);\n+    public boolean hasParallelSubProcesses(Map<String, ProcessTime> subProcessTimes) {\n+        ProcessTime[] processTimes = subProcessTimes.values()\n+                                                    .toArray(new ProcessTime[0]);\n+        Arrays.sort(processTimes, Comparator.comparing(ProcessTime::getStartTime));\n+\n+        for (int i = 0; i < processTimes.length - 1; i++) {\n+            for (int j = i + 1; j < processTimes.length; j++) {\n+                if (processTimes[i].getEndTime()", "originalCommit": "090a5b1e434fe2e94b507d5089e741b72bcbfaa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM2ODIwMw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r471368203", "bodyText": "That won't be problem because the process times operated on here are only the sub processes of the process on which we are calculating the delay. The parent process is absent in this array.", "author": "radito3", "createdAt": "2020-08-17T09:52:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc5NzcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc5ODEyMw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r467798123", "bodyText": "Is this actually serialized anywhere? If not, then you don't need these Jackson annotations.", "author": "nictas", "createdAt": "2020-08-10T09:52:54Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/util/ProcessTime.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package org.cloudfoundry.multiapps.controller.process.util;\n+\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import org.immutables.value.Value;\n+\n+import java.util.Date;\n+\n+@Value.Immutable\n+@JsonSerialize(as = ImmutableProcessTime.class)", "originalCommit": "090a5b1e434fe2e94b507d5089e741b72bcbfaa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM2NjA4OA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r471366088", "bodyText": "Removed", "author": "radito3", "createdAt": "2020-08-17T09:48:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc5ODEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc5OTgyMA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r467799820", "bodyText": "Why not when(flowableFacade.getHistoricProcessById(CORRELATION_ID)).thenReturn(createProcess())? It would be consistent with the line above.", "author": "nictas", "createdAt": "2020-08-10T09:56:15Z", "path": "multiapps-controller-process/src/test/java/org/cloudfoundry/multiapps/controller/process/util/OperationTimeAggregatorTest.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.cloudfoundry.multiapps.controller.process.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.when;\n+\n+import org.cloudfoundry.multiapps.controller.process.flowable.FlowableFacade;\n+import org.flowable.engine.HistoryService;\n+import org.flowable.engine.ProcessEngine;\n+import org.flowable.engine.history.HistoricActivityInstance;\n+import org.flowable.engine.history.HistoricActivityInstanceQuery;\n+import org.flowable.engine.history.HistoricProcessInstance;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class OperationTimeAggregatorTest {\n+\n+    private static final String CORRELATION_ID = \"id\";\n+\n+    @Mock\n+    private FlowableFacade flowableFacade;\n+    @InjectMocks\n+    private OperationTimeAggregator operationTimeAggregator;\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @Test\n+    void testOperationTimeWithNoSubProcesses() {\n+        //maybe split this test into multiple?\n+        when(flowableFacade.getHistoricSubProcessIds(CORRELATION_ID)).thenReturn(new ArrayList<>());\n+        doReturn(createProcess()).when(flowableFacade).getHistoricProcessById(CORRELATION_ID);", "originalCommit": "090a5b1e434fe2e94b507d5089e741b72bcbfaa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDAwMw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r473230003", "bodyText": "I was having issues with Mockito, \"unfinished stubbing exception\", that's why I did this but it's fixed now", "author": "radito3", "createdAt": "2020-08-19T18:14:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc5OTgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgwMDYzMw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r467800633", "bodyText": "Here you're using Mockito.when, but above you're using the static import. Use one or the other, but not both. Personally I prefer the one without the static import.", "author": "nictas", "createdAt": "2020-08-10T09:57:50Z", "path": "multiapps-controller-process/src/test/java/org/cloudfoundry/multiapps/controller/process/util/OperationTimeAggregatorTest.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.cloudfoundry.multiapps.controller.process.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.when;\n+\n+import org.cloudfoundry.multiapps.controller.process.flowable.FlowableFacade;\n+import org.flowable.engine.HistoryService;\n+import org.flowable.engine.ProcessEngine;\n+import org.flowable.engine.history.HistoricActivityInstance;\n+import org.flowable.engine.history.HistoricActivityInstanceQuery;\n+import org.flowable.engine.history.HistoricProcessInstance;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class OperationTimeAggregatorTest {\n+\n+    private static final String CORRELATION_ID = \"id\";\n+\n+    @Mock\n+    private FlowableFacade flowableFacade;\n+    @InjectMocks\n+    private OperationTimeAggregator operationTimeAggregator;\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @Test\n+    void testOperationTimeWithNoSubProcesses() {\n+        //maybe split this test into multiple?\n+        when(flowableFacade.getHistoricSubProcessIds(CORRELATION_ID)).thenReturn(new ArrayList<>());\n+        doReturn(createProcess()).when(flowableFacade).getHistoricProcessById(CORRELATION_ID);\n+\n+        ProcessEngine processEngine = Mockito.mock(ProcessEngine.class);\n+        Mockito.when(flowableFacade.getProcessEngine())", "originalCommit": "090a5b1e434fe2e94b507d5089e741b72bcbfaa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDE2Nw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r473230167", "bodyText": "Done", "author": "radito3", "createdAt": "2020-08-19T18:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgwMDYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgxNDkxMg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r467814912", "bodyText": "Use Mockito.when instead of doReturn.", "author": "nictas", "createdAt": "2020-08-10T10:28:50Z", "path": "multiapps-controller-process/src/test/java/org/cloudfoundry/multiapps/controller/process/util/OperationTimeAggregatorTest.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.cloudfoundry.multiapps.controller.process.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.when;\n+\n+import org.cloudfoundry.multiapps.controller.process.flowable.FlowableFacade;\n+import org.flowable.engine.HistoryService;\n+import org.flowable.engine.ProcessEngine;\n+import org.flowable.engine.history.HistoricActivityInstance;\n+import org.flowable.engine.history.HistoricActivityInstanceQuery;\n+import org.flowable.engine.history.HistoricProcessInstance;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class OperationTimeAggregatorTest {\n+\n+    private static final String CORRELATION_ID = \"id\";\n+\n+    @Mock\n+    private FlowableFacade flowableFacade;\n+    @InjectMocks\n+    private OperationTimeAggregator operationTimeAggregator;\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @Test\n+    void testOperationTimeWithNoSubProcesses() {\n+        //maybe split this test into multiple?\n+        when(flowableFacade.getHistoricSubProcessIds(CORRELATION_ID)).thenReturn(new ArrayList<>());\n+        doReturn(createProcess()).when(flowableFacade).getHistoricProcessById(CORRELATION_ID);\n+\n+        ProcessEngine processEngine = Mockito.mock(ProcessEngine.class);\n+        Mockito.when(flowableFacade.getProcessEngine())\n+               .thenReturn(processEngine);\n+        HistoryService historyServiceMock = Mockito.mock(HistoryService.class);\n+        Mockito.when(processEngine.getHistoryService())\n+               .thenReturn(historyServiceMock);\n+        HistoricActivityInstanceQuery historicActivityInstanceQueryMock = Mockito.mock(HistoricActivityInstanceQuery.class);\n+        Mockito.when(historyServiceMock.createHistoricActivityInstanceQuery())\n+               .thenReturn(historicActivityInstanceQueryMock);\n+        Mockito.when(historicActivityInstanceQueryMock.processInstanceId(CORRELATION_ID))\n+               .thenReturn(historicActivityInstanceQueryMock);\n+        doReturn(mockProcessActivities(\"serviceTask\", 2, 100))", "originalCommit": "090a5b1e434fe2e94b507d5089e741b72bcbfaa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDIxOA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r473230218", "bodyText": "Done", "author": "radito3", "createdAt": "2020-08-19T18:15:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgxNDkxMg=="}], "type": "inlineReview"}, {"oid": "0b868e33fa54794ed82cd578744ecfd6e6883aa3", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/0b868e33fa54794ed82cd578744ecfd6e6883aa3", "message": "Fix inaccurate calculation of delay between steps\n\nLMCROSSITXSADEPLOY-2135", "committedDate": "2020-08-17T09:30:42Z", "type": "forcePushed"}, {"oid": "1cee5dd32e1daa7fdc793ffbcecaeedb6a273fc5", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/1cee5dd32e1daa7fdc793ffbcecaeedb6a273fc5", "message": "Fix inaccurate calculation of delay between steps\n\nLMCROSSITXSADEPLOY-2135", "committedDate": "2020-08-17T09:49:46Z", "type": "forcePushed"}, {"oid": "f4ffc7e30734b16f43255a94510942bfd6515cf2", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/f4ffc7e30734b16f43255a94510942bfd6515cf2", "message": "Fix inaccurate calculation of delay between steps\n\nLMCROSSITXSADEPLOY-2135", "committedDate": "2020-08-17T09:58:35Z", "type": "forcePushed"}, {"oid": "dfe99897d47702fa980930d2269f9a963c52cf3b", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/dfe99897d47702fa980930d2269f9a963c52cf3b", "message": "Fix inaccurate calculation of delay between steps\n\nLMCROSSITXSADEPLOY-2135", "committedDate": "2020-08-17T10:06:41Z", "type": "forcePushed"}, {"oid": "ab9f5fb8d2989954ee175201bdc93c45dcbc1ee4", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/ab9f5fb8d2989954ee175201bdc93c45dcbc1ee4", "message": "Fix inaccurate calculation of delay between steps\n\nLMCROSSITXSADEPLOY-2135", "committedDate": "2020-08-18T13:20:59Z", "type": "forcePushed"}, {"oid": "81fe818bfd41a59b4d6746669f235915dc1da695", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/81fe818bfd41a59b4d6746669f235915dc1da695", "message": "Fix inaccurate calculation of delay between steps\n\nLMCROSSITXSADEPLOY-2135", "committedDate": "2020-08-20T13:42:21Z", "type": "forcePushed"}, {"oid": "9d06b5a33cc6e42b75ebd7942a31166e75c63df3", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/9d06b5a33cc6e42b75ebd7942a31166e75c63df3", "message": "Fix inaccurate calculation of delay between steps\n\nLMCROSSITXSADEPLOY-2135", "committedDate": "2020-08-24T08:09:55Z", "type": "forcePushed"}, {"oid": "76c434b61d13a1297c6cd910d6cedf9bbdcb1f31", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/76c434b61d13a1297c6cd910d6cedf9bbdcb1f31", "message": "Fix inaccurate calculation of delay between steps\n\nLMCROSSITXSADEPLOY-2135", "committedDate": "2020-08-24T11:44:04Z", "type": "forcePushed"}, {"oid": "6f2a4aeaa3353b6155f6f3752ca5ea9dfc7380be", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/6f2a4aeaa3353b6155f6f3752ca5ea9dfc7380be", "message": "Fix inaccurate calculation of delay between steps\n\nLMCROSSITXSADEPLOY-2135", "committedDate": "2020-08-24T12:05:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMyODE0MQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r476328141", "bodyText": "Exception message does not match with passed variable. The message is related with space_id but passed argument is orgName.", "author": "theghost5800", "createdAt": "2020-08-25T09:56:39Z", "path": "multiapps-controller-core/src/main/java/org/cloudfoundry/multiapps/controller/core/cf/CloudControllerClientProvider.java", "diffHunk": "@@ -49,15 +49,15 @@ public CloudControllerClient getControllerClient(String userName, String org, St\n      * one.\n      *\n      * @param userName the user name associated with the client\n-     * @param spaceGuid the space guid associated with the client\n-     * @param processId the processId associated with the client\n+     * @param orgName the organization name associated with the client\n+     * @param spaceName the space name associated with the client\n      * @return a CF client for the specified access token, organization, and space\n      */\n-    public CloudControllerClient getControllerClient(String userName, String spaceGuid, String processId) {\n+    public CloudControllerClient getControllerClient(String userName, String orgName, String spaceName) {\n         try {\n-            return getClientFromCache(userName, spaceGuid, processId);\n+            return getClientFromCache(userName, orgName, spaceName);\n         } catch (CloudOperationException e) {\n-            throw new SLException(e, Messages.CANT_CREATE_CLIENT_FOR_SPACE_ID, spaceGuid);\n+            throw new SLException(e, Messages.CANT_CREATE_CLIENT_FOR_SPACE_ID, orgName);", "originalCommit": "6f2a4aeaa3353b6155f6f3752ca5ea9dfc7380be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA2MjkyNQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r477062925", "bodyText": "Fixed", "author": "radito3", "createdAt": "2020-08-26T06:28:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMyODE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM0MjMwMw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r476342303", "bodyText": "Do you think that it could be better to log step name instead of processId?", "author": "theghost5800", "createdAt": "2020-08-25T10:22:45Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/util/OperationInFinalStateHandler.java", "diffHunk": "@@ -80,21 +82,41 @@ protected void setOperationState(String processInstanceId, Operation.State state\n         Operation operation = operationService.createQuery()\n                                               .processId(processInstanceId)\n                                               .singleResult();\n-        LOGGER.info(MessageFormat.format(Messages.PROCESS_0_RELEASING_LOCK_FOR_MTA_1_IN_SPACE_2, operation.getProcessId(),\n-                                         operation.getMtaId(), operation.getSpaceId()));\n+        LOGGER.info(format(Messages.PROCESS_0_RELEASING_LOCK_FOR_MTA_1_IN_SPACE_2, operation.getProcessId(), operation.getMtaId(),\n+                           operation.getSpaceId()));\n         operation = ImmutableOperation.builder()\n                                       .from(operation)\n                                       .state(state)\n                                       .hasAcquiredLock(false)\n                                       .endedAt(ZonedDateTime.now())\n                                       .build();\n         operationService.update(operation, operation);\n-        LOGGER.debug(MessageFormat.format(Messages.PROCESS_0_RELEASED_LOCK, operation.getProcessId()));\n+        LOGGER.debug(format(Messages.PROCESS_0_RELEASED_LOCK, operation.getProcessId()));\n         historicOperationEventPersister.add(processInstanceId, toEventType(state));\n     }\n \n     private EventType toEventType(State state) {\n         return state == Operation.State.FINISHED ? EventType.FINISHED : EventType.ABORTED;\n     }\n \n+    private void logOperationTime(String correlationId) {\n+        Map<String, ProcessTime> processTimes = operationTimeAggregator.collectProcessTimes(correlationId);\n+\n+        processTimes.forEach((processId, processTime) -> logProcessTime(correlationId, processId, processTime));\n+\n+        ProcessTime overallProcessTime = operationTimeAggregator.computeOverallProcessTime(correlationId, processTimes);\n+\n+        if (overallProcessTime.hasParallelSubProcesses()) {\n+            LOGGER.info(format(Messages.TIME_STATISTICS_FOR_OPERATION_WITH_PARALLEL_PROCESSES_0_DURATION_1_DELAY_2, correlationId,\n+                               overallProcessTime.getProcessDuration(), overallProcessTime.getDelayBetweenSteps()));\n+        } else {\n+            LOGGER.info(format(Messages.TIME_STATISTICS_FOR_OPERATION_0_DURATION_1_DELAY_2, correlationId,\n+                               overallProcessTime.getProcessDuration(), overallProcessTime.getDelayBetweenSteps()));\n+        }\n+    }\n+\n+    private void logProcessTime(String correlationId, String processId, ProcessTime processTime) {\n+        LOGGER.debug(format(Messages.TIME_STATISTICS_FOR_PROCESS_0_OPERATION_1_DURATION_2_DELAY_3, processId, correlationId,", "originalCommit": "6f2a4aeaa3353b6155f6f3752ca5ea9dfc7380be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA2NjAyMg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r477066022", "bodyText": "What step name?\nThis code is called in EndProcessListener", "author": "radito3", "createdAt": "2020-08-26T06:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM0MjMwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA5NzE0Mw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r477097143", "bodyText": "You can try with execution.getCurrentFlowElement().getName() as I can see execution is passed as parameter in EndProcessListener\nI have a look again in the code and I can see that OperationInFinalStateHandler is called when the process is the root. So this won't work. If you couldn't find a way to determine easily step name by process id, leave it as it is now.", "author": "theghost5800", "createdAt": "2020-08-26T07:40:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM0MjMwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE3Mzc5MQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r478173791", "bodyText": "This code is called once per process and not once per step, so it doesn't make sense to log the step name.", "author": "nictas", "createdAt": "2020-08-27T06:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM0MjMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM4MTg4MQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r476381881", "bodyText": "fix order of methods", "author": "theghost5800", "createdAt": "2020-08-25T11:39:53Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/util/ProcessTimeCalculator.java", "diffHunk": "@@ -32,24 +31,47 @@ public ProcessTimeCalculator(FlowableFacade flowableFacade) {\n \n     public ProcessTime calculate(String processInstanceId) {\n         HistoricProcessInstance rootProcessInstance = flowableFacade.getHistoricProcessById(processInstanceId);\n-\n-        long processDuration = calculateProcessDuration(rootProcessInstance);\n-\n         List<HistoricActivityInstance> processActivities = flowableFacade.getProcessEngine()\n                                                                          .getHistoryService()\n                                                                          .createHistoricActivityInstanceQuery()\n                                                                          .processInstanceId(processInstanceId)\n                                                                          .list();\n+        long processDuration = calculateProcessDuration(rootProcessInstance);\n+        long flatSum = flattenProcessDuration(processActivities);\n+\n         long processActivitiesTime = calculateFilteredProcessActivitiesTime(processActivities, inst -> true);\n-        long callActivitiesTime = calculateFilteredProcessActivitiesTime(processActivities, this::isCallActivity);\n         long timerEventsTime = calculateFilteredProcessActivitiesTime(processActivities, this::isTimerEvent);\n+        long gatewaysTime = calculateFilteredProcessActivitiesTime(processActivities, this::isGateway);\n \n         return ImmutableProcessTime.builder()\n                                    .processDuration(processDuration)\n-                                   .delayBetweenSteps(processDuration - processActivitiesTime + callActivitiesTime + timerEventsTime)\n+                                   .delayBetweenSteps((processDuration + flatSum) - processActivitiesTime + timerEventsTime + gatewaysTime)\n+                                   .hasParallelSubProcesses(flatSum != 0)\n                                    .build();\n     }\n \n+    private long flattenProcessDuration(List<HistoricActivityInstance> processActivitiesList) {\n+        HistoricActivityInstance[] processActivities = processActivitiesList.toArray(new HistoricActivityInstance[0]);\n+        Arrays.sort(processActivities, Comparator.comparing(HistoricActivityInstance::getStartTime));\n+        long flatSum = 0;\n+\n+        for (int i = 0; i < processActivities.length - 1; i++) {\n+            for (int j = i + 1; j < processActivities.length; j++) {\n+                if (areParallelActivities(processActivities[i], processActivities[j])) {\n+                    flatSum += calculateActivityDuration(processActivities[j]);\n+                }\n+            }\n+        }\n+\n+        return flatSum;\n+    }\n+\n+    private boolean areParallelActivities(HistoricActivityInstance instance1, HistoricActivityInstance instance2) {\n+        return instance1.getEndTime()\n+                        .after(instance2.getStartTime())\n+            && CALL_ACTIVITY_TYPE.equals(instance2.getActivityType());\n+    }\n+\n     private long calculateProcessDuration(HistoricProcessInstance processInstance) {", "originalCommit": "6f2a4aeaa3353b6155f6f3752ca5ea9dfc7380be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMyNDcyMw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r477324723", "bodyText": "Done", "author": "radito3", "createdAt": "2020-08-26T14:01:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM4MTg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM4NjQyMA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r476386420", "bodyText": "Why don't use toArray() method?", "author": "theghost5800", "createdAt": "2020-08-25T11:46:55Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/util/ProcessTimeCalculator.java", "diffHunk": "@@ -32,24 +31,47 @@ public ProcessTimeCalculator(FlowableFacade flowableFacade) {\n \n     public ProcessTime calculate(String processInstanceId) {\n         HistoricProcessInstance rootProcessInstance = flowableFacade.getHistoricProcessById(processInstanceId);\n-\n-        long processDuration = calculateProcessDuration(rootProcessInstance);\n-\n         List<HistoricActivityInstance> processActivities = flowableFacade.getProcessEngine()\n                                                                          .getHistoryService()\n                                                                          .createHistoricActivityInstanceQuery()\n                                                                          .processInstanceId(processInstanceId)\n                                                                          .list();\n+        long processDuration = calculateProcessDuration(rootProcessInstance);\n+        long flatSum = flattenProcessDuration(processActivities);\n+\n         long processActivitiesTime = calculateFilteredProcessActivitiesTime(processActivities, inst -> true);\n-        long callActivitiesTime = calculateFilteredProcessActivitiesTime(processActivities, this::isCallActivity);\n         long timerEventsTime = calculateFilteredProcessActivitiesTime(processActivities, this::isTimerEvent);\n+        long gatewaysTime = calculateFilteredProcessActivitiesTime(processActivities, this::isGateway);\n \n         return ImmutableProcessTime.builder()\n                                    .processDuration(processDuration)\n-                                   .delayBetweenSteps(processDuration - processActivitiesTime + callActivitiesTime + timerEventsTime)\n+                                   .delayBetweenSteps((processDuration + flatSum) - processActivitiesTime + timerEventsTime + gatewaysTime)\n+                                   .hasParallelSubProcesses(flatSum != 0)\n                                    .build();\n     }\n \n+    private long flattenProcessDuration(List<HistoricActivityInstance> processActivitiesList) {\n+        HistoricActivityInstance[] processActivities = processActivitiesList.toArray(new HistoricActivityInstance[0]);", "originalCommit": "6f2a4aeaa3353b6155f6f3752ca5ea9dfc7380be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA2NDM1Nw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r477064357", "bodyText": "toArray() returns an Object array and I need to cast it to the appropriate type before assigning to a variable.\nThe generic toArray(T[] arr) method uses the correct type and avoids casting", "author": "radito3", "createdAt": "2020-08-26T06:31:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM4NjQyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEwNDcxNQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r477104715", "bodyText": "okay, I am agree with you.", "author": "theghost5800", "createdAt": "2020-08-26T07:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM4NjQyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM4Nzc2NA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r476387764", "bodyText": "Is it possible to use another solution without converting the list into array and avoid using of nested loops", "author": "theghost5800", "createdAt": "2020-08-25T11:49:31Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/util/ProcessTimeCalculator.java", "diffHunk": "@@ -32,24 +31,47 @@ public ProcessTimeCalculator(FlowableFacade flowableFacade) {\n \n     public ProcessTime calculate(String processInstanceId) {\n         HistoricProcessInstance rootProcessInstance = flowableFacade.getHistoricProcessById(processInstanceId);\n-\n-        long processDuration = calculateProcessDuration(rootProcessInstance);\n-\n         List<HistoricActivityInstance> processActivities = flowableFacade.getProcessEngine()\n                                                                          .getHistoryService()\n                                                                          .createHistoricActivityInstanceQuery()\n                                                                          .processInstanceId(processInstanceId)\n                                                                          .list();\n+        long processDuration = calculateProcessDuration(rootProcessInstance);\n+        long flatSum = flattenProcessDuration(processActivities);\n+\n         long processActivitiesTime = calculateFilteredProcessActivitiesTime(processActivities, inst -> true);\n-        long callActivitiesTime = calculateFilteredProcessActivitiesTime(processActivities, this::isCallActivity);\n         long timerEventsTime = calculateFilteredProcessActivitiesTime(processActivities, this::isTimerEvent);\n+        long gatewaysTime = calculateFilteredProcessActivitiesTime(processActivities, this::isGateway);\n \n         return ImmutableProcessTime.builder()\n                                    .processDuration(processDuration)\n-                                   .delayBetweenSteps(processDuration - processActivitiesTime + callActivitiesTime + timerEventsTime)\n+                                   .delayBetweenSteps((processDuration + flatSum) - processActivitiesTime + timerEventsTime + gatewaysTime)\n+                                   .hasParallelSubProcesses(flatSum != 0)\n                                    .build();\n     }\n \n+    private long flattenProcessDuration(List<HistoricActivityInstance> processActivitiesList) {\n+        HistoricActivityInstance[] processActivities = processActivitiesList.toArray(new HistoricActivityInstance[0]);\n+        Arrays.sort(processActivities, Comparator.comparing(HistoricActivityInstance::getStartTime));\n+        long flatSum = 0;\n+\n+        for (int i = 0; i < processActivities.length - 1; i++) {", "originalCommit": "6f2a4aeaa3353b6155f6f3752ca5ea9dfc7380be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMyMzM1MA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r477323350", "bodyText": "Yes, the logic is changed", "author": "radito3", "createdAt": "2020-08-26T13:59:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM4Nzc2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM5MDM5Ng==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r476390396", "bodyText": "Why you need to compare end time of instance1 and start time of instance2? Isn't it enought to check activity type only?", "author": "theghost5800", "createdAt": "2020-08-25T11:54:35Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/util/ProcessTimeCalculator.java", "diffHunk": "@@ -32,24 +31,47 @@ public ProcessTimeCalculator(FlowableFacade flowableFacade) {\n \n     public ProcessTime calculate(String processInstanceId) {\n         HistoricProcessInstance rootProcessInstance = flowableFacade.getHistoricProcessById(processInstanceId);\n-\n-        long processDuration = calculateProcessDuration(rootProcessInstance);\n-\n         List<HistoricActivityInstance> processActivities = flowableFacade.getProcessEngine()\n                                                                          .getHistoryService()\n                                                                          .createHistoricActivityInstanceQuery()\n                                                                          .processInstanceId(processInstanceId)\n                                                                          .list();\n+        long processDuration = calculateProcessDuration(rootProcessInstance);\n+        long flatSum = flattenProcessDuration(processActivities);\n+\n         long processActivitiesTime = calculateFilteredProcessActivitiesTime(processActivities, inst -> true);\n-        long callActivitiesTime = calculateFilteredProcessActivitiesTime(processActivities, this::isCallActivity);\n         long timerEventsTime = calculateFilteredProcessActivitiesTime(processActivities, this::isTimerEvent);\n+        long gatewaysTime = calculateFilteredProcessActivitiesTime(processActivities, this::isGateway);\n \n         return ImmutableProcessTime.builder()\n                                    .processDuration(processDuration)\n-                                   .delayBetweenSteps(processDuration - processActivitiesTime + callActivitiesTime + timerEventsTime)\n+                                   .delayBetweenSteps((processDuration + flatSum) - processActivitiesTime + timerEventsTime + gatewaysTime)\n+                                   .hasParallelSubProcesses(flatSum != 0)\n                                    .build();\n     }\n \n+    private long flattenProcessDuration(List<HistoricActivityInstance> processActivitiesList) {\n+        HistoricActivityInstance[] processActivities = processActivitiesList.toArray(new HistoricActivityInstance[0]);\n+        Arrays.sort(processActivities, Comparator.comparing(HistoricActivityInstance::getStartTime));\n+        long flatSum = 0;\n+\n+        for (int i = 0; i < processActivities.length - 1; i++) {\n+            for (int j = i + 1; j < processActivities.length; j++) {\n+                if (areParallelActivities(processActivities[i], processActivities[j])) {\n+                    flatSum += calculateActivityDuration(processActivities[j]);\n+                }\n+            }\n+        }\n+\n+        return flatSum;\n+    }\n+\n+    private boolean areParallelActivities(HistoricActivityInstance instance1, HistoricActivityInstance instance2) {\n+        return instance1.getEndTime()", "originalCommit": "6f2a4aeaa3353b6155f6f3752ca5ea9dfc7380be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA2NDYzNg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r477064636", "bodyText": "This comparison is to check whether two activities are parallel", "author": "radito3", "createdAt": "2020-08-26T06:32:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM5MDM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExNDUyNw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r477114527", "bodyText": "okay.", "author": "theghost5800", "createdAt": "2020-08-26T08:09:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM5MDM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM5NTE4MQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r476395181", "bodyText": "Maybe it will be better to use equalsIgnoreCase for all activity types", "author": "theghost5800", "createdAt": "2020-08-25T12:03:43Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/util/ProcessTimeCalculator.java", "diffHunk": "@@ -8,18 +10,15 @@\n import org.cloudfoundry.multiapps.controller.process.flowable.FlowableFacade;\n import org.flowable.engine.history.HistoricActivityInstance;\n import org.flowable.engine.history.HistoricProcessInstance;\n-import org.immutables.value.Value.Immutable;\n-\n-import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n \n public class ProcessTimeCalculator {\n \n     private static final String CALL_ACTIVITY_TYPE = \"callActivity\";\n     private static final String TIMER_EVENT_TYPE = \"intermediateCatchEvent\";\n+    private static final String GATEWAY_TYPE = \"Gateway\";", "originalCommit": "6f2a4aeaa3353b6155f6f3752ca5ea9dfc7380be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA2NDg1MA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r477064850", "bodyText": "Why?", "author": "radito3", "createdAt": "2020-08-26T06:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM5NTE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEwNDMyMQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r477104321", "bodyText": "In case where returned activity type is with lower or upper cases only. If you think that getActivityType() method wouldn't return just gateway as activity type, you can leave as it is.", "author": "theghost5800", "createdAt": "2020-08-26T07:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM5NTE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMyNDMyNQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r477324325", "bodyText": "The comparison with \"Gateway\" isn't equals() but endsWith() (due to exclusive and inclusive gateways), so we don't need to use equalsIgnoreCase()", "author": "radito3", "createdAt": "2020-08-26T14:00:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM5NTE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwNjgxNQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r476406815", "bodyText": "Is it okay to initialize this variable locally instead of passing offset as parameter? I am asking this because I have already notice that you have method called createProcess where your pass offset. Maybe you have to pass offset as parameter in both methods.", "author": "theghost5800", "createdAt": "2020-08-25T12:23:54Z", "path": "multiapps-controller-process/src/test/java/org/cloudfoundry/multiapps/controller/process/util/OperationTimeAggregatorTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+package org.cloudfoundry.multiapps.controller.process.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import org.cloudfoundry.multiapps.controller.process.flowable.FlowableFacade;\n+import org.flowable.engine.HistoryService;\n+import org.flowable.engine.ProcessEngine;\n+import org.flowable.engine.history.HistoricActivityInstance;\n+import org.flowable.engine.history.HistoricActivityInstanceQuery;\n+import org.flowable.engine.history.HistoricProcessInstance;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+public class OperationTimeAggregatorTest {\n+\n+    private static final String CORRELATION_ID = \"id\";\n+\n+    @Mock\n+    private FlowableFacade flowableFacade;\n+    @InjectMocks\n+    private OperationTimeAggregator operationTimeAggregator;\n+\n+    //TODO the tests here will work in a real life scenario if the subprocesses are registered as both:\n+    // a callActivity historic activity within the process\n+    // and\n+    // a different historic process (with the same correlation id)\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.openMocks(this);\n+    }\n+\n+    @Test\n+    void testOperationTimeWithNoSubProcesses() {\n+        Mockito.when(flowableFacade.getHistoricSubProcessIds(CORRELATION_ID))\n+               .thenReturn(new ArrayList<>());\n+        HistoricProcessInstance process = createProcess(200);\n+        Mockito.when(flowableFacade.getHistoricProcessById(CORRELATION_ID))\n+               .thenReturn(process);\n+        List<HistoricActivityInstance> activities = mockProcessActivities(false,\n+                                                                          SimpleActivity.of(\"serviceTask\", 2, 100));\n+        mockQuery(activities);\n+\n+        Map<String, ProcessTime> result = operationTimeAggregator.collectProcessTimes(CORRELATION_ID);\n+        assertEquals(1, result.size());\n+        ProcessTime rootProcessTime = result.get(CORRELATION_ID);\n+\n+        ProcessTime overallTime = operationTimeAggregator.computeOverallProcessTime(CORRELATION_ID, result);\n+\n+        assertEquals(200, rootProcessTime.getProcessDuration());\n+        assertEquals(0, rootProcessTime.getDelayBetweenSteps());\n+        assertEquals(rootProcessTime, overallTime);\n+        assertFalse(overallTime.hasParallelSubProcesses());\n+    }\n+\n+    private void mockQuery(List<HistoricActivityInstance> rootProcessActivities, List<HistoricActivityInstance>... subProcessActivities) {\n+        Supplier<HistoricActivityInstanceQuery> querySupplier = () -> Mockito.mock(HistoricActivityInstanceQuery.class);\n+\n+        ProcessEngine processEngine = Mockito.mock(ProcessEngine.class);\n+        Mockito.when(flowableFacade.getProcessEngine())\n+               .thenReturn(processEngine);\n+        HistoryService historyServiceMock = Mockito.mock(HistoryService.class);\n+        Mockito.when(processEngine.getHistoryService())\n+               .thenReturn(historyServiceMock);\n+\n+        HistoricActivityInstanceQuery rootProcessQuery = querySupplier.get();\n+        Mockito.when(historyServiceMock.createHistoricActivityInstanceQuery())\n+               .thenReturn(rootProcessQuery);\n+        Mockito.when(rootProcessQuery.processInstanceId(CORRELATION_ID))\n+               .thenReturn(rootProcessQuery);\n+        Mockito.when(rootProcessQuery.list())\n+               .thenReturn(rootProcessActivities);\n+\n+        for (int i = 0; i < subProcessActivities.length; i++) {\n+            HistoricActivityInstanceQuery subProcessQuery = querySupplier.get();\n+\n+            Mockito.when(rootProcessQuery.processInstanceId(Integer.toString(i)))\n+                   .thenReturn(subProcessQuery);\n+            Mockito.when(subProcessQuery.list())\n+                   .thenReturn(subProcessActivities[i]);\n+        }\n+    }\n+\n+    @Test\n+    void testOperationTimeWithOneSubProcess() {\n+        List<String> subProcessIds = new ArrayList<>();\n+        subProcessIds.add(\"0\");\n+        Mockito.when(flowableFacade.getHistoricSubProcessIds(CORRELATION_ID))\n+               .thenReturn(subProcessIds);\n+        HistoricProcessInstance rootProcess = createProcess(400);\n+        Mockito.when(flowableFacade.getHistoricProcessById(CORRELATION_ID))\n+               .thenReturn(rootProcess);\n+        HistoricProcessInstance subProcess = createProcess(150);\n+        Mockito.when(flowableFacade.getHistoricProcessById(\"0\"))\n+               .thenReturn(subProcess);\n+\n+        List<HistoricActivityInstance> rootProcessActivities = mockProcessActivities(false,\n+                                                                                     SimpleActivity.of(\"serviceTask\", 2, 100),\n+                                                                                     SimpleActivity.of(\"callActivity\", 1, 150),\n+                                                                                     SimpleActivity.of(\"exclusiveGateway\", 1, 50));\n+        List<HistoricActivityInstance> subProcessActivities = mockProcessActivities(false,\n+                                                                                    SimpleActivity.of(\"serviceTask\", 1, 100),\n+                                                                                    SimpleActivity.of(\"exclusiveGateway\", 1, 50));\n+        mockQuery(rootProcessActivities, subProcessActivities);\n+\n+        Map<String, ProcessTime> result = operationTimeAggregator.collectProcessTimes(CORRELATION_ID);\n+        assertEquals(2, result.size());\n+        ProcessTime rootProcessTime = result.get(CORRELATION_ID);\n+        ProcessTime subProcessTime = result.get(\"0\");\n+\n+        ProcessTime overallTime = operationTimeAggregator.computeOverallProcessTime(CORRELATION_ID, result);\n+\n+        assertEquals(50, rootProcessTime.getDelayBetweenSteps());\n+        assertEquals(400, rootProcessTime.getProcessDuration());\n+        assertEquals(150, subProcessTime.getProcessDuration());\n+        assertEquals(50, subProcessTime.getDelayBetweenSteps());\n+        assertEquals(100, overallTime.getDelayBetweenSteps());\n+        assertFalse(overallTime.hasParallelSubProcesses());\n+    }\n+\n+    @Test\n+    void testOperationWithTwoSubProcesses() {\n+        List<String> subProcessIds = new ArrayList<>();\n+        subProcessIds.add(\"0\");\n+        subProcessIds.add(\"1\");\n+        Mockito.when(flowableFacade.getHistoricSubProcessIds(CORRELATION_ID))\n+               .thenReturn(subProcessIds);\n+        HistoricProcessInstance process = createProcess(0, 650);\n+        Mockito.when(flowableFacade.getHistoricProcessById(CORRELATION_ID))\n+               .thenReturn(process);\n+        HistoricProcessInstance process1 = createProcess(1, 150);\n+        Mockito.when(flowableFacade.getHistoricProcessById(\"0\"))\n+               .thenReturn(process1);\n+        HistoricProcessInstance process2 = createProcess(152, 250);\n+        Mockito.when(flowableFacade.getHistoricProcessById(\"1\"))\n+               .thenReturn(process2);\n+\n+        List<HistoricActivityInstance> rootProcessActivities = mockProcessActivities(false,\n+                                                                                     SimpleActivity.of(\"serviceTask\", 2, 100),\n+                                                                                     SimpleActivity.of(\"callActivity\", 1, 150),\n+                                                                                     SimpleActivity.of(\"callActivity\", 1, 250),\n+                                                                                     SimpleActivity.of(\"exclusiveGateway\", 1, 50));\n+        List<HistoricActivityInstance> subProcessOneActivities = mockProcessActivities(false,\n+                                                                                       SimpleActivity.of(\"serviceTask\", 1, 100),\n+                                                                                       SimpleActivity.of(\"exclusiveGateway\", 1, 50));\n+        List<HistoricActivityInstance> subProcessTwoActivities = mockProcessActivities(false,\n+                                                                                       SimpleActivity.of(\"serviceTask\", 2, 100),\n+                                                                                       SimpleActivity.of(\"exclusiveGateway\", 1, 50));\n+\n+       mockQuery(rootProcessActivities, subProcessOneActivities, subProcessTwoActivities);\n+\n+        Map<String, ProcessTime> result = operationTimeAggregator.collectProcessTimes(CORRELATION_ID);\n+        assertEquals(3, result.size());\n+        ProcessTime rootProcessTime = result.get(CORRELATION_ID);\n+        ProcessTime subProcessOneTime = result.get(\"0\");\n+        ProcessTime subProcessTwoTime = result.get(\"1\");\n+\n+        ProcessTime overallTime = operationTimeAggregator.computeOverallProcessTime(CORRELATION_ID, result);\n+\n+        assertEquals(50, rootProcessTime.getDelayBetweenSteps());\n+        assertEquals(650, rootProcessTime.getProcessDuration());\n+        assertEquals(150, subProcessOneTime.getProcessDuration());\n+        assertEquals(50, subProcessOneTime.getDelayBetweenSteps());\n+        assertEquals(250, subProcessTwoTime.getProcessDuration());\n+        assertEquals(50, subProcessTwoTime.getDelayBetweenSteps());\n+        assertEquals(150, overallTime.getDelayBetweenSteps());\n+        assertFalse(overallTime.hasParallelSubProcesses());\n+    }\n+\n+    @Test\n+    void testOperationWithTwoParallelSubProcesses() {\n+        long initialOffset = System.currentTimeMillis();\n+        List<String> subProcessIds = new ArrayList<>();\n+        subProcessIds.add(\"0\");\n+        subProcessIds.add(\"1\");\n+        Mockito.when(flowableFacade.getHistoricSubProcessIds(CORRELATION_ID))\n+               .thenReturn(subProcessIds);\n+        HistoricProcessInstance process = createProcess(initialOffset, 400);\n+        Mockito.when(flowableFacade.getHistoricProcessById(CORRELATION_ID))\n+               .thenReturn(process);\n+        HistoricProcessInstance process1 = createProcess(initialOffset + 10, 150);\n+        Mockito.when(flowableFacade.getHistoricProcessById(\"0\"))\n+               .thenReturn(process1);\n+        HistoricProcessInstance process2 = createProcess(initialOffset + 20, 250);\n+        Mockito.when(flowableFacade.getHistoricProcessById(\"1\"))\n+               .thenReturn(process2);\n+\n+        List<HistoricActivityInstance> rootProcessActivities = mockProcessActivities(true,\n+                                                                                     SimpleActivity.of(\"serviceTask\", 1, 50),\n+                                                                                     SimpleActivity.of(\"callActivity\", 1, 150),\n+                                                                                     SimpleActivity.of(\"callActivity\", 1, 250),\n+                                                                                     SimpleActivity.of(\"exclusiveGateway\", 2, 50));\n+        List<HistoricActivityInstance> subProcessOneActivities = mockProcessActivities(false,\n+                                                                                       SimpleActivity.of(\"serviceTask\", 1, 100),\n+                                                                                       SimpleActivity.of(\"exclusiveGateway\", 1, 50));\n+        List<HistoricActivityInstance> subProcessTwoActivities = mockProcessActivities(false,\n+                                                                                       SimpleActivity.of(\"serviceTask\", 2, 100),\n+                                                                                       SimpleActivity.of(\"exclusiveGateway\", 1, 50));\n+\n+        mockQuery(rootProcessActivities, subProcessOneActivities, subProcessTwoActivities);\n+\n+        Map<String, ProcessTime> result = operationTimeAggregator.collectProcessTimes(CORRELATION_ID);\n+        assertEquals(3, result.size());\n+        ProcessTime rootProcessTime = result.get(CORRELATION_ID);\n+        ProcessTime subProcessOneTime = result.get(\"0\");\n+        ProcessTime subProcessTwoTime = result.get(\"1\");\n+\n+        ProcessTime overallTime = operationTimeAggregator.computeOverallProcessTime(CORRELATION_ID, result);\n+\n+        assertEquals(200, rootProcessTime.getDelayBetweenSteps());\n+        assertEquals(400, rootProcessTime.getProcessDuration());\n+        assertEquals(150, subProcessOneTime.getProcessDuration());\n+        assertEquals(50, subProcessOneTime.getDelayBetweenSteps());\n+        assertEquals(250, subProcessTwoTime.getProcessDuration());\n+        assertEquals(50, subProcessTwoTime.getDelayBetweenSteps());\n+        assertEquals(300, overallTime.getDelayBetweenSteps());\n+        assertTrue(overallTime.hasParallelSubProcesses());\n+    }\n+\n+    private HistoricProcessInstance createProcess(long processTime) {\n+        return createProcess(0, processTime);\n+    }\n+\n+    private List<HistoricActivityInstance> mockProcessActivities(boolean parallel, SimpleActivity... activities) {\n+        long offset = System.currentTimeMillis();", "originalCommit": "6f2a4aeaa3353b6155f6f3752ca5ea9dfc7380be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxNDQzMg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r476414432", "bodyText": "Extract processEngine as field", "author": "theghost5800", "createdAt": "2020-08-25T12:37:25Z", "path": "multiapps-controller-process/src/test/java/org/cloudfoundry/multiapps/controller/process/util/OperationTimeAggregatorTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+package org.cloudfoundry.multiapps.controller.process.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import org.cloudfoundry.multiapps.controller.process.flowable.FlowableFacade;\n+import org.flowable.engine.HistoryService;\n+import org.flowable.engine.ProcessEngine;\n+import org.flowable.engine.history.HistoricActivityInstance;\n+import org.flowable.engine.history.HistoricActivityInstanceQuery;\n+import org.flowable.engine.history.HistoricProcessInstance;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+public class OperationTimeAggregatorTest {\n+\n+    private static final String CORRELATION_ID = \"id\";\n+\n+    @Mock\n+    private FlowableFacade flowableFacade;\n+    @InjectMocks\n+    private OperationTimeAggregator operationTimeAggregator;\n+\n+    //TODO the tests here will work in a real life scenario if the subprocesses are registered as both:\n+    // a callActivity historic activity within the process\n+    // and\n+    // a different historic process (with the same correlation id)\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.openMocks(this);\n+    }\n+\n+    @Test\n+    void testOperationTimeWithNoSubProcesses() {\n+        Mockito.when(flowableFacade.getHistoricSubProcessIds(CORRELATION_ID))\n+               .thenReturn(new ArrayList<>());\n+        HistoricProcessInstance process = createProcess(200);\n+        Mockito.when(flowableFacade.getHistoricProcessById(CORRELATION_ID))\n+               .thenReturn(process);\n+        List<HistoricActivityInstance> activities = mockProcessActivities(false,\n+                                                                          SimpleActivity.of(\"serviceTask\", 2, 100));\n+        mockQuery(activities);\n+\n+        Map<String, ProcessTime> result = operationTimeAggregator.collectProcessTimes(CORRELATION_ID);\n+        assertEquals(1, result.size());\n+        ProcessTime rootProcessTime = result.get(CORRELATION_ID);\n+\n+        ProcessTime overallTime = operationTimeAggregator.computeOverallProcessTime(CORRELATION_ID, result);\n+\n+        assertEquals(200, rootProcessTime.getProcessDuration());\n+        assertEquals(0, rootProcessTime.getDelayBetweenSteps());\n+        assertEquals(rootProcessTime, overallTime);\n+        assertFalse(overallTime.hasParallelSubProcesses());\n+    }\n+\n+    private void mockQuery(List<HistoricActivityInstance> rootProcessActivities, List<HistoricActivityInstance>... subProcessActivities) {\n+        Supplier<HistoricActivityInstanceQuery> querySupplier = () -> Mockito.mock(HistoricActivityInstanceQuery.class);\n+\n+        ProcessEngine processEngine = Mockito.mock(ProcessEngine.class);", "originalCommit": "6f2a4aeaa3353b6155f6f3752ca5ea9dfc7380be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxNTMxNw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r476415317", "bodyText": "Extract historyService as field and align variable name with other mock objects", "author": "theghost5800", "createdAt": "2020-08-25T12:38:54Z", "path": "multiapps-controller-process/src/test/java/org/cloudfoundry/multiapps/controller/process/util/OperationTimeAggregatorTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+package org.cloudfoundry.multiapps.controller.process.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import org.cloudfoundry.multiapps.controller.process.flowable.FlowableFacade;\n+import org.flowable.engine.HistoryService;\n+import org.flowable.engine.ProcessEngine;\n+import org.flowable.engine.history.HistoricActivityInstance;\n+import org.flowable.engine.history.HistoricActivityInstanceQuery;\n+import org.flowable.engine.history.HistoricProcessInstance;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+public class OperationTimeAggregatorTest {\n+\n+    private static final String CORRELATION_ID = \"id\";\n+\n+    @Mock\n+    private FlowableFacade flowableFacade;\n+    @InjectMocks\n+    private OperationTimeAggregator operationTimeAggregator;\n+\n+    //TODO the tests here will work in a real life scenario if the subprocesses are registered as both:\n+    // a callActivity historic activity within the process\n+    // and\n+    // a different historic process (with the same correlation id)\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.openMocks(this);\n+    }\n+\n+    @Test\n+    void testOperationTimeWithNoSubProcesses() {\n+        Mockito.when(flowableFacade.getHistoricSubProcessIds(CORRELATION_ID))\n+               .thenReturn(new ArrayList<>());\n+        HistoricProcessInstance process = createProcess(200);\n+        Mockito.when(flowableFacade.getHistoricProcessById(CORRELATION_ID))\n+               .thenReturn(process);\n+        List<HistoricActivityInstance> activities = mockProcessActivities(false,\n+                                                                          SimpleActivity.of(\"serviceTask\", 2, 100));\n+        mockQuery(activities);\n+\n+        Map<String, ProcessTime> result = operationTimeAggregator.collectProcessTimes(CORRELATION_ID);\n+        assertEquals(1, result.size());\n+        ProcessTime rootProcessTime = result.get(CORRELATION_ID);\n+\n+        ProcessTime overallTime = operationTimeAggregator.computeOverallProcessTime(CORRELATION_ID, result);\n+\n+        assertEquals(200, rootProcessTime.getProcessDuration());\n+        assertEquals(0, rootProcessTime.getDelayBetweenSteps());\n+        assertEquals(rootProcessTime, overallTime);\n+        assertFalse(overallTime.hasParallelSubProcesses());\n+    }\n+\n+    private void mockQuery(List<HistoricActivityInstance> rootProcessActivities, List<HistoricActivityInstance>... subProcessActivities) {\n+        Supplier<HistoricActivityInstanceQuery> querySupplier = () -> Mockito.mock(HistoricActivityInstanceQuery.class);\n+\n+        ProcessEngine processEngine = Mockito.mock(ProcessEngine.class);\n+        Mockito.when(flowableFacade.getProcessEngine())\n+               .thenReturn(processEngine);\n+        HistoryService historyServiceMock = Mockito.mock(HistoryService.class);", "originalCommit": "6f2a4aeaa3353b6155f6f3752ca5ea9dfc7380be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxOTY4Ng==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r476419686", "bodyText": "you can convert varargs into list (Arrays::asList) and use forEach method", "author": "theghost5800", "createdAt": "2020-08-25T12:46:10Z", "path": "multiapps-controller-process/src/test/java/org/cloudfoundry/multiapps/controller/process/util/OperationTimeAggregatorTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+package org.cloudfoundry.multiapps.controller.process.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import org.cloudfoundry.multiapps.controller.process.flowable.FlowableFacade;\n+import org.flowable.engine.HistoryService;\n+import org.flowable.engine.ProcessEngine;\n+import org.flowable.engine.history.HistoricActivityInstance;\n+import org.flowable.engine.history.HistoricActivityInstanceQuery;\n+import org.flowable.engine.history.HistoricProcessInstance;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+public class OperationTimeAggregatorTest {\n+\n+    private static final String CORRELATION_ID = \"id\";\n+\n+    @Mock\n+    private FlowableFacade flowableFacade;\n+    @InjectMocks\n+    private OperationTimeAggregator operationTimeAggregator;\n+\n+    //TODO the tests here will work in a real life scenario if the subprocesses are registered as both:\n+    // a callActivity historic activity within the process\n+    // and\n+    // a different historic process (with the same correlation id)\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.openMocks(this);\n+    }\n+\n+    @Test\n+    void testOperationTimeWithNoSubProcesses() {\n+        Mockito.when(flowableFacade.getHistoricSubProcessIds(CORRELATION_ID))\n+               .thenReturn(new ArrayList<>());\n+        HistoricProcessInstance process = createProcess(200);\n+        Mockito.when(flowableFacade.getHistoricProcessById(CORRELATION_ID))\n+               .thenReturn(process);\n+        List<HistoricActivityInstance> activities = mockProcessActivities(false,\n+                                                                          SimpleActivity.of(\"serviceTask\", 2, 100));\n+        mockQuery(activities);\n+\n+        Map<String, ProcessTime> result = operationTimeAggregator.collectProcessTimes(CORRELATION_ID);\n+        assertEquals(1, result.size());\n+        ProcessTime rootProcessTime = result.get(CORRELATION_ID);\n+\n+        ProcessTime overallTime = operationTimeAggregator.computeOverallProcessTime(CORRELATION_ID, result);\n+\n+        assertEquals(200, rootProcessTime.getProcessDuration());\n+        assertEquals(0, rootProcessTime.getDelayBetweenSteps());\n+        assertEquals(rootProcessTime, overallTime);\n+        assertFalse(overallTime.hasParallelSubProcesses());\n+    }\n+\n+    private void mockQuery(List<HistoricActivityInstance> rootProcessActivities, List<HistoricActivityInstance>... subProcessActivities) {\n+        Supplier<HistoricActivityInstanceQuery> querySupplier = () -> Mockito.mock(HistoricActivityInstanceQuery.class);\n+\n+        ProcessEngine processEngine = Mockito.mock(ProcessEngine.class);\n+        Mockito.when(flowableFacade.getProcessEngine())\n+               .thenReturn(processEngine);\n+        HistoryService historyServiceMock = Mockito.mock(HistoryService.class);\n+        Mockito.when(processEngine.getHistoryService())\n+               .thenReturn(historyServiceMock);\n+\n+        HistoricActivityInstanceQuery rootProcessQuery = querySupplier.get();\n+        Mockito.when(historyServiceMock.createHistoricActivityInstanceQuery())\n+               .thenReturn(rootProcessQuery);\n+        Mockito.when(rootProcessQuery.processInstanceId(CORRELATION_ID))\n+               .thenReturn(rootProcessQuery);\n+        Mockito.when(rootProcessQuery.list())\n+               .thenReturn(rootProcessActivities);\n+\n+        for (int i = 0; i < subProcessActivities.length; i++) {", "originalCommit": "6f2a4aeaa3353b6155f6f3752ca5ea9dfc7380be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyMDQxMA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r476420410", "bodyText": "Arrays.asList(\"0\")", "author": "theghost5800", "createdAt": "2020-08-25T12:47:27Z", "path": "multiapps-controller-process/src/test/java/org/cloudfoundry/multiapps/controller/process/util/OperationTimeAggregatorTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+package org.cloudfoundry.multiapps.controller.process.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import org.cloudfoundry.multiapps.controller.process.flowable.FlowableFacade;\n+import org.flowable.engine.HistoryService;\n+import org.flowable.engine.ProcessEngine;\n+import org.flowable.engine.history.HistoricActivityInstance;\n+import org.flowable.engine.history.HistoricActivityInstanceQuery;\n+import org.flowable.engine.history.HistoricProcessInstance;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+public class OperationTimeAggregatorTest {\n+\n+    private static final String CORRELATION_ID = \"id\";\n+\n+    @Mock\n+    private FlowableFacade flowableFacade;\n+    @InjectMocks\n+    private OperationTimeAggregator operationTimeAggregator;\n+\n+    //TODO the tests here will work in a real life scenario if the subprocesses are registered as both:\n+    // a callActivity historic activity within the process\n+    // and\n+    // a different historic process (with the same correlation id)\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.openMocks(this);\n+    }\n+\n+    @Test\n+    void testOperationTimeWithNoSubProcesses() {\n+        Mockito.when(flowableFacade.getHistoricSubProcessIds(CORRELATION_ID))\n+               .thenReturn(new ArrayList<>());\n+        HistoricProcessInstance process = createProcess(200);\n+        Mockito.when(flowableFacade.getHistoricProcessById(CORRELATION_ID))\n+               .thenReturn(process);\n+        List<HistoricActivityInstance> activities = mockProcessActivities(false,\n+                                                                          SimpleActivity.of(\"serviceTask\", 2, 100));\n+        mockQuery(activities);\n+\n+        Map<String, ProcessTime> result = operationTimeAggregator.collectProcessTimes(CORRELATION_ID);\n+        assertEquals(1, result.size());\n+        ProcessTime rootProcessTime = result.get(CORRELATION_ID);\n+\n+        ProcessTime overallTime = operationTimeAggregator.computeOverallProcessTime(CORRELATION_ID, result);\n+\n+        assertEquals(200, rootProcessTime.getProcessDuration());\n+        assertEquals(0, rootProcessTime.getDelayBetweenSteps());\n+        assertEquals(rootProcessTime, overallTime);\n+        assertFalse(overallTime.hasParallelSubProcesses());\n+    }\n+\n+    private void mockQuery(List<HistoricActivityInstance> rootProcessActivities, List<HistoricActivityInstance>... subProcessActivities) {\n+        Supplier<HistoricActivityInstanceQuery> querySupplier = () -> Mockito.mock(HistoricActivityInstanceQuery.class);\n+\n+        ProcessEngine processEngine = Mockito.mock(ProcessEngine.class);\n+        Mockito.when(flowableFacade.getProcessEngine())\n+               .thenReturn(processEngine);\n+        HistoryService historyServiceMock = Mockito.mock(HistoryService.class);\n+        Mockito.when(processEngine.getHistoryService())\n+               .thenReturn(historyServiceMock);\n+\n+        HistoricActivityInstanceQuery rootProcessQuery = querySupplier.get();\n+        Mockito.when(historyServiceMock.createHistoricActivityInstanceQuery())\n+               .thenReturn(rootProcessQuery);\n+        Mockito.when(rootProcessQuery.processInstanceId(CORRELATION_ID))\n+               .thenReturn(rootProcessQuery);\n+        Mockito.when(rootProcessQuery.list())\n+               .thenReturn(rootProcessActivities);\n+\n+        for (int i = 0; i < subProcessActivities.length; i++) {\n+            HistoricActivityInstanceQuery subProcessQuery = querySupplier.get();\n+\n+            Mockito.when(rootProcessQuery.processInstanceId(Integer.toString(i)))\n+                   .thenReturn(subProcessQuery);\n+            Mockito.when(subProcessQuery.list())\n+                   .thenReturn(subProcessActivities[i]);\n+        }\n+    }\n+\n+    @Test\n+    void testOperationTimeWithOneSubProcess() {\n+        List<String> subProcessIds = new ArrayList<>();", "originalCommit": "6f2a4aeaa3353b6155f6f3752ca5ea9dfc7380be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA2NTQ5OQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r477065499", "bodyText": "There is an add() operation done on this list in OperationTimeAggregator.\nUsing Arrays.asList() will throw an UnsupportedOperationException", "author": "radito3", "createdAt": "2020-08-26T06:34:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyMDQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExNjY5Ng==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r477116696", "bodyText": "okay", "author": "theghost5800", "createdAt": "2020-08-26T08:13:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyMDQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ1MDE1Ng==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r476450156", "bodyText": "Is it possible to avoid nested for loop", "author": "theghost5800", "createdAt": "2020-08-25T13:31:39Z", "path": "multiapps-controller-process/src/test/java/org/cloudfoundry/multiapps/controller/process/util/OperationTimeAggregatorTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+package org.cloudfoundry.multiapps.controller.process.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import org.cloudfoundry.multiapps.controller.process.flowable.FlowableFacade;\n+import org.flowable.engine.HistoryService;\n+import org.flowable.engine.ProcessEngine;\n+import org.flowable.engine.history.HistoricActivityInstance;\n+import org.flowable.engine.history.HistoricActivityInstanceQuery;\n+import org.flowable.engine.history.HistoricProcessInstance;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+public class OperationTimeAggregatorTest {\n+\n+    private static final String CORRELATION_ID = \"id\";\n+\n+    @Mock\n+    private FlowableFacade flowableFacade;\n+    @InjectMocks\n+    private OperationTimeAggregator operationTimeAggregator;\n+\n+    //TODO the tests here will work in a real life scenario if the subprocesses are registered as both:\n+    // a callActivity historic activity within the process\n+    // and\n+    // a different historic process (with the same correlation id)\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.openMocks(this);\n+    }\n+\n+    @Test\n+    void testOperationTimeWithNoSubProcesses() {\n+        Mockito.when(flowableFacade.getHistoricSubProcessIds(CORRELATION_ID))\n+               .thenReturn(new ArrayList<>());\n+        HistoricProcessInstance process = createProcess(200);\n+        Mockito.when(flowableFacade.getHistoricProcessById(CORRELATION_ID))\n+               .thenReturn(process);\n+        List<HistoricActivityInstance> activities = mockProcessActivities(false,\n+                                                                          SimpleActivity.of(\"serviceTask\", 2, 100));\n+        mockQuery(activities);\n+\n+        Map<String, ProcessTime> result = operationTimeAggregator.collectProcessTimes(CORRELATION_ID);\n+        assertEquals(1, result.size());\n+        ProcessTime rootProcessTime = result.get(CORRELATION_ID);\n+\n+        ProcessTime overallTime = operationTimeAggregator.computeOverallProcessTime(CORRELATION_ID, result);\n+\n+        assertEquals(200, rootProcessTime.getProcessDuration());\n+        assertEquals(0, rootProcessTime.getDelayBetweenSteps());\n+        assertEquals(rootProcessTime, overallTime);\n+        assertFalse(overallTime.hasParallelSubProcesses());\n+    }\n+\n+    private void mockQuery(List<HistoricActivityInstance> rootProcessActivities, List<HistoricActivityInstance>... subProcessActivities) {\n+        Supplier<HistoricActivityInstanceQuery> querySupplier = () -> Mockito.mock(HistoricActivityInstanceQuery.class);\n+\n+        ProcessEngine processEngine = Mockito.mock(ProcessEngine.class);\n+        Mockito.when(flowableFacade.getProcessEngine())\n+               .thenReturn(processEngine);\n+        HistoryService historyServiceMock = Mockito.mock(HistoryService.class);\n+        Mockito.when(processEngine.getHistoryService())\n+               .thenReturn(historyServiceMock);\n+\n+        HistoricActivityInstanceQuery rootProcessQuery = querySupplier.get();\n+        Mockito.when(historyServiceMock.createHistoricActivityInstanceQuery())\n+               .thenReturn(rootProcessQuery);\n+        Mockito.when(rootProcessQuery.processInstanceId(CORRELATION_ID))\n+               .thenReturn(rootProcessQuery);\n+        Mockito.when(rootProcessQuery.list())\n+               .thenReturn(rootProcessActivities);\n+\n+        for (int i = 0; i < subProcessActivities.length; i++) {\n+            HistoricActivityInstanceQuery subProcessQuery = querySupplier.get();\n+\n+            Mockito.when(rootProcessQuery.processInstanceId(Integer.toString(i)))\n+                   .thenReturn(subProcessQuery);\n+            Mockito.when(subProcessQuery.list())\n+                   .thenReturn(subProcessActivities[i]);\n+        }\n+    }\n+\n+    @Test\n+    void testOperationTimeWithOneSubProcess() {\n+        List<String> subProcessIds = new ArrayList<>();\n+        subProcessIds.add(\"0\");\n+        Mockito.when(flowableFacade.getHistoricSubProcessIds(CORRELATION_ID))\n+               .thenReturn(subProcessIds);\n+        HistoricProcessInstance rootProcess = createProcess(400);\n+        Mockito.when(flowableFacade.getHistoricProcessById(CORRELATION_ID))\n+               .thenReturn(rootProcess);\n+        HistoricProcessInstance subProcess = createProcess(150);\n+        Mockito.when(flowableFacade.getHistoricProcessById(\"0\"))\n+               .thenReturn(subProcess);\n+\n+        List<HistoricActivityInstance> rootProcessActivities = mockProcessActivities(false,\n+                                                                                     SimpleActivity.of(\"serviceTask\", 2, 100),\n+                                                                                     SimpleActivity.of(\"callActivity\", 1, 150),\n+                                                                                     SimpleActivity.of(\"exclusiveGateway\", 1, 50));\n+        List<HistoricActivityInstance> subProcessActivities = mockProcessActivities(false,\n+                                                                                    SimpleActivity.of(\"serviceTask\", 1, 100),\n+                                                                                    SimpleActivity.of(\"exclusiveGateway\", 1, 50));\n+        mockQuery(rootProcessActivities, subProcessActivities);\n+\n+        Map<String, ProcessTime> result = operationTimeAggregator.collectProcessTimes(CORRELATION_ID);\n+        assertEquals(2, result.size());\n+        ProcessTime rootProcessTime = result.get(CORRELATION_ID);\n+        ProcessTime subProcessTime = result.get(\"0\");\n+\n+        ProcessTime overallTime = operationTimeAggregator.computeOverallProcessTime(CORRELATION_ID, result);\n+\n+        assertEquals(50, rootProcessTime.getDelayBetweenSteps());\n+        assertEquals(400, rootProcessTime.getProcessDuration());\n+        assertEquals(150, subProcessTime.getProcessDuration());\n+        assertEquals(50, subProcessTime.getDelayBetweenSteps());\n+        assertEquals(100, overallTime.getDelayBetweenSteps());\n+        assertFalse(overallTime.hasParallelSubProcesses());\n+    }\n+\n+    @Test\n+    void testOperationWithTwoSubProcesses() {\n+        List<String> subProcessIds = new ArrayList<>();\n+        subProcessIds.add(\"0\");\n+        subProcessIds.add(\"1\");\n+        Mockito.when(flowableFacade.getHistoricSubProcessIds(CORRELATION_ID))\n+               .thenReturn(subProcessIds);\n+        HistoricProcessInstance process = createProcess(0, 650);\n+        Mockito.when(flowableFacade.getHistoricProcessById(CORRELATION_ID))\n+               .thenReturn(process);\n+        HistoricProcessInstance process1 = createProcess(1, 150);\n+        Mockito.when(flowableFacade.getHistoricProcessById(\"0\"))\n+               .thenReturn(process1);\n+        HistoricProcessInstance process2 = createProcess(152, 250);\n+        Mockito.when(flowableFacade.getHistoricProcessById(\"1\"))\n+               .thenReturn(process2);\n+\n+        List<HistoricActivityInstance> rootProcessActivities = mockProcessActivities(false,\n+                                                                                     SimpleActivity.of(\"serviceTask\", 2, 100),\n+                                                                                     SimpleActivity.of(\"callActivity\", 1, 150),\n+                                                                                     SimpleActivity.of(\"callActivity\", 1, 250),\n+                                                                                     SimpleActivity.of(\"exclusiveGateway\", 1, 50));\n+        List<HistoricActivityInstance> subProcessOneActivities = mockProcessActivities(false,\n+                                                                                       SimpleActivity.of(\"serviceTask\", 1, 100),\n+                                                                                       SimpleActivity.of(\"exclusiveGateway\", 1, 50));\n+        List<HistoricActivityInstance> subProcessTwoActivities = mockProcessActivities(false,\n+                                                                                       SimpleActivity.of(\"serviceTask\", 2, 100),\n+                                                                                       SimpleActivity.of(\"exclusiveGateway\", 1, 50));\n+\n+       mockQuery(rootProcessActivities, subProcessOneActivities, subProcessTwoActivities);\n+\n+        Map<String, ProcessTime> result = operationTimeAggregator.collectProcessTimes(CORRELATION_ID);\n+        assertEquals(3, result.size());\n+        ProcessTime rootProcessTime = result.get(CORRELATION_ID);\n+        ProcessTime subProcessOneTime = result.get(\"0\");\n+        ProcessTime subProcessTwoTime = result.get(\"1\");\n+\n+        ProcessTime overallTime = operationTimeAggregator.computeOverallProcessTime(CORRELATION_ID, result);\n+\n+        assertEquals(50, rootProcessTime.getDelayBetweenSteps());\n+        assertEquals(650, rootProcessTime.getProcessDuration());\n+        assertEquals(150, subProcessOneTime.getProcessDuration());\n+        assertEquals(50, subProcessOneTime.getDelayBetweenSteps());\n+        assertEquals(250, subProcessTwoTime.getProcessDuration());\n+        assertEquals(50, subProcessTwoTime.getDelayBetweenSteps());\n+        assertEquals(150, overallTime.getDelayBetweenSteps());\n+        assertFalse(overallTime.hasParallelSubProcesses());\n+    }\n+\n+    @Test\n+    void testOperationWithTwoParallelSubProcesses() {\n+        long initialOffset = System.currentTimeMillis();\n+        List<String> subProcessIds = new ArrayList<>();\n+        subProcessIds.add(\"0\");\n+        subProcessIds.add(\"1\");\n+        Mockito.when(flowableFacade.getHistoricSubProcessIds(CORRELATION_ID))\n+               .thenReturn(subProcessIds);\n+        HistoricProcessInstance process = createProcess(initialOffset, 400);\n+        Mockito.when(flowableFacade.getHistoricProcessById(CORRELATION_ID))\n+               .thenReturn(process);\n+        HistoricProcessInstance process1 = createProcess(initialOffset + 10, 150);\n+        Mockito.when(flowableFacade.getHistoricProcessById(\"0\"))\n+               .thenReturn(process1);\n+        HistoricProcessInstance process2 = createProcess(initialOffset + 20, 250);\n+        Mockito.when(flowableFacade.getHistoricProcessById(\"1\"))\n+               .thenReturn(process2);\n+\n+        List<HistoricActivityInstance> rootProcessActivities = mockProcessActivities(true,\n+                                                                                     SimpleActivity.of(\"serviceTask\", 1, 50),\n+                                                                                     SimpleActivity.of(\"callActivity\", 1, 150),\n+                                                                                     SimpleActivity.of(\"callActivity\", 1, 250),\n+                                                                                     SimpleActivity.of(\"exclusiveGateway\", 2, 50));\n+        List<HistoricActivityInstance> subProcessOneActivities = mockProcessActivities(false,\n+                                                                                       SimpleActivity.of(\"serviceTask\", 1, 100),\n+                                                                                       SimpleActivity.of(\"exclusiveGateway\", 1, 50));\n+        List<HistoricActivityInstance> subProcessTwoActivities = mockProcessActivities(false,\n+                                                                                       SimpleActivity.of(\"serviceTask\", 2, 100),\n+                                                                                       SimpleActivity.of(\"exclusiveGateway\", 1, 50));\n+\n+        mockQuery(rootProcessActivities, subProcessOneActivities, subProcessTwoActivities);\n+\n+        Map<String, ProcessTime> result = operationTimeAggregator.collectProcessTimes(CORRELATION_ID);\n+        assertEquals(3, result.size());\n+        ProcessTime rootProcessTime = result.get(CORRELATION_ID);\n+        ProcessTime subProcessOneTime = result.get(\"0\");\n+        ProcessTime subProcessTwoTime = result.get(\"1\");\n+\n+        ProcessTime overallTime = operationTimeAggregator.computeOverallProcessTime(CORRELATION_ID, result);\n+\n+        assertEquals(200, rootProcessTime.getDelayBetweenSteps());\n+        assertEquals(400, rootProcessTime.getProcessDuration());\n+        assertEquals(150, subProcessOneTime.getProcessDuration());\n+        assertEquals(50, subProcessOneTime.getDelayBetweenSteps());\n+        assertEquals(250, subProcessTwoTime.getProcessDuration());\n+        assertEquals(50, subProcessTwoTime.getDelayBetweenSteps());\n+        assertEquals(300, overallTime.getDelayBetweenSteps());\n+        assertTrue(overallTime.hasParallelSubProcesses());\n+    }\n+\n+    private HistoricProcessInstance createProcess(long processTime) {\n+        return createProcess(0, processTime);\n+    }\n+\n+    private List<HistoricActivityInstance> mockProcessActivities(boolean parallel, SimpleActivity... activities) {\n+        long offset = System.currentTimeMillis();\n+        List<HistoricActivityInstance> result = new ArrayList<>();\n+\n+        for (SimpleActivity activity : activities) {\n+            for (int i = 1; i <= activity.numberOf; i++) {", "originalCommit": "6f2a4aeaa3353b6155f6f3752ca5ea9dfc7380be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA5MDQ2Mw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r477090463", "bodyText": "Hmmm... Here we're removing the root process time from the map, only to add its value later in:\nreturn ImmutableProcessTime.copyOf(rootProcessTime)\n                           .withDelayBetweenSteps(rootProcessTime.getDelayBetweenSteps() + overallDelayBetweenSteps);\n\nWe can do just processTimesWithoutRootProcess.get(correlationId); and then construct the result as:\nreturn ImmutableProcessTime.copyOf(rootProcessTime)\n                           .withDelayBetweenSteps(overallDelayBetweenSteps);", "author": "nictas", "createdAt": "2020-08-26T07:27:37Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/util/OperationTimeAggregator.java", "diffHunk": "@@ -10,58 +9,37 @@\n import javax.inject.Named;\n \n import org.cloudfoundry.multiapps.controller.process.flowable.FlowableFacade;\n-import org.cloudfoundry.multiapps.controller.process.util.ProcessTimeCalculator.ProcessTime;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n @Named\n public class OperationTimeAggregator {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(OperationTimeAggregator.class);\n-\n-    private ProcessTimeCalculator processTimeCalculator;\n-    private FlowableFacade flowableFacade;\n+    private final ProcessTimeCalculator processTimeCalculator;\n+    private final FlowableFacade flowableFacade;\n \n     @Inject\n     public OperationTimeAggregator(FlowableFacade flowableFacade) {\n         this.flowableFacade = flowableFacade;\n         this.processTimeCalculator = new ProcessTimeCalculator(flowableFacade);\n     }\n \n-    public void aggregateOperationTime(String correlationId) {\n+    public Map<String, ProcessTime> collectProcessTimes(String correlationId) {\n         List<String> historicSubProcesses = flowableFacade.getHistoricSubProcessIds(correlationId);\n         historicSubProcesses.add(correlationId);\n \n-        Map<String, ProcessTime> processTimesForSubProcesses = historicSubProcesses.stream()\n-                                                                                   .collect(Collectors.toMap(processId -> processId,\n-                                                                                                             processTimeCalculator::calculate));\n-        processTimesForSubProcesses.forEach((key, value) -> logProcessTimeIndividually(value, correlationId, key));\n-\n-        ProcessTime rootProcessTime = processTimesForSubProcesses.get(correlationId);\n-        logOverallProcesstime(correlationId, rootProcessTime, processTimesForSubProcesses.values());\n+        return historicSubProcesses.stream()\n+                                   .collect(Collectors.toMap(processId -> processId, processTimeCalculator::calculate));\n     }\n \n-    private void logOverallProcesstime(String correlationId, ProcessTime rootProcessTime,\n-                                       Collection<ProcessTime> subProcessesProcessTimes) {\n-        long overallDelayBetweenSteps = subProcessesProcessTimes.stream()\n-                                                                .mapToLong(ProcessTime::getDelayBetweenSteps)\n-                                                                .sum();\n-        ProcessTime overallProcessTime = ImmutableProcessTime.copyOf(rootProcessTime)\n-                                                             .withDelayBetweenSteps(rootProcessTime.getDelayBetweenSteps()\n-                                                                 + overallDelayBetweenSteps);\n-\n-        logOverallProcessTime(overallProcessTime, correlationId);\n-    }\n+    public ProcessTime computeOverallProcessTime(String correlationId, Map<String, ProcessTime> processTimes) {\n+        Map<String, ProcessTime> processTimesWithoutRootProcess = new HashMap<>(processTimes);\n+        ProcessTime rootProcessTime = processTimesWithoutRootProcess.remove(correlationId);", "originalCommit": "6f2a4aeaa3353b6155f6f3752ca5ea9dfc7380be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMwNzYxNA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r477307614", "bodyText": "Done", "author": "radito3", "createdAt": "2020-08-26T13:39:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA5MDQ2Mw=="}], "type": "inlineReview"}, {"oid": "3adfc26fb423a35e5a3f09601a0c6fc4f8c85cfb", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/3adfc26fb423a35e5a3f09601a0c6fc4f8c85cfb", "message": "Fix inaccurate calculation of delay between steps\n\nLMCROSSITXSADEPLOY-2135", "committedDate": "2020-08-26T13:57:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE3NTAwNw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r478175007", "bodyText": "This will be obvious to anyone who tries to refactor this code, so this comment is unnecessary.", "author": "nictas", "createdAt": "2020-08-27T06:23:52Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/util/ProcessTimeCalculator.java", "diffHunk": "@@ -64,24 +63,46 @@ private long calculateFilteredProcessActivitiesTime(List<HistoricActivityInstanc\n                                                         Predicate<HistoricActivityInstance> filter) {\n         return processActivities.stream()\n                                 .filter(filter)\n-                                .mapToLong(HistoricActivityInstance::getDurationInMillis)\n+                                .mapToLong(this::calculateActivityDuration)\n                                 .sum();\n     }\n \n-    private boolean isCallActivity(HistoricActivityInstance historicActivityInstance) {\n-        return CALL_ACTIVITY_TYPE.equals(historicActivityInstance.getActivityType());\n+    // unfortunately, HistoricActivityInstance and HistoricProcessInstance have no common ancestor", "originalCommit": "3adfc26fb423a35e5a3f09601a0c6fc4f8c85cfb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0NDM4OA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r478344388", "bodyText": "Removed", "author": "radito3", "createdAt": "2020-08-27T11:24:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE3NTAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE3NjE0OQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r478176149", "bodyText": "This is a bit too long of a line. It's hard to read.", "author": "nictas", "createdAt": "2020-08-27T06:25:19Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/util/ProcessTimeCalculator.java", "diffHunk": "@@ -64,24 +63,46 @@ private long calculateFilteredProcessActivitiesTime(List<HistoricActivityInstanc\n                                                         Predicate<HistoricActivityInstance> filter) {\n         return processActivities.stream()\n                                 .filter(filter)\n-                                .mapToLong(HistoricActivityInstance::getDurationInMillis)\n+                                .mapToLong(this::calculateActivityDuration)\n                                 .sum();\n     }\n \n-    private boolean isCallActivity(HistoricActivityInstance historicActivityInstance) {\n-        return CALL_ACTIVITY_TYPE.equals(historicActivityInstance.getActivityType());\n+    // unfortunately, HistoricActivityInstance and HistoricProcessInstance have no common ancestor\n+    // even though both have getStart/EndTime methods\n+    // that's why there is duplication in the methods\n+    private long calculateActivityDuration(HistoricActivityInstance activityInstance) {\n+        Date startTime = activityInstance.getStartTime();\n+        Date endTime = determineProcessActivityEndTime(activityInstance);\n+        return endTime.getTime() - startTime.getTime();\n+    }\n+\n+    private Date determineProcessActivityEndTime(HistoricActivityInstance activityInstance) {\n+        return activityInstance.getEndTime() == null ? new Date(currentTimeSupplier.getAsLong()) : activityInstance.getEndTime();\n     }\n \n     private boolean isTimerEvent(HistoricActivityInstance historicActivityInstance) {\n         return TIMER_EVENT_TYPE.equals(historicActivityInstance.getActivityType());\n     }\n \n-    @Immutable\n-    @JsonSerialize(as = ImmutableProcessTime.class)\n-    @JsonDeserialize(as = ImmutableProcessTime.class)\n-    public interface ProcessTime {\n-        long getProcessDuration();\n+    private boolean isSequenceFlow(HistoricActivityInstance historicActivityInstance) {\n+        return SEQUENCE_FLOW_TYPE.equals(historicActivityInstance.getActivityType());\n+    }\n+\n+    private boolean isGateway(HistoricActivityInstance historicActivityInstance) {\n+        String activityType = historicActivityInstance.getActivityType();\n+        return activityType != null && activityType.endsWith(GATEWAY_TYPE);\n+    }\n \n-        long getDelayBetweenSteps();\n+    private long getDelayBetweenActivities(List<HistoricActivityInstance> activities) {\n+        HistoricActivityInstance[] processActivities = activities.toArray(new HistoricActivityInstance[0]);\n+        Arrays.sort(processActivities, Comparator.comparing(HistoricActivityInstance::getStartTime));\n+        long result = 0;\n+\n+        for (int i = 0; i < processActivities.length - 1; i++) {\n+            long delay = processActivities[i + 1].getStartTime()", "originalCommit": "3adfc26fb423a35e5a3f09601a0c6fc4f8c85cfb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE4MDEyNw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r478180127", "bodyText": "Add a comment here saying that this is done, because of the possibility of parallel call activities.", "author": "nictas", "createdAt": "2020-08-27T06:30:33Z", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/util/ProcessTimeCalculator.java", "diffHunk": "@@ -64,24 +63,46 @@ private long calculateFilteredProcessActivitiesTime(List<HistoricActivityInstanc\n                                                         Predicate<HistoricActivityInstance> filter) {\n         return processActivities.stream()\n                                 .filter(filter)\n-                                .mapToLong(HistoricActivityInstance::getDurationInMillis)\n+                                .mapToLong(this::calculateActivityDuration)\n                                 .sum();\n     }\n \n-    private boolean isCallActivity(HistoricActivityInstance historicActivityInstance) {\n-        return CALL_ACTIVITY_TYPE.equals(historicActivityInstance.getActivityType());\n+    // unfortunately, HistoricActivityInstance and HistoricProcessInstance have no common ancestor\n+    // even though both have getStart/EndTime methods\n+    // that's why there is duplication in the methods\n+    private long calculateActivityDuration(HistoricActivityInstance activityInstance) {\n+        Date startTime = activityInstance.getStartTime();\n+        Date endTime = determineProcessActivityEndTime(activityInstance);\n+        return endTime.getTime() - startTime.getTime();\n+    }\n+\n+    private Date determineProcessActivityEndTime(HistoricActivityInstance activityInstance) {\n+        return activityInstance.getEndTime() == null ? new Date(currentTimeSupplier.getAsLong()) : activityInstance.getEndTime();\n     }\n \n     private boolean isTimerEvent(HistoricActivityInstance historicActivityInstance) {\n         return TIMER_EVENT_TYPE.equals(historicActivityInstance.getActivityType());\n     }\n \n-    @Immutable\n-    @JsonSerialize(as = ImmutableProcessTime.class)\n-    @JsonDeserialize(as = ImmutableProcessTime.class)\n-    public interface ProcessTime {\n-        long getProcessDuration();\n+    private boolean isSequenceFlow(HistoricActivityInstance historicActivityInstance) {\n+        return SEQUENCE_FLOW_TYPE.equals(historicActivityInstance.getActivityType());\n+    }\n+\n+    private boolean isGateway(HistoricActivityInstance historicActivityInstance) {\n+        String activityType = historicActivityInstance.getActivityType();\n+        return activityType != null && activityType.endsWith(GATEWAY_TYPE);\n+    }\n \n-        long getDelayBetweenSteps();\n+    private long getDelayBetweenActivities(List<HistoricActivityInstance> activities) {\n+        HistoricActivityInstance[] processActivities = activities.toArray(new HistoricActivityInstance[0]);\n+        Arrays.sort(processActivities, Comparator.comparing(HistoricActivityInstance::getStartTime));\n+        long result = 0;\n+\n+        for (int i = 0; i < processActivities.length - 1; i++) {\n+            long delay = processActivities[i + 1].getStartTime()\n+                                                 .getTime() - determineProcessActivityEndTime(processActivities[i]).getTime();\n+            result += delay < 0 ? 0 : delay;", "originalCommit": "3adfc26fb423a35e5a3f09601a0c6fc4f8c85cfb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0NDQ3NA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/924#discussion_r478344474", "bodyText": "Done", "author": "radito3", "createdAt": "2020-08-27T11:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE4MDEyNw=="}], "type": "inlineReview"}, {"oid": "ce82a5a3661d9abb24d8ae1d7a3575a9b2f51d01", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/ce82a5a3661d9abb24d8ae1d7a3575a9b2f51d01", "message": "Refactoring", "committedDate": "2020-08-27T13:35:03Z", "type": "commit"}, {"oid": "e7ba8a0dd6d8e173751c9491c73a46acfff70840", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/e7ba8a0dd6d8e173751c9491c73a46acfff70840", "message": "Fix inaccurate calculation of delay between steps\n\nLMCROSSITXSADEPLOY-2135", "committedDate": "2020-08-27T13:35:03Z", "type": "commit"}, {"oid": "e7ba8a0dd6d8e173751c9491c73a46acfff70840", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/e7ba8a0dd6d8e173751c9491c73a46acfff70840", "message": "Fix inaccurate calculation of delay between steps\n\nLMCROSSITXSADEPLOY-2135", "committedDate": "2020-08-27T13:35:03Z", "type": "forcePushed"}]}