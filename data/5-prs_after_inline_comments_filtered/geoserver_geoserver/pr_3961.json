{"pr_number": 3961, "pr_title": "[GEOS-9440] New WMS Vendor option \"clip\"", "pr_createdAt": "2020-01-08T18:27:46Z", "pr_url": "https://github.com/geoserver/geoserver/pull/3961", "timeline": [{"oid": "f2429f99cb342c593d5e272f8092e00f751a31ba", "url": "https://github.com/geoserver/geoserver/commit/f2429f99cb342c593d5e272f8092e00f751a31ba", "message": "[GEOS-9440] New WMS Vendor option \"clip\"\n\n-implemeted using WMS callback\n-added unit tests\n-updated documentation", "committedDate": "2020-01-08T18:24:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgwNTY1OQ==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r365805659", "bodyText": "\"validation\" normally checks for inputs, and returns an error in case they are not matching expectations.\nHere the code is checking if the request fits inside the clip, which is something the client has no control over.\nSuggested a replacement name:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static boolean validateClipParam(FeatureInfoRequestParameters params) throws Exception {\n          \n          \n            \n                public static boolean isInsideClipArea(FeatureInfoRequestParameters params) throws Exception {\n          \n      \n    \n    \n  \n\nHowever, see my other comment about the usage of this code... it likely have to be modified significantly.", "author": "aaime", "createdAt": "2020-01-13T13:34:41Z", "path": "src/wms/src/main/java/org/geoserver/wms/clip/ClipWMSGetMapCallBack.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\r\n+ * This code is licensed under the GPL 2.0 license, available at the root\r\n+ * application directory.\r\n+ */\r\n+package org.geoserver.wms.clip;\r\n+\r\n+import java.awt.Rectangle;\r\n+import java.awt.geom.AffineTransform;\r\n+import java.awt.geom.Point2D;\r\n+import java.util.logging.Level;\r\n+import java.util.logging.Logger;\r\n+import java.util.regex.Pattern;\r\n+import org.apache.commons.beanutils.BeanUtilsBean2;\r\n+import org.geoserver.wms.FeatureInfoRequestParameters;\r\n+import org.geoserver.wms.GetMapCallback;\r\n+import org.geoserver.wms.GetMapRequest;\r\n+import org.geoserver.wms.WMSMapContent;\r\n+import org.geoserver.wms.WebMap;\r\n+import org.geotools.geometry.DirectPosition2D;\r\n+import org.geotools.geometry.jts.JTS;\r\n+import org.geotools.geometry.jts.ReferencedEnvelope;\r\n+import org.geotools.geometry.jts.WKTReader2;\r\n+import org.geotools.map.FeatureLayer;\r\n+import org.geotools.map.GridReaderLayer;\r\n+import org.geotools.map.Layer;\r\n+import org.geotools.referencing.CRS;\r\n+import org.geotools.renderer.lite.RendererUtilities;\r\n+import org.geotools.util.logging.Logging;\r\n+import org.locationtech.jts.geom.Geometry;\r\n+import org.locationtech.jts.geom.MultiPolygon;\r\n+import org.locationtech.jts.geom.Polygon;\r\n+import org.opengis.referencing.crs.CoordinateReferenceSystem;\r\n+import org.opengis.referencing.operation.MathTransform;\r\n+\r\n+/** @author ImranR */\r\n+public class ClipWMSGetMapCallBack implements GetMapCallback {\r\n+\r\n+    //  private static Set<ProcessFactory> processFactories = Processors.getProcessFactories();\r\n+    private static final Logger LOGGER = Logging.getLogger(ClipWMSGetMapCallBack.class.getName());\r\n+\r\n+    private static final WKTReader2 reader = new WKTReader2();\r\n+\r\n+    private static final Pattern SRID_REGEX = Pattern.compile(\"SRID=[0-9].*\");\r\n+\r\n+    @Override\r\n+    public GetMapRequest initRequest(GetMapRequest request) {\r\n+        return request;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initMapContent(WMSMapContent mapContent) {}\r\n+\r\n+    @Override\r\n+    public Layer beforeLayer(WMSMapContent mapContent, Layer layer) {\r\n+\r\n+        // find and parse WKT geometry from WMS request\r\n+        //\r\n+        Geometry wktGeom = getClipGeometry(mapContent.getRequest());\r\n+        if (wktGeom == null) return layer;\r\n+\r\n+        Geometry bboxGeom = JTS.toGeometry(mapContent.getRequest().getBbox());\r\n+        // check: if wkt area fully contains bbox\r\n+        if (wktGeom.covers(bboxGeom)) return layer;\r\n+        try {\r\n+            if (layer instanceof FeatureLayer) {\r\n+\r\n+                // wrap around\r\n+                FeatureLayer fl = (FeatureLayer) layer;\r\n+\r\n+                ClippedFeatureSource clippedFS =\r\n+                        new ClippedFeatureSource(layer.getFeatureSource(), wktGeom);\r\n+                FeatureLayer clippedLayer =\r\n+                        new FeatureLayer(clippedFS, fl.getStyle(), fl.getTitle());\r\n+                BeanUtilsBean2.getInstance().copyProperties(clippedLayer, fl);\r\n+                fl.getUserData().putAll(layer.getUserData());\r\n+                return clippedLayer;\r\n+\r\n+            } else if (layer instanceof GridReaderLayer) {\r\n+\r\n+                GridReaderLayer gr = (GridReaderLayer) layer;\r\n+                // wrap\r\n+                CroppedGridCoverage2DReader croppedGridReader =\r\n+                        new CroppedGridCoverage2DReader(gr.getReader(), wktGeom);\r\n+                GridReaderLayer croppedGridLayer =\r\n+                        new GridReaderLayer(croppedGridReader, layer.getStyle());\r\n+                BeanUtilsBean2.getInstance().copyProperties(croppedGridLayer, gr);\r\n+                croppedGridLayer.getUserData().putAll(layer.getUserData());\r\n+                return croppedGridLayer;\r\n+            }\r\n+        } catch (Exception e) {\r\n+            LOGGER.severe(\"Error occurred while clipping layer \" + layer.getTitle());\r\n+            LOGGER.log(Level.SEVERE, e.getMessage(), e);\r\n+            return layer;\r\n+        }\r\n+\r\n+        return layer;\r\n+    }\r\n+\r\n+    @Override\r\n+    public WMSMapContent beforeRender(WMSMapContent mapContent) {\r\n+        return mapContent;\r\n+    }\r\n+\r\n+    @Override\r\n+    public WebMap finished(WebMap map) {\r\n+        return map;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void failed(Throwable t) {}\r\n+\r\n+    private static synchronized Geometry readGeometry(\r\n+            final String wkt, final CoordinateReferenceSystem mapCRS) throws Exception {\r\n+        String[] wktContents = wkt.split(\";\");\r\n+        Geometry geom = reader.read(wktContents[wktContents.length - 1]);\r\n+        // geom.setSRID(CRS.lookupEpsgCode(mapCRS, false));\r\n+        if (!(geom.getClass().isAssignableFrom(Polygon.class)\r\n+                || geom.getClass().isAssignableFrom(MultiPolygon.class))) return null;\r\n+        // parse SRID if passed\r\n+        // looking for a pattern srid=4326:Polygon(...)\r\n+        if (wktContents.length == 2 && SRID_REGEX.matcher(wktContents[0].toUpperCase()).matches()) {\r\n+            String sridString = wktContents[0].split(\"=\")[1];\r\n+            // force xy\r\n+            CoordinateReferenceSystem geomCRS = CRS.decode(\"EPSG:\" + sridString, true);\r\n+            CoordinateReferenceSystem mapCRSXY =\r\n+                    CRS.decode(\"EPSG:\" + CRS.lookupEpsgCode(mapCRS, false), true);\r\n+            if (CRS.isTransformationRequired(mapCRSXY, geomCRS)) {\r\n+                MathTransform transform = CRS.findMathTransform(geomCRS, mapCRSXY);\r\n+                geom = JTS.transform(geom, transform);\r\n+            }\r\n+        }\r\n+        // finally assign map crs\r\n+        geom.setSRID(CRS.lookupEpsgCode(mapCRS, false));\r\n+        return geom;\r\n+    }\r\n+\r\n+    public static Geometry getClipGeometry(GetMapRequest getMapRequest) {\r\n+\r\n+        String wktString = getMapRequest.getClip();\r\n+        // not found or request has no crs\r\n+        if (wktString == null || getMapRequest.getCrs() == null) return null;\r\n+        try {\r\n+            Geometry geom = readGeometry(wktString, getMapRequest.getCrs());\r\n+\r\n+            if (LOGGER.isLoggable(Level.FINE) && geom != null)\r\n+                LOGGER.fine(\"parsed Clip param to geometry \" + geom.toText());\r\n+            return geom;\r\n+        } catch (Exception e) {\r\n+            LOGGER.severe(\"Ignoring clip param,Error parsing wkt in clip parameter : \" + wktString);\r\n+            LOGGER.log(Level.SEVERE, e.getMessage(), e);\r\n+        }\r\n+        return null;\r\n+    }\r\n+\r\n+    public static boolean validateClipParam(FeatureInfoRequestParameters params) throws Exception {\r", "originalCommit": "f2429f99cb342c593d5e272f8092e00f751a31ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQwMDUxNw==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r366400517", "bodyText": "this function will be useless after clipping getFeatureInfo results", "author": "imranrajjad", "createdAt": "2020-01-14T15:22:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgwNTY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgwNjI5NA==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r365806294", "bodyText": "The normal behavior is to have parsed objects in here, as opposed to \"yet to parse\" ones. You can do the WKT parsing in GetMapKVPRequestReader.", "author": "aaime", "createdAt": "2020-01-13T13:36:03Z", "path": "src/wms/src/main/java/org/geoserver/wms/GetMapRequest.java", "diffHunk": "@@ -600,6 +600,16 @@ public void setScaleMethod(ScaleComputationMethod scaleMethod) {\n         this.optionalParams.scaleMethod = scaleMethod;\n     }\n \n+    /** @return the clip */\n+    public String getClip() {\n+        return this.optionalParams.clip;\n+    }\n+\n+    /** @param clip the clip to set */\n+    public void setClip(String clip) {", "originalCommit": "f2429f99cb342c593d5e272f8092e00f751a31ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIzMzAxNQ==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r366233015", "bodyText": "understood, parse in GetMapKVPRequestReader and set Geometry", "author": "imranrajjad", "createdAt": "2020-01-14T09:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgwNjI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgwNzQyMw==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r365807423", "bodyText": "This is good. I suggest adding a test where the geometry is in the clip, and the result gets out as expected. Ideally, it would be nice to have a request where the clip cuts the search area, so that some results are returned, and others are not, but it may be tricky to setup such test (thinking out loud, maybe by zooming out, so that the search area gets to intercept multiple source geometries).", "author": "aaime", "createdAt": "2020-01-13T13:38:35Z", "path": "src/wms/src/test/java/org/geoserver/wms/wms_1_1_1/GetFeatureInfoTest.java", "diffHunk": "@@ -1305,4 +1318,32 @@ public void testOnNodataValueGetNans() throws Exception {\n         result = getAsString(request2);\n         assertTrue(result.indexOf(\"NaN\") > 0);\n     }\n+\n+    @Test\n+    public void testClipParam() throws Exception {\n+        // a polygon away from the click area\n+        Polygon geom = JTS.toGeometry(new Envelope(0.003, 0.004, -0.002, 0.002));\n+        String wkt = geom.toText();\n+        String layer = getLayerId(MockData.FORESTS);\n+\n+        CoordinateReferenceSystem crs =\n+                getCatalog().getLayerByName(MockData.FORESTS.getLocalPart()).getResource().getCRS();\n+        int srid = CRS.lookupEpsgCode(crs, false);\n+        String request =\n+                \"wms?version=1.1.1&bbox=-0.002,-0.002,0.002,0.002&styles=&format=jpeg\"\n+                        + \"&info_format=application/json&request=GetFeatureInfo&layers=\"\n+                        + layer\n+                        + \"&query_layers=\"\n+                        + layer\n+                        + \"&width=20&height=20&x=10&y=10\"\n+                        + \"&srs=EPSG:\"\n+                        + srid\n+                        + \"&clip=\"\n+                        + wkt;\n+        String result = getAsString(request);\n+        assertNotNull(result);\n+        // assert no features were returned\n+        JSONObject responseJson = JSONObject.fromObject(result);\n+        assertTrue(responseJson.getJSONArray(\"features\").isEmpty());", "originalCommit": "f2429f99cb342c593d5e272f8092e00f751a31ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIzMzE2OQ==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r366233169", "bodyText": "will look into it", "author": "imranrajjad", "createdAt": "2020-01-14T09:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgwNzQyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxMTAyMA==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r365811020", "bodyText": "Please remove commented out code sections.", "author": "aaime", "createdAt": "2020-01-13T13:45:59Z", "path": "src/wms/src/test/java/org/geoserver/wms/wms_1_1_1/GetMapIntegrationTest.java", "diffHunk": "@@ -1828,4 +1828,103 @@ public void testWFSNGReprojection() throws Exception {\n                 wfsNGImage,\n                 300);\n     }\n+\n+    @Test\n+    public void testVendorOptionClipVector() throws Exception {\n+        URL exptectedResponse = this.getClass().getResource(\"../wms_clip_vector.png\");\n+        BufferedImage expectedImage = ImageIO.read(exptectedResponse);\n+\n+        String polygonWkt =\n+                \"POLYGON((-103.81153231351766%2038.73789567417218,-105.74512606351766%2031.78525172547746,-95.28614168851766%2028.053665204466157,-91.33106356351766%2031.260810654461146,-96.42871981351766%2038.66930662128952,-103.81153231351766%2038.73789567417218))\";\n+\n+        BufferedImage response =\n+                getAsImage(\n+                        \"wms?bbox=\"\n+                                + bbox\n+                                + \"&styles=&layers=\"\n+                                + layers\n+                                + \"&Format=image/png\"\n+                                + \"&request=GetMap\"\n+                                + \"&width=550\"\n+                                + \"&height=250\"\n+                                + \"&srs=EPSG:4326\"\n+                                + \"&version=1.1.1\"\n+                                + \"&clip=\"\n+                                + polygonWkt,\n+                        \"image/png\");\n+        ImageAssert.assertEquals(expectedImage, response, 10);\n+        // ImageIO.write(response, \"png\", new File(\"D://wms_clip_vector.png\"));", "originalCommit": "f2429f99cb342c593d5e272f8092e00f751a31ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNjYzNQ==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r367406635", "bodyText": "will remove", "author": "imranrajjad", "createdAt": "2020-01-16T13:07:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxMTAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxMTA3Ng==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r365811076", "bodyText": "Same here and other places. This kind of debug code could be useful if it can just be decommented, but here would also have to change the path, and then revert both comment and path changes... gets messy. If you want to have a quick way to see images, try out RenderedImageBrowser.showChain(....)", "author": "aaime", "createdAt": "2020-01-13T13:46:08Z", "path": "src/wms/src/test/java/org/geoserver/wms/wms_1_1_1/GetMapIntegrationTest.java", "diffHunk": "@@ -1828,4 +1828,103 @@ public void testWFSNGReprojection() throws Exception {\n                 wfsNGImage,\n                 300);\n     }\n+\n+    @Test\n+    public void testVendorOptionClipVector() throws Exception {\n+        URL exptectedResponse = this.getClass().getResource(\"../wms_clip_vector.png\");\n+        BufferedImage expectedImage = ImageIO.read(exptectedResponse);\n+\n+        String polygonWkt =\n+                \"POLYGON((-103.81153231351766%2038.73789567417218,-105.74512606351766%2031.78525172547746,-95.28614168851766%2028.053665204466157,-91.33106356351766%2031.260810654461146,-96.42871981351766%2038.66930662128952,-103.81153231351766%2038.73789567417218))\";\n+\n+        BufferedImage response =\n+                getAsImage(\n+                        \"wms?bbox=\"\n+                                + bbox\n+                                + \"&styles=&layers=\"\n+                                + layers\n+                                + \"&Format=image/png\"\n+                                + \"&request=GetMap\"\n+                                + \"&width=550\"\n+                                + \"&height=250\"\n+                                + \"&srs=EPSG:4326\"\n+                                + \"&version=1.1.1\"\n+                                + \"&clip=\"\n+                                + polygonWkt,\n+                        \"image/png\");\n+        ImageAssert.assertEquals(expectedImage, response, 10);\n+        // ImageIO.write(response, \"png\", new File(\"D://wms_clip_vector.png\"));\n+\n+        String polygonWkt900913 =\n+                \"srid=900913;POLYGON ((-11556246.91561025 4684196.6150700655, -11771493.587261306 3735154.4718813156, -10607204.772421502 3255741.4304766906, -10166927.489498887 3666666.8945377995, -10734395.987488035 4674412.675449564, -11556246.91561025 4684196.6150700655))\";\n+        response =\n+                getAsImage(\n+                        \"wms?bbox=\"\n+                                + bbox\n+                                + \"&styles=&layers=\"\n+                                + layers\n+                                + \"&Format=image/png\"\n+                                + \"&request=GetMap\"\n+                                + \"&width=550\"\n+                                + \"&height=250\"\n+                                + \"&srs=EPSG:4326\"\n+                                + \"&version=1.1.1\"\n+                                + \"&clip=\"\n+                                + polygonWkt900913,\n+                        \"image/png\");\n+        ImageAssert.assertEquals(expectedImage, response, 10);\n+        // ImageIO.write(response, \"png\", new File(\"D://wms_clip_vector_900913.png\"));", "originalCommit": "f2429f99cb342c593d5e272f8092e00f751a31ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxNjIxNw==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r365816217", "bodyText": "Looking at the clipping polygon against a full resolution topp:states I see the following:\n\nThe clipped output is:\n\nNow, the test states file is heavily generalized, so not surprised the borders are not looking the same. But what about those gray squares over the states? It's as if there was a point symbolizer, but not sure where that is coming from? population.sld does not seem to have it, nor polygon.sld. I'm likely just missing something.", "author": "aaime", "createdAt": "2020-01-13T13:56:42Z", "path": "src/wms/src/test/java/org/geoserver/wms/wms_1_3/GetMapIntegrationTest.java", "diffHunk": "@@ -653,4 +654,104 @@ public void testAllowedMimeTypes() throws Exception {\n \n         assertTrue(result.indexOf(\"OpenLayers\") > 0);\n     }\n+\n+    @Test\n+    public void testVendorOptionClipVector() throws Exception {\n+        String bbox130 = \"24,-130,50,-66\";\n+        URL exptectedResponse = this.getClass().getResource(\"../wms_clip_vector.png\");\n+        BufferedImage expectedImage = ImageIO.read(exptectedResponse);\n+\n+        String polygonWkt =\n+                \"POLYGON((-103.81153231351766%2038.73789567417218,-105.74512606351766%2031.78525172547746,-95.28614168851766%2028.053665204466157,-91.33106356351766%2031.260810654461146,-96.42871981351766%2038.66930662128952,-103.81153231351766%2038.73789567417218))\";\n+\n+        BufferedImage response =", "originalCommit": "f2429f99cb342c593d5e272f8092e00f751a31ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxNzQ0Nw==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r367417447", "bodyText": "its the sld, I will fix this by applying the simple polygon style", "author": "imranrajjad", "createdAt": "2020-01-16T13:31:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxNjIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxNjg1OQ==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r365816859", "bodyText": "Can you use a non rectangular mask here? Just to prove it's not just a rectangular clip, but it works fine with other shapes as well?", "author": "aaime", "createdAt": "2020-01-13T13:58:00Z", "path": "src/wms/src/test/java/org/geoserver/wms/wms_1_3/GetMapIntegrationTest.java", "diffHunk": "@@ -653,4 +654,104 @@ public void testAllowedMimeTypes() throws Exception {\n \n         assertTrue(result.indexOf(\"OpenLayers\") > 0);\n     }\n+\n+    @Test\n+    public void testVendorOptionClipVector() throws Exception {\n+        String bbox130 = \"24,-130,50,-66\";\n+        URL exptectedResponse = this.getClass().getResource(\"../wms_clip_vector.png\");\n+        BufferedImage expectedImage = ImageIO.read(exptectedResponse);\n+\n+        String polygonWkt =\n+                \"POLYGON((-103.81153231351766%2038.73789567417218,-105.74512606351766%2031.78525172547746,-95.28614168851766%2028.053665204466157,-91.33106356351766%2031.260810654461146,-96.42871981351766%2038.66930662128952,-103.81153231351766%2038.73789567417218))\";\n+\n+        BufferedImage response =\n+                getAsImage(\n+                        \"wms?bbox=\"\n+                                + bbox130\n+                                + \"&styles=&layers=\"\n+                                + layers\n+                                + \"&Format=image/png\"\n+                                + \"&request=GetMap\"\n+                                + \"&width=550\"\n+                                + \"&height=250\"\n+                                + \"&srs=EPSG:4326\"\n+                                + \"&version=1.3.0\"\n+                                + \"&clip=\"\n+                                + polygonWkt,\n+                        \"image/png\");\n+        ImageAssert.assertEquals(expectedImage, response, 100);\n+        // ImageIO.write(response, \"png\", new File(\"D://wms_clip_vector.png\"));\n+\n+        String polygonWkt900913 =\n+                \"srid=900913;POLYGON ((-11556246.91561025 4684196.6150700655, -11771493.587261306 3735154.4718813156, -10607204.772421502 3255741.4304766906, -10166927.489498887 3666666.8945377995, -10734395.987488035 4674412.675449564, -11556246.91561025 4684196.6150700655))\";\n+        response =\n+                getAsImage(\n+                        \"wms?bbox=\"\n+                                + bbox130\n+                                + \"&styles=&layers=\"\n+                                + layers\n+                                + \"&Format=image/png\"\n+                                + \"&request=GetMap\"\n+                                + \"&width=550\"\n+                                + \"&height=250\"\n+                                + \"&srs=EPSG:4326\"\n+                                + \"&version=1.3.0\"\n+                                + \"&clip=\"\n+                                + polygonWkt900913,\n+                        \"image/png\");\n+        ImageAssert.assertEquals(expectedImage, response, 100);\n+        // ImageIO.write(response, \"png\", new File(\"D://wms_clip_vector_900913.png\"));\n+    }\n+\n+    @Test\n+    public void testVendorOptionClipRaster() throws Exception {\n+\n+        URL exptectedResponse = this.getClass().getResource(\"../wms_clip_raster.png\");\n+        BufferedImage expectedImage = ImageIO.read(exptectedResponse);\n+\n+        // EU south of Schengen\n+        String rasterMask =", "originalCommit": "f2429f99cb342c593d5e272f8092e00f751a31ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNjgxNg==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r367406816", "bodyText": "will do", "author": "imranrajjad", "createdAt": "2020-01-16T13:08:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxNjg1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxNzgwNw==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r365817807", "bodyText": "Please avoid commented out sections", "author": "aaime", "createdAt": "2020-01-13T14:00:05Z", "path": "src/wms/src/main/java/org/geoserver/wms/clip/ClipWMSGetMapCallBack.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\r\n+ * This code is licensed under the GPL 2.0 license, available at the root\r\n+ * application directory.\r\n+ */\r\n+package org.geoserver.wms.clip;\r\n+\r\n+import java.awt.Rectangle;\r\n+import java.awt.geom.AffineTransform;\r\n+import java.awt.geom.Point2D;\r\n+import java.util.logging.Level;\r\n+import java.util.logging.Logger;\r\n+import java.util.regex.Pattern;\r\n+import org.apache.commons.beanutils.BeanUtilsBean2;\r\n+import org.geoserver.wms.FeatureInfoRequestParameters;\r\n+import org.geoserver.wms.GetMapCallback;\r\n+import org.geoserver.wms.GetMapRequest;\r\n+import org.geoserver.wms.WMSMapContent;\r\n+import org.geoserver.wms.WebMap;\r\n+import org.geotools.geometry.DirectPosition2D;\r\n+import org.geotools.geometry.jts.JTS;\r\n+import org.geotools.geometry.jts.ReferencedEnvelope;\r\n+import org.geotools.geometry.jts.WKTReader2;\r\n+import org.geotools.map.FeatureLayer;\r\n+import org.geotools.map.GridReaderLayer;\r\n+import org.geotools.map.Layer;\r\n+import org.geotools.referencing.CRS;\r\n+import org.geotools.renderer.lite.RendererUtilities;\r\n+import org.geotools.util.logging.Logging;\r\n+import org.locationtech.jts.geom.Geometry;\r\n+import org.locationtech.jts.geom.MultiPolygon;\r\n+import org.locationtech.jts.geom.Polygon;\r\n+import org.opengis.referencing.crs.CoordinateReferenceSystem;\r\n+import org.opengis.referencing.operation.MathTransform;\r\n+\r\n+/** @author ImranR */\r\n+public class ClipWMSGetMapCallBack implements GetMapCallback {\r\n+\r\n+    //  private static Set<ProcessFactory> processFactories = Processors.getProcessFactories();\r\n+    private static final Logger LOGGER = Logging.getLogger(ClipWMSGetMapCallBack.class.getName());\r\n+\r\n+    private static final WKTReader2 reader = new WKTReader2();\r\n+\r\n+    private static final Pattern SRID_REGEX = Pattern.compile(\"SRID=[0-9].*\");\r\n+\r\n+    @Override\r\n+    public GetMapRequest initRequest(GetMapRequest request) {\r\n+        return request;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initMapContent(WMSMapContent mapContent) {}\r\n+\r\n+    @Override\r\n+    public Layer beforeLayer(WMSMapContent mapContent, Layer layer) {\r\n+\r\n+        // find and parse WKT geometry from WMS request\r\n+        //\r\n+        Geometry wktGeom = getClipGeometry(mapContent.getRequest());\r\n+        if (wktGeom == null) return layer;\r\n+\r\n+        Geometry bboxGeom = JTS.toGeometry(mapContent.getRequest().getBbox());\r\n+        // check: if wkt area fully contains bbox\r\n+        if (wktGeom.covers(bboxGeom)) return layer;\r\n+        try {\r\n+            if (layer instanceof FeatureLayer) {\r\n+\r\n+                // wrap around\r\n+                FeatureLayer fl = (FeatureLayer) layer;\r\n+\r\n+                ClippedFeatureSource clippedFS =\r\n+                        new ClippedFeatureSource(layer.getFeatureSource(), wktGeom);\r\n+                FeatureLayer clippedLayer =\r\n+                        new FeatureLayer(clippedFS, fl.getStyle(), fl.getTitle());\r\n+                BeanUtilsBean2.getInstance().copyProperties(clippedLayer, fl);\r\n+                fl.getUserData().putAll(layer.getUserData());\r\n+                return clippedLayer;\r\n+\r\n+            } else if (layer instanceof GridReaderLayer) {\r\n+\r\n+                GridReaderLayer gr = (GridReaderLayer) layer;\r\n+                // wrap\r\n+                CroppedGridCoverage2DReader croppedGridReader =\r\n+                        new CroppedGridCoverage2DReader(gr.getReader(), wktGeom);\r\n+                GridReaderLayer croppedGridLayer =\r\n+                        new GridReaderLayer(croppedGridReader, layer.getStyle());\r\n+                BeanUtilsBean2.getInstance().copyProperties(croppedGridLayer, gr);\r\n+                croppedGridLayer.getUserData().putAll(layer.getUserData());\r\n+                return croppedGridLayer;\r\n+            }\r\n+        } catch (Exception e) {\r\n+            LOGGER.severe(\"Error occurred while clipping layer \" + layer.getTitle());\r\n+            LOGGER.log(Level.SEVERE, e.getMessage(), e);\r\n+            return layer;\r\n+        }\r\n+\r\n+        return layer;\r\n+    }\r\n+\r\n+    @Override\r\n+    public WMSMapContent beforeRender(WMSMapContent mapContent) {\r\n+        return mapContent;\r\n+    }\r\n+\r\n+    @Override\r\n+    public WebMap finished(WebMap map) {\r\n+        return map;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void failed(Throwable t) {}\r\n+\r\n+    private static synchronized Geometry readGeometry(\r\n+            final String wkt, final CoordinateReferenceSystem mapCRS) throws Exception {\r\n+        String[] wktContents = wkt.split(\";\");\r\n+        Geometry geom = reader.read(wktContents[wktContents.length - 1]);\r\n+        // geom.setSRID(CRS.lookupEpsgCode(mapCRS, false));\r", "originalCommit": "f2429f99cb342c593d5e272f8092e00f751a31ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxODQzNQ==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r365818435", "bodyText": "Throw a service exception in this case, indicating that the content of \"clip\" is invalid.\nSomething like (untested): throw new ServiceException(\"Clip must be a polygon or multipolygon\", \"InvalidParameterValue\", \"clip\")", "author": "aaime", "createdAt": "2020-01-13T14:01:18Z", "path": "src/wms/src/main/java/org/geoserver/wms/clip/ClipWMSGetMapCallBack.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\r\n+ * This code is licensed under the GPL 2.0 license, available at the root\r\n+ * application directory.\r\n+ */\r\n+package org.geoserver.wms.clip;\r\n+\r\n+import java.awt.Rectangle;\r\n+import java.awt.geom.AffineTransform;\r\n+import java.awt.geom.Point2D;\r\n+import java.util.logging.Level;\r\n+import java.util.logging.Logger;\r\n+import java.util.regex.Pattern;\r\n+import org.apache.commons.beanutils.BeanUtilsBean2;\r\n+import org.geoserver.wms.FeatureInfoRequestParameters;\r\n+import org.geoserver.wms.GetMapCallback;\r\n+import org.geoserver.wms.GetMapRequest;\r\n+import org.geoserver.wms.WMSMapContent;\r\n+import org.geoserver.wms.WebMap;\r\n+import org.geotools.geometry.DirectPosition2D;\r\n+import org.geotools.geometry.jts.JTS;\r\n+import org.geotools.geometry.jts.ReferencedEnvelope;\r\n+import org.geotools.geometry.jts.WKTReader2;\r\n+import org.geotools.map.FeatureLayer;\r\n+import org.geotools.map.GridReaderLayer;\r\n+import org.geotools.map.Layer;\r\n+import org.geotools.referencing.CRS;\r\n+import org.geotools.renderer.lite.RendererUtilities;\r\n+import org.geotools.util.logging.Logging;\r\n+import org.locationtech.jts.geom.Geometry;\r\n+import org.locationtech.jts.geom.MultiPolygon;\r\n+import org.locationtech.jts.geom.Polygon;\r\n+import org.opengis.referencing.crs.CoordinateReferenceSystem;\r\n+import org.opengis.referencing.operation.MathTransform;\r\n+\r\n+/** @author ImranR */\r\n+public class ClipWMSGetMapCallBack implements GetMapCallback {\r\n+\r\n+    //  private static Set<ProcessFactory> processFactories = Processors.getProcessFactories();\r\n+    private static final Logger LOGGER = Logging.getLogger(ClipWMSGetMapCallBack.class.getName());\r\n+\r\n+    private static final WKTReader2 reader = new WKTReader2();\r\n+\r\n+    private static final Pattern SRID_REGEX = Pattern.compile(\"SRID=[0-9].*\");\r\n+\r\n+    @Override\r\n+    public GetMapRequest initRequest(GetMapRequest request) {\r\n+        return request;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initMapContent(WMSMapContent mapContent) {}\r\n+\r\n+    @Override\r\n+    public Layer beforeLayer(WMSMapContent mapContent, Layer layer) {\r\n+\r\n+        // find and parse WKT geometry from WMS request\r\n+        //\r\n+        Geometry wktGeom = getClipGeometry(mapContent.getRequest());\r\n+        if (wktGeom == null) return layer;\r\n+\r\n+        Geometry bboxGeom = JTS.toGeometry(mapContent.getRequest().getBbox());\r\n+        // check: if wkt area fully contains bbox\r\n+        if (wktGeom.covers(bboxGeom)) return layer;\r\n+        try {\r\n+            if (layer instanceof FeatureLayer) {\r\n+\r\n+                // wrap around\r\n+                FeatureLayer fl = (FeatureLayer) layer;\r\n+\r\n+                ClippedFeatureSource clippedFS =\r\n+                        new ClippedFeatureSource(layer.getFeatureSource(), wktGeom);\r\n+                FeatureLayer clippedLayer =\r\n+                        new FeatureLayer(clippedFS, fl.getStyle(), fl.getTitle());\r\n+                BeanUtilsBean2.getInstance().copyProperties(clippedLayer, fl);\r\n+                fl.getUserData().putAll(layer.getUserData());\r\n+                return clippedLayer;\r\n+\r\n+            } else if (layer instanceof GridReaderLayer) {\r\n+\r\n+                GridReaderLayer gr = (GridReaderLayer) layer;\r\n+                // wrap\r\n+                CroppedGridCoverage2DReader croppedGridReader =\r\n+                        new CroppedGridCoverage2DReader(gr.getReader(), wktGeom);\r\n+                GridReaderLayer croppedGridLayer =\r\n+                        new GridReaderLayer(croppedGridReader, layer.getStyle());\r\n+                BeanUtilsBean2.getInstance().copyProperties(croppedGridLayer, gr);\r\n+                croppedGridLayer.getUserData().putAll(layer.getUserData());\r\n+                return croppedGridLayer;\r\n+            }\r\n+        } catch (Exception e) {\r\n+            LOGGER.severe(\"Error occurred while clipping layer \" + layer.getTitle());\r\n+            LOGGER.log(Level.SEVERE, e.getMessage(), e);\r\n+            return layer;\r\n+        }\r\n+\r\n+        return layer;\r\n+    }\r\n+\r\n+    @Override\r\n+    public WMSMapContent beforeRender(WMSMapContent mapContent) {\r\n+        return mapContent;\r\n+    }\r\n+\r\n+    @Override\r\n+    public WebMap finished(WebMap map) {\r\n+        return map;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void failed(Throwable t) {}\r\n+\r\n+    private static synchronized Geometry readGeometry(\r\n+            final String wkt, final CoordinateReferenceSystem mapCRS) throws Exception {\r\n+        String[] wktContents = wkt.split(\";\");\r\n+        Geometry geom = reader.read(wktContents[wktContents.length - 1]);\r\n+        // geom.setSRID(CRS.lookupEpsgCode(mapCRS, false));\r\n+        if (!(geom.getClass().isAssignableFrom(Polygon.class)\r", "originalCommit": "f2429f99cb342c593d5e272f8092e00f751a31ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgyMDY5Nw==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r365820697", "bodyText": "Does it work fine if the request is a WMS 1.3, typically with a flipped bbox?  I don't see tests covering this case (clip fully containing map area). Please choose a bbox that would not be a match for the clip if the flipped version is used. (e.g., not 20,20,40,40 :-D ).", "author": "aaime", "createdAt": "2020-01-13T14:06:02Z", "path": "src/wms/src/main/java/org/geoserver/wms/clip/ClipWMSGetMapCallBack.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\r\n+ * This code is licensed under the GPL 2.0 license, available at the root\r\n+ * application directory.\r\n+ */\r\n+package org.geoserver.wms.clip;\r\n+\r\n+import java.awt.Rectangle;\r\n+import java.awt.geom.AffineTransform;\r\n+import java.awt.geom.Point2D;\r\n+import java.util.logging.Level;\r\n+import java.util.logging.Logger;\r\n+import java.util.regex.Pattern;\r\n+import org.apache.commons.beanutils.BeanUtilsBean2;\r\n+import org.geoserver.wms.FeatureInfoRequestParameters;\r\n+import org.geoserver.wms.GetMapCallback;\r\n+import org.geoserver.wms.GetMapRequest;\r\n+import org.geoserver.wms.WMSMapContent;\r\n+import org.geoserver.wms.WebMap;\r\n+import org.geotools.geometry.DirectPosition2D;\r\n+import org.geotools.geometry.jts.JTS;\r\n+import org.geotools.geometry.jts.ReferencedEnvelope;\r\n+import org.geotools.geometry.jts.WKTReader2;\r\n+import org.geotools.map.FeatureLayer;\r\n+import org.geotools.map.GridReaderLayer;\r\n+import org.geotools.map.Layer;\r\n+import org.geotools.referencing.CRS;\r\n+import org.geotools.renderer.lite.RendererUtilities;\r\n+import org.geotools.util.logging.Logging;\r\n+import org.locationtech.jts.geom.Geometry;\r\n+import org.locationtech.jts.geom.MultiPolygon;\r\n+import org.locationtech.jts.geom.Polygon;\r\n+import org.opengis.referencing.crs.CoordinateReferenceSystem;\r\n+import org.opengis.referencing.operation.MathTransform;\r\n+\r\n+/** @author ImranR */\r\n+public class ClipWMSGetMapCallBack implements GetMapCallback {\r\n+\r\n+    //  private static Set<ProcessFactory> processFactories = Processors.getProcessFactories();\r\n+    private static final Logger LOGGER = Logging.getLogger(ClipWMSGetMapCallBack.class.getName());\r\n+\r\n+    private static final WKTReader2 reader = new WKTReader2();\r\n+\r\n+    private static final Pattern SRID_REGEX = Pattern.compile(\"SRID=[0-9].*\");\r\n+\r\n+    @Override\r\n+    public GetMapRequest initRequest(GetMapRequest request) {\r\n+        return request;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initMapContent(WMSMapContent mapContent) {}\r\n+\r\n+    @Override\r\n+    public Layer beforeLayer(WMSMapContent mapContent, Layer layer) {\r\n+\r\n+        // find and parse WKT geometry from WMS request\r\n+        //\r\n+        Geometry wktGeom = getClipGeometry(mapContent.getRequest());\r\n+        if (wktGeom == null) return layer;\r\n+\r\n+        Geometry bboxGeom = JTS.toGeometry(mapContent.getRequest().getBbox());\r\n+        // check: if wkt area fully contains bbox\r\n+        if (wktGeom.covers(bboxGeom)) return layer;\r", "originalCommit": "f2429f99cb342c593d5e272f8092e00f751a31ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMwNzg0Ng==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r366307846", "bodyText": "there are WMS 1.3.0 unit tests also with flipped BBOX", "author": "imranrajjad", "createdAt": "2020-01-14T12:21:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgyMDY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzODA2Mw==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r365838063", "bodyText": "Why static?", "author": "aaime", "createdAt": "2020-01-13T14:38:29Z", "path": "src/wms/src/main/java/org/geoserver/wms/clip/ClippedFeatureSource.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\r\n+ * This code is licensed under the GPL 2.0 license, available at the root\r\n+ * application directory.\r\n+ */\r\n+package org.geoserver.wms.clip;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.logging.Level;\r\n+import java.util.logging.Logger;\r\n+import org.geoserver.security.decorators.DecoratingFeatureSource;\r\n+import org.geotools.data.FeatureSource;\r\n+import org.geotools.data.Query;\r\n+import org.geotools.data.simple.SimpleFeatureCollection;\r\n+import org.geotools.feature.FeatureCollection;\r\n+import org.geotools.geometry.jts.JTS;\r\n+import org.geotools.geometry.jts.ReferencedEnvelope;\r\n+import org.geotools.process.vector.ClipProcess;\r\n+import org.geotools.referencing.CRS;\r\n+import org.geotools.util.logging.Logging;\r\n+import org.locationtech.jts.geom.Geometry;\r\n+import org.opengis.filter.Filter;\r\n+import org.opengis.referencing.crs.CoordinateReferenceSystem;\r\n+import org.opengis.referencing.operation.MathTransform;\r\n+\r\n+/** @author ImranR */\r\n+public class ClippedFeatureSource extends DecoratingFeatureSource {\r\n+    static final Logger LOGGER = Logging.getLogger(ClippedFeatureSource.class.getCanonicalName());\r\n+    static final ClipProcess clipProcess = new ClipProcess();\r\n+\r\n+    Geometry clip;\r\n+\r\n+    public ClippedFeatureSource(FeatureSource delegate, Geometry clipGeometry) {\r\n+        super(delegate);\r\n+        this.clip = reproject(delegate.getInfo().getCRS(), clipGeometry);\r\n+    }\r\n+\r\n+    private Geometry reproject(CoordinateReferenceSystem fsCRS, Geometry clipGeom) {\r\n+        // re-project if required\r\n+        try {\r\n+            CoordinateReferenceSystem geomCRS = CRS.decode(\"EPSG:\" + clipGeom.getSRID());\r\n+            if (CRS.isTransformationRequired(geomCRS, fsCRS)) {\r\n+                MathTransform mt = CRS.findMathTransform(geomCRS, fsCRS);\r\n+                clipGeom = JTS.transform(clipGeom, mt);\r\n+                clipGeom.setSRID(CRS.lookupEpsgCode(fsCRS, false));\r\n+            }\r\n+        } catch (Exception e) {\r\n+            LOGGER.log(Level.SEVERE, \"failed to reproject \" + clipGeom.toText());\r\n+            LOGGER.log(Level.SEVERE, e.getMessage(), e);\r\n+        }\r\n+\r\n+        return clipGeom;\r\n+    }\r\n+\r\n+    @Override\r\n+    public ReferencedEnvelope getBounds() throws IOException {\r\n+        return this.getFeatures().getBounds();\r\n+    }\r\n+\r\n+    @Override\r\n+    public ReferencedEnvelope getBounds(Query query) throws IOException {\r\n+        return this.getFeatures(query).getBounds();\r\n+    }\r\n+\r\n+    @Override\r\n+    public int getCount(Query query) throws IOException {\r\n+        return this.getFeatures(query).size();\r\n+    }\r\n+\r\n+    @Override\r\n+    public FeatureCollection getFeatures() throws IOException {\r\n+        FeatureCollection fc = super.getFeatures();\r\n+        if (SimpleFeatureCollection.class.isAssignableFrom(fc.getClass())) {\r\n+            return getClippedCollection((SimpleFeatureCollection) fc, clip);\r\n+        }\r\n+        return fc;\r\n+    }\r\n+\r\n+    @Override\r\n+    public FeatureCollection getFeatures(Filter filter) throws IOException {\r\n+        FeatureCollection fc = super.getFeatures(filter);\r\n+        if (SimpleFeatureCollection.class.isAssignableFrom(fc.getClass())) {\r\n+            return getClippedCollection((SimpleFeatureCollection) fc, clip);\r\n+        }\r\n+        return fc;\r\n+    }\r\n+\r\n+    @Override\r\n+    public FeatureCollection getFeatures(Query query) throws IOException {\r\n+        FeatureCollection fc = super.getFeatures(query);\r\n+        if (SimpleFeatureCollection.class.isAssignableFrom(fc.getClass())) {\r\n+            return getClippedCollection((SimpleFeatureCollection) fc, clip);\r\n+        }\r\n+        return fc;\r\n+    }\r\n+\r\n+    private static synchronized FeatureCollection getClippedCollection(\r", "originalCommit": "f2429f99cb342c593d5e272f8092e00f751a31ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1MzQ3OQ==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r366853479", "bodyText": "@aaime To avoid instantiating a new ClipProcess for each OWS request separately.", "author": "imranrajjad", "createdAt": "2020-01-15T12:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzODA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzOTQ4Nw==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r365839487", "bodyText": "Ouch ouch, so this won't work for complex features? That might be an issue, as they are also used for WMS. At the very least this limitation should be clearly documented (building a clipping wrapper for complex features can be indeed signifcant work, complex features lack the same set of classes supporting copying/wrapping/rebuilding ).", "author": "aaime", "createdAt": "2020-01-13T14:41:11Z", "path": "src/wms/src/main/java/org/geoserver/wms/clip/ClippedFeatureSource.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\r\n+ * This code is licensed under the GPL 2.0 license, available at the root\r\n+ * application directory.\r\n+ */\r\n+package org.geoserver.wms.clip;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.logging.Level;\r\n+import java.util.logging.Logger;\r\n+import org.geoserver.security.decorators.DecoratingFeatureSource;\r\n+import org.geotools.data.FeatureSource;\r\n+import org.geotools.data.Query;\r\n+import org.geotools.data.simple.SimpleFeatureCollection;\r\n+import org.geotools.feature.FeatureCollection;\r\n+import org.geotools.geometry.jts.JTS;\r\n+import org.geotools.geometry.jts.ReferencedEnvelope;\r\n+import org.geotools.process.vector.ClipProcess;\r\n+import org.geotools.referencing.CRS;\r\n+import org.geotools.util.logging.Logging;\r\n+import org.locationtech.jts.geom.Geometry;\r\n+import org.opengis.filter.Filter;\r\n+import org.opengis.referencing.crs.CoordinateReferenceSystem;\r\n+import org.opengis.referencing.operation.MathTransform;\r\n+\r\n+/** @author ImranR */\r\n+public class ClippedFeatureSource extends DecoratingFeatureSource {\r\n+    static final Logger LOGGER = Logging.getLogger(ClippedFeatureSource.class.getCanonicalName());\r\n+    static final ClipProcess clipProcess = new ClipProcess();\r\n+\r\n+    Geometry clip;\r\n+\r\n+    public ClippedFeatureSource(FeatureSource delegate, Geometry clipGeometry) {\r\n+        super(delegate);\r\n+        this.clip = reproject(delegate.getInfo().getCRS(), clipGeometry);\r\n+    }\r\n+\r\n+    private Geometry reproject(CoordinateReferenceSystem fsCRS, Geometry clipGeom) {\r\n+        // re-project if required\r\n+        try {\r\n+            CoordinateReferenceSystem geomCRS = CRS.decode(\"EPSG:\" + clipGeom.getSRID());\r\n+            if (CRS.isTransformationRequired(geomCRS, fsCRS)) {\r\n+                MathTransform mt = CRS.findMathTransform(geomCRS, fsCRS);\r\n+                clipGeom = JTS.transform(clipGeom, mt);\r\n+                clipGeom.setSRID(CRS.lookupEpsgCode(fsCRS, false));\r\n+            }\r\n+        } catch (Exception e) {\r\n+            LOGGER.log(Level.SEVERE, \"failed to reproject \" + clipGeom.toText());\r\n+            LOGGER.log(Level.SEVERE, e.getMessage(), e);\r\n+        }\r\n+\r\n+        return clipGeom;\r\n+    }\r\n+\r\n+    @Override\r\n+    public ReferencedEnvelope getBounds() throws IOException {\r\n+        return this.getFeatures().getBounds();\r\n+    }\r\n+\r\n+    @Override\r\n+    public ReferencedEnvelope getBounds(Query query) throws IOException {\r\n+        return this.getFeatures(query).getBounds();\r\n+    }\r\n+\r\n+    @Override\r\n+    public int getCount(Query query) throws IOException {\r\n+        return this.getFeatures(query).size();\r\n+    }\r\n+\r\n+    @Override\r\n+    public FeatureCollection getFeatures() throws IOException {\r\n+        FeatureCollection fc = super.getFeatures();\r\n+        if (SimpleFeatureCollection.class.isAssignableFrom(fc.getClass())) {\r", "originalCommit": "f2429f99cb342c593d5e272f8092e00f751a31ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIxNjkyNw==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r366216927", "bodyText": "will include in documentation", "author": "imranrajjad", "createdAt": "2020-01-14T09:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzOTQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MDkwOA==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r365840908", "bodyText": "Somewhat inefficient here.. is it getting used at all? You could get the bounds of the original collection, turn into a polygon, intersect with the clip, and return the bounds of the resulting geometry.", "author": "aaime", "createdAt": "2020-01-13T14:43:46Z", "path": "src/wms/src/main/java/org/geoserver/wms/clip/ClippedFeatureSource.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\r\n+ * This code is licensed under the GPL 2.0 license, available at the root\r\n+ * application directory.\r\n+ */\r\n+package org.geoserver.wms.clip;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.logging.Level;\r\n+import java.util.logging.Logger;\r\n+import org.geoserver.security.decorators.DecoratingFeatureSource;\r\n+import org.geotools.data.FeatureSource;\r\n+import org.geotools.data.Query;\r\n+import org.geotools.data.simple.SimpleFeatureCollection;\r\n+import org.geotools.feature.FeatureCollection;\r\n+import org.geotools.geometry.jts.JTS;\r\n+import org.geotools.geometry.jts.ReferencedEnvelope;\r\n+import org.geotools.process.vector.ClipProcess;\r\n+import org.geotools.referencing.CRS;\r\n+import org.geotools.util.logging.Logging;\r\n+import org.locationtech.jts.geom.Geometry;\r\n+import org.opengis.filter.Filter;\r\n+import org.opengis.referencing.crs.CoordinateReferenceSystem;\r\n+import org.opengis.referencing.operation.MathTransform;\r\n+\r\n+/** @author ImranR */\r\n+public class ClippedFeatureSource extends DecoratingFeatureSource {\r\n+    static final Logger LOGGER = Logging.getLogger(ClippedFeatureSource.class.getCanonicalName());\r\n+    static final ClipProcess clipProcess = new ClipProcess();\r\n+\r\n+    Geometry clip;\r\n+\r\n+    public ClippedFeatureSource(FeatureSource delegate, Geometry clipGeometry) {\r\n+        super(delegate);\r\n+        this.clip = reproject(delegate.getInfo().getCRS(), clipGeometry);\r\n+    }\r\n+\r\n+    private Geometry reproject(CoordinateReferenceSystem fsCRS, Geometry clipGeom) {\r\n+        // re-project if required\r\n+        try {\r\n+            CoordinateReferenceSystem geomCRS = CRS.decode(\"EPSG:\" + clipGeom.getSRID());\r\n+            if (CRS.isTransformationRequired(geomCRS, fsCRS)) {\r\n+                MathTransform mt = CRS.findMathTransform(geomCRS, fsCRS);\r\n+                clipGeom = JTS.transform(clipGeom, mt);\r\n+                clipGeom.setSRID(CRS.lookupEpsgCode(fsCRS, false));\r\n+            }\r\n+        } catch (Exception e) {\r\n+            LOGGER.log(Level.SEVERE, \"failed to reproject \" + clipGeom.toText());\r\n+            LOGGER.log(Level.SEVERE, e.getMessage(), e);\r\n+        }\r\n+\r\n+        return clipGeom;\r\n+    }\r\n+\r\n+    @Override\r\n+    public ReferencedEnvelope getBounds() throws IOException {\r\n+        return this.getFeatures().getBounds();\r", "originalCommit": "f2429f99cb342c593d5e272f8092e00f751a31ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIxNzE1OQ==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r366217159", "bodyText": "understood, will do", "author": "imranrajjad", "createdAt": "2020-01-14T09:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MDkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MTYwMQ==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r365841601", "bodyText": "Shouldn't you intersect with the original envelope first? Some unit tests for this class (and the feature equivalent) would not hurt.", "author": "aaime", "createdAt": "2020-01-13T14:45:06Z", "path": "src/wms/src/main/java/org/geoserver/wms/clip/CroppedGridCoverage2DReader.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\r\n+ * This code is licensed under the GPL 2.0 license, available at the root\r\n+ * application directory.\r\n+ */\r\n+package org.geoserver.wms.clip;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.logging.Level;\r\n+import java.util.logging.Logger;\r\n+import org.geoserver.security.decorators.DecoratingGridCoverage2DReader;\r\n+import org.geotools.coverage.grid.GridCoverage2D;\r\n+import org.geotools.coverage.grid.io.GridCoverage2DReader;\r\n+import org.geotools.coverage.processing.CoverageProcessor;\r\n+import org.geotools.coverage.processing.operation.Crop;\r\n+import org.geotools.data.ResourceInfo;\r\n+import org.geotools.data.ServiceInfo;\r\n+import org.geotools.geometry.GeneralEnvelope;\r\n+import org.geotools.geometry.jts.JTS;\r\n+import org.geotools.referencing.CRS;\r\n+import org.geotools.util.factory.Hints;\r\n+import org.geotools.util.logging.Logging;\r\n+import org.locationtech.jts.geom.Geometry;\r\n+import org.opengis.parameter.GeneralParameterValue;\r\n+import org.opengis.parameter.ParameterValueGroup;\r\n+import org.opengis.referencing.crs.CoordinateReferenceSystem;\r\n+import org.opengis.referencing.operation.MathTransform;\r\n+\r\n+/** @author ImranR */\r\n+public class CroppedGridCoverage2DReader extends DecoratingGridCoverage2DReader {\r\n+    /** Parameters used to control the {@link Crop} operation. */\r\n+    private static final ParameterValueGroup cropParams;\r\n+\r\n+    static final Logger LOGGER =\r\n+            Logging.getLogger(CroppedGridCoverage2DReader.class.getCanonicalName());\r\n+\r\n+    static {\r\n+        final CoverageProcessor processor =\r\n+                new CoverageProcessor(new Hints(Hints.LENIENT_DATUM_SHIFT, Boolean.TRUE));\r\n+        cropParams = processor.getOperation(\"CoverageCrop\").getParameters();\r\n+    }\r\n+\r\n+    /** Cached crop factory */\r\n+    private static final Crop coverageCropFactory = new Crop();\r\n+\r\n+    Geometry roiGeom;\r\n+\r\n+    public CroppedGridCoverage2DReader(GridCoverage2DReader delegate, Geometry roiGeom) {\r\n+        super(delegate);\r\n+        this.roiGeom = reproject(delegate.getCoordinateReferenceSystem(), roiGeom);\r\n+    }\r\n+\r\n+    private Geometry reproject(CoordinateReferenceSystem gridCRS, Geometry clipGeom) {\r\n+        // re-project if required\r\n+        try {\r\n+            CoordinateReferenceSystem geomCRS = CRS.decode(\"EPSG:\" + clipGeom.getSRID());\r\n+            if (CRS.isTransformationRequired(geomCRS, gridCRS)) {\r\n+                MathTransform mt = CRS.findMathTransform(geomCRS, gridCRS);\r\n+                clipGeom = JTS.transform(clipGeom, mt);\r\n+                clipGeom.setSRID(CRS.lookupEpsgCode(gridCRS, false));\r\n+            }\r\n+        } catch (Exception e) {\r\n+            LOGGER.log(Level.SEVERE, \"failed to reproject \" + clipGeom.toText());\r\n+            LOGGER.log(Level.SEVERE, e.getMessage(), e);\r\n+        }\r\n+\r\n+        return clipGeom;\r\n+    }\r\n+\r\n+    @Override\r\n+    public ServiceInfo getInfo() {\r\n+        return delegate.getInfo();\r\n+    }\r\n+\r\n+    @Override\r\n+    public ResourceInfo getInfo(String coverageName) {\r\n+        return delegate.getInfo(coverageName);\r\n+    }\r\n+\r\n+    @Override\r\n+    public GridCoverage2D read(GeneralParameterValue[] parameters)\r\n+            throws IllegalArgumentException, IOException {\r\n+\r\n+        return getCroppedGrid(super.read(parameters), roiGeom);\r\n+    }\r\n+\r\n+    @Override\r\n+    public GridCoverage2D read(String coverageName, GeneralParameterValue[] parameters)\r\n+            throws IllegalArgumentException, IOException {\r\n+        return getCroppedGrid(super.read(coverageName, parameters), roiGeom);\r\n+    }\r\n+\r\n+    @Override\r\n+    public GeneralEnvelope getOriginalEnvelope() {\r\n+        return GeneralEnvelope.toGeneralEnvelope(JTS.toEnvelope(roiGeom));\r", "originalCommit": "f2429f99cb342c593d5e272f8092e00f751a31ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIxNzcwMw==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r366217703", "bodyText": "understood, yes it should intersect with the result of super.getOriginalEnvelope", "author": "imranrajjad", "createdAt": "2020-01-14T09:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MTYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MTk3MA==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r365841970", "bodyText": "As a curiosity, these have been actually written in 2019? Could be, just asking.\nFor new PRs remember to update the year to 2020.", "author": "aaime", "createdAt": "2020-01-13T14:45:49Z", "path": "src/wms/src/main/java/org/geoserver/wms/clip/CroppedGridCoverage2DReader.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\r", "originalCommit": "f2429f99cb342c593d5e272f8092e00f751a31ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIxNzc4Ng==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r366217786", "bodyText": "will do", "author": "imranrajjad", "createdAt": "2020-01-14T09:02:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MTk3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0NTU5Nw==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r365845597", "bodyText": "I don't believe this is quite right. A GetFeatureInfo uses a search buffer and by default a full rendering to figure out what was depicted at the point clicked. \"Depicted\" is key, could have been a large point symbolizer, or a small one with an offset, whose source point is outside of the clip. Conversely, a large point symbolizer could allow to render outside of the clip a symbol whose origin is inside the clip (you can actually see that in the WMS states sample, those large square boxes go outside of the clip).\nSo this test is ineffective, the data should be clipped like in GetMap instead. Maybe you can roll a super-interface of GetMapCallback that allows to do this job, and the callback can implement it? GetFeatureInfo.java would have to call the callbacks of course.", "author": "aaime", "createdAt": "2020-01-13T14:52:17Z", "path": "src/wms/src/main/java/org/geoserver/wms/GetFeatureInfo.java", "diffHunk": "@@ -58,8 +60,14 @@ private FeatureCollectionType buildResults(List<FeatureCollection> results) {\n \n     @SuppressWarnings(\"rawtypes\")\n     private List<FeatureCollection> execute(GetFeatureInfoRequest request) throws Exception {\n+\n         final List<MapLayerInfo> requestedLayers = request.getQueryLayers();\n         FeatureInfoRequestParameters requestParams = new FeatureInfoRequestParameters(request);\n+        // if url has a clip param and the clicked point is outside\n+        // then abort and return empty list\n+        if (!ClipWMSGetMapCallBack.validateClipParam(requestParams)) {", "originalCommit": "f2429f99cb342c593d5e272f8092e00f751a31ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIyNTc0NA==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r366225744", "bodyText": "understood, I will clip the getFeatureInfo response just like Get Map.", "author": "imranrajjad", "createdAt": "2020-01-14T09:20:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0NTU5Nw=="}], "type": "inlineReview"}, {"oid": "033d9656ed77b9cdcf5dce0a8784fbd6d4fa2268", "url": "https://github.com/geoserver/geoserver/commit/033d9656ed77b9cdcf5dce0a8784fbd6d4fa2268", "message": "[GEOS-9440] AA rev commit 1\n\n-get feature info is clipped\n-Reflections on LayerIdentifier\n-added new unit tests for raster and cascaded\n-use non rectanglular mask on raster tests\n-add inside, outside, on the line tests\n-updated documentation\n-fixed vector clip unit test", "committedDate": "2020-01-16T14:19:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIzMTkwNQ==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r370231905", "bodyText": "This method is actually used only inside the implementations, but never called from outside. So, no need to make it public in the interface, nothing holding a LayerIdentifer uses it. As far as I can see, you can remove it from here, remove the @OverRide markers from the implementations, and it will still work fine. Compare with the identify method, which sees usage from objects holding LayerIdentifier instead.", "author": "aaime", "createdAt": "2020-01-23T16:44:17Z", "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/LayerIdentifier.java", "diffHunk": "@@ -35,4 +35,12 @@\n      */\n     List<FeatureCollection> identify(FeatureInfoRequestParameters params, int maxFeatures)\n             throws Exception;\n+", "originalCommit": "033d9656ed77b9cdcf5dce0a8784fbd6d4fa2268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2ODg0Nw==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r370268847", "bodyText": "will do", "author": "imranrajjad", "createdAt": "2020-01-23T17:58:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIzMTkwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIzMjY5Ng==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r370232696", "bodyText": "Why go and re-parse the geometry? The GetMapRequest already contains it as a Geometry by now no?", "author": "aaime", "createdAt": "2020-01-23T16:45:45Z", "path": "src/wms/src/main/java/org/geoserver/wms/clip/ClipWMSGetMapCallBack.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\r\n+ * This code is licensed under the GPL 2.0 license, available at the root\r\n+ * application directory.\r\n+ */\r\n+package org.geoserver.wms.clip;\r\n+\r\n+import java.util.logging.Level;\r\n+import java.util.logging.Logger;\r\n+import java.util.regex.Pattern;\r\n+import org.apache.commons.beanutils.BeanUtilsBean2;\r\n+import org.geoserver.platform.ServiceException;\r\n+import org.geoserver.wms.GetMapCallback;\r\n+import org.geoserver.wms.GetMapRequest;\r\n+import org.geoserver.wms.WMSMapContent;\r\n+import org.geoserver.wms.WebMap;\r\n+import org.geotools.geometry.jts.JTS;\r\n+import org.geotools.geometry.jts.WKTReader2;\r\n+import org.geotools.map.FeatureLayer;\r\n+import org.geotools.map.GridReaderLayer;\r\n+import org.geotools.map.Layer;\r\n+import org.geotools.referencing.CRS;\r\n+import org.geotools.util.logging.Logging;\r\n+import org.locationtech.jts.geom.Geometry;\r\n+import org.locationtech.jts.geom.MultiPolygon;\r\n+import org.locationtech.jts.geom.Polygon;\r\n+import org.opengis.referencing.crs.CoordinateReferenceSystem;\r\n+import org.opengis.referencing.operation.MathTransform;\r\n+\r\n+/** @author ImranR */\r\n+public class ClipWMSGetMapCallBack implements GetMapCallback {\r\n+\r\n+    //  private static Set<ProcessFactory> processFactories = Processors.getProcessFactories();\r\n+    private static final Logger LOGGER = Logging.getLogger(ClipWMSGetMapCallBack.class.getName());\r\n+\r\n+    private static final WKTReader2 reader = new WKTReader2();\r\n+\r\n+    private static final Pattern SRID_REGEX = Pattern.compile(\"SRID=[0-9].*\");\r\n+\r\n+    @Override\r\n+    public GetMapRequest initRequest(GetMapRequest request) {\r\n+        return request;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initMapContent(WMSMapContent mapContent) {}\r\n+\r\n+    @Override\r\n+    public Layer beforeLayer(WMSMapContent mapContent, Layer layer) {\r\n+\r\n+        // find and parse WKT geometry from WMS request\r\n+        //\r\n+        Geometry wktGeom = getClipGeometry(mapContent.getRequest());\r\n+        if (wktGeom == null) return layer;\r\n+\r\n+        Geometry bboxGeom = JTS.toGeometry(mapContent.getRequest().getBbox());\r\n+        // check: if wkt area fully contains bbox\r\n+        if (wktGeom.covers(bboxGeom)) return layer;\r\n+        try {\r\n+            if (layer instanceof FeatureLayer) {\r\n+\r\n+                // wrap around\r\n+                FeatureLayer fl = (FeatureLayer) layer;\r\n+\r\n+                ClippedFeatureSource clippedFS =\r\n+                        new ClippedFeatureSource(layer.getFeatureSource(), wktGeom);\r\n+                FeatureLayer clippedLayer =\r\n+                        new FeatureLayer(clippedFS, fl.getStyle(), fl.getTitle());\r\n+                BeanUtilsBean2.getInstance().copyProperties(clippedLayer, fl);\r\n+                fl.getUserData().putAll(layer.getUserData());\r\n+                return clippedLayer;\r\n+\r\n+            } else if (layer instanceof GridReaderLayer) {\r\n+\r\n+                GridReaderLayer gr = (GridReaderLayer) layer;\r\n+                // wrap\r\n+                CroppedGridCoverage2DReader croppedGridReader =\r\n+                        new CroppedGridCoverage2DReader(gr.getReader(), wktGeom);\r\n+                GridReaderLayer croppedGridLayer =\r\n+                        new GridReaderLayer(croppedGridReader, layer.getStyle());\r\n+                BeanUtilsBean2.getInstance().copyProperties(croppedGridLayer, gr);\r\n+                croppedGridLayer.getUserData().putAll(layer.getUserData());\r\n+                return croppedGridLayer;\r\n+            }\r\n+        } catch (Exception e) {\r\n+            LOGGER.severe(\"Error occurred while clipping layer \" + layer.getTitle());\r\n+            LOGGER.log(Level.SEVERE, e.getMessage(), e);\r\n+            return layer;\r\n+        }\r\n+\r\n+        return layer;\r\n+    }\r\n+\r\n+    @Override\r\n+    public WMSMapContent beforeRender(WMSMapContent mapContent) {\r\n+        return mapContent;\r\n+    }\r\n+\r\n+    @Override\r\n+    public WebMap finished(WebMap map) {\r\n+        return map;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void failed(Throwable t) {}\r\n+\r\n+    private static synchronized Geometry readGeometry(\r\n+            final String wkt, final CoordinateReferenceSystem mapCRS) throws Exception {\r\n+        String[] wktContents = wkt.split(\";\");\r\n+        Geometry geom = reader.read(wktContents[wktContents.length - 1]);\r\n+        // geom.setSRID(CRS.lookupEpsgCode(mapCRS, false));\r\n+        if (!(geom.getClass().isAssignableFrom(Polygon.class)\r\n+                || geom.getClass().isAssignableFrom(MultiPolygon.class)))\r\n+            throw new ServiceException(\r\n+                    \"Clip must be a polygon or multipolygon\", \"InvalidParameterValue\", \"clip\");\r\n+        // parse SRID if passed\r\n+        // looking for a pattern srid=4326:Polygon(...)\r\n+        if (wktContents.length == 2 && SRID_REGEX.matcher(wktContents[0].toUpperCase()).matches()) {\r\n+            String sridString = wktContents[0].split(\"=\")[1];\r\n+            // force xy\r\n+            CoordinateReferenceSystem geomCRS = CRS.decode(\"EPSG:\" + sridString, true);\r\n+            CoordinateReferenceSystem mapCRSXY =\r\n+                    CRS.decode(\"EPSG:\" + CRS.lookupEpsgCode(mapCRS, false), true);\r\n+            if (CRS.isTransformationRequired(mapCRSXY, geomCRS)) {\r\n+                MathTransform transform = CRS.findMathTransform(geomCRS, mapCRSXY);\r\n+                geom = JTS.transform(geom, transform);\r\n+            }\r\n+        }\r\n+        // finally assign map crs\r\n+        geom.setSRID(CRS.lookupEpsgCode(mapCRS, false));\r\n+        return geom;\r\n+    }\r\n+\r\n+    public static Geometry getClipGeometry(GetMapRequest getMapRequest) {\r\n+\r\n+        // no raw kvp or request has no crs\r\n+        if (getMapRequest.getRawKvp() == null || getMapRequest.getCrs() == null) return null;\r", "originalCommit": "033d9656ed77b9cdcf5dce0a8784fbd6d4fa2268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIzMjg4Mg==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r370232882", "bodyText": "Also, if the above is true, this method could become a private one in the KVP reader.", "author": "aaime", "createdAt": "2020-01-23T16:46:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIzMjY5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4Nzk0OQ==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r370487949", "bodyText": "this method itself is used in  org.geoserver.wms.map.GetMapKvpRequestReader.read(.... , but rightfully pointed out, I will use the getter in GetMapRequest", "author": "imranrajjad", "createdAt": "2020-01-24T06:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIzMjY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIzMzY1Mg==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r370233652", "bodyText": "No commented out code please... believe this class needs no change at all now, right?", "author": "aaime", "createdAt": "2020-01-23T16:47:28Z", "path": "src/wms/src/main/java/org/geoserver/wms/GetFeatureInfo.java", "diffHunk": "@@ -58,8 +58,14 @@ private FeatureCollectionType buildResults(List<FeatureCollection> results) {\n \n     @SuppressWarnings(\"rawtypes\")\n     private List<FeatureCollection> execute(GetFeatureInfoRequest request) throws Exception {\n+\n         final List<MapLayerInfo> requestedLayers = request.getQueryLayers();\n         FeatureInfoRequestParameters requestParams = new FeatureInfoRequestParameters(request);\n+        // if url has a clip param and the clicked point is outside", "originalCommit": "033d9656ed77b9cdcf5dce0a8784fbd6d4fa2268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2ODU1NA==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r370268554", "bodyText": "will remove", "author": "imranrajjad", "createdAt": "2020-01-23T17:57:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIzMzY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4NTA2MA==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r370485060", "bodyText": "yes will replace with master version", "author": "imranrajjad", "createdAt": "2020-01-24T06:05:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIzMzY1Mg=="}], "type": "inlineReview"}, {"oid": "29ec880b21dfbf8bfa73a97940601446642a4821", "url": "https://github.com/geoserver/geoserver/commit/29ec880b21dfbf8bfa73a97940601446642a4821", "message": "[GEOS-9440] AA rev 2\n\n-fixed LayerIdentifier\n-fixed documentation\n-fixed:using getter for clip param", "committedDate": "2020-01-24T06:42:26Z", "type": "commit"}, {"oid": "29ec880b21dfbf8bfa73a97940601446642a4821", "url": "https://github.com/geoserver/geoserver/commit/29ec880b21dfbf8bfa73a97940601446642a4821", "message": "[GEOS-9440] AA rev 2\n\n-fixed LayerIdentifier\n-fixed documentation\n-fixed:using getter for clip param", "committedDate": "2020-01-24T06:42:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU0ODQ0Mg==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r370548442", "bodyText": "Isn't the clip geometry already parsed and present in the GetMapRequest object? As said yesterday, please move the getClipGeometry method inside the KVP parser, make it private, and use the already parsed geometry available in GetMapRequest everywhere else...", "author": "aaime", "createdAt": "2020-01-24T09:49:47Z", "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/AbstractVectorLayerIdentifier.java", "diffHunk": "@@ -42,4 +50,12 @@ public boolean canHandle(MapLayerInfo layer) {\n         }\n         return result;\n     }\n+\n+    public FeatureSource<? extends FeatureType, ? extends Feature> handleClipParam(\n+            FeatureInfoRequestParameters params,\n+            FeatureSource<? extends FeatureType, ? extends Feature> featureSource) {\n+        Geometry clipGeom = ClipWMSGetMapCallBack.getClipGeometry(params.getGetMapRequest());", "originalCommit": "29ec880b21dfbf8bfa73a97940601446642a4821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU1NzIzMg==", "url": "https://github.com/geoserver/geoserver/pull/3961#discussion_r370557232", "bodyText": "understood, guess this call was missed", "author": "imranrajjad", "createdAt": "2020-01-24T10:09:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU0ODQ0Mg=="}], "type": "inlineReview"}, {"oid": "44bd177213f8523cc387eab4668b903ab8227822", "url": "https://github.com/geoserver/geoserver/commit/44bd177213f8523cc387eab4668b903ab8227822", "message": "[GEOS-9440] rev 2.1\n\n-moved ClipWMSGetMapCallBack.getClipGeometry\ninto GetMapKvpReaderReader", "committedDate": "2020-01-24T10:37:20Z", "type": "commit"}]}