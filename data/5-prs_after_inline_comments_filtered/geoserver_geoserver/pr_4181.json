{"pr_number": 4181, "pr_title": "[GEOS-9570] Allow the possibility to customize the GeoJSON GetFeature\u2026", "pr_createdAt": "2020-04-10T14:24:33Z", "pr_url": "https://github.com/geoserver/geoserver/pull/4181", "timeline": [{"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d", "url": "https://github.com/geoserver/geoserver/commit/e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d", "message": "[GEOS-9570] Allow the possibility to customize the GeoJSON GetFeatureInfo output format using free marker templates", "committedDate": "2020-04-10T14:39:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyMjE4Ng==", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417422186", "bodyText": "This class won't work correctly with just any random format, it just supports html and json. Best to make the format variable an enumeration then.", "author": "aaime", "createdAt": "2020-04-29T15:50:02Z", "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {", "originalCommit": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxMjEzMg==", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r420912132", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-05-06T16:07:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyMjE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyMzE3Mg==", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417423172", "bodyText": "Seems to heavily duplicate the code of the \"write\" method. Is there no way to share it? Seems like a flag to allow for empty templates is all that would be needed?", "author": "aaime", "createdAt": "2020-04-29T15:51:25Z", "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {\n+        this.resourceLoader = resourceLoader;\n+        this.wms = wms;\n+        this.format = format;\n+    }\n+\n+    /**\n+     * Write FeatureCollectionType to the output\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public void write(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+            if (ri != null) {\n+                header = getTemplate(ri, charSet, \"header\");\n+                footer = getTemplate(ri, charSet, \"footer\");\n+            } else {\n+                header = getTemplate(null, charSet, \"header\");\n+                footer = getTemplate(null, charSet, \"footer\");\n+            }\n+\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+            for (int i = 0; i < collections.size(); i++) {\n+                FeatureCollection fc = collections.get(i);\n+                Template content = getContentTemplate(fc, charSet);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, content, osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+    }\n+\n+    /**\n+     * Write a FeatureCollectionType to the output, checking that header.ftl, content.ftl and\n+     * footer.ftl are all present\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @return false if the three templates are not all present true if they are and output got\n+     *     written.\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public boolean writeWithNullCheck(", "originalCommit": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxMjIyNA==", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r420912224", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-05-06T16:07:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyMzE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNDc1MA==", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417424750", "bodyText": "If you don't bother documenting the parameters, please don't add them in the javadoc, it's just noise.", "author": "aaime", "createdAt": "2020-04-29T15:53:43Z", "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {\n+        this.resourceLoader = resourceLoader;\n+        this.wms = wms;\n+        this.format = format;\n+    }\n+\n+    /**\n+     * Write FeatureCollectionType to the output\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public void write(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+            if (ri != null) {\n+                header = getTemplate(ri, charSet, \"header\");\n+                footer = getTemplate(ri, charSet, \"footer\");\n+            } else {\n+                header = getTemplate(null, charSet, \"header\");\n+                footer = getTemplate(null, charSet, \"footer\");\n+            }\n+\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+            for (int i = 0; i < collections.size(); i++) {\n+                FeatureCollection fc = collections.get(i);\n+                Template content = getContentTemplate(fc, charSet);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, content, osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+    }\n+\n+    /**\n+     * Write a FeatureCollectionType to the output, checking that header.ftl, content.ftl and\n+     * footer.ftl are all present\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @return false if the three templates are not all present true if they are and output got\n+     *     written.\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public boolean writeWithNullCheck(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+\n+            header = getTemplate(ri, charSet, \"header\");\n+            if (header == null) return false;\n+\n+            footer = getTemplate(ri, charSet, \"footer\");\n+            if (footer == null) return false;\n+\n+            int collSize = collections.size();\n+            Template[] contentTemplates = new Template[collSize];\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+\n+                Template content = getContentTemplate(fc, charSet);\n+                if (content == null) return false;\n+\n+                contentTemplates[i] = content;\n+            }\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, contentTemplates[i], osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Process a template with dynamic content\n+     *\n+     * @param typeName", "originalCommit": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxMjMwNA==", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r420912304", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-05-06T16:08:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNDc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNTQwOQ==", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417425409", "bodyText": "Seems like this two methods could be turned into one, the static template case could just use this method and receive a null for the feature collection.", "author": "aaime", "createdAt": "2020-04-29T15:54:32Z", "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {\n+        this.resourceLoader = resourceLoader;\n+        this.wms = wms;\n+        this.format = format;\n+    }\n+\n+    /**\n+     * Write FeatureCollectionType to the output\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public void write(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+            if (ri != null) {\n+                header = getTemplate(ri, charSet, \"header\");\n+                footer = getTemplate(ri, charSet, \"footer\");\n+            } else {\n+                header = getTemplate(null, charSet, \"header\");\n+                footer = getTemplate(null, charSet, \"footer\");\n+            }\n+\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+            for (int i = 0; i < collections.size(); i++) {\n+                FeatureCollection fc = collections.get(i);\n+                Template content = getContentTemplate(fc, charSet);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, content, osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+    }\n+\n+    /**\n+     * Write a FeatureCollectionType to the output, checking that header.ftl, content.ftl and\n+     * footer.ftl are all present\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @return false if the three templates are not all present true if they are and output got\n+     *     written.\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public boolean writeWithNullCheck(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+\n+            header = getTemplate(ri, charSet, \"header\");\n+            if (header == null) return false;\n+\n+            footer = getTemplate(ri, charSet, \"footer\");\n+            if (footer == null) return false;\n+\n+            int collSize = collections.size();\n+            Template[] contentTemplates = new Template[collSize];\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+\n+                Template content = getContentTemplate(fc, charSet);\n+                if (content == null) return false;\n+\n+                contentTemplates[i] = content;\n+            }\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, contentTemplates[i], osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Process a template with dynamic content\n+     *\n+     * @param typeName\n+     * @param fc\n+     * @param template\n+     * @param osw\n+     * @throws IOException\n+     */\n+    private void processDynamicTemplate(", "originalCommit": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxMjM4NA==", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r420912384", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-05-06T16:08:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNTQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyODg1NA==", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417428854", "bodyText": "Uh, this one is interesting... so if one has a mix of collections with custom templates and some without, the resulting output would be the normal geojson one? Mind the multi-collection case is not uncommon, happens every time one does a GetFeatureInfo against a layer group. Ideally the code should be able to mix the custom part with the normal one, maybe calling the geojson encoder just to generate the output for the collection that does not have its own template. This assumes each content template leaves a clean json output that one can attach stuff to... may be not easy, and should be documented.", "author": "aaime", "createdAt": "2020-04-29T15:59:13Z", "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {\n+        this.resourceLoader = resourceLoader;\n+        this.wms = wms;\n+        this.format = format;\n+    }\n+\n+    /**\n+     * Write FeatureCollectionType to the output\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public void write(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+            if (ri != null) {\n+                header = getTemplate(ri, charSet, \"header\");\n+                footer = getTemplate(ri, charSet, \"footer\");\n+            } else {\n+                header = getTemplate(null, charSet, \"header\");\n+                footer = getTemplate(null, charSet, \"footer\");\n+            }\n+\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+            for (int i = 0; i < collections.size(); i++) {\n+                FeatureCollection fc = collections.get(i);\n+                Template content = getContentTemplate(fc, charSet);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, content, osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+    }\n+\n+    /**\n+     * Write a FeatureCollectionType to the output, checking that header.ftl, content.ftl and\n+     * footer.ftl are all present\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @return false if the three templates are not all present true if they are and output got\n+     *     written.\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public boolean writeWithNullCheck(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+\n+            header = getTemplate(ri, charSet, \"header\");\n+            if (header == null) return false;\n+\n+            footer = getTemplate(ri, charSet, \"footer\");\n+            if (footer == null) return false;\n+\n+            int collSize = collections.size();\n+            Template[] contentTemplates = new Template[collSize];\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+\n+                Template content = getContentTemplate(fc, charSet);\n+                if (content == null) return false;", "originalCommit": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxMjgyMA==", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r420912820", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-05-06T16:08:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyODg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMDU1OQ==", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417430559", "bodyText": "Good start for testing, but insufficient. Should check the multi-collection case (try with a layer group) and the mix of layers with and without templates.", "author": "aaime", "createdAt": "2020-04-29T16:01:31Z", "path": "src/wms/src/test/java/org/geoserver/wms/featureinfo/GetFeatureInfoJSONTest.java", "diffHunk": "@@ -361,4 +372,130 @@ public void testDateTimeFormattingDisabled() throws Exception {\n             TimeZone.setDefault(defaultTimeZone);\n         }\n     }\n+\n+    /** Tests json output mediated by a free marker template */\n+    @Test\n+    public void testJSONFreeMarkerTemplate() throws Exception {", "originalCommit": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxMjkxOA==", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r420912918", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-05-06T16:08:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMDU1OQ=="}], "type": "inlineReview"}, {"oid": "ebcfa627c2db6d8a43f1785728d996894c9c9c0c", "url": "https://github.com/geoserver/geoserver/commit/ebcfa627c2db6d8a43f1785728d996894c9c9c0c", "message": "reviewer's feedback applied", "committedDate": "2020-05-06T16:04:57Z", "type": "forcePushed"}, {"oid": "7b1450e0172c8604de5e09c33423a4e455d69aec", "url": "https://github.com/geoserver/geoserver/commit/7b1450e0172c8604de5e09c33423a4e455d69aec", "message": "reviewer's suggestion applied", "committedDate": "2020-05-07T07:04:16Z", "type": "forcePushed"}, {"oid": "a08c4a8b467b0de493afdf43f82e4123c3a3ec2b", "url": "https://github.com/geoserver/geoserver/commit/a08c4a8b467b0de493afdf43f82e4123c3a3ec2b", "message": "[GEOS-9570] Allow the possibility to customize the GeoJSON GetFeatureInfo output format using free marker templates", "committedDate": "2020-05-11T06:42:57Z", "type": "commit"}, {"oid": "c45495e4936bf4343b5a8924b1979d0c11103153", "url": "https://github.com/geoserver/geoserver/commit/c45495e4936bf4343b5a8924b1979d0c11103153", "message": "reviewer's suggestion applied", "committedDate": "2020-05-11T06:42:57Z", "type": "commit"}, {"oid": "f9a2206a66fd2188d80bb694f8a8090ac6cd097e", "url": "https://github.com/geoserver/geoserver/commit/f9a2206a66fd2188d80bb694f8a8090ac6cd097e", "message": "added template for valid geoJSON and better visibility for template process", "committedDate": "2020-05-11T06:42:57Z", "type": "forcePushed"}, {"oid": "523c2e4910cf00c8bbec4636c08b9a3578474ec1", "url": "https://github.com/geoserver/geoserver/commit/523c2e4910cf00c8bbec4636c08b9a3578474ec1", "message": "added template for valid geoJSON and better visibility for template process", "committedDate": "2020-05-11T08:42:36Z", "type": "commit"}, {"oid": "523c2e4910cf00c8bbec4636c08b9a3578474ec1", "url": "https://github.com/geoserver/geoserver/commit/523c2e4910cf00c8bbec4636c08b9a3578474ec1", "message": "added template for valid geoJSON and better visibility for template process", "committedDate": "2020-05-11T08:42:36Z", "type": "forcePushed"}]}