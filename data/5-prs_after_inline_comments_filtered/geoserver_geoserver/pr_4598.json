{"pr_number": 4598, "pr_title": "[GEOS-9817] Add LayerGroup support to Geofence", "pr_createdAt": "2020-12-03T16:59:11Z", "pr_url": "https://github.com/geoserver/geoserver/pull/4598", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM1MTYwMA==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r537351600", "bodyText": "Code readability.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    try (CloseableIterator<LayerGroupInfo> it =\n          \n          \n            \n                            workspaceName != null\n          \n          \n            \n                                    ? facade.list(\n          \n          \n            \n                                            LayerGroupInfo.class,\n          \n          \n            \n                                            Predicates.equal(\"workspace.name\", workspaceName),\n          \n          \n            \n                                            null,\n          \n          \n            \n                                            null,\n          \n          \n            \n                                            sort)\n          \n          \n            \n                                    : facade.list(\n          \n          \n            \n                                            LayerGroupInfo.class,\n          \n          \n            \n                                            Predicates.isNull(\"workspace\"),\n          \n          \n            \n                                            null,\n          \n          \n            \n                                            null,\n          \n          \n            \n                                            sort)) {\n          \n          \n            \n                    Predicate wsPredicate = workspaceName != null ? Predicates.equal(\"workspace.name\", workspaceName) : \n          \n          \n            \n             Predicates.isNull(\"workspace\");\n          \n          \n            \n                    try (CloseableIterator<LayerGroupInfo> it = facade.list(LayerGroupInfo.class, wsPredicate, null, null, sort)) {", "author": "aaime", "createdAt": "2020-12-07T09:25:53Z", "path": "src/extension/geofence-server/src/main/java/org/geoserver/geofence/web/GeofenceRulePage.java", "diffHunk": "@@ -323,6 +328,43 @@ private MultiPolygon castToMultiPolygon(Geometry geometry) {\n         return resultSet;\n     }\n \n+    /**\n+     * Returns a sorted list of layer names in the specified workspace (or * if the workspace is *)\n+     */\n+    protected List<String> getLayerGroupNames(String workspaceName) {\n+        List<String> resultSet = new ArrayList<String>();\n+        FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2();\n+        CatalogFacade facade = getCatalog().getFacade();\n+        SortBy sort = ff.sort(\"name\", SortOrder.ASCENDING);\n+        try (CloseableIterator<LayerGroupInfo> it =\n+                workspaceName != null\n+                        ? facade.list(\n+                                LayerGroupInfo.class,\n+                                Predicates.equal(\"workspace.name\", workspaceName),\n+                                null,\n+                                null,\n+                                sort)\n+                        : facade.list(\n+                                LayerGroupInfo.class,\n+                                Predicates.isNull(\"workspace\"),\n+                                null,\n+                                null,\n+                                sort)) {", "originalCommit": "eccecaf488f41a45373bd576ed48db293c50b410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4MTg3Nw==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r539981877", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-12-10T08:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM1MTYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM1MzE1MQ==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r537353151", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        while (it.hasNext()) {\n          \n          \n            \n                            resultSet.add(it.next().getName());\n          \n          \n            \n                        }\n          \n          \n            \n                        it.forEachRemaining(lg -> resultSet.add(lg.getName());", "author": "aaime", "createdAt": "2020-12-07T09:28:04Z", "path": "src/extension/geofence-server/src/main/java/org/geoserver/geofence/web/GeofenceRulePage.java", "diffHunk": "@@ -323,6 +328,43 @@ private MultiPolygon castToMultiPolygon(Geometry geometry) {\n         return resultSet;\n     }\n \n+    /**\n+     * Returns a sorted list of layer names in the specified workspace (or * if the workspace is *)\n+     */\n+    protected List<String> getLayerGroupNames(String workspaceName) {\n+        List<String> resultSet = new ArrayList<String>();\n+        FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2();\n+        CatalogFacade facade = getCatalog().getFacade();\n+        SortBy sort = ff.sort(\"name\", SortOrder.ASCENDING);\n+        try (CloseableIterator<LayerGroupInfo> it =\n+                workspaceName != null\n+                        ? facade.list(\n+                                LayerGroupInfo.class,\n+                                Predicates.equal(\"workspace.name\", workspaceName),\n+                                null,\n+                                null,\n+                                sort)\n+                        : facade.list(\n+                                LayerGroupInfo.class,\n+                                Predicates.isNull(\"workspace\"),\n+                                null,\n+                                null,\n+                                sort)) {\n+            while (it.hasNext()) {\n+                resultSet.add(it.next().getName());\n+            }", "originalCommit": "eccecaf488f41a45373bd576ed48db293c50b410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4MTkzNQ==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r539981935", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-12-10T08:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM1MzE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM1NDkzMA==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r537354930", "bodyText": "Please add back the diamond and fix whatever reason made you remove it. The \"unchecked branch\" will soon be merged, need to learn how to handle unchecked cast warnings anyways.", "author": "aaime", "createdAt": "2020-12-07T09:30:40Z", "path": "src/extension/geofence-server/src/main/java/org/geoserver/geofence/web/GeofenceRulePage.java", "diffHunk": "@@ -691,12 +741,33 @@ protected void onUpdate(AjaxRequestTarget target) {\n                     });\n \n             DropDownChoice<LayerType> layerType =\n-                    new DropDownChoice<>(\n+                    new DropDownChoice(", "originalCommit": "eccecaf488f41a45373bd576ed48db293c50b410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4MTk5NQ==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r539981995", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-12-10T08:49:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM1NDkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM1NTQ2OQ==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r537355469", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        boolean enableFiltersAndStyles = true;\n          \n          \n            \n                                        if (layerType.getValue().equals(LayerType.LAYERGROUP.name()))\n          \n          \n            \n                                            enableFiltersAndStyles = false;\n          \n          \n            \n                                        boolean enableFiltersAndStyles = !layerType.getValue().equals(LayerType.LAYERGROUP.name());", "author": "aaime", "createdAt": "2020-12-07T09:31:29Z", "path": "src/extension/geofence-server/src/main/java/org/geoserver/geofence/web/GeofenceRulePage.java", "diffHunk": "@@ -691,12 +741,33 @@ protected void onUpdate(AjaxRequestTarget target) {\n                     });\n \n             DropDownChoice<LayerType> layerType =\n-                    new DropDownChoice<>(\n+                    new DropDownChoice(\n                             \"layerType\",\n                             ruleFormModel.bind(\"layerDetails.layerType\"),\n                             Arrays.asList(LayerType.values()),\n                             new LayerTypeRenderer());\n-            layerType.setEnabled(false);\n+            boolean isNullType = ruleFormModel.getObject().layerDetails.layerType == null;\n+            layerType.setEnabled(isNullType);\n+            layerType.add(\n+                    new AjaxFormComponentUpdatingBehavior(\"onchange\") {\n+                        @Override\n+                        protected void onUpdate(AjaxRequestTarget ajaxRequestTarget) {\n+                            boolean enableFiltersAndStyles = true;\n+                            if (layerType.getValue().equals(LayerType.LAYERGROUP.name()))\n+                                enableFiltersAndStyles = false;", "originalCommit": "eccecaf488f41a45373bd576ed48db293c50b410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4MjEwMQ==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r539982101", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-12-10T08:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM1NTQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM1NjI3Nw==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r537356277", "bodyText": "Duplicate line of code?", "author": "aaime", "createdAt": "2020-12-07T09:32:40Z", "path": "src/extension/geofence-server/src/main/java/org/geoserver/geofence/web/GeofenceRulePage.java", "diffHunk": "@@ -691,12 +741,33 @@ protected void onUpdate(AjaxRequestTarget target) {\n                     });\n \n             DropDownChoice<LayerType> layerType =\n-                    new DropDownChoice<>(\n+                    new DropDownChoice(\n                             \"layerType\",\n                             ruleFormModel.bind(\"layerDetails.layerType\"),\n                             Arrays.asList(LayerType.values()),\n                             new LayerTypeRenderer());\n-            layerType.setEnabled(false);\n+            boolean isNullType = ruleFormModel.getObject().layerDetails.layerType == null;\n+            layerType.setEnabled(isNullType);\n+            layerType.add(\n+                    new AjaxFormComponentUpdatingBehavior(\"onchange\") {\n+                        @Override\n+                        protected void onUpdate(AjaxRequestTarget ajaxRequestTarget) {\n+                            boolean enableFiltersAndStyles = true;\n+                            if (layerType.getValue().equals(LayerType.LAYERGROUP.name()))\n+                                enableFiltersAndStyles = false;\n+\n+                            Component readFilter = container.get(\"cqlFilterRead\");\n+                            readFilter.setEnabled(enableFiltersAndStyles);\n+                            Component writeFilter = container.get(\"cqlFilterWrite\");\n+                            writeFilter.setEnabled(enableFiltersAndStyles);\n+                            Component defaultStyles = container.get(\"defaultStyle\");\n+                            defaultStyles.setEnabled(enableFiltersAndStyles);\n+                            defaultStyles.setEnabled(enableFiltersAndStyles);", "originalCommit": "eccecaf488f41a45373bd576ed48db293c50b410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4MjIxNQ==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r539982215", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-12-10T08:49:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM1NjI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4NTM1MA==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r537385350", "bodyText": "So for the rule, the less restrictive is taken. But the area is just the last one found instead? What if two groups have different restrictions? Are there tests for that?", "author": "aaime", "createdAt": "2020-12-07T10:15:01Z", "path": "src/extension/geofence/src/main/java/org/geoserver/geofence/GeofenceAccessManager.java", "diffHunk": "@@ -269,108 +279,189 @@ public StyleAccessLimits getAccessLimits(Authentication user, StyleInfo style) {\n \n     @Override\n     public LayerGroupAccessLimits getAccessLimits(Authentication user, LayerGroupInfo layerInfo) {\n-        // return getAccessLimits(user, layerInfo.getResource());\n-        LOGGER.fine(\"Not limiting layergroups\");\n-        return null;\n-        // TODO\n+        return getAccessLimits(user, layerInfo, Collections.emptyList());\n     }\n \n     @Override\n     public DataAccessLimits getAccessLimits(Authentication user, LayerInfo layer) {\n         LOGGER.log(Level.FINE, \"Getting access limits for Layer {0}\", layer.getName());\n-        return getAccessLimits(user, layer.getResource());\n+        return getAccessLimits(user, layer, Collections.emptyList());\n     }\n \n     @Override\n     public DataAccessLimits getAccessLimits(Authentication user, ResourceInfo resource) {\n         LOGGER.log(Level.FINE, \"Getting access limits for Resource {0}\", resource.getName());\n         // extract the user name\n-        String username = null;\n+        String workspace = resource.getStore().getWorkspace().getName();\n+        String layer = resource.getName();\n+        return (DataAccessLimits)\n+                getAccessLimits(user, resource, layer, workspace, Collections.emptyList());\n+    }\n+\n+    @Override\n+    public DataAccessLimits getAccessLimits(\n+            Authentication user, LayerInfo layer, List<LayerGroupInfo> containers) {\n+        String workspace = layer.getResource().getStore().getWorkspace().getName();\n+        String layerName = layer.getName();\n+        return (DataAccessLimits) getAccessLimits(user, layer, layerName, workspace, containers);\n+    }\n+\n+    @Override\n+    public LayerGroupAccessLimits getAccessLimits(\n+            Authentication user, LayerGroupInfo layerGroup, List<LayerGroupInfo> containers) {\n+        WorkspaceInfo ws = layerGroup.getWorkspace();\n+        String workspace = ws != null ? ws.getName() : null;\n+        String layer = layerGroup.getName();\n+        return (LayerGroupAccessLimits)\n+                getAccessLimits(user, layerGroup, layer, workspace, containers);\n+    }\n+\n+    private AccessLimits getAccessLimits(\n+            Authentication user,\n+            CatalogInfo info,\n+            String layer,\n+            String workspace,\n+            List<LayerGroupInfo> containers) {\n         if ((user != null) && !(user instanceof AnonymousAuthenticationToken)) {\n             // shortcut, if the user is the admin, he can do everything\n             if (isAdmin(user)) {\n                 LOGGER.log(\n                         Level.FINE,\n                         \"Admin level access, returning \" + \"full rights for layer {0}\",\n-                        resource.prefixedName());\n-\n-                return buildAccessLimits(resource, AccessInfo.ALLOW_ALL);\n-            }\n-\n-            username = user.getName();\n-            if (username != null && username.isEmpty()) {\n-                username = null;\n+                        layer);\n+                return buildAdminAccessLimits(info);\n             }\n         }\n \n-        // get info from the current request\n-        String service = null;\n-        String request = null;\n-        Request owsRequest = Dispatcher.REQUEST.get();\n-        if (owsRequest != null) {\n-            service = owsRequest.getService();\n-            request = owsRequest.getRequest();\n+        RuleFilter ruleFilter = buildRuleFilter(workspace, layer, user);\n+        AccessInfo rule = rules.getAccessInfo(ruleFilter);\n+        Pair<Geometry, AccessInfo> containerRule =\n+                getAllowedAreaAndAccessInfoFromContainers(info, containers, user);\n+        if (rule == null) rule = AccessInfo.DENY_ALL;\n+\n+        AccessLimits limits;\n+        if (info instanceof LayerGroupInfo) {\n+            limits = buildLayerGroupAccessLimits(rule, containerRule);\n+        } else if (info instanceof ResourceInfo) {\n+            limits = buildResourceAccessLimits((ResourceInfo) info, rule, containerRule);\n+        } else {\n+            limits =\n+                    buildResourceAccessLimits(\n+                            ((LayerInfo) info).getResource(), rule, containerRule);\n         }\n \n-        // get the resource info\n-        String layer = resource.getName();\n-        StoreInfo store = resource.getStore();\n-        WorkspaceInfo ws = store.getWorkspace();\n-        String workspace = ws.getName();\n+        LOGGER.log(\n+                Level.FINE,\n+                \"Returning {0} for layer {1} and user {2}\",\n+                new Object[] {limits, layer, getUserNameFromAuth(user)});\n \n-        // get the request infos\n-        RuleFilter ruleFilter = new RuleFilter(RuleFilter.SpecialFilterType.ANY);\n-        setRuleFilterUserOrRole(user, ruleFilter);\n+        return limits;\n+    }\n \n-        ruleFilter.setInstance(configurationManager.getConfiguration().getInstanceName());\n-        if (service != null) {\n-            if (\"*\".equals(service)) {\n-                ruleFilter.setService(RuleFilter.SpecialFilterType.ANY);\n-            } else {\n-                ruleFilter.setService(service);\n-            }\n-        } else {\n-            ruleFilter.setService(RuleFilter.SpecialFilterType.DEFAULT);\n-        }\n+    // build the accessLimits for an admin user\n+    private AccessLimits buildAdminAccessLimits(CatalogInfo info) {\n+        AccessLimits accessLimits;\n+        if (info instanceof LayerGroupInfo)\n+            accessLimits = buildLayerGroupAccessLimits(AccessInfo.ALLOW_ALL, null);\n+        else if (info instanceof ResourceInfo)\n+            accessLimits =\n+                    buildResourceAccessLimits((ResourceInfo) info, AccessInfo.ALLOW_ALL, null);\n+        else\n+            accessLimits =\n+                    buildResourceAccessLimits(\n+                            ((LayerInfo) info).getResource(), AccessInfo.ALLOW_ALL, null);\n+        return accessLimits;\n+    }\n \n-        if (request != null) {\n-            if (\"*\".equals(request)) {\n-                ruleFilter.setRequest(RuleFilter.SpecialFilterType.ANY);\n-            } else {\n-                ruleFilter.setRequest(request);\n-            }\n+    private Pair<Geometry, AccessInfo> getAllowedAreaAndAccessInfoFromContainers(\n+            CatalogInfo resource, List<LayerGroupInfo> containers, Authentication user) {\n+        boolean directAccess = containers == null || containers.isEmpty();\n+        Request req = Dispatcher.REQUEST.get();\n+        String service = req != null ? req.getService() : null;\n+        boolean isWms = service != null && service.equalsIgnoreCase(\"WMS\");\n+        Pair<Geometry, AccessInfo> containerRule = null;\n+        if (directAccess && isWms) {\n+            containerRule = getContainerRuleForLayerDirectAccess(resource, user);\n         } else {\n-            ruleFilter.setRequest(RuleFilter.SpecialFilterType.DEFAULT);\n+            containerRule = handleContainers(containers, user);\n         }\n-        ruleFilter.setWorkspace(workspace);\n-        ruleFilter.setLayer(layer);\n+        return containerRule;\n+    }\n \n-        String sourceAddress = retrieveCallerIpAddress();\n-        if (sourceAddress != null) {\n-            ruleFilter.setSourceAddress(sourceAddress);\n-        } else {\n-            LOGGER.log(Level.WARNING, \"No source IP address found\");\n-            ruleFilter.setSourceAddress(RuleFilter.SpecialFilterType.DEFAULT);\n+    private String getUserNameFromAuth(Authentication authentication) {\n+        String username = authentication != null ? authentication.getName() : null;\n+        if (username != null && username.isEmpty()) {\n+            username = null;\n         }\n+        return username;\n+    }\n \n-        LOGGER.log(Level.FINE, \"ResourceInfo filter: {0}\", ruleFilter);\n-\n-        AccessInfo rule = rules.getAccessInfo(ruleFilter);\n-\n-        if (rule == null) {\n-            rule = AccessInfo.DENY_ALL;\n+    private Pair<Geometry, AccessInfo> handleContainers(\n+            List<LayerGroupInfo> groups, Authentication user) {\n+        Geometry allowedArea = null;\n+        AccessInfo lessRestrictiveRule = null;\n+        for (LayerGroupInfo lgi : groups) {\n+            WorkspaceInfo ws = lgi.getWorkspace();\n+            String workspace = ws != null ? ws.getName() : null;\n+            String layer = lgi.getName();\n+            RuleFilter filter = buildRuleFilter(workspace, layer, user);\n+            AccessInfo accessInfo = rules.getAccessInfo(filter);\n+            lessRestrictiveRule = getLessRestrictiveRule(lessRestrictiveRule, accessInfo);\n+            allowedArea =\n+                    getReprojectArea(accessInfo, lgi.getBounds().getCoordinateReferenceSystem());", "originalCommit": "eccecaf488f41a45373bd576ed48db293c50b410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4MjMxNw==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r539982317", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-12-10T08:49:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4NTM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4ODM1NQ==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r537388355", "bodyText": "Confusing usage of Pair API. Decide if you want to use left/right or key/value and use them consistently.", "author": "aaime", "createdAt": "2020-12-07T10:19:27Z", "path": "src/extension/geofence/src/main/java/org/geoserver/geofence/GeofenceAccessManager.java", "diffHunk": "@@ -269,108 +279,189 @@ public StyleAccessLimits getAccessLimits(Authentication user, StyleInfo style) {\n \n     @Override\n     public LayerGroupAccessLimits getAccessLimits(Authentication user, LayerGroupInfo layerInfo) {\n-        // return getAccessLimits(user, layerInfo.getResource());\n-        LOGGER.fine(\"Not limiting layergroups\");\n-        return null;\n-        // TODO\n+        return getAccessLimits(user, layerInfo, Collections.emptyList());\n     }\n \n     @Override\n     public DataAccessLimits getAccessLimits(Authentication user, LayerInfo layer) {\n         LOGGER.log(Level.FINE, \"Getting access limits for Layer {0}\", layer.getName());\n-        return getAccessLimits(user, layer.getResource());\n+        return getAccessLimits(user, layer, Collections.emptyList());\n     }\n \n     @Override\n     public DataAccessLimits getAccessLimits(Authentication user, ResourceInfo resource) {\n         LOGGER.log(Level.FINE, \"Getting access limits for Resource {0}\", resource.getName());\n         // extract the user name\n-        String username = null;\n+        String workspace = resource.getStore().getWorkspace().getName();\n+        String layer = resource.getName();\n+        return (DataAccessLimits)\n+                getAccessLimits(user, resource, layer, workspace, Collections.emptyList());\n+    }\n+\n+    @Override\n+    public DataAccessLimits getAccessLimits(\n+            Authentication user, LayerInfo layer, List<LayerGroupInfo> containers) {\n+        String workspace = layer.getResource().getStore().getWorkspace().getName();\n+        String layerName = layer.getName();\n+        return (DataAccessLimits) getAccessLimits(user, layer, layerName, workspace, containers);\n+    }\n+\n+    @Override\n+    public LayerGroupAccessLimits getAccessLimits(\n+            Authentication user, LayerGroupInfo layerGroup, List<LayerGroupInfo> containers) {\n+        WorkspaceInfo ws = layerGroup.getWorkspace();\n+        String workspace = ws != null ? ws.getName() : null;\n+        String layer = layerGroup.getName();\n+        return (LayerGroupAccessLimits)\n+                getAccessLimits(user, layerGroup, layer, workspace, containers);\n+    }\n+\n+    private AccessLimits getAccessLimits(\n+            Authentication user,\n+            CatalogInfo info,\n+            String layer,\n+            String workspace,\n+            List<LayerGroupInfo> containers) {\n         if ((user != null) && !(user instanceof AnonymousAuthenticationToken)) {\n             // shortcut, if the user is the admin, he can do everything\n             if (isAdmin(user)) {\n                 LOGGER.log(\n                         Level.FINE,\n                         \"Admin level access, returning \" + \"full rights for layer {0}\",\n-                        resource.prefixedName());\n-\n-                return buildAccessLimits(resource, AccessInfo.ALLOW_ALL);\n-            }\n-\n-            username = user.getName();\n-            if (username != null && username.isEmpty()) {\n-                username = null;\n+                        layer);\n+                return buildAdminAccessLimits(info);\n             }\n         }\n \n-        // get info from the current request\n-        String service = null;\n-        String request = null;\n-        Request owsRequest = Dispatcher.REQUEST.get();\n-        if (owsRequest != null) {\n-            service = owsRequest.getService();\n-            request = owsRequest.getRequest();\n+        RuleFilter ruleFilter = buildRuleFilter(workspace, layer, user);\n+        AccessInfo rule = rules.getAccessInfo(ruleFilter);\n+        Pair<Geometry, AccessInfo> containerRule =\n+                getAllowedAreaAndAccessInfoFromContainers(info, containers, user);\n+        if (rule == null) rule = AccessInfo.DENY_ALL;\n+\n+        AccessLimits limits;\n+        if (info instanceof LayerGroupInfo) {\n+            limits = buildLayerGroupAccessLimits(rule, containerRule);\n+        } else if (info instanceof ResourceInfo) {\n+            limits = buildResourceAccessLimits((ResourceInfo) info, rule, containerRule);\n+        } else {\n+            limits =\n+                    buildResourceAccessLimits(\n+                            ((LayerInfo) info).getResource(), rule, containerRule);\n         }\n \n-        // get the resource info\n-        String layer = resource.getName();\n-        StoreInfo store = resource.getStore();\n-        WorkspaceInfo ws = store.getWorkspace();\n-        String workspace = ws.getName();\n+        LOGGER.log(\n+                Level.FINE,\n+                \"Returning {0} for layer {1} and user {2}\",\n+                new Object[] {limits, layer, getUserNameFromAuth(user)});\n \n-        // get the request infos\n-        RuleFilter ruleFilter = new RuleFilter(RuleFilter.SpecialFilterType.ANY);\n-        setRuleFilterUserOrRole(user, ruleFilter);\n+        return limits;\n+    }\n \n-        ruleFilter.setInstance(configurationManager.getConfiguration().getInstanceName());\n-        if (service != null) {\n-            if (\"*\".equals(service)) {\n-                ruleFilter.setService(RuleFilter.SpecialFilterType.ANY);\n-            } else {\n-                ruleFilter.setService(service);\n-            }\n-        } else {\n-            ruleFilter.setService(RuleFilter.SpecialFilterType.DEFAULT);\n-        }\n+    // build the accessLimits for an admin user\n+    private AccessLimits buildAdminAccessLimits(CatalogInfo info) {\n+        AccessLimits accessLimits;\n+        if (info instanceof LayerGroupInfo)\n+            accessLimits = buildLayerGroupAccessLimits(AccessInfo.ALLOW_ALL, null);\n+        else if (info instanceof ResourceInfo)\n+            accessLimits =\n+                    buildResourceAccessLimits((ResourceInfo) info, AccessInfo.ALLOW_ALL, null);\n+        else\n+            accessLimits =\n+                    buildResourceAccessLimits(\n+                            ((LayerInfo) info).getResource(), AccessInfo.ALLOW_ALL, null);\n+        return accessLimits;\n+    }\n \n-        if (request != null) {\n-            if (\"*\".equals(request)) {\n-                ruleFilter.setRequest(RuleFilter.SpecialFilterType.ANY);\n-            } else {\n-                ruleFilter.setRequest(request);\n-            }\n+    private Pair<Geometry, AccessInfo> getAllowedAreaAndAccessInfoFromContainers(\n+            CatalogInfo resource, List<LayerGroupInfo> containers, Authentication user) {\n+        boolean directAccess = containers == null || containers.isEmpty();\n+        Request req = Dispatcher.REQUEST.get();\n+        String service = req != null ? req.getService() : null;\n+        boolean isWms = service != null && service.equalsIgnoreCase(\"WMS\");\n+        Pair<Geometry, AccessInfo> containerRule = null;\n+        if (directAccess && isWms) {\n+            containerRule = getContainerRuleForLayerDirectAccess(resource, user);\n         } else {\n-            ruleFilter.setRequest(RuleFilter.SpecialFilterType.DEFAULT);\n+            containerRule = handleContainers(containers, user);\n         }\n-        ruleFilter.setWorkspace(workspace);\n-        ruleFilter.setLayer(layer);\n+        return containerRule;\n+    }\n \n-        String sourceAddress = retrieveCallerIpAddress();\n-        if (sourceAddress != null) {\n-            ruleFilter.setSourceAddress(sourceAddress);\n-        } else {\n-            LOGGER.log(Level.WARNING, \"No source IP address found\");\n-            ruleFilter.setSourceAddress(RuleFilter.SpecialFilterType.DEFAULT);\n+    private String getUserNameFromAuth(Authentication authentication) {\n+        String username = authentication != null ? authentication.getName() : null;\n+        if (username != null && username.isEmpty()) {\n+            username = null;\n         }\n+        return username;\n+    }\n \n-        LOGGER.log(Level.FINE, \"ResourceInfo filter: {0}\", ruleFilter);\n-\n-        AccessInfo rule = rules.getAccessInfo(ruleFilter);\n-\n-        if (rule == null) {\n-            rule = AccessInfo.DENY_ALL;\n+    private Pair<Geometry, AccessInfo> handleContainers(\n+            List<LayerGroupInfo> groups, Authentication user) {\n+        Geometry allowedArea = null;\n+        AccessInfo lessRestrictiveRule = null;\n+        for (LayerGroupInfo lgi : groups) {\n+            WorkspaceInfo ws = lgi.getWorkspace();\n+            String workspace = ws != null ? ws.getName() : null;\n+            String layer = lgi.getName();\n+            RuleFilter filter = buildRuleFilter(workspace, layer, user);\n+            AccessInfo accessInfo = rules.getAccessInfo(filter);\n+            lessRestrictiveRule = getLessRestrictiveRule(lessRestrictiveRule, accessInfo);\n+            allowedArea =\n+                    getReprojectArea(accessInfo, lgi.getBounds().getCoordinateReferenceSystem());\n         }\n+        return new ImmutablePair<>(allowedArea, lessRestrictiveRule);\n+    }\n \n-        DataAccessLimits limits = buildAccessLimits(resource, rule);\n-        LOGGER.log(\n-                Level.FINE,\n-                \"Returning {0} for layer {1} and user {2}\",\n-                new Object[] {limits, resource.prefixedName(), username});\n+    // get the AccessInfo from the layer's containers returning a tuple with\n+    // the Geometry of the allowed area if found and the less restrictive accessInfo\n+    // among the ones of associated layerGroups\n+    private Pair<Geometry, AccessInfo> getContainerRuleForLayerDirectAccess(\n+            Object resource, Authentication user) {\n+        MutablePair<Geometry, AccessInfo> result = new MutablePair<>(null, null);\n+        Collection<LayerGroupContainmentCache.LayerGroupSummary> summaries;\n+        if (resource instanceof ResourceInfo)\n+            summaries = groupsCache.getContainerGroupsFor((ResourceInfo) resource);\n+        else if (resource instanceof LayerInfo)\n+            summaries = groupsCache.getContainerGroupsFor(((LayerInfo) resource).getResource());\n+        else summaries = groupsCache.getContainerGroupsFor((LayerGroupInfo) resource);\n+\n+        for (LayerGroupContainmentCache.LayerGroupSummary gs : summaries) {\n+            LayerGroupInfo.Mode mode = gs.getMode();\n+            if (mode.equals(LayerGroupInfo.Mode.OPAQUE_CONTAINER)) {\n+                // opaque mode deny access for the layer\n+                AccessInfo newInfo = AccessInfo.DENY_ALL;\n+                result.setValue(getLessRestrictiveRule(result.getRight(), newInfo));", "originalCommit": "eccecaf488f41a45373bd576ed48db293c50b410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4MjM5MQ==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r539982391", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-12-10T08:49:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4ODM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM5MTM2MQ==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r537391361", "bodyText": "Since each branch contains a return stratement, no need for all the \"else\"", "author": "aaime", "createdAt": "2020-12-07T10:23:45Z", "path": "src/extension/geofence/src/main/java/org/geoserver/geofence/GeofenceAccessManager.java", "diffHunk": "@@ -269,108 +279,189 @@ public StyleAccessLimits getAccessLimits(Authentication user, StyleInfo style) {\n \n     @Override\n     public LayerGroupAccessLimits getAccessLimits(Authentication user, LayerGroupInfo layerInfo) {\n-        // return getAccessLimits(user, layerInfo.getResource());\n-        LOGGER.fine(\"Not limiting layergroups\");\n-        return null;\n-        // TODO\n+        return getAccessLimits(user, layerInfo, Collections.emptyList());\n     }\n \n     @Override\n     public DataAccessLimits getAccessLimits(Authentication user, LayerInfo layer) {\n         LOGGER.log(Level.FINE, \"Getting access limits for Layer {0}\", layer.getName());\n-        return getAccessLimits(user, layer.getResource());\n+        return getAccessLimits(user, layer, Collections.emptyList());\n     }\n \n     @Override\n     public DataAccessLimits getAccessLimits(Authentication user, ResourceInfo resource) {\n         LOGGER.log(Level.FINE, \"Getting access limits for Resource {0}\", resource.getName());\n         // extract the user name\n-        String username = null;\n+        String workspace = resource.getStore().getWorkspace().getName();\n+        String layer = resource.getName();\n+        return (DataAccessLimits)\n+                getAccessLimits(user, resource, layer, workspace, Collections.emptyList());\n+    }\n+\n+    @Override\n+    public DataAccessLimits getAccessLimits(\n+            Authentication user, LayerInfo layer, List<LayerGroupInfo> containers) {\n+        String workspace = layer.getResource().getStore().getWorkspace().getName();\n+        String layerName = layer.getName();\n+        return (DataAccessLimits) getAccessLimits(user, layer, layerName, workspace, containers);\n+    }\n+\n+    @Override\n+    public LayerGroupAccessLimits getAccessLimits(\n+            Authentication user, LayerGroupInfo layerGroup, List<LayerGroupInfo> containers) {\n+        WorkspaceInfo ws = layerGroup.getWorkspace();\n+        String workspace = ws != null ? ws.getName() : null;\n+        String layer = layerGroup.getName();\n+        return (LayerGroupAccessLimits)\n+                getAccessLimits(user, layerGroup, layer, workspace, containers);\n+    }\n+\n+    private AccessLimits getAccessLimits(\n+            Authentication user,\n+            CatalogInfo info,\n+            String layer,\n+            String workspace,\n+            List<LayerGroupInfo> containers) {\n         if ((user != null) && !(user instanceof AnonymousAuthenticationToken)) {\n             // shortcut, if the user is the admin, he can do everything\n             if (isAdmin(user)) {\n                 LOGGER.log(\n                         Level.FINE,\n                         \"Admin level access, returning \" + \"full rights for layer {0}\",\n-                        resource.prefixedName());\n-\n-                return buildAccessLimits(resource, AccessInfo.ALLOW_ALL);\n-            }\n-\n-            username = user.getName();\n-            if (username != null && username.isEmpty()) {\n-                username = null;\n+                        layer);\n+                return buildAdminAccessLimits(info);\n             }\n         }\n \n-        // get info from the current request\n-        String service = null;\n-        String request = null;\n-        Request owsRequest = Dispatcher.REQUEST.get();\n-        if (owsRequest != null) {\n-            service = owsRequest.getService();\n-            request = owsRequest.getRequest();\n+        RuleFilter ruleFilter = buildRuleFilter(workspace, layer, user);\n+        AccessInfo rule = rules.getAccessInfo(ruleFilter);\n+        Pair<Geometry, AccessInfo> containerRule =\n+                getAllowedAreaAndAccessInfoFromContainers(info, containers, user);\n+        if (rule == null) rule = AccessInfo.DENY_ALL;\n+\n+        AccessLimits limits;\n+        if (info instanceof LayerGroupInfo) {\n+            limits = buildLayerGroupAccessLimits(rule, containerRule);\n+        } else if (info instanceof ResourceInfo) {\n+            limits = buildResourceAccessLimits((ResourceInfo) info, rule, containerRule);\n+        } else {\n+            limits =\n+                    buildResourceAccessLimits(\n+                            ((LayerInfo) info).getResource(), rule, containerRule);\n         }\n \n-        // get the resource info\n-        String layer = resource.getName();\n-        StoreInfo store = resource.getStore();\n-        WorkspaceInfo ws = store.getWorkspace();\n-        String workspace = ws.getName();\n+        LOGGER.log(\n+                Level.FINE,\n+                \"Returning {0} for layer {1} and user {2}\",\n+                new Object[] {limits, layer, getUserNameFromAuth(user)});\n \n-        // get the request infos\n-        RuleFilter ruleFilter = new RuleFilter(RuleFilter.SpecialFilterType.ANY);\n-        setRuleFilterUserOrRole(user, ruleFilter);\n+        return limits;\n+    }\n \n-        ruleFilter.setInstance(configurationManager.getConfiguration().getInstanceName());\n-        if (service != null) {\n-            if (\"*\".equals(service)) {\n-                ruleFilter.setService(RuleFilter.SpecialFilterType.ANY);\n-            } else {\n-                ruleFilter.setService(service);\n-            }\n-        } else {\n-            ruleFilter.setService(RuleFilter.SpecialFilterType.DEFAULT);\n-        }\n+    // build the accessLimits for an admin user\n+    private AccessLimits buildAdminAccessLimits(CatalogInfo info) {\n+        AccessLimits accessLimits;\n+        if (info instanceof LayerGroupInfo)\n+            accessLimits = buildLayerGroupAccessLimits(AccessInfo.ALLOW_ALL, null);\n+        else if (info instanceof ResourceInfo)\n+            accessLimits =\n+                    buildResourceAccessLimits((ResourceInfo) info, AccessInfo.ALLOW_ALL, null);\n+        else\n+            accessLimits =\n+                    buildResourceAccessLimits(\n+                            ((LayerInfo) info).getResource(), AccessInfo.ALLOW_ALL, null);\n+        return accessLimits;\n+    }\n \n-        if (request != null) {\n-            if (\"*\".equals(request)) {\n-                ruleFilter.setRequest(RuleFilter.SpecialFilterType.ANY);\n-            } else {\n-                ruleFilter.setRequest(request);\n-            }\n+    private Pair<Geometry, AccessInfo> getAllowedAreaAndAccessInfoFromContainers(\n+            CatalogInfo resource, List<LayerGroupInfo> containers, Authentication user) {\n+        boolean directAccess = containers == null || containers.isEmpty();\n+        Request req = Dispatcher.REQUEST.get();\n+        String service = req != null ? req.getService() : null;\n+        boolean isWms = service != null && service.equalsIgnoreCase(\"WMS\");\n+        Pair<Geometry, AccessInfo> containerRule = null;\n+        if (directAccess && isWms) {\n+            containerRule = getContainerRuleForLayerDirectAccess(resource, user);\n         } else {\n-            ruleFilter.setRequest(RuleFilter.SpecialFilterType.DEFAULT);\n+            containerRule = handleContainers(containers, user);\n         }\n-        ruleFilter.setWorkspace(workspace);\n-        ruleFilter.setLayer(layer);\n+        return containerRule;\n+    }\n \n-        String sourceAddress = retrieveCallerIpAddress();\n-        if (sourceAddress != null) {\n-            ruleFilter.setSourceAddress(sourceAddress);\n-        } else {\n-            LOGGER.log(Level.WARNING, \"No source IP address found\");\n-            ruleFilter.setSourceAddress(RuleFilter.SpecialFilterType.DEFAULT);\n+    private String getUserNameFromAuth(Authentication authentication) {\n+        String username = authentication != null ? authentication.getName() : null;\n+        if (username != null && username.isEmpty()) {\n+            username = null;\n         }\n+        return username;\n+    }\n \n-        LOGGER.log(Level.FINE, \"ResourceInfo filter: {0}\", ruleFilter);\n-\n-        AccessInfo rule = rules.getAccessInfo(ruleFilter);\n-\n-        if (rule == null) {\n-            rule = AccessInfo.DENY_ALL;\n+    private Pair<Geometry, AccessInfo> handleContainers(\n+            List<LayerGroupInfo> groups, Authentication user) {\n+        Geometry allowedArea = null;\n+        AccessInfo lessRestrictiveRule = null;\n+        for (LayerGroupInfo lgi : groups) {\n+            WorkspaceInfo ws = lgi.getWorkspace();\n+            String workspace = ws != null ? ws.getName() : null;\n+            String layer = lgi.getName();\n+            RuleFilter filter = buildRuleFilter(workspace, layer, user);\n+            AccessInfo accessInfo = rules.getAccessInfo(filter);\n+            lessRestrictiveRule = getLessRestrictiveRule(lessRestrictiveRule, accessInfo);\n+            allowedArea =\n+                    getReprojectArea(accessInfo, lgi.getBounds().getCoordinateReferenceSystem());\n         }\n+        return new ImmutablePair<>(allowedArea, lessRestrictiveRule);\n+    }\n \n-        DataAccessLimits limits = buildAccessLimits(resource, rule);\n-        LOGGER.log(\n-                Level.FINE,\n-                \"Returning {0} for layer {1} and user {2}\",\n-                new Object[] {limits, resource.prefixedName(), username});\n+    // get the AccessInfo from the layer's containers returning a tuple with\n+    // the Geometry of the allowed area if found and the less restrictive accessInfo\n+    // among the ones of associated layerGroups\n+    private Pair<Geometry, AccessInfo> getContainerRuleForLayerDirectAccess(\n+            Object resource, Authentication user) {\n+        MutablePair<Geometry, AccessInfo> result = new MutablePair<>(null, null);\n+        Collection<LayerGroupContainmentCache.LayerGroupSummary> summaries;\n+        if (resource instanceof ResourceInfo)\n+            summaries = groupsCache.getContainerGroupsFor((ResourceInfo) resource);\n+        else if (resource instanceof LayerInfo)\n+            summaries = groupsCache.getContainerGroupsFor(((LayerInfo) resource).getResource());\n+        else summaries = groupsCache.getContainerGroupsFor((LayerGroupInfo) resource);\n+\n+        for (LayerGroupContainmentCache.LayerGroupSummary gs : summaries) {\n+            LayerGroupInfo.Mode mode = gs.getMode();\n+            if (mode.equals(LayerGroupInfo.Mode.OPAQUE_CONTAINER)) {\n+                // opaque mode deny access for the layer\n+                AccessInfo newInfo = AccessInfo.DENY_ALL;\n+                result.setValue(getLessRestrictiveRule(result.getRight(), newInfo));\n+            } else if (!mode.equals(LayerGroupInfo.Mode.SINGLE)) {\n+                // not opaque and not single mode, the container rule\n+                // should override the layer rule\n+                String workspace = gs.getWorkspace();\n+                String layer = gs.getName();\n+                RuleFilter filter = buildRuleFilter(workspace, layer, user);\n+                AccessInfo newInfo = rules.getAccessInfo(filter);\n+                newInfo = getLessRestrictiveRule(result.getRight(), newInfo);\n+                result.setRight(newInfo);\n+                if (newInfo.getAreaWkt() != null) {\n+                    LayerGroupInfo gi = catalog.getLayerGroupByName(layer);\n+                    CoordinateReferenceSystem crs = gi.getBounds().getCoordinateReferenceSystem();\n+                    Geometry allowedArea = getReprojectArea(newInfo, crs);\n+                    result.setLeft(allowedArea);\n+                }\n+            }\n+        }\n+        return result;\n+    }\n \n-        return limits;\n+    // compares two access info and return the less restrictive one\n+    private AccessInfo getLessRestrictiveRule(AccessInfo current, AccessInfo newInfo) {\n+        if (newInfo == null) return current;", "originalCommit": "eccecaf488f41a45373bd576ed48db293c50b410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4MjY4NQ==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r539982685", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-12-10T08:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM5MTM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM5MzI0NA==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r537393244", "bodyText": "So if both are of type \"limit\", the less restrictive is the \"current\" one? Shouldn'it it somehow merge the rules, I don't know, pick the OR of the filters, the union of the geometries, the union of the list of attributes (and also say something about attribute read/write restrictions?).\nI'm not saying it's the thing to do, just wondering really. The way to go is to first clarify in the documentation what is the indeded behavior, and then implement it consistently.", "author": "aaime", "createdAt": "2020-12-07T10:26:30Z", "path": "src/extension/geofence/src/main/java/org/geoserver/geofence/GeofenceAccessManager.java", "diffHunk": "@@ -269,108 +279,189 @@ public StyleAccessLimits getAccessLimits(Authentication user, StyleInfo style) {\n \n     @Override\n     public LayerGroupAccessLimits getAccessLimits(Authentication user, LayerGroupInfo layerInfo) {\n-        // return getAccessLimits(user, layerInfo.getResource());\n-        LOGGER.fine(\"Not limiting layergroups\");\n-        return null;\n-        // TODO\n+        return getAccessLimits(user, layerInfo, Collections.emptyList());\n     }\n \n     @Override\n     public DataAccessLimits getAccessLimits(Authentication user, LayerInfo layer) {\n         LOGGER.log(Level.FINE, \"Getting access limits for Layer {0}\", layer.getName());\n-        return getAccessLimits(user, layer.getResource());\n+        return getAccessLimits(user, layer, Collections.emptyList());\n     }\n \n     @Override\n     public DataAccessLimits getAccessLimits(Authentication user, ResourceInfo resource) {\n         LOGGER.log(Level.FINE, \"Getting access limits for Resource {0}\", resource.getName());\n         // extract the user name\n-        String username = null;\n+        String workspace = resource.getStore().getWorkspace().getName();\n+        String layer = resource.getName();\n+        return (DataAccessLimits)\n+                getAccessLimits(user, resource, layer, workspace, Collections.emptyList());\n+    }\n+\n+    @Override\n+    public DataAccessLimits getAccessLimits(\n+            Authentication user, LayerInfo layer, List<LayerGroupInfo> containers) {\n+        String workspace = layer.getResource().getStore().getWorkspace().getName();\n+        String layerName = layer.getName();\n+        return (DataAccessLimits) getAccessLimits(user, layer, layerName, workspace, containers);\n+    }\n+\n+    @Override\n+    public LayerGroupAccessLimits getAccessLimits(\n+            Authentication user, LayerGroupInfo layerGroup, List<LayerGroupInfo> containers) {\n+        WorkspaceInfo ws = layerGroup.getWorkspace();\n+        String workspace = ws != null ? ws.getName() : null;\n+        String layer = layerGroup.getName();\n+        return (LayerGroupAccessLimits)\n+                getAccessLimits(user, layerGroup, layer, workspace, containers);\n+    }\n+\n+    private AccessLimits getAccessLimits(\n+            Authentication user,\n+            CatalogInfo info,\n+            String layer,\n+            String workspace,\n+            List<LayerGroupInfo> containers) {\n         if ((user != null) && !(user instanceof AnonymousAuthenticationToken)) {\n             // shortcut, if the user is the admin, he can do everything\n             if (isAdmin(user)) {\n                 LOGGER.log(\n                         Level.FINE,\n                         \"Admin level access, returning \" + \"full rights for layer {0}\",\n-                        resource.prefixedName());\n-\n-                return buildAccessLimits(resource, AccessInfo.ALLOW_ALL);\n-            }\n-\n-            username = user.getName();\n-            if (username != null && username.isEmpty()) {\n-                username = null;\n+                        layer);\n+                return buildAdminAccessLimits(info);\n             }\n         }\n \n-        // get info from the current request\n-        String service = null;\n-        String request = null;\n-        Request owsRequest = Dispatcher.REQUEST.get();\n-        if (owsRequest != null) {\n-            service = owsRequest.getService();\n-            request = owsRequest.getRequest();\n+        RuleFilter ruleFilter = buildRuleFilter(workspace, layer, user);\n+        AccessInfo rule = rules.getAccessInfo(ruleFilter);\n+        Pair<Geometry, AccessInfo> containerRule =\n+                getAllowedAreaAndAccessInfoFromContainers(info, containers, user);\n+        if (rule == null) rule = AccessInfo.DENY_ALL;\n+\n+        AccessLimits limits;\n+        if (info instanceof LayerGroupInfo) {\n+            limits = buildLayerGroupAccessLimits(rule, containerRule);\n+        } else if (info instanceof ResourceInfo) {\n+            limits = buildResourceAccessLimits((ResourceInfo) info, rule, containerRule);\n+        } else {\n+            limits =\n+                    buildResourceAccessLimits(\n+                            ((LayerInfo) info).getResource(), rule, containerRule);\n         }\n \n-        // get the resource info\n-        String layer = resource.getName();\n-        StoreInfo store = resource.getStore();\n-        WorkspaceInfo ws = store.getWorkspace();\n-        String workspace = ws.getName();\n+        LOGGER.log(\n+                Level.FINE,\n+                \"Returning {0} for layer {1} and user {2}\",\n+                new Object[] {limits, layer, getUserNameFromAuth(user)});\n \n-        // get the request infos\n-        RuleFilter ruleFilter = new RuleFilter(RuleFilter.SpecialFilterType.ANY);\n-        setRuleFilterUserOrRole(user, ruleFilter);\n+        return limits;\n+    }\n \n-        ruleFilter.setInstance(configurationManager.getConfiguration().getInstanceName());\n-        if (service != null) {\n-            if (\"*\".equals(service)) {\n-                ruleFilter.setService(RuleFilter.SpecialFilterType.ANY);\n-            } else {\n-                ruleFilter.setService(service);\n-            }\n-        } else {\n-            ruleFilter.setService(RuleFilter.SpecialFilterType.DEFAULT);\n-        }\n+    // build the accessLimits for an admin user\n+    private AccessLimits buildAdminAccessLimits(CatalogInfo info) {\n+        AccessLimits accessLimits;\n+        if (info instanceof LayerGroupInfo)\n+            accessLimits = buildLayerGroupAccessLimits(AccessInfo.ALLOW_ALL, null);\n+        else if (info instanceof ResourceInfo)\n+            accessLimits =\n+                    buildResourceAccessLimits((ResourceInfo) info, AccessInfo.ALLOW_ALL, null);\n+        else\n+            accessLimits =\n+                    buildResourceAccessLimits(\n+                            ((LayerInfo) info).getResource(), AccessInfo.ALLOW_ALL, null);\n+        return accessLimits;\n+    }\n \n-        if (request != null) {\n-            if (\"*\".equals(request)) {\n-                ruleFilter.setRequest(RuleFilter.SpecialFilterType.ANY);\n-            } else {\n-                ruleFilter.setRequest(request);\n-            }\n+    private Pair<Geometry, AccessInfo> getAllowedAreaAndAccessInfoFromContainers(\n+            CatalogInfo resource, List<LayerGroupInfo> containers, Authentication user) {\n+        boolean directAccess = containers == null || containers.isEmpty();\n+        Request req = Dispatcher.REQUEST.get();\n+        String service = req != null ? req.getService() : null;\n+        boolean isWms = service != null && service.equalsIgnoreCase(\"WMS\");\n+        Pair<Geometry, AccessInfo> containerRule = null;\n+        if (directAccess && isWms) {\n+            containerRule = getContainerRuleForLayerDirectAccess(resource, user);\n         } else {\n-            ruleFilter.setRequest(RuleFilter.SpecialFilterType.DEFAULT);\n+            containerRule = handleContainers(containers, user);\n         }\n-        ruleFilter.setWorkspace(workspace);\n-        ruleFilter.setLayer(layer);\n+        return containerRule;\n+    }\n \n-        String sourceAddress = retrieveCallerIpAddress();\n-        if (sourceAddress != null) {\n-            ruleFilter.setSourceAddress(sourceAddress);\n-        } else {\n-            LOGGER.log(Level.WARNING, \"No source IP address found\");\n-            ruleFilter.setSourceAddress(RuleFilter.SpecialFilterType.DEFAULT);\n+    private String getUserNameFromAuth(Authentication authentication) {\n+        String username = authentication != null ? authentication.getName() : null;\n+        if (username != null && username.isEmpty()) {\n+            username = null;\n         }\n+        return username;\n+    }\n \n-        LOGGER.log(Level.FINE, \"ResourceInfo filter: {0}\", ruleFilter);\n-\n-        AccessInfo rule = rules.getAccessInfo(ruleFilter);\n-\n-        if (rule == null) {\n-            rule = AccessInfo.DENY_ALL;\n+    private Pair<Geometry, AccessInfo> handleContainers(\n+            List<LayerGroupInfo> groups, Authentication user) {\n+        Geometry allowedArea = null;\n+        AccessInfo lessRestrictiveRule = null;\n+        for (LayerGroupInfo lgi : groups) {\n+            WorkspaceInfo ws = lgi.getWorkspace();\n+            String workspace = ws != null ? ws.getName() : null;\n+            String layer = lgi.getName();\n+            RuleFilter filter = buildRuleFilter(workspace, layer, user);\n+            AccessInfo accessInfo = rules.getAccessInfo(filter);\n+            lessRestrictiveRule = getLessRestrictiveRule(lessRestrictiveRule, accessInfo);\n+            allowedArea =\n+                    getReprojectArea(accessInfo, lgi.getBounds().getCoordinateReferenceSystem());\n         }\n+        return new ImmutablePair<>(allowedArea, lessRestrictiveRule);\n+    }\n \n-        DataAccessLimits limits = buildAccessLimits(resource, rule);\n-        LOGGER.log(\n-                Level.FINE,\n-                \"Returning {0} for layer {1} and user {2}\",\n-                new Object[] {limits, resource.prefixedName(), username});\n+    // get the AccessInfo from the layer's containers returning a tuple with\n+    // the Geometry of the allowed area if found and the less restrictive accessInfo\n+    // among the ones of associated layerGroups\n+    private Pair<Geometry, AccessInfo> getContainerRuleForLayerDirectAccess(\n+            Object resource, Authentication user) {\n+        MutablePair<Geometry, AccessInfo> result = new MutablePair<>(null, null);\n+        Collection<LayerGroupContainmentCache.LayerGroupSummary> summaries;\n+        if (resource instanceof ResourceInfo)\n+            summaries = groupsCache.getContainerGroupsFor((ResourceInfo) resource);\n+        else if (resource instanceof LayerInfo)\n+            summaries = groupsCache.getContainerGroupsFor(((LayerInfo) resource).getResource());\n+        else summaries = groupsCache.getContainerGroupsFor((LayerGroupInfo) resource);\n+\n+        for (LayerGroupContainmentCache.LayerGroupSummary gs : summaries) {\n+            LayerGroupInfo.Mode mode = gs.getMode();\n+            if (mode.equals(LayerGroupInfo.Mode.OPAQUE_CONTAINER)) {\n+                // opaque mode deny access for the layer\n+                AccessInfo newInfo = AccessInfo.DENY_ALL;\n+                result.setValue(getLessRestrictiveRule(result.getRight(), newInfo));\n+            } else if (!mode.equals(LayerGroupInfo.Mode.SINGLE)) {\n+                // not opaque and not single mode, the container rule\n+                // should override the layer rule\n+                String workspace = gs.getWorkspace();\n+                String layer = gs.getName();\n+                RuleFilter filter = buildRuleFilter(workspace, layer, user);\n+                AccessInfo newInfo = rules.getAccessInfo(filter);\n+                newInfo = getLessRestrictiveRule(result.getRight(), newInfo);\n+                result.setRight(newInfo);\n+                if (newInfo.getAreaWkt() != null) {\n+                    LayerGroupInfo gi = catalog.getLayerGroupByName(layer);\n+                    CoordinateReferenceSystem crs = gi.getBounds().getCoordinateReferenceSystem();\n+                    Geometry allowedArea = getReprojectArea(newInfo, crs);\n+                    result.setLeft(allowedArea);\n+                }\n+            }\n+        }\n+        return result;\n+    }\n \n-        return limits;\n+    // compares two access info and return the less restrictive one\n+    private AccessInfo getLessRestrictiveRule(AccessInfo current, AccessInfo newInfo) {\n+        if (newInfo == null) return current;\n+        else if (current == null) return newInfo;\n+        else if (current.getGrant().equals(GrantType.DENY)) return newInfo;\n+        else if (current.getGrant().equals(GrantType.LIMIT)\n+                && newInfo.getGrant().equals(GrantType.ALLOW)) return newInfo;\n+        else return current;", "originalCommit": "eccecaf488f41a45373bd576ed48db293c50b410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM5NDA1Nw==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r537394057", "bodyText": "Also, if things are implemented consistently, I'm guessing you won't need pairs to bring aroud the AccessInfo (which contains a geometry itself) and the geometry, just build a new access info applying the aggregation rules.", "author": "aaime", "createdAt": "2020-12-07T10:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM5MzI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4NjgwMg==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r539986802", "bodyText": "Thanks for your point @aaime. The LayerGroup doesn't have the possibility to define read write filters, so the thing to handle in that piece of is the allowedArea filter.\nI added the necessary logic to union the two geometries if the rules have the same grantType and have an allowedArea. If one of the container which might affect the layer (eg. NAMED) doesn't have an allowed area then no allowed area will be specified (the less restrictive).\nRegarding the Pairs usage: the allowed area needs to be reprojected according to the LayerGroup CRS and inside the rule is served as WKT. The only way I found to handle this situation and pass to the Layer Limit building process a Geometry ready to be included in the filter was to use Pairs.", "author": "taba90", "createdAt": "2020-12-10T08:56:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM5MzI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM5ODA4OQ==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r537398089", "bodyText": "Weak testing, should verify various layer group modes and layers contained in multiple groups. Probably better done in \"AccessManagerTest\" though, as you can verify how the final access rules contain.", "author": "aaime", "createdAt": "2020-12-07T10:33:57Z", "path": "src/extension/geofence-server/src/test/java/org/geoserver/geofence/web/GeofenceRulePageTest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+\n+package org.geoserver.geofence.web;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.logging.Level;\n+import org.apache.wicket.markup.html.form.DropDownChoice;\n+import org.apache.wicket.markup.html.form.Form;\n+import org.apache.wicket.util.tester.FormTester;\n+import org.geoserver.data.test.SystemTestData;\n+import org.geoserver.web.data.layergroup.LayerGroupBaseTest;\n+import org.junit.Test;\n+import org.opengis.referencing.FactoryException;\n+\n+public class GeofenceRulePageTest extends LayerGroupBaseTest {\n+\n+    @Override\n+    protected void onSetUp(SystemTestData testData) throws Exception {\n+        login();\n+        super.onSetUp(testData);\n+    }\n+\n+    @Test\n+    public void testAddLayerGroupRule() throws FactoryException {", "originalCommit": "eccecaf488f41a45373bd576ed48db293c50b410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4ODE4NQ==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r539988185", "bodyText": "I've added a GeofenceAccessManagerIntegrationTest class to tests the accessManager behaviour with direct access and multiple containers. Also a GetMapIntegration class was already present in the first commit of this pull request, showing tests for SINGLE and OPAQUE containers, with and without allowed areas", "author": "taba90", "createdAt": "2020-12-10T08:58:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM5ODA4OQ=="}], "type": "inlineReview"}, {"oid": "22143264c3b48584cc7d6031a1945488b71a9f43", "url": "https://github.com/geoserver/geoserver/commit/22143264c3b48584cc7d6031a1945488b71a9f43", "message": "[GEOS-9817] Add LayerGroup support to Geofence", "committedDate": "2020-12-10T08:48:04Z", "type": "commit"}, {"oid": "e5bb4f6e51eab1b620b883acb50f666e1415cc34", "url": "https://github.com/geoserver/geoserver/commit/e5bb4f6e51eab1b620b883acb50f666e1415cc34", "message": "reviewer's suggestion applied", "committedDate": "2020-12-10T08:48:04Z", "type": "forcePushed"}, {"oid": "285464bb23ac4ffef8fdb623f02d1e2cea22b585", "url": "https://github.com/geoserver/geoserver/commit/285464bb23ac4ffef8fdb623f02d1e2cea22b585", "message": "reviewer's suggestion applied", "committedDate": "2020-12-10T12:00:09Z", "type": "forcePushed"}, {"oid": "5c9becbd352b41161813de017d0d3ad05c446e18", "url": "https://github.com/geoserver/geoserver/commit/5c9becbd352b41161813de017d0d3ad05c446e18", "message": "reviewer's suggestion applied", "committedDate": "2020-12-10T12:55:12Z", "type": "commit"}, {"oid": "5c9becbd352b41161813de017d0d3ad05c446e18", "url": "https://github.com/geoserver/geoserver/commit/5c9becbd352b41161813de017d0d3ad05c446e18", "message": "reviewer's suggestion applied", "committedDate": "2020-12-10T12:55:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgyNDA4NA==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r540824084", "bodyText": "Also konwn as:\nboolean enableFiltersAndStyles = !layerType.getValue().equals(LayerType.LAYERGROUP.name()));", "author": "aaime", "createdAt": "2020-12-11T09:52:57Z", "path": "src/extension/geofence-server/src/main/java/org/geoserver/geofence/web/GeofenceRulePage.java", "diffHunk": "@@ -752,17 +742,16 @@ protected void onUpdate(AjaxRequestTarget target) {\n                     new AjaxFormComponentUpdatingBehavior(\"onchange\") {\n                         @Override\n                         protected void onUpdate(AjaxRequestTarget ajaxRequestTarget) {\n-                            boolean enableFiltersAndStyles = true;\n-                            if (layerType.getValue().equals(LayerType.LAYERGROUP.name()))\n-                                enableFiltersAndStyles = false;\n-\n+                            boolean enableFiltersAndStyles =", "originalCommit": "5c9becbd352b41161813de017d0d3ad05c446e18", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE5MDM2OA==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r542190368", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-12-14T08:21:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgyNDA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgyNjI3MA==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r540826270", "bodyText": "Seems a bit convoluted... if this code works, makes me think the second expression is a Literal, which means the following is likely to work as well:\nMultiPolygon filterArea = filter.getExpressions2(null, MultiPolygon.class);", "author": "aaime", "createdAt": "2020-12-11T09:56:27Z", "path": "src/extension/geofence-server/src/test/java/org/geoserver/geofence/integration/GeofenceAccessManagerIntegrationTest.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.geofence.integration;\n+\n+import static org.geoserver.geofence.integration.GeofenceGetMapIntegrationTest.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.geoserver.catalog.*;\n+import org.geoserver.data.test.MockData;\n+import org.geoserver.data.test.SystemTestData;\n+import org.geoserver.geofence.GeofenceAccessManager;\n+import org.geoserver.geofence.core.model.enums.CatalogMode;\n+import org.geoserver.geofence.core.model.enums.GrantType;\n+import org.geoserver.geofence.services.RuleAdminService;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.ows.Request;\n+import org.geoserver.security.VectorAccessLimits;\n+import org.geoserver.test.GeoServerSystemTestSupport;\n+import org.geotools.filter.visitor.DefaultFilterVisitor;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.MultiPolygon;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.FilterVisitor;\n+import org.opengis.filter.spatial.Intersects;\n+import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.GrantedAuthority;\n+import org.springframework.security.core.authority.SimpleGrantedAuthority;\n+\n+public class GeofenceAccessManagerIntegrationTest extends GeoServerSystemTestSupport {\n+\n+    private GeofenceAccessManager accessManager;\n+    private RuleAdminService ruleService;\n+\n+    @Before\n+    public void setUp() {\n+        accessManager =\n+                applicationContext.getBean(\n+                        \"geofenceRuleAccessManager\", GeofenceAccessManager.class);\n+        ruleService = (RuleAdminService) applicationContext.getBean(\"ruleAdminService\");\n+        // add rule to grant access to all to everything with a very low priority\n+        if (ruleService.getRuleByPriority(9999) == null)\n+            addRule(GrantType.ALLOW, null, null, null, null, null, null, 9999, ruleService);\n+    }\n+\n+    @Override\n+    protected void setUpTestData(SystemTestData testData) throws Exception {\n+        super.setUpTestData(testData);\n+    }\n+\n+    @Test\n+    public void testAllowedAreaLayerInTwoGroups() throws Exception {\n+        // tests that when a Layer is directly accessed for WMS request\n+        // if it is belonging to more then one LayerGroup, if one of the container\n+        // LayerGroup doesn't have an allowed area, there will be no allowedArea in the final\n+        // filter.\n+        Long idRule = null;\n+        Long idRule2 = null;\n+        LayerGroupInfo group1 = null;\n+        LayerGroupInfo group2 = null;\n+        try {\n+            Authentication user = getUser(\"anonymousUser\", \"\", \"ROLE_ANONYMOUS\");\n+            login(\"admin\", \"geoserver\", new String[] {\"ROLE_ADMINISTRATOR\"});\n+            Catalog catalog = getCatalog();\n+\n+            LayerInfo places = catalog.getLayerByName(getLayerId(MockData.NAMED_PLACES));\n+            LayerInfo forests = catalog.getLayerByName(getLayerId(MockData.FORESTS));\n+\n+            group1 =\n+                    createsLayerGroup(\n+                            catalog,\n+                            \"group21\",\n+                            LayerGroupInfo.Mode.NAMED,\n+                            null,\n+                            Arrays.asList(places, forests));\n+            group2 =\n+                    createsLayerGroup(\n+                            catalog,\n+                            \"group22\",\n+                            LayerGroupInfo.Mode.NAMED,\n+                            null,\n+                            Arrays.asList(places, forests));\n+            // rule to grant access in general to everyone\n+            // limit rule for anonymousUser on LayerGroup group1\n+            idRule =\n+                    addRule(\n+                            GrantType.LIMIT,\n+                            \"anonymousUser\",\n+                            \"ROLE_ANONYMOUS\",\n+                            \"WMS\",\n+                            null,\n+                            null,\n+                            \"group21\",\n+                            0,\n+                            ruleService);\n+\n+            // limit rule for anonymousUser on LayerGroup group2\n+            idRule2 =\n+                    addRule(\n+                            GrantType.LIMIT,\n+                            \"anonymousUser\",\n+                            \"ROLE_ANONYMOUS\",\n+                            \"WMS\",\n+                            null,\n+                            null,\n+                            \"group22\",\n+                            1,\n+                            ruleService);\n+\n+            // add allowed Area only to the first layer group\n+            String areWKT =\n+                    \"MULTIPOLYGON(((0.0016139656066815888 -0.0006386457758059581,0.0019599705696027314 -0.0006386457758059581,0.0019599705696027314 -0.0008854090051601674,0.0016139656066815888 -0.0008854090051601674,0.0016139656066815888 -0.0006386457758059581)))\";\n+            addRuleLimits(idRule, CatalogMode.HIDE, areWKT, 4326, ruleService);\n+\n+            // mock a WMS request to check contained layers direct access\n+            Request req = new Request();\n+            req.setService(\"WMS\");\n+            req.setRequest(\"GetMap\");\n+            Dispatcher.REQUEST.set(req);\n+            logout();\n+\n+            login(\"anonymousUser\", \"\", new String[] {\"ROLE_ANONYMOUS\"});\n+\n+            VectorAccessLimits vl =\n+                    (VectorAccessLimits) accessManager.getAccessLimits(user, places);\n+\n+            assertEquals(vl.getReadFilter(), Filter.INCLUDE);\n+            assertEquals(vl.getWriteFilter(), Filter.INCLUDE);\n+            logout();\n+        } finally {\n+            removeLayerGroup(group1, group2);\n+            deleteRules(ruleService, idRule, idRule2);\n+        }\n+    }\n+\n+    @Test\n+    public void testAllowedAreaLayerInTwoGroups2() throws Exception {\n+        // tests that when a Layer is directly accessed for WMS request\n+        // if it is belonging to more then one LayerGroup, the allowedArea\n+        // applied to the filter is the union of the allowed area of each LayerGroup\n+        Long idRule = null;\n+        Long idRule2 = null;\n+        LayerGroupInfo group1 = null;\n+        LayerGroupInfo group2 = null;\n+        try {\n+            Authentication user = getUser(\"anonymousUser\", \"\", \"ROLE_ANONYMOUS\");\n+            login(\"admin\", \"geoserver\", new String[] {\"ROLE_ADMINISTRATOR\"});\n+            Catalog catalog = getCatalog();\n+            LayerInfo bridges = catalog.getLayerByName(getLayerId(MockData.BRIDGES));\n+            LayerInfo buildings = catalog.getLayerByName(getLayerId(MockData.BUILDINGS));\n+            group1 =\n+                    createsLayerGroup(\n+                            catalog,\n+                            \"group1\",\n+                            LayerGroupInfo.Mode.NAMED,\n+                            null,\n+                            Arrays.asList(bridges, buildings));\n+            group2 =\n+                    createsLayerGroup(\n+                            catalog,\n+                            \"group2\",\n+                            LayerGroupInfo.Mode.NAMED,\n+                            null,\n+                            Arrays.asList(bridges, buildings));\n+            // limit rule for anonymousUser on LayerGroup group1\n+            idRule =\n+                    addRule(\n+                            GrantType.LIMIT,\n+                            \"anonymousUser\",\n+                            \"ROLE_ANONYMOUS\",\n+                            \"WMS\",\n+                            null,\n+                            null,\n+                            \"group1\",\n+                            2,\n+                            ruleService);\n+\n+            // limit rule for anonymousUser on LayerGroup group2\n+            idRule2 =\n+                    addRule(\n+                            GrantType.LIMIT,\n+                            \"anonymousUser\",\n+                            \"ROLE_ANONYMOUS\",\n+                            \"WMS\",\n+                            null,\n+                            null,\n+                            \"group2\",\n+                            3,\n+                            ruleService);\n+\n+            // add allowed Area to layer groups rules\n+            String areWKT =\n+                    \"MULTIPOLYGON(((0.0016139656066815888 -0.0006386457758059581,0.0019599705696027314 -0.0006386457758059581,0.0019599705696027314 -0.0008854090051601674,0.0016139656066815888 -0.0008854090051601674,0.0016139656066815888 -0.0006386457758059581)))\";\n+            addRuleLimits(idRule, CatalogMode.HIDE, areWKT, 4326, ruleService);\n+            String areaWKT2 =\n+                    \"MULTIPOLYGON(((0.0011204391479413545 -0.0006405065746780663,0.0015764146804730927 -0.0006405065746780663,0.0015764146804730927 -0.0014612625330857614,0.0011204391479413545 -0.0014612625330857614,0.0011204391479413545 -0.0006405065746780663)))\";\n+            addRuleLimits(idRule2, CatalogMode.HIDE, areaWKT2, 4326, ruleService);\n+\n+            // mock a WMS request to check contained layers direct access\n+            Request req = new Request();\n+            req.setService(\"WMS\");\n+            req.setRequest(\"GetMap\");\n+            Dispatcher.REQUEST.set(req);\n+            logout();\n+\n+            login(\"anonymousUser\", \"\", new String[] {\"ROLE_ANONYMOUS\"});\n+\n+            VectorAccessLimits vl =\n+                    (VectorAccessLimits) accessManager.getAccessLimits(user, bridges);\n+\n+            // Merge the allowed areas\n+            Geometry allowedArea1 = new WKTReader().read(areWKT);\n+            Geometry allowedArea2 = new WKTReader().read(areaWKT2);\n+            MultiPolygon totalArea = (MultiPolygon) allowedArea1.union(allowedArea2);\n+\n+            FilterVisitor visitor =\n+                    new DefaultFilterVisitor() {\n+                        @Override\n+                        public Object visit(Intersects filter, Object extraData) {\n+                            try {\n+                                MultiPolygon filterArea =", "originalCommit": "5c9becbd352b41161813de017d0d3ad05c446e18", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE5MDQyNg==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r542190426", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-12-14T08:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgyNjI3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgyNjg4Mw==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r540826883", "bodyText": "Are these wkts used in all tests? If so please avoid the copy paste, turn them into constants for the class.", "author": "aaime", "createdAt": "2020-12-11T09:57:22Z", "path": "src/extension/geofence-server/src/test/java/org/geoserver/geofence/integration/GeofenceAccessManagerIntegrationTest.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.geofence.integration;\n+\n+import static org.geoserver.geofence.integration.GeofenceGetMapIntegrationTest.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.geoserver.catalog.*;\n+import org.geoserver.data.test.MockData;\n+import org.geoserver.data.test.SystemTestData;\n+import org.geoserver.geofence.GeofenceAccessManager;\n+import org.geoserver.geofence.core.model.enums.CatalogMode;\n+import org.geoserver.geofence.core.model.enums.GrantType;\n+import org.geoserver.geofence.services.RuleAdminService;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.ows.Request;\n+import org.geoserver.security.VectorAccessLimits;\n+import org.geoserver.test.GeoServerSystemTestSupport;\n+import org.geotools.filter.visitor.DefaultFilterVisitor;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.MultiPolygon;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.FilterVisitor;\n+import org.opengis.filter.spatial.Intersects;\n+import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.GrantedAuthority;\n+import org.springframework.security.core.authority.SimpleGrantedAuthority;\n+\n+public class GeofenceAccessManagerIntegrationTest extends GeoServerSystemTestSupport {\n+\n+    private GeofenceAccessManager accessManager;\n+    private RuleAdminService ruleService;\n+\n+    @Before\n+    public void setUp() {\n+        accessManager =\n+                applicationContext.getBean(\n+                        \"geofenceRuleAccessManager\", GeofenceAccessManager.class);\n+        ruleService = (RuleAdminService) applicationContext.getBean(\"ruleAdminService\");\n+        // add rule to grant access to all to everything with a very low priority\n+        if (ruleService.getRuleByPriority(9999) == null)\n+            addRule(GrantType.ALLOW, null, null, null, null, null, null, 9999, ruleService);\n+    }\n+\n+    @Override\n+    protected void setUpTestData(SystemTestData testData) throws Exception {\n+        super.setUpTestData(testData);\n+    }\n+\n+    @Test\n+    public void testAllowedAreaLayerInTwoGroups() throws Exception {\n+        // tests that when a Layer is directly accessed for WMS request\n+        // if it is belonging to more then one LayerGroup, if one of the container\n+        // LayerGroup doesn't have an allowed area, there will be no allowedArea in the final\n+        // filter.\n+        Long idRule = null;\n+        Long idRule2 = null;\n+        LayerGroupInfo group1 = null;\n+        LayerGroupInfo group2 = null;\n+        try {\n+            Authentication user = getUser(\"anonymousUser\", \"\", \"ROLE_ANONYMOUS\");\n+            login(\"admin\", \"geoserver\", new String[] {\"ROLE_ADMINISTRATOR\"});\n+            Catalog catalog = getCatalog();\n+\n+            LayerInfo places = catalog.getLayerByName(getLayerId(MockData.NAMED_PLACES));\n+            LayerInfo forests = catalog.getLayerByName(getLayerId(MockData.FORESTS));\n+\n+            group1 =\n+                    createsLayerGroup(\n+                            catalog,\n+                            \"group21\",\n+                            LayerGroupInfo.Mode.NAMED,\n+                            null,\n+                            Arrays.asList(places, forests));\n+            group2 =\n+                    createsLayerGroup(\n+                            catalog,\n+                            \"group22\",\n+                            LayerGroupInfo.Mode.NAMED,\n+                            null,\n+                            Arrays.asList(places, forests));\n+            // rule to grant access in general to everyone\n+            // limit rule for anonymousUser on LayerGroup group1\n+            idRule =\n+                    addRule(\n+                            GrantType.LIMIT,\n+                            \"anonymousUser\",\n+                            \"ROLE_ANONYMOUS\",\n+                            \"WMS\",\n+                            null,\n+                            null,\n+                            \"group21\",\n+                            0,\n+                            ruleService);\n+\n+            // limit rule for anonymousUser on LayerGroup group2\n+            idRule2 =\n+                    addRule(\n+                            GrantType.LIMIT,\n+                            \"anonymousUser\",\n+                            \"ROLE_ANONYMOUS\",\n+                            \"WMS\",\n+                            null,\n+                            null,\n+                            \"group22\",\n+                            1,\n+                            ruleService);\n+\n+            // add allowed Area only to the first layer group\n+            String areWKT =\n+                    \"MULTIPOLYGON(((0.0016139656066815888 -0.0006386457758059581,0.0019599705696027314 -0.0006386457758059581,0.0019599705696027314 -0.0008854090051601674,0.0016139656066815888 -0.0008854090051601674,0.0016139656066815888 -0.0006386457758059581)))\";\n+            addRuleLimits(idRule, CatalogMode.HIDE, areWKT, 4326, ruleService);\n+\n+            // mock a WMS request to check contained layers direct access\n+            Request req = new Request();\n+            req.setService(\"WMS\");\n+            req.setRequest(\"GetMap\");\n+            Dispatcher.REQUEST.set(req);\n+            logout();\n+\n+            login(\"anonymousUser\", \"\", new String[] {\"ROLE_ANONYMOUS\"});\n+\n+            VectorAccessLimits vl =\n+                    (VectorAccessLimits) accessManager.getAccessLimits(user, places);\n+\n+            assertEquals(vl.getReadFilter(), Filter.INCLUDE);\n+            assertEquals(vl.getWriteFilter(), Filter.INCLUDE);\n+            logout();\n+        } finally {\n+            removeLayerGroup(group1, group2);\n+            deleteRules(ruleService, idRule, idRule2);\n+        }\n+    }\n+\n+    @Test\n+    public void testAllowedAreaLayerInTwoGroups2() throws Exception {\n+        // tests that when a Layer is directly accessed for WMS request\n+        // if it is belonging to more then one LayerGroup, the allowedArea\n+        // applied to the filter is the union of the allowed area of each LayerGroup\n+        Long idRule = null;\n+        Long idRule2 = null;\n+        LayerGroupInfo group1 = null;\n+        LayerGroupInfo group2 = null;\n+        try {\n+            Authentication user = getUser(\"anonymousUser\", \"\", \"ROLE_ANONYMOUS\");\n+            login(\"admin\", \"geoserver\", new String[] {\"ROLE_ADMINISTRATOR\"});\n+            Catalog catalog = getCatalog();\n+            LayerInfo bridges = catalog.getLayerByName(getLayerId(MockData.BRIDGES));\n+            LayerInfo buildings = catalog.getLayerByName(getLayerId(MockData.BUILDINGS));\n+            group1 =\n+                    createsLayerGroup(\n+                            catalog,\n+                            \"group1\",\n+                            LayerGroupInfo.Mode.NAMED,\n+                            null,\n+                            Arrays.asList(bridges, buildings));\n+            group2 =\n+                    createsLayerGroup(\n+                            catalog,\n+                            \"group2\",\n+                            LayerGroupInfo.Mode.NAMED,\n+                            null,\n+                            Arrays.asList(bridges, buildings));\n+            // limit rule for anonymousUser on LayerGroup group1\n+            idRule =\n+                    addRule(\n+                            GrantType.LIMIT,\n+                            \"anonymousUser\",\n+                            \"ROLE_ANONYMOUS\",\n+                            \"WMS\",\n+                            null,\n+                            null,\n+                            \"group1\",\n+                            2,\n+                            ruleService);\n+\n+            // limit rule for anonymousUser on LayerGroup group2\n+            idRule2 =\n+                    addRule(\n+                            GrantType.LIMIT,\n+                            \"anonymousUser\",\n+                            \"ROLE_ANONYMOUS\",\n+                            \"WMS\",\n+                            null,\n+                            null,\n+                            \"group2\",\n+                            3,\n+                            ruleService);\n+\n+            // add allowed Area to layer groups rules\n+            String areWKT =\n+                    \"MULTIPOLYGON(((0.0016139656066815888 -0.0006386457758059581,0.0019599705696027314 -0.0006386457758059581,0.0019599705696027314 -0.0008854090051601674,0.0016139656066815888 -0.0008854090051601674,0.0016139656066815888 -0.0006386457758059581)))\";\n+            addRuleLimits(idRule, CatalogMode.HIDE, areWKT, 4326, ruleService);\n+            String areaWKT2 =\n+                    \"MULTIPOLYGON(((0.0011204391479413545 -0.0006405065746780663,0.0015764146804730927 -0.0006405065746780663,0.0015764146804730927 -0.0014612625330857614,0.0011204391479413545 -0.0014612625330857614,0.0011204391479413545 -0.0006405065746780663)))\";\n+            addRuleLimits(idRule2, CatalogMode.HIDE, areaWKT2, 4326, ruleService);\n+\n+            // mock a WMS request to check contained layers direct access\n+            Request req = new Request();\n+            req.setService(\"WMS\");\n+            req.setRequest(\"GetMap\");\n+            Dispatcher.REQUEST.set(req);\n+            logout();\n+\n+            login(\"anonymousUser\", \"\", new String[] {\"ROLE_ANONYMOUS\"});\n+\n+            VectorAccessLimits vl =\n+                    (VectorAccessLimits) accessManager.getAccessLimits(user, bridges);\n+\n+            // Merge the allowed areas\n+            Geometry allowedArea1 = new WKTReader().read(areWKT);\n+            Geometry allowedArea2 = new WKTReader().read(areaWKT2);\n+            MultiPolygon totalArea = (MultiPolygon) allowedArea1.union(allowedArea2);\n+\n+            FilterVisitor visitor =\n+                    new DefaultFilterVisitor() {\n+                        @Override\n+                        public Object visit(Intersects filter, Object extraData) {\n+                            try {\n+                                MultiPolygon filterArea =\n+                                        (MultiPolygon)\n+                                                new WKTReader()\n+                                                        .read(filter.getExpression2().toString());\n+\n+                                assertTrue(totalArea.equalsExact(filterArea, 10.0E-15));\n+                            } catch (ParseException e) {\n+                            }\n+                            return super.visit(filter, extraData);\n+                        }\n+                    };\n+            vl.getReadFilter().accept(visitor, null);\n+            vl.getWriteFilter().accept(visitor, null);\n+            logout();\n+        } finally {\n+            removeLayerGroup(group1, group2);\n+            deleteRules(ruleService, idRule, idRule2);\n+        }\n+    }\n+\n+    @Test\n+    public void testAllowedAreaLayerInTwoGroupsModeSingle() throws Exception {\n+        // tests that when a Layer is directly accessed for WMS request\n+        // if it is belonging to LayerGroups with SINGLE mode, the LayerGroup\n+        // is not applied\n+        Long idRule = null;\n+        Long idRule2 = null;\n+        LayerGroupInfo group1 = null;\n+        LayerGroupInfo group2 = null;\n+        try {\n+            Authentication user = getUser(\"anonymousUser\", \"\", \"ROLE_ANONYMOUS\");\n+            login(\"admin\", \"geoserver\", new String[] {\"ROLE_ADMINISTRATOR\"});\n+            Catalog catalog = getCatalog();\n+            LayerInfo lakes = catalog.getLayerByName(getLayerId(MockData.LAKES));\n+            LayerInfo fifteen = catalog.getLayerByName(getLayerId(MockData.FIFTEEN));\n+            group1 =\n+                    createsLayerGroup(\n+                            catalog,\n+                            \"group31\",\n+                            LayerGroupInfo.Mode.SINGLE,\n+                            null,\n+                            Arrays.asList(lakes, fifteen));\n+            group2 =\n+                    createsLayerGroup(\n+                            catalog,\n+                            \"group32\",\n+                            LayerGroupInfo.Mode.SINGLE,\n+                            null,\n+                            Arrays.asList(lakes, fifteen));\n+            // limit rule for anonymousUser on LayerGroup group1\n+            idRule =\n+                    addRule(\n+                            GrantType.LIMIT,\n+                            \"anonymousUser\",\n+                            \"ROLE_ANONYMOUS\",\n+                            \"WMS\",\n+                            null,\n+                            null,\n+                            \"group31\",\n+                            4,\n+                            ruleService);\n+\n+            // limit rule for anonymousUser on LayerGroup group2\n+            idRule2 =\n+                    addRule(\n+                            GrantType.LIMIT,\n+                            \"anonymousUser\",\n+                            \"ROLE_ANONYMOUS\",\n+                            \"WMS\",\n+                            null,\n+                            null,\n+                            \"group32\",\n+                            5,\n+                            ruleService);\n+\n+            // add allowed Area to layer groups rules\n+            String areWKT =", "originalCommit": "5c9becbd352b41161813de017d0d3ad05c446e18", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE5MDQ5Mg==", "url": "https://github.com/geoserver/geoserver/pull/4598#discussion_r542190492", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-12-14T08:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgyNjg4Mw=="}], "type": "inlineReview"}, {"oid": "637b268b303bb98546be130e05f36f2dbe7e8ab5", "url": "https://github.com/geoserver/geoserver/commit/637b268b303bb98546be130e05f36f2dbe7e8ab5", "message": "review feedback #2", "committedDate": "2020-12-11T16:19:11Z", "type": "commit"}, {"oid": "637b268b303bb98546be130e05f36f2dbe7e8ab5", "url": "https://github.com/geoserver/geoserver/commit/637b268b303bb98546be130e05f36f2dbe7e8ab5", "message": "review feedback #2", "committedDate": "2020-12-11T16:19:11Z", "type": "forcePushed"}]}