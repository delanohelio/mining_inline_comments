{"pr_number": 4344, "pr_title": "[GEOS-9663] Add support for GEOJSON output in the JSON-LD module and rename it", "pr_createdAt": "2020-06-25T09:05:31Z", "pr_url": "https://github.com/geoserver/geoserver/pull/4344", "timeline": [{"oid": "2fbc72eb264084e4f59609ec83bbd8c644b40c8d", "url": "https://github.com/geoserver/geoserver/commit/2fbc72eb264084e4f59609ec83bbd8c644b40c8d", "message": "refactoring", "committedDate": "2020-06-26T15:04:39Z", "type": "forcePushed"}, {"oid": "980df02467b664426ea087930561f37e45f92664", "url": "https://github.com/geoserver/geoserver/commit/980df02467b664426ea087930561f37e45f92664", "message": "refactoring", "committedDate": "2020-06-29T07:02:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxNjc1Nw==", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r447016757", "bodyText": "Un-necessary override", "author": "aaime", "createdAt": "2020-06-29T14:31:36Z", "path": "src/community/wfs-templating/src/main/java/org/geoserver/wfstemplating/writers/GeoJsonWriter.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+\n+package org.geoserver.wfstemplating.writers;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import org.geotools.geojson.geom.GeometryJSON;\n+import org.locationtech.jts.geom.Geometry;\n+\n+/** Implements its superclass methods to write a valid GeoJSON output */\n+public class GeoJsonWriter extends CommonJsonWriter {\n+\n+    public GeoJsonWriter(JsonGenerator generator, boolean flattenedList) {\n+        super(generator, flattenedList);\n+    }\n+\n+    @Override\n+    protected void writeValue(Object value) throws IOException {\n+        if (value instanceof String) {\n+            writeString((String) value);\n+        } else if (value instanceof Integer) {\n+            writeNumber((Integer) value);\n+        } else if (value instanceof Double) {\n+            writeNumber((Double) value);\n+        } else if (value instanceof Float) {\n+            writeNumber((Float) value);\n+        } else if (value instanceof Long) {\n+            writeNumber((Long) value);\n+        } else if (value instanceof BigInteger) {\n+            writeNumber((BigInteger) value);\n+        } else if (value instanceof BigDecimal) {\n+            writeNumber((BigDecimal) value);\n+        } else if (value instanceof Boolean) {\n+            writeBoolean((Boolean) value);\n+        }\n+    }\n+\n+    @Override\n+    protected void writeGeometry(Object value) throws IOException {\n+        GeometryJSON geomJson = new GeometryJSON();\n+        String strGeom = geomJson.toString((Geometry) value);\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonNode actualObj = mapper.readTree(strGeom);\n+        writeObjectNode(null, actualObj);\n+    }\n+\n+    @Override\n+    public void startJson() throws IOException {", "originalCommit": "980df02467b664426ea087930561f37e45f92664", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM2MDMxMA==", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r448360310", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-07-01T13:24:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxNjc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxNzA0MA==", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r447017040", "bodyText": "Wondering why the GeoJson writer has a writeValue method that looks a lot smarter than the jsonld one?", "author": "aaime", "createdAt": "2020-06-29T14:31:57Z", "path": "src/community/wfs-templating/src/main/java/org/geoserver/wfstemplating/writers/GeoJsonWriter.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+\n+package org.geoserver.wfstemplating.writers;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import org.geotools.geojson.geom.GeometryJSON;\n+import org.locationtech.jts.geom.Geometry;\n+\n+/** Implements its superclass methods to write a valid GeoJSON output */\n+public class GeoJsonWriter extends CommonJsonWriter {\n+\n+    public GeoJsonWriter(JsonGenerator generator, boolean flattenedList) {\n+        super(generator, flattenedList);\n+    }\n+\n+    @Override\n+    protected void writeValue(Object value) throws IOException {", "originalCommit": "980df02467b664426ea087930561f37e45f92664", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM4NzAzNQ==", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r448387035", "bodyText": "Because Json-ld needs every value encoded as a string", "author": "taba90", "createdAt": "2020-07-01T14:05:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxNzA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzMjEzMg==", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r447032132", "bodyText": "Confused... here it checks only the first feature type, but then during the loop each feature type is checked for template presence too. So, isn't this check redundant? The same seems to be happening in the GEoJSONTemplateGetFeatureResponse", "author": "aaime", "createdAt": "2020-06-29T14:52:07Z", "path": "src/community/wfs-templating/src/main/java/org/geoserver/wfstemplating/response/JSONLDGetFeatureResponse.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wfstemplating.response;\n+\n+import java.io.*;\n+import java.util.List;\n+import org.geoserver.catalog.FeatureTypeInfo;\n+import org.geoserver.config.GeoServer;\n+import org.geoserver.platform.Operation;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.wfs.WFSGetFeatureOutputFormat;\n+import org.geoserver.wfs.request.FeatureCollectionResponse;\n+import org.geoserver.wfs.request.GetFeatureRequest;\n+import org.geoserver.wfstemplating.builders.TemplateBuilder;\n+import org.geoserver.wfstemplating.builders.impl.RootBuilder;\n+import org.geoserver.wfstemplating.builders.impl.TemplateBuilderContext;\n+import org.geoserver.wfstemplating.builders.jsonld.JsonLdRootBuilder;\n+import org.geoserver.wfstemplating.configuration.TemplateConfiguration;\n+import org.geoserver.wfstemplating.configuration.TemplateIdentifier;\n+import org.geoserver.wfstemplating.writers.JsonLdWriter;\n+import org.geotools.feature.FeatureCollection;\n+import org.geotools.feature.FeatureIterator;\n+\n+/**\n+ * Encodes features in json-ld output format by means of a ${@link TemplateBuilder} tree obtained by\n+ * a JSON-LD template\n+ */\n+public class JSONLDGetFeatureResponse extends WFSGetFeatureOutputFormat {\n+\n+    /** The MIME type for a JSON-LD response* */\n+    public static final String MIME = \"application/ld+json\";\n+\n+    private TemplateConfiguration configuration;\n+\n+    public JSONLDGetFeatureResponse(GeoServer gs, TemplateConfiguration configuration) {\n+        super(gs, MIME);\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    protected void write(\n+            FeatureCollectionResponse featureCollection, OutputStream output, Operation getFeature)\n+            throws ServiceException {\n+\n+        TemplateGetFeatureResponseHelper helper =\n+                new TemplateGetFeatureResponseHelper(gs.getCatalog(), TemplateIdentifier.JSONLD);\n+        FeatureTypeInfo info =\n+                helper.getFeatureTypeInfo(GetFeatureRequest.adapt(getFeature.getParameters()[0]));\n+        JsonLdWriter writer = null;\n+        try {\n+            JsonLdRootBuilder rootBuilder =", "originalCommit": "980df02467b664426ea087930561f37e45f92664", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM4NjE1MQ==", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r448386151", "bodyText": "Indeed that is a dummy check.\nThe reason for that is that json-ld output is working for one featureType only. To make it able to encode more then one layer a strategy to handle multiple context is needed. Since GeoJSON doesn't have context I made json-ld response encoding multiple layer too, with a temporary workaround using only the context available from the first featureType.\nBut was a bad idea, since was not a really solution. I've restored the previous behaviour.", "author": "taba90", "createdAt": "2020-07-01T14:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzMjEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzNjI5Mg==", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r447036292", "bodyText": "This class and GeoJsonTemplateGetFeatureResponse look very similar to me... comparing them with a diff tool, seem to suggest they might be actually the same class, with parameters to specify which type of builders to use,\nor a common base class with subclasses filling the parameters in the constructor.", "author": "aaime", "createdAt": "2020-06-29T14:57:36Z", "path": "src/community/wfs-templating/src/main/java/org/geoserver/wfstemplating/response/JSONLDGetFeatureResponse.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wfstemplating.response;\n+\n+import java.io.*;\n+import java.util.List;\n+import org.geoserver.catalog.FeatureTypeInfo;\n+import org.geoserver.config.GeoServer;\n+import org.geoserver.platform.Operation;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.wfs.WFSGetFeatureOutputFormat;\n+import org.geoserver.wfs.request.FeatureCollectionResponse;\n+import org.geoserver.wfs.request.GetFeatureRequest;\n+import org.geoserver.wfstemplating.builders.TemplateBuilder;\n+import org.geoserver.wfstemplating.builders.impl.RootBuilder;\n+import org.geoserver.wfstemplating.builders.impl.TemplateBuilderContext;\n+import org.geoserver.wfstemplating.builders.jsonld.JsonLdRootBuilder;\n+import org.geoserver.wfstemplating.configuration.TemplateConfiguration;\n+import org.geoserver.wfstemplating.configuration.TemplateIdentifier;\n+import org.geoserver.wfstemplating.writers.JsonLdWriter;\n+import org.geotools.feature.FeatureCollection;\n+import org.geotools.feature.FeatureIterator;\n+\n+/**\n+ * Encodes features in json-ld output format by means of a ${@link TemplateBuilder} tree obtained by\n+ * a JSON-LD template\n+ */\n+public class JSONLDGetFeatureResponse extends WFSGetFeatureOutputFormat {", "originalCommit": "980df02467b664426ea087930561f37e45f92664", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM4NjU3OQ==", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r448386579", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-07-01T14:04:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzNjI5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0MDQ4Mg==", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r447040482", "bodyText": "Unsure what's happening here... seems like a workaround for an issue with response resolution? Ah, I'm guessing the dispatcher would not be happy to see two responses producing the same output for the same request and mime type, and it would conflict with the main GeoJSON response?", "author": "aaime", "createdAt": "2020-06-29T15:03:27Z", "path": "src/community/wfs-templating/src/main/java/org/geoserver/wfstemplating/request/JsonTemplateCallBackOGC.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wfstemplating.request;\n+\n+import java.io.OutputStream;\n+import org.geoserver.api.features.FeaturesResponse;\n+import org.geoserver.catalog.Catalog;\n+import org.geoserver.catalog.FeatureTypeInfo;\n+import org.geoserver.config.GeoServer;\n+import org.geoserver.ows.AbstractDispatcherCallback;\n+import org.geoserver.ows.DispatcherCallback;\n+import org.geoserver.ows.Request;\n+import org.geoserver.ows.Response;\n+import org.geoserver.platform.GeoServerExtensions;\n+import org.geoserver.platform.Operation;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.util.XCQL;\n+import org.geoserver.wfs.json.GeoJSONGetFeatureResponse;\n+import org.geoserver.wfs.request.FeatureCollectionResponse;\n+import org.geoserver.wfstemplating.builders.TemplateBuilder;\n+import org.geoserver.wfstemplating.builders.impl.RootBuilder;\n+import org.geoserver.wfstemplating.configuration.TemplateConfiguration;\n+import org.geoserver.wfstemplating.configuration.TemplateIdentifier;\n+import org.geoserver.wfstemplating.expressions.JsonLdCQLManager;\n+import org.geoserver.wfstemplating.response.GeoJsonTemplateGetFeatureResponse;\n+import org.geotools.filter.text.ecql.ECQL;\n+import org.opengis.filter.Filter;\n+import org.springframework.http.HttpHeaders;\n+\n+/**\n+ * This {@link DispatcherCallback} implementation OGCAPI compliant that checks on operation\n+ * dispatched event if a json-ld path has been provided to cql_filter and evaluate it against the\n+ * {@link TemplateBuilder} tree to get the corresponding {@link Filter}\n+ */\n+public class JsonTemplateCallBackOGC extends AbstractDispatcherCallback {\n+\n+    private Catalog catalog;\n+\n+    private TemplateConfiguration configuration;\n+\n+    private GeoServer gs;\n+\n+    public JsonTemplateCallBackOGC(GeoServer gs, TemplateConfiguration configuration) {\n+        this.catalog = gs.getCatalog();\n+        this.configuration = configuration;\n+        this.gs = gs;\n+    }\n+\n+    @Override\n+    public Operation operationDispatched(Request request, Operation operation) {\n+        String outputFormat = getFormatSupportingTemplating(request);\n+        if (\"FEATURES\".equalsIgnoreCase(request.getService()) && outputFormat != null) {\n+            try {\n+                String filterLang = (String) request.getKvp().get(\"FILTER-LANG\");\n+                if (filterLang != null && filterLang.equalsIgnoreCase(\"CQL-TEXT\")) {\n+                    String filter = (String) request.getKvp().get(\"FILTER\");\n+                    replaceJsonLdPathWithFilter(filter, outputFormat, operation);\n+                }\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        return super.operationDispatched(request, operation);\n+    }\n+\n+    private FeatureTypeInfo getFeatureType(String collectionId) {\n+        FeatureTypeInfo featureType = catalog.getFeatureTypeByName(collectionId);\n+        if (featureType == null) {\n+            throw new ServiceException(\n+                    \"Unknown collection \" + collectionId,\n+                    ServiceException.INVALID_PARAMETER_VALUE,\n+                    \"collectionId\");\n+        }\n+        return featureType;\n+    }\n+\n+    private String getFormatSupportingTemplating(Request request) {\n+        String accept = request.getHttpRequest().getHeader(HttpHeaders.ACCEPT);\n+        String format = request.getKvp() != null ? (String) request.getKvp().get(\"f\") : null;\n+        if (format != null\n+                && (format.equals(TemplateIdentifier.JSONLD.getOutputFormat())\n+                        || format.equals(TemplateIdentifier.GEOJSON.getOutputFormat()))) {\n+            return format;\n+        } else if (accept != null) {\n+            if (accept.contains(TemplateIdentifier.GEOJSON.getOutputFormat()))\n+                return TemplateIdentifier.GEOJSON.getOutputFormat();\n+            else if (accept.contains(TemplateIdentifier.JSONLD.getOutputFormat()))\n+                return TemplateIdentifier.JSONLD.getOutputFormat();\n+        }\n+        return null;\n+    }\n+\n+    private void replaceJsonLdPathWithFilter(\n+            String strFilter, String outputFormat, Operation operation) throws Exception {\n+        if (strFilter != null && strFilter.indexOf(\".\") != -1) {\n+            FeatureTypeInfo typeInfo = getFeatureType((String) operation.getParameters()[0]);\n+            RootBuilder root = configuration.getTemplate(typeInfo, outputFormat);\n+            if (root != null) {\n+                JsonPathVisitor visitor = new JsonPathVisitor(typeInfo.getFeatureType());\n+                /* Todo find a better way to replace json-ld path with corresponding template attribute*/\n+                // Get filter from string in order to make it accept the visitor\n+                Filter f = (Filter) XCQL.toFilter(strFilter).accept(visitor, root);\n+                // Taking back a string from Function cause\n+                // OGC API get a string cql filter from query string\n+                String newFilter =\n+                        JsonLdCQLManager.removeQuotes(ECQL.toCQL(f)).replaceAll(\"/\", \".\");\n+                newFilter = JsonLdCQLManager.quoteXpathAttribute(newFilter);\n+                for (int i = 0; i < operation.getParameters().length; i++) {\n+                    Object p = operation.getParameters()[i];\n+                    if (p != null && ((String.valueOf(p)).trim().equals(strFilter.trim()))) {\n+                        operation.getParameters()[i] = newFilter;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Response responseDispatched(\n+            Request request, Operation operation, Object result, Response response) {\n+        String format = getFormatSupportingTemplating(request);\n+        if (format != null && format.equals(TemplateIdentifier.GEOJSON.getOutputFormat())) {\n+            FeatureTypeInfo typeInfo = null;\n+            typeInfo = getFeatureType((String) operation.getParameters()[0]);\n+            if (typeInfo != null) {\n+                try {\n+                    RootBuilder root = configuration.getTemplate(typeInfo, format);\n+                    if (root != null) {\n+                        GeoJSONGetFeatureResponse featureResponse =\n+                                (GeoJSONGetFeatureResponse)\n+                                        GeoServerExtensions.bean(\"geoJSONGetFeatureResponse\");\n+                        GeoJsonTemplateGetFeatureResponse templatingResp =", "originalCommit": "980df02467b664426ea087930561f37e45f92664", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM4MjIyOA==", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r448382228", "bodyText": "I made some more investigation and turned out that the problem is only with test MockResponse so I guess I was trying to address a false problem: the code here \n  \n    \n      geoserver/src/community/ogcapi/ogcapi-core/src/main/java/org/geoserver/api/APIBodyMethodProcessor.java\n    \n    \n         Line 137\n      in\n      f81df44\n    \n    \n    \n    \n\n        \n          \n           outputMessage \n        \n    \n  \n\n doesn't set the output format to the test Mock Response but it correctly set to the HttpServletResponse object. I've then removed that set.", "author": "taba90", "createdAt": "2020-07-01T13:58:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0MDQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0MTIwNA==", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r447041204", "bodyText": "Could you please reduce a bit the nesting level? There is no requirement to put everything in the same method, once you determined you want to replace the response, you can call a different method that does exactly that, and give it a name that explains the purpose in the process too (e.g., \"replaceResponse(...)\").", "author": "aaime", "createdAt": "2020-06-29T15:04:28Z", "path": "src/community/wfs-templating/src/main/java/org/geoserver/wfstemplating/request/JsonTemplateCallBackOGC.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wfstemplating.request;\n+\n+import java.io.OutputStream;\n+import org.geoserver.api.features.FeaturesResponse;\n+import org.geoserver.catalog.Catalog;\n+import org.geoserver.catalog.FeatureTypeInfo;\n+import org.geoserver.config.GeoServer;\n+import org.geoserver.ows.AbstractDispatcherCallback;\n+import org.geoserver.ows.DispatcherCallback;\n+import org.geoserver.ows.Request;\n+import org.geoserver.ows.Response;\n+import org.geoserver.platform.GeoServerExtensions;\n+import org.geoserver.platform.Operation;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.util.XCQL;\n+import org.geoserver.wfs.json.GeoJSONGetFeatureResponse;\n+import org.geoserver.wfs.request.FeatureCollectionResponse;\n+import org.geoserver.wfstemplating.builders.TemplateBuilder;\n+import org.geoserver.wfstemplating.builders.impl.RootBuilder;\n+import org.geoserver.wfstemplating.configuration.TemplateConfiguration;\n+import org.geoserver.wfstemplating.configuration.TemplateIdentifier;\n+import org.geoserver.wfstemplating.expressions.JsonLdCQLManager;\n+import org.geoserver.wfstemplating.response.GeoJsonTemplateGetFeatureResponse;\n+import org.geotools.filter.text.ecql.ECQL;\n+import org.opengis.filter.Filter;\n+import org.springframework.http.HttpHeaders;\n+\n+/**\n+ * This {@link DispatcherCallback} implementation OGCAPI compliant that checks on operation\n+ * dispatched event if a json-ld path has been provided to cql_filter and evaluate it against the\n+ * {@link TemplateBuilder} tree to get the corresponding {@link Filter}\n+ */\n+public class JsonTemplateCallBackOGC extends AbstractDispatcherCallback {\n+\n+    private Catalog catalog;\n+\n+    private TemplateConfiguration configuration;\n+\n+    private GeoServer gs;\n+\n+    public JsonTemplateCallBackOGC(GeoServer gs, TemplateConfiguration configuration) {\n+        this.catalog = gs.getCatalog();\n+        this.configuration = configuration;\n+        this.gs = gs;\n+    }\n+\n+    @Override\n+    public Operation operationDispatched(Request request, Operation operation) {\n+        String outputFormat = getFormatSupportingTemplating(request);\n+        if (\"FEATURES\".equalsIgnoreCase(request.getService()) && outputFormat != null) {\n+            try {\n+                String filterLang = (String) request.getKvp().get(\"FILTER-LANG\");\n+                if (filterLang != null && filterLang.equalsIgnoreCase(\"CQL-TEXT\")) {\n+                    String filter = (String) request.getKvp().get(\"FILTER\");\n+                    replaceJsonLdPathWithFilter(filter, outputFormat, operation);\n+                }\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        return super.operationDispatched(request, operation);\n+    }\n+\n+    private FeatureTypeInfo getFeatureType(String collectionId) {\n+        FeatureTypeInfo featureType = catalog.getFeatureTypeByName(collectionId);\n+        if (featureType == null) {\n+            throw new ServiceException(\n+                    \"Unknown collection \" + collectionId,\n+                    ServiceException.INVALID_PARAMETER_VALUE,\n+                    \"collectionId\");\n+        }\n+        return featureType;\n+    }\n+\n+    private String getFormatSupportingTemplating(Request request) {\n+        String accept = request.getHttpRequest().getHeader(HttpHeaders.ACCEPT);\n+        String format = request.getKvp() != null ? (String) request.getKvp().get(\"f\") : null;\n+        if (format != null\n+                && (format.equals(TemplateIdentifier.JSONLD.getOutputFormat())\n+                        || format.equals(TemplateIdentifier.GEOJSON.getOutputFormat()))) {\n+            return format;\n+        } else if (accept != null) {\n+            if (accept.contains(TemplateIdentifier.GEOJSON.getOutputFormat()))\n+                return TemplateIdentifier.GEOJSON.getOutputFormat();\n+            else if (accept.contains(TemplateIdentifier.JSONLD.getOutputFormat()))\n+                return TemplateIdentifier.JSONLD.getOutputFormat();\n+        }\n+        return null;\n+    }\n+\n+    private void replaceJsonLdPathWithFilter(\n+            String strFilter, String outputFormat, Operation operation) throws Exception {\n+        if (strFilter != null && strFilter.indexOf(\".\") != -1) {\n+            FeatureTypeInfo typeInfo = getFeatureType((String) operation.getParameters()[0]);\n+            RootBuilder root = configuration.getTemplate(typeInfo, outputFormat);\n+            if (root != null) {\n+                JsonPathVisitor visitor = new JsonPathVisitor(typeInfo.getFeatureType());\n+                /* Todo find a better way to replace json-ld path with corresponding template attribute*/\n+                // Get filter from string in order to make it accept the visitor\n+                Filter f = (Filter) XCQL.toFilter(strFilter).accept(visitor, root);\n+                // Taking back a string from Function cause\n+                // OGC API get a string cql filter from query string\n+                String newFilter =\n+                        JsonLdCQLManager.removeQuotes(ECQL.toCQL(f)).replaceAll(\"/\", \".\");\n+                newFilter = JsonLdCQLManager.quoteXpathAttribute(newFilter);\n+                for (int i = 0; i < operation.getParameters().length; i++) {\n+                    Object p = operation.getParameters()[i];\n+                    if (p != null && ((String.valueOf(p)).trim().equals(strFilter.trim()))) {\n+                        operation.getParameters()[i] = newFilter;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Response responseDispatched(\n+            Request request, Operation operation, Object result, Response response) {\n+        String format = getFormatSupportingTemplating(request);\n+        if (format != null && format.equals(TemplateIdentifier.GEOJSON.getOutputFormat())) {\n+            FeatureTypeInfo typeInfo = null;\n+            typeInfo = getFeatureType((String) operation.getParameters()[0]);\n+            if (typeInfo != null) {\n+                try {\n+                    RootBuilder root = configuration.getTemplate(typeInfo, format);\n+                    if (root != null) {\n+                        GeoJSONGetFeatureResponse featureResponse =\n+                                (GeoJSONGetFeatureResponse)\n+                                        GeoServerExtensions.bean(\"geoJSONGetFeatureResponse\");\n+                        GeoJsonTemplateGetFeatureResponse templatingResp =\n+                                new GeoJsonTemplateGetFeatureResponse(", "originalCommit": "980df02467b664426ea087930561f37e45f92664", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM2MjEwNQ==", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r448362105", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-07-01T13:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0MTIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0MjQwNA==", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r447042404", "bodyText": "When the formatter starts wrapping variable declaration and simple assignments over two lines, it's a sign you're nesting too much, try to split the method in two or more, keep shorter (but significant, and well named) methods instead.", "author": "aaime", "createdAt": "2020-06-29T15:06:03Z", "path": "src/community/wfs-templating/src/main/java/org/geoserver/wfstemplating/request/JsonTemplateCallback.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wfstemplating.request;\n+\n+import java.util.List;\n+import javax.xml.namespace.QName;\n+import org.geoserver.catalog.*;\n+import org.geoserver.config.GeoServer;\n+import org.geoserver.ows.AbstractDispatcherCallback;\n+import org.geoserver.ows.DispatcherCallback;\n+import org.geoserver.ows.Request;\n+import org.geoserver.ows.Response;\n+import org.geoserver.platform.Operation;\n+import org.geoserver.wfs.json.GeoJSONGetFeatureResponse;\n+import org.geoserver.wfs.request.GetFeatureRequest;\n+import org.geoserver.wfs.request.Query;\n+import org.geoserver.wfstemplating.builders.TemplateBuilder;\n+import org.geoserver.wfstemplating.builders.impl.RootBuilder;\n+import org.geoserver.wfstemplating.configuration.TemplateConfiguration;\n+import org.geoserver.wfstemplating.configuration.TemplateIdentifier;\n+import org.geoserver.wfstemplating.response.GeoJsonTemplateGetFeatureResponse;\n+import org.geotools.feature.NameImpl;\n+import org.opengis.filter.Filter;\n+\n+/**\n+ * This {@link DispatcherCallback} implementation checks on operation dispatched event if a json-ld\n+ * path has been provided to cql_filter and evaluate it against the {@link TemplateBuilder} tree to\n+ * get the corresponding {@link Filter}\n+ */\n+public class JsonTemplateCallback extends AbstractDispatcherCallback {\n+\n+    private Catalog catalog;\n+\n+    private GeoServer gs;\n+\n+    private TemplateConfiguration configuration;\n+\n+    public JsonTemplateCallback(GeoServer gs, TemplateConfiguration configuration) {\n+        this.gs = gs;\n+        this.catalog = gs.getCatalog();\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public Operation operationDispatched(Request request, Operation operation) {\n+        if (\"WFS\".equalsIgnoreCase(request.getService())\n+                && request.getOutputFormat() != null\n+                && (request.getOutputFormat().equals(TemplateIdentifier.JSONLD.getOutputFormat())\n+                        || request.getOutputFormat()\n+                                .equals(TemplateIdentifier.GEOJSON.getOutputFormat()))) {\n+            FeatureTypeInfo typeInfo = null;\n+            GetFeatureRequest getFeature = null;\n+            getFeature = GetFeatureRequest.adapt(operation.getParameters()[0]);\n+            List<Query> queries = getFeature.getQueries();\n+            if (getFeature != null && queries != null && queries.size() > 0) {\n+                for (int i = 0; i < queries.size(); i++) {\n+                    Query q = queries.get(i);\n+                    QName type = q.getTypeNames().get(0);\n+                    typeInfo =\n+                            catalog.getFeatureTypeByName(\n+                                    new NameImpl(type.getPrefix(), type.getLocalPart()));\n+                    if (typeInfo != null) {\n+                        try {\n+                            RootBuilder root =\n+                                    configuration.getTemplate(typeInfo, request.getOutputFormat());\n+                            if (root != null) {\n+                                JsonPathVisitor visitor =", "originalCommit": "980df02467b664426ea087930561f37e45f92664", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM2MjE4MQ==", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r448362181", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-07-01T13:27:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0MjQwNA=="}], "type": "inlineReview"}, {"oid": "a74cd7ba7afcf490809673049cfc0d76f2b9b658", "url": "https://github.com/geoserver/geoserver/commit/a74cd7ba7afcf490809673049cfc0d76f2b9b658", "message": "reviewer's suggestion", "committedDate": "2020-07-01T12:40:35Z", "type": "forcePushed"}, {"oid": "aa2241490d5eaead7127988ba8d2d055bee88cbb", "url": "https://github.com/geoserver/geoserver/commit/aa2241490d5eaead7127988ba8d2d055bee88cbb", "message": "reviewer's suggestion", "committedDate": "2020-07-01T15:06:39Z", "type": "forcePushed"}, {"oid": "f120a93edb36a726221653844298bd7db26f5ae4", "url": "https://github.com/geoserver/geoserver/commit/f120a93edb36a726221653844298bd7db26f5ae4", "message": "[GEOS-9663] Add support for GEOJSON output in the JSON-LD module and rename it", "committedDate": "2020-07-08T07:06:50Z", "type": "commit"}, {"oid": "8a9494075cf7d64e5b0af5bb1afe7d9529690e32", "url": "https://github.com/geoserver/geoserver/commit/8a9494075cf7d64e5b0af5bb1afe7d9529690e32", "message": "tests", "committedDate": "2020-07-08T07:06:50Z", "type": "commit"}, {"oid": "2c3f5089e1e91dff307cc8739f5581d9a57ac9ed", "url": "https://github.com/geoserver/geoserver/commit/2c3f5089e1e91dff307cc8739f5581d9a57ac9ed", "message": "documentation", "committedDate": "2020-07-08T07:06:50Z", "type": "commit"}, {"oid": "0706ec2cd84b3db733d3e1ad7f83a10474660b31", "url": "https://github.com/geoserver/geoserver/commit/0706ec2cd84b3db733d3e1ad7f83a10474660b31", "message": "refactoring", "committedDate": "2020-07-08T07:06:50Z", "type": "commit"}, {"oid": "883898da58bf5b2a88d8fe3b524ae043688a3a3d", "url": "https://github.com/geoserver/geoserver/commit/883898da58bf5b2a88d8fe3b524ae043688a3a3d", "message": "reviewer's suggestion", "committedDate": "2020-07-08T07:06:50Z", "type": "commit"}, {"oid": "d389f7cf06e5ad6ca6f5e14b55f74f5510a93363", "url": "https://github.com/geoserver/geoserver/commit/d389f7cf06e5ad6ca6f5e14b55f74f5510a93363", "message": "last stuff", "committedDate": "2020-07-07T08:30:02Z", "type": "forcePushed"}, {"oid": "b08d24c46f24cc18e4f795104932fa1b85cec2ad", "url": "https://github.com/geoserver/geoserver/commit/b08d24c46f24cc18e4f795104932fa1b85cec2ad", "message": "fix context not included in the output if not an json object", "committedDate": "2020-07-08T07:06:51Z", "type": "forcePushed"}, {"oid": "afd8b255ac87d89450255a92dece968c5704bdee", "url": "https://github.com/geoserver/geoserver/commit/afd8b255ac87d89450255a92dece968c5704bdee", "message": "added support for geo+json", "committedDate": "2020-07-09T08:33:26Z", "type": "commit"}, {"oid": "807efa257d58752c9363348a783446ebf0736d8f", "url": "https://github.com/geoserver/geoserver/commit/807efa257d58752c9363348a783446ebf0736d8f", "message": "fix context included in json-ld output only if is an object", "committedDate": "2020-07-09T08:33:34Z", "type": "commit"}, {"oid": "807efa257d58752c9363348a783446ebf0736d8f", "url": "https://github.com/geoserver/geoserver/commit/807efa257d58752c9363348a783446ebf0736d8f", "message": "fix context included in json-ld output only if is an object", "committedDate": "2020-07-09T08:33:34Z", "type": "forcePushed"}]}