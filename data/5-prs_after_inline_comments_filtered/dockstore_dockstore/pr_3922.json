{"pr_number": 3922, "pr_title": "Feature/3810/workflowToolList500", "pr_createdAt": "2020-11-10T17:25:03Z", "pr_url": "https://github.com/dockstore/dockstore/pull/3922", "timeline": [{"oid": "8d19fddbf64385c8eec6ff456972d3ac3130de1d", "url": "https://github.com/dockstore/dockstore/commit/8d19fddbf64385c8eec6ff456972d3ac3130de1d", "message": "workflow tools 500 errors due to parsing issues", "committedDate": "2020-11-10T00:34:41Z", "type": "commit"}, {"oid": "94ba5772dfc8184994d8726ebe6d92b54bedf280", "url": "https://github.com/dockstore/dockstore/commit/94ba5772dfc8184994d8726ebe6d92b54bedf280", "message": "Updated comment to be more accurate", "committedDate": "2020-11-10T16:55:49Z", "type": "commit"}, {"oid": "dbcf1d0171a929a0938cdf8a0713be0897ade138", "url": "https://github.com/dockstore/dockstore/commit/dbcf1d0171a929a0938cdf8a0713be0897ade138", "message": "Modified so CWL and WDL parsing errors are handled equivalently", "committedDate": "2020-11-10T17:56:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMTYwMQ==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r520811601", "bodyText": "As you suggested in your PR description, I think this should be a 400 error.", "author": "coverbeck", "createdAt": "2020-11-10T19:13:27Z", "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/languages/WDLHandler.java", "diffHunk": "@@ -427,10 +427,13 @@ public VersionTypeValidation validateTestParameterSet(Set<SourceFile> sourceFile\n             // Iterate over each call, determine dependencies\n             Map<String, List<String>> callsToDependencies = wdlBridge.getCallsToDependencies(tempMainDescriptor.getAbsolutePath(), mainDescName);\n             toolInfoMap = mapConverterToToolInfo(callsToDockerMap, callsToDependencies);\n+\n             // Get import files\n             namespaceToPath = wdlBridge.getImportMap(tempMainDescriptor.getAbsolutePath(), mainDescName);\n-        } catch (IOException | NoSuchElementException | WdlParser.SyntaxError e) {\n-            throw new CustomWebApplicationException(\"could not process wdl into DAG: \" + e.getMessage(), HttpStatus.SC_INTERNAL_SERVER_ERROR);\n+        } catch (WdlParser.SyntaxError e) {\n+            return Optional.empty();", "originalCommit": "dbcf1d0171a929a0938cdf8a0713be0897ade138", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgyMDkxNA==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r520820914", "bodyText": "Should CWLHandler throw a 400 as well when encountering parsing errors (such as invalid YAML syntax)?", "author": "Richard-Hansen", "createdAt": "2020-11-10T19:29:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMTYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNDkxNw==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r520834917", "bodyText": "The initial commit in the PR handles the errors this way (both CWL and WDL), see here. I can revert back if that seems more appropriate.", "author": "Richard-Hansen", "createdAt": "2020-11-10T19:53:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMTYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNTE2NQ==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r520915165", "bodyText": "Not sure about the CWL case; in this case it definitely seems like it should be a 400 -- the method is not returning a useful response; it's not Dockstore's fault -- it's a WDL with syntax errors submitted by a user.", "author": "coverbeck", "createdAt": "2020-11-10T22:29:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMTYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDcwMTE4Mg==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r524701182", "bodyText": "Fixed.", "author": "Richard-Hansen", "createdAt": "2020-11-16T22:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMTYwMQ=="}], "type": "inlineReview"}, {"oid": "83dd20049283fbef0282a564f4369066c39c7ffc", "url": "https://github.com/dockstore/dockstore/commit/83dd20049283fbef0282a564f4369066c39c7ffc", "message": "WDLhandler throws 400 when provided a descriptor with syntax errors", "committedDate": "2020-11-11T00:11:26Z", "type": "commit"}, {"oid": "7b10140352b8ec791e84051ecaf5bc6378a2d428", "url": "https://github.com/dockstore/dockstore/commit/7b10140352b8ec791e84051ecaf5bc6378a2d428", "message": "Added descriptive 400s to content parsing of CWL/WDL descriptors. Added testing", "committedDate": "2020-11-12T17:52:56Z", "type": "commit"}, {"oid": "6a35ba1d6c4d3538479636d65c79d5d0cabbf486", "url": "https://github.com/dockstore/dockstore/commit/6a35ba1d6c4d3538479636d65c79d5d0cabbf486", "message": "Moved testing resources to correct directory", "committedDate": "2020-11-12T18:20:13Z", "type": "commit"}, {"oid": "33f9f15787b809228f22b7fa27720a4698d0a369", "url": "https://github.com/dockstore/dockstore/commit/33f9f15787b809228f22b7fa27720a4698d0a369", "message": "style fixes, added newline to end of test files", "committedDate": "2020-11-12T19:19:24Z", "type": "commit"}, {"oid": "5c6faaea254c9d141b1bd28b235f559129bab58f", "url": "https://github.com/dockstore/dockstore/commit/5c6faaea254c9d141b1bd28b235f559129bab58f", "message": "Added test case for invalid secondary file specification", "committedDate": "2020-11-12T21:37:24Z", "type": "commit"}, {"oid": "a2b130262fa7f033814d101bfe8573a4dc3f685e", "url": "https://github.com/dockstore/dockstore/commit/a2b130262fa7f033814d101bfe8573a4dc3f685e", "message": "Added newline to end of file", "committedDate": "2020-11-12T21:52:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMDE5NA==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r522520194", "bodyText": "put Assert.fail(\"blah blah\") under this to be certain it actually had an exception. same with other places", "author": "garyluu", "createdAt": "2020-11-13T00:09:38Z", "path": "dockstore-webservice/src/test/java/io/dockstore/webservice/languages/CWLHandlerTest.java", "diffHunk": "@@ -101,4 +105,58 @@ public void testURLFromEntry() {\n         Assert.assertEquals(\"https://www.dockstore.org/containers/registry.hub.docker.com/foo/bar\", handler.getURLFromEntry(\"foo/bar\", toolDAO));\n         Assert.assertEquals(\"https://www.dockstore.org/containers/registry.hub.docker.com/foo/bar\", handler.getURLFromEntry(\"foo/bar:1\", toolDAO));\n     }\n+\n+    @Test\n+    public void testGetContentWithMalformedDescriptors() throws IOException {\n+        CWLHandler cwlHandler = new CWLHandler();\n+\n+        // create and mock parameters for getContent()\n+        final Set<SourceFile> emptySet = Collections.emptySet();\n+        final ToolDAO toolDAO = Mockito.mock(ToolDAO.class);\n+        when(toolDAO.findAllByPath(Mockito.anyString(), Mockito.anyBoolean())).thenReturn(null);\n+\n+        // expect parsing error\n+        File cwlFile = new File(ResourceHelpers.resourceFilePath(\"brokenCWL.cwl\"));\n+        try {\n+            cwlHandler.getContent(\"/brokenCWL.cwl\", FileUtils.readFileToString(cwlFile, StandardCharsets.UTF_8), emptySet,\n+                LanguageHandlerInterface.Type.TOOLS, toolDAO);", "originalCommit": "a2b130262fa7f033814d101bfe8573a4dc3f685e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDcwMjU1Ng==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r524702556", "bodyText": "Fixed in both WDL and CWL test files.", "author": "Richard-Hansen", "createdAt": "2020-11-16T22:49:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMDE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMDM0Nw==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r522520347", "bodyText": "swap parameters, it's assertEquals(expected, actual).  Here and other places", "author": "garyluu", "createdAt": "2020-11-13T00:10:08Z", "path": "dockstore-webservice/src/test/java/io/dockstore/webservice/languages/CWLHandlerTest.java", "diffHunk": "@@ -101,4 +105,58 @@ public void testURLFromEntry() {\n         Assert.assertEquals(\"https://www.dockstore.org/containers/registry.hub.docker.com/foo/bar\", handler.getURLFromEntry(\"foo/bar\", toolDAO));\n         Assert.assertEquals(\"https://www.dockstore.org/containers/registry.hub.docker.com/foo/bar\", handler.getURLFromEntry(\"foo/bar:1\", toolDAO));\n     }\n+\n+    @Test\n+    public void testGetContentWithMalformedDescriptors() throws IOException {\n+        CWLHandler cwlHandler = new CWLHandler();\n+\n+        // create and mock parameters for getContent()\n+        final Set<SourceFile> emptySet = Collections.emptySet();\n+        final ToolDAO toolDAO = Mockito.mock(ToolDAO.class);\n+        when(toolDAO.findAllByPath(Mockito.anyString(), Mockito.anyBoolean())).thenReturn(null);\n+\n+        // expect parsing error\n+        File cwlFile = new File(ResourceHelpers.resourceFilePath(\"brokenCWL.cwl\"));\n+        try {\n+            cwlHandler.getContent(\"/brokenCWL.cwl\", FileUtils.readFileToString(cwlFile, StandardCharsets.UTF_8), emptySet,\n+                LanguageHandlerInterface.Type.TOOLS, toolDAO);\n+        } catch (CustomWebApplicationException e) {\n+            Assert.assertEquals(e.getResponse().getStatus(), 400);", "originalCommit": "a2b130262fa7f033814d101bfe8573a4dc3f685e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDcwNDk3NQ==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r524704975", "bodyText": "Swapped order, thanks for the catch, I've mixed these up before so I'll make a note to double check my parameter orderings.", "author": "Richard-Hansen", "createdAt": "2020-11-16T22:51:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMDM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMDgzOA==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r522520838", "bodyText": "AssertThat(blah blah).contains(blah blah)", "author": "garyluu", "createdAt": "2020-11-13T00:11:39Z", "path": "dockstore-webservice/src/test/java/io/dockstore/webservice/languages/WDLHandlerTest.java", "diffHunk": "@@ -151,6 +152,27 @@ public void testGetToolsForComplexWorkflow() throws IOException {\n \n     }\n \n+    @Test\n+    public void testGetContentWithSyntaxErrors() throws IOException {\n+        final WDLHandler wdlHandler = new WDLHandler();\n+        final File wdlFile = new File(ResourceHelpers.resourceFilePath(\"brokenWDL.wdl\"));\n+        final Set<SourceFile> emptySet = Collections.emptySet();\n+\n+        // wdlHandler.getContent ultimately invokes toolDAO.findAllByPath from LanguageHandlerEntry.getURLFromEntry for look\n+        // up; just have it return null\n+        final ToolDAO toolDAO = Mockito.mock(ToolDAO.class);\n+        when(toolDAO.findAllByPath(Mockito.anyString(), Mockito.anyBoolean())).thenReturn(null);\n+\n+        // run test with a WDL descriptor with syntax errors\n+        try {\n+            wdlHandler.getContent(\"/brokenWDL.wdl\", FileUtils.readFileToString(wdlFile, StandardCharsets.UTF_8), emptySet,\n+                LanguageHandlerInterface.Type.TOOLS, toolDAO);\n+        } catch (CustomWebApplicationException e) {\n+            Assert.assertEquals(e.getResponse().getStatus(), 400);\n+            Assert.assertTrue(\"Should contain parsing error statement, found: \" + e.errorMessage, e.errorMessage.contains(WDLHandler.WDL_PARSE_ERROR));", "originalCommit": "a2b130262fa7f033814d101bfe8573a4dc3f685e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDcwNzczNQ==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r524707735", "bodyText": "Fixed in WDL and CWL test files.", "author": "Richard-Hansen", "createdAt": "2020-11-16T22:54:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMDgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMjk0NA==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r522522944", "bodyText": "Log the exception.", "author": "coverbeck", "createdAt": "2020-11-13T00:18:11Z", "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/languages/WDLHandler.java", "diffHunk": "@@ -427,10 +428,13 @@ public VersionTypeValidation validateTestParameterSet(Set<SourceFile> sourceFile\n             // Iterate over each call, determine dependencies\n             Map<String, List<String>> callsToDependencies = wdlBridge.getCallsToDependencies(tempMainDescriptor.getAbsolutePath(), mainDescName);\n             toolInfoMap = mapConverterToToolInfo(callsToDockerMap, callsToDependencies);\n+\n             // Get import files\n             namespaceToPath = wdlBridge.getImportMap(tempMainDescriptor.getAbsolutePath(), mainDescName);\n-        } catch (IOException | NoSuchElementException | WdlParser.SyntaxError e) {\n-            throw new CustomWebApplicationException(\"could not process wdl into DAG: \" + e.getMessage(), HttpStatus.SC_INTERNAL_SERVER_ERROR);\n+        } catch (WdlParser.SyntaxError e) {\n+            throw new CustomWebApplicationException(this.WDL_PARSE_ERROR + e.getMessage(), HttpStatus.SC_BAD_REQUEST);", "originalCommit": "a2b130262fa7f033814d101bfe8573a4dc3f685e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDcwOTI1MQ==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r524709251", "bodyText": "Logged. Overloaded the constructor for CustomWebApplicationException to allow for the Throwable parameter.", "author": "Richard-Hansen", "createdAt": "2020-11-16T22:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMjk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMjk5Mw==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r522522993", "bodyText": "Log the exception", "author": "coverbeck", "createdAt": "2020-11-13T00:18:20Z", "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/languages/WDLHandler.java", "diffHunk": "@@ -427,10 +428,13 @@ public VersionTypeValidation validateTestParameterSet(Set<SourceFile> sourceFile\n             // Iterate over each call, determine dependencies\n             Map<String, List<String>> callsToDependencies = wdlBridge.getCallsToDependencies(tempMainDescriptor.getAbsolutePath(), mainDescName);\n             toolInfoMap = mapConverterToToolInfo(callsToDockerMap, callsToDependencies);\n+\n             // Get import files\n             namespaceToPath = wdlBridge.getImportMap(tempMainDescriptor.getAbsolutePath(), mainDescName);\n-        } catch (IOException | NoSuchElementException | WdlParser.SyntaxError e) {\n-            throw new CustomWebApplicationException(\"could not process wdl into DAG: \" + e.getMessage(), HttpStatus.SC_INTERNAL_SERVER_ERROR);\n+        } catch (WdlParser.SyntaxError e) {\n+            throw new CustomWebApplicationException(this.WDL_PARSE_ERROR + e.getMessage(), HttpStatus.SC_BAD_REQUEST);\n+        } catch (IOException | NoSuchElementException e) {\n+            throw new CustomWebApplicationException(\"Could not process request, \" + e.getMessage(), HttpStatus.SC_INTERNAL_SERVER_ERROR);", "originalCommit": "a2b130262fa7f033814d101bfe8573a4dc3f685e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDcwOTYyOQ==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r524709629", "bodyText": "Logged.", "author": "Richard-Hansen", "createdAt": "2020-11-16T22:56:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMjk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyNjE3OA==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r522526178", "bodyText": "Why aren't you using this any more? It still gets used in 2 other spots, and it looks like you duplicate the code on line 273. I guess because you're throwing exceptions here and don't want to otherwise. Still, it would be nice if there wasn't the duplication... What happens we we support v2 some day, if there ever is one? If we don't update in both places....", "author": "coverbeck", "createdAt": "2020-11-13T00:27:59Z", "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/languages/CWLHandler.java", "diffHunk": "@@ -249,7 +255,7 @@ private void handlePotentialFormatEntry(Set<FileFormat> fileFormats, Object v) {\n     public Optional<String> getContent(String mainDescriptorPath, String mainDescriptor, Set<SourceFile> secondarySourceFiles, LanguageHandlerInterface.Type type,\n         ToolDAO dao) {\n         Yaml yaml = new Yaml();\n-        if (isValidCwl(mainDescriptor, yaml)) {", "originalCommit": "a2b130262fa7f033814d101bfe8573a4dc3f685e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDcxMjc4Mw==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r524712783", "bodyText": "As you stated, I duplicated the code segment to allow for detailed exception messages. To address the versioning change, added static variable CWL_VERSION_PREFIX here, making the version easier to update.", "author": "Richard-Hansen", "createdAt": "2020-11-16T22:59:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyNjE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyNjQxNg==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r522526416", "bodyText": "Log the exception", "author": "coverbeck", "createdAt": "2020-11-13T00:28:45Z", "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/languages/CWLHandler.java", "diffHunk": "@@ -274,177 +293,170 @@ private void handlePotentialFormatEntry(Set<FileFormat> fileFormats, Object v) {\n             String expressionToolType = \"expressionTool\";\n \n             // Set up GSON for JSON parsing\n-            Gson gson;\n-            try {\n-                gson = CWL.getTypeSafeCWLToolDocument();\n+            Gson gson = CWL.getTypeSafeCWLToolDocument();\n \n-                final Workflow workflow = gson.fromJson(cwlJson.toString(), Workflow.class);\n+            final Workflow workflow = gson.fromJson(cwlJson.toString(), Workflow.class);\n \n-                if (workflow == null) {\n-                    LOG.error(\"The workflow does not seem to conform to CWL specs.\");\n-                    return Optional.empty();\n-                }\n+            if (workflow == null) {\n+                LOG.error(\"The workflow does not seem to conform to CWL specs.\");\n+                return Optional.empty();\n+            }\n \n-                // Determine default docker path (Check requirement first and then hint)\n-                defaultDockerPath = getRequirementOrHint(workflow.getRequirements(), workflow.getHints(), defaultDockerPath);\n-\n-                // Store workflow steps in json and then read it into map <String, WorkflowStep>\n-                Object steps = workflow.getSteps();\n-                String stepJson = gson.toJson(steps);\n-                Map<String, WorkflowStep> workflowStepMap;\n-                if (steps instanceof ArrayList) {\n-                    ArrayList<WorkflowStep> workflowStepList = gson.fromJson(stepJson, new TypeToken<ArrayList<WorkflowStep>>() {\n-                    }.getType());\n-                    workflowStepMap = new LinkedTreeMap<>();\n-                    workflowStepList.forEach(workflowStep -> workflowStepMap.put(workflowStep.getId().toString(), workflowStep));\n-                } else {\n-                    workflowStepMap = gson.fromJson(stepJson, new TypeToken<Map<String, WorkflowStep>>() {\n-                    }.getType());\n-                }\n+            // Determine default docker path (Check requirement first and then hint)\n+            defaultDockerPath = getRequirementOrHint(workflow.getRequirements(), workflow.getHints(), defaultDockerPath);\n+\n+            // Store workflow steps in json and then read it into map <String, WorkflowStep>\n+            Object steps = workflow.getSteps();\n+            String stepJson = gson.toJson(steps);\n+            Map<String, WorkflowStep> workflowStepMap;\n+            if (steps instanceof ArrayList) {\n+                ArrayList<WorkflowStep> workflowStepList = gson.fromJson(stepJson, new TypeToken<ArrayList<WorkflowStep>>() {\n+                }.getType());\n+                workflowStepMap = new LinkedTreeMap<>();\n+                workflowStepList.forEach(workflowStep -> workflowStepMap.put(workflowStep.getId().toString(), workflowStep));\n+            } else {\n+                workflowStepMap = gson.fromJson(stepJson, new TypeToken<Map<String, WorkflowStep>>() {\n+                }.getType());\n+            }\n \n-                if (stepJson == null) {\n-                    LOG.error(\"Could not find any steps for the workflow.\");\n-                    return Optional.empty();\n-                }\n+            if (stepJson == null) {\n+                LOG.error(\"Could not find any steps for the workflow.\");\n+                return Optional.empty();\n+            }\n \n-                if (workflowStepMap == null) {\n-                    LOG.error(\"Error deserializing workflow steps\");\n-                    return Optional.empty();\n-                }\n+            if (workflowStepMap == null) {\n+                LOG.error(\"Error deserializing workflow steps\");\n+                return Optional.empty();\n+            }\n \n-                // Iterate through steps to find dependencies and docker requirements\n-                for (Map.Entry<String, WorkflowStep> entry : workflowStepMap.entrySet()) {\n-                    WorkflowStep workflowStep = entry.getValue();\n-                    String workflowStepId = nodePrefix + entry.getKey();\n+            // Iterate through steps to find dependencies and docker requirements\n+            for (Map.Entry<String, WorkflowStep> entry : workflowStepMap.entrySet()) {\n+                WorkflowStep workflowStep = entry.getValue();\n+                String workflowStepId = nodePrefix + entry.getKey();\n \n-                    ArrayList<String> stepDependencies = new ArrayList<>();\n+                ArrayList<String> stepDependencies = new ArrayList<>();\n \n-                    // Iterate over source and get the dependencies\n-                    if (workflowStep.getIn() != null) {\n-                        for (WorkflowStepInput workflowStepInput : workflowStep.getIn()) {\n-                            Object sources = workflowStepInput.getSource();\n+                // Iterate over source and get the dependencies\n+                if (workflowStep.getIn() != null) {\n+                    for (WorkflowStepInput workflowStepInput : workflowStep.getIn()) {\n+                        Object sources = workflowStepInput.getSource();\n \n-                            processDependencies(nodePrefix, stepDependencies, sources);\n-                        }\n-                        if (stepDependencies.size() > 0) {\n-                            toolInfoMap.computeIfPresent(workflowStepId, (toolId, toolInfo) -> {\n-                                toolInfo.toolDependencyList.addAll(stepDependencies);\n-                                return toolInfo;\n-                            });\n-                            toolInfoMap.computeIfAbsent(workflowStepId, toolId -> new ToolInfo(null, stepDependencies));\n-                        }\n+                        processDependencies(nodePrefix, stepDependencies, sources);\n                     }\n-\n-                    // Check workflow step for docker requirement and hints\n-                    String stepDockerRequirement = defaultDockerPath;\n-                    stepDockerRequirement = getRequirementOrHint(workflowStep.getRequirements(), workflowStep.getHints(),\n-                        stepDockerRequirement);\n-\n-                    // Check for docker requirement within workflow step file\n-                    String secondaryFile = null;\n-                    Object run = workflowStep.getRun();\n-                    String runAsJson = gson.toJson(gson.toJsonTree(run));\n-\n-                    if (run instanceof String) {\n-                        secondaryFile = (String)run;\n-                    } else if (isTool(runAsJson, yaml)) {\n-                        CommandLineTool clTool = gson.fromJson(runAsJson, CommandLineTool.class);\n-                        stepDockerRequirement = getRequirementOrHint(clTool.getRequirements(), clTool.getHints(),\n-                            stepDockerRequirement);\n-                        stepToType.put(workflowStepId, toolType);\n-                    } else if (isWorkflow(runAsJson, yaml)) {\n-                        Workflow stepWorkflow = gson.fromJson(runAsJson, Workflow.class);\n-                        stepDockerRequirement = getRequirementOrHint(stepWorkflow.getRequirements(), stepWorkflow.getHints(),\n-                            stepDockerRequirement);\n-                        stepToType.put(workflowStepId, workflowType);\n-                    } else if (isExpressionTool(runAsJson, yaml)) {\n-                        ExpressionTool expressionTool = gson.fromJson(runAsJson, ExpressionTool.class);\n-                        stepDockerRequirement = getRequirementOrHint(expressionTool.getRequirements(), expressionTool.getHints(),\n-                            stepDockerRequirement);\n-                        stepToType.put(workflowStepId, expressionToolType);\n-                    } else if (run instanceof Map) {\n-                        // must be import or include\n-                        Object importVal = ((Map)run).containsKey(\"$import\") ? ((Map)run).get(\"$import\") : ((Map)run).get(\"import\");\n-                        if (importVal != null) {\n-                            secondaryFile = importVal.toString();\n-                        }\n-\n-                        Object includeVal = ((Map)run).containsKey(\"$include\") ? ((Map)run).get(\"$include\") : ((Map)run).get(\"include\");\n-                        if (includeVal != null) {\n-                            secondaryFile = includeVal.toString();\n-                        }\n-\n-                        if (secondaryFile == null) {\n-                            LOG.error(\"Syntax incorrect. Could not ($)import or ($)include secondary file for run command: \" + run);\n-                            return Optional.empty();\n-                        }\n+                    if (stepDependencies.size() > 0) {\n+                        toolInfoMap.computeIfPresent(workflowStepId, (toolId, toolInfo) -> {\n+                            toolInfo.toolDependencyList.addAll(stepDependencies);\n+                            return toolInfo;\n+                        });\n+                        toolInfoMap.computeIfAbsent(workflowStepId, toolId -> new ToolInfo(null, stepDependencies));\n                     }\n+                }\n \n-                    // Check secondary file for docker pull\n-                    if (secondaryFile != null) {\n-                        String finalSecondaryFile = secondaryFile;\n-                        final Optional<SourceFile> sourceFileOptional = secondarySourceFiles.stream()\n-                                .filter(sf -> sf.getPath().equals(finalSecondaryFile)).findFirst();\n-                        final String content = sourceFileOptional.map(SourceFile::getContent).orElse(null);\n-                        stepDockerRequirement = parseSecondaryFile(stepDockerRequirement, content, gson, yaml);\n-                        if (isExpressionTool(content, yaml)) {\n-                            stepToType.put(workflowStepId, expressionToolType);\n-                        } else if (isTool(content, yaml)) {\n-                            stepToType.put(workflowStepId, toolType);\n-                        } else if (isWorkflow(content, yaml)) {\n-                            stepToType.put(workflowStepId, workflowType);\n-                        } else {\n-                            stepToType.put(workflowStepId, \"n/a\");\n-                        }\n+                // Check workflow step for docker requirement and hints\n+                String stepDockerRequirement = defaultDockerPath;\n+                stepDockerRequirement = getRequirementOrHint(workflowStep.getRequirements(), workflowStep.getHints(),\n+                    stepDockerRequirement);\n+\n+                // Check for docker requirement within workflow step file\n+                String secondaryFile = null;\n+                Object run = workflowStep.getRun();\n+                String runAsJson = gson.toJson(gson.toJsonTree(run));\n+\n+                if (run instanceof String) {\n+                    secondaryFile = (String)run;\n+                } else if (isTool(runAsJson, yaml)) {\n+                    CommandLineTool clTool = gson.fromJson(runAsJson, CommandLineTool.class);\n+                    stepDockerRequirement = getRequirementOrHint(clTool.getRequirements(), clTool.getHints(),\n+                        stepDockerRequirement);\n+                    stepToType.put(workflowStepId, toolType);\n+                } else if (isWorkflow(runAsJson, yaml)) {\n+                    Workflow stepWorkflow = gson.fromJson(runAsJson, Workflow.class);\n+                    stepDockerRequirement = getRequirementOrHint(stepWorkflow.getRequirements(), stepWorkflow.getHints(),\n+                        stepDockerRequirement);\n+                    stepToType.put(workflowStepId, workflowType);\n+                } else if (isExpressionTool(runAsJson, yaml)) {\n+                    ExpressionTool expressionTool = gson.fromJson(runAsJson, ExpressionTool.class);\n+                    stepDockerRequirement = getRequirementOrHint(expressionTool.getRequirements(), expressionTool.getHints(),\n+                        stepDockerRequirement);\n+                    stepToType.put(workflowStepId, expressionToolType);\n+                } else if (run instanceof Map) {\n+                    // must be import or include\n+                    Object importVal = ((Map)run).containsKey(\"$import\") ? ((Map)run).get(\"$import\") : ((Map)run).get(\"import\");\n+                    if (importVal != null) {\n+                        secondaryFile = importVal.toString();\n                     }\n \n-                    String dockerUrl = null;\n-                    if ((stepToType.get(workflowStepId).equals(workflowType) || stepToType.get(workflowStepId).equals(toolType)) && !Strings.isNullOrEmpty(stepDockerRequirement)) {\n-                        dockerUrl = getURLFromEntry(stepDockerRequirement, dao);\n+                    Object includeVal = ((Map)run).containsKey(\"$include\") ? ((Map)run).get(\"$include\") : ((Map)run).get(\"include\");\n+                    if (includeVal != null) {\n+                        secondaryFile = includeVal.toString();\n                     }\n \n-                    if (type == LanguageHandlerInterface.Type.DAG) {\n-                        nodePairs.add(new MutablePair<>(workflowStepId, dockerUrl));\n+                    if (secondaryFile == null) {\n+                        throw new CustomWebApplicationException(this.CWL_PARSE_SECONDARY_ERROR + run, HttpStatus.SC_BAD_REQUEST);\n                     }\n+                }\n \n-                    if (secondaryFile != null) {\n-                        nodeDockerInfo.put(workflowStepId, new MutableTriple<>(secondaryFile, stepDockerRequirement, dockerUrl));\n+                // Check secondary file for docker pull\n+                if (secondaryFile != null) {\n+                    String finalSecondaryFile = secondaryFile;\n+                    final Optional<SourceFile> sourceFileOptional = secondarySourceFiles.stream()\n+                            .filter(sf -> sf.getPath().equals(finalSecondaryFile)).findFirst();\n+                    final String content = sourceFileOptional.map(SourceFile::getContent).orElse(null);\n+                    stepDockerRequirement = parseSecondaryFile(stepDockerRequirement, content, gson, yaml);\n+                    if (isExpressionTool(content, yaml)) {\n+                        stepToType.put(workflowStepId, expressionToolType);\n+                    } else if (isTool(content, yaml)) {\n+                        stepToType.put(workflowStepId, toolType);\n+                    } else if (isWorkflow(content, yaml)) {\n+                        stepToType.put(workflowStepId, workflowType);\n                     } else {\n-                        nodeDockerInfo.put(workflowStepId, new MutableTriple<>(mainDescriptorPath, stepDockerRequirement, dockerUrl));\n+                        stepToType.put(workflowStepId, \"n/a\");\n                     }\n+                }\n \n+                String dockerUrl = null;\n+                if ((stepToType.get(workflowStepId).equals(workflowType) || stepToType.get(workflowStepId).equals(toolType)) && !Strings.isNullOrEmpty(stepDockerRequirement)) {\n+                    dockerUrl = getURLFromEntry(stepDockerRequirement, dao);\n                 }\n \n                 if (type == LanguageHandlerInterface.Type.DAG) {\n-                    // Determine steps that point to end\n-                    List<String> endDependencies = new ArrayList<>();\n+                    nodePairs.add(new MutablePair<>(workflowStepId, dockerUrl));\n+                }\n \n-                    for (WorkflowOutputParameter workflowOutputParameter : workflow.getOutputs()) {\n-                        Object sources = workflowOutputParameter.getOutputSource();\n-                        processDependencies(nodePrefix, endDependencies, sources);\n-                    }\n+                if (secondaryFile != null) {\n+                    nodeDockerInfo.put(workflowStepId, new MutableTriple<>(secondaryFile, stepDockerRequirement, dockerUrl));\n+                } else {\n+                    nodeDockerInfo.put(workflowStepId, new MutableTriple<>(mainDescriptorPath, stepDockerRequirement, dockerUrl));\n+                }\n \n-                    toolInfoMap.put(\"UniqueEndKey\", new ToolInfo(null, endDependencies));\n-                    nodePairs.add(new MutablePair<>(\"UniqueEndKey\", \"\"));\n+            }\n \n-                    // connect start node with them\n-                    for (Pair<String, String> node : nodePairs) {\n-                        if (toolInfoMap.get(node.getLeft()) == null) {\n-                            toolInfoMap.put(node.getLeft(), new ToolInfo(null, Lists.newArrayList(\"UniqueBeginKey\")));\n-                        }\n-                    }\n-                    nodePairs.add(new MutablePair<>(\"UniqueBeginKey\", \"\"));\n+            if (type == LanguageHandlerInterface.Type.DAG) {\n+                // Determine steps that point to end\n+                List<String> endDependencies = new ArrayList<>();\n \n-                    return Optional.of(setupJSONDAG(nodePairs, toolInfoMap, stepToType, nodeDockerInfo));\n-                } else {\n-                    return Optional.of(getJSONTableToolContent(nodeDockerInfo));\n+                for (WorkflowOutputParameter workflowOutputParameter : workflow.getOutputs()) {\n+                    Object sources = workflowOutputParameter.getOutputSource();\n+                    processDependencies(nodePrefix, endDependencies, sources);\n                 }\n-            } catch (JsonParseException ex) {\n-                LOG.error(\"The JSON file provided is invalid.\", ex);\n-                return Optional.empty();\n+\n+                toolInfoMap.put(\"UniqueEndKey\", new ToolInfo(null, endDependencies));\n+                nodePairs.add(new MutablePair<>(\"UniqueEndKey\", \"\"));\n+\n+                // connect start node with them\n+                for (Pair<String, String> node : nodePairs) {\n+                    if (toolInfoMap.get(node.getLeft()) == null) {\n+                        toolInfoMap.put(node.getLeft(), new ToolInfo(null, Lists.newArrayList(\"UniqueBeginKey\")));\n+                    }\n+                }\n+                nodePairs.add(new MutablePair<>(\"UniqueBeginKey\", \"\"));\n+\n+                return Optional.of(setupJSONDAG(nodePairs, toolInfoMap, stepToType, nodeDockerInfo));\n+            } else {\n+                return Optional.of(getJSONTableToolContent(nodeDockerInfo));\n             }\n-        } else {\n-            return Optional.empty();\n+        } catch (ClassCastException | YAMLException | JsonParseException ex) {\n+            throw new CustomWebApplicationException(this.CWL_PARSE_ERROR + ex.getMessage(), HttpStatus.SC_BAD_REQUEST);", "originalCommit": "a2b130262fa7f033814d101bfe8573a4dc3f685e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDcxMzMzOA==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r524713338", "bodyText": "Logged.", "author": "Richard-Hansen", "createdAt": "2020-11-16T22:59:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyNjQxNg=="}], "type": "inlineReview"}, {"oid": "c5277c33e2a3bf271f3be4e33b742fb646b1a076", "url": "https://github.com/dockstore/dockstore/commit/c5277c33e2a3bf271f3be4e33b742fb646b1a076", "message": "PR suggestions. Modifed test assertions and logging", "committedDate": "2020-11-16T22:38:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2NDIwOQ==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r524864209", "bodyText": "Sorry, I didn't provide the right level of request to log the exception. Before the throw, LOG the error, making the exception the second parameter. Something like this:\nfinal String msg = WDLHandler.WDL_PARSE_ERROR + ex.getMessage();\nLOG.error(msg, ex);\nthrow new CustomWebApplicationException(msg, HttpStatus.SC_BAD_REQUEST);\n\nThe reason for this if this error starts happening in production, we can go look at the logs, and see what the actual error is.\nI don't think you need the 3rd parameter to CustomWebapplicationException.", "author": "coverbeck", "createdAt": "2020-11-17T03:39:04Z", "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/languages/WDLHandler.java", "diffHunk": "@@ -427,10 +428,13 @@ public VersionTypeValidation validateTestParameterSet(Set<SourceFile> sourceFile\n             // Iterate over each call, determine dependencies\n             Map<String, List<String>> callsToDependencies = wdlBridge.getCallsToDependencies(tempMainDescriptor.getAbsolutePath(), mainDescName);\n             toolInfoMap = mapConverterToToolInfo(callsToDockerMap, callsToDependencies);\n+\n             // Get import files\n             namespaceToPath = wdlBridge.getImportMap(tempMainDescriptor.getAbsolutePath(), mainDescName);\n-        } catch (IOException | NoSuchElementException | WdlParser.SyntaxError e) {\n-            throw new CustomWebApplicationException(\"could not process wdl into DAG: \" + e.getMessage(), HttpStatus.SC_INTERNAL_SERVER_ERROR);\n+        } catch (WdlParser.SyntaxError ex) {\n+            throw new CustomWebApplicationException(WDLHandler.WDL_PARSE_ERROR + ex.getMessage(), HttpStatus.SC_BAD_REQUEST, ex);", "originalCommit": "c5277c33e2a3bf271f3be4e33b742fb646b1a076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU5MDg5Nw==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r525590897", "bodyText": "Oops, I see what you mean. I thought we wanted the stack trace to be available within the thrown exception, which is why I added the extra parameter to CustomWebapplicationException.\nFixed.", "author": "Richard-Hansen", "createdAt": "2020-11-17T23:21:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2NDIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2NTA1Ng==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r524865056", "bodyText": "The variable name is equals, but you're not testing for equality, you're testing for startsWith. A little confusing, and I'm not sure which one you want.\nNvm, I see it was like this already.", "author": "coverbeck", "createdAt": "2020-11-17T03:41:55Z", "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/languages/CWLHandler.java", "diffHunk": "@@ -261,6 +268,21 @@ private void handlePotentialFormatEntry(Set<FileFormat> fileFormats, Object v) {\n \n             // Convert YAML to JSON\n             Map<String, Object> mapping = yaml.loadAs(mainDescriptor, Map.class);\n+\n+            // verify cwl version is correctly specified\n+            final Object cwlVersion = mapping.get(\"cwlVersion\");\n+            if (cwlVersion != null) {\n+                final boolean equals = cwlVersion.toString().startsWith(CWLHandler.CWL_VERSION_PREFIX);", "originalCommit": "c5277c33e2a3bf271f3be4e33b742fb646b1a076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU5MTYyOQ==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r525591629", "bodyText": "Modified both areas to have a more descriptive variable name, see here.", "author": "Richard-Hansen", "createdAt": "2020-11-17T23:23:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2NTA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2NTUyOA==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r524865528", "bodyText": "Log the exception (see my other comment)", "author": "coverbeck", "createdAt": "2020-11-17T03:43:44Z", "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/languages/CWLHandler.java", "diffHunk": "@@ -274,177 +296,171 @@ private void handlePotentialFormatEntry(Set<FileFormat> fileFormats, Object v) {\n             String expressionToolType = \"expressionTool\";\n \n             // Set up GSON for JSON parsing\n-            Gson gson;\n-            try {\n-                gson = CWL.getTypeSafeCWLToolDocument();\n+            Gson gson = CWL.getTypeSafeCWLToolDocument();\n \n-                final Workflow workflow = gson.fromJson(cwlJson.toString(), Workflow.class);\n+            final Workflow workflow = gson.fromJson(cwlJson.toString(), Workflow.class);\n \n-                if (workflow == null) {\n-                    LOG.error(\"The workflow does not seem to conform to CWL specs.\");\n-                    return Optional.empty();\n-                }\n+            if (workflow == null) {\n+                LOG.error(\"The workflow does not seem to conform to CWL specs.\");\n+                return Optional.empty();\n+            }\n \n-                // Determine default docker path (Check requirement first and then hint)\n-                defaultDockerPath = getRequirementOrHint(workflow.getRequirements(), workflow.getHints(), defaultDockerPath);\n-\n-                // Store workflow steps in json and then read it into map <String, WorkflowStep>\n-                Object steps = workflow.getSteps();\n-                String stepJson = gson.toJson(steps);\n-                Map<String, WorkflowStep> workflowStepMap;\n-                if (steps instanceof ArrayList) {\n-                    ArrayList<WorkflowStep> workflowStepList = gson.fromJson(stepJson, new TypeToken<ArrayList<WorkflowStep>>() {\n-                    }.getType());\n-                    workflowStepMap = new LinkedTreeMap<>();\n-                    workflowStepList.forEach(workflowStep -> workflowStepMap.put(workflowStep.getId().toString(), workflowStep));\n-                } else {\n-                    workflowStepMap = gson.fromJson(stepJson, new TypeToken<Map<String, WorkflowStep>>() {\n-                    }.getType());\n-                }\n+            // Determine default docker path (Check requirement first and then hint)\n+            defaultDockerPath = getRequirementOrHint(workflow.getRequirements(), workflow.getHints(), defaultDockerPath);\n+\n+            // Store workflow steps in json and then read it into map <String, WorkflowStep>\n+            Object steps = workflow.getSteps();\n+            String stepJson = gson.toJson(steps);\n+            Map<String, WorkflowStep> workflowStepMap;\n+            if (steps instanceof ArrayList) {\n+                ArrayList<WorkflowStep> workflowStepList = gson.fromJson(stepJson, new TypeToken<ArrayList<WorkflowStep>>() {\n+                }.getType());\n+                workflowStepMap = new LinkedTreeMap<>();\n+                workflowStepList.forEach(workflowStep -> workflowStepMap.put(workflowStep.getId().toString(), workflowStep));\n+            } else {\n+                workflowStepMap = gson.fromJson(stepJson, new TypeToken<Map<String, WorkflowStep>>() {\n+                }.getType());\n+            }\n \n-                if (stepJson == null) {\n-                    LOG.error(\"Could not find any steps for the workflow.\");\n-                    return Optional.empty();\n-                }\n+            if (stepJson == null) {\n+                LOG.error(\"Could not find any steps for the workflow.\");\n+                return Optional.empty();\n+            }\n \n-                if (workflowStepMap == null) {\n-                    LOG.error(\"Error deserializing workflow steps\");\n-                    return Optional.empty();\n-                }\n+            if (workflowStepMap == null) {\n+                LOG.error(\"Error deserializing workflow steps\");\n+                return Optional.empty();\n+            }\n \n-                // Iterate through steps to find dependencies and docker requirements\n-                for (Map.Entry<String, WorkflowStep> entry : workflowStepMap.entrySet()) {\n-                    WorkflowStep workflowStep = entry.getValue();\n-                    String workflowStepId = nodePrefix + entry.getKey();\n+            // Iterate through steps to find dependencies and docker requirements\n+            for (Map.Entry<String, WorkflowStep> entry : workflowStepMap.entrySet()) {\n+                WorkflowStep workflowStep = entry.getValue();\n+                String workflowStepId = nodePrefix + entry.getKey();\n \n-                    ArrayList<String> stepDependencies = new ArrayList<>();\n+                ArrayList<String> stepDependencies = new ArrayList<>();\n \n-                    // Iterate over source and get the dependencies\n-                    if (workflowStep.getIn() != null) {\n-                        for (WorkflowStepInput workflowStepInput : workflowStep.getIn()) {\n-                            Object sources = workflowStepInput.getSource();\n+                // Iterate over source and get the dependencies\n+                if (workflowStep.getIn() != null) {\n+                    for (WorkflowStepInput workflowStepInput : workflowStep.getIn()) {\n+                        Object sources = workflowStepInput.getSource();\n \n-                            processDependencies(nodePrefix, stepDependencies, sources);\n-                        }\n-                        if (stepDependencies.size() > 0) {\n-                            toolInfoMap.computeIfPresent(workflowStepId, (toolId, toolInfo) -> {\n-                                toolInfo.toolDependencyList.addAll(stepDependencies);\n-                                return toolInfo;\n-                            });\n-                            toolInfoMap.computeIfAbsent(workflowStepId, toolId -> new ToolInfo(null, stepDependencies));\n-                        }\n+                        processDependencies(nodePrefix, stepDependencies, sources);\n                     }\n-\n-                    // Check workflow step for docker requirement and hints\n-                    String stepDockerRequirement = defaultDockerPath;\n-                    stepDockerRequirement = getRequirementOrHint(workflowStep.getRequirements(), workflowStep.getHints(),\n-                        stepDockerRequirement);\n-\n-                    // Check for docker requirement within workflow step file\n-                    String secondaryFile = null;\n-                    Object run = workflowStep.getRun();\n-                    String runAsJson = gson.toJson(gson.toJsonTree(run));\n-\n-                    if (run instanceof String) {\n-                        secondaryFile = (String)run;\n-                    } else if (isTool(runAsJson, yaml)) {\n-                        CommandLineTool clTool = gson.fromJson(runAsJson, CommandLineTool.class);\n-                        stepDockerRequirement = getRequirementOrHint(clTool.getRequirements(), clTool.getHints(),\n-                            stepDockerRequirement);\n-                        stepToType.put(workflowStepId, toolType);\n-                    } else if (isWorkflow(runAsJson, yaml)) {\n-                        Workflow stepWorkflow = gson.fromJson(runAsJson, Workflow.class);\n-                        stepDockerRequirement = getRequirementOrHint(stepWorkflow.getRequirements(), stepWorkflow.getHints(),\n-                            stepDockerRequirement);\n-                        stepToType.put(workflowStepId, workflowType);\n-                    } else if (isExpressionTool(runAsJson, yaml)) {\n-                        ExpressionTool expressionTool = gson.fromJson(runAsJson, ExpressionTool.class);\n-                        stepDockerRequirement = getRequirementOrHint(expressionTool.getRequirements(), expressionTool.getHints(),\n-                            stepDockerRequirement);\n-                        stepToType.put(workflowStepId, expressionToolType);\n-                    } else if (run instanceof Map) {\n-                        // must be import or include\n-                        Object importVal = ((Map)run).containsKey(\"$import\") ? ((Map)run).get(\"$import\") : ((Map)run).get(\"import\");\n-                        if (importVal != null) {\n-                            secondaryFile = importVal.toString();\n-                        }\n-\n-                        Object includeVal = ((Map)run).containsKey(\"$include\") ? ((Map)run).get(\"$include\") : ((Map)run).get(\"include\");\n-                        if (includeVal != null) {\n-                            secondaryFile = includeVal.toString();\n-                        }\n-\n-                        if (secondaryFile == null) {\n-                            LOG.error(\"Syntax incorrect. Could not ($)import or ($)include secondary file for run command: \" + run);\n-                            return Optional.empty();\n-                        }\n+                    if (stepDependencies.size() > 0) {\n+                        toolInfoMap.computeIfPresent(workflowStepId, (toolId, toolInfo) -> {\n+                            toolInfo.toolDependencyList.addAll(stepDependencies);\n+                            return toolInfo;\n+                        });\n+                        toolInfoMap.computeIfAbsent(workflowStepId, toolId -> new ToolInfo(null, stepDependencies));\n                     }\n+                }\n \n-                    // Check secondary file for docker pull\n-                    if (secondaryFile != null) {\n-                        String finalSecondaryFile = secondaryFile;\n-                        final Optional<SourceFile> sourceFileOptional = secondarySourceFiles.stream()\n-                                .filter(sf -> sf.getPath().equals(finalSecondaryFile)).findFirst();\n-                        final String content = sourceFileOptional.map(SourceFile::getContent).orElse(null);\n-                        stepDockerRequirement = parseSecondaryFile(stepDockerRequirement, content, gson, yaml);\n-                        if (isExpressionTool(content, yaml)) {\n-                            stepToType.put(workflowStepId, expressionToolType);\n-                        } else if (isTool(content, yaml)) {\n-                            stepToType.put(workflowStepId, toolType);\n-                        } else if (isWorkflow(content, yaml)) {\n-                            stepToType.put(workflowStepId, workflowType);\n-                        } else {\n-                            stepToType.put(workflowStepId, \"n/a\");\n-                        }\n+                // Check workflow step for docker requirement and hints\n+                String stepDockerRequirement = defaultDockerPath;\n+                stepDockerRequirement = getRequirementOrHint(workflowStep.getRequirements(), workflowStep.getHints(),\n+                    stepDockerRequirement);\n+\n+                // Check for docker requirement within workflow step file\n+                String secondaryFile = null;\n+                Object run = workflowStep.getRun();\n+                String runAsJson = gson.toJson(gson.toJsonTree(run));\n+\n+                if (run instanceof String) {\n+                    secondaryFile = (String)run;\n+                } else if (isTool(runAsJson, yaml)) {\n+                    CommandLineTool clTool = gson.fromJson(runAsJson, CommandLineTool.class);\n+                    stepDockerRequirement = getRequirementOrHint(clTool.getRequirements(), clTool.getHints(),\n+                        stepDockerRequirement);\n+                    stepToType.put(workflowStepId, toolType);\n+                } else if (isWorkflow(runAsJson, yaml)) {\n+                    Workflow stepWorkflow = gson.fromJson(runAsJson, Workflow.class);\n+                    stepDockerRequirement = getRequirementOrHint(stepWorkflow.getRequirements(), stepWorkflow.getHints(),\n+                        stepDockerRequirement);\n+                    stepToType.put(workflowStepId, workflowType);\n+                } else if (isExpressionTool(runAsJson, yaml)) {\n+                    ExpressionTool expressionTool = gson.fromJson(runAsJson, ExpressionTool.class);\n+                    stepDockerRequirement = getRequirementOrHint(expressionTool.getRequirements(), expressionTool.getHints(),\n+                        stepDockerRequirement);\n+                    stepToType.put(workflowStepId, expressionToolType);\n+                } else if (run instanceof Map) {\n+                    // must be import or include\n+                    Object importVal = ((Map)run).containsKey(\"$import\") ? ((Map)run).get(\"$import\") : ((Map)run).get(\"import\");\n+                    if (importVal != null) {\n+                        secondaryFile = importVal.toString();\n                     }\n \n-                    String dockerUrl = null;\n-                    if ((stepToType.get(workflowStepId).equals(workflowType) || stepToType.get(workflowStepId).equals(toolType)) && !Strings.isNullOrEmpty(stepDockerRequirement)) {\n-                        dockerUrl = getURLFromEntry(stepDockerRequirement, dao);\n+                    Object includeVal = ((Map)run).containsKey(\"$include\") ? ((Map)run).get(\"$include\") : ((Map)run).get(\"include\");\n+                    if (includeVal != null) {\n+                        secondaryFile = includeVal.toString();\n                     }\n \n-                    if (type == LanguageHandlerInterface.Type.DAG) {\n-                        nodePairs.add(new MutablePair<>(workflowStepId, dockerUrl));\n+                    if (secondaryFile == null) {\n+                        LOG.error(CWLHandler.CWL_PARSE_SECONDARY_ERROR + run);\n+                        throw new CustomWebApplicationException(CWLHandler.CWL_PARSE_SECONDARY_ERROR + run, HttpStatus.SC_BAD_REQUEST);\n                     }\n+                }\n \n-                    if (secondaryFile != null) {\n-                        nodeDockerInfo.put(workflowStepId, new MutableTriple<>(secondaryFile, stepDockerRequirement, dockerUrl));\n+                // Check secondary file for docker pull\n+                if (secondaryFile != null) {\n+                    String finalSecondaryFile = secondaryFile;\n+                    final Optional<SourceFile> sourceFileOptional = secondarySourceFiles.stream()\n+                            .filter(sf -> sf.getPath().equals(finalSecondaryFile)).findFirst();\n+                    final String content = sourceFileOptional.map(SourceFile::getContent).orElse(null);\n+                    stepDockerRequirement = parseSecondaryFile(stepDockerRequirement, content, gson, yaml);\n+                    if (isExpressionTool(content, yaml)) {\n+                        stepToType.put(workflowStepId, expressionToolType);\n+                    } else if (isTool(content, yaml)) {\n+                        stepToType.put(workflowStepId, toolType);\n+                    } else if (isWorkflow(content, yaml)) {\n+                        stepToType.put(workflowStepId, workflowType);\n                     } else {\n-                        nodeDockerInfo.put(workflowStepId, new MutableTriple<>(mainDescriptorPath, stepDockerRequirement, dockerUrl));\n+                        stepToType.put(workflowStepId, \"n/a\");\n                     }\n+                }\n \n+                String dockerUrl = null;\n+                if ((stepToType.get(workflowStepId).equals(workflowType) || stepToType.get(workflowStepId).equals(toolType)) && !Strings.isNullOrEmpty(stepDockerRequirement)) {\n+                    dockerUrl = getURLFromEntry(stepDockerRequirement, dao);\n                 }\n \n                 if (type == LanguageHandlerInterface.Type.DAG) {\n-                    // Determine steps that point to end\n-                    List<String> endDependencies = new ArrayList<>();\n+                    nodePairs.add(new MutablePair<>(workflowStepId, dockerUrl));\n+                }\n \n-                    for (WorkflowOutputParameter workflowOutputParameter : workflow.getOutputs()) {\n-                        Object sources = workflowOutputParameter.getOutputSource();\n-                        processDependencies(nodePrefix, endDependencies, sources);\n-                    }\n+                if (secondaryFile != null) {\n+                    nodeDockerInfo.put(workflowStepId, new MutableTriple<>(secondaryFile, stepDockerRequirement, dockerUrl));\n+                } else {\n+                    nodeDockerInfo.put(workflowStepId, new MutableTriple<>(mainDescriptorPath, stepDockerRequirement, dockerUrl));\n+                }\n \n-                    toolInfoMap.put(\"UniqueEndKey\", new ToolInfo(null, endDependencies));\n-                    nodePairs.add(new MutablePair<>(\"UniqueEndKey\", \"\"));\n+            }\n \n-                    // connect start node with them\n-                    for (Pair<String, String> node : nodePairs) {\n-                        if (toolInfoMap.get(node.getLeft()) == null) {\n-                            toolInfoMap.put(node.getLeft(), new ToolInfo(null, Lists.newArrayList(\"UniqueBeginKey\")));\n-                        }\n-                    }\n-                    nodePairs.add(new MutablePair<>(\"UniqueBeginKey\", \"\"));\n+            if (type == LanguageHandlerInterface.Type.DAG) {\n+                // Determine steps that point to end\n+                List<String> endDependencies = new ArrayList<>();\n \n-                    return Optional.of(setupJSONDAG(nodePairs, toolInfoMap, stepToType, nodeDockerInfo));\n-                } else {\n-                    return Optional.of(getJSONTableToolContent(nodeDockerInfo));\n+                for (WorkflowOutputParameter workflowOutputParameter : workflow.getOutputs()) {\n+                    Object sources = workflowOutputParameter.getOutputSource();\n+                    processDependencies(nodePrefix, endDependencies, sources);\n                 }\n-            } catch (JsonParseException ex) {\n-                LOG.error(\"The JSON file provided is invalid.\", ex);\n-                return Optional.empty();\n+\n+                toolInfoMap.put(\"UniqueEndKey\", new ToolInfo(null, endDependencies));\n+                nodePairs.add(new MutablePair<>(\"UniqueEndKey\", \"\"));\n+\n+                // connect start node with them\n+                for (Pair<String, String> node : nodePairs) {\n+                    if (toolInfoMap.get(node.getLeft()) == null) {\n+                        toolInfoMap.put(node.getLeft(), new ToolInfo(null, Lists.newArrayList(\"UniqueBeginKey\")));\n+                    }\n+                }\n+                nodePairs.add(new MutablePair<>(\"UniqueBeginKey\", \"\"));\n+\n+                return Optional.of(setupJSONDAG(nodePairs, toolInfoMap, stepToType, nodeDockerInfo));\n+            } else {\n+                return Optional.of(getJSONTableToolContent(nodeDockerInfo));\n             }\n-        } else {\n-            return Optional.empty();\n+        } catch (ClassCastException | YAMLException | JsonParseException ex) {\n+            throw new CustomWebApplicationException(CWLHandler.CWL_PARSE_ERROR + ex.getMessage(), HttpStatus.SC_BAD_REQUEST, ex);", "originalCommit": "c5277c33e2a3bf271f3be4e33b742fb646b1a076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU5MTE4MA==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r525591180", "bodyText": "Logged.", "author": "Richard-Hansen", "createdAt": "2020-11-17T23:22:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2NTUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2NTYwOA==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r524865608", "bodyText": "equals != startsWith", "author": "coverbeck", "createdAt": "2020-11-17T03:44:02Z", "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/languages/CWLHandler.java", "diffHunk": "@@ -725,7 +741,7 @@ private boolean isValidCwl(String content, Yaml yaml) {\n             final Object cwlVersion = mapping.get(\"cwlVersion\");\n \n             if (cwlVersion != null) {\n-                final boolean equals = cwlVersion.toString().startsWith(\"v1\");\n+                final boolean equals = cwlVersion.toString().startsWith(CWLHandler.CWL_VERSION_PREFIX);", "originalCommit": "c5277c33e2a3bf271f3be4e33b742fb646b1a076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU5MjIzNQ==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r525592235", "bodyText": "Modified. Changed to startsWith (in both locations, see comment above).", "author": "Richard-Hansen", "createdAt": "2020-11-17T23:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2NTYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2NzA4NQ==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r524867085", "bodyText": "Not sure you need this (see my other comment)", "author": "coverbeck", "createdAt": "2020-11-17T03:49:38Z", "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/CustomWebApplicationException.java", "diffHunk": "@@ -31,6 +31,11 @@ public CustomWebApplicationException(String message, int status) {\n         this.errorMessage = message;\n     }\n \n+    public CustomWebApplicationException(String message, int status, Throwable ex) {", "originalCommit": "c5277c33e2a3bf271f3be4e33b742fb646b1a076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU5MjkxMg==", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r525592912", "bodyText": "Removed overloaded constructor with third parameter, since no longer passing the Throwable into the custom exception.", "author": "Richard-Hansen", "createdAt": "2020-11-17T23:26:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2NzA4NQ=="}], "type": "inlineReview"}, {"oid": "76d246baa2dabe6b004914606056c5645a7acb12", "url": "https://github.com/dockstore/dockstore/commit/76d246baa2dabe6b004914606056c5645a7acb12", "message": "Fixed logging. Renamed variable to better represent its functionality", "committedDate": "2020-11-17T16:09:09Z", "type": "commit"}, {"oid": "f183bbe170eb2515e6a04e8314ed040fb35d24ec", "url": "https://github.com/dockstore/dockstore/commit/f183bbe170eb2515e6a04e8314ed040fb35d24ec", "message": "Merge branch 'develop' of https://github.com/dockstore/dockstore into feature/3810/WorkflowToolList500", "committedDate": "2020-11-18T19:37:02Z", "type": "commit"}, {"oid": "9787e01ee0b37d12109cd1accd2e8fb69770cec4", "url": "https://github.com/dockstore/dockstore/commit/9787e01ee0b37d12109cd1accd2e8fb69770cec4", "message": "Fixed test text assertion, syntax change for other tests", "committedDate": "2020-11-20T16:41:19Z", "type": "commit"}]}