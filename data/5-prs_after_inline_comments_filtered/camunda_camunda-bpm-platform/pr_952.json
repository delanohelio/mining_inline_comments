{"pr_number": 952, "pr_title": "[CAM-12382] chore(optimize): add new historic incident endpoint", "pr_createdAt": "2020-09-02T09:44:54Z", "pr_url": "https://github.com/camunda/camunda-bpm-platform/pull/952", "timeline": [{"oid": "e626ce93b1307aad2b18821b4f9e94fa511448cf", "url": "https://github.com/camunda/camunda-bpm-platform/commit/e626ce93b1307aad2b18821b4f9e94fa511448cf", "message": "chore(optimize): add new historic incident endpoint\n\nrelated to #CAM-12382", "committedDate": "2020-09-02T09:42:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ5NTI0Ng==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484495246", "bodyText": "You can consider asserting all of the result properties to ensure that they are all mapped to JSON.", "author": "ThorbenLindhauer", "createdAt": "2020-09-07T15:33:22Z", "path": "engine-rest/engine-rest/src/test/java/org/camunda/bpm/engine/rest/optimize/OptimizeCompletedHistoricIncidentRestServiceTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.rest.optimize;\n+\n+import io.restassured.response.Response;\n+import org.camunda.bpm.engine.ProcessEngine;\n+import org.camunda.bpm.engine.impl.OptimizeService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.HistoricIncidentEntity;\n+import org.camunda.bpm.engine.rest.AbstractRestServiceTest;\n+import org.camunda.bpm.engine.rest.helper.MockProvider;\n+import org.camunda.bpm.engine.rest.util.container.TestContainerRule;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response.Status;\n+import java.util.Collections;\n+import java.util.Date;\n+\n+import static io.restassured.RestAssured.given;\n+import static io.restassured.path.json.JsonPath.from;\n+import static org.camunda.bpm.engine.rest.util.DateTimeUtils.DATE_FORMAT_WITH_TIMEZONE;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+public class OptimizeCompletedHistoricIncidentRestServiceTest extends AbstractRestServiceTest {\n+\n+  public static final String OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH =\n+    TEST_RESOURCE_ROOT_PATH + \"/optimize/incident/completed\";\n+\n+  protected OptimizeService mockedOptimizeService;\n+  protected ProcessEngine namedProcessEngine;\n+\n+  @ClassRule\n+  public static TestContainerRule rule = new TestContainerRule();\n+\n+  @Before\n+  public void setUpRuntimeData() {\n+    mockedOptimizeService = mock(OptimizeService.class);\n+    ProcessEngineConfigurationImpl mockedConfig = mock(ProcessEngineConfigurationImpl.class);\n+\n+    namedProcessEngine = getProcessEngine(MockProvider.EXAMPLE_PROCESS_ENGINE_NAME);\n+    when(namedProcessEngine.getProcessEngineConfiguration()).thenReturn(mockedConfig);\n+    when(mockedConfig.getOptimizeService()).thenReturn(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testNoQueryParameters() {\n+    given()\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getCompletedHistoricIncidents(null, null, Integer.MAX_VALUE);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testFinishedAfterQueryParameter() {\n+    Date now = new Date();\n+    given()\n+      .queryParam(\"finishedAfter\", DATE_FORMAT_WITH_TIMEZONE.format(now))\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getCompletedHistoricIncidents(now, null, Integer.MAX_VALUE);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testFinishedAtQueryParameter() {\n+    Date now = new Date();\n+    given()\n+      .queryParam(\"finishedAt\", DATE_FORMAT_WITH_TIMEZONE.format(now))\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getCompletedHistoricIncidents(null, now, Integer.MAX_VALUE);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testMaxResultsQueryParameter() {\n+    given()\n+      .queryParam(\"maxResults\", 10)\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getCompletedHistoricIncidents(null, null, 10);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testQueryParameterCombination() {\n+    Date now = new Date();\n+    given()\n+      .queryParam(\"finishedAfter\", DATE_FORMAT_WITH_TIMEZONE.format(now))\n+      .queryParam(\"finishedAt\", DATE_FORMAT_WITH_TIMEZONE.format(now))\n+      .queryParam(\"maxResults\", 10)\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getCompletedHistoricIncidents(now, now, 10);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testPresenceOfProcessInstanceIdProperty() {\n+    final HistoricIncidentEntity mock = mock(HistoricIncidentEntity.class);\n+    when(mock.getProcessInstanceId()).thenReturn(MockProvider.EXAMPLE_PROCESS_INSTANCE_ID);\n+    when(mockedOptimizeService.getCompletedHistoricIncidents(null, null, Integer.MAX_VALUE))\n+      .thenReturn(Collections.singletonList(mock));\n+\n+    final Response response = given()\n+      .then()\n+        .expect()\n+          .statusCode(Status.OK.getStatusCode())\n+          .contentType(MediaType.APPLICATION_JSON)\n+      .when()\n+        .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    String content = response.asString();\n+    String processInstanceId = from(content).getString(\"[0].processInstanceId\");\n+\n+    assertEquals(MockProvider.EXAMPLE_PROCESS_INSTANCE_ID, processInstanceId);", "originalCommit": "e626ce93b1307aad2b18821b4f9e94fa511448cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc5OTYwNw==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484799607", "bodyText": "Good idea, but I'm not sure if it adds a lot of value. I think this would just test the mapping library. I'll keep it as it is if you don't have any profound reasons to test all the fields.", "author": "JoHeinem", "createdAt": "2020-09-08T10:00:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ5NTI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgwMDc5Mg==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484800792", "bodyText": "It also tests the presence of the properties in the DTO as well as their initialization. But I'm fine either way.", "author": "ThorbenLindhauer", "createdAt": "2020-09-08T10:02:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ5NTI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0NDI5Nw==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r485544297", "bodyText": "I gave it a try and wanted to reuse the mock methods that are already used by other test classes. However, it turns out to be more complicated so I'll leave it as it is as the value isn't worth the effort imho.", "author": "JoHeinem", "createdAt": "2020-09-09T11:41:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ5NTI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ5NTQzNw==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484495437", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static final String OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH =\n          \n          \n            \n              public static final String OPTIMIZE_OPEN_HISTORIC_INCIDENT_PATH =\n          \n      \n    \n    \n  \n\nand also rename the usages.", "author": "ThorbenLindhauer", "createdAt": "2020-09-07T15:33:53Z", "path": "engine-rest/engine-rest/src/test/java/org/camunda/bpm/engine/rest/optimize/OptimizeOpenHistoricIncidentRestServiceTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.rest.optimize;\n+\n+import io.restassured.response.Response;\n+import org.camunda.bpm.engine.ProcessEngine;\n+import org.camunda.bpm.engine.impl.OptimizeService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.HistoricIncidentEntity;\n+import org.camunda.bpm.engine.rest.AbstractRestServiceTest;\n+import org.camunda.bpm.engine.rest.helper.MockProvider;\n+import org.camunda.bpm.engine.rest.util.container.TestContainerRule;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response.Status;\n+import java.util.Collections;\n+import java.util.Date;\n+\n+import static io.restassured.RestAssured.given;\n+import static io.restassured.path.json.JsonPath.from;\n+import static org.camunda.bpm.engine.rest.util.DateTimeUtils.DATE_FORMAT_WITH_TIMEZONE;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+public class OptimizeOpenHistoricIncidentRestServiceTest extends AbstractRestServiceTest {\n+\n+  public static final String OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH =", "originalCommit": "e626ce93b1307aad2b18821b4f9e94fa511448cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc5OTc3MQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484799771", "bodyText": "Good catch!", "author": "JoHeinem", "createdAt": "2020-09-08T10:00:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ5NTQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ5NTY2Ng==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484495666", "bodyText": "Same here, it could make sense to assert all properties.", "author": "ThorbenLindhauer", "createdAt": "2020-09-07T15:34:27Z", "path": "engine-rest/engine-rest/src/test/java/org/camunda/bpm/engine/rest/optimize/OptimizeOpenHistoricIncidentRestServiceTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.rest.optimize;\n+\n+import io.restassured.response.Response;\n+import org.camunda.bpm.engine.ProcessEngine;\n+import org.camunda.bpm.engine.impl.OptimizeService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.HistoricIncidentEntity;\n+import org.camunda.bpm.engine.rest.AbstractRestServiceTest;\n+import org.camunda.bpm.engine.rest.helper.MockProvider;\n+import org.camunda.bpm.engine.rest.util.container.TestContainerRule;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response.Status;\n+import java.util.Collections;\n+import java.util.Date;\n+\n+import static io.restassured.RestAssured.given;\n+import static io.restassured.path.json.JsonPath.from;\n+import static org.camunda.bpm.engine.rest.util.DateTimeUtils.DATE_FORMAT_WITH_TIMEZONE;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+public class OptimizeOpenHistoricIncidentRestServiceTest extends AbstractRestServiceTest {\n+\n+  public static final String OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH =\n+    TEST_RESOURCE_ROOT_PATH + \"/optimize/incident/open\";\n+\n+  protected OptimizeService mockedOptimizeService;\n+  protected ProcessEngine namedProcessEngine;\n+\n+  @ClassRule\n+  public static TestContainerRule rule = new TestContainerRule();\n+\n+  @Before\n+  public void setUpRuntimeData() {\n+    mockedOptimizeService = mock(OptimizeService.class);\n+    ProcessEngineConfigurationImpl mockedConfig = mock(ProcessEngineConfigurationImpl.class);\n+\n+    namedProcessEngine = getProcessEngine(MockProvider.EXAMPLE_PROCESS_ENGINE_NAME);\n+    when(namedProcessEngine.getProcessEngineConfiguration()).thenReturn(mockedConfig);\n+    when(mockedConfig.getOptimizeService()).thenReturn(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testNoQueryParameters() {\n+    given()\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getOpenHistoricIncidents(null, null, Integer.MAX_VALUE);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testCreatedAfterQueryParameter() {\n+    Date now = new Date();\n+    given()\n+      .queryParam(\"createdAfter\", DATE_FORMAT_WITH_TIMEZONE.format(now))\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getOpenHistoricIncidents(now, null, Integer.MAX_VALUE);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testCreatedAtQueryParameter() {\n+    Date now = new Date();\n+    given()\n+      .queryParam(\"createdAt\", DATE_FORMAT_WITH_TIMEZONE.format(now))\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getOpenHistoricIncidents(null, now, Integer.MAX_VALUE);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testMaxResultsQueryParameter() {\n+    given()\n+      .queryParam(\"maxResults\", 10)\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getOpenHistoricIncidents(null, null, 10);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testQueryParameterCombination() {\n+    Date now = new Date();\n+    given()\n+      .queryParam(\"createdAfter\", DATE_FORMAT_WITH_TIMEZONE.format(now))\n+      .queryParam(\"createdAt\", DATE_FORMAT_WITH_TIMEZONE.format(now))\n+      .queryParam(\"maxResults\", 10)\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getOpenHistoricIncidents(now, now, 10);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testPresenceOfProcessInstanceIdProperty() {\n+    final HistoricIncidentEntity mock = mock(HistoricIncidentEntity.class);\n+    when(mock.getProcessInstanceId()).thenReturn(MockProvider.EXAMPLE_PROCESS_INSTANCE_ID);\n+    when(mockedOptimizeService.getOpenHistoricIncidents(null, null, Integer.MAX_VALUE))\n+      .thenReturn(Collections.singletonList(mock));\n+\n+    final Response response = given()\n+      .then()\n+        .expect()\n+          .statusCode(Status.OK.getStatusCode())\n+          .contentType(MediaType.APPLICATION_JSON)\n+      .when()\n+        .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    String content = response.asString();\n+    String processInstanceId = from(content).getString(\"[0].processInstanceId\");\n+\n+    assertEquals(MockProvider.EXAMPLE_PROCESS_INSTANCE_ID, processInstanceId);", "originalCommit": "e626ce93b1307aad2b18821b4f9e94fa511448cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0NDg1Nw==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r485544857", "bodyText": "See my remarks to your comment above. I'll leave it as it is.", "author": "JoHeinem", "createdAt": "2020-09-09T11:42:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ5NTY2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwMDAyOA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484500028", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                testRule.executeAvailableJobs();\n          \n          \n            \n                runtimeService.setVariable(failingProcessInstance.getId(), \"fail\", false);\n          \n          \n            \n                String jobId = managementService.createJobQuery().singleResult().getId();\n          \n          \n            \n                managementService.setJobRetries(jobId, 1);\n          \n          \n            \n                // create open incident\n          \n          \n            \n                runtimeService.startProcessInstanceByKey(FAILING_PROCESS);\n          \n          \n            \n                testRule.executeAvailableJobs();\n          \n          \n            \n                String jobId = managementService.createJobQuery().singleResult().getId();\n          \n          \n            \n                managementService.setJobRetries(jobId, 0); // creates incident\n          \n          \n            \n                managementService.setJobRetries(jobId, 1); // resolves incident\n          \n          \n            \n                managementService.setJobRetries(jobId, 0); // creates second incident\n          \n      \n    \n    \n  \n\nThis is a bit more straightforward for creating the incidents.", "author": "ThorbenLindhauer", "createdAt": "2020-09-07T15:45:22Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/api/authorization/optimize/OptimizeServiceAuthorizationTest.java", "diffHunk": "@@ -357,6 +327,16 @@ private void generateTestData() {\n     decisionService.evaluateDecisionById(decision.getId())\n       .variables(Variables.createVariables().putValue(\"input1\", \"a\")).evaluate();\n \n+    // create completed incident data\n+    final ProcessInstance failingProcessInstance = runtimeService.startProcessInstanceByKey(FAILING_PROCESS);\n+    testRule.executeAvailableJobs();\n+    runtimeService.setVariable(failingProcessInstance.getId(), \"fail\", false);\n+    String jobId = managementService.createJobQuery().singleResult().getId();\n+    managementService.setJobRetries(jobId, 1);\n+    // create open incident\n+    runtimeService.startProcessInstanceByKey(FAILING_PROCESS);\n+    testRule.executeAvailableJobs();", "originalCommit": "e626ce93b1307aad2b18821b4f9e94fa511448cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0NTI5NA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r485545294", "bodyText": "Ah nice! I have to admit that I just copy 'n pasted the code from the historic incident tests but I like that a lot more \ud83d\udc4d", "author": "JoHeinem", "createdAt": "2020-09-09T11:43:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwMDAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwMDcyNA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484500724", "bodyText": "Same here, we can just set the job retries to 0 which is a little more efficient than executing the retries.", "author": "ThorbenLindhauer", "createdAt": "2020-09-07T15:47:10Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/api/optimize/GetCompletedHistoricIncidentsForOptimizeTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.api.optimize;\n+\n+import org.camunda.bpm.engine.AuthorizationService;\n+import org.camunda.bpm.engine.IdentityService;\n+import org.camunda.bpm.engine.ManagementService;\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.RuntimeService;\n+import org.camunda.bpm.engine.authorization.Authorization;\n+import org.camunda.bpm.engine.identity.Group;\n+import org.camunda.bpm.engine.identity.User;\n+import org.camunda.bpm.engine.impl.OptimizeService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.HistoricIncidentEntity;\n+import org.camunda.bpm.engine.impl.util.ClockUtil;\n+import org.camunda.bpm.engine.runtime.ProcessInstance;\n+import org.camunda.bpm.engine.test.ProcessEngineRule;\n+import org.camunda.bpm.engine.test.RequiredHistoryLevel;\n+import org.camunda.bpm.engine.test.api.runtime.FailingDelegate;\n+import org.camunda.bpm.engine.test.util.ProcessEngineTestRule;\n+import org.camunda.bpm.engine.test.util.ProvidedProcessEngineRule;\n+import org.camunda.bpm.model.bpmn.Bpmn;\n+import org.camunda.bpm.model.bpmn.BpmnModelInstance;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+\n+import java.util.Date;\n+import java.util.List;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+\n+@RequiredHistoryLevel(ProcessEngineConfiguration.HISTORY_FULL)\n+public class GetCompletedHistoricIncidentsForOptimizeTest {\n+\n+  private static final String PROCESS_DEFINITION_KEY = \"oneFailingServiceTaskProcess\";\n+  private static final BpmnModelInstance FAILING_SERVICE_TASK_MODEL =\n+    Bpmn.createExecutableProcess(PROCESS_DEFINITION_KEY)\n+      .startEvent(\"start\")\n+      .serviceTask(\"task\")\n+        .camundaAsyncBefore()\n+        .camundaClass(FailingDelegate.class.getName())\n+      .endEvent(\"end\")\n+      .done();\n+\n+  public ProcessEngineRule engineRule = new ProvidedProcessEngineRule();\n+  protected ProcessEngineTestRule testHelper = new ProcessEngineTestRule(engineRule);\n+\n+  @Rule\n+  public RuleChain ruleChain = RuleChain.outerRule(engineRule).around(testHelper);\n+\n+  private OptimizeService optimizeService;\n+  private IdentityService identityService;\n+  private RuntimeService runtimeService;\n+  private AuthorizationService authorizationService;\n+  private ManagementService managementService;\n+\n+  @Before\n+  public void init() {\n+    ProcessEngineConfigurationImpl config =\n+      engineRule.getProcessEngineConfiguration();\n+    optimizeService = config.getOptimizeService();\n+    identityService = engineRule.getIdentityService();\n+    runtimeService = engineRule.getRuntimeService();\n+    authorizationService = engineRule.getAuthorizationService();\n+    managementService = engineRule.getManagementService();\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    for (User user : identityService.createUserQuery().list()) {\n+      identityService.deleteUser(user.getId());\n+    }\n+    for (Group group : identityService.createGroupQuery().list()) {\n+      identityService.deleteGroup(group.getId());\n+    }\n+    for (Authorization authorization : authorizationService.createAuthorizationQuery().list()) {\n+      authorizationService.deleteAuthorization(authorization.getId());\n+    }\n+    ClockUtil.reset();\n+  }\n+\n+  @Test\n+  public void getCompletedHistoricIncidents() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(pastDate(), null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+    assertThatInstanceHasAllImportantInformation(completedIncidents.get(0));\n+  }\n+\n+  @Test\n+  public void fishedAfterParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(now, null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+  }\n+\n+  @Test\n+  public void fishedAtParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(null, now, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+    assertThat(completedIncidents.get(0).getProcessInstanceId(), is(processInstance.getId()));\n+  }\n+\n+  @Test\n+  public void fishedAfterAndFinishedAtParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(now, now, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(0));\n+  }\n+\n+  @Test\n+  public void maxResultsParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    for (int i = 0; i < 5; i++) {\n+      final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+      retryAndSucceed(processInstance);\n+    }\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(pastDate(), null, 3);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(3));\n+  }\n+\n+  @Test\n+  public void resultIsSortedByEndTime() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    Date nowPlus1Second = new Date(now.getTime() + 1000L);\n+    ClockUtil.setCurrentTime(nowPlus1Second);\n+    ProcessInstance processInstance1 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance1);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+    Date nowPlus4Seconds = new Date(nowPlus2Seconds.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus4Seconds);\n+    final ProcessInstance processInstance3 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance3);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(now, null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(3));\n+    assertThat(completedIncidents.get(0).getProcessInstanceId(), is(processInstance1.getId()));\n+    assertThat(completedIncidents.get(1).getProcessInstanceId(), is(processInstance2.getId()));\n+    assertThat(completedIncidents.get(2).getProcessInstanceId(), is(processInstance3.getId()));\n+  }\n+\n+  @Test\n+  public void fetchOnlyCompletedIncidents() {\n+    // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    startProcessInstanceAndFailWithIncident();\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(pastDate(), null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+    assertThat(completedIncidents.get(0).getProcessInstanceId(), is(processInstance.getId()));\n+  }\n+\n+  private Date pastDate() {\n+    return new Date(2L);\n+  }\n+\n+  protected void createUser(String userId) {\n+    User user = identityService.newUser(userId);\n+    identityService.saveUser(user);\n+  }\n+\n+  private void assertThatInstanceHasAllImportantInformation(HistoricIncidentEntity historicIncidentEntity) {\n+    assertThat(historicIncidentEntity, notNullValue());\n+    assertThat(historicIncidentEntity.getId(), notNullValue());\n+    assertThat(historicIncidentEntity.getProcessDefinitionKey(), is(PROCESS_DEFINITION_KEY));\n+    assertThat(historicIncidentEntity.getProcessDefinitionVersion(), nullValue());\n+    assertThat(historicIncidentEntity.getProcessDefinitionId(), notNullValue());\n+    assertThat(historicIncidentEntity.getCreateTime(), notNullValue());\n+    assertThat(historicIncidentEntity.getEndTime(), notNullValue());\n+  }\n+\n+  private void retryAndSucceed(final ProcessInstance processInstance) {\n+    runtimeService.setVariable(processInstance.getId(), \"fail\", false);\n+    String jobId = managementService.createJobQuery().singleResult().getId();\n+    managementService.setJobRetries(jobId, 1);\n+  }\n+\n+  private ProcessInstance startProcessInstanceAndFailWithIncident() {", "originalCommit": "e626ce93b1307aad2b18821b4f9e94fa511448cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwNDIyNg==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484504226", "bodyText": "This test case can be merged with getCompletedHistoricIncidents.", "author": "ThorbenLindhauer", "createdAt": "2020-09-07T15:56:17Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/api/optimize/GetCompletedHistoricIncidentsForOptimizeTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.api.optimize;\n+\n+import org.camunda.bpm.engine.AuthorizationService;\n+import org.camunda.bpm.engine.IdentityService;\n+import org.camunda.bpm.engine.ManagementService;\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.RuntimeService;\n+import org.camunda.bpm.engine.authorization.Authorization;\n+import org.camunda.bpm.engine.identity.Group;\n+import org.camunda.bpm.engine.identity.User;\n+import org.camunda.bpm.engine.impl.OptimizeService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.HistoricIncidentEntity;\n+import org.camunda.bpm.engine.impl.util.ClockUtil;\n+import org.camunda.bpm.engine.runtime.ProcessInstance;\n+import org.camunda.bpm.engine.test.ProcessEngineRule;\n+import org.camunda.bpm.engine.test.RequiredHistoryLevel;\n+import org.camunda.bpm.engine.test.api.runtime.FailingDelegate;\n+import org.camunda.bpm.engine.test.util.ProcessEngineTestRule;\n+import org.camunda.bpm.engine.test.util.ProvidedProcessEngineRule;\n+import org.camunda.bpm.model.bpmn.Bpmn;\n+import org.camunda.bpm.model.bpmn.BpmnModelInstance;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+\n+import java.util.Date;\n+import java.util.List;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+\n+@RequiredHistoryLevel(ProcessEngineConfiguration.HISTORY_FULL)\n+public class GetCompletedHistoricIncidentsForOptimizeTest {\n+\n+  private static final String PROCESS_DEFINITION_KEY = \"oneFailingServiceTaskProcess\";\n+  private static final BpmnModelInstance FAILING_SERVICE_TASK_MODEL =\n+    Bpmn.createExecutableProcess(PROCESS_DEFINITION_KEY)\n+      .startEvent(\"start\")\n+      .serviceTask(\"task\")\n+        .camundaAsyncBefore()\n+        .camundaClass(FailingDelegate.class.getName())\n+      .endEvent(\"end\")\n+      .done();\n+\n+  public ProcessEngineRule engineRule = new ProvidedProcessEngineRule();\n+  protected ProcessEngineTestRule testHelper = new ProcessEngineTestRule(engineRule);\n+\n+  @Rule\n+  public RuleChain ruleChain = RuleChain.outerRule(engineRule).around(testHelper);\n+\n+  private OptimizeService optimizeService;\n+  private IdentityService identityService;\n+  private RuntimeService runtimeService;\n+  private AuthorizationService authorizationService;\n+  private ManagementService managementService;\n+\n+  @Before\n+  public void init() {\n+    ProcessEngineConfigurationImpl config =\n+      engineRule.getProcessEngineConfiguration();\n+    optimizeService = config.getOptimizeService();\n+    identityService = engineRule.getIdentityService();\n+    runtimeService = engineRule.getRuntimeService();\n+    authorizationService = engineRule.getAuthorizationService();\n+    managementService = engineRule.getManagementService();\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    for (User user : identityService.createUserQuery().list()) {\n+      identityService.deleteUser(user.getId());\n+    }\n+    for (Group group : identityService.createGroupQuery().list()) {\n+      identityService.deleteGroup(group.getId());\n+    }\n+    for (Authorization authorization : authorizationService.createAuthorizationQuery().list()) {\n+      authorizationService.deleteAuthorization(authorization.getId());\n+    }\n+    ClockUtil.reset();\n+  }\n+\n+  @Test\n+  public void getCompletedHistoricIncidents() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(pastDate(), null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+    assertThatInstanceHasAllImportantInformation(completedIncidents.get(0));\n+  }\n+\n+  @Test\n+  public void fishedAfterParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(now, null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+  }\n+\n+  @Test\n+  public void fishedAtParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(null, now, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+    assertThat(completedIncidents.get(0).getProcessInstanceId(), is(processInstance.getId()));\n+  }\n+\n+  @Test\n+  public void fishedAfterAndFinishedAtParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(now, now, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(0));\n+  }\n+\n+  @Test\n+  public void maxResultsParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    for (int i = 0; i < 5; i++) {\n+      final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+      retryAndSucceed(processInstance);\n+    }\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(pastDate(), null, 3);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(3));\n+  }\n+\n+  @Test\n+  public void resultIsSortedByEndTime() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    Date nowPlus1Second = new Date(now.getTime() + 1000L);\n+    ClockUtil.setCurrentTime(nowPlus1Second);\n+    ProcessInstance processInstance1 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance1);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+    Date nowPlus4Seconds = new Date(nowPlus2Seconds.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus4Seconds);\n+    final ProcessInstance processInstance3 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance3);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(now, null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(3));\n+    assertThat(completedIncidents.get(0).getProcessInstanceId(), is(processInstance1.getId()));\n+    assertThat(completedIncidents.get(1).getProcessInstanceId(), is(processInstance2.getId()));\n+    assertThat(completedIncidents.get(2).getProcessInstanceId(), is(processInstance3.getId()));\n+  }\n+\n+  @Test\n+  public void fetchOnlyCompletedIncidents() {", "originalCommit": "e626ce93b1307aad2b18821b4f9e94fa511448cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwNDc4NQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484504785", "bodyText": "I recommend to assert the process instance id here as the test would otherwise also succeed if finishedAfter was implemented as = or <=.", "author": "ThorbenLindhauer", "createdAt": "2020-09-07T15:57:39Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/api/optimize/GetCompletedHistoricIncidentsForOptimizeTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.api.optimize;\n+\n+import org.camunda.bpm.engine.AuthorizationService;\n+import org.camunda.bpm.engine.IdentityService;\n+import org.camunda.bpm.engine.ManagementService;\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.RuntimeService;\n+import org.camunda.bpm.engine.authorization.Authorization;\n+import org.camunda.bpm.engine.identity.Group;\n+import org.camunda.bpm.engine.identity.User;\n+import org.camunda.bpm.engine.impl.OptimizeService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.HistoricIncidentEntity;\n+import org.camunda.bpm.engine.impl.util.ClockUtil;\n+import org.camunda.bpm.engine.runtime.ProcessInstance;\n+import org.camunda.bpm.engine.test.ProcessEngineRule;\n+import org.camunda.bpm.engine.test.RequiredHistoryLevel;\n+import org.camunda.bpm.engine.test.api.runtime.FailingDelegate;\n+import org.camunda.bpm.engine.test.util.ProcessEngineTestRule;\n+import org.camunda.bpm.engine.test.util.ProvidedProcessEngineRule;\n+import org.camunda.bpm.model.bpmn.Bpmn;\n+import org.camunda.bpm.model.bpmn.BpmnModelInstance;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+\n+import java.util.Date;\n+import java.util.List;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+\n+@RequiredHistoryLevel(ProcessEngineConfiguration.HISTORY_FULL)\n+public class GetCompletedHistoricIncidentsForOptimizeTest {\n+\n+  private static final String PROCESS_DEFINITION_KEY = \"oneFailingServiceTaskProcess\";\n+  private static final BpmnModelInstance FAILING_SERVICE_TASK_MODEL =\n+    Bpmn.createExecutableProcess(PROCESS_DEFINITION_KEY)\n+      .startEvent(\"start\")\n+      .serviceTask(\"task\")\n+        .camundaAsyncBefore()\n+        .camundaClass(FailingDelegate.class.getName())\n+      .endEvent(\"end\")\n+      .done();\n+\n+  public ProcessEngineRule engineRule = new ProvidedProcessEngineRule();\n+  protected ProcessEngineTestRule testHelper = new ProcessEngineTestRule(engineRule);\n+\n+  @Rule\n+  public RuleChain ruleChain = RuleChain.outerRule(engineRule).around(testHelper);\n+\n+  private OptimizeService optimizeService;\n+  private IdentityService identityService;\n+  private RuntimeService runtimeService;\n+  private AuthorizationService authorizationService;\n+  private ManagementService managementService;\n+\n+  @Before\n+  public void init() {\n+    ProcessEngineConfigurationImpl config =\n+      engineRule.getProcessEngineConfiguration();\n+    optimizeService = config.getOptimizeService();\n+    identityService = engineRule.getIdentityService();\n+    runtimeService = engineRule.getRuntimeService();\n+    authorizationService = engineRule.getAuthorizationService();\n+    managementService = engineRule.getManagementService();\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    for (User user : identityService.createUserQuery().list()) {\n+      identityService.deleteUser(user.getId());\n+    }\n+    for (Group group : identityService.createGroupQuery().list()) {\n+      identityService.deleteGroup(group.getId());\n+    }\n+    for (Authorization authorization : authorizationService.createAuthorizationQuery().list()) {\n+      authorizationService.deleteAuthorization(authorization.getId());\n+    }\n+    ClockUtil.reset();\n+  }\n+\n+  @Test\n+  public void getCompletedHistoricIncidents() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(pastDate(), null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+    assertThatInstanceHasAllImportantInformation(completedIncidents.get(0));\n+  }\n+\n+  @Test\n+  public void fishedAfterParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(now, null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));", "originalCommit": "e626ce93b1307aad2b18821b4f9e94fa511448cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwNTAyMA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484505020", "bodyText": "This is hard to read. Can we structure this block a bit better with some new lines?", "author": "ThorbenLindhauer", "createdAt": "2020-09-07T15:58:19Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/api/optimize/GetCompletedHistoricIncidentsForOptimizeTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.api.optimize;\n+\n+import org.camunda.bpm.engine.AuthorizationService;\n+import org.camunda.bpm.engine.IdentityService;\n+import org.camunda.bpm.engine.ManagementService;\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.RuntimeService;\n+import org.camunda.bpm.engine.authorization.Authorization;\n+import org.camunda.bpm.engine.identity.Group;\n+import org.camunda.bpm.engine.identity.User;\n+import org.camunda.bpm.engine.impl.OptimizeService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.HistoricIncidentEntity;\n+import org.camunda.bpm.engine.impl.util.ClockUtil;\n+import org.camunda.bpm.engine.runtime.ProcessInstance;\n+import org.camunda.bpm.engine.test.ProcessEngineRule;\n+import org.camunda.bpm.engine.test.RequiredHistoryLevel;\n+import org.camunda.bpm.engine.test.api.runtime.FailingDelegate;\n+import org.camunda.bpm.engine.test.util.ProcessEngineTestRule;\n+import org.camunda.bpm.engine.test.util.ProvidedProcessEngineRule;\n+import org.camunda.bpm.model.bpmn.Bpmn;\n+import org.camunda.bpm.model.bpmn.BpmnModelInstance;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+\n+import java.util.Date;\n+import java.util.List;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+\n+@RequiredHistoryLevel(ProcessEngineConfiguration.HISTORY_FULL)\n+public class GetCompletedHistoricIncidentsForOptimizeTest {\n+\n+  private static final String PROCESS_DEFINITION_KEY = \"oneFailingServiceTaskProcess\";\n+  private static final BpmnModelInstance FAILING_SERVICE_TASK_MODEL =\n+    Bpmn.createExecutableProcess(PROCESS_DEFINITION_KEY)\n+      .startEvent(\"start\")\n+      .serviceTask(\"task\")\n+        .camundaAsyncBefore()\n+        .camundaClass(FailingDelegate.class.getName())\n+      .endEvent(\"end\")\n+      .done();\n+\n+  public ProcessEngineRule engineRule = new ProvidedProcessEngineRule();\n+  protected ProcessEngineTestRule testHelper = new ProcessEngineTestRule(engineRule);\n+\n+  @Rule\n+  public RuleChain ruleChain = RuleChain.outerRule(engineRule).around(testHelper);\n+\n+  private OptimizeService optimizeService;\n+  private IdentityService identityService;\n+  private RuntimeService runtimeService;\n+  private AuthorizationService authorizationService;\n+  private ManagementService managementService;\n+\n+  @Before\n+  public void init() {\n+    ProcessEngineConfigurationImpl config =\n+      engineRule.getProcessEngineConfiguration();\n+    optimizeService = config.getOptimizeService();\n+    identityService = engineRule.getIdentityService();\n+    runtimeService = engineRule.getRuntimeService();\n+    authorizationService = engineRule.getAuthorizationService();\n+    managementService = engineRule.getManagementService();\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    for (User user : identityService.createUserQuery().list()) {\n+      identityService.deleteUser(user.getId());\n+    }\n+    for (Group group : identityService.createGroupQuery().list()) {\n+      identityService.deleteGroup(group.getId());\n+    }\n+    for (Authorization authorization : authorizationService.createAuthorizationQuery().list()) {\n+      authorizationService.deleteAuthorization(authorization.getId());\n+    }\n+    ClockUtil.reset();\n+  }\n+\n+  @Test\n+  public void getCompletedHistoricIncidents() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(pastDate(), null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+    assertThatInstanceHasAllImportantInformation(completedIncidents.get(0));\n+  }\n+\n+  @Test\n+  public void fishedAfterParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(now, null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+  }\n+\n+  @Test\n+  public void fishedAtParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(null, now, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+    assertThat(completedIncidents.get(0).getProcessInstanceId(), is(processInstance.getId()));\n+  }\n+\n+  @Test\n+  public void fishedAfterAndFinishedAtParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(now, now, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(0));\n+  }\n+\n+  @Test\n+  public void maxResultsParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    for (int i = 0; i < 5; i++) {\n+      final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+      retryAndSucceed(processInstance);\n+    }\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(pastDate(), null, 3);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(3));\n+  }\n+\n+  @Test\n+  public void resultIsSortedByEndTime() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    Date nowPlus1Second = new Date(now.getTime() + 1000L);\n+    ClockUtil.setCurrentTime(nowPlus1Second);\n+    ProcessInstance processInstance1 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance1);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+    Date nowPlus4Seconds = new Date(nowPlus2Seconds.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus4Seconds);\n+    final ProcessInstance processInstance3 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance3);", "originalCommit": "e626ce93b1307aad2b18821b4f9e94fa511448cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwNTM4NQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484505385", "bodyText": "Let's remove all the user-, group- and authorization-related code from this class as it is not needed.", "author": "ThorbenLindhauer", "createdAt": "2020-09-07T15:59:20Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/api/optimize/GetCompletedHistoricIncidentsForOptimizeTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.api.optimize;\n+\n+import org.camunda.bpm.engine.AuthorizationService;\n+import org.camunda.bpm.engine.IdentityService;\n+import org.camunda.bpm.engine.ManagementService;\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.RuntimeService;\n+import org.camunda.bpm.engine.authorization.Authorization;\n+import org.camunda.bpm.engine.identity.Group;\n+import org.camunda.bpm.engine.identity.User;\n+import org.camunda.bpm.engine.impl.OptimizeService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.HistoricIncidentEntity;\n+import org.camunda.bpm.engine.impl.util.ClockUtil;\n+import org.camunda.bpm.engine.runtime.ProcessInstance;\n+import org.camunda.bpm.engine.test.ProcessEngineRule;\n+import org.camunda.bpm.engine.test.RequiredHistoryLevel;\n+import org.camunda.bpm.engine.test.api.runtime.FailingDelegate;\n+import org.camunda.bpm.engine.test.util.ProcessEngineTestRule;\n+import org.camunda.bpm.engine.test.util.ProvidedProcessEngineRule;\n+import org.camunda.bpm.model.bpmn.Bpmn;\n+import org.camunda.bpm.model.bpmn.BpmnModelInstance;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+\n+import java.util.Date;\n+import java.util.List;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+\n+@RequiredHistoryLevel(ProcessEngineConfiguration.HISTORY_FULL)\n+public class GetCompletedHistoricIncidentsForOptimizeTest {\n+\n+  private static final String PROCESS_DEFINITION_KEY = \"oneFailingServiceTaskProcess\";\n+  private static final BpmnModelInstance FAILING_SERVICE_TASK_MODEL =\n+    Bpmn.createExecutableProcess(PROCESS_DEFINITION_KEY)\n+      .startEvent(\"start\")\n+      .serviceTask(\"task\")\n+        .camundaAsyncBefore()\n+        .camundaClass(FailingDelegate.class.getName())\n+      .endEvent(\"end\")\n+      .done();\n+\n+  public ProcessEngineRule engineRule = new ProvidedProcessEngineRule();\n+  protected ProcessEngineTestRule testHelper = new ProcessEngineTestRule(engineRule);\n+\n+  @Rule\n+  public RuleChain ruleChain = RuleChain.outerRule(engineRule).around(testHelper);\n+\n+  private OptimizeService optimizeService;\n+  private IdentityService identityService;\n+  private RuntimeService runtimeService;\n+  private AuthorizationService authorizationService;\n+  private ManagementService managementService;\n+\n+  @Before\n+  public void init() {\n+    ProcessEngineConfigurationImpl config =\n+      engineRule.getProcessEngineConfiguration();\n+    optimizeService = config.getOptimizeService();\n+    identityService = engineRule.getIdentityService();\n+    runtimeService = engineRule.getRuntimeService();\n+    authorizationService = engineRule.getAuthorizationService();\n+    managementService = engineRule.getManagementService();\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    for (User user : identityService.createUserQuery().list()) {\n+      identityService.deleteUser(user.getId());\n+    }\n+    for (Group group : identityService.createGroupQuery().list()) {\n+      identityService.deleteGroup(group.getId());\n+    }\n+    for (Authorization authorization : authorizationService.createAuthorizationQuery().list()) {\n+      authorizationService.deleteAuthorization(authorization.getId());\n+    }", "originalCommit": "e626ce93b1307aad2b18821b4f9e94fa511448cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwNDYxNw==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r485604617", "bodyText": "Ooops, I think I tend to get sloppy when it comes to tests \ud83d\ude05", "author": "JoHeinem", "createdAt": "2020-09-09T13:19:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwNTM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwNTk2OA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484505968", "bodyText": "Most of the review hints for GetCompletedHistoricIncidentsForOptimizeTest  apply here as well. Please make any changes in both classes.", "author": "ThorbenLindhauer", "createdAt": "2020-09-07T16:01:07Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/api/optimize/GetOpenHistoricIncidentsForOptimizeTest.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.api.optimize;\n+\n+import org.camunda.bpm.engine.AuthorizationService;\n+import org.camunda.bpm.engine.IdentityService;\n+import org.camunda.bpm.engine.ManagementService;\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.RuntimeService;\n+import org.camunda.bpm.engine.authorization.Authorization;\n+import org.camunda.bpm.engine.identity.Group;\n+import org.camunda.bpm.engine.identity.User;\n+import org.camunda.bpm.engine.impl.OptimizeService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.HistoricIncidentEntity;\n+import org.camunda.bpm.engine.impl.util.ClockUtil;\n+import org.camunda.bpm.engine.runtime.ProcessInstance;\n+import org.camunda.bpm.engine.test.ProcessEngineRule;\n+import org.camunda.bpm.engine.test.RequiredHistoryLevel;\n+import org.camunda.bpm.engine.test.api.runtime.FailingDelegate;\n+import org.camunda.bpm.engine.test.util.ProcessEngineTestRule;\n+import org.camunda.bpm.engine.test.util.ProvidedProcessEngineRule;\n+import org.camunda.bpm.model.bpmn.Bpmn;\n+import org.camunda.bpm.model.bpmn.BpmnModelInstance;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+\n+import java.util.Date;\n+import java.util.List;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+\n+@RequiredHistoryLevel(ProcessEngineConfiguration.HISTORY_FULL)\n+public class GetOpenHistoricIncidentsForOptimizeTest {", "originalCommit": "e626ce93b1307aad2b18821b4f9e94fa511448cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5312bc6997bf3ec0811b419e4864416c01e3b3b8", "url": "https://github.com/camunda/camunda-bpm-platform/commit/5312bc6997bf3ec0811b419e4864416c01e3b3b8", "message": "implement review hints", "committedDate": "2020-09-09T13:25:50Z", "type": "commit"}]}