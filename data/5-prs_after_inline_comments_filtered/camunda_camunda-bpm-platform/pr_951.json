{"pr_number": 951, "pr_title": "CAM-12071: add cockroachdb support", "pr_createdAt": "2020-09-02T08:49:33Z", "pr_url": "https://github.com/camunda/camunda-bpm-platform/pull/951", "timeline": [{"oid": "10a9b256625d07aa261ebb126536f4021a892a5e", "url": "https://github.com/camunda/camunda-bpm-platform/commit/10a9b256625d07aa261ebb126536f4021a892a5e", "message": "feat(engine): dissable pessimistic locks\n\n* Ensure process engine bootstrap is retriable;\n* Add CRDB Retries tests;\n* Add (CRDB) Serializable Transaction Isolation level tests;\n* Fix failing tests (due to disabled pessimistic locks on CRDB)\n* Refactor runtime code to get it review ready.\n\nRelated to CAM-12232, CAM-12253", "committedDate": "2020-09-02T14:32:16Z", "type": "forcePushed"}, {"oid": "acfc45ca38c520e05f650cc559f5fb23c2526884", "url": "https://github.com/camunda/camunda-bpm-platform/commit/acfc45ca38c520e05f650cc559f5fb23c2526884", "message": "WIP: adjust exteranlly managed transaction integrations", "committedDate": "2020-09-14T08:23:39Z", "type": "forcePushed"}, {"oid": "b1b3731998f13d70c126d0ec08305143fc8288c0", "url": "https://github.com/camunda/camunda-bpm-platform/commit/b1b3731998f13d70c126d0ec08305143fc8288c0", "message": "WIP: adjust exteranlly managed transaction integrations", "committedDate": "2020-09-15T19:03:18Z", "type": "forcePushed"}, {"oid": "bd575eb5def7519f643752f3a31e2a6e9ebad2c8", "url": "https://github.com/camunda/camunda-bpm-platform/commit/bd575eb5def7519f643752f3a31e2a6e9ebad2c8", "message": "feat(spring): adjust exteranlly managed transaction integrations\n\nRelated to CAM-12394", "committedDate": "2020-09-17T15:53:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU1OTM2NA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492559364", "bodyText": "Please be a bit clearer here: The error occurs during job execution, which means that the jobs may be acquired multiple times before they succeed. Please also create a ticket that documents this problem and link to it.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T08:28:50Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/api/mgmt/metrics/JobExecutorMetricsTest.java", "diffHunk": "@@ -79,7 +79,18 @@ public void testJobAcquisitionMetricReporting() {\n \n     long acquiredJobs = managementService.createMetricsQuery()\n         .name(Metrics.JOB_ACQUIRED_SUCCESS).sum();\n-    assertEquals(3, acquiredJobs);\n+    if (testRule.isOptimisticLockingExceptionSuppressible()) {\n+      assertEquals(3, acquiredJobs);\n+    } else {\n+      // on CRDB there are additional job failures due to a self-referencing foreign\n+      // key constraint on the ACT_RU_EXECUTION table which causes a TransactionRetryError,\n+      // leading to a larger number of job acquisitions", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY5MDI0NQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492690245", "bodyText": "Clarified and created CAM-12480 for the issue. The issue is also referenced in the comment.", "author": "koevskinikola", "createdAt": "2020-09-22T12:24:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU1OTM2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU2MDU1OQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492560559", "bodyText": "Please include the reason why in this comment.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T08:30:19Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/api/mgmt/metrics/JobExecutorMetricsTest.java", "diffHunk": "@@ -125,7 +136,14 @@ public void testCompetingJobAcquisitionMetricReporting() {\n \n     long acquiredJobsFailure = managementService.createMetricsQuery()\n         .name(Metrics.JOB_ACQUIRED_FAILURE).sum();\n-    assertEquals(3, acquiredJobsFailure);\n+    \n+    if (testRule.isOptimisticLockingExceptionSuppressible()) {\n+      assertEquals(3, acquiredJobsFailure);\n+    } else {\n+      // in the case of CRDB, the acquisitionCmd could not tell the job executor\n+      // how many jobs it unsuccessfully attempted to acquire", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU2MjYxOA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492562618", "bodyText": "I recommend to create a second method in test rule called usesCockroachDB that does exactly the same thing. It makes this line of code more readable, because here it has nothing to do with the possibility to suppress OLEs.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T08:33:42Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/api/mgmt/metrics/JobExecutorMetricsTest.java", "diffHunk": "@@ -147,23 +165,33 @@ public void testJobExecutionMetricReporting() {\n     }\n \n     // when\n-    testRule.waitForJobExecutorToProcessAllJobs(5000);\n+    // extend waiting time for CRDB since it takes longer to process all the jobs there\n+    // see CAM-12239 for more details\n+    long maxMillisToWait = testRule.isOptimisticLockingExceptionSuppressible()? 5000L : 30000L;", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcwMTkyNQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492701925", "bodyText": "This test is still flaky, even though the wait time was increased. As we discussed before, I would exclude it since we already have other tests that cover the JobExecution metrics. The test is referenced in CAM-12461.", "author": "koevskinikola", "createdAt": "2020-09-22T12:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU2MjYxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU2NjQ1NQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492566455", "bodyText": "Same here, a method usesCockroachDB is much clearer. Please check all occurrences.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T08:40:03Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/api/runtime/migration/batch/BatchMigrationTest.java", "diffHunk": "@@ -396,7 +396,10 @@ public void testMigrationJobsExecutionByJobExecutorWithAuthorizationEnabledAndTe\n       Batch batch = helper.migrateProcessInstancesAsyncForTenant(10, \"someTenantId\");\n       helper.completeSeedJobs(batch);\n \n-      testRule.waitForJobExecutorToProcessAllJobs();\n+      // extend waiting time for CRDB since it takes longer to process all the jobs there\n+      // see CAM-12239 for more details\n+      long maxMillisToWait = testRule.isOptimisticLockingExceptionSuppressible()? 10000L : 30000L;", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU2ODI2NA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492568264", "bodyText": "Why is this necessary?", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T08:43:05Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/cockroachdb/CockroachDBRetriesTest.java", "diffHunk": "@@ -0,0 +1,505 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.cockroachdb;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.camunda.bpm.engine.CrdbTransactionRetryException;\n+import org.camunda.bpm.engine.ManagementService;\n+import org.camunda.bpm.engine.ProcessEngine;\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.ProcessEngines;\n+import org.camunda.bpm.engine.RuntimeService;\n+import org.camunda.bpm.engine.externaltask.ExternalTask;\n+import org.camunda.bpm.engine.externaltask.LockedExternalTask;\n+import org.camunda.bpm.engine.impl.BootstrapEngineCommand;\n+import org.camunda.bpm.engine.impl.ProcessEngineImpl;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.cmd.FetchExternalTasksCmd;\n+import org.camunda.bpm.engine.impl.cmd.SetJobDefinitionPriorityCmd;\n+import org.camunda.bpm.engine.impl.cmd.SuspendJobDefinitionCmd;\n+import org.camunda.bpm.engine.impl.db.sql.DbSqlSessionFactory;\n+import org.camunda.bpm.engine.impl.externaltask.TopicFetchInstruction;\n+import org.camunda.bpm.engine.impl.interceptor.Command;\n+import org.camunda.bpm.engine.impl.interceptor.CommandContext;\n+import org.camunda.bpm.engine.impl.management.UpdateJobDefinitionSuspensionStateBuilderImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.JobEntity;\n+import org.camunda.bpm.engine.impl.test.RequiredDatabase;\n+import org.camunda.bpm.engine.management.JobDefinition;\n+import org.camunda.bpm.engine.runtime.Job;\n+import org.camunda.bpm.engine.test.Deployment;\n+import org.camunda.bpm.engine.test.concurrency.CompetingExternalTaskFetchingTest;\n+import org.camunda.bpm.engine.test.concurrency.CompetingJobAcquisitionTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrencyTestHelper;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentJobExecutorTest;\n+import org.camunda.bpm.engine.test.jobexecutor.ControllableJobExecutor;\n+import org.camunda.bpm.engine.test.jobexecutor.RecordingAcquireJobsRunnable.RecordedWaitEvent;\n+import org.camunda.bpm.engine.test.util.ProcessEngineBootstrapRule;\n+import org.camunda.bpm.engine.test.util.ProcessEngineTestRule;\n+import org.camunda.bpm.engine.test.util.ProvidedProcessEngineRule;\n+import org.camunda.bpm.model.bpmn.Bpmn;\n+import org.camunda.bpm.model.bpmn.BpmnModelInstance;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+\n+@RequiredDatabase(includes = DbSqlSessionFactory.CRDB)\n+public class CockroachDBRetriesTest extends ConcurrencyTestHelper {\n+\n+  protected static final int DEFAULT_NUM_JOBS_TO_ACQUIRE = 3;\n+  protected static final int COMMAND_RETRIES = 3;\n+  protected static final String PROCESS_ENGINE_NAME = \"failingProcessEngine\";\n+  protected static final BpmnModelInstance SIMPLE_ASYNC_PROCESS = Bpmn.createExecutableProcess(\"simpleAsyncProcess\")\n+      .startEvent()\n+      .serviceTask()\n+      .camundaExpression(\"${true}\")\n+      .camundaAsyncBefore()\n+      .endEvent()\n+      .done();\n+  \n+  @ClassRule\n+  public static ProcessEngineBootstrapRule bootstrapRule = new ProcessEngineBootstrapRule(\n+      c -> c.setCommandRetries(COMMAND_RETRIES));\n+  protected ProvidedProcessEngineRule engineRule = new ProvidedProcessEngineRule(bootstrapRule);\n+  protected ProcessEngineTestRule testRule = new ProcessEngineTestRule(engineRule);\n+\n+  @Rule\n+  public RuleChain ruleChain = RuleChain.outerRule(engineRule).around(testRule);\n+\n+  @Rule\n+  public ExpectedException thrown = ExpectedException.none();\n+\n+  protected ControllableJobExecutor jobExecutor1;\n+  protected ControllableJobExecutor jobExecutor2;\n+\n+  protected ThreadControl acquisitionThread1;\n+  protected ThreadControl acquisitionThread2;\n+\n+  protected RuntimeService runtimeService;\n+  protected ManagementService managementService;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    processEngineConfiguration = engineRule.getProcessEngineConfiguration();\n+    runtimeService = engineRule.getRuntimeService();\n+    managementService = engineRule.getManagementService();\n+\n+    // two job executors with the default settings\n+    jobExecutor1 = new ControllableJobExecutor((ProcessEngineImpl) engineRule.getProcessEngine());\n+    jobExecutor1.setMaxJobsPerAcquisition(DEFAULT_NUM_JOBS_TO_ACQUIRE);\n+    acquisitionThread1 = jobExecutor1.getAcquisitionThreadControl();\n+    processEngineConfiguration.setJobExecutor(jobExecutor1);\n+\n+    jobExecutor2 = new ControllableJobExecutor((ProcessEngineImpl) engineRule.getProcessEngine());\n+    jobExecutor2.setMaxJobsPerAcquisition(DEFAULT_NUM_JOBS_TO_ACQUIRE);\n+    acquisitionThread2 = jobExecutor2.getAcquisitionThreadControl();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    jobExecutor1.shutdown();\n+    jobExecutor2.shutdown();\n+    closeDownProcessEngine();\n+  }\n+  \n+  /**\n+   * See {@link CompetingJobAcquisitionTest#testCompetingJobAcquisitions} for the test\n+   * case without retries\n+   */\n+  @Test\n+  @Deployment(resources = \"org/camunda/bpm/engine/test/jobexecutor/simpleAsyncProcess.bpmn20.xml\")\n+  public void shouldRetryJobAcquisition() {\n+\n+    // given\n+    int numJobs = DEFAULT_NUM_JOBS_TO_ACQUIRE + 1;\n+    for (int i = 0; i < numJobs; i++) {\n+      engineRule.getRuntimeService().startProcessInstanceByKey(\"simpleAsyncProcess\").getId();\n+    }\n+\n+    jobExecutor1.start();\n+    jobExecutor2.start();\n+    // both acquisition threads wait before acquiring something\n+    acquisitionThread1.waitForSync();\n+    acquisitionThread2.waitForSync();\n+    \n+    // both threads run the job acquisition query and should get overlapping results (3 out of 4 jobs)\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+    acquisitionThread2.makeContinueAndWaitForSync();\n+    \n+    // thread1 flushes and commits first (success)\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+    \n+    // when\n+    // acquisition fails => retry interceptor kicks in and retries command => waiting again before acquisition\n+    acquisitionThread2.makeContinueAndWaitForSync();\n+\n+    // thread2 immediately acquires again and commits\n+    acquisitionThread2.makeContinueAndWaitForSync();\n+    acquisitionThread2.makeContinueAndWaitForSync();\n+    \n+    // then \n+    // all jobs have been executed\n+    long currentJobs = engineRule.getManagementService().createJobQuery().active().count();\n+    assertThat(currentJobs).isEqualTo(0);\n+    \n+    // and thread2 has no reported failure\n+    assertThat(acquisitionThread2.getException()).isNull();\n+    \n+    List<RecordedWaitEvent> jobAcquisition2WaitEvents = jobExecutor2.getAcquireJobsRunnable().getWaitEvents();\n+    \n+    // and only one cycle of job acquisition was made (the wait event is from after the acquisition finished)\n+    assertThat(jobAcquisition2WaitEvents).hasSize(1); \n+    Exception acquisitionException = jobAcquisition2WaitEvents.get(0).getAcquisitionException();\n+    \n+    // and the exception never bubbled up to the job executor (i.e. the retry was transparent)\n+    assertThat(acquisitionException).isNull(); \n+  }\n+  \n+  /**\n+   * See {@link CompetingExternalTaskFetchingTest#testCompetingExternalTaskFetching()}\n+   * for the test case without retries.\n+   */\n+  @Test\n+  @Deployment(resources = \"org/camunda/bpm/engine/test/concurrency/CompetingExternalTaskFetchingTest.testCompetingExternalTaskFetching.bpmn20.xml\")\n+  public void shouldRetryExternalTaskFetchAndLock() {\n+    // given\n+    RuntimeService runtimeService = engineRule.getRuntimeService();\n+    \n+    int numTasksToFetch = 3;\n+    int numExternalTasks = numTasksToFetch + 1;\n+    \n+    for (int i = 0; i < numExternalTasks; i++) {\n+      runtimeService.startProcessInstanceByKey(\"oneExternalTaskProcess\");\n+    }\n+\n+    ThreadControl thread1 = executeControllableCommand(new ControlledFetchAndLockCommand(numTasksToFetch, \"thread1\", \"externalTaskTopic\"));\n+    ThreadControl thread2 = executeControllableCommand(new ControlledFetchAndLockCommand(numTasksToFetch, \"thread2\", \"externalTaskTopic\"));\n+\n+    // thread1 and thread2 begin their transactions and fetch tasks\n+    thread1.waitForSync();\n+    thread2.waitForSync();\n+    thread1.makeContinueAndWaitForSync();\n+    thread2.makeContinueAndWaitForSync();\n+    \n+    // thread1 commits\n+    thread1.waitUntilDone();\n+\n+    // when\n+    // thread2 flushes and fails => leads to retry\n+    thread2.waitUntilDone(true);\n+    \n+    // then\n+    List<ExternalTask> tasks = engineRule.getExternalTaskService().createExternalTaskQuery().list();\n+    List<ExternalTask> thread1Tasks = tasks.stream()\n+        .filter(t -> \"thread1\".equals(t.getWorkerId())).collect(Collectors.toList());\n+    List<ExternalTask> thread2Tasks = tasks.stream()\n+        .filter(t -> \"thread2\".equals(t.getWorkerId())).collect(Collectors.toList());\n+    \n+    assertThat(tasks).hasSize(numExternalTasks);\n+    assertThat(thread1Tasks).hasSize(numTasksToFetch);\n+    assertThat(thread2Tasks).hasSize(numExternalTasks - numTasksToFetch);\n+  }\n+\n+  /**\n+   * See {@link ConcurrentJobExecutorTest#testCompletingUpdateJobDefinitionPriorityDuringExecution()}\n+   * for the test case without retries.\n+   */\n+  @Test\n+  @Deployment(resources = \"org/camunda/bpm/engine/test/jobexecutor/simpleAsyncProcess.bpmn20.xml\")\n+  public void shouldRetryJobExecutionTxAfterJobPriorityOLE() {\n+    // given\n+    // several running process instances with an async continuation\n+    int numJobs = DEFAULT_NUM_JOBS_TO_ACQUIRE + 1;\n+    for (int i = 0; i < numJobs; i++) {\n+      engineRule.getRuntimeService().startProcessInstanceByKey(\"simpleAsyncProcess\");\n+    }\n+    // and a job definition\n+    JobDefinition jobDefinition = managementService.createJobDefinitionQuery().singleResult();\n+\n+    jobExecutor1.start();\n+    acquisitionThread1.waitForSync();\n+    ThreadControl jobPriorityThread = executeControllableCommand(new ControllableJobDefinitionPriorityCommand(jobDefinition.getId(), 42L, true));\n+    jobPriorityThread.waitForSync();\n+\n+    // the acquisition thread acquires the jobs\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+\n+    // the job priority thread updates the job priority and flushes the change\n+    jobPriorityThread.makeContinue();\n+    jobPriorityThread.waitUntilDone(true);\n+\n+    // when\n+    // the job acquisition thread attempts to flush the job locks it fails\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+\n+    // thread2 immediately acquires again and commits\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+    acquisitionThread1.ignoreFutureSyncs();\n+\n+    // then\n+    // the jobs have been executed and only one is remaining\n+    Job currentJob = engineRule.getManagementService().createJobQuery().active().singleResult();\n+    assertThat(currentJob).isNotNull();\n+    // the job priority has changed\n+    assertEquals(42, currentJob.getPriority());\n+    // and thread2 has no reported failure\n+    assertThat(acquisitionThread1.getException()).isNull();\n+  }\n+\n+  @Test\n+  @Deployment(resources = \"org/camunda/bpm/engine/test/jobexecutor/simpleAsyncProcess.bpmn20.xml\")\n+  public void shouldRetryAcquisitionJobTxAfterJobSuspensionOLE() {\n+    // given\n+    String processDefinitionKey = \"simpleAsyncProcess\";\n+    // a running process instance with an async continuation\n+    runtimeService.startProcessInstanceByKey(processDefinitionKey);\n+    // a waiting acquisition and a waiting suspension\n+    jobExecutor1.start();\n+    acquisitionThread1.reportInterrupts();\n+    acquisitionThread1.waitForSync();\n+    ThreadControl jobSuspensionThread = executeControllableCommand(new ControllableJobSuspensionCommand(processDefinitionKey));\n+    jobSuspensionThread.reportInterrupts();\n+    jobSuspensionThread.waitForSync();\n+\n+    // the acquisition thread acquires the jobs\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+\n+    // when the job suspension thread completes the suspension\n+    jobSuspensionThread.makeContinue();\n+    jobSuspensionThread.waitUntilDone(true);\n+\n+    // then\n+    // the acquisition thread fails to flush the job locks\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+\n+    // the acquisition thread immediately acquires again and commits\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+\n+    // the suspension state doesn't fail at all\n+    assertNull(jobSuspensionThread.getException());\n+    // and the acquisition will not fail with optimistic locking since it was retried\n+    assertNull(acquisitionThread1.getException());\n+    // and no jobs were executed since they are suspended\n+    long jobCount = managementService.createJobQuery().suspended().count();\n+    assertThat(jobCount).isOne();\n+  }\n+\n+  @Test\n+  public void shouldRethrowBootstrapEngineOleWhenRetriesAreExhausted() {\n+    // given\n+    // a bootstrap command failing with a CrdbTransactionRetryException\n+    FailingProcessEngineBootstrapCommand bootstrapCommand = new FailingProcessEngineBootstrapCommand();\n+    ProcessEngineConfigurationImpl processEngineConfiguration = ((ProcessEngineConfigurationImpl)\n+        ProcessEngineConfiguration\n+            .createProcessEngineConfigurationFromResource(\"camunda.cfg.xml\"))\n+        .setCommandRetries(COMMAND_RETRIES)\n+        .setProcessEngineName(PROCESS_ENGINE_NAME);\n+    processEngineConfiguration.setProcessEngineBootstrapCommand(bootstrapCommand);\n+\n+    // then\n+    // a CrdbTransactionRetryException is re-thrown to the caller\n+    thrown.expect(CrdbTransactionRetryException.class);\n+\n+    // when\n+    processEngineConfiguration.buildProcessEngine();\n+\n+    // since the Command retries were exausted\n+    assertThat(bootstrapCommand.getTries()).isEqualTo(4);\n+  }\n+\n+  @Test\n+  public void shouldNotRetryCommandByDefault() {\n+    // given\n+    // a failing command\n+    ControllableFailingCommand failingCommand = new ControllableFailingCommand();\n+    ThreadControl failingCommandThread = executeControllableCommand(failingCommand);\n+    failingCommandThread.reportInterrupts();\n+    failingCommandThread.waitForSync();\n+\n+    // when\n+    // the command is executed and fails\n+    failingCommandThread.waitUntilDone(true);\n+\n+    // then\n+    // the exception is thrown to the called\n+    assertThat(failingCommandThread.getException()).isInstanceOf(CrdbTransactionRetryException.class);\n+    // and the command is only tried once\n+    assertThat(failingCommand.getTries()).isOne();\n+  }\n+\n+  protected static class ControlledFetchAndLockCommand extends ControllableCommand<List<LockedExternalTask>> {\n+\n+    protected FetchExternalTasksCmd wrappedCmd;\n+\n+    public ControlledFetchAndLockCommand(int numTasks, String workerId, String topic) {\n+      Map<String, TopicFetchInstruction> instructions = new HashMap<>();\n+\n+      TopicFetchInstruction instruction = new TopicFetchInstruction(topic, 10000L);\n+      instructions.put(topic, instruction);\n+\n+      this.wrappedCmd = new FetchExternalTasksCmd(workerId, numTasks, instructions);\n+    }\n+\n+    @Override\n+    public List<LockedExternalTask> execute(CommandContext commandContext) {\n+      monitor.sync();\n+\n+      List<LockedExternalTask> tasks = wrappedCmd.execute(commandContext);\n+\n+      monitor.sync();\n+\n+      return tasks;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+      return wrappedCmd.isRetryable();\n+    }\n+  }\n+\n+  protected static class FailingProcessEngineBootstrapCommand  extends BootstrapEngineCommand {\n+\n+    protected int tries;\n+\n+    public FailingProcessEngineBootstrapCommand() {\n+      this.tries = 0;\n+    }\n+\n+    @Override\n+    public Void execute(CommandContext commandContext) {\n+\n+      tries++;\n+      throw new CrdbTransactionRetryException(\"The Process Engine Bootstrap has failed.\");\n+\n+    }\n+\n+    public int getTries() {\n+      return tries;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+      return super.isRetryable();\n+    }\n+  }\n+\n+  protected static class ControllableFailingCommand extends ControllableCommand<Void> {\n+\n+    protected int tries = 0;\n+\n+    @Override\n+    public Void execute(CommandContext commandContext) {\n+\n+      monitor.sync();\n+\n+      tries++;\n+      throw new CrdbTransactionRetryException(\"Does not retry\");\n+    }\n+\n+    public int getTries() {\n+      return tries;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+      return false;\n+    }\n+  }\n+\n+  protected class ControllableJobDefinitionPriorityCommand extends ControllableCommand<Void> {\n+\n+    protected SetJobDefinitionPriorityCmd jobDefinitionPriorityCmd;\n+\n+    public ControllableJobDefinitionPriorityCommand(String jobDefinitionId, Long priority, boolean cascade) {\n+      this.jobDefinitionPriorityCmd = new SetJobDefinitionPriorityCmd(jobDefinitionId, priority, cascade);\n+    }\n+\n+    @Override\n+    public Void execute(CommandContext commandContext) {\n+\n+      monitor.sync();\n+\n+      jobDefinitionPriorityCmd.execute(commandContext);\n+\n+      monitor.sync();\n+\n+      return null;\n+    }\n+  }\n+\n+  protected class ControllableJobSuspensionCommand extends ControllableCommand<Void> {\n+\n+    protected SuspendJobDefinitionCmd suspendJobDefinitionCmd;\n+\n+    public ControllableJobSuspensionCommand(String processDefinitionKey) {\n+      UpdateJobDefinitionSuspensionStateBuilderImpl builder = new UpdateJobDefinitionSuspensionStateBuilderImpl()\n+          .byProcessDefinitionKey(processDefinitionKey)\n+          .includeJobs(true);\n+\n+      this.suspendJobDefinitionCmd = new SuspendJobDefinitionCmd(builder);\n+    }\n+\n+    @Override\n+    public Void execute(CommandContext commandContext) {\n+\n+      monitor.sync();\n+\n+      suspendJobDefinitionCmd.execute(commandContext);\n+\n+      monitor.sync();\n+\n+      return null;\n+    }\n+  }\n+\n+  protected void closeDownProcessEngine() {\n+    final ProcessEngine otherProcessEngine = ProcessEngines.getProcessEngine(PROCESS_ENGINE_NAME);\n+    if (otherProcessEngine != null) {\n+\n+      ((ProcessEngineConfigurationImpl)otherProcessEngine.getProcessEngineConfiguration())\n+          .getCommandExecutorTxRequired()\n+          .execute((Command<Void>) commandContext -> {\n+\n+            List<Job> jobs = otherProcessEngine.getManagementService().createJobQuery().list();\n+            if (jobs.size() > 0) {\n+              assertEquals(1, jobs.size());\n+              String jobId = jobs.get(0).getId();\n+              commandContext.getJobManager().deleteJob((JobEntity) jobs.get(0));\n+              commandContext.getHistoricJobLogManager().deleteHistoricJobLogByJobId(jobId);\n+            }\n+\n+            return null;\n+          });", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0MjI0NA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492842244", "bodyText": "Removed it. It's not actually necessary. The reason was to remove any data created by the additional Process Engine that is created by the shouldRethrowBootstrapEngineOleWhenRetriesAreExhausted() test case. However, since the test simulates a scenario where the Process  Engine bootstrap fails, and the transaction is rolled back, there is nothing to clean up.", "author": "koevskinikola", "createdAt": "2020-09-22T15:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU2ODI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU3MjU5Mw==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492572593", "bodyText": "Why does this test use a controllable command at all? It tests no concurrency situation.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T08:49:43Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/cockroachdb/CockroachDBRetriesTest.java", "diffHunk": "@@ -0,0 +1,505 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.cockroachdb;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.camunda.bpm.engine.CrdbTransactionRetryException;\n+import org.camunda.bpm.engine.ManagementService;\n+import org.camunda.bpm.engine.ProcessEngine;\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.ProcessEngines;\n+import org.camunda.bpm.engine.RuntimeService;\n+import org.camunda.bpm.engine.externaltask.ExternalTask;\n+import org.camunda.bpm.engine.externaltask.LockedExternalTask;\n+import org.camunda.bpm.engine.impl.BootstrapEngineCommand;\n+import org.camunda.bpm.engine.impl.ProcessEngineImpl;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.cmd.FetchExternalTasksCmd;\n+import org.camunda.bpm.engine.impl.cmd.SetJobDefinitionPriorityCmd;\n+import org.camunda.bpm.engine.impl.cmd.SuspendJobDefinitionCmd;\n+import org.camunda.bpm.engine.impl.db.sql.DbSqlSessionFactory;\n+import org.camunda.bpm.engine.impl.externaltask.TopicFetchInstruction;\n+import org.camunda.bpm.engine.impl.interceptor.Command;\n+import org.camunda.bpm.engine.impl.interceptor.CommandContext;\n+import org.camunda.bpm.engine.impl.management.UpdateJobDefinitionSuspensionStateBuilderImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.JobEntity;\n+import org.camunda.bpm.engine.impl.test.RequiredDatabase;\n+import org.camunda.bpm.engine.management.JobDefinition;\n+import org.camunda.bpm.engine.runtime.Job;\n+import org.camunda.bpm.engine.test.Deployment;\n+import org.camunda.bpm.engine.test.concurrency.CompetingExternalTaskFetchingTest;\n+import org.camunda.bpm.engine.test.concurrency.CompetingJobAcquisitionTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrencyTestHelper;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentJobExecutorTest;\n+import org.camunda.bpm.engine.test.jobexecutor.ControllableJobExecutor;\n+import org.camunda.bpm.engine.test.jobexecutor.RecordingAcquireJobsRunnable.RecordedWaitEvent;\n+import org.camunda.bpm.engine.test.util.ProcessEngineBootstrapRule;\n+import org.camunda.bpm.engine.test.util.ProcessEngineTestRule;\n+import org.camunda.bpm.engine.test.util.ProvidedProcessEngineRule;\n+import org.camunda.bpm.model.bpmn.Bpmn;\n+import org.camunda.bpm.model.bpmn.BpmnModelInstance;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+\n+@RequiredDatabase(includes = DbSqlSessionFactory.CRDB)\n+public class CockroachDBRetriesTest extends ConcurrencyTestHelper {\n+\n+  protected static final int DEFAULT_NUM_JOBS_TO_ACQUIRE = 3;\n+  protected static final int COMMAND_RETRIES = 3;\n+  protected static final String PROCESS_ENGINE_NAME = \"failingProcessEngine\";\n+  protected static final BpmnModelInstance SIMPLE_ASYNC_PROCESS = Bpmn.createExecutableProcess(\"simpleAsyncProcess\")\n+      .startEvent()\n+      .serviceTask()\n+      .camundaExpression(\"${true}\")\n+      .camundaAsyncBefore()\n+      .endEvent()\n+      .done();\n+  \n+  @ClassRule\n+  public static ProcessEngineBootstrapRule bootstrapRule = new ProcessEngineBootstrapRule(\n+      c -> c.setCommandRetries(COMMAND_RETRIES));\n+  protected ProvidedProcessEngineRule engineRule = new ProvidedProcessEngineRule(bootstrapRule);\n+  protected ProcessEngineTestRule testRule = new ProcessEngineTestRule(engineRule);\n+\n+  @Rule\n+  public RuleChain ruleChain = RuleChain.outerRule(engineRule).around(testRule);\n+\n+  @Rule\n+  public ExpectedException thrown = ExpectedException.none();\n+\n+  protected ControllableJobExecutor jobExecutor1;\n+  protected ControllableJobExecutor jobExecutor2;\n+\n+  protected ThreadControl acquisitionThread1;\n+  protected ThreadControl acquisitionThread2;\n+\n+  protected RuntimeService runtimeService;\n+  protected ManagementService managementService;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    processEngineConfiguration = engineRule.getProcessEngineConfiguration();\n+    runtimeService = engineRule.getRuntimeService();\n+    managementService = engineRule.getManagementService();\n+\n+    // two job executors with the default settings\n+    jobExecutor1 = new ControllableJobExecutor((ProcessEngineImpl) engineRule.getProcessEngine());\n+    jobExecutor1.setMaxJobsPerAcquisition(DEFAULT_NUM_JOBS_TO_ACQUIRE);\n+    acquisitionThread1 = jobExecutor1.getAcquisitionThreadControl();\n+    processEngineConfiguration.setJobExecutor(jobExecutor1);\n+\n+    jobExecutor2 = new ControllableJobExecutor((ProcessEngineImpl) engineRule.getProcessEngine());\n+    jobExecutor2.setMaxJobsPerAcquisition(DEFAULT_NUM_JOBS_TO_ACQUIRE);\n+    acquisitionThread2 = jobExecutor2.getAcquisitionThreadControl();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    jobExecutor1.shutdown();\n+    jobExecutor2.shutdown();\n+    closeDownProcessEngine();\n+  }\n+  \n+  /**\n+   * See {@link CompetingJobAcquisitionTest#testCompetingJobAcquisitions} for the test\n+   * case without retries\n+   */\n+  @Test\n+  @Deployment(resources = \"org/camunda/bpm/engine/test/jobexecutor/simpleAsyncProcess.bpmn20.xml\")\n+  public void shouldRetryJobAcquisition() {\n+\n+    // given\n+    int numJobs = DEFAULT_NUM_JOBS_TO_ACQUIRE + 1;\n+    for (int i = 0; i < numJobs; i++) {\n+      engineRule.getRuntimeService().startProcessInstanceByKey(\"simpleAsyncProcess\").getId();\n+    }\n+\n+    jobExecutor1.start();\n+    jobExecutor2.start();\n+    // both acquisition threads wait before acquiring something\n+    acquisitionThread1.waitForSync();\n+    acquisitionThread2.waitForSync();\n+    \n+    // both threads run the job acquisition query and should get overlapping results (3 out of 4 jobs)\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+    acquisitionThread2.makeContinueAndWaitForSync();\n+    \n+    // thread1 flushes and commits first (success)\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+    \n+    // when\n+    // acquisition fails => retry interceptor kicks in and retries command => waiting again before acquisition\n+    acquisitionThread2.makeContinueAndWaitForSync();\n+\n+    // thread2 immediately acquires again and commits\n+    acquisitionThread2.makeContinueAndWaitForSync();\n+    acquisitionThread2.makeContinueAndWaitForSync();\n+    \n+    // then \n+    // all jobs have been executed\n+    long currentJobs = engineRule.getManagementService().createJobQuery().active().count();\n+    assertThat(currentJobs).isEqualTo(0);\n+    \n+    // and thread2 has no reported failure\n+    assertThat(acquisitionThread2.getException()).isNull();\n+    \n+    List<RecordedWaitEvent> jobAcquisition2WaitEvents = jobExecutor2.getAcquireJobsRunnable().getWaitEvents();\n+    \n+    // and only one cycle of job acquisition was made (the wait event is from after the acquisition finished)\n+    assertThat(jobAcquisition2WaitEvents).hasSize(1); \n+    Exception acquisitionException = jobAcquisition2WaitEvents.get(0).getAcquisitionException();\n+    \n+    // and the exception never bubbled up to the job executor (i.e. the retry was transparent)\n+    assertThat(acquisitionException).isNull(); \n+  }\n+  \n+  /**\n+   * See {@link CompetingExternalTaskFetchingTest#testCompetingExternalTaskFetching()}\n+   * for the test case without retries.\n+   */\n+  @Test\n+  @Deployment(resources = \"org/camunda/bpm/engine/test/concurrency/CompetingExternalTaskFetchingTest.testCompetingExternalTaskFetching.bpmn20.xml\")\n+  public void shouldRetryExternalTaskFetchAndLock() {\n+    // given\n+    RuntimeService runtimeService = engineRule.getRuntimeService();\n+    \n+    int numTasksToFetch = 3;\n+    int numExternalTasks = numTasksToFetch + 1;\n+    \n+    for (int i = 0; i < numExternalTasks; i++) {\n+      runtimeService.startProcessInstanceByKey(\"oneExternalTaskProcess\");\n+    }\n+\n+    ThreadControl thread1 = executeControllableCommand(new ControlledFetchAndLockCommand(numTasksToFetch, \"thread1\", \"externalTaskTopic\"));\n+    ThreadControl thread2 = executeControllableCommand(new ControlledFetchAndLockCommand(numTasksToFetch, \"thread2\", \"externalTaskTopic\"));\n+\n+    // thread1 and thread2 begin their transactions and fetch tasks\n+    thread1.waitForSync();\n+    thread2.waitForSync();\n+    thread1.makeContinueAndWaitForSync();\n+    thread2.makeContinueAndWaitForSync();\n+    \n+    // thread1 commits\n+    thread1.waitUntilDone();\n+\n+    // when\n+    // thread2 flushes and fails => leads to retry\n+    thread2.waitUntilDone(true);\n+    \n+    // then\n+    List<ExternalTask> tasks = engineRule.getExternalTaskService().createExternalTaskQuery().list();\n+    List<ExternalTask> thread1Tasks = tasks.stream()\n+        .filter(t -> \"thread1\".equals(t.getWorkerId())).collect(Collectors.toList());\n+    List<ExternalTask> thread2Tasks = tasks.stream()\n+        .filter(t -> \"thread2\".equals(t.getWorkerId())).collect(Collectors.toList());\n+    \n+    assertThat(tasks).hasSize(numExternalTasks);\n+    assertThat(thread1Tasks).hasSize(numTasksToFetch);\n+    assertThat(thread2Tasks).hasSize(numExternalTasks - numTasksToFetch);\n+  }\n+\n+  /**\n+   * See {@link ConcurrentJobExecutorTest#testCompletingUpdateJobDefinitionPriorityDuringExecution()}\n+   * for the test case without retries.\n+   */\n+  @Test\n+  @Deployment(resources = \"org/camunda/bpm/engine/test/jobexecutor/simpleAsyncProcess.bpmn20.xml\")\n+  public void shouldRetryJobExecutionTxAfterJobPriorityOLE() {\n+    // given\n+    // several running process instances with an async continuation\n+    int numJobs = DEFAULT_NUM_JOBS_TO_ACQUIRE + 1;\n+    for (int i = 0; i < numJobs; i++) {\n+      engineRule.getRuntimeService().startProcessInstanceByKey(\"simpleAsyncProcess\");\n+    }\n+    // and a job definition\n+    JobDefinition jobDefinition = managementService.createJobDefinitionQuery().singleResult();\n+\n+    jobExecutor1.start();\n+    acquisitionThread1.waitForSync();\n+    ThreadControl jobPriorityThread = executeControllableCommand(new ControllableJobDefinitionPriorityCommand(jobDefinition.getId(), 42L, true));\n+    jobPriorityThread.waitForSync();\n+\n+    // the acquisition thread acquires the jobs\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+\n+    // the job priority thread updates the job priority and flushes the change\n+    jobPriorityThread.makeContinue();\n+    jobPriorityThread.waitUntilDone(true);\n+\n+    // when\n+    // the job acquisition thread attempts to flush the job locks it fails\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+\n+    // thread2 immediately acquires again and commits\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+    acquisitionThread1.ignoreFutureSyncs();\n+\n+    // then\n+    // the jobs have been executed and only one is remaining\n+    Job currentJob = engineRule.getManagementService().createJobQuery().active().singleResult();\n+    assertThat(currentJob).isNotNull();\n+    // the job priority has changed\n+    assertEquals(42, currentJob.getPriority());\n+    // and thread2 has no reported failure\n+    assertThat(acquisitionThread1.getException()).isNull();\n+  }\n+\n+  @Test\n+  @Deployment(resources = \"org/camunda/bpm/engine/test/jobexecutor/simpleAsyncProcess.bpmn20.xml\")\n+  public void shouldRetryAcquisitionJobTxAfterJobSuspensionOLE() {\n+    // given\n+    String processDefinitionKey = \"simpleAsyncProcess\";\n+    // a running process instance with an async continuation\n+    runtimeService.startProcessInstanceByKey(processDefinitionKey);\n+    // a waiting acquisition and a waiting suspension\n+    jobExecutor1.start();\n+    acquisitionThread1.reportInterrupts();\n+    acquisitionThread1.waitForSync();\n+    ThreadControl jobSuspensionThread = executeControllableCommand(new ControllableJobSuspensionCommand(processDefinitionKey));\n+    jobSuspensionThread.reportInterrupts();\n+    jobSuspensionThread.waitForSync();\n+\n+    // the acquisition thread acquires the jobs\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+\n+    // when the job suspension thread completes the suspension\n+    jobSuspensionThread.makeContinue();\n+    jobSuspensionThread.waitUntilDone(true);\n+\n+    // then\n+    // the acquisition thread fails to flush the job locks\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+\n+    // the acquisition thread immediately acquires again and commits\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+    acquisitionThread1.makeContinueAndWaitForSync();\n+\n+    // the suspension state doesn't fail at all\n+    assertNull(jobSuspensionThread.getException());\n+    // and the acquisition will not fail with optimistic locking since it was retried\n+    assertNull(acquisitionThread1.getException());\n+    // and no jobs were executed since they are suspended\n+    long jobCount = managementService.createJobQuery().suspended().count();\n+    assertThat(jobCount).isOne();\n+  }\n+\n+  @Test\n+  public void shouldRethrowBootstrapEngineOleWhenRetriesAreExhausted() {\n+    // given\n+    // a bootstrap command failing with a CrdbTransactionRetryException\n+    FailingProcessEngineBootstrapCommand bootstrapCommand = new FailingProcessEngineBootstrapCommand();\n+    ProcessEngineConfigurationImpl processEngineConfiguration = ((ProcessEngineConfigurationImpl)\n+        ProcessEngineConfiguration\n+            .createProcessEngineConfigurationFromResource(\"camunda.cfg.xml\"))\n+        .setCommandRetries(COMMAND_RETRIES)\n+        .setProcessEngineName(PROCESS_ENGINE_NAME);\n+    processEngineConfiguration.setProcessEngineBootstrapCommand(bootstrapCommand);\n+\n+    // then\n+    // a CrdbTransactionRetryException is re-thrown to the caller\n+    thrown.expect(CrdbTransactionRetryException.class);\n+\n+    // when\n+    processEngineConfiguration.buildProcessEngine();\n+\n+    // since the Command retries were exausted\n+    assertThat(bootstrapCommand.getTries()).isEqualTo(4);\n+  }\n+\n+  @Test\n+  public void shouldNotRetryCommandByDefault() {", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcxMDMxNQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492710315", "bodyText": "You're right! I was writing/porting all the concurrency test scenarios then, so I applied the same pattern to this test, just to catch the CrdbTransactionRetryException. I agree that it's not necessary, I will refactor it.", "author": "koevskinikola", "createdAt": "2020-09-22T12:56:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU3MjU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU3NjMwNQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492576305", "bodyText": "Please explain here why we are waiting for 2 seconds instead of waiting for the next sync (I assume because some statement blocks).", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T08:55:41Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/cockroachdb/CockroachDbExclusiveLockDisabledTest.java", "diffHunk": "@@ -0,0 +1,739 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.cockroachdb;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.List;\n+\n+import org.camunda.bpm.engine.CrdbTransactionRetryException;\n+import org.camunda.bpm.engine.HistoryService;\n+import org.camunda.bpm.engine.ManagementService;\n+import org.camunda.bpm.engine.ProcessEngine;\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.ProcessEngines;\n+import org.camunda.bpm.engine.RepositoryService;\n+import org.camunda.bpm.engine.impl.BootstrapEngineCommand;\n+import org.camunda.bpm.engine.impl.HistoryLevelSetupCommand;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.cmd.DeployCmd;\n+import org.camunda.bpm.engine.impl.cmd.HistoryCleanupCmd;\n+import org.camunda.bpm.engine.impl.context.Context;\n+import org.camunda.bpm.engine.impl.db.sql.DbSqlSessionFactory;\n+import org.camunda.bpm.engine.impl.history.HistoryLevel;\n+import org.camunda.bpm.engine.impl.interceptor.Command;\n+import org.camunda.bpm.engine.impl.interceptor.CommandContext;\n+import org.camunda.bpm.engine.impl.interceptor.CommandInvocationContext;\n+import org.camunda.bpm.engine.impl.persistence.entity.JobEntity;\n+import org.camunda.bpm.engine.impl.repository.DeploymentBuilderImpl;\n+import org.camunda.bpm.engine.impl.test.RequiredDatabase;\n+import org.camunda.bpm.engine.impl.test.TestHelper;\n+import org.camunda.bpm.engine.repository.DeploymentBuilder;\n+import org.camunda.bpm.engine.repository.ProcessDefinition;\n+import org.camunda.bpm.engine.runtime.Job;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrencyTestHelper;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentDeploymentTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentHistoryCleanupTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentHistoryLevelTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentInstallationIdInitializationTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentProcessEngineJobExecutorHistoryCleanupJobTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentTelemetryConfigurationTest;\n+import org.camunda.bpm.engine.test.jobexecutor.ControllableJobExecutor;\n+import org.camunda.bpm.engine.test.util.ProcessEngineBootstrapRule;\n+import org.camunda.bpm.engine.test.util.ProcessEngineTestRule;\n+import org.camunda.bpm.engine.test.util.ProvidedProcessEngineRule;\n+import org.camunda.bpm.model.bpmn.Bpmn;\n+import org.camunda.bpm.model.bpmn.BpmnModelInstance;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+\n+@RequiredDatabase(includes = DbSqlSessionFactory.CRDB)\n+public class CockroachDbExclusiveLockDisabledTest extends ConcurrencyTestHelper {\n+\n+  protected static final String PROCESS_ENGINE_NAME = \"retriableBootstrapProcessEngine\";\n+  protected static final int COMMAND_RETRIES = 3;\n+  protected final BpmnModelInstance PROCESS_WITH_USERTASK = Bpmn.createExecutableProcess(\"process\")\n+      .startEvent()\n+      .userTask()\n+      .endEvent()\n+      .done();\n+\n+  @ClassRule\n+  public static ProcessEngineBootstrapRule bootstrapRule = new ProcessEngineBootstrapRule(\n+    c -> c.setCommandRetries(COMMAND_RETRIES).setJobExecutor(new ControllableJobExecutor()));\n+  protected ProvidedProcessEngineRule engineRule = new ProvidedProcessEngineRule(bootstrapRule);\n+  protected ProcessEngineTestRule testRule = new ProcessEngineTestRule(engineRule);\n+\n+  @Rule\n+  public RuleChain ruleChain = RuleChain.outerRule(engineRule).around(testRule);\n+\n+  protected RepositoryService repositoryService;\n+  protected ManagementService managementService;\n+  protected HistoryService historyService;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    processEngineConfiguration = engineRule.getProcessEngineConfiguration();\n+    repositoryService = engineRule.getRepositoryService();\n+    managementService = engineRule.getManagementService();\n+    historyService = engineRule.getHistoryService();\n+\n+    TestHelper.deleteInstallationId(processEngineConfiguration);\n+    TestHelper.deleteTelemetryProperty(processEngineConfiguration);\n+    TestHelper.deleteHistoryLevel(processEngineConfiguration);\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    testRule.deleteHistoryCleanupJobs();\n+    processEngineConfiguration.getCommandExecutorTxRequired().execute((Command<Void>) commandContext -> {\n+\n+      commandContext.getMeterLogManager().deleteAll();\n+      List<Job> jobs = managementService.createJobQuery().list();\n+      if (jobs.size() > 0) {\n+        String jobId = jobs.get(0).getId();\n+        commandContext.getJobManager().deleteJob((JobEntity) jobs.get(0));\n+        commandContext.getHistoricJobLogManager().deleteHistoricJobLogByJobId(jobId);\n+      }\n+      commandContext.getHistoricJobLogManager().deleteHistoricJobLogsByHandlerType(\"history-cleanup\");\n+\n+      return null;\n+    });\n+    for(org.camunda.bpm.engine.repository.Deployment deployment : repositoryService.createDeploymentQuery().list()) {\n+      repositoryService.deleteDeployment(deployment.getId(), true);\n+    }\n+    processEngineConfiguration.getDeploymentCache().purgeCache();\n+    closeDownProcessEngine();\n+  }\n+\n+  /**\n+   * See {@link ConcurrentDeploymentTest#testVersioning()}\n+   * for the test case without retries, and with an exclusive lock.\n+   */\n+  @Test\n+  public void shouldRetryDeployCmdWithoutExclusiveLock() throws InterruptedException {\n+    // given\n+    DeploymentBuilder deploymentOne = createDeploymentBuilder();\n+    DeploymentBuilder deploymentTwo = createDeploymentBuilder();\n+\n+    // STEP 1: bring two threads to a point where they have\n+    // 1) started a new transaction\n+    // 2) are ready to deploy\n+    ControllableDeployCommand deployCommand1 = new ControllableDeployCommand(deploymentOne);\n+    ControllableDeployCommand deployCommand2 = new ControllableDeployCommand(deploymentTwo);\n+    ConcurrencyTestHelper.ThreadControl thread1 = executeControllableCommand(deployCommand1);\n+    thread1.waitForSync();\n+\n+    ConcurrencyTestHelper.ThreadControl thread2 = executeControllableCommand(deployCommand2);\n+    thread2.reportInterrupts();\n+    thread2.waitForSync();\n+\n+    // STEP 2: make Thread 1 proceed and wait until it has deployed but not yet committed\n+    // -> will still hold the exclusive lock\n+    thread1.makeContinue();\n+    thread1.waitForSync();\n+\n+    // when\n+    // STEP 3: make Thread 2 continue\n+    // -> it will attempt a deployment\n+    thread2.makeContinue();\n+\n+    // wait for 2 seconds\n+    Thread.sleep(2000);", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI2MjcwNQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r494262705", "bodyText": "In this test, we can replace all Thread.sleep calls with thread2.waitForSync(). Thread 2 never blocks on a statement, you can verify that with the debugger. By this point in the test (and the other tests in this class), both threads have only performed SELECTs.", "author": "ThorbenLindhauer", "createdAt": "2020-09-24T12:10:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU3NjMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQxMjI2OQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r494412269", "bodyText": "Done with 156dcdd.", "author": "koevskinikola", "createdAt": "2020-09-24T15:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU3NjMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU4MTI1NA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492581254", "bodyText": "This is not a good pattern for testing these aspects, because the command that we use for testing is much different from the actual bootstrap command (because of SQL statements that are executed before the telemetry part is reached, the case tested here may not exist in practice). We should instead test with the actual bootstrap command and insert some sync points if necessary for the tests.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T09:03:53Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/cockroachdb/CockroachDbExclusiveLockDisabledTest.java", "diffHunk": "@@ -0,0 +1,739 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.cockroachdb;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.List;\n+\n+import org.camunda.bpm.engine.CrdbTransactionRetryException;\n+import org.camunda.bpm.engine.HistoryService;\n+import org.camunda.bpm.engine.ManagementService;\n+import org.camunda.bpm.engine.ProcessEngine;\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.ProcessEngines;\n+import org.camunda.bpm.engine.RepositoryService;\n+import org.camunda.bpm.engine.impl.BootstrapEngineCommand;\n+import org.camunda.bpm.engine.impl.HistoryLevelSetupCommand;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.cmd.DeployCmd;\n+import org.camunda.bpm.engine.impl.cmd.HistoryCleanupCmd;\n+import org.camunda.bpm.engine.impl.context.Context;\n+import org.camunda.bpm.engine.impl.db.sql.DbSqlSessionFactory;\n+import org.camunda.bpm.engine.impl.history.HistoryLevel;\n+import org.camunda.bpm.engine.impl.interceptor.Command;\n+import org.camunda.bpm.engine.impl.interceptor.CommandContext;\n+import org.camunda.bpm.engine.impl.interceptor.CommandInvocationContext;\n+import org.camunda.bpm.engine.impl.persistence.entity.JobEntity;\n+import org.camunda.bpm.engine.impl.repository.DeploymentBuilderImpl;\n+import org.camunda.bpm.engine.impl.test.RequiredDatabase;\n+import org.camunda.bpm.engine.impl.test.TestHelper;\n+import org.camunda.bpm.engine.repository.DeploymentBuilder;\n+import org.camunda.bpm.engine.repository.ProcessDefinition;\n+import org.camunda.bpm.engine.runtime.Job;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrencyTestHelper;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentDeploymentTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentHistoryCleanupTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentHistoryLevelTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentInstallationIdInitializationTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentProcessEngineJobExecutorHistoryCleanupJobTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentTelemetryConfigurationTest;\n+import org.camunda.bpm.engine.test.jobexecutor.ControllableJobExecutor;\n+import org.camunda.bpm.engine.test.util.ProcessEngineBootstrapRule;\n+import org.camunda.bpm.engine.test.util.ProcessEngineTestRule;\n+import org.camunda.bpm.engine.test.util.ProvidedProcessEngineRule;\n+import org.camunda.bpm.model.bpmn.Bpmn;\n+import org.camunda.bpm.model.bpmn.BpmnModelInstance;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+\n+@RequiredDatabase(includes = DbSqlSessionFactory.CRDB)\n+public class CockroachDbExclusiveLockDisabledTest extends ConcurrencyTestHelper {\n+\n+  protected static final String PROCESS_ENGINE_NAME = \"retriableBootstrapProcessEngine\";\n+  protected static final int COMMAND_RETRIES = 3;\n+  protected final BpmnModelInstance PROCESS_WITH_USERTASK = Bpmn.createExecutableProcess(\"process\")\n+      .startEvent()\n+      .userTask()\n+      .endEvent()\n+      .done();\n+\n+  @ClassRule\n+  public static ProcessEngineBootstrapRule bootstrapRule = new ProcessEngineBootstrapRule(\n+    c -> c.setCommandRetries(COMMAND_RETRIES).setJobExecutor(new ControllableJobExecutor()));\n+  protected ProvidedProcessEngineRule engineRule = new ProvidedProcessEngineRule(bootstrapRule);\n+  protected ProcessEngineTestRule testRule = new ProcessEngineTestRule(engineRule);\n+\n+  @Rule\n+  public RuleChain ruleChain = RuleChain.outerRule(engineRule).around(testRule);\n+\n+  protected RepositoryService repositoryService;\n+  protected ManagementService managementService;\n+  protected HistoryService historyService;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    processEngineConfiguration = engineRule.getProcessEngineConfiguration();\n+    repositoryService = engineRule.getRepositoryService();\n+    managementService = engineRule.getManagementService();\n+    historyService = engineRule.getHistoryService();\n+\n+    TestHelper.deleteInstallationId(processEngineConfiguration);\n+    TestHelper.deleteTelemetryProperty(processEngineConfiguration);\n+    TestHelper.deleteHistoryLevel(processEngineConfiguration);\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    testRule.deleteHistoryCleanupJobs();\n+    processEngineConfiguration.getCommandExecutorTxRequired().execute((Command<Void>) commandContext -> {\n+\n+      commandContext.getMeterLogManager().deleteAll();\n+      List<Job> jobs = managementService.createJobQuery().list();\n+      if (jobs.size() > 0) {\n+        String jobId = jobs.get(0).getId();\n+        commandContext.getJobManager().deleteJob((JobEntity) jobs.get(0));\n+        commandContext.getHistoricJobLogManager().deleteHistoricJobLogByJobId(jobId);\n+      }\n+      commandContext.getHistoricJobLogManager().deleteHistoricJobLogsByHandlerType(\"history-cleanup\");\n+\n+      return null;\n+    });\n+    for(org.camunda.bpm.engine.repository.Deployment deployment : repositoryService.createDeploymentQuery().list()) {\n+      repositoryService.deleteDeployment(deployment.getId(), true);\n+    }\n+    processEngineConfiguration.getDeploymentCache().purgeCache();\n+    closeDownProcessEngine();\n+  }\n+\n+  /**\n+   * See {@link ConcurrentDeploymentTest#testVersioning()}\n+   * for the test case without retries, and with an exclusive lock.\n+   */\n+  @Test\n+  public void shouldRetryDeployCmdWithoutExclusiveLock() throws InterruptedException {\n+    // given\n+    DeploymentBuilder deploymentOne = createDeploymentBuilder();\n+    DeploymentBuilder deploymentTwo = createDeploymentBuilder();\n+\n+    // STEP 1: bring two threads to a point where they have\n+    // 1) started a new transaction\n+    // 2) are ready to deploy\n+    ControllableDeployCommand deployCommand1 = new ControllableDeployCommand(deploymentOne);\n+    ControllableDeployCommand deployCommand2 = new ControllableDeployCommand(deploymentTwo);\n+    ConcurrencyTestHelper.ThreadControl thread1 = executeControllableCommand(deployCommand1);\n+    thread1.waitForSync();\n+\n+    ConcurrencyTestHelper.ThreadControl thread2 = executeControllableCommand(deployCommand2);\n+    thread2.reportInterrupts();\n+    thread2.waitForSync();\n+\n+    // STEP 2: make Thread 1 proceed and wait until it has deployed but not yet committed\n+    // -> will still hold the exclusive lock\n+    thread1.makeContinue();\n+    thread1.waitForSync();\n+\n+    // when\n+    // STEP 3: make Thread 2 continue\n+    // -> it will attempt a deployment\n+    thread2.makeContinue();\n+\n+    // wait for 2 seconds\n+    Thread.sleep(2000);\n+\n+    // STEP 4: allow Thread 1 to terminate\n+    // -> Thread 1 will commit\n+    thread1.waitUntilDone();\n+\n+    // then\n+    // STEP 5: wait for Thread 2 to fail on flush and retry\n+    thread2.waitForSync();\n+    thread2.waitUntilDone(true);\n+\n+    // ensure that although both transactions were run concurrently, the process definitions have different versions\n+    List<ProcessDefinition> processDefinitions = repositoryService\n+      .createProcessDefinitionQuery()\n+      .orderByProcessDefinitionVersion()\n+      .asc()\n+      .list();\n+\n+    Assert.assertThat(processDefinitions.size(), is(2));\n+    Assert.assertThat(processDefinitions.get(0).getVersion(), is(1));\n+    Assert.assertThat(processDefinitions.get(1).getVersion(), is(2));\n+\n+    // ensure that the first deploy command was only executed once\n+    assertThat(deployCommand1.getTries()).isEqualTo(1);\n+    // while the second deploy command failed with an OLE, and was retried\n+    assertThat(deployCommand2.getTries()).isEqualTo(2);\n+  }\n+\n+  /**\n+   * See {@link ConcurrentTelemetryConfigurationTest}\n+   * for the test case without retries, and with an exclusive lock.\n+   */\n+  @Test\n+  public void shouldEnableTelemetryWithoutExclusiveLock() throws InterruptedException {\n+    // given\n+    // two concurrent commands to create a new telemetry property\n+    ControllableUpdateTelemetrySetupCommand telemetrySetupCommand1 = new ControllableUpdateTelemetrySetupCommand();\n+    ControllableUpdateTelemetrySetupCommand telemetrySetupCommand2 = new ControllableUpdateTelemetrySetupCommand();\n+\n+    ConcurrencyTestHelper.ThreadControl thread1 = executeControllableCommand(telemetrySetupCommand1);\n+    thread1.reportInterrupts();\n+    thread1.waitForSync();\n+\n+    ConcurrencyTestHelper.ThreadControl thread2 = executeControllableCommand(telemetrySetupCommand2);\n+    thread2.reportInterrupts();\n+    thread2.waitForSync();\n+\n+    // the first command initializes the property\n+    thread1.makeContinue();\n+    thread1.waitForSync();\n+\n+    // the second command initializes the property\n+    thread2.makeContinue();\n+\n+    Thread.sleep(2000);\n+\n+    // the first commands flushes its result\n+    thread1.waitUntilDone();\n+\n+    // when\n+    // the second command attempts to flush its result\n+    thread2.waitForSync();\n+    // fails, and retries\n+    thread2.waitUntilDone(true);\n+\n+    // then\n+    // the first command shouldn't fail at all\n+    assertNull(thread1.getException());\n+    // the second command should fail with an OLE, but it should be\n+    // caught by the CrdbTransactionRetryInterceptor\n+    assertNull(thread2.getException());\n+    // the telemetry property is successfully set\n+    assertThat(managementService.isTelemetryEnabled()).isFalse();\n+\n+    // the first command was only executed once\n+    assertThat(telemetrySetupCommand1.getTries()).isOne();\n+    // but the second failed with an OLE, and was retried\n+    assertThat(telemetrySetupCommand2.getTries()).isEqualTo(2);\n+  }\n+\n+  /**\n+   * See {@link ConcurrentInstallationIdInitializationTest}\n+   * for the test case without retries, and with an exclusive lock.\n+   */\n+  @Test\n+  public void shouldSetInstallationIdWithoutExclusiveLock() throws InterruptedException {\n+    // given\n+    // two concurrent commands to set an installation id\n+    ControllableInstallationIdInitializationCommand initializationCommand1 =\n+      new ControllableInstallationIdInitializationCommand();\n+    ControllableInstallationIdInitializationCommand initializationCommand2 =\n+      new ControllableInstallationIdInitializationCommand();\n+    ConcurrencyTestHelper.ThreadControl thread1 = executeControllableCommand(initializationCommand1);\n+    thread1.reportInterrupts();\n+    thread1.waitForSync();\n+\n+    ConcurrencyTestHelper.ThreadControl thread2 = executeControllableCommand(initializationCommand2);\n+    thread2.reportInterrupts();\n+    thread2.waitForSync();\n+\n+    // the first command initializes an installation id property\n+    thread1.makeContinue();\n+    thread1.waitForSync();\n+\n+    // the second command initializes an installation id property\n+    thread2.makeContinue();\n+\n+    Thread.sleep(2000);\n+\n+    // the first command flushes its installation id\n+    thread1.waitUntilDone();\n+    String firstInstallationId = processEngineConfiguration.getInstallationId();\n+\n+    // when\n+    // the second command attempts to flush its installation id\n+    thread2.waitForSync();\n+    // fails, and is retried\n+    thread2.waitUntilDone(true);\n+\n+    // then\n+    // the fist command shouldn't fail\n+    assertNull(thread1.getException());\n+    // the second command should fail, but the OLE should be caught\n+    assertNull(thread2.getException());\n+\n+    // the first command was only executed once\n+    assertThat(initializationCommand1.getTries()).isOne();\n+    // but the second failed with an OLE, and was retried\n+    assertThat(initializationCommand2.getTries()).isEqualTo(2);\n+\n+    // the installation id of the second command is the last one\n+    String secondInstallationId = processEngineConfiguration.getInstallationId();\n+    assertThat(secondInstallationId).isNotEmpty();\n+    assertThat(secondInstallationId).isNotEqualTo(firstInstallationId);\n+    assertThat(secondInstallationId).matches(\"[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}\");\n+  }\n+\n+  /**\n+   * See {@link ConcurrentHistoryCleanupTest}\n+   * for the test case without retries, and with an exclusive lock.\n+   */\n+  @Test\n+  public void shouldReconfigureHistoryCleanupJobWithoutExclusiveLock() throws InterruptedException {\n+    // given\n+    ControllableHistoryCleanupCommand historyCleanupCommand1 = new ControllableHistoryCleanupCommand();\n+    ControllableHistoryCleanupCommand historyCleanupCommand2 = new ControllableHistoryCleanupCommand();\n+\n+    // first thread that executes a HistoryCleanupCmd\n+    ThreadControl thread1 = executeControllableCommand(historyCleanupCommand1);\n+    thread1.waitForSync();\n+\n+    // second thread that executes a HistoryCleanupCmd\n+    ThreadControl thread2 = executeControllableCommand(historyCleanupCommand2);\n+    thread2.reportInterrupts();\n+    thread2.waitForSync();\n+\n+    // first thread executes the job, reconfigures the next one and waits to flush to the db\n+    thread1.makeContinue();\n+    thread1.waitForSync();\n+\n+    // second thread executes the job, reconfigures the next one and waits to flush to the db\n+    thread2.makeContinue();\n+\n+    Thread.sleep(2000);\n+\n+    // first thread flushes the changes to the db\n+    thread1.waitUntilDone();\n+\n+    //only one history cleanup job exists -> no exception\n+    List<Job> historyCleanupJobs = historyService.findHistoryCleanupJobs();\n+    assertEquals(1, historyCleanupJobs.size());\n+    Job firstHistoryCleanupJob = historyCleanupJobs.get(0);\n+\n+    // second thread attempts to flush, fails and retries\n+    thread2.waitForSync();\n+    thread2.waitUntilDone(true);\n+\n+    // the OLE was caught by the CrdbTransactionRetryInterceptor\n+    assertNull(thread2.getException());\n+    // and the command was retried\n+    assertEquals(2, ((ControllableHistoryCleanupCommand) controllableCommands.get(1)).getTries());\n+\n+    //still, only one history cleanup job exists -> no exception\n+    historyCleanupJobs = historyService.findHistoryCleanupJobs();\n+    assertEquals(1, historyCleanupJobs.size());\n+\n+    // however, thread2 successfully reconfigured the HistoryCleanupJob\n+    Job secondHistoryCleanupJob = historyCleanupJobs.get(0);\n+    assertTrue(secondHistoryCleanupJob.getDuedate().after(firstHistoryCleanupJob.getDuedate()));\n+\n+    assertThat(historyCleanupCommand1.getTries()).isOne();\n+    assertThat(historyCleanupCommand2.getTries()).isEqualTo(2);\n+  }\n+\n+  /**\n+   * See {@link ConcurrentProcessEngineJobExecutorHistoryCleanupJobTest#testConcurrentHistoryCleanupJobReconfigurationExecution()}\n+   * for the test case without retries, and with an exclusive lock.\n+   */\n+  @Test\n+  public void shouldRetryTxToBootstrapConcurrentProcessEngineWithoutExclusiveLock() throws InterruptedException {\n+    // given\n+    historyService.cleanUpHistoryAsync(true);\n+\n+    ThreadControl thread1 = executeControllableCommand(new ControllableJobExecutionCommand());\n+    thread1.reportInterrupts();\n+    thread1.waitForSync();\n+\n+    ControllableProcessEngineBootstrapCommand bootstrapCommand = new ControllableProcessEngineBootstrapCommand();\n+    ThreadControl thread2 = executeControllableCommand(bootstrapCommand);\n+    thread2.reportInterrupts();\n+    thread2.waitForSync();\n+\n+    // the first Bootstrap Engine cmd performs its initialization steps\n+    thread1.makeContinue();\n+    thread1.waitForSync();\n+\n+    // the second Bootstrap Engine cmd performs its initialization steps\n+    thread2.makeContinue();\n+\n+    Thread.sleep(2000);\n+\n+    // the first Bootstrap Engine cmd flushes its changes\n+    thread1.waitUntilDone();\n+\n+    // when\n+    // the second Process Engine Bootstrap Command attempts to flush\n+    thread2.waitForSync();\n+    // it fails, and is retried\n+    thread2.waitUntilDone(true);\n+\n+    assertNull(thread1.getException());\n+    assertNull(thread2.getException());\n+\n+    // When CockroachDB is used, the CrdbTransactionRetryException is caught by\n+    // the CrdbTransactionRetryInterceptor and the command is retried\n+    assertThat(bootstrapCommand.getContextSpy().getThrowable()).isNull();\n+    assertThat(bootstrapCommand.getTries()).isEqualTo(2);\n+\n+    // the Process Engine is successfully registered even when run on CRDB\n+    // since the OLE is caught and handled during the Process Engine Bootstrap command\n+    assertNotNull(ProcessEngines.getProcessEngines().get(PROCESS_ENGINE_NAME));\n+  }\n+\n+  /**\n+   * See {@link ConcurrentHistoryLevelTest}\n+   * for the test case without retries, and with an exclusive lock.\n+   */\n+  @Test\n+  public void shouldUpdateHistoryLevelWithoutExclusiveLock() throws InterruptedException {\n+    // given\n+    ControllableUpdateHistoryLevelCommand historyLevelCommand1 = new ControllableUpdateHistoryLevelCommand();\n+    ControllableUpdateHistoryLevelCommand historyLevelCommand2 = new ControllableUpdateHistoryLevelCommand();\n+    ThreadControl thread1 = executeControllableCommand(historyLevelCommand1);\n+    thread1.reportInterrupts();\n+    thread1.waitForSync();\n+\n+    ThreadControl thread2 = executeControllableCommand(historyLevelCommand2);\n+    thread2.reportInterrupts();\n+    thread2.waitForSync();\n+\n+    // the first command determines the history level\n+    thread1.makeContinue();\n+    thread1.waitForSync();\n+\n+    // the second command determines the history level\n+    thread2.makeContinue();\n+\n+    Thread.sleep(2000);\n+\n+    // the first command flushes the history level to the database\n+    thread1.waitUntilDone();\n+\n+    // when\n+    // the second command attempts to flush the history level to the database\n+    thread2.waitForSync();\n+    // it fails, and is retried\n+    thread2.waitUntilDone(true);\n+\n+    // then\n+    assertNull(thread1.getException());\n+    assertNull(thread2.getException());\n+\n+    // the first command is only executed once\n+    assertThat(historyLevelCommand1.getTries()).isOne();\n+    // but the second encounters an OLE and is retried\n+    assertThat(historyLevelCommand2.getTries()).isEqualTo(2);\n+\n+    // but the history level is correct\n+    HistoryLevel historyLevel = processEngineConfiguration.getHistoryLevel();\n+    assertEquals(\"full\", historyLevel.getName());\n+  }\n+\n+  protected static class ControllableUpdateHistoryLevelCommand extends ControllableCommand<Void> {\n+\n+    protected HistoryLevelSetupCommand historyLevelSetupCommand;\n+    protected int tries;\n+\n+    public ControllableUpdateHistoryLevelCommand() {\n+      this.historyLevelSetupCommand = new HistoryLevelSetupCommand();\n+      this.tries = 0;\n+    }\n+\n+    public Void execute(CommandContext commandContext) {\n+\n+      monitor.sync();  // thread will block here until makeContinue() is called form main thread\n+\n+      tries++;\n+      historyLevelSetupCommand.execute(commandContext);\n+\n+      monitor.sync(); // thread will block here until waitUntilDone() is called form main thread\n+\n+      return null;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+      return historyLevelSetupCommand.isRetryable();\n+    }\n+\n+    public int getTries() {\n+      return tries;\n+    }\n+  }\n+\n+  protected static class ControllableJobExecutionCommand extends ControllableCommand<Void> {\n+\n+    @Override\n+    public Void execute(CommandContext commandContext) {\n+\n+      monitor.sync();\n+\n+      List<Job> historyCleanupJobs = commandContext.getProcessEngineConfiguration()\n+          .getHistoryService()\n+          .findHistoryCleanupJobs();\n+\n+      for (Job job : historyCleanupJobs) {\n+        commandContext.getProcessEngineConfiguration().getManagementService().executeJob(job.getId());\n+      }\n+\n+      monitor.sync();\n+\n+      return null;\n+    }\n+  }\n+\n+  protected static class ControllableProcessEngineBootstrapCommand extends ControllableCommand<Void> {\n+\n+    protected ControllableBootstrapEngineCommand bootstrapCommand;\n+\n+    public ControllableProcessEngineBootstrapCommand() {\n+      this.bootstrapCommand = new ControllableBootstrapEngineCommand(this.monitor);\n+    }\n+\n+    @Override\n+    public Void execute(CommandContext commandContext) {\n+\n+      ProcessEngineConfigurationImpl processEngineConfiguration = ((ProcessEngineConfigurationImpl)\n+          ProcessEngineConfiguration\n+              .createProcessEngineConfigurationFromResource(\"camunda.cfg.xml\"))\n+          .setCommandRetries(COMMAND_RETRIES)\n+          .setProcessEngineName(PROCESS_ENGINE_NAME);\n+      processEngineConfiguration.setProcessEngineBootstrapCommand(bootstrapCommand);\n+\n+      processEngineConfiguration.buildProcessEngine();\n+\n+      return null;\n+    }\n+\n+    public int getTries() {\n+      return bootstrapCommand.getTries();\n+    }\n+\n+    public CommandInvocationContext getContextSpy() {\n+      return bootstrapCommand.getSpy();\n+    }\n+  }\n+\n+  protected static class ControllableBootstrapEngineCommand extends BootstrapEngineCommand {\n+\n+    protected final ThreadControl monitor;\n+    protected CommandInvocationContext spy;\n+    protected int tries;\n+\n+    public ControllableBootstrapEngineCommand(ThreadControl threadControl) {\n+      this.monitor = threadControl;\n+      this.tries = 0;\n+    }\n+\n+    @Override\n+    protected void createHistoryCleanupJob(CommandContext commandContext) {\n+\n+      monitor.sync();\n+\n+      tries++;\n+      super.createHistoryCleanupJob(commandContext);\n+      spy = Context.getCommandInvocationContext();\n+\n+      monitor.sync();\n+    }\n+\n+    public int getTries() {\n+      return tries;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+      return super.isRetryable();\n+    }\n+\n+    public CommandInvocationContext getSpy() {\n+      return spy;\n+    }\n+  }\n+\n+  protected static class ControllableHistoryCleanupCommand extends ControllableCommand<Void> {\n+\n+    protected int tries;\n+    protected HistoryCleanupCmd historyCleanupCmd;\n+\n+    public ControllableHistoryCleanupCommand() {\n+      this.tries = 0;\n+      this.historyCleanupCmd = new HistoryCleanupCmd(true);\n+    }\n+\n+    public Void execute(CommandContext commandContext) {\n+      monitor.sync();  // thread will block here until makeContinue() is called form main thread\n+\n+      historyCleanupCmd.execute(commandContext);\n+\n+      // increment command retries;\n+      tries++;\n+\n+      monitor.sync();  // thread will block here until waitUntilDone() is called form main thread\n+\n+      return null;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+      return historyCleanupCmd.isRetryable();\n+    }\n+\n+    public int getTries() {\n+      return tries;\n+    }\n+  }\n+\n+  protected static class ControllableInstallationIdInitializationCommand extends ConcurrencyTestHelper.ControllableCommand<Void> {\n+\n+    protected int tries;\n+    protected BootstrapEngineCommand bootstrapEngineCommand;\n+\n+    public ControllableInstallationIdInitializationCommand() {\n+      this.tries = 0;\n+      this.bootstrapEngineCommand = new BootstrapEngineCommand();\n+    }\n+\n+    public Void execute(CommandContext commandContext) {\n+\n+      monitor.sync(); // thread will block here until makeContinue() is called form main thread\n+\n+      tries++;\n+      bootstrapEngineCommand.initializeInstallationId(commandContext);\n+\n+      monitor.sync(); // thread will block here until waitUntilDone() is called form main thread\n+\n+      return null;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+      return bootstrapEngineCommand.isRetryable();\n+    }\n+\n+    public int getTries() {\n+      return tries;\n+    }\n+  }\n+\n+  protected static class ControllableUpdateTelemetrySetupCommand extends ConcurrencyTestHelper.ControllableCommand<Void> {\n+\n+    protected int tries;\n+    protected BootstrapEngineCommand bootstrapEngineCommand;\n+\n+    public ControllableUpdateTelemetrySetupCommand() {\n+      this.tries = 0;\n+      this.bootstrapEngineCommand = new BootstrapEngineCommand();\n+    }\n+\n+    public Void execute(CommandContext commandContext) {\n+\n+      monitor.sync(); // thread will block here until makeContinue() is called form main thread\n+\n+      tries++;\n+      bootstrapEngineCommand.initializeTelemetryProperty(commandContext);\n+\n+      monitor.sync(); // thread will block here until waitUntilDone() is called form main thread\n+\n+      return null;\n+    }", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2MjcyMQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r493462721", "bodyText": "Refactored the code to use the complete BootstrapEngineCommand, and apply sync points to the feature being tested (installation id, telemetry or history cleanup job).", "author": "koevskinikola", "createdAt": "2020-09-23T11:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU4MTI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU4Mzc2OA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492583768", "bodyText": "This does not execute jobs, or am I missing something?", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T09:07:55Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/cockroachdb/CockroachDbExclusiveLockDisabledTest.java", "diffHunk": "@@ -0,0 +1,739 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.cockroachdb;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.List;\n+\n+import org.camunda.bpm.engine.CrdbTransactionRetryException;\n+import org.camunda.bpm.engine.HistoryService;\n+import org.camunda.bpm.engine.ManagementService;\n+import org.camunda.bpm.engine.ProcessEngine;\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.ProcessEngines;\n+import org.camunda.bpm.engine.RepositoryService;\n+import org.camunda.bpm.engine.impl.BootstrapEngineCommand;\n+import org.camunda.bpm.engine.impl.HistoryLevelSetupCommand;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.cmd.DeployCmd;\n+import org.camunda.bpm.engine.impl.cmd.HistoryCleanupCmd;\n+import org.camunda.bpm.engine.impl.context.Context;\n+import org.camunda.bpm.engine.impl.db.sql.DbSqlSessionFactory;\n+import org.camunda.bpm.engine.impl.history.HistoryLevel;\n+import org.camunda.bpm.engine.impl.interceptor.Command;\n+import org.camunda.bpm.engine.impl.interceptor.CommandContext;\n+import org.camunda.bpm.engine.impl.interceptor.CommandInvocationContext;\n+import org.camunda.bpm.engine.impl.persistence.entity.JobEntity;\n+import org.camunda.bpm.engine.impl.repository.DeploymentBuilderImpl;\n+import org.camunda.bpm.engine.impl.test.RequiredDatabase;\n+import org.camunda.bpm.engine.impl.test.TestHelper;\n+import org.camunda.bpm.engine.repository.DeploymentBuilder;\n+import org.camunda.bpm.engine.repository.ProcessDefinition;\n+import org.camunda.bpm.engine.runtime.Job;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrencyTestHelper;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentDeploymentTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentHistoryCleanupTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentHistoryLevelTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentInstallationIdInitializationTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentProcessEngineJobExecutorHistoryCleanupJobTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentTelemetryConfigurationTest;\n+import org.camunda.bpm.engine.test.jobexecutor.ControllableJobExecutor;\n+import org.camunda.bpm.engine.test.util.ProcessEngineBootstrapRule;\n+import org.camunda.bpm.engine.test.util.ProcessEngineTestRule;\n+import org.camunda.bpm.engine.test.util.ProvidedProcessEngineRule;\n+import org.camunda.bpm.model.bpmn.Bpmn;\n+import org.camunda.bpm.model.bpmn.BpmnModelInstance;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+\n+@RequiredDatabase(includes = DbSqlSessionFactory.CRDB)\n+public class CockroachDbExclusiveLockDisabledTest extends ConcurrencyTestHelper {\n+\n+  protected static final String PROCESS_ENGINE_NAME = \"retriableBootstrapProcessEngine\";\n+  protected static final int COMMAND_RETRIES = 3;\n+  protected final BpmnModelInstance PROCESS_WITH_USERTASK = Bpmn.createExecutableProcess(\"process\")\n+      .startEvent()\n+      .userTask()\n+      .endEvent()\n+      .done();\n+\n+  @ClassRule\n+  public static ProcessEngineBootstrapRule bootstrapRule = new ProcessEngineBootstrapRule(\n+    c -> c.setCommandRetries(COMMAND_RETRIES).setJobExecutor(new ControllableJobExecutor()));\n+  protected ProvidedProcessEngineRule engineRule = new ProvidedProcessEngineRule(bootstrapRule);\n+  protected ProcessEngineTestRule testRule = new ProcessEngineTestRule(engineRule);\n+\n+  @Rule\n+  public RuleChain ruleChain = RuleChain.outerRule(engineRule).around(testRule);\n+\n+  protected RepositoryService repositoryService;\n+  protected ManagementService managementService;\n+  protected HistoryService historyService;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    processEngineConfiguration = engineRule.getProcessEngineConfiguration();\n+    repositoryService = engineRule.getRepositoryService();\n+    managementService = engineRule.getManagementService();\n+    historyService = engineRule.getHistoryService();\n+\n+    TestHelper.deleteInstallationId(processEngineConfiguration);\n+    TestHelper.deleteTelemetryProperty(processEngineConfiguration);\n+    TestHelper.deleteHistoryLevel(processEngineConfiguration);\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    testRule.deleteHistoryCleanupJobs();\n+    processEngineConfiguration.getCommandExecutorTxRequired().execute((Command<Void>) commandContext -> {\n+\n+      commandContext.getMeterLogManager().deleteAll();\n+      List<Job> jobs = managementService.createJobQuery().list();\n+      if (jobs.size() > 0) {\n+        String jobId = jobs.get(0).getId();\n+        commandContext.getJobManager().deleteJob((JobEntity) jobs.get(0));\n+        commandContext.getHistoricJobLogManager().deleteHistoricJobLogByJobId(jobId);\n+      }\n+      commandContext.getHistoricJobLogManager().deleteHistoricJobLogsByHandlerType(\"history-cleanup\");\n+\n+      return null;\n+    });\n+    for(org.camunda.bpm.engine.repository.Deployment deployment : repositoryService.createDeploymentQuery().list()) {\n+      repositoryService.deleteDeployment(deployment.getId(), true);\n+    }\n+    processEngineConfiguration.getDeploymentCache().purgeCache();\n+    closeDownProcessEngine();\n+  }\n+\n+  /**\n+   * See {@link ConcurrentDeploymentTest#testVersioning()}\n+   * for the test case without retries, and with an exclusive lock.\n+   */\n+  @Test\n+  public void shouldRetryDeployCmdWithoutExclusiveLock() throws InterruptedException {\n+    // given\n+    DeploymentBuilder deploymentOne = createDeploymentBuilder();\n+    DeploymentBuilder deploymentTwo = createDeploymentBuilder();\n+\n+    // STEP 1: bring two threads to a point where they have\n+    // 1) started a new transaction\n+    // 2) are ready to deploy\n+    ControllableDeployCommand deployCommand1 = new ControllableDeployCommand(deploymentOne);\n+    ControllableDeployCommand deployCommand2 = new ControllableDeployCommand(deploymentTwo);\n+    ConcurrencyTestHelper.ThreadControl thread1 = executeControllableCommand(deployCommand1);\n+    thread1.waitForSync();\n+\n+    ConcurrencyTestHelper.ThreadControl thread2 = executeControllableCommand(deployCommand2);\n+    thread2.reportInterrupts();\n+    thread2.waitForSync();\n+\n+    // STEP 2: make Thread 1 proceed and wait until it has deployed but not yet committed\n+    // -> will still hold the exclusive lock\n+    thread1.makeContinue();\n+    thread1.waitForSync();\n+\n+    // when\n+    // STEP 3: make Thread 2 continue\n+    // -> it will attempt a deployment\n+    thread2.makeContinue();\n+\n+    // wait for 2 seconds\n+    Thread.sleep(2000);\n+\n+    // STEP 4: allow Thread 1 to terminate\n+    // -> Thread 1 will commit\n+    thread1.waitUntilDone();\n+\n+    // then\n+    // STEP 5: wait for Thread 2 to fail on flush and retry\n+    thread2.waitForSync();\n+    thread2.waitUntilDone(true);\n+\n+    // ensure that although both transactions were run concurrently, the process definitions have different versions\n+    List<ProcessDefinition> processDefinitions = repositoryService\n+      .createProcessDefinitionQuery()\n+      .orderByProcessDefinitionVersion()\n+      .asc()\n+      .list();\n+\n+    Assert.assertThat(processDefinitions.size(), is(2));\n+    Assert.assertThat(processDefinitions.get(0).getVersion(), is(1));\n+    Assert.assertThat(processDefinitions.get(1).getVersion(), is(2));\n+\n+    // ensure that the first deploy command was only executed once\n+    assertThat(deployCommand1.getTries()).isEqualTo(1);\n+    // while the second deploy command failed with an OLE, and was retried\n+    assertThat(deployCommand2.getTries()).isEqualTo(2);\n+  }\n+\n+  /**\n+   * See {@link ConcurrentTelemetryConfigurationTest}\n+   * for the test case without retries, and with an exclusive lock.\n+   */\n+  @Test\n+  public void shouldEnableTelemetryWithoutExclusiveLock() throws InterruptedException {\n+    // given\n+    // two concurrent commands to create a new telemetry property\n+    ControllableUpdateTelemetrySetupCommand telemetrySetupCommand1 = new ControllableUpdateTelemetrySetupCommand();\n+    ControllableUpdateTelemetrySetupCommand telemetrySetupCommand2 = new ControllableUpdateTelemetrySetupCommand();\n+\n+    ConcurrencyTestHelper.ThreadControl thread1 = executeControllableCommand(telemetrySetupCommand1);\n+    thread1.reportInterrupts();\n+    thread1.waitForSync();\n+\n+    ConcurrencyTestHelper.ThreadControl thread2 = executeControllableCommand(telemetrySetupCommand2);\n+    thread2.reportInterrupts();\n+    thread2.waitForSync();\n+\n+    // the first command initializes the property\n+    thread1.makeContinue();\n+    thread1.waitForSync();\n+\n+    // the second command initializes the property\n+    thread2.makeContinue();\n+\n+    Thread.sleep(2000);\n+\n+    // the first commands flushes its result\n+    thread1.waitUntilDone();\n+\n+    // when\n+    // the second command attempts to flush its result\n+    thread2.waitForSync();\n+    // fails, and retries\n+    thread2.waitUntilDone(true);\n+\n+    // then\n+    // the first command shouldn't fail at all\n+    assertNull(thread1.getException());\n+    // the second command should fail with an OLE, but it should be\n+    // caught by the CrdbTransactionRetryInterceptor\n+    assertNull(thread2.getException());\n+    // the telemetry property is successfully set\n+    assertThat(managementService.isTelemetryEnabled()).isFalse();\n+\n+    // the first command was only executed once\n+    assertThat(telemetrySetupCommand1.getTries()).isOne();\n+    // but the second failed with an OLE, and was retried\n+    assertThat(telemetrySetupCommand2.getTries()).isEqualTo(2);\n+  }\n+\n+  /**\n+   * See {@link ConcurrentInstallationIdInitializationTest}\n+   * for the test case without retries, and with an exclusive lock.\n+   */\n+  @Test\n+  public void shouldSetInstallationIdWithoutExclusiveLock() throws InterruptedException {\n+    // given\n+    // two concurrent commands to set an installation id\n+    ControllableInstallationIdInitializationCommand initializationCommand1 =\n+      new ControllableInstallationIdInitializationCommand();\n+    ControllableInstallationIdInitializationCommand initializationCommand2 =\n+      new ControllableInstallationIdInitializationCommand();\n+    ConcurrencyTestHelper.ThreadControl thread1 = executeControllableCommand(initializationCommand1);\n+    thread1.reportInterrupts();\n+    thread1.waitForSync();\n+\n+    ConcurrencyTestHelper.ThreadControl thread2 = executeControllableCommand(initializationCommand2);\n+    thread2.reportInterrupts();\n+    thread2.waitForSync();\n+\n+    // the first command initializes an installation id property\n+    thread1.makeContinue();\n+    thread1.waitForSync();\n+\n+    // the second command initializes an installation id property\n+    thread2.makeContinue();\n+\n+    Thread.sleep(2000);\n+\n+    // the first command flushes its installation id\n+    thread1.waitUntilDone();\n+    String firstInstallationId = processEngineConfiguration.getInstallationId();\n+\n+    // when\n+    // the second command attempts to flush its installation id\n+    thread2.waitForSync();\n+    // fails, and is retried\n+    thread2.waitUntilDone(true);\n+\n+    // then\n+    // the fist command shouldn't fail\n+    assertNull(thread1.getException());\n+    // the second command should fail, but the OLE should be caught\n+    assertNull(thread2.getException());\n+\n+    // the first command was only executed once\n+    assertThat(initializationCommand1.getTries()).isOne();\n+    // but the second failed with an OLE, and was retried\n+    assertThat(initializationCommand2.getTries()).isEqualTo(2);\n+\n+    // the installation id of the second command is the last one\n+    String secondInstallationId = processEngineConfiguration.getInstallationId();\n+    assertThat(secondInstallationId).isNotEmpty();\n+    assertThat(secondInstallationId).isNotEqualTo(firstInstallationId);\n+    assertThat(secondInstallationId).matches(\"[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}\");\n+  }\n+\n+  /**\n+   * See {@link ConcurrentHistoryCleanupTest}\n+   * for the test case without retries, and with an exclusive lock.\n+   */\n+  @Test\n+  public void shouldReconfigureHistoryCleanupJobWithoutExclusiveLock() throws InterruptedException {\n+    // given\n+    ControllableHistoryCleanupCommand historyCleanupCommand1 = new ControllableHistoryCleanupCommand();\n+    ControllableHistoryCleanupCommand historyCleanupCommand2 = new ControllableHistoryCleanupCommand();\n+\n+    // first thread that executes a HistoryCleanupCmd\n+    ThreadControl thread1 = executeControllableCommand(historyCleanupCommand1);\n+    thread1.waitForSync();\n+\n+    // second thread that executes a HistoryCleanupCmd\n+    ThreadControl thread2 = executeControllableCommand(historyCleanupCommand2);\n+    thread2.reportInterrupts();\n+    thread2.waitForSync();\n+\n+    // first thread executes the job, reconfigures the next one and waits to flush to the db", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyMzg3NA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492723874", "bodyText": "Correct, sorry. I will change the comments.", "author": "koevskinikola", "createdAt": "2020-09-22T13:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU4Mzc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU4NzQwOA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492587408", "bodyText": "This is not a bootstrap command.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T09:13:51Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/cockroachdb/CockroachDbExclusiveLockDisabledTest.java", "diffHunk": "@@ -0,0 +1,739 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.cockroachdb;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.List;\n+\n+import org.camunda.bpm.engine.CrdbTransactionRetryException;\n+import org.camunda.bpm.engine.HistoryService;\n+import org.camunda.bpm.engine.ManagementService;\n+import org.camunda.bpm.engine.ProcessEngine;\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.ProcessEngines;\n+import org.camunda.bpm.engine.RepositoryService;\n+import org.camunda.bpm.engine.impl.BootstrapEngineCommand;\n+import org.camunda.bpm.engine.impl.HistoryLevelSetupCommand;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.cmd.DeployCmd;\n+import org.camunda.bpm.engine.impl.cmd.HistoryCleanupCmd;\n+import org.camunda.bpm.engine.impl.context.Context;\n+import org.camunda.bpm.engine.impl.db.sql.DbSqlSessionFactory;\n+import org.camunda.bpm.engine.impl.history.HistoryLevel;\n+import org.camunda.bpm.engine.impl.interceptor.Command;\n+import org.camunda.bpm.engine.impl.interceptor.CommandContext;\n+import org.camunda.bpm.engine.impl.interceptor.CommandInvocationContext;\n+import org.camunda.bpm.engine.impl.persistence.entity.JobEntity;\n+import org.camunda.bpm.engine.impl.repository.DeploymentBuilderImpl;\n+import org.camunda.bpm.engine.impl.test.RequiredDatabase;\n+import org.camunda.bpm.engine.impl.test.TestHelper;\n+import org.camunda.bpm.engine.repository.DeploymentBuilder;\n+import org.camunda.bpm.engine.repository.ProcessDefinition;\n+import org.camunda.bpm.engine.runtime.Job;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrencyTestHelper;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentDeploymentTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentHistoryCleanupTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentHistoryLevelTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentInstallationIdInitializationTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentProcessEngineJobExecutorHistoryCleanupJobTest;\n+import org.camunda.bpm.engine.test.concurrency.ConcurrentTelemetryConfigurationTest;\n+import org.camunda.bpm.engine.test.jobexecutor.ControllableJobExecutor;\n+import org.camunda.bpm.engine.test.util.ProcessEngineBootstrapRule;\n+import org.camunda.bpm.engine.test.util.ProcessEngineTestRule;\n+import org.camunda.bpm.engine.test.util.ProvidedProcessEngineRule;\n+import org.camunda.bpm.model.bpmn.Bpmn;\n+import org.camunda.bpm.model.bpmn.BpmnModelInstance;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+\n+@RequiredDatabase(includes = DbSqlSessionFactory.CRDB)\n+public class CockroachDbExclusiveLockDisabledTest extends ConcurrencyTestHelper {\n+\n+  protected static final String PROCESS_ENGINE_NAME = \"retriableBootstrapProcessEngine\";\n+  protected static final int COMMAND_RETRIES = 3;\n+  protected final BpmnModelInstance PROCESS_WITH_USERTASK = Bpmn.createExecutableProcess(\"process\")\n+      .startEvent()\n+      .userTask()\n+      .endEvent()\n+      .done();\n+\n+  @ClassRule\n+  public static ProcessEngineBootstrapRule bootstrapRule = new ProcessEngineBootstrapRule(\n+    c -> c.setCommandRetries(COMMAND_RETRIES).setJobExecutor(new ControllableJobExecutor()));\n+  protected ProvidedProcessEngineRule engineRule = new ProvidedProcessEngineRule(bootstrapRule);\n+  protected ProcessEngineTestRule testRule = new ProcessEngineTestRule(engineRule);\n+\n+  @Rule\n+  public RuleChain ruleChain = RuleChain.outerRule(engineRule).around(testRule);\n+\n+  protected RepositoryService repositoryService;\n+  protected ManagementService managementService;\n+  protected HistoryService historyService;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    processEngineConfiguration = engineRule.getProcessEngineConfiguration();\n+    repositoryService = engineRule.getRepositoryService();\n+    managementService = engineRule.getManagementService();\n+    historyService = engineRule.getHistoryService();\n+\n+    TestHelper.deleteInstallationId(processEngineConfiguration);\n+    TestHelper.deleteTelemetryProperty(processEngineConfiguration);\n+    TestHelper.deleteHistoryLevel(processEngineConfiguration);\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    testRule.deleteHistoryCleanupJobs();\n+    processEngineConfiguration.getCommandExecutorTxRequired().execute((Command<Void>) commandContext -> {\n+\n+      commandContext.getMeterLogManager().deleteAll();\n+      List<Job> jobs = managementService.createJobQuery().list();\n+      if (jobs.size() > 0) {\n+        String jobId = jobs.get(0).getId();\n+        commandContext.getJobManager().deleteJob((JobEntity) jobs.get(0));\n+        commandContext.getHistoricJobLogManager().deleteHistoricJobLogByJobId(jobId);\n+      }\n+      commandContext.getHistoricJobLogManager().deleteHistoricJobLogsByHandlerType(\"history-cleanup\");\n+\n+      return null;\n+    });\n+    for(org.camunda.bpm.engine.repository.Deployment deployment : repositoryService.createDeploymentQuery().list()) {\n+      repositoryService.deleteDeployment(deployment.getId(), true);\n+    }\n+    processEngineConfiguration.getDeploymentCache().purgeCache();\n+    closeDownProcessEngine();\n+  }\n+\n+  /**\n+   * See {@link ConcurrentDeploymentTest#testVersioning()}\n+   * for the test case without retries, and with an exclusive lock.\n+   */\n+  @Test\n+  public void shouldRetryDeployCmdWithoutExclusiveLock() throws InterruptedException {\n+    // given\n+    DeploymentBuilder deploymentOne = createDeploymentBuilder();\n+    DeploymentBuilder deploymentTwo = createDeploymentBuilder();\n+\n+    // STEP 1: bring two threads to a point where they have\n+    // 1) started a new transaction\n+    // 2) are ready to deploy\n+    ControllableDeployCommand deployCommand1 = new ControllableDeployCommand(deploymentOne);\n+    ControllableDeployCommand deployCommand2 = new ControllableDeployCommand(deploymentTwo);\n+    ConcurrencyTestHelper.ThreadControl thread1 = executeControllableCommand(deployCommand1);\n+    thread1.waitForSync();\n+\n+    ConcurrencyTestHelper.ThreadControl thread2 = executeControllableCommand(deployCommand2);\n+    thread2.reportInterrupts();\n+    thread2.waitForSync();\n+\n+    // STEP 2: make Thread 1 proceed and wait until it has deployed but not yet committed\n+    // -> will still hold the exclusive lock\n+    thread1.makeContinue();\n+    thread1.waitForSync();\n+\n+    // when\n+    // STEP 3: make Thread 2 continue\n+    // -> it will attempt a deployment\n+    thread2.makeContinue();\n+\n+    // wait for 2 seconds\n+    Thread.sleep(2000);\n+\n+    // STEP 4: allow Thread 1 to terminate\n+    // -> Thread 1 will commit\n+    thread1.waitUntilDone();\n+\n+    // then\n+    // STEP 5: wait for Thread 2 to fail on flush and retry\n+    thread2.waitForSync();\n+    thread2.waitUntilDone(true);\n+\n+    // ensure that although both transactions were run concurrently, the process definitions have different versions\n+    List<ProcessDefinition> processDefinitions = repositoryService\n+      .createProcessDefinitionQuery()\n+      .orderByProcessDefinitionVersion()\n+      .asc()\n+      .list();\n+\n+    Assert.assertThat(processDefinitions.size(), is(2));\n+    Assert.assertThat(processDefinitions.get(0).getVersion(), is(1));\n+    Assert.assertThat(processDefinitions.get(1).getVersion(), is(2));\n+\n+    // ensure that the first deploy command was only executed once\n+    assertThat(deployCommand1.getTries()).isEqualTo(1);\n+    // while the second deploy command failed with an OLE, and was retried\n+    assertThat(deployCommand2.getTries()).isEqualTo(2);\n+  }\n+\n+  /**\n+   * See {@link ConcurrentTelemetryConfigurationTest}\n+   * for the test case without retries, and with an exclusive lock.\n+   */\n+  @Test\n+  public void shouldEnableTelemetryWithoutExclusiveLock() throws InterruptedException {\n+    // given\n+    // two concurrent commands to create a new telemetry property\n+    ControllableUpdateTelemetrySetupCommand telemetrySetupCommand1 = new ControllableUpdateTelemetrySetupCommand();\n+    ControllableUpdateTelemetrySetupCommand telemetrySetupCommand2 = new ControllableUpdateTelemetrySetupCommand();\n+\n+    ConcurrencyTestHelper.ThreadControl thread1 = executeControllableCommand(telemetrySetupCommand1);\n+    thread1.reportInterrupts();\n+    thread1.waitForSync();\n+\n+    ConcurrencyTestHelper.ThreadControl thread2 = executeControllableCommand(telemetrySetupCommand2);\n+    thread2.reportInterrupts();\n+    thread2.waitForSync();\n+\n+    // the first command initializes the property\n+    thread1.makeContinue();\n+    thread1.waitForSync();\n+\n+    // the second command initializes the property\n+    thread2.makeContinue();\n+\n+    Thread.sleep(2000);\n+\n+    // the first commands flushes its result\n+    thread1.waitUntilDone();\n+\n+    // when\n+    // the second command attempts to flush its result\n+    thread2.waitForSync();\n+    // fails, and retries\n+    thread2.waitUntilDone(true);\n+\n+    // then\n+    // the first command shouldn't fail at all\n+    assertNull(thread1.getException());\n+    // the second command should fail with an OLE, but it should be\n+    // caught by the CrdbTransactionRetryInterceptor\n+    assertNull(thread2.getException());\n+    // the telemetry property is successfully set\n+    assertThat(managementService.isTelemetryEnabled()).isFalse();\n+\n+    // the first command was only executed once\n+    assertThat(telemetrySetupCommand1.getTries()).isOne();\n+    // but the second failed with an OLE, and was retried\n+    assertThat(telemetrySetupCommand2.getTries()).isEqualTo(2);\n+  }\n+\n+  /**\n+   * See {@link ConcurrentInstallationIdInitializationTest}\n+   * for the test case without retries, and with an exclusive lock.\n+   */\n+  @Test\n+  public void shouldSetInstallationIdWithoutExclusiveLock() throws InterruptedException {\n+    // given\n+    // two concurrent commands to set an installation id\n+    ControllableInstallationIdInitializationCommand initializationCommand1 =\n+      new ControllableInstallationIdInitializationCommand();\n+    ControllableInstallationIdInitializationCommand initializationCommand2 =\n+      new ControllableInstallationIdInitializationCommand();\n+    ConcurrencyTestHelper.ThreadControl thread1 = executeControllableCommand(initializationCommand1);\n+    thread1.reportInterrupts();\n+    thread1.waitForSync();\n+\n+    ConcurrencyTestHelper.ThreadControl thread2 = executeControllableCommand(initializationCommand2);\n+    thread2.reportInterrupts();\n+    thread2.waitForSync();\n+\n+    // the first command initializes an installation id property\n+    thread1.makeContinue();\n+    thread1.waitForSync();\n+\n+    // the second command initializes an installation id property\n+    thread2.makeContinue();\n+\n+    Thread.sleep(2000);\n+\n+    // the first command flushes its installation id\n+    thread1.waitUntilDone();\n+    String firstInstallationId = processEngineConfiguration.getInstallationId();\n+\n+    // when\n+    // the second command attempts to flush its installation id\n+    thread2.waitForSync();\n+    // fails, and is retried\n+    thread2.waitUntilDone(true);\n+\n+    // then\n+    // the fist command shouldn't fail\n+    assertNull(thread1.getException());\n+    // the second command should fail, but the OLE should be caught\n+    assertNull(thread2.getException());\n+\n+    // the first command was only executed once\n+    assertThat(initializationCommand1.getTries()).isOne();\n+    // but the second failed with an OLE, and was retried\n+    assertThat(initializationCommand2.getTries()).isEqualTo(2);\n+\n+    // the installation id of the second command is the last one\n+    String secondInstallationId = processEngineConfiguration.getInstallationId();\n+    assertThat(secondInstallationId).isNotEmpty();\n+    assertThat(secondInstallationId).isNotEqualTo(firstInstallationId);\n+    assertThat(secondInstallationId).matches(\"[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}\");\n+  }\n+\n+  /**\n+   * See {@link ConcurrentHistoryCleanupTest}\n+   * for the test case without retries, and with an exclusive lock.\n+   */\n+  @Test\n+  public void shouldReconfigureHistoryCleanupJobWithoutExclusiveLock() throws InterruptedException {\n+    // given\n+    ControllableHistoryCleanupCommand historyCleanupCommand1 = new ControllableHistoryCleanupCommand();\n+    ControllableHistoryCleanupCommand historyCleanupCommand2 = new ControllableHistoryCleanupCommand();\n+\n+    // first thread that executes a HistoryCleanupCmd\n+    ThreadControl thread1 = executeControllableCommand(historyCleanupCommand1);\n+    thread1.waitForSync();\n+\n+    // second thread that executes a HistoryCleanupCmd\n+    ThreadControl thread2 = executeControllableCommand(historyCleanupCommand2);\n+    thread2.reportInterrupts();\n+    thread2.waitForSync();\n+\n+    // first thread executes the job, reconfigures the next one and waits to flush to the db\n+    thread1.makeContinue();\n+    thread1.waitForSync();\n+\n+    // second thread executes the job, reconfigures the next one and waits to flush to the db\n+    thread2.makeContinue();\n+\n+    Thread.sleep(2000);\n+\n+    // first thread flushes the changes to the db\n+    thread1.waitUntilDone();\n+\n+    //only one history cleanup job exists -> no exception\n+    List<Job> historyCleanupJobs = historyService.findHistoryCleanupJobs();\n+    assertEquals(1, historyCleanupJobs.size());\n+    Job firstHistoryCleanupJob = historyCleanupJobs.get(0);\n+\n+    // second thread attempts to flush, fails and retries\n+    thread2.waitForSync();\n+    thread2.waitUntilDone(true);\n+\n+    // the OLE was caught by the CrdbTransactionRetryInterceptor\n+    assertNull(thread2.getException());\n+    // and the command was retried\n+    assertEquals(2, ((ControllableHistoryCleanupCommand) controllableCommands.get(1)).getTries());\n+\n+    //still, only one history cleanup job exists -> no exception\n+    historyCleanupJobs = historyService.findHistoryCleanupJobs();\n+    assertEquals(1, historyCleanupJobs.size());\n+\n+    // however, thread2 successfully reconfigured the HistoryCleanupJob\n+    Job secondHistoryCleanupJob = historyCleanupJobs.get(0);\n+    assertTrue(secondHistoryCleanupJob.getDuedate().after(firstHistoryCleanupJob.getDuedate()));\n+\n+    assertThat(historyCleanupCommand1.getTries()).isOne();\n+    assertThat(historyCleanupCommand2.getTries()).isEqualTo(2);\n+  }\n+\n+  /**\n+   * See {@link ConcurrentProcessEngineJobExecutorHistoryCleanupJobTest#testConcurrentHistoryCleanupJobReconfigurationExecution()}\n+   * for the test case without retries, and with an exclusive lock.\n+   */\n+  @Test\n+  public void shouldRetryTxToBootstrapConcurrentProcessEngineWithoutExclusiveLock() throws InterruptedException {\n+    // given\n+    historyService.cleanUpHistoryAsync(true);\n+\n+    ThreadControl thread1 = executeControllableCommand(new ControllableJobExecutionCommand());\n+    thread1.reportInterrupts();\n+    thread1.waitForSync();\n+\n+    ControllableProcessEngineBootstrapCommand bootstrapCommand = new ControllableProcessEngineBootstrapCommand();\n+    ThreadControl thread2 = executeControllableCommand(bootstrapCommand);\n+    thread2.reportInterrupts();\n+    thread2.waitForSync();\n+\n+    // the first Bootstrap Engine cmd performs its initialization steps", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI5OTAzMw==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r493299033", "bodyText": "Rephrased all the comments in this test case to refer to:\n\nA \"JobExecutor\" thread\nA BootstrapEngineCmd thread", "author": "koevskinikola", "createdAt": "2020-09-23T08:19:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU4NzQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5MDg2NQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492590865", "bodyText": "Why does the command fail when it is retryable? If it is because the controlled command already opens the transaction and the nested fetch and lock command then aborts it and retries with an aborted transaction, then we are testing a case that is not supposed to occur in practice.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T09:19:33Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/concurrency/CompetingExternalTaskFetchingTest.java", "diffHunk": "@@ -113,6 +119,11 @@ public void testCompetingExternalTaskFetching() {\n     thread2.proceedAndWaitTillDone();\n     assertEquals(0, thread2.fetchedTasks.size());\n     // but does not fail with an OptimisticLockingException\n-    assertNull(thread2.exception);\n+    if (testRule.isOptimisticLockingExceptionSuppressible()) {\n+      assertNull(thread2.exception);\n+    } else {\n+      // CockroachDb\n+      assertTrue(thread2.exception instanceof CrdbTransactionRetryException);\n+    }", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyNzg0OQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492727849", "bodyText": "The command fails since by default we have the commandRetries property set to 0. So even if a retryable command fails, it  will not be retried, but the exception will be re-thrown to the caller. In this case, the exception is expected.\nWe can also discuss this further, if I didn't understand your question.", "author": "koevskinikola", "createdAt": "2020-09-22T13:21:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5MDg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5MTUwNA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492591504", "bodyText": "Same here, why is the command not retried successfully?", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T09:20:41Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/concurrency/CompetingJobAcquisitionTest.java", "diffHunk": "@@ -105,11 +98,42 @@ public void testCompetingJobAcquisitions() throws Exception {\n \n     LOG.debug(\"test thread notifies thread 2\");\n     threadTwo.proceedAndWaitTillDone();\n-    // the acquisition did NOT fail\n-    assertNull(threadTwo.exception);\n-    // but the job was not acquired\n-    assertEquals(0, threadTwo.jobs.size());\n \n+    if (testRule.isOptimisticLockingExceptionSuppressible()) {\n+      // the acquisition did NOT fail\n+      assertNull(threadTwo.exception);\n+      // but the job was not acquired\n+      assertEquals(0, threadTwo.jobs.size());\n+    } else {\n+      // if the Process Engine runs on CockroachDB\n+      // the acquisition fails due to an OLE that can't be handled or ignored\n+      assertThat(threadTwo.exception).isInstanceOf(OptimisticLockingException.class);\n+    }", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyOTY0OA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492729648", "bodyText": "It's the same as above, the commandRetries property is set to 0, so any retryable commands will not be retried, and the CrdbTransactionRetryException will be re-thrown to the caller.", "author": "koevskinikola", "createdAt": "2020-09-22T13:23:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5MTUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5MjI5OQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492592299", "bodyText": "Can this be removed?", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T09:22:03Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/concurrency/CompetingMessageCorrelationTest.java", "diffHunk": "@@ -192,6 +204,7 @@ public void testConcurrentExclusiveCorrelationToDifferentExecutions() throws Int\n     // thread two correlates and acquires the exclusive lock on the event subscription of instance2\n     // depending on the database and locking used, this may block thread2\n     thread2.makeContinue();\n+    Thread.sleep(3000); // wait a bit until t2 is blocked during the flush", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1MzE4Mg==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492753182", "bodyText": "Yes, this was added before we concluded that Exclusive Message Correlations can't be used on CRDB. Since the test is excluded for CRDB, we can revert the test to it's original setup.", "author": "koevskinikola", "createdAt": "2020-09-22T13:54:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5MjI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NjIxMg==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492596212", "bodyText": "It makes sense here to assert that at least thread1 was successful. Also, this test tests a scenarion that does not occur like that in practice, because the deploy command is retryable.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T09:28:12Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/concurrency/ConcurrentDeploymentTest.java", "diffHunk": "@@ -67,9 +69,15 @@ public void testDuplicateFiltering() throws InterruptedException {\n         createDeploymentBuilder().enableDuplicateFiltering(false),\n         createDeploymentBuilder().enableDuplicateFiltering(false));\n \n-    // ensure that although both transactions were run concurrently, only one deployment was constructed.\n-    DeploymentQuery deploymentQuery = repositoryService.createDeploymentQuery();\n-    assertThat(deploymentQuery.count(), is(1L));\n+    if (testRule.isOptimisticLockingExceptionSuppressible()) {\n+      // ensure that although both transactions were run concurrently, only one deployment was constructed.\n+      DeploymentQuery deploymentQuery = repositoryService.createDeploymentQuery();\n+      assertThat(deploymentQuery.count()).isEqualTo(1L);\n+    } else {\n+      // on CockroachDB, the deployment pessimistic lock is disabled\n+      // and concurrent deployments rely on the CRDB optimistic locking mechanism\n+      assertCockroachDBConcurrentFailure();", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc2OTk0OQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492769949", "bodyText": "Added additional assertions. As in the previous cases, this scenario covers the default configuration, when the commandRetries property is set to 0. In that case, even retryable commands fail, and report the CrdbTransactionRetryException to the caller.", "author": "koevskinikola", "createdAt": "2020-09-22T14:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NjIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5Njg5Ng==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492596896", "bodyText": "Same here. The value of the test is questionable, because the command is retryable in practice.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T09:29:21Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/concurrency/ConcurrentHistoryCleanupReconfigureTest.java", "diffHunk": "@@ -76,6 +94,13 @@ public void testReconfigureCleanupJobs() {\n     // then\n     engineTwo.makeContinue(); // reconfigure job & flush\n     engineTwo.join();\n+    if (testRule.isOptimisticLockingExceptionSuppressible()) {\n+      assertThat(engineTwo.getException()).isNull();\n+    } else {\n+      // on CockroachDB, a concurrent reconfiguration of the HistoryCleanupJobs will result\n+      // in an un-ignorable OptimisticLockingException and the whole command will need to be retried.\n+      assertThat(engineTwo.getException()).isInstanceOf(OptimisticLockingException.class);", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc3NzU0Mg==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492777542", "bodyText": "Added additional assertions. As in the previous cases, this scenario covers the default configuration, when the commandRetries property is set to 0. In that case, even retryable commands fail, and report the CrdbTransactionRetryException to the caller.", "author": "koevskinikola", "createdAt": "2020-09-22T14:25:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5Njg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5Nzc4Nw==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492597787", "bodyText": "Please replace tabs with spaces so that it formats nicely in all environments.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T09:30:46Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/concurrency/ConcurrentHistoryCleanupUpdateOfFailingJobTest.java", "diffHunk": "@@ -36,6 +38,25 @@\n import org.junit.Test;\n import org.junit.rules.RuleChain;\n \n+/**\n+ * When CockroachDB is used, this test is ignored since this scenario behaves in a serialized manner there.\n+ * The HistoryCleanupJob retries are set first, and then the BootstrapCommand reconfigures\n+ * the HistoryCleanupJob, overwriting the retires and stack trace. The following diagram explains this\n+ * in more detail:\n+ *\n+ * TX1 (job retries)   \t\t\t      |\tTX2 (Bootstrap command)\n+ * ------------------------------------------------------------------------------------------------------\n+ * READ HistoryCleanupJob    \t\t\t|\n+ * WRITE Job Retries              |\n+ *     ---> CRDB TX Write Intent\t|\t-> READ (check for HistoryCleanupJob) -> CRDB TX Block\n+ * Thread SYNC\t\t\t\t\t\t\t\t\t  |\n+ * COMMIT\t\t\t\t\t\t\t\t\t        |   -> CRDB TX Unblock\n+ * \t\t\t\t\t\t\t\t          \t\t\t|   Continue regular execution to reconfigure HistoryCleanupJob\n+ * \t\t\t\t\t\t\t\t          \t\t\t|     * Set default retries (3)\n+ * \t\t\t\t\t\t\t\t          \t\t\t|     * Clear exception stacktrace\n+ *\n+ */", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5ODcwMQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492598701", "bodyText": "Same here, what's the value of the test if the code under test behaves differently than in practice? There are more occurrences of this pattern, I will not mark all.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T09:32:18Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/concurrency/ConcurrentHistoryLevelTest.java", "diffHunk": "@@ -69,8 +73,15 @@ public void test() throws InterruptedException {\n     thread2.waitForSync();\n     thread2.waitUntilDone();\n \n-    assertNull(thread1.exception);\n-    assertNull(thread2.exception);\n+    assertNull(thread1.getException());\n+    Throwable thread2Exception = thread2.getException();\n+    if (testRule.isOptimisticLockingExceptionSuppressible()) {\n+      assertNull(thread2Exception);\n+    } else {\n+      // on CRDB, the pessimistic lock is disabled and the concurrent transaction\n+      // with fail with a CrdbTransactionRetryException and will need to be retried\n+      assertThat(thread2Exception).isInstanceOf(CrdbTransactionRetryException.class);", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc5OTMzNQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492799335", "bodyText": "As in the previous cases, this scenario covers the default configuration, when the commandRetries property is set to 0. In that case, even retryable commands fail, and report the CrdbTransactionRetryException to the caller.", "author": "koevskinikola", "createdAt": "2020-09-22T14:51:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5ODcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5OTU3Mg==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492599572", "bodyText": "Please complete or remove this.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T09:33:55Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/concurrency/ConcurrentJobExecutorTest.java", "diffHunk": "@@ -60,8 +62,13 @@\n import org.slf4j.Logger;\n \n /**\n- * @author Thorben Lindhauer\n+ * This test covers the behavior of two competing JobAcquisition threads.\n+ *\n+ * In the test:\n+ * 1. The first JobAcquisition thread is started.\n+ * 1.1.", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1NDk5Nw==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492754997", "bodyText": "I removed it, the test case scenarios are understandable from the code comments.", "author": "koevskinikola", "createdAt": "2020-09-22T13:56:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5OTU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMjM4NA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492602384", "bodyText": "This is unused code.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T09:38:37Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/concurrency/ControllableThread.java", "diffHunk": "@@ -77,4 +72,15 @@ public synchronized void proceedAndWaitTillDone() {\n       e.printStackTrace();\n     }\n   }\n+  \n+\n+  public synchronized void proceedAndWaitForSync() {\n+    LOG.debug(\"test thread will notify \"+getName()+\" and wait until it completes\");\n+    notify();\n+    try {\n+      wait();\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();\n+    }\n+  }", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1NTk3OQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492755979", "bodyText": "Removed.", "author": "koevskinikola", "createdAt": "2020-09-22T13:57:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMjM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNDY5OQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492604699", "bodyText": "This is a bit misleading, because the failure in the test is not provoked by a concurrent update.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T09:42:42Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/concurrency/TransactionIsolationSerializableTest.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.concurrency;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.Collections;\n+\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.impl.db.sql.DbSqlSessionFactory;\n+import org.camunda.bpm.engine.impl.interceptor.CommandContext;\n+import org.camunda.bpm.engine.impl.test.RequiredDatabase;\n+import org.camunda.bpm.engine.runtime.VariableInstance;\n+import org.camunda.bpm.engine.test.Deployment;\n+import org.camunda.bpm.engine.test.RequiredHistoryLevel;\n+import org.junit.Test;\n+\n+/**\n+ * We only test Serializable Transaction Isolation on CockroachDB.\n+ */\n+@RequiredHistoryLevel(ProcessEngineConfiguration.HISTORY_ACTIVITY)\n+@RequiredDatabase(includes = DbSqlSessionFactory.CRDB)\n+public class TransactionIsolationSerializableTest extends ConcurrencyTestCase {\n+\n+  protected static final String PROC_DEF_KEY = \"oneTaskProcess\";\n+  protected static final String VAR_NAME = \"testVariableName\";\n+  protected static final String VAR_INIT_VAL = \"initialValue\";\n+  protected static final String VAR_FIRST_VAL = \"firstValue\";\n+  protected static final String VAR_SECOND_VAL = \"secondValue\";\n+\n+  /**\n+   * In this test, we run two transactions concurrently.\n+   * The transactions have the following behavior:\n+   *\n+   * (1) READ row from a table\n+   * (2) WRITE (update) the row from that table\n+   *\n+   * We execute it with two threads in the following interleaving:\n+   *\n+   *      Thread 1             Thread 2\n+   *      ========             ========\n+   * ------READ---------------------------\n+   * ---------------------------READ------\n+   * ------WRITE--------------------------\n+   * ---------------------------WRITE----- | FAILS due to concurrent update\n+   *\n+   * Data may become inconsistent if transactions are not ordered properly\n+   */\n+  @Test\n+  @Deployment(resources = \"org/camunda/bpm/engine/test/concurrency/oneTaskProcess.bpmn20.xml\")\n+  public void shouldHandleConcurrentWriteConflictWithTX2Failure() {\n+    // given\n+    String processInstanceId = runtimeService\n+        .startProcessInstanceByKey(PROC_DEF_KEY, Collections.singletonMap(VAR_NAME, VAR_INIT_VAL))\n+        .getId();\n+    ThreadControl updateVarThread1 = executeControllableCommand(\n+        new ControllableVariableWriteCommand(processInstanceId, VAR_FIRST_VAL));\n+    updateVarThread1.waitForSync();\n+    updateVarThread1.reportInterrupts();\n+    ThreadControl updateVarThread2 = executeControllableCommand(\n+        new ControllableVariableWriteCommand(processInstanceId, VAR_SECOND_VAL));\n+    updateVarThread2.waitForSync();\n+    updateVarThread2.reportInterrupts();\n+\n+    // the first thread updates the variable and flushes the changes\n+    updateVarThread1.makeContinue();\n+    updateVarThread1.waitUntilDone();\n+\n+    // when\n+    // the second thread attempts to update the variable\n+    updateVarThread2.makeContinue();\n+    updateVarThread2.waitUntilDone();\n+\n+    // then\n+    // a exception is expected with a `TransactionRetryWithProtoRefreshError` as the cause\n+    assertThat(updateVarThread2.getException().getCause().getMessage())\n+        .containsIgnoringCase(\"TransactionRetryWithProtoRefreshError\");\n+    VariableInstance var = runtimeService.createVariableInstanceQuery().variableName(VAR_NAME).singleResult();\n+    assertThat(var.getValue()).isEqualTo(VAR_FIRST_VAL);\n+  }\n+\n+  /**\n+   * In this test, we run two transactions concurrently.\n+   * The transactions have the following behavior:\n+   *\n+   * (1) READ row from a table\n+   * (2) WRITE (update) the row from that table\n+   *\n+   * We execute it with two threads in the following interleaving:\n+   *\n+   *      Thread 1             Thread 2\n+   *      ========             ========\n+   * ------READ---------------------------\n+   * ---------------------------READ------\n+   * ------WRITE-------------------------- | FAILS due to concurrent update", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc4NTM0Mg==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492785342", "bodyText": "Updated to FAILS due to an unrelated, runtime error and is rolled back.", "author": "koevskinikola", "createdAt": "2020-09-22T14:34:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNDY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxMDkzNA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492610934", "bodyText": "Like this, the test does not assert that the schema log entry for a new CockroachDB instance is correct; the fix should instead assume that the current minor version is the expected version if there are no update scripts (=> careful: the .0 must be hardcoded or else it will break as soon as we build a first patch)", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T09:53:22Z", "path": "engine/src/test/java/org/camunda/bpm/engine/test/standalone/db/SchemaLogEnsureSqlScriptTest.java", "diffHunk": "@@ -55,7 +55,11 @@ public void ensureUpgradeScriptsUpdateSchemaLogVersion() {\n         scriptsForDB.add(file);\n       }\n     }\n-    assertThat(getLatestTargetVersion(scriptsForDB), is(currentSchemaVersion));\n+\n+    // exclude databases that are newly added\n+    if (!scriptsForDB.isEmpty()) {\n+      assertThat(getLatestTargetVersion(scriptsForDB), is(currentSchemaVersion));\n+    }", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA5MTY3Ng==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r494091676", "bodyText": "By this, careful: the .0 must be hardcoded or else it will break as soon as we build a first patch), I assume you meant if we build a (first) patch that doesn't contain an upgrade script, as the Schema log entry will remain on the previous (minor) version.\nI solved this by getting the minor version from the projects pom.xml, through a *.properties file, patch versions are removed, and a .0 is appended.", "author": "koevskinikola", "createdAt": "2020-09-24T07:20:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxMDkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxMzEwNA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492613104", "bodyText": "It looks like this is missing for MariaDB/MySQL", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T09:57:12Z", "path": "engine/src/main/java/org/camunda/bpm/engine/impl/db/sql/DbSqlSessionFactory.java", "diffHunk": "@@ -253,98 +257,106 @@\n     }\n \n     // postgres specific\n-    databaseSpecificLimitBeforeStatements.put(POSTGRES, \"\");\n-    optimizeDatabaseSpecificLimitBeforeWithoutOffsetStatements.put(POSTGRES, \"\");\n-    databaseSpecificLimitAfterStatements.put(POSTGRES, \"LIMIT #{maxResults} OFFSET #{firstResult}\");\n-    optimizeDatabaseSpecificLimitAfterWithoutOffsetStatements.put(POSTGRES, \"LIMIT #{maxResults}\");\n-    databaseSpecificLimitBeforeWithoutOffsetStatements.put(POSTGRES, \"\");\n-    databaseSpecificLimitAfterWithoutOffsetStatements.put(POSTGRES, \"LIMIT #{maxResults}\");\n-    databaseSpecificInnerLimitAfterStatements.put(POSTGRES, databaseSpecificLimitAfterStatements.get(POSTGRES));\n-    databaseSpecificLimitBetweenStatements.put(POSTGRES, \"\");\n-    databaseSpecificLimitBetweenFilterStatements.put(POSTGRES, \"\");\n-    databaseSpecificLimitBetweenAcquisitionStatements.put(POSTGRES, \"\");\n-    databaseSpecificOrderByStatements.put(POSTGRES, defaultOrderBy);\n-    databaseSpecificLimitBeforeNativeQueryStatements.put(POSTGRES, \"\");\n-    databaseSpecificDistinct.put(POSTGRES, \"distinct\");\n-\n-    databaseSpecificCountDistinctBeforeStart.put(POSTGRES, \"SELECT COUNT(*) FROM (SELECT DISTINCT\");\n-    databaseSpecificCountDistinctBeforeEnd.put(POSTGRES, \"\");\n-    databaseSpecificCountDistinctAfterEnd.put(POSTGRES, \") countDistinct\");\n-\n-    databaseSpecificEscapeChar.put(POSTGRES, defaultEscapeChar);\n-\n-    databaseSpecificBitAnd1.put(POSTGRES, \"\");\n-    databaseSpecificBitAnd2.put(POSTGRES, \" & \");\n-    databaseSpecificBitAnd3.put(POSTGRES, \"\");\n-    databaseSpecificDatepart1.put(POSTGRES, \"extract(\");\n-    databaseSpecificDatepart2.put(POSTGRES, \" from \");\n-    databaseSpecificDatepart3.put(POSTGRES, \")\");\n-\n-    databaseSpecificDummyTable.put(POSTGRES, \"\");\n-    databaseSpecificTrueConstant.put(POSTGRES, \"true\");\n-    databaseSpecificFalseConstant.put(POSTGRES, \"false\");\n-    databaseSpecificIfNull.put(POSTGRES, \"COALESCE\");\n+    // use the same specific for cockroachdb since it supports the postgres wire protocol\n+    for (String postgresLikeDatabase : Arrays.asList(POSTGRES, CRDB)) {\n+      databaseSpecificLimitBeforeStatements.put(postgresLikeDatabase, \"\");\n+      optimizeDatabaseSpecificLimitBeforeWithoutOffsetStatements.put(postgresLikeDatabase, \"\");\n+      databaseSpecificLimitAfterStatements.put(postgresLikeDatabase, \"LIMIT #{maxResults} OFFSET #{firstResult}\");\n+      optimizeDatabaseSpecificLimitAfterWithoutOffsetStatements.put(postgresLikeDatabase, \"LIMIT #{maxResults}\");\n+      databaseSpecificLimitBeforeWithoutOffsetStatements.put(postgresLikeDatabase, \"\");\n+      databaseSpecificLimitAfterWithoutOffsetStatements.put(postgresLikeDatabase, \"LIMIT #{maxResults}\");\n+      databaseSpecificInnerLimitAfterStatements.put(postgresLikeDatabase, databaseSpecificLimitAfterStatements.get(POSTGRES));\n+      databaseSpecificLimitBetweenStatements.put(postgresLikeDatabase, \"\");\n+      databaseSpecificLimitBetweenFilterStatements.put(postgresLikeDatabase, \"\");\n+      databaseSpecificLimitBetweenAcquisitionStatements.put(postgresLikeDatabase, \"\");\n+      databaseSpecificOrderByStatements.put(postgresLikeDatabase, defaultOrderBy);\n+      databaseSpecificLimitBeforeNativeQueryStatements.put(postgresLikeDatabase, \"\");\n+      databaseSpecificDistinct.put(postgresLikeDatabase, \"distinct\");\n+\n+      databaseSpecificCountDistinctBeforeStart.put(postgresLikeDatabase, \"SELECT COUNT(*) FROM (SELECT DISTINCT\");\n+      databaseSpecificCountDistinctBeforeEnd.put(postgresLikeDatabase, \"\");\n+      databaseSpecificCountDistinctAfterEnd.put(postgresLikeDatabase, \") countDistinct\");\n+\n+      databaseSpecificEscapeChar.put(postgresLikeDatabase, defaultEscapeChar);\n+\n+      databaseSpecificBitAnd1.put(postgresLikeDatabase, \"\");\n+      databaseSpecificBitAnd2.put(postgresLikeDatabase, \" & \");\n+      databaseSpecificBitAnd3.put(postgresLikeDatabase, \"\");\n+      databaseSpecificDatepart1.put(postgresLikeDatabase, \"extract(\");\n+      databaseSpecificDatepart2.put(postgresLikeDatabase, \" from \");\n+      databaseSpecificDatepart3.put(postgresLikeDatabase, \")\");\n+\n+      databaseSpecificDummyTable.put(postgresLikeDatabase, \"\");\n+      databaseSpecificTrueConstant.put(postgresLikeDatabase, \"true\");\n+      databaseSpecificFalseConstant.put(postgresLikeDatabase, \"false\");\n+      databaseSpecificIfNull.put(postgresLikeDatabase, \"COALESCE\");\n+\n+      databaseSpecificCollationForCaseSensitivity.put(postgresLikeDatabase, \"\");\n+\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"insertByteArray\", \"insertByteArray_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"updateByteArray\", \"updateByteArray_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectByteArray\", \"selectByteArray_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectByteArrays\", \"selectByteArrays_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectResourceByDeploymentIdAndResourceName\", \"selectResourceByDeploymentIdAndResourceName_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectResourceByDeploymentIdAndResourceNames\", \"selectResourceByDeploymentIdAndResourceNames_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectResourceByDeploymentIdAndResourceId\", \"selectResourceByDeploymentIdAndResourceId_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectResourceByDeploymentIdAndResourceIds\", \"selectResourceByDeploymentIdAndResourceIds_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectResourcesByDeploymentId\", \"selectResourcesByDeploymentId_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectResourceById\", \"selectResourceById_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectLatestResourcesByDeploymentName\", \"selectLatestResourcesByDeploymentName_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"insertIdentityInfo\", \"insertIdentityInfo_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"updateIdentityInfo\", \"updateIdentityInfo_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectIdentityInfoById\", \"selectIdentityInfoById_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectIdentityInfoByUserIdAndKey\", \"selectIdentityInfoByUserIdAndKey_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectIdentityInfoByUserId\", \"selectIdentityInfoByUserId_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectIdentityInfoDetails\", \"selectIdentityInfoDetails_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"insertComment\", \"insertComment_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectCommentsByTaskId\", \"selectCommentsByTaskId_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectCommentsByProcessInstanceId\", \"selectCommentsByProcessInstanceId_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectCommentByTaskIdAndCommentId\", \"selectCommentByTaskIdAndCommentId_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectEventsByTaskId\", \"selectEventsByTaskId_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectFilterByQueryCriteria\", \"selectFilterByQueryCriteria_postgres\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"selectFilter\", \"selectFilter_postgres\");\n+\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"deleteAttachmentsByRemovalTime\", \"deleteAttachmentsByRemovalTime_postgres_or_db2\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"deleteCommentsByRemovalTime\", \"deleteCommentsByRemovalTime_postgres_or_db2\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"deleteHistoricActivityInstancesByRemovalTime\", \"deleteHistoricActivityInstancesByRemovalTime_postgres_or_db2\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"deleteHistoricDecisionInputInstancesByRemovalTime\", \"deleteHistoricDecisionInputInstancesByRemovalTime_postgres_or_db2\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"deleteHistoricDecisionInstancesByRemovalTime\", \"deleteHistoricDecisionInstancesByRemovalTime_postgres_or_db2\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"deleteHistoricDecisionOutputInstancesByRemovalTime\", \"deleteHistoricDecisionOutputInstancesByRemovalTime_postgres_or_db2\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"deleteHistoricDetailsByRemovalTime\", \"deleteHistoricDetailsByRemovalTime_postgres_or_db2\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"deleteExternalTaskLogByRemovalTime\", \"deleteExternalTaskLogByRemovalTime_postgres_or_db2\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"deleteHistoricIdentityLinkLogByRemovalTime\", \"deleteHistoricIdentityLinkLogByRemovalTime_postgres_or_db2\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"deleteHistoricIncidentsByRemovalTime\", \"deleteHistoricIncidentsByRemovalTime_postgres_or_db2\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"deleteJobLogByRemovalTime\", \"deleteJobLogByRemovalTime_postgres_or_db2\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"deleteHistoricProcessInstancesByRemovalTime\", \"deleteHistoricProcessInstancesByRemovalTime_postgres_or_db2\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"deleteHistoricTaskInstancesByRemovalTime\", \"deleteHistoricTaskInstancesByRemovalTime_postgres_or_db2\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"deleteHistoricVariableInstancesByRemovalTime\", \"deleteHistoricVariableInstancesByRemovalTime_postgres_or_db2\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"deleteUserOperationLogByRemovalTime\", \"deleteUserOperationLogByRemovalTime_postgres_or_db2\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"deleteByteArraysByRemovalTime\", \"deleteByteArraysByRemovalTime_postgres_or_db2\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"deleteHistoricBatchesByRemovalTime\", \"deleteHistoricBatchesByRemovalTime_postgres_or_db2\");\n+      addDatabaseSpecificStatement(postgresLikeDatabase, \"deleteAuthorizationsByRemovalTime\", \"deleteAuthorizationsByRemovalTime_postgres_or_db2\");\n \n+      constants = new HashMap<>();\n+      constants.put(\"constant.event\", \"'event'\");\n+      constants.put(\"constant.op_message\", \"NEW_VALUE_ || '_|_' || PROPERTY_\");\n+      constants.put(\"constant_for_update\", \"for update\");\n+      constants.put(\"constant.datepart.quarter\", \"QUARTER\");\n+      constants.put(\"constant.datepart.month\", \"MONTH\");\n+      constants.put(\"constant.datepart.minute\", \"MINUTE\");\n+      constants.put(\"constant.null.startTime\", \"null START_TIME_\");\n+      constants.put(\"constant.varchar.cast\", \"cast('${key}' as varchar(64))\");\n+      constants.put(\"constant.integer.cast\", \"cast(NULL as integer)\");\n+      constants.put(\"constant.null.reporter\", \"CAST(NULL AS VARCHAR) AS REPORTER_\");\n+      dbSpecificConstants.put(postgresLikeDatabase, constants);\n+    }\n     databaseSpecificDaysComparator.put(POSTGRES, \"EXTRACT (DAY FROM #{currentTimestamp} - ${date}) >= ${days}\");\n+    databaseSpecificNumericCast.put(POSTGRES, \"\");", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgwMTM5Mw==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492801393", "bodyText": "Added.", "author": "koevskinikola", "createdAt": "2020-09-22T14:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxMzEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxNDI3OQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492614279", "bodyText": "I assume this exists only to make the Spring test work. This is way too complex in my opinion just to make it possible to plug in the retry interceptor even when it is not CockroachDB and would be rather cumbersome to understand and use by anyone who finds it. Can we find a simpler solution?", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T09:59:12Z", "path": "engine/src/main/java/org/camunda/bpm/engine/CrdbIntegrationProvider.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine;\n+\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.db.sql.DbSqlSessionFactory;\n+import org.camunda.bpm.engine.impl.interceptor.Command;\n+import org.camunda.bpm.engine.impl.interceptor.CrdbTransactionRetryInterceptor;\n+\n+public interface CrdbIntegrationProvider {", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcxNDU5Nw==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492714597", "bodyText": "Adding to this: When running Cockpit with CRDB, we currently get a NullPointerException. Root cause: Cockpit has a subclass of StandaloneProcessEngineConfiguration  called org.camunda.bpm.cockpit.impl.db.QuerySessionFactory and this has a method initFromProcessEngineConfiguration that is supposed to copy over the values from a given process engine configuration. The integration provider is not copied here, so the retry interceptor cannot be instantiated.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T13:02:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxNDI3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcxNTEyOQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492715129", "bodyText": "Relevant stacktrace snippet:\njava.lang.NullPointerException\n\tat org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl.getCrdbRetryInterceptor(ProcessEngineConfigurationImpl.java:4912)\n\tat org.camunda.bpm.engine.impl.cfg.StandaloneProcessEngineConfiguration.getDefaultCommandInterceptorsTxRequired(StandaloneProcessEngineConfiguration.java:44)\n\tat org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl.initCommandInterceptorsTxRequired(ProcessEngineConfigurationImpl.java:1374)\n\tat org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl.initCommandExecutors(ProcessEngineConfigurationImpl.java:1356)\n\tat org.camunda.bpm.cockpit.impl.db.QuerySessionFactory.initFromProcessEngineConfiguration(QuerySessionFactory.java:73)\n\tat org.camunda.bpm.cockpit.impl.db.CommandExecutorImpl.<init>(CommandExecutorImpl.java:38)\n\tat org.camunda.bpm.cockpit.impl.DefaultCockpitRuntimeDelegate.createCommandExecutor(DefaultCockpitRuntimeDelegate.java:114)\n\tat org.camunda.bpm.cockpit.impl.DefaultCockpitRuntimeDelegate.getCommandExecutor(DefaultCockpitRuntimeDelegate.java:66)\n\tat org.camunda.bpm.cockpit.Cockpit.getCommandExecutor(Cockpit.java:59)\n\tat org.camunda.bpm.cockpit.plugin.resource.AbstractCockpitPluginResource.getCommandExecutor(AbstractCockpitPluginResource.java:53)\n\tat org.camunda.bpm.cockpit.impl.plugin.resources.ProcessInstanceRestService.queryProcessInstancesCount(ProcessInstanceRestService.java:106)", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T13:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxNDI3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU3MzIwMg==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r493573202", "bodyText": "As discussed, I will remove the CrdbIntegrationProvider (and all of it's uses), and will refactor the CrdbTransactionIntegrationTest to include a the CrdbTransactionRetryInterceptor as a custom interceptor. The order of interceptors will remain the same as in the default implementation.", "author": "koevskinikola", "createdAt": "2020-09-23T13:13:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxNDI3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxNDU1Ng==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492614556", "bodyText": "This method is not consistently used by all engine configuration classes (standalone, jta, spring).", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T09:59:40Z", "path": "engine/src/main/java/org/camunda/bpm/engine/CrdbIntegrationProvider.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine;\n+\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.db.sql.DbSqlSessionFactory;\n+import org.camunda.bpm.engine.impl.interceptor.Command;\n+import org.camunda.bpm.engine.impl.interceptor.CrdbTransactionRetryInterceptor;\n+\n+public interface CrdbIntegrationProvider {\n+\n+  /**\n+   * This method determines if a {@link CrdbTransactionRetryInterceptor} needs to be registered\n+   * for the current Process Engine. By default, it will only be true when CockroachDB is used.\n+   *\n+   * @param configuration - the {@link ProcessEngineConfiguration} instance where\n+   *                      the {@link CrdbTransactionRetryInterceptor} needs to be registered.\n+   * @return true, if the interceptor should be registered. Otherwise, it is false.\n+   */\n+  default boolean registerCrdbRetryInterceptor(ProcessEngineConfiguration configuration) {\n+    return DbSqlSessionFactory.CRDB.equals(configuration.getDatabaseType());\n+  };\n+\n+  /**\n+   *\n+   * @param commandRetries - the number of Command retries the {@link CrdbTransactionRetryInterceptor}\n+   *                       is allowed to perform. This parameter is provided by the {@link ProcessEngineConfigurationImpl}\n+   *                       instance, when this method is invoked.\n+   * @return an object that is an implementation of the {@link CrdbTransactionRetryInterceptor}.\n+   */\n+  default CrdbTransactionRetryInterceptor getCrdbRetryInterceptor(int commandRetries){\n+    return new CrdbTransactionRetryInterceptor(commandRetries);\n+  };", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU3Mzc3NA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r493573774", "bodyText": "I will remove the CrdbIntegrationProvider completely.", "author": "koevskinikola", "createdAt": "2020-09-23T13:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxNDU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxNTE1OA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492615158", "bodyText": "Let's move the retry interceptor to be the first one in the chain, so that we get logging once per command retry. Same applies to the other engine configurations.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T10:00:38Z", "path": "engine/src/main/java/org/camunda/bpm/engine/impl/cfg/StandaloneProcessEngineConfiguration.java", "diffHunk": "@@ -38,7 +39,13 @@\n     defaultCommandInterceptorsTxRequired.add(new LogInterceptor());\n     defaultCommandInterceptorsTxRequired.add(new CommandCounterInterceptor(this));\n     defaultCommandInterceptorsTxRequired.add(new ProcessApplicationContextInterceptor(this));\n+\n+    if (DbSqlSessionFactory.CRDB.equals(databaseType)) {\n+      defaultCommandInterceptorsTxRequired.add(getCrdbRetryInterceptor());\n+    }", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgwNjExOA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492806118", "bodyText": "Refactored and mirrored in the Spring and JTA configurations.", "author": "koevskinikola", "createdAt": "2020-09-22T14:59:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxNTE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxNTg1MQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492615851", "bodyText": "Please remove/resolve this.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T10:01:51Z", "path": "engine/src/main/java/org/camunda/bpm/engine/impl/db/entitymanager/DbEntityManager.java", "diffHunk": "@@ -388,28 +403,63 @@ public void flushEntity(DbEntity entity) {\n    * @throws OptimisticLockingException if there is no handler for the failure\n    */\n   protected void handleConcurrentModification(DbOperation dbOperation) {\n-    boolean isHandled = false;\n+    OptimisticLockingResult handlingResult = invokeOptimisticLockingListeners(dbOperation);\n+\n+    if (OptimisticLockingResult.THROW.equals(handlingResult)\n+        && canIgnoreHistoryModificationFailure(dbOperation)) {\n+        handlingResult = OptimisticLockingResult.IGNORE;\n+    }\n+\n+    switch (handlingResult) {\n+      case IGNORE:\n+        break;\n+      case THROW:\n+      default:\n+        throw LOG.concurrentUpdateDbEntityException(dbOperation);\n+    }\n+  }\n+  \n+  protected void handleConcurrentModificationCrdb(DbOperation dbOperation) {\n+    OptimisticLockingResult handlingResult = invokeOptimisticLockingListeners(dbOperation);\n+    \n+    if (OptimisticLockingResult.IGNORE.equals(handlingResult)) {\n+      LOG.crdbFailureIgnored(dbOperation);\n+    }\n+    \n+    // CRDB concurrent modification exceptions always lead to the transaction\n+    // being aborted, so we must always throw an exception.\n+    \n+    // TODO: hand in root cause", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc5NDkzNg==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492794936", "bodyText": "Removed, the failue cause is obtained by calling operation.getFailure() inside the EnginePersistenceLogger#crdbTransactionRetryException() method.", "author": "koevskinikola", "createdAt": "2020-09-22T14:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxNTg1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxNzI2OA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492617268", "bodyText": "This is one out of multiple SELECT methods in this class, but only here we have this treatment. We should implement it everywhere or nowhere. If we go with everywhere, have a look at the latest changes on master and the exception wrapping that has been introduced around all mybatis interactions. In the end, make sure that these exceptions actually bubble up to the command and are not wrapped in more generic ProcessEngineExceptions (or else the user or retry interceptor won't be able to act on them).", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T10:04:37Z", "path": "engine/src/main/java/org/camunda/bpm/engine/impl/db/entitymanager/DbEntityManager.java", "diffHunk": "@@ -178,8 +179,19 @@ public List selectListWithRawParameter(String statement, Object parameter, int f\n     if(firstResult == -1 ||  maxResults==-1) {\n       return Collections.EMPTY_LIST;\n     }\n-    List loadedObjects = persistenceSession.selectList(statement, parameter);\n-    return filterLoadedObjects(loadedObjects);\n+    try {\n+\n+      List loadedObjects = persistenceSession.selectList(statement, parameter);\n+      return filterLoadedObjects(loadedObjects);\n+    } catch (Exception e) {\n+\n+      if (DbSqlSession.isCrdbConcurrencyConflict(e)) {\n+        // on CRDB, selects might fail with an OLE and the transaction must be retried.\n+        throw LOG.crdbTransactionRetryExceptionOnSelect(e);\n+      }", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEwMjU4Ng==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r494102586", "bodyText": "I removed this, as this impacted Exclusive Message Correlation, which we concluded that is not supported on CRDB. Ticket CAM-12490 tracks the issue.", "author": "koevskinikola", "createdAt": "2020-09-24T07:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxNzI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxNzQ1NQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492617455", "bodyText": "There is no class ProcessEnginePersistenceException", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T10:04:58Z", "path": "engine/src/main/java/org/camunda/bpm/engine/impl/util/ExceptionUtil.java", "diffHunk": "@@ -181,6 +181,23 @@ public static boolean checkVariableIntegrityViolation(Throwable cause) {\n     return false;\n   }\n \n+  public static Boolean checkCrdbTransactionRetryException(Throwable cause) {\n+    List<SQLException> relatedSqlExceptions = findRelatedSqlExceptions(cause);\n+    for (SQLException exception : relatedSqlExceptions) {\n+      String errorMessage = exception.getMessage().toLowerCase();\n+      int errorCode = exception.getErrorCode();\n+      if ((errorCode == 40001 || errorMessage != null)\n+          && (errorMessage.contains(\"restart transaction\") || errorMessage.contains(\"retry txn\"))\n+          // TX retry errors with RETRY_COMMIT_DEADLINE_EXCEEDED are handled\n+          // as a ProcessEnginePersistenceException due to a long-running transaction", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2NTczMg==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r493465732", "bodyText": "I clarified the comment. The exception is ProcessEngineException (cause: Process engine persistence exception)", "author": "koevskinikola", "createdAt": "2020-09-23T11:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxNzQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxODQ1OA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492618458", "bodyText": "This should be implemented in DbSqlSession#lock to have it in one place and not repeated for every usage of pessimistic locks.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T10:06:47Z", "path": "engine/src/main/java/org/camunda/bpm/engine/impl/cmd/DeployCmd.java", "diffHunk": "@@ -186,7 +188,8 @@ protected DeploymentWithDefinitions doExecute(final CommandContext commandContex\n   }\n \n   protected void acquireExclusiveLock(CommandContext commandContext) {\n-    if (commandContext.getProcessEngineConfiguration().isDeploymentLockUsed()) {\n+    if (commandContext.getProcessEngineConfiguration().isDeploymentLockUsed()\n+        && !DatabaseUtil.checkDatabaseType(DbSqlSessionFactory.CRDB)) {", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ5NTIwNA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r493495204", "bodyText": "Refactored. Also added code comments to all retryable commands with explanations on why this command can be retried.", "author": "koevskinikola", "createdAt": "2020-09-23T11:50:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxODQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI5NTcwMA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r494295700", "bodyText": "Any particular reason you implemented this in DbEntityManager#lock instead of DbSqlSession#lock where we already do the check for H2?", "author": "ThorbenLindhauer", "createdAt": "2020-09-24T12:58:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxODQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM2Mjg0OQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r494362849", "bodyText": "Just because we use the PesistenceSession interface, so it means that it can be replaced with another implementation. On the other hand, the DbEntityManager class is always the same.", "author": "koevskinikola", "createdAt": "2020-09-24T14:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxODQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM3NTYyMg==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r494375622", "bodyText": "I'd prefer to have it in the DbSqlSession to be honest. It is very unlikely there will other be persistence session implementations for CRDB in the future. In contrast, by having this concern in a single place we reduce the code complexity for anyone who reads this until then.", "author": "ThorbenLindhauer", "createdAt": "2020-09-24T14:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxODQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM5NzgzNw==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r494397837", "bodyText": "Already done :)\nUPDATE: the change is actually wrong, I'll fix it with the upcoming commit.\nUPDATE 2: fixed with 1db52c5", "author": "koevskinikola", "createdAt": "2020-09-24T15:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxODQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxODczNQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492618735", "bodyText": "Why do we want to throw the exception in case of CockroachDB?", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T10:07:14Z", "path": "engine/src/main/java/org/camunda/bpm/engine/impl/ProcessEngineImpl.java", "diffHunk": "@@ -149,7 +151,15 @@ protected void executeSchemaOperations() {\n     try {\n       commandExecutorSchemaOperations.execute(processEngineConfiguration.getProcessEngineBootstrapCommand());\n     } catch (OptimisticLockingException ole) {\n+      // if an OLE occurred during the process engine bootstrap, we suppress it\n+      // since all the data has already been persisted by a previous process engine bootstrap\n       LOG.historyCleanupJobReconfigurationFailure(ole);\n+      String databaseType = this.getProcessEngineConfiguration().getDatabaseType();\n+      if (DbSqlSessionFactory.CRDB.equals(databaseType)) {\n+        // on CRDB, we want to re-throw the OLE to the caller\n+        // when the CRDB Command retries are exausted\n+        throw ole;", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyNDg4OA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492824888", "bodyText": "In the regular case, the catch block suppresses the OLE since the changes made by the concurrent transaction are acceptable, and the conflict can be ignored so that the Process Engine bootstrap can complete successfully.\nIn the CRDB case, if the BootstrapEngineCmd exausts the maximum number of commandRetries, we want to notify the caller that the Process Engine bootstrap failed since the transaction was aborted/rolled-back and must be manually retried.", "author": "koevskinikola", "createdAt": "2020-09-22T15:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxODczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxOTEwOQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r492619109", "bodyText": "This test succeeds regardless of the order of interceptors. I think we should additionally assert that the retries are run in separate transactions.", "author": "ThorbenLindhauer", "createdAt": "2020-09-22T10:07:54Z", "path": "engine-spring/core/src/test/java/org/camunda/bpm/engine/spring/test/transaction/crdb/CrdbTransactionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.spring.test.transaction.crdb;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.camunda.bpm.engine.CrdbTransactionRetryException;\n+import org.camunda.bpm.engine.HistoryService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.interceptor.Command;\n+import org.camunda.bpm.engine.impl.interceptor.CommandContext;\n+import org.camunda.bpm.engine.test.Deployment;\n+import org.camunda.bpm.engine.test.ProcessEngineRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+\n+/**\n+ * This tests simulates a CockroachDB concurrency error retry scenario, where the transaction\n+ * is managed by the Process Engine. Concurrency errors involved in external transaction\n+ * management setups are not tested since they should be handled by the app developer.\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@ContextConfiguration(locations = {\"classpath:org/camunda/bpm/engine/spring/test/transaction/\" +\n+    \"CrdbTransactionIntegrationTest-applicationContext.xml\"})\n+public class CrdbTransactionIntegrationTest {", "originalCommit": "95615d5112fc1e48334954937ab4d7dbd40582b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYxNjY4OA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/951#discussion_r493616688", "bodyText": "Done.", "author": "koevskinikola", "createdAt": "2020-09-23T14:00:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxOTEwOQ=="}], "type": "inlineReview"}, {"oid": "7440273864be1d6e543ad9990a5b22b34b9c3cea", "url": "https://github.com/camunda/camunda-bpm-platform/commit/7440273864be1d6e543ad9990a5b22b34b9c3cea", "message": "SQUASH ME:\n\n* Add more detailed code comments;\n* Remove redundant code comments and test methods;\n* Refactor test cases so that the CRDB usage scenario is clearer.\n* Fix new failing tests.\n* Add missing index.\n\nRelated to CAM-12071", "committedDate": "2020-09-24T08:17:12Z", "type": "forcePushed"}, {"oid": "d4910b18ce9183bf7f161672d759164411783b7b", "url": "https://github.com/camunda/camunda-bpm-platform/commit/d4910b18ce9183bf7f161672d759164411783b7b", "message": "feat(crdb): add cockroachdb in supported database list\n\n* Add a CRDB profile in Maven.\n* Add crdb to sql scripts module\n* Drop all foreign key constraints before dropping indexes. This is done since some foreign key constraints are also associated with indexes. CockroachDB considers this as a dependency and throws an error if the constraint is not removed first,\n* Drop unique indexes with a drop index cascade statement. A UNIQUE constraint in CRDB creates an index in the background. Similar to the point above, there is a dependency between the UNIQUE constraint and the index, so CRDB requires CASCADE to be used for removal of both.\n* Fix unique constraints in crdb.\n\nRelated to CAM-12071", "committedDate": "2020-09-25T12:34:32Z", "type": "commit"}, {"oid": "70b88dcc2f47723975dacc48aae4b25b78d4426d", "url": "https://github.com/camunda/camunda-bpm-platform/commit/70b88dcc2f47723975dacc48aae4b25b78d4426d", "message": "fix(crdb): make day extraction work with crdb\n\n* CRDB currently doesn't support EXTRACT (DAY from INTERVAL). Due to this, the History Cleanup is unable to find valid data for removal. Extracting the hours and obtaining the number of days manually fixes the problem.\n\nRelated to CAM-12071, CAM-12128", "committedDate": "2020-09-25T12:35:52Z", "type": "commit"}, {"oid": "cf2841104ef514708669ae0ca938493abf74f0c2", "url": "https://github.com/camunda/camunda-bpm-platform/commit/cf2841104ef514708669ae0ca938493abf74f0c2", "message": "fix(crdb): correct type mismatch in union queries\n\n* CRDB is more strict with data types in SQL UNION queries. In our statistics queries, we use UNION to join incidents with activity instance counts. However, CRDB casts (0) to INT, and the result of the SUM function to NUMERIC. This leads to a type mismatch error. Casting the (0) values to NUMERIC fixes the problem.\n\nRelated to CAM-12071, CAM-12160", "committedDate": "2020-09-25T12:35:53Z", "type": "commit"}, {"oid": "1f5d26e367dec9e930eef091d1c2654984c1dc08", "url": "https://github.com/camunda/camunda-bpm-platform/commit/1f5d26e367dec9e930eef091d1c2654984c1dc08", "message": "feat(engine): add crdb transaction retries handler\n\n* Add a mechanism to handle TransactionRetry exceptions generated by CRDB due to concurrent transactions.\n* Add a CommandContextInterceptor that will retry failing Commands when\n  run on CockroachDB.\n\nRelated to CAM-12071, CAM-12138", "committedDate": "2020-09-25T12:35:53Z", "type": "commit"}, {"oid": "deecf22aea413a340e6b59a1b0fbdca509dcb6bb", "url": "https://github.com/camunda/camunda-bpm-platform/commit/deecf22aea413a340e6b59a1b0fbdca509dcb6bb", "message": "chore(engine): make schema log test work for newly supported dbs\n\n* If support for a completely new DB is added, the test will obtain the minor version from the projects POM, and compare it with the schema log entry.\n\nRelated to CAM-12071", "committedDate": "2020-09-25T12:35:53Z", "type": "commit"}, {"oid": "42b8ff25bc1bbc814ce846cf17f2d4629a080027", "url": "https://github.com/camunda/camunda-bpm-platform/commit/42b8ff25bc1bbc814ce846cf17f2d4629a080027", "message": "feat(test): add crdb behavior tests, assertions and workarounds\n\n* Add CRDB workarounds for concurrency tests;\n* Add CRDB workarounds for metrics tests.\n* Adjust test for bootstraping process engine with a concurrent history cleanup job\n* Add tx retry exception on commit;\n* Convert CRDB exception on commit immediately;\n* Fixes BatchMigrationTest;\n* Avoids that we wrap an exception that occurred on the flush and that we already wrapped in an OLE;\n* Adjust job acquisition tests.\n\nRelated to CAM-12071", "committedDate": "2020-09-25T12:35:53Z", "type": "commit"}, {"oid": "5c0ee02c71231cef2747d9fceae60ef038b6e1b4", "url": "https://github.com/camunda/camunda-bpm-platform/commit/5c0ee02c71231cef2747d9fceae60ef038b6e1b4", "message": "chore(engine): ignore crdb tx timeout failing tests\n\n* Ignore tests in CRDB that cover the scenario of capped list size in Oracle/SqlServer;\n* Ensure that CRDB TXRetryExceptions, that are thrown due to a TX COMMIT_DEADLINE_EXCEEDED, are not caught by the TX Retry mechanism.\n\nRelated to CAM-12071, CAM-12159", "committedDate": "2020-09-25T12:37:02Z", "type": "commit"}, {"oid": "98fa4d863c14196e38663441fb55656ea56817a6", "url": "https://github.com/camunda/camunda-bpm-platform/commit/98fa4d863c14196e38663441fb55656ea56817a6", "message": "feat(engine): enable retryable commands\n\n* Add infrastructure to Command-related classes to accommodate CRDB Retries.\n* Enable retries for job acquisition and external task fetch&lock;\n* Refactor code for CRDB failure handling\n* In CRDB, an OptimisticLockingException may occur when a SELECT FOR\n  UPDATE is executed with a concurrent Message Correlation command. We\ntry to handle this on the same level as the rest of the OLE-handling\nlogic, in the DbEntityManager.\n\nRelated to CAM-12071, CAM-12138", "committedDate": "2020-09-25T12:39:15Z", "type": "commit"}, {"oid": "613768536c9e354947c7d63e85c1c6327e3b86d4", "url": "https://github.com/camunda/camunda-bpm-platform/commit/613768536c9e354947c7d63e85c1c6327e3b86d4", "message": "feat(engine): dissable pessimistic locks\n\n* Ensure process engine bootstrap is retriable;\n* Add CRDB Retries tests;\n* Add (CRDB) Serializable Transaction Isolation level tests;\n* Fix failing tests (due to disabled pessimistic locks on CRDB)\n* Refactor runtime code to get it review ready.\n\nRelated to CAM-12071, CAM-12232, CAM-12253", "committedDate": "2020-09-25T12:44:35Z", "type": "commit"}, {"oid": "054749c0e4fa37802e7eb632444bb5e9ad63ca07", "url": "https://github.com/camunda/camunda-bpm-platform/commit/054749c0e4fa37802e7eb632444bb5e9ad63ca07", "message": "chore(engine): exclude flaky tests on crdb\n\n* Exclude tests that randomly fail when run on CockroachDB due to the\n  slow execution of SQL queries on this database.\n\nRelated to CAM-12071, CAM-12461", "committedDate": "2020-09-25T12:46:29Z", "type": "commit"}, {"oid": "ba48ce272d6ba0fbc4aef27830cf6206ff984c25", "url": "https://github.com/camunda/camunda-bpm-platform/commit/ba48ce272d6ba0fbc4aef27830cf6206ff984c25", "message": "feat(spring): adjust exteranlly managed transaction integrations\n\nRelated to CAM-12071, CAM-12394", "committedDate": "2020-09-25T12:46:29Z", "type": "commit"}, {"oid": "ba48ce272d6ba0fbc4aef27830cf6206ff984c25", "url": "https://github.com/camunda/camunda-bpm-platform/commit/ba48ce272d6ba0fbc4aef27830cf6206ff984c25", "message": "feat(spring): adjust exteranlly managed transaction integrations\n\nRelated to CAM-12071, CAM-12394", "committedDate": "2020-09-25T12:46:29Z", "type": "forcePushed"}]}