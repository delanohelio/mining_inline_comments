{"pr_number": 664, "pr_title": "CAM-11346: feat(feel): port spin feel integration from  scala to java", "pr_createdAt": "2020-02-17T16:27:30Z", "pr_url": "https://github.com/camunda/camunda-bpm-platform/pull/664", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwOTE2MA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380809160", "bodyText": "We cannot use unprefixed scala classes due to shading => use camundajar.impl.scala... instead", "author": "tasso94", "createdAt": "2020-02-18T17:04:05Z", "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;", "originalCommit": "04109966910e194930c7e375dc0bb0a36615924d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI2MTE4MQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r381261181", "bodyText": "I'm using the converter only once, and I can do the same thing with the innerValueMapper, so I'll refactor the code like that and not use a Scala import.", "author": "koevskinikola", "createdAt": "2020-02-19T12:31:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwOTE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMDg3Mw==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380810873", "bodyText": "Lines of code must not exceed 100 characters", "author": "tasso94", "createdAt": "2020-02-18T17:06:49Z", "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());", "originalCommit": "04109966910e194930c7e375dc0bb0a36615924d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMTA4Nw==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380811087", "bodyText": "Lines of code must not exceed 100 characters", "author": "tasso94", "createdAt": "2020-02-18T17:07:12Z", "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {", "originalCommit": "04109966910e194930c7e375dc0bb0a36615924d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMTE5NA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380811194", "bodyText": "Lines of code must not exceed 100 characters", "author": "tasso94", "createdAt": "2020-02-18T17:07:23Z", "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {\n+    Map<String, Object> membersMap = new HashMap<>();\n+    String content = e.textContent().trim();\n+    if (!content.isEmpty()) {\n+      membersMap.put(\"$content\", new ValString(content));\n+    }\n+\n+    Map<String, ValString> attributes = e.attrs().stream().collect(toMap(attr -> spinXmlAttributeToKey(attr), attr -> new ValString(attr.value())));", "originalCommit": "04109966910e194930c7e375dc0bb0a36615924d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMTc5Nw==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380811797", "bodyText": "Isn't this::spinXmlAttributeToKey much more shorter and readable?", "author": "tasso94", "createdAt": "2020-02-18T17:08:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMTE5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI2MzA1Mg==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r381263052", "bodyText": "Yes, you're right, nice catch!", "author": "koevskinikola", "createdAt": "2020-02-19T12:35:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMTE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMjEzMg==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380812132", "bodyText": "Isn't this::nodeName much more shorter and readable?", "author": "tasso94", "createdAt": "2020-02-18T17:08:56Z", "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {\n+    Map<String, Object> membersMap = new HashMap<>();\n+    String content = e.textContent().trim();\n+    if (!content.isEmpty()) {\n+      membersMap.put(\"$content\", new ValString(content));\n+    }\n+\n+    Map<String, ValString> attributes = e.attrs().stream().collect(toMap(attr -> spinXmlAttributeToKey(attr), attr -> new ValString(attr.value())));\n+    if (!attributes.isEmpty()) {\n+      membersMap.putAll(attributes);\n+    }\n+\n+    Map<String, Val> childrenMap = e.childElements().stream()\n+     .collect(\n+       groupingBy(\n+         el -> nodeName(el),", "originalCommit": "04109966910e194930c7e375dc0bb0a36615924d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMjQzMw==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380812433", "bodyText": "Isn't Map.Entry::getKey much more shorter and readable?", "author": "tasso94", "createdAt": "2020-02-18T17:09:28Z", "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {\n+    Map<String, Object> membersMap = new HashMap<>();\n+    String content = e.textContent().trim();\n+    if (!content.isEmpty()) {\n+      membersMap.put(\"$content\", new ValString(content));\n+    }\n+\n+    Map<String, ValString> attributes = e.attrs().stream().collect(toMap(attr -> spinXmlAttributeToKey(attr), attr -> new ValString(attr.value())));\n+    if (!attributes.isEmpty()) {\n+      membersMap.putAll(attributes);\n+    }\n+\n+    Map<String, Val> childrenMap = e.childElements().stream()\n+     .collect(\n+       groupingBy(\n+         el -> nodeName(el),\n+         mapping(el -> spinXmlElementToVal(el, innerValueMapper), toList())\n+                 ))\n+     .entrySet().stream()\n+       .collect(toMap(entry -> entry.getKey(), entry -> {", "originalCommit": "04109966910e194930c7e375dc0bb0a36615924d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI2NzczNg==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r381267736", "bodyText": "Good catch, thanks! I keep forgetting about method references, I'll be more careful next time.", "author": "koevskinikola", "createdAt": "2020-02-19T12:46:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMjQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMjcwNw==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380812707", "bodyText": "We cannot use unprefixed scala classes due to shading => use camundajar.impl.scala... instead", "author": "tasso94", "createdAt": "2020-02-18T17:09:56Z", "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {\n+    Map<String, Object> membersMap = new HashMap<>();\n+    String content = e.textContent().trim();\n+    if (!content.isEmpty()) {\n+      membersMap.put(\"$content\", new ValString(content));\n+    }\n+\n+    Map<String, ValString> attributes = e.attrs().stream().collect(toMap(attr -> spinXmlAttributeToKey(attr), attr -> new ValString(attr.value())));\n+    if (!attributes.isEmpty()) {\n+      membersMap.putAll(attributes);\n+    }\n+\n+    Map<String, Val> childrenMap = e.childElements().stream()\n+     .collect(\n+       groupingBy(\n+         el -> nodeName(el),\n+         mapping(el -> spinXmlElementToVal(el, innerValueMapper), toList())\n+                 ))\n+     .entrySet().stream()\n+       .collect(toMap(entry -> entry.getKey(), entry -> {\n+         List<Val> valList = entry.getValue();\n+         if (!valList.isEmpty() && valList.size() > 1) {\n+           scala.collection.immutable.List<Val> vals = ListHasAsScala(valList).asScala().toList();", "originalCommit": "04109966910e194930c7e375dc0bb0a36615924d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI2OTEzOA==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r381269138", "bodyText": "Yes, as I mentioned here, I'll refactor the code, so that the import is not needed.", "author": "koevskinikola", "createdAt": "2020-02-19T12:49:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMjcwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxNDcyMw==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380814723", "bodyText": "Can we change the name of the class to SpinValueMapper?", "author": "tasso94", "createdAt": "2020-02-18T17:13:17Z", "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {", "originalCommit": "04109966910e194930c7e375dc0bb0a36615924d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI2MDQ4NQ==", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r381260485", "bodyText": "Sure, makes more sense without the prefix.", "author": "koevskinikola", "createdAt": "2020-02-19T12:29:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxNDcyMw=="}], "type": "inlineReview"}, {"oid": "2c020117145d020575eba409d3fb320f2b0eb394", "url": "https://github.com/camunda/camunda-bpm-platform/commit/2c020117145d020575eba409d3fb320f2b0eb394", "message": "feat(feel): port spin feel integration from  scala to java\n\n* Port the Spin Integration for the Scala FEEL Engine from Scala to Java;\n* Merge the FEEL Spin Integration module with the Spin Process Engine Plugin module;\n* Port Scala tests to JUnit and add additional integration tests to assert SPI functionality and correct Process/DMN Engine integration.\n\nRelated to CAM-11346", "committedDate": "2020-02-19T16:11:42Z", "type": "commit"}, {"oid": "2c020117145d020575eba409d3fb320f2b0eb394", "url": "https://github.com/camunda/camunda-bpm-platform/commit/2c020117145d020575eba409d3fb320f2b0eb394", "message": "feat(feel): port spin feel integration from  scala to java\n\n* Port the Spin Integration for the Scala FEEL Engine from Scala to Java;\n* Merge the FEEL Spin Integration module with the Spin Process Engine Plugin module;\n* Port Scala tests to JUnit and add additional integration tests to assert SPI functionality and correct Process/DMN Engine integration.\n\nRelated to CAM-11346", "committedDate": "2020-02-19T16:11:42Z", "type": "forcePushed"}]}