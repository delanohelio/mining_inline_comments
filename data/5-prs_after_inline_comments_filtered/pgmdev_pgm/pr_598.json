{"pr_number": 598, "pr_title": "Add an option for verbose stats at the end of the match", "pr_createdAt": "2020-08-07T22:01:13Z", "pr_url": "https://github.com/PGMDev/PGM/pull/598", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwNjgzMw==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r467306833", "bodyText": "Maybe instead of prettyMenu1 2 3 etc, you could make it more informative. For example\n1-> prettyMenu()\n2-> smallMenu()\n3 -> normalMenu()\nFeel free to use other names, but just so you get the general idea \ud83d\ude04", "author": "applenick", "createdAt": "2020-08-07T22:06:57Z", "path": "core/src/main/java/tc/oc/pgm/menu/InventoryMenuUtils.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package tc.oc.pgm.menu;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import net.kyori.text.TranslatableComponent;\n+import tc.oc.pgm.api.match.Match;\n+\n+/** A collection of some static methods for working with building {@link InventoryMenu}s */\n+// TODO: Abstract out adding a row for pagination?\n+public class InventoryMenuUtils {\n+\n+  /**\n+   * A {@link InventoryMenu} that fits any amount of {@link InventoryMenuItem}s\n+   *\n+   * @param match the match the inventory will exist in\n+   * @param title the title of the inventory\n+   * @param itemsWithoutSpaces a list of all {@link InventoryMenuItem}s that should be displayed on\n+   *     this menu\n+   * @return a pretty menu that fits any amount of {@link InventoryMenuItem}s\n+   */\n+  public static InventoryMenu prettyMenu1(", "originalCommit": "bd3eff27c3a31a4136d97a72ebfd046fca815b19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwNzQzMQ==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r467307431", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              InventoryMenu in;\n          \n          \n            \n            \n          \n          \n            \n              public FlySpeedTool(InventoryMenu in) {\n          \n          \n            \n                this.in = in;\n          \n          \n            \n              InventoryMenu menu;\n          \n          \n            \n            \n          \n          \n            \n              public FlySpeedTool(InventoryMenu menu) {\n          \n          \n            \n                this.menu = menu;", "author": "applenick", "createdAt": "2020-08-07T22:09:22Z", "path": "core/src/main/java/tc/oc/pgm/observers/tools/FlySpeedTool.java", "diffHunk": "@@ -17,6 +17,12 @@\n \n   private static String TRANSLATION_KEY = \"setting.flyspeed.\";\n \n+  InventoryMenu in;\n+\n+  public FlySpeedTool(InventoryMenu in) {\n+    this.in = in;", "originalCommit": "bd3eff27c3a31a4136d97a72ebfd046fca815b19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxNTk3NA==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r467315974", "bodyText": "Wops this is just code I forgot to remove", "author": "KingOfSquares", "createdAt": "2020-08-07T22:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwNzQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwNzU2MQ==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r467307561", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              final InventoryMenu in;\n          \n          \n            \n            \n          \n          \n            \n              public GamemodeTool(InventoryMenu in) {\n          \n          \n            \n                this.in = in;\n          \n          \n            \n              final InventoryMenu menu;\n          \n          \n            \n            \n          \n          \n            \n              public GamemodeTool(InventoryMenu menu) {\n          \n          \n            \n                this.menu = menu;", "author": "applenick", "createdAt": "2020-08-07T22:09:52Z", "path": "core/src/main/java/tc/oc/pgm/observers/tools/GamemodeTool.java", "diffHunk": "@@ -20,6 +20,12 @@\n \n public class GamemodeTool implements InventoryMenuItem {\n \n+  final InventoryMenu in;\n+\n+  public GamemodeTool(InventoryMenu in) {\n+    this.in = in;", "originalCommit": "bd3eff27c3a31a4136d97a72ebfd046fca815b19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxNTg5Mw==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r467315893", "bodyText": "Wops this is just code I forgot to remove", "author": "KingOfSquares", "createdAt": "2020-08-07T22:42:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwNzU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwNzY4Nw==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r467307687", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              final InventoryMenu in;\n          \n          \n            \n            \n          \n          \n            \n              public NightVisionTool(InventoryMenu in) {\n          \n          \n            \n                this.in = in;\n          \n          \n            \n              final InventoryMenu menu;\n          \n          \n            \n            \n          \n          \n            \n              public NightVisionTool(InventoryMenu menu) {\n          \n          \n            \n                this.menu = menu;", "author": "applenick", "createdAt": "2020-08-07T22:10:14Z", "path": "core/src/main/java/tc/oc/pgm/observers/tools/NightVisionTool.java", "diffHunk": "@@ -17,6 +17,12 @@\n \n public class NightVisionTool implements InventoryMenuItem {\n \n+  final InventoryMenu in;\n+\n+  public NightVisionTool(InventoryMenu in) {\n+    this.in = in;", "originalCommit": "bd3eff27c3a31a4136d97a72ebfd046fca815b19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxNTkxMQ==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r467315911", "bodyText": "Wops this is just code I forgot to remove", "author": "KingOfSquares", "createdAt": "2020-08-07T22:42:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwNzY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwNzgyNg==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r467307826", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              final InventoryMenu in;\n          \n          \n            \n            \n          \n          \n            \n              public VisibilityTool(InventoryMenu in) {\n          \n          \n            \n                this.in = in;\n          \n          \n            \n              final InventoryMenu menu;\n          \n          \n            \n            \n          \n          \n            \n              public VisibilityTool(InventoryMenu menu) {\n          \n          \n            \n                this.menu = menu;", "author": "applenick", "createdAt": "2020-08-07T22:10:39Z", "path": "core/src/main/java/tc/oc/pgm/observers/tools/VisibilityTool.java", "diffHunk": "@@ -18,6 +18,12 @@\n \n public class VisibilityTool implements InventoryMenuItem {\n \n+  final InventoryMenu in;\n+\n+  public VisibilityTool(InventoryMenu in) {\n+    this.in = in;", "originalCommit": "bd3eff27c3a31a4136d97a72ebfd046fca815b19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxNTk0NQ==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r467315945", "bodyText": "Wops this is just code I forgot to remove", "author": "KingOfSquares", "createdAt": "2020-08-07T22:42:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwNzgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwODkzNg==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r467308936", "bodyText": "Make RESET", "author": "applenick", "createdAt": "2020-08-07T22:14:52Z", "path": "core/src/main/java/tc/oc/pgm/stats/PlayerStatsInventoryMenuItem.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package tc.oc.pgm.stats;\n+\n+import static tc.oc.pgm.stats.StatsMatchModule.numberComponent;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import net.kyori.text.Component;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Material;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.inventory.ClickType;\n+import org.bukkit.inventory.ItemFlag;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.SkullMeta;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.menu.InventoryMenu;\n+import tc.oc.pgm.menu.InventoryMenuItem;\n+import tc.oc.pgm.util.text.TextTranslations;\n+\n+public class PlayerStatsInventoryMenuItem implements InventoryMenuItem {\n+\n+  private final MatchPlayer player;\n+  private final TextColor reset = TextColor.WHITE;", "originalCommit": "bd3eff27c3a31a4136d97a72ebfd046fca815b19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwOTEyMg==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r467309122", "bodyText": "Make RESET", "author": "applenick", "createdAt": "2020-08-07T22:15:30Z", "path": "core/src/main/java/tc/oc/pgm/stats/TeamInventoryMenuItem.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package tc.oc.pgm.stats;\n+\n+import static tc.oc.pgm.stats.StatsMatchModule.PlayerStats.statFormat;\n+import static tc.oc.pgm.stats.StatsMatchModule.numberComponent;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import net.kyori.text.Component;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Material;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.inventory.ClickType;\n+import org.bukkit.inventory.ItemFlag;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.menu.InventoryMenu;\n+import tc.oc.pgm.menu.InventoryMenuItem;\n+import tc.oc.pgm.menu.InventoryMenuUtils;\n+import tc.oc.pgm.util.bukkit.BukkitUtils;\n+import tc.oc.pgm.util.text.TextTranslations;\n+\n+public class TeamInventoryMenuItem implements InventoryMenuItem {\n+\n+  private final Competitor team;\n+  private final InventoryMenu teamSubGUI;\n+\n+  private final TextColor reset = TextColor.WHITE;", "originalCommit": "bd3eff27c3a31a4136d97a72ebfd046fca815b19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "34cc1a75fe71a8db1a36e1683551ae7eaf8f0b3b", "url": "https://github.com/PGMDev/PGM/commit/34cc1a75fe71a8db1a36e1683551ae7eaf8f0b3b", "message": "Ready for release\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>", "committedDate": "2020-08-07T22:31:57Z", "type": "forcePushed"}, {"oid": "0cc5628ac4e72f0ff17b9cf8214bdcc6ef708f5c", "url": "https://github.com/PGMDev/PGM/commit/0cc5628ac4e72f0ff17b9cf8214bdcc6ef708f5c", "message": "Remove old code\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>", "committedDate": "2020-08-07T22:46:03Z", "type": "forcePushed"}, {"oid": "eab9eb1c9f1846f5de6ca07e67c4695647a8dc03", "url": "https://github.com/PGMDev/PGM/commit/eab9eb1c9f1846f5de6ca07e67c4695647a8dc03", "message": "Remove old code\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>", "committedDate": "2020-08-07T22:47:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkxNDkzMQ==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r475914931", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final TranslatableComponent title; // Title of the inventory\n          \n          \n            \n              private final Component title; // Title of the inventory\n          \n      \n    \n    \n  \n\nProbably best to make this a Component, a menu title in the future may not come from a translation. Such as if the menu name was that of a username.", "author": "applenick", "createdAt": "2020-08-24T21:51:29Z", "path": "core/src/main/java/tc/oc/pgm/menu/InventoryMenu.java", "diffHunk": "@@ -1,50 +1,75 @@\n package tc.oc.pgm.menu;\n \n import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Preconditions.checkNotNull;\n \n+import com.google.common.collect.Lists;\n+import java.util.List;\n import java.util.WeakHashMap;\n import javax.annotation.Nullable;\n import net.kyori.text.TranslatableComponent;\n import org.bukkit.Bukkit;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.HandlerList;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.inventory.InventoryClickEvent;\n+import org.bukkit.event.inventory.InventoryCloseEvent;\n import org.bukkit.inventory.Inventory;\n import org.bukkit.inventory.ItemStack;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchUnloadEvent;\n import tc.oc.pgm.api.player.MatchPlayer;\n import tc.oc.pgm.observers.ObserverToolsMatchModule;\n import tc.oc.pgm.util.StringUtils;\n import tc.oc.pgm.util.text.TextTranslations;\n \n-public abstract class InventoryMenu {\n+public class InventoryMenu implements Listener {\n \n   protected static final int ROW_WIDTH = 9; // Number of columns per row\n   protected static final int MAX_ROWS = 6; // Max allowed row size\n \n+  private final List<InventoryMenuItem> inventoryMenuItems;\n+\n   private final WeakHashMap<MatchPlayer, InventoryMenu> viewing =\n       new WeakHashMap<>(); // Map of players who are viewing the gui, along with the menu\n-  private final String title; // Title of the inventory\n+  private final TranslatableComponent title; // Title of the inventory", "originalCommit": "273e9a801e88e1ba2a74872a03179561d5e31dbd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkxNjA5Nw==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r475916097", "bodyText": "See other comment", "author": "applenick", "createdAt": "2020-08-24T21:54:18Z", "path": "core/src/main/java/tc/oc/pgm/menu/InventoryMenu.java", "diffHunk": "@@ -1,50 +1,75 @@\n package tc.oc.pgm.menu;\n \n import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Preconditions.checkNotNull;\n \n+import com.google.common.collect.Lists;\n+import java.util.List;\n import java.util.WeakHashMap;\n import javax.annotation.Nullable;\n import net.kyori.text.TranslatableComponent;\n import org.bukkit.Bukkit;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.HandlerList;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.inventory.InventoryClickEvent;\n+import org.bukkit.event.inventory.InventoryCloseEvent;\n import org.bukkit.inventory.Inventory;\n import org.bukkit.inventory.ItemStack;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchUnloadEvent;\n import tc.oc.pgm.api.player.MatchPlayer;\n import tc.oc.pgm.observers.ObserverToolsMatchModule;\n import tc.oc.pgm.util.StringUtils;\n import tc.oc.pgm.util.text.TextTranslations;\n \n-public abstract class InventoryMenu {\n+public class InventoryMenu implements Listener {\n \n   protected static final int ROW_WIDTH = 9; // Number of columns per row\n   protected static final int MAX_ROWS = 6; // Max allowed row size\n \n+  private final List<InventoryMenuItem> inventoryMenuItems;\n+\n   private final WeakHashMap<MatchPlayer, InventoryMenu> viewing =\n       new WeakHashMap<>(); // Map of players who are viewing the gui, along with the menu\n-  private final String title; // Title of the inventory\n+  private final TranslatableComponent title; // Title of the inventory\n   private final int rows; // The # of rows in the inventory\n \n   /**\n    * InventoryMenu: An easy way to make an GUI menu that users can interact with.\n    *\n    * <p>See {@link ObserverToolsMatchModule} for an example on implementation\n    *\n-   * <p>Note: Code here was extracted from PickerMatchModule to allow for reuse\n+   * <p>Note: Code here was initially extracted from PickerMatchModule to allow for reuse\n    *\n+   * @param match - The match this inventory should exist it\n    * @param title - A string that will be translated and made the inventory title\n    * @param rows - The amount of rows the inventory will be created with\n+   * @param items - The items this inventory will contain\n    */\n-  public InventoryMenu(String title, int rows) {\n+  public InventoryMenu(\n+      Match match, TranslatableComponent title, int rows, List<InventoryMenuItem> items) {", "originalCommit": "273e9a801e88e1ba2a74872a03179561d5e31dbd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c195a566c33602389368ffbc282ac35815a64fb7", "url": "https://github.com/PGMDev/PGM/commit/c195a566c33602389368ffbc282ac35815a64fb7", "message": "Make inventory title a Component\n instead of TranslatableComponent\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>", "committedDate": "2020-08-28T08:33:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkxNjk3NQ==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r486916975", "bodyText": "Unlikely, it would be easier to just deny via permissions them being used than to disable them/remove from menu", "author": "Pablete1234", "createdAt": "2020-09-11T09:38:19Z", "path": "core/src/main/java/tc/oc/pgm/observers/ObserverToolsMatchModule.java", "diffHunk": "@@ -52,11 +44,20 @@ public ObserverToolsMatchModule createMatchModule(Match match) throws ModuleLoad\n   public static final Material TOOL_MATERIAL = Material.DIAMOND;\n \n   private final Match match;\n-  private ObserverToolMenu menu;\n+  private final InventoryMenu menu;\n+  private final InventoryMenuItem toolItem = new ObserverToolsInventoryMenuItem();\n \n   public ObserverToolsMatchModule(Match match) {\n     this.match = match;\n-    this.menu = new ObserverToolMenu();\n+\n+    // TODO?: Add config options to enable/disable each tool", "originalCommit": "721bcd1e28d769fe3235825b5ea4d61d55aee72f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI1NTA1Mg==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r487255052", "bodyText": "This was leftover from @applenick , ill remove it", "author": "KingOfSquares", "createdAt": "2020-09-11T19:45:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkxNjk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkyMTY2MA==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r486921660", "bodyText": "Consider a method that takes Number stat as parameter, so both ints and doubles can be passed. Strings make no sense since it will literally throw an exception if you try a non-number string, so it makes no sense.\nIt would also eliminate the need for 2 \"numberComponent\" methods", "author": "Pablete1234", "createdAt": "2020-09-11T09:43:08Z", "path": "core/src/main/java/tc/oc/pgm/stats/PlayerStatsInventoryMenuItem.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package tc.oc.pgm.stats;\n+\n+import static tc.oc.pgm.stats.StatsMatchModule.numberComponent;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import net.kyori.text.Component;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Material;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.inventory.ClickType;\n+import org.bukkit.inventory.ItemFlag;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.SkullMeta;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.menu.InventoryMenu;\n+import tc.oc.pgm.menu.InventoryMenuItem;\n+import tc.oc.pgm.util.text.TextTranslations;\n+\n+public class PlayerStatsInventoryMenuItem implements InventoryMenuItem {\n+\n+  private final MatchPlayer player;\n+  private final TextColor RESET = TextColor.WHITE;\n+\n+  PlayerStatsInventoryMenuItem(MatchPlayer player) {\n+    this.player = player;\n+  }\n+\n+  @Override\n+  public Component getName() {\n+    return player.getName();\n+  }\n+\n+  @Override\n+  public ChatColor getColor() {\n+    return ChatColor.GOLD;\n+  }\n+\n+  @Override\n+  public List<String> getLore(MatchPlayer player) {\n+    List<String> lore = new ArrayList<>();\n+    StatsMatchModule smm = player.getMatch().needModule(StatsMatchModule.class);\n+    StatsMatchModule.PlayerStats stats = smm.getPlayerStat(player.getId());\n+\n+    Component killLore =\n+        TranslatableComponent.of(\n+            \"match.stats.kills.concise\", RESET, numberComponent(stats.kills, TextColor.GREEN));\n+    Component deathLore =\n+        TranslatableComponent.of(\n+            \"match.stats.deaths.concise\", RESET, numberComponent(stats.deaths, TextColor.RED));\n+    Component kdLore =\n+        TranslatableComponent.of(\n+            \"match.stats.kd.concise\", RESET, numberComponent(stats.getKD(), TextColor.GREEN));\n+    Component killstreakLore =\n+        TranslatableComponent.of(\n+            \"match.stats.killstreak.concise\",\n+            RESET,\n+            numberComponent(stats.killstreakMax, TextColor.GREEN));\n+    Component damageLore =\n+        TranslatableComponent.of(\n+            \"match.stats.damage.concise\",\n+            RESET,\n+            numberComponent(stats.getDamageDone(), TextColor.GREEN),\n+            numberComponent(stats.getBowDamage(), TextColor.YELLOW),\n+            numberComponent(stats.getDamageTaken(), TextColor.RED));\n+    Component bowLore =\n+        TranslatableComponent.of(\n+            \"match.stats.bow.concise\",\n+            RESET,\n+            numberComponent(stats.shotsTaken, TextColor.YELLOW),\n+            numberComponent(stats.getArrowAccuracy(), TextColor.YELLOW));\n+\n+    Player bukkit = player.getBukkit();\n+\n+    lore.add(TextTranslations.translateLegacy(killLore, bukkit));\n+    lore.add(TextTranslations.translateLegacy(deathLore, bukkit));\n+    lore.add(TextTranslations.translateLegacy(kdLore, bukkit));\n+    lore.add(TextTranslations.translateLegacy(killstreakLore, bukkit));\n+    lore.add(TextTranslations.translateLegacy(damageLore, bukkit));\n+    lore.add(TextTranslations.translateLegacy(bowLore, bukkit));\n+\n+    optionalStat(lore, stats.flagsCaptured, \"match.stats.flagsCaptured.concise\", bukkit);\n+    optionalStat(lore, stats.destroyablePiecesBroken, \"match.stats.broken.concise\", bukkit);\n+    optionalStat(lore, stats.getLongestFlagHold(), \"match.stats.flaghold.concise\", bukkit);\n+\n+    return lore;\n+  }\n+\n+  private void optionalStat(List<String> lore, int stat, String key, Player bukkit) {\n+    if (stat > 0) {\n+      lore.add(null);\n+      Component loreComponent =\n+          TranslatableComponent.of(key, RESET, numberComponent(stat, TextColor.AQUA));\n+      lore.add(TextTranslations.translateLegacy(loreComponent, bukkit));\n+    }\n+  }\n+\n+  private void optionalStat(List<String> lore, String stat, String key, Player bukkit) {\n+    if (Double.parseDouble(stat) > 0) {\n+      lore.add(null);\n+      Component loreComponent =\n+          TranslatableComponent.of(key, RESET, numberComponent(stat, TextColor.AQUA));\n+      lore.add(TextTranslations.translateLegacy(loreComponent, bukkit));\n+    }\n+  }", "originalCommit": "721bcd1e28d769fe3235825b5ea4d61d55aee72f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkzNjQ3NQ==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r486936475", "bodyText": "Give this a better name, what is the task for?", "author": "Pablete1234", "createdAt": "2020-09-11T09:57:56Z", "path": "core/src/main/java/tc/oc/pgm/stats/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,492 @@\n+package tc.oc.pgm.stats;\n+\n+import com.google.common.collect.Lists;\n+import java.text.DecimalFormat;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.kyori.text.Component;\n+import net.kyori.text.TextComponent;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.kyori.text.format.TextDecoration;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Material;\n+import org.bukkit.entity.Arrow;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.block.Action;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityShootBowEvent;\n+import org.bukkit.event.player.PlayerInteractEvent;\n+import org.bukkit.event.player.PlayerJoinEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.inventory.ItemFlag;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.ParticipantState;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.api.setting.SettingKey;\n+import tc.oc.pgm.api.setting.SettingValue;\n+import tc.oc.pgm.destroyable.DestroyableHealthChange;\n+import tc.oc.pgm.destroyable.DestroyableHealthChangeEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.ffa.Tribute;\n+import tc.oc.pgm.flag.event.FlagCaptureEvent;\n+import tc.oc.pgm.flag.event.FlagPickupEvent;\n+import tc.oc.pgm.flag.event.FlagStateChangeEvent;\n+import tc.oc.pgm.flag.state.Dropped;\n+import tc.oc.pgm.menu.InventoryMenu;\n+import tc.oc.pgm.menu.InventoryMenuItem;\n+import tc.oc.pgm.menu.InventoryMenuUtils;\n+import tc.oc.pgm.tracker.TrackerMatchModule;\n+import tc.oc.pgm.tracker.info.ProjectileInfo;\n+import tc.oc.pgm.util.named.NameStyle;\n+import tc.oc.pgm.util.text.TextFormatter;\n+import tc.oc.pgm.util.text.TextTranslations;\n+import tc.oc.pgm.util.text.types.PlayerComponent;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+  // Since Bukkit#getOfflinePlayer reads the cached user files, and those files have an expire date\n+  // + will be wiped if X amount of players join, we need a separate cache for players with stats\n+  private final Map<UUID, String> cachedUsernames = new HashMap<>();\n+\n+  private final boolean verboseStats = PGM.get().getConfiguration().showVerboseStats();\n+  private final Component verboseStatsTitle = TranslatableComponent.of(\"match.stats.title\");\n+\n+  public StatsMatchModule(Match match) {\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    // K/D\n+    int kills;\n+    int deaths;\n+    int killstreak;\n+    int killstreakMax;\n+\n+    // Bow\n+    int longestBowKill;\n+    double bowDamage;\n+    int shotsTaken;\n+    int shotsHit;\n+\n+    // Damage\n+    double damageDone;\n+    double damageTaken;\n+\n+    // Objectives\n+    int destroyablePiecesBroken;\n+    int flagsCaptured;\n+\n+    Duration longestFlagHold;\n+    Instant longestFlagHoldCache;\n+\n+    //\n+    private Future<?> task;", "originalCommit": "721bcd1e28d769fe3235825b5ea4d61d55aee72f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwMTE0MA==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r487001140", "bodyText": "In reality, you just support teams not competitors, do a check on team match module existing or competitors being Team, instead of checking for no tributes", "author": "Pablete1234", "createdAt": "2020-09-11T12:07:50Z", "path": "core/src/main/java/tc/oc/pgm/stats/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,492 @@\n+package tc.oc.pgm.stats;\n+\n+import com.google.common.collect.Lists;\n+import java.text.DecimalFormat;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.kyori.text.Component;\n+import net.kyori.text.TextComponent;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.kyori.text.format.TextDecoration;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Material;\n+import org.bukkit.entity.Arrow;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.block.Action;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityShootBowEvent;\n+import org.bukkit.event.player.PlayerInteractEvent;\n+import org.bukkit.event.player.PlayerJoinEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.inventory.ItemFlag;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.ParticipantState;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.api.setting.SettingKey;\n+import tc.oc.pgm.api.setting.SettingValue;\n+import tc.oc.pgm.destroyable.DestroyableHealthChange;\n+import tc.oc.pgm.destroyable.DestroyableHealthChangeEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.ffa.Tribute;\n+import tc.oc.pgm.flag.event.FlagCaptureEvent;\n+import tc.oc.pgm.flag.event.FlagPickupEvent;\n+import tc.oc.pgm.flag.event.FlagStateChangeEvent;\n+import tc.oc.pgm.flag.state.Dropped;\n+import tc.oc.pgm.menu.InventoryMenu;\n+import tc.oc.pgm.menu.InventoryMenuItem;\n+import tc.oc.pgm.menu.InventoryMenuUtils;\n+import tc.oc.pgm.tracker.TrackerMatchModule;\n+import tc.oc.pgm.tracker.info.ProjectileInfo;\n+import tc.oc.pgm.util.named.NameStyle;\n+import tc.oc.pgm.util.text.TextFormatter;\n+import tc.oc.pgm.util.text.TextTranslations;\n+import tc.oc.pgm.util.text.types.PlayerComponent;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+  // Since Bukkit#getOfflinePlayer reads the cached user files, and those files have an expire date\n+  // + will be wiped if X amount of players join, we need a separate cache for players with stats\n+  private final Map<UUID, String> cachedUsernames = new HashMap<>();\n+\n+  private final boolean verboseStats = PGM.get().getConfiguration().showVerboseStats();\n+  private final Component verboseStatsTitle = TranslatableComponent.of(\"match.stats.title\");\n+\n+  public StatsMatchModule(Match match) {\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    // K/D\n+    int kills;\n+    int deaths;\n+    int killstreak;\n+    int killstreakMax;\n+\n+    // Bow\n+    int longestBowKill;\n+    double bowDamage;\n+    int shotsTaken;\n+    int shotsHit;\n+\n+    // Damage\n+    double damageDone;\n+    double damageTaken;\n+\n+    // Objectives\n+    int destroyablePiecesBroken;\n+    int flagsCaptured;\n+\n+    Duration longestFlagHold;\n+    Instant longestFlagHoldCache;\n+\n+    //\n+    private Future<?> task;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void onDamage(double damage, boolean bow) {\n+      damageDone += damage;\n+      if (bow) {\n+        bowDamage += damage;\n+        shotsHit++;\n+      }\n+    }\n+\n+    private void onDamaged(double damage) {\n+      damageTaken += damage;\n+    }\n+\n+    private void onDestroyablePieceBroken(int change) {\n+      destroyablePiecesBroken += change;\n+    }\n+\n+    private void onFlagCapture() {\n+      flagsCaptured++;\n+      onFlagDrop();\n+    }\n+\n+    private void onFlagPickup() {\n+      longestFlagHoldCache = Instant.now();\n+    }\n+\n+    private void onFlagDrop() {\n+      setLongestFlagHold(\n+          Duration.ofMillis(Instant.now().toEpochMilli() - longestFlagHoldCache.toEpochMilli()));\n+    }\n+\n+    private void setLongestFlagHold(Duration time) {\n+      if ((time.toNanos() - longestFlagHold.toNanos()) > 0) longestFlagHold = time;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) Math.ceil(distance);\n+      }\n+    }\n+\n+    private void onBowShoot() {\n+      shotsTaken++;\n+    }\n+\n+    /** A common format used by all stats with decimals */\n+    public static final DecimalFormat STATS_DECIMALFORMAT = new DecimalFormat(\"#.##\");\n+\n+    public static String statFormat(Object number) {\n+      return STATS_DECIMALFORMAT.format(number);\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      return TranslatableComponent.of(\n+          \"match.stats\",\n+          TextColor.GRAY,\n+          TextComponent.of(kills, TextColor.GREEN),\n+          TextComponent.of(killstreak, TextColor.GREEN),\n+          TextComponent.of(deaths, TextColor.RED),\n+          TextComponent.of(getKD(), TextColor.GREEN));\n+    }\n+\n+    // Methods that gives stats with decimals already formatted\n+\n+    public String getKD() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = Double.toString(kills);\n+      } else {\n+        kd = statFormat(kills / (double) deaths);\n+      }\n+      return kd;\n+    }\n+\n+    public String getArrowAccuracy() {\n+      String acc;\n+      if (shotsTaken == 0) acc = String.valueOf(100);\n+      else acc = statFormat(shotsHit / (shotsTaken / (double) 100));\n+      return acc;\n+    }\n+\n+    public String getDamageDone() {\n+      return statFormat(damageDone);\n+    }\n+\n+    public String getBowDamage() {\n+      return statFormat(bowDamage);\n+    }\n+\n+    public String getDamageTaken() {\n+      return statFormat(damageTaken);\n+    }\n+\n+    public String getLongestFlagHold() {\n+      if (longestFlagHold == null) return String.valueOf(0);\n+      return String.valueOf(longestFlagHold.toMinutes());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onDamage(EntityDamageByEntityEvent event) {\n+    ParticipantState damager =\n+        match.needModule(TrackerMatchModule.class).getOwner(event.getDamager());\n+    ParticipantState damaged = match.getParticipantState(event.getEntity());\n+    boolean bow = event.getDamager() instanceof Arrow;\n+    if (damager != null) getPlayerStat(damager).onDamage(event.getFinalDamage(), bow);\n+    if (damaged != null) getPlayerStat(damaged).onDamaged(event.getFinalDamage());\n+  }\n+\n+  @EventHandler\n+  public void onShoot(EntityShootBowEvent event) {\n+    if (event.getEntity() instanceof Player) {\n+      MatchPlayer player = match.getPlayer(event.getEntity());\n+      if (player != null) getPlayerStat(player).onBowShoot();\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onDestroyableBreak(DestroyableHealthChangeEvent event) {\n+    DestroyableHealthChange change = event.getChange();\n+    if (change != null && change.getHealthChange() > 0 && change.getPlayerCause() != null)\n+      getPlayerStat(change.getPlayerCause()).onDestroyablePieceBroken(change.getHealthChange());\n+  }\n+\n+  @EventHandler\n+  public void onFlagCapture(FlagCaptureEvent event) {\n+    getPlayerStat(event.getCarrier()).onFlagCapture();\n+  }\n+\n+  @EventHandler\n+  public void onFlagHold(FlagPickupEvent event) {\n+    getPlayerStat(event.getCarrier()).onFlagPickup();\n+  }\n+\n+  @EventHandler\n+  public void onFlagDrop(FlagStateChangeEvent event) {\n+    if (event.getOldState() instanceof Dropped)\n+      getPlayerStat(((Dropped) event.getOldState()).getDropper()).onFlagDrop();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    if (victim.getSettings().getValue(SettingKey.STATS).equals(SettingValue.STATS_ON)) {\n+      PlayerStats victimStats = getPlayerStat(victim);\n+\n+      victimStats.onDeath();\n+\n+      sendPlayerStats(victim, victimStats);\n+    }\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF\n+        && murderer.getSettings().getValue(SettingKey.STATS).equals(SettingValue.STATS_ON)) {\n+\n+      PlayerStats murdererStats = getPlayerStat(murderer);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendPlayerStats(murderer, murdererStats);\n+    }\n+  }\n+\n+  private void sendPlayerStats(MatchPlayer player, PlayerStats stats) {\n+    if (stats.task != null && !stats.task.isDone()) {\n+      stats.task.cancel(true);\n+    }\n+    stats.task = sendLongHotbarMessage(player, stats.getBasicStatsMessage());\n+  }\n+\n+  private Future<?> sendLongHotbarMessage(MatchPlayer player, Component message) {\n+    Future<?> task =\n+        match\n+            .getExecutor(MatchScope.LOADED)\n+            .scheduleWithFixedDelay(() -> player.showHotbar(message), 0, 1, TimeUnit.SECONDS);\n+\n+    match.getExecutor(MatchScope.LOADED).schedule(() -> task.cancel(true), 4, TimeUnit.SECONDS);\n+\n+    return task;\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+\n+    if (allPlayerStats.isEmpty()) return;\n+\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+    Map<UUID, Double> allDamage = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      getPlayerStat(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+      allDamage.put(playerUUID, playerStats.damageDone);\n+    }\n+\n+    Component killMessage = getMessage(\"match.stats.kills\", sortStats(allKills), TextColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"match.stats.killstreak\", sortStats(allKillstreaks), TextColor.GREEN);\n+    Component deathMessage = getMessage(\"match.stats.deaths\", sortStats(allDeaths), TextColor.RED);\n+    Map.Entry<UUID, Integer> bestBowshot = sortStats(allBowshots);\n+    if (bestBowshot.getValue() == 1)\n+      bestBowshot.setValue(2); // Avoids translating \"1 block\" vs \"n blocks\"\n+    Component bowshotMessage = getMessage(\"match.stats.bowshot\", bestBowshot, TextColor.YELLOW);\n+    Component damageMessage =\n+        getMessage(\"match.stats.damage\", sortStatsDouble(allDamage), TextColor.GREEN);\n+\n+    match\n+        .getExecutor(MatchScope.LOADED)\n+        .schedule(\n+            () -> {\n+              for (MatchPlayer viewer : match.getPlayers()) {\n+                if (viewer.getSettings().getValue(SettingKey.STATS) == SettingValue.STATS_OFF)\n+                  continue;\n+\n+                viewer.sendMessage(\n+                    TextFormatter.horizontalLineHeading(\n+                        viewer.getBukkit(),\n+                        TranslatableComponent.of(\"match.stats.title\", TextColor.YELLOW),\n+                        TextColor.WHITE));\n+                viewer.sendMessage(killMessage);\n+                viewer.sendMessage(killstreakMessage);\n+                viewer.sendMessage(deathMessage);\n+                if (bestBowshot.getValue() != 0) viewer.sendMessage(bowshotMessage);\n+                viewer.sendMessage(damageMessage);\n+                if (verboseStats) viewer.getInventory().setItem(7, createToolItem(viewer));\n+              }\n+            },\n+            5 + 1, // NOTE: This is 1 second after the votebook appears\n+            TimeUnit.SECONDS);\n+\n+    final Collection<Competitor> competitors = match.getCompetitors();\n+    // TODO: Support all Parties, Tributes(FFA)\n+    if (verboseStats && competitors.stream().noneMatch(c -> c instanceof Tribute)) {", "originalCommit": "721bcd1e28d769fe3235825b5ea4d61d55aee72f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwMTg1Nw==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r487001857", "bodyText": "There's a translatable for unknown, it's used in the tablist for unresolved authors, use it here", "author": "Pablete1234", "createdAt": "2020-09-11T12:09:19Z", "path": "core/src/main/java/tc/oc/pgm/stats/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,492 @@\n+package tc.oc.pgm.stats;\n+\n+import com.google.common.collect.Lists;\n+import java.text.DecimalFormat;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.kyori.text.Component;\n+import net.kyori.text.TextComponent;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.kyori.text.format.TextDecoration;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Material;\n+import org.bukkit.entity.Arrow;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.block.Action;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityShootBowEvent;\n+import org.bukkit.event.player.PlayerInteractEvent;\n+import org.bukkit.event.player.PlayerJoinEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.inventory.ItemFlag;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.ParticipantState;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.api.setting.SettingKey;\n+import tc.oc.pgm.api.setting.SettingValue;\n+import tc.oc.pgm.destroyable.DestroyableHealthChange;\n+import tc.oc.pgm.destroyable.DestroyableHealthChangeEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.ffa.Tribute;\n+import tc.oc.pgm.flag.event.FlagCaptureEvent;\n+import tc.oc.pgm.flag.event.FlagPickupEvent;\n+import tc.oc.pgm.flag.event.FlagStateChangeEvent;\n+import tc.oc.pgm.flag.state.Dropped;\n+import tc.oc.pgm.menu.InventoryMenu;\n+import tc.oc.pgm.menu.InventoryMenuItem;\n+import tc.oc.pgm.menu.InventoryMenuUtils;\n+import tc.oc.pgm.tracker.TrackerMatchModule;\n+import tc.oc.pgm.tracker.info.ProjectileInfo;\n+import tc.oc.pgm.util.named.NameStyle;\n+import tc.oc.pgm.util.text.TextFormatter;\n+import tc.oc.pgm.util.text.TextTranslations;\n+import tc.oc.pgm.util.text.types.PlayerComponent;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+  // Since Bukkit#getOfflinePlayer reads the cached user files, and those files have an expire date\n+  // + will be wiped if X amount of players join, we need a separate cache for players with stats\n+  private final Map<UUID, String> cachedUsernames = new HashMap<>();\n+\n+  private final boolean verboseStats = PGM.get().getConfiguration().showVerboseStats();\n+  private final Component verboseStatsTitle = TranslatableComponent.of(\"match.stats.title\");\n+\n+  public StatsMatchModule(Match match) {\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    // K/D\n+    int kills;\n+    int deaths;\n+    int killstreak;\n+    int killstreakMax;\n+\n+    // Bow\n+    int longestBowKill;\n+    double bowDamage;\n+    int shotsTaken;\n+    int shotsHit;\n+\n+    // Damage\n+    double damageDone;\n+    double damageTaken;\n+\n+    // Objectives\n+    int destroyablePiecesBroken;\n+    int flagsCaptured;\n+\n+    Duration longestFlagHold;\n+    Instant longestFlagHoldCache;\n+\n+    //\n+    private Future<?> task;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void onDamage(double damage, boolean bow) {\n+      damageDone += damage;\n+      if (bow) {\n+        bowDamage += damage;\n+        shotsHit++;\n+      }\n+    }\n+\n+    private void onDamaged(double damage) {\n+      damageTaken += damage;\n+    }\n+\n+    private void onDestroyablePieceBroken(int change) {\n+      destroyablePiecesBroken += change;\n+    }\n+\n+    private void onFlagCapture() {\n+      flagsCaptured++;\n+      onFlagDrop();\n+    }\n+\n+    private void onFlagPickup() {\n+      longestFlagHoldCache = Instant.now();\n+    }\n+\n+    private void onFlagDrop() {\n+      setLongestFlagHold(\n+          Duration.ofMillis(Instant.now().toEpochMilli() - longestFlagHoldCache.toEpochMilli()));\n+    }\n+\n+    private void setLongestFlagHold(Duration time) {\n+      if ((time.toNanos() - longestFlagHold.toNanos()) > 0) longestFlagHold = time;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) Math.ceil(distance);\n+      }\n+    }\n+\n+    private void onBowShoot() {\n+      shotsTaken++;\n+    }\n+\n+    /** A common format used by all stats with decimals */\n+    public static final DecimalFormat STATS_DECIMALFORMAT = new DecimalFormat(\"#.##\");\n+\n+    public static String statFormat(Object number) {\n+      return STATS_DECIMALFORMAT.format(number);\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      return TranslatableComponent.of(\n+          \"match.stats\",\n+          TextColor.GRAY,\n+          TextComponent.of(kills, TextColor.GREEN),\n+          TextComponent.of(killstreak, TextColor.GREEN),\n+          TextComponent.of(deaths, TextColor.RED),\n+          TextComponent.of(getKD(), TextColor.GREEN));\n+    }\n+\n+    // Methods that gives stats with decimals already formatted\n+\n+    public String getKD() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = Double.toString(kills);\n+      } else {\n+        kd = statFormat(kills / (double) deaths);\n+      }\n+      return kd;\n+    }\n+\n+    public String getArrowAccuracy() {\n+      String acc;\n+      if (shotsTaken == 0) acc = String.valueOf(100);\n+      else acc = statFormat(shotsHit / (shotsTaken / (double) 100));\n+      return acc;\n+    }\n+\n+    public String getDamageDone() {\n+      return statFormat(damageDone);\n+    }\n+\n+    public String getBowDamage() {\n+      return statFormat(bowDamage);\n+    }\n+\n+    public String getDamageTaken() {\n+      return statFormat(damageTaken);\n+    }\n+\n+    public String getLongestFlagHold() {\n+      if (longestFlagHold == null) return String.valueOf(0);\n+      return String.valueOf(longestFlagHold.toMinutes());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onDamage(EntityDamageByEntityEvent event) {\n+    ParticipantState damager =\n+        match.needModule(TrackerMatchModule.class).getOwner(event.getDamager());\n+    ParticipantState damaged = match.getParticipantState(event.getEntity());\n+    boolean bow = event.getDamager() instanceof Arrow;\n+    if (damager != null) getPlayerStat(damager).onDamage(event.getFinalDamage(), bow);\n+    if (damaged != null) getPlayerStat(damaged).onDamaged(event.getFinalDamage());\n+  }\n+\n+  @EventHandler\n+  public void onShoot(EntityShootBowEvent event) {\n+    if (event.getEntity() instanceof Player) {\n+      MatchPlayer player = match.getPlayer(event.getEntity());\n+      if (player != null) getPlayerStat(player).onBowShoot();\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onDestroyableBreak(DestroyableHealthChangeEvent event) {\n+    DestroyableHealthChange change = event.getChange();\n+    if (change != null && change.getHealthChange() > 0 && change.getPlayerCause() != null)\n+      getPlayerStat(change.getPlayerCause()).onDestroyablePieceBroken(change.getHealthChange());\n+  }\n+\n+  @EventHandler\n+  public void onFlagCapture(FlagCaptureEvent event) {\n+    getPlayerStat(event.getCarrier()).onFlagCapture();\n+  }\n+\n+  @EventHandler\n+  public void onFlagHold(FlagPickupEvent event) {\n+    getPlayerStat(event.getCarrier()).onFlagPickup();\n+  }\n+\n+  @EventHandler\n+  public void onFlagDrop(FlagStateChangeEvent event) {\n+    if (event.getOldState() instanceof Dropped)\n+      getPlayerStat(((Dropped) event.getOldState()).getDropper()).onFlagDrop();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    if (victim.getSettings().getValue(SettingKey.STATS).equals(SettingValue.STATS_ON)) {\n+      PlayerStats victimStats = getPlayerStat(victim);\n+\n+      victimStats.onDeath();\n+\n+      sendPlayerStats(victim, victimStats);\n+    }\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF\n+        && murderer.getSettings().getValue(SettingKey.STATS).equals(SettingValue.STATS_ON)) {\n+\n+      PlayerStats murdererStats = getPlayerStat(murderer);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendPlayerStats(murderer, murdererStats);\n+    }\n+  }\n+\n+  private void sendPlayerStats(MatchPlayer player, PlayerStats stats) {\n+    if (stats.task != null && !stats.task.isDone()) {\n+      stats.task.cancel(true);\n+    }\n+    stats.task = sendLongHotbarMessage(player, stats.getBasicStatsMessage());\n+  }\n+\n+  private Future<?> sendLongHotbarMessage(MatchPlayer player, Component message) {\n+    Future<?> task =\n+        match\n+            .getExecutor(MatchScope.LOADED)\n+            .scheduleWithFixedDelay(() -> player.showHotbar(message), 0, 1, TimeUnit.SECONDS);\n+\n+    match.getExecutor(MatchScope.LOADED).schedule(() -> task.cancel(true), 4, TimeUnit.SECONDS);\n+\n+    return task;\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+\n+    if (allPlayerStats.isEmpty()) return;\n+\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+    Map<UUID, Double> allDamage = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      getPlayerStat(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+      allDamage.put(playerUUID, playerStats.damageDone);\n+    }\n+\n+    Component killMessage = getMessage(\"match.stats.kills\", sortStats(allKills), TextColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"match.stats.killstreak\", sortStats(allKillstreaks), TextColor.GREEN);\n+    Component deathMessage = getMessage(\"match.stats.deaths\", sortStats(allDeaths), TextColor.RED);\n+    Map.Entry<UUID, Integer> bestBowshot = sortStats(allBowshots);\n+    if (bestBowshot.getValue() == 1)\n+      bestBowshot.setValue(2); // Avoids translating \"1 block\" vs \"n blocks\"\n+    Component bowshotMessage = getMessage(\"match.stats.bowshot\", bestBowshot, TextColor.YELLOW);\n+    Component damageMessage =\n+        getMessage(\"match.stats.damage\", sortStatsDouble(allDamage), TextColor.GREEN);\n+\n+    match\n+        .getExecutor(MatchScope.LOADED)\n+        .schedule(\n+            () -> {\n+              for (MatchPlayer viewer : match.getPlayers()) {\n+                if (viewer.getSettings().getValue(SettingKey.STATS) == SettingValue.STATS_OFF)\n+                  continue;\n+\n+                viewer.sendMessage(\n+                    TextFormatter.horizontalLineHeading(\n+                        viewer.getBukkit(),\n+                        TranslatableComponent.of(\"match.stats.title\", TextColor.YELLOW),\n+                        TextColor.WHITE));\n+                viewer.sendMessage(killMessage);\n+                viewer.sendMessage(killstreakMessage);\n+                viewer.sendMessage(deathMessage);\n+                if (bestBowshot.getValue() != 0) viewer.sendMessage(bowshotMessage);\n+                viewer.sendMessage(damageMessage);\n+                if (verboseStats) viewer.getInventory().setItem(7, createToolItem(viewer));\n+              }\n+            },\n+            5 + 1, // NOTE: This is 1 second after the votebook appears\n+            TimeUnit.SECONDS);\n+\n+    final Collection<Competitor> competitors = match.getCompetitors();\n+    // TODO: Support all Parties, Tributes(FFA)\n+    if (verboseStats && competitors.stream().noneMatch(c -> c instanceof Tribute)) {\n+\n+      final List<InventoryMenuItem> items =\n+          competitors.stream()\n+              .map(c -> new TeamInventoryMenuItem(match, c))\n+              .collect(Collectors.toList());\n+\n+      endOfMatchMenu =\n+          competitors.size() <= 4\n+              ? InventoryMenuUtils.smallMenu(match, verboseStatsTitle, items)\n+              : InventoryMenuUtils.progressiveMenu(match, verboseStatsTitle, items);\n+    }\n+  }\n+\n+  InventoryMenu endOfMatchMenu;\n+\n+  private ItemStack createToolItem(MatchPlayer player) {\n+    ItemStack tool = new ItemStack(Material.RED_SANDSTONE);\n+    ItemMeta meta = tool.getItemMeta();\n+    Component displayName =\n+        TranslatableComponent.of(\"match.stats.title\", TextColor.GREEN, TextDecoration.BOLD);\n+    Component lore = TranslatableComponent.of(\"setting.lore\", TextColor.GRAY);\n+    meta.setDisplayName(TextTranslations.translateLegacy(displayName, player.getBukkit()));\n+    meta.setLore(Lists.newArrayList(TextTranslations.translateLegacy(lore, player.getBukkit())));\n+    meta.addItemFlags(ItemFlag.values());\n+    tool.setItemMeta(meta);\n+    return tool;\n+  }\n+\n+  @EventHandler\n+  public void onToolClick(PlayerInteractEvent event) {\n+    if (!verboseStats) return;\n+    Action action = event.getAction();\n+    if ((action == Action.RIGHT_CLICK_AIR || action == Action.RIGHT_CLICK_BLOCK)\n+        && match.isFinished()) {\n+      ItemStack item = event.getPlayer().getItemInHand();\n+\n+      if (item.getType() == Material.RED_SANDSTONE) {\n+        MatchPlayer player = match.getPlayer(event.getPlayer());\n+        if (player == null) return;\n+        endOfMatchMenu.display(player);\n+      }\n+    }\n+  }\n+\n+  private Map.Entry<UUID, Integer> sortStats(Map<UUID, Integer> map) {\n+    return map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+  }\n+\n+  private Map.Entry<UUID, Double> sortStatsDouble(Map<UUID, Double> map) {\n+    return map.entrySet().stream()\n+        .max(Comparator.comparingDouble(Map.Entry::getValue))\n+        .orElse(null);\n+  }\n+\n+  Component getMessage(\n+      String messageKey, Map.Entry<UUID, ? extends Number> mapEntry, TextColor color) {\n+    return TranslatableComponent.of(\n+        messageKey,\n+        playerName(mapEntry.getKey()),\n+        numberComponent(String.valueOf(mapEntry.getValue()), color));\n+  }\n+\n+  public static Component numberComponent(int stat, TextColor color) {\n+    return TextComponent.of(stat, color, TextDecoration.BOLD);\n+  }\n+\n+  public static Component numberComponent(String stat, TextColor color) {\n+    return TextComponent.of(stat, color, TextDecoration.BOLD);\n+  }\n+\n+  @EventHandler\n+  public void onPlayerLeave(PlayerQuitEvent event) {\n+    Player player = event.getPlayer();\n+    if (allPlayerStats.containsKey(player.getUniqueId()))\n+      cachedUsernames.put(player.getUniqueId(), player.getName());\n+  }\n+\n+  @EventHandler\n+  public void onPlayerJoin(PlayerJoinEvent event) {\n+    UUID playerUUID = event.getPlayer().getUniqueId();\n+    cachedUsernames.remove(playerUUID);\n+  }\n+\n+  private Component playerName(UUID playerUUID) {\n+    return PlayerComponent.of(\n+        Bukkit.getPlayer(playerUUID),\n+        cachedUsernames.getOrDefault(playerUUID, \"Unknown\"),", "originalCommit": "721bcd1e28d769fe3235825b5ea4d61d55aee72f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM3MjI4OA==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r488372288", "bodyText": "Won't this create 3.333333333 things unless passed thru a number format?", "author": "Pablete1234", "createdAt": "2020-09-15T04:14:51Z", "path": "core/src/main/java/tc/oc/pgm/stats/StatsMatchModule.java", "diffHunk": "@@ -430,17 +432,13 @@ public void onToolClick(PlayerInteractEvent event) {\n   Component getMessage(\n       String messageKey, Map.Entry<UUID, ? extends Number> mapEntry, TextColor color) {\n     return TranslatableComponent.of(\n-        messageKey,\n-        playerName(mapEntry.getKey()),\n-        numberComponent(String.valueOf(mapEntry.getValue()), color));\n-  }\n-\n-  public static Component numberComponent(int stat, TextColor color) {\n-    return TextComponent.of(stat, color, TextDecoration.BOLD);\n+        messageKey, playerName(mapEntry.getKey()), numberComponent(mapEntry.getValue(), color));\n   }\n \n-  public static Component numberComponent(String stat, TextColor color) {\n-    return TextComponent.of(stat, color, TextDecoration.BOLD);\n+  public static Component numberComponent(Number stat, TextColor color) {\n+    double doubleStat = stat.doubleValue();\n+    if (doubleStat % 1 == 0) return TextComponent.of((int) stat, color, TextDecoration.BOLD);\n+    else return TextComponent.of((double) stat, color, TextDecoration.BOLD);", "originalCommit": "8facb9d192efdef172db5b68177a77e71b5c1a59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwODk1Mg==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r489208952", "bodyText": "Its already passed through a format when its fetched from the PlayerStats \ud83e\udd14  I'll check", "author": "KingOfSquares", "createdAt": "2020-09-16T07:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM3MjI4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxODIwNA==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r490418204", "bodyText": "Had to do some small finicking to parse correctly, but should work as intended now \ud83d\udc4d\n(Also fixed the fact damage to yourself is tracked in the last commit)", "author": "KingOfSquares", "createdAt": "2020-09-17T17:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM3MjI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4NjE3NA==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r490986174", "bodyText": "Consider leaving a Double.NaN in here, and on the component display as a - or similar, to show no number rather than 100% or 0%", "author": "Pablete1234", "createdAt": "2020-09-18T14:24:25Z", "path": "core/src/main/java/tc/oc/pgm/stats/TeamInventoryMenuItem.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package tc.oc.pgm.stats;\n+\n+import static tc.oc.pgm.stats.StatsMatchModule.PlayerStats.statFormat;\n+import static tc.oc.pgm.stats.StatsMatchModule.numberComponent;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import net.kyori.text.Component;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Material;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.inventory.ClickType;\n+import org.bukkit.inventory.ItemFlag;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.menu.InventoryMenu;\n+import tc.oc.pgm.menu.InventoryMenuItem;\n+import tc.oc.pgm.menu.InventoryMenuUtils;\n+import tc.oc.pgm.util.bukkit.BukkitUtils;\n+import tc.oc.pgm.util.text.TextTranslations;\n+\n+public class TeamInventoryMenuItem implements InventoryMenuItem {\n+\n+  private final Competitor team;\n+  private final InventoryMenu teamSubGUI;\n+\n+  private final TextColor RESET = TextColor.WHITE;\n+\n+  TeamInventoryMenuItem(Match match, Competitor team) {\n+    this.team = team;\n+    this.teamSubGUI =\n+        InventoryMenuUtils.prettyMenu(\n+            match,\n+            TranslatableComponent.of(\"match.stats.title\"),\n+            team.getPlayers().stream()\n+                .map(PlayerStatsInventoryMenuItem::new)\n+                .collect(Collectors.toList()));\n+  }\n+\n+  @Override\n+  public Component getName() {\n+    return TranslatableComponent.of(\"match.stats.team\", team.getName());\n+  }\n+\n+  @Override\n+  public ChatColor getColor() {\n+    return ChatColor.valueOf(team.getColor().name());\n+  }\n+\n+  @Override\n+  public List<String> getLore(MatchPlayer player) {\n+\n+    StatsMatchModule smm = player.getMatch().needModule(StatsMatchModule.class);\n+    List<String> lore = new ArrayList<>();\n+    int teamKills = 0;\n+    int teamDeaths = 0;\n+    double damageDone = 0;\n+    double damageTaken = 0;\n+    double bowDamage = 0;\n+    int shotsTaken = 0;\n+    int shotsHit = 0;\n+    for (MatchPlayer teamPlayer : team.getPlayers()) {\n+      StatsMatchModule.PlayerStats stats = smm.getPlayerStat(teamPlayer.getId());\n+      teamKills += stats.kills;\n+      teamDeaths += stats.deaths;\n+      damageDone += stats.getDamageDone();\n+      damageTaken += stats.getDamageTaken();\n+      bowDamage += stats.getBowDamage();\n+      shotsTaken += stats.shotsTaken;\n+      shotsHit += stats.shotsHit;\n+    }\n+\n+    double teamKD = teamDeaths == 0 ? teamKills : statFormat(teamKills / (double) teamDeaths);\n+    // You hit 100% of the shots you dont take? :thinking:\n+    double teamBowAcc = shotsTaken == 0 ? 100 : statFormat(shotsHit / (shotsTaken / (double) 100));", "originalCommit": "44794bc429b9aac52d4ce157e4595049d2cf96b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4Nzc3MA==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r490987770", "bodyText": "Don't convert a double into a double. Format when you're about to display it to the user, when creating the TextComponent. Here's you're not setting format, you're just arbitrarily altering doubles to try to force a specific rounding", "author": "Pablete1234", "createdAt": "2020-09-18T14:26:42Z", "path": "core/src/main/java/tc/oc/pgm/stats/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,489 @@\n+package tc.oc.pgm.stats;\n+\n+import com.google.common.collect.Lists;\n+import java.text.DecimalFormat;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.kyori.text.Component;\n+import net.kyori.text.TextComponent;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.kyori.text.format.TextDecoration;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Material;\n+import org.bukkit.entity.Arrow;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.block.Action;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityShootBowEvent;\n+import org.bukkit.event.player.PlayerInteractEvent;\n+import org.bukkit.event.player.PlayerJoinEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.inventory.ItemFlag;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.ParticipantState;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.api.setting.SettingKey;\n+import tc.oc.pgm.api.setting.SettingValue;\n+import tc.oc.pgm.destroyable.DestroyableHealthChange;\n+import tc.oc.pgm.destroyable.DestroyableHealthChangeEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.flag.event.FlagCaptureEvent;\n+import tc.oc.pgm.flag.event.FlagPickupEvent;\n+import tc.oc.pgm.flag.event.FlagStateChangeEvent;\n+import tc.oc.pgm.flag.state.Carried;\n+import tc.oc.pgm.menu.InventoryMenu;\n+import tc.oc.pgm.menu.InventoryMenuItem;\n+import tc.oc.pgm.menu.InventoryMenuUtils;\n+import tc.oc.pgm.teams.Team;\n+import tc.oc.pgm.tracker.TrackerMatchModule;\n+import tc.oc.pgm.tracker.info.ProjectileInfo;\n+import tc.oc.pgm.util.named.NameStyle;\n+import tc.oc.pgm.util.text.TextFormatter;\n+import tc.oc.pgm.util.text.TextTranslations;\n+import tc.oc.pgm.util.text.types.PlayerComponent;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+  // Since Bukkit#getOfflinePlayer reads the cached user files, and those files have an expire date\n+  // + will be wiped if X amount of players join, we need a separate cache for players with stats\n+  private final Map<UUID, String> cachedUsernames = new HashMap<>();\n+\n+  private final boolean verboseStats = PGM.get().getConfiguration().showVerboseStats();\n+  private final Component verboseStatsTitle = TranslatableComponent.of(\"match.stats.title\");\n+\n+  // Defined at match end, see #onMatchEnd\n+  InventoryMenu endOfMatchMenu;\n+\n+  public StatsMatchModule(Match match) {\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    // K/D\n+    int kills;\n+    int deaths;\n+    int killstreak;\n+    int killstreakMax;\n+\n+    // Bow\n+    int longestBowKill;\n+    private double bowDamage;\n+    int shotsTaken;\n+    int shotsHit;\n+\n+    // Damage\n+    private double damageDone;\n+    private double damageTaken;\n+\n+    // Objectives\n+    int destroyablePiecesBroken;\n+    int flagsCaptured;\n+\n+    Duration longestFlagHold = Duration.ZERO;\n+    private Instant longestFlagHoldCache;\n+\n+    // The task responsible for displaying the stats over the hotbar\n+    // See #sendLongHotbarMessage\n+    private Future<?> hotbarTask;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void onDamage(double damage, boolean bow) {\n+      damageDone += damage;\n+      if (bow) {\n+        bowDamage += damage;\n+        shotsHit++;\n+      }\n+    }\n+\n+    private void onDamaged(double damage) {\n+      damageTaken += damage;\n+    }\n+\n+    private void onDestroyablePieceBroken(int change) {\n+      destroyablePiecesBroken += change;\n+    }\n+\n+    private void onFlagCapture() {\n+      flagsCaptured++;\n+      onFlagDrop();\n+    }\n+\n+    private void onFlagPickup() {\n+      longestFlagHoldCache = Instant.now();\n+    }\n+\n+    private void onFlagDrop() {\n+      setLongestFlagHold(\n+          Duration.ofMillis(Instant.now().toEpochMilli() - longestFlagHoldCache.toEpochMilli()));\n+    }\n+\n+    private void setLongestFlagHold(Duration time) {\n+      if (longestFlagHold == null || (time.toNanos() - longestFlagHold.toNanos()) > 0)\n+        longestFlagHold = time;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) Math.ceil(distance);\n+      }\n+    }\n+\n+    private void onBowShoot() {\n+      shotsTaken++;\n+    }\n+\n+    /** A common format used by all stats with decimals */\n+    public static final DecimalFormat STATS_DECIMALFORMAT = new DecimalFormat(\"#.##\");\n+\n+    public static double statFormat(Number number) {\n+      String stat = STATS_DECIMALFORMAT.format(number).replace(',', '.');\n+      return Double.parseDouble(stat);\n+    }", "originalCommit": "44794bc429b9aac52d4ce157e4595049d2cf96b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4ODgxOA==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r490988818", "bodyText": "Use a number formatter here, to set the format you want (with 2 decimals) and pass the resulting formatted string to TextComponent", "author": "Pablete1234", "createdAt": "2020-09-18T14:28:23Z", "path": "core/src/main/java/tc/oc/pgm/stats/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,489 @@\n+package tc.oc.pgm.stats;\n+\n+import com.google.common.collect.Lists;\n+import java.text.DecimalFormat;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.kyori.text.Component;\n+import net.kyori.text.TextComponent;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.kyori.text.format.TextDecoration;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Material;\n+import org.bukkit.entity.Arrow;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.block.Action;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityShootBowEvent;\n+import org.bukkit.event.player.PlayerInteractEvent;\n+import org.bukkit.event.player.PlayerJoinEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.inventory.ItemFlag;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.ParticipantState;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.api.setting.SettingKey;\n+import tc.oc.pgm.api.setting.SettingValue;\n+import tc.oc.pgm.destroyable.DestroyableHealthChange;\n+import tc.oc.pgm.destroyable.DestroyableHealthChangeEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.flag.event.FlagCaptureEvent;\n+import tc.oc.pgm.flag.event.FlagPickupEvent;\n+import tc.oc.pgm.flag.event.FlagStateChangeEvent;\n+import tc.oc.pgm.flag.state.Carried;\n+import tc.oc.pgm.menu.InventoryMenu;\n+import tc.oc.pgm.menu.InventoryMenuItem;\n+import tc.oc.pgm.menu.InventoryMenuUtils;\n+import tc.oc.pgm.teams.Team;\n+import tc.oc.pgm.tracker.TrackerMatchModule;\n+import tc.oc.pgm.tracker.info.ProjectileInfo;\n+import tc.oc.pgm.util.named.NameStyle;\n+import tc.oc.pgm.util.text.TextFormatter;\n+import tc.oc.pgm.util.text.TextTranslations;\n+import tc.oc.pgm.util.text.types.PlayerComponent;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+  // Since Bukkit#getOfflinePlayer reads the cached user files, and those files have an expire date\n+  // + will be wiped if X amount of players join, we need a separate cache for players with stats\n+  private final Map<UUID, String> cachedUsernames = new HashMap<>();\n+\n+  private final boolean verboseStats = PGM.get().getConfiguration().showVerboseStats();\n+  private final Component verboseStatsTitle = TranslatableComponent.of(\"match.stats.title\");\n+\n+  // Defined at match end, see #onMatchEnd\n+  InventoryMenu endOfMatchMenu;\n+\n+  public StatsMatchModule(Match match) {\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    // K/D\n+    int kills;\n+    int deaths;\n+    int killstreak;\n+    int killstreakMax;\n+\n+    // Bow\n+    int longestBowKill;\n+    private double bowDamage;\n+    int shotsTaken;\n+    int shotsHit;\n+\n+    // Damage\n+    private double damageDone;\n+    private double damageTaken;\n+\n+    // Objectives\n+    int destroyablePiecesBroken;\n+    int flagsCaptured;\n+\n+    Duration longestFlagHold = Duration.ZERO;\n+    private Instant longestFlagHoldCache;\n+\n+    // The task responsible for displaying the stats over the hotbar\n+    // See #sendLongHotbarMessage\n+    private Future<?> hotbarTask;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void onDamage(double damage, boolean bow) {\n+      damageDone += damage;\n+      if (bow) {\n+        bowDamage += damage;\n+        shotsHit++;\n+      }\n+    }\n+\n+    private void onDamaged(double damage) {\n+      damageTaken += damage;\n+    }\n+\n+    private void onDestroyablePieceBroken(int change) {\n+      destroyablePiecesBroken += change;\n+    }\n+\n+    private void onFlagCapture() {\n+      flagsCaptured++;\n+      onFlagDrop();\n+    }\n+\n+    private void onFlagPickup() {\n+      longestFlagHoldCache = Instant.now();\n+    }\n+\n+    private void onFlagDrop() {\n+      setLongestFlagHold(\n+          Duration.ofMillis(Instant.now().toEpochMilli() - longestFlagHoldCache.toEpochMilli()));\n+    }\n+\n+    private void setLongestFlagHold(Duration time) {\n+      if (longestFlagHold == null || (time.toNanos() - longestFlagHold.toNanos()) > 0)\n+        longestFlagHold = time;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) Math.ceil(distance);\n+      }\n+    }\n+\n+    private void onBowShoot() {\n+      shotsTaken++;\n+    }\n+\n+    /** A common format used by all stats with decimals */\n+    public static final DecimalFormat STATS_DECIMALFORMAT = new DecimalFormat(\"#.##\");\n+\n+    public static double statFormat(Number number) {\n+      String stat = STATS_DECIMALFORMAT.format(number).replace(',', '.');\n+      return Double.parseDouble(stat);\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      return TranslatableComponent.of(\n+          \"match.stats\",\n+          TextColor.GRAY,\n+          TextComponent.of(kills, TextColor.GREEN),\n+          TextComponent.of(killstreak, TextColor.GREEN),\n+          TextComponent.of(deaths, TextColor.RED),\n+          TextComponent.of(getKD(), TextColor.GREEN));\n+    }\n+\n+    // Methods that gives stats with decimals already formatted\n+\n+    public double getKD() {\n+      double kd;\n+      if (deaths == 0) {\n+        kd = kills;\n+      } else {\n+        kd = statFormat(kills / (double) deaths);\n+      }\n+      return kd;\n+    }\n+\n+    public double getArrowAccuracy() {\n+      double acc;\n+      if (shotsTaken == 0) acc = 100;\n+      else acc = statFormat(shotsHit / (shotsTaken / (double) 100));\n+      return acc;\n+    }\n+\n+    public double getDamageDone() {\n+      return statFormat(damageDone);\n+    }\n+\n+    public double getBowDamage() {\n+      return statFormat(bowDamage);\n+    }\n+\n+    public double getDamageTaken() {\n+      return statFormat(damageTaken);\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onDamage(EntityDamageByEntityEvent event) {\n+    ParticipantState damager =\n+        match.needModule(TrackerMatchModule.class).getOwner(event.getDamager());\n+    ParticipantState damaged = match.getParticipantState(event.getEntity());\n+    if ((damaged != null && damager != null) && damaged.getId() == damager.getId()) return;\n+    boolean bow = event.getDamager() instanceof Arrow;\n+    if (damager != null) getPlayerStat(damager).onDamage(event.getFinalDamage(), bow);\n+    if (damaged != null) getPlayerStat(damaged).onDamaged(event.getFinalDamage());\n+  }\n+\n+  @EventHandler\n+  public void onShoot(EntityShootBowEvent event) {\n+    if (event.getEntity() instanceof Player) {\n+      MatchPlayer player = match.getPlayer(event.getEntity());\n+      if (player != null) getPlayerStat(player).onBowShoot();\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onDestroyableBreak(DestroyableHealthChangeEvent event) {\n+    DestroyableHealthChange change = event.getChange();\n+    if (change != null && change.getHealthChange() > 0 && change.getPlayerCause() != null)\n+      getPlayerStat(change.getPlayerCause()).onDestroyablePieceBroken(change.getHealthChange());\n+  }\n+\n+  @EventHandler\n+  public void onFlagCapture(FlagCaptureEvent event) {\n+    getPlayerStat(event.getCarrier()).onFlagCapture();\n+  }\n+\n+  @EventHandler\n+  public void onFlagHold(FlagPickupEvent event) {\n+    getPlayerStat(event.getCarrier()).onFlagPickup();\n+  }\n+\n+  @EventHandler\n+  public void onFlagDrop(FlagStateChangeEvent event) {\n+    if (event.getOldState() instanceof Carried)\n+      getPlayerStat(((Carried) event.getOldState()).getCarrier()).onFlagDrop();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    if (victim.getSettings().getValue(SettingKey.STATS).equals(SettingValue.STATS_ON)) {\n+      PlayerStats victimStats = getPlayerStat(victim);\n+\n+      victimStats.onDeath();\n+\n+      sendPlayerStats(victim, victimStats);\n+    }\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF\n+        && murderer.getSettings().getValue(SettingKey.STATS).equals(SettingValue.STATS_ON)) {\n+\n+      PlayerStats murdererStats = getPlayerStat(murderer);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendPlayerStats(murderer, murdererStats);\n+    }\n+  }\n+\n+  private void sendPlayerStats(MatchPlayer player, PlayerStats stats) {\n+    if (stats.hotbarTask != null && !stats.hotbarTask.isDone()) {\n+      stats.hotbarTask.cancel(true);\n+    }\n+    stats.hotbarTask = sendLongHotbarMessage(player, stats.getBasicStatsMessage());\n+  }\n+\n+  private Future<?> sendLongHotbarMessage(MatchPlayer player, Component message) {\n+    Future<?> task =\n+        match\n+            .getExecutor(MatchScope.LOADED)\n+            .scheduleWithFixedDelay(() -> player.showHotbar(message), 0, 1, TimeUnit.SECONDS);\n+\n+    match.getExecutor(MatchScope.LOADED).schedule(() -> task.cancel(true), 4, TimeUnit.SECONDS);\n+\n+    return task;\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+\n+    if (allPlayerStats.isEmpty()) return;\n+\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+    Map<UUID, Double> allDamage = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      getPlayerStat(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+      allDamage.put(playerUUID, playerStats.getDamageDone());\n+    }\n+\n+    Component killMessage = getMessage(\"match.stats.kills\", sortStats(allKills), TextColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"match.stats.killstreak\", sortStats(allKillstreaks), TextColor.GREEN);\n+    Component deathMessage = getMessage(\"match.stats.deaths\", sortStats(allDeaths), TextColor.RED);\n+    Map.Entry<UUID, Integer> bestBowshot = sortStats(allBowshots);\n+    if (bestBowshot.getValue() == 1)\n+      bestBowshot.setValue(2); // Avoids translating \"1 block\" vs \"n blocks\"\n+    Component bowshotMessage = getMessage(\"match.stats.bowshot\", bestBowshot, TextColor.YELLOW);\n+    Component damageMessage =\n+        getMessage(\"match.stats.damage\", sortStatsDouble(allDamage), TextColor.GREEN);\n+\n+    match\n+        .getExecutor(MatchScope.LOADED)\n+        .schedule(\n+            () -> {\n+              for (MatchPlayer viewer : match.getPlayers()) {\n+                if (viewer.getSettings().getValue(SettingKey.STATS) == SettingValue.STATS_OFF)\n+                  continue;\n+\n+                viewer.sendMessage(\n+                    TextFormatter.horizontalLineHeading(\n+                        viewer.getBukkit(),\n+                        TranslatableComponent.of(\"match.stats.title\", TextColor.YELLOW),\n+                        TextColor.WHITE));\n+                viewer.sendMessage(killMessage);\n+                viewer.sendMessage(killstreakMessage);\n+                viewer.sendMessage(deathMessage);\n+                if (bestBowshot.getValue() != 0) viewer.sendMessage(bowshotMessage);\n+                if (verboseStats) {\n+                  viewer.sendMessage(damageMessage);\n+                  viewer.getInventory().setItem(7, createToolItem(viewer));\n+                }\n+              }\n+            },\n+            5 + 1, // NOTE: This is 1 second after the votebook appears\n+            TimeUnit.SECONDS);\n+\n+    final Collection<Competitor> competitors = match.getCompetitors();\n+\n+    if (verboseStats && competitors.stream().allMatch(c -> c instanceof Team)) {\n+\n+      final List<InventoryMenuItem> items =\n+          competitors.stream()\n+              .map(c -> new TeamInventoryMenuItem(match, c))\n+              .collect(Collectors.toList());\n+\n+      endOfMatchMenu =\n+          competitors.size() <= 4\n+              ? InventoryMenuUtils.smallMenu(match, verboseStatsTitle, items)\n+              : InventoryMenuUtils.progressiveMenu(match, verboseStatsTitle, items);\n+    }\n+  }\n+\n+  private ItemStack createToolItem(MatchPlayer player) {\n+    ItemStack tool = new ItemStack(Material.RED_SANDSTONE);\n+    ItemMeta meta = tool.getItemMeta();\n+    Component displayName =\n+        TranslatableComponent.of(\"match.stats.title\", TextColor.GREEN, TextDecoration.BOLD);\n+    Component lore = TranslatableComponent.of(\"setting.lore\", TextColor.GRAY);\n+    meta.setDisplayName(TextTranslations.translateLegacy(displayName, player.getBukkit()));\n+    meta.setLore(Lists.newArrayList(TextTranslations.translateLegacy(lore, player.getBukkit())));\n+    meta.addItemFlags(ItemFlag.values());\n+    tool.setItemMeta(meta);\n+    return tool;\n+  }\n+\n+  @EventHandler\n+  public void onToolClick(PlayerInteractEvent event) {\n+    if (!verboseStats) return;\n+    Action action = event.getAction();\n+    if ((action == Action.RIGHT_CLICK_AIR || action == Action.RIGHT_CLICK_BLOCK)\n+        && match.isFinished()) {\n+      ItemStack item = event.getPlayer().getItemInHand();\n+\n+      if (item.getType() == Material.RED_SANDSTONE) {\n+        MatchPlayer player = match.getPlayer(event.getPlayer());\n+        if (player == null) return;\n+        endOfMatchMenu.display(player);\n+      }\n+    }\n+  }\n+\n+  private Map.Entry<UUID, Integer> sortStats(Map<UUID, Integer> map) {\n+    return map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+  }\n+\n+  private Map.Entry<UUID, Double> sortStatsDouble(Map<UUID, Double> map) {\n+    return map.entrySet().stream()\n+        .max(Comparator.comparingDouble(Map.Entry::getValue))\n+        .orElse(null);\n+  }\n+\n+  Component getMessage(\n+      String messageKey, Map.Entry<UUID, ? extends Number> mapEntry, TextColor color) {\n+    return TranslatableComponent.of(\n+        messageKey, playerName(mapEntry.getKey()), numberComponent(mapEntry.getValue(), color));\n+  }\n+\n+  public static Component numberComponent(Number stat, TextColor color) {\n+    double doubleStat = stat.doubleValue();\n+    if (doubleStat % 1 == 0) return TextComponent.of(stat.intValue(), color, TextDecoration.BOLD);\n+    else return TextComponent.of(doubleStat, color, TextDecoration.BOLD);", "originalCommit": "44794bc429b9aac52d4ce157e4595049d2cf96b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA3NzI2Nw==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r491077267", "bodyText": "What's the reason behind wrapping the string in a translatable component? \ud83e\udd14", "author": "applenick", "createdAt": "2020-09-18T16:58:44Z", "path": "util/src/main/java/tc/oc/pgm/util/text/types/PlayerComponent.java", "diffHunk": "@@ -92,7 +92,8 @@ static Component of(\n \n   // What an offline or vanished username renders as\n   static TextComponent.Builder formatOffline(String name, boolean plain) {\n-    TextComponent.Builder component = TextComponent.builder().append(name);\n+    TextComponent.Builder component =\n+        TextComponent.builder().append(TranslatableComponent.of(name));", "originalCommit": "44794bc429b9aac52d4ce157e4595049d2cf96b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcyNjIxNw==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r491726217", "bodyText": "Right, I wanted to use a translatable string key, but I realize I should require a Component instead of a String there in the first place. (Instead of hardcoded \"Unknown\" as it was previously I wanted \"misc.unknown\")\nI will revert this change and do a separate PR for this specific issue", "author": "KingOfSquares", "createdAt": "2020-09-20T19:38:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA3NzI2Nw=="}], "type": "inlineReview"}, {"oid": "9e2509642b94f8ffeb35b4a2251d9479500c0ab9", "url": "https://github.com/PGMDev/PGM/commit/9e2509642b94f8ffeb35b4a2251d9479500c0ab9", "message": "TeamInventoryMenuItem -> TeamStatsInventoryMenuItem\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>", "committedDate": "2020-09-21T10:17:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDExOTg3Ng==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r494119876", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                double acc;\n          \n          \n            \n                if (shotsTaken == 0) acc = Double.NaN;\n          \n          \n            \n                else acc = shotsHit / (shotsTaken / (double) 100);\n          \n          \n            \n                return acc;\n          \n          \n            \n                if (shotsTaken == 0) return Double.NaN;\n          \n          \n            \n                return shotsHit / (shotsTaken / (double) 100);\n          \n      \n    \n    \n  \n\nSimplify logic", "author": "Pablete1234", "createdAt": "2020-09-24T08:08:16Z", "path": "core/src/main/java/tc/oc/pgm/stats/PlayerStats.java", "diffHunk": "@@ -0,0 +1,188 @@\n+package tc.oc.pgm.stats;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.Future;\n+import net.kyori.text.Component;\n+import net.kyori.text.TextComponent;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+\n+/** A wrapper for stat info belonging to a {@link tc.oc.pgm.api.player.MatchPlayer} */\n+class PlayerStats {\n+  // K/D\n+  private int kills;\n+  private int deaths;\n+  private int killstreak; // Current killstreak\n+  private int killstreakMax; // The highest killstreak reached this match\n+\n+  // Bow\n+  private int longestBowKill;\n+  private double bowDamage;\n+  private int shotsTaken;\n+  private int shotsHit;\n+\n+  // Damage\n+  private double damageDone;\n+  private double damageTaken;\n+\n+  // Objectives\n+  private int destroyablePiecesBroken;\n+  private int flagsCaptured;\n+\n+  private Duration longestFlagHold = Duration.ZERO;\n+  private Instant longestFlagHoldCache;\n+\n+  // The task responsible for displaying the stats over the hotbar\n+  // See StatsMatchModule#sendLongHotbarMessage\n+  private Future<?> hotbarTaskCache;\n+\n+  // Methods to update the stats, should only be accessed by StatsMatchModule\n+\n+  protected void onMurder() {\n+    kills++;\n+    killstreak++;\n+    if (killstreak > killstreakMax) killstreakMax = killstreak;\n+  }\n+\n+  protected void onDeath() {\n+    deaths++;\n+    killstreak = 0;\n+  }\n+\n+  protected void onDamage(double damage, boolean bow) {\n+    damageDone += damage;\n+    if (bow) {\n+      bowDamage += damage;\n+      shotsHit++;\n+    }\n+  }\n+\n+  protected void onDamaged(double damage) {\n+    damageTaken += damage;\n+  }\n+\n+  protected void onDestroyablePieceBroken(int change) {\n+    destroyablePiecesBroken += change;\n+  }\n+\n+  protected void onFlagCapture() {\n+    flagsCaptured++;\n+    onFlagDrop();\n+  }\n+\n+  protected void onFlagPickup() {\n+    longestFlagHoldCache = Instant.now();\n+  }\n+\n+  protected void onFlagDrop() {\n+    setLongestFlagHold(\n+        Duration.ofMillis(Instant.now().toEpochMilli() - longestFlagHoldCache.toEpochMilli()));\n+  }\n+\n+  protected void setLongestFlagHold(Duration time) {\n+    if (longestFlagHold == null || (time.toNanos() - longestFlagHold.toNanos()) > 0)\n+      longestFlagHold = time;\n+  }\n+\n+  protected void setLongestBowKill(double distance) {\n+    if (distance > longestBowKill) {\n+      longestBowKill = (int) Math.ceil(distance);\n+    }\n+  }\n+\n+  protected void onBowShoot() {\n+    shotsTaken++;\n+  }\n+\n+  // Makes a simple stat message for this player that fits in one line\n+\n+  public Component getBasicStatsMessage() {\n+    return TranslatableComponent.of(\n+        \"match.stats\",\n+        TextColor.GRAY,\n+        TextComponent.of(kills, TextColor.GREEN),\n+        TextComponent.of(killstreak, TextColor.GREEN),\n+        TextComponent.of(deaths, TextColor.RED),\n+        TextComponent.of(getKD(), TextColor.GREEN));\n+  }\n+\n+  // Getters, both raw stats and some handy calculations\n+\n+  public double getKD() {\n+    double kd;\n+    if (deaths == 0) {\n+      kd = kills;\n+    } else {\n+      kd = kills / (double) deaths;\n+    }\n+    return kd;\n+  }\n+\n+  public double getArrowAccuracy() {\n+    double acc;\n+    if (shotsTaken == 0) acc = Double.NaN;\n+    else acc = shotsHit / (shotsTaken / (double) 100);\n+    return acc;", "originalCommit": "9e2509642b94f8ffeb35b4a2251d9479500c0ab9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEyMDg2Mg==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r494120862", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                double kd;\n          \n          \n            \n                if (deaths == 0) {\n          \n          \n            \n                  kd = kills;\n          \n          \n            \n                } else {\n          \n          \n            \n                  kd = kills / (double) deaths;\n          \n          \n            \n                }\n          \n          \n            \n                return kd;\n          \n          \n            \n            return kills / Math.max(1d, (double) deaths);\n          \n      \n    \n    \n  \n\nSimplify this, you may be able to get rid of the double cast too if the first parameter is explicitly double", "author": "Pablete1234", "createdAt": "2020-09-24T08:09:52Z", "path": "core/src/main/java/tc/oc/pgm/stats/PlayerStats.java", "diffHunk": "@@ -0,0 +1,188 @@\n+package tc.oc.pgm.stats;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.Future;\n+import net.kyori.text.Component;\n+import net.kyori.text.TextComponent;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+\n+/** A wrapper for stat info belonging to a {@link tc.oc.pgm.api.player.MatchPlayer} */\n+class PlayerStats {\n+  // K/D\n+  private int kills;\n+  private int deaths;\n+  private int killstreak; // Current killstreak\n+  private int killstreakMax; // The highest killstreak reached this match\n+\n+  // Bow\n+  private int longestBowKill;\n+  private double bowDamage;\n+  private int shotsTaken;\n+  private int shotsHit;\n+\n+  // Damage\n+  private double damageDone;\n+  private double damageTaken;\n+\n+  // Objectives\n+  private int destroyablePiecesBroken;\n+  private int flagsCaptured;\n+\n+  private Duration longestFlagHold = Duration.ZERO;\n+  private Instant longestFlagHoldCache;\n+\n+  // The task responsible for displaying the stats over the hotbar\n+  // See StatsMatchModule#sendLongHotbarMessage\n+  private Future<?> hotbarTaskCache;\n+\n+  // Methods to update the stats, should only be accessed by StatsMatchModule\n+\n+  protected void onMurder() {\n+    kills++;\n+    killstreak++;\n+    if (killstreak > killstreakMax) killstreakMax = killstreak;\n+  }\n+\n+  protected void onDeath() {\n+    deaths++;\n+    killstreak = 0;\n+  }\n+\n+  protected void onDamage(double damage, boolean bow) {\n+    damageDone += damage;\n+    if (bow) {\n+      bowDamage += damage;\n+      shotsHit++;\n+    }\n+  }\n+\n+  protected void onDamaged(double damage) {\n+    damageTaken += damage;\n+  }\n+\n+  protected void onDestroyablePieceBroken(int change) {\n+    destroyablePiecesBroken += change;\n+  }\n+\n+  protected void onFlagCapture() {\n+    flagsCaptured++;\n+    onFlagDrop();\n+  }\n+\n+  protected void onFlagPickup() {\n+    longestFlagHoldCache = Instant.now();\n+  }\n+\n+  protected void onFlagDrop() {\n+    setLongestFlagHold(\n+        Duration.ofMillis(Instant.now().toEpochMilli() - longestFlagHoldCache.toEpochMilli()));\n+  }\n+\n+  protected void setLongestFlagHold(Duration time) {\n+    if (longestFlagHold == null || (time.toNanos() - longestFlagHold.toNanos()) > 0)\n+      longestFlagHold = time;\n+  }\n+\n+  protected void setLongestBowKill(double distance) {\n+    if (distance > longestBowKill) {\n+      longestBowKill = (int) Math.ceil(distance);\n+    }\n+  }\n+\n+  protected void onBowShoot() {\n+    shotsTaken++;\n+  }\n+\n+  // Makes a simple stat message for this player that fits in one line\n+\n+  public Component getBasicStatsMessage() {\n+    return TranslatableComponent.of(\n+        \"match.stats\",\n+        TextColor.GRAY,\n+        TextComponent.of(kills, TextColor.GREEN),\n+        TextComponent.of(killstreak, TextColor.GREEN),\n+        TextComponent.of(deaths, TextColor.RED),\n+        TextComponent.of(getKD(), TextColor.GREEN));\n+  }\n+\n+  // Getters, both raw stats and some handy calculations\n+\n+  public double getKD() {\n+    double kd;\n+    if (deaths == 0) {\n+      kd = kills;\n+    } else {\n+      kd = kills / (double) deaths;\n+    }\n+    return kd;", "originalCommit": "9e2509642b94f8ffeb35b4a2251d9479500c0ab9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUzNzc4Mg==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r494537782", "bodyText": "It will(is what my IDE says)! Since Math.max returns a double in that case", "author": "KingOfSquares", "createdAt": "2020-09-24T18:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEyMDg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEyODQ2Mw==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r494128463", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (Double.isNaN(stat.doubleValue()))\n          \n          \n            \n                if (Double.isNaN(doubleStat))", "author": "Pablete1234", "createdAt": "2020-09-24T08:21:59Z", "path": "core/src/main/java/tc/oc/pgm/stats/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,377 @@\n+package tc.oc.pgm.stats;\n+\n+import com.google.common.collect.Lists;\n+import java.text.DecimalFormat;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.kyori.text.Component;\n+import net.kyori.text.TextComponent;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.kyori.text.format.TextDecoration;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Material;\n+import org.bukkit.entity.Arrow;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.block.Action;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityShootBowEvent;\n+import org.bukkit.event.player.PlayerInteractEvent;\n+import org.bukkit.event.player.PlayerJoinEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.inventory.ItemFlag;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.ParticipantState;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.api.setting.SettingKey;\n+import tc.oc.pgm.api.setting.SettingValue;\n+import tc.oc.pgm.destroyable.DestroyableHealthChange;\n+import tc.oc.pgm.destroyable.DestroyableHealthChangeEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.flag.event.FlagCaptureEvent;\n+import tc.oc.pgm.flag.event.FlagPickupEvent;\n+import tc.oc.pgm.flag.event.FlagStateChangeEvent;\n+import tc.oc.pgm.flag.state.Carried;\n+import tc.oc.pgm.menu.InventoryMenu;\n+import tc.oc.pgm.menu.InventoryMenuItem;\n+import tc.oc.pgm.menu.InventoryMenuUtils;\n+import tc.oc.pgm.teams.Team;\n+import tc.oc.pgm.tracker.TrackerMatchModule;\n+import tc.oc.pgm.tracker.info.ProjectileInfo;\n+import tc.oc.pgm.util.named.NameStyle;\n+import tc.oc.pgm.util.text.TextFormatter;\n+import tc.oc.pgm.util.text.TextTranslations;\n+import tc.oc.pgm.util.text.types.PlayerComponent;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+  // Since Bukkit#getOfflinePlayer reads the cached user files, and those files have an expire date\n+  // + will be wiped if X amount of players join, we need a separate cache for players with stats\n+  private final Map<UUID, String> cachedUsernames = new HashMap<>();\n+\n+  private final boolean verboseStats = PGM.get().getConfiguration().showVerboseStats();\n+  private final Component verboseStatsTitle = TranslatableComponent.of(\"match.stats.title\");\n+\n+  /** A common format used by all stats with decimals */\n+  public static final DecimalFormat STATS_DECIMALFORMAT = new DecimalFormat(\"#.##\");\n+\n+  // Defined at match end, see #onMatchEnd\n+  private InventoryMenu endOfMatchMenu;\n+\n+  public StatsMatchModule(Match match) {\n+    this.match = match;\n+  }\n+\n+  @EventHandler\n+  public void onDamage(EntityDamageByEntityEvent event) {\n+    ParticipantState damager =\n+        match.needModule(TrackerMatchModule.class).getOwner(event.getDamager());\n+    ParticipantState damaged = match.getParticipantState(event.getEntity());\n+    if ((damaged != null && damager != null) && damaged.getId() == damager.getId()) return;\n+    boolean bow = event.getDamager() instanceof Arrow;\n+    if (damager != null) getPlayerStat(damager).onDamage(event.getFinalDamage(), bow);\n+    if (damaged != null) getPlayerStat(damaged).onDamaged(event.getFinalDamage());\n+  }\n+\n+  @EventHandler\n+  public void onShoot(EntityShootBowEvent event) {\n+    if (event.getEntity() instanceof Player) {\n+      MatchPlayer player = match.getPlayer(event.getEntity());\n+      if (player != null) getPlayerStat(player).onBowShoot();\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onDestroyableBreak(DestroyableHealthChangeEvent event) {\n+    DestroyableHealthChange change = event.getChange();\n+    if (change != null && change.getHealthChange() > 0 && change.getPlayerCause() != null)\n+      getPlayerStat(change.getPlayerCause()).onDestroyablePieceBroken(change.getHealthChange());\n+  }\n+\n+  @EventHandler\n+  public void onFlagCapture(FlagCaptureEvent event) {\n+    getPlayerStat(event.getCarrier()).onFlagCapture();\n+  }\n+\n+  @EventHandler\n+  public void onFlagHold(FlagPickupEvent event) {\n+    getPlayerStat(event.getCarrier()).onFlagPickup();\n+  }\n+\n+  @EventHandler\n+  public void onFlagDrop(FlagStateChangeEvent event) {\n+    if (event.getOldState() instanceof Carried)\n+      getPlayerStat(((Carried) event.getOldState()).getCarrier()).onFlagDrop();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    if (victim.getSettings().getValue(SettingKey.STATS).equals(SettingValue.STATS_ON)) {\n+      PlayerStats victimStats = getPlayerStat(victim);\n+\n+      victimStats.onDeath();\n+\n+      sendPlayerStats(victim, victimStats);\n+    }\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF\n+        && murderer.getSettings().getValue(SettingKey.STATS).equals(SettingValue.STATS_ON)) {\n+\n+      PlayerStats murdererStats = getPlayerStat(murderer);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendPlayerStats(murderer, murdererStats);\n+    }\n+  }\n+\n+  private void sendPlayerStats(MatchPlayer player, PlayerStats stats) {\n+    if (stats.getHotbarTask() != null && !stats.getHotbarTask().isDone()) {\n+      stats.getHotbarTask().cancel(true);\n+    }\n+    stats.putHotbarTaskCache(sendLongHotbarMessage(player, stats.getBasicStatsMessage()));\n+  }\n+\n+  private Future<?> sendLongHotbarMessage(MatchPlayer player, Component message) {\n+    Future<?> task =\n+        match\n+            .getExecutor(MatchScope.LOADED)\n+            .scheduleWithFixedDelay(() -> player.showHotbar(message), 0, 1, TimeUnit.SECONDS);\n+\n+    match.getExecutor(MatchScope.LOADED).schedule(() -> task.cancel(true), 4, TimeUnit.SECONDS);\n+\n+    return task;\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+\n+    if (allPlayerStats.isEmpty()) return;\n+\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+    Map<UUID, Double> allDamage = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      getPlayerStat(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.getKills());\n+      allKillstreaks.put(playerUUID, playerStats.getMaxKillstreak());\n+      allDeaths.put(playerUUID, playerStats.getDeaths());\n+      allBowshots.put(playerUUID, playerStats.getLongestBowKill());\n+      allDamage.put(playerUUID, playerStats.getDamageDone());\n+    }\n+\n+    Component killMessage = getMessage(\"match.stats.kills\", sortStats(allKills), TextColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"match.stats.killstreak\", sortStats(allKillstreaks), TextColor.GREEN);\n+    Component deathMessage = getMessage(\"match.stats.deaths\", sortStats(allDeaths), TextColor.RED);\n+    Map.Entry<UUID, Integer> bestBowshot = sortStats(allBowshots);\n+    if (bestBowshot.getValue() == 1)\n+      bestBowshot.setValue(2); // Avoids translating \"1 block\" vs \"n blocks\"\n+    Component bowshotMessage = getMessage(\"match.stats.bowshot\", bestBowshot, TextColor.YELLOW);\n+    Component damageMessage =\n+        getMessage(\"match.stats.damage\", sortStatsDouble(allDamage), TextColor.GREEN);\n+\n+    match\n+        .getExecutor(MatchScope.LOADED)\n+        .schedule(\n+            () -> {\n+              for (MatchPlayer viewer : match.getPlayers()) {\n+                if (viewer.getSettings().getValue(SettingKey.STATS) == SettingValue.STATS_OFF)\n+                  continue;\n+\n+                viewer.sendMessage(\n+                    TextFormatter.horizontalLineHeading(\n+                        viewer.getBukkit(),\n+                        TranslatableComponent.of(\"match.stats.title\", TextColor.YELLOW),\n+                        TextColor.WHITE));\n+                viewer.sendMessage(killMessage);\n+                viewer.sendMessage(killstreakMessage);\n+                viewer.sendMessage(deathMessage);\n+                if (bestBowshot.getValue() != 0) viewer.sendMessage(bowshotMessage);\n+                if (verboseStats) {\n+                  viewer.sendMessage(damageMessage);\n+                  viewer.getInventory().setItem(7, createToolItem(viewer));\n+                }\n+              }\n+            },\n+            5 + 1, // NOTE: This is 1 second after the votebook appears\n+            TimeUnit.SECONDS);\n+\n+    final Collection<Competitor> competitors = match.getCompetitors();\n+\n+    if (verboseStats && competitors.stream().allMatch(c -> c instanceof Team)) {\n+\n+      final List<InventoryMenuItem> items =\n+          competitors.stream()\n+              .map(c -> new TeamStatsInventoryMenuItem(match, c))\n+              .collect(Collectors.toList());\n+\n+      endOfMatchMenu =\n+          competitors.size() <= 4\n+              ? InventoryMenuUtils.smallMenu(match, verboseStatsTitle, items)\n+              : InventoryMenuUtils.progressiveMenu(match, verboseStatsTitle, items);\n+    }\n+  }\n+\n+  private ItemStack createToolItem(MatchPlayer player) {\n+    ItemStack tool = new ItemStack(Material.RED_SANDSTONE);\n+    ItemMeta meta = tool.getItemMeta();\n+    Component displayName =\n+        TranslatableComponent.of(\"match.stats.title\", TextColor.GREEN, TextDecoration.BOLD);\n+    Component lore = TranslatableComponent.of(\"setting.lore\", TextColor.GRAY);\n+    meta.setDisplayName(TextTranslations.translateLegacy(displayName, player.getBukkit()));\n+    meta.setLore(Lists.newArrayList(TextTranslations.translateLegacy(lore, player.getBukkit())));\n+    meta.addItemFlags(ItemFlag.values());\n+    tool.setItemMeta(meta);\n+    return tool;\n+  }\n+\n+  @EventHandler\n+  public void onToolClick(PlayerInteractEvent event) {\n+    if (!verboseStats) return;\n+    Action action = event.getAction();\n+    if ((action == Action.RIGHT_CLICK_AIR || action == Action.RIGHT_CLICK_BLOCK)\n+        && match.isFinished()) {\n+      ItemStack item = event.getPlayer().getItemInHand();\n+\n+      if (item.getType() == Material.RED_SANDSTONE) {\n+        MatchPlayer player = match.getPlayer(event.getPlayer());\n+        if (player == null) return;\n+        endOfMatchMenu.display(player);\n+      }\n+    }\n+  }\n+\n+  private Map.Entry<UUID, Integer> sortStats(Map<UUID, Integer> map) {\n+    return map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+  }\n+\n+  private Map.Entry<UUID, Double> sortStatsDouble(Map<UUID, Double> map) {\n+    return map.entrySet().stream()\n+        .max(Comparator.comparingDouble(Map.Entry::getValue))\n+        .orElse(null);\n+  }\n+\n+  Component getMessage(\n+      String messageKey, Map.Entry<UUID, ? extends Number> mapEntry, TextColor color) {\n+    return TranslatableComponent.of(\n+        messageKey, playerName(mapEntry.getKey()), numberComponent(mapEntry.getValue(), color));\n+  }\n+\n+  /**\n+   * Wraps a {@link Number} in a {@link TextComponent} that is bolded and colored with the given\n+   * {@link TextColor}.\n+   *\n+   * <p>If the given number is a double, it is formatted with {@link\n+   * StatsMatchModule#STATS_DECIMALFORMAT}.\n+   *\n+   * <p>If the number is NaN \"-\" is wrapped instead\n+   *\n+   * @param stat The number you want wrapped in a {@link Component}\n+   * @param color The color you want the number to be\n+   * @return A bolded {@link Component} wrapping the given number or \"-\" if NaN\n+   */\n+  public static Component numberComponent(Number stat, TextColor color) {\n+    double doubleStat = stat.doubleValue();\n+    String returnValue;\n+    if (Double.isNaN(stat.doubleValue()))", "originalCommit": "9e2509642b94f8ffeb35b4a2251d9479500c0ab9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "750f8cc2dd467fb05a85792b3db321e5a385680f", "url": "https://github.com/PGMDev/PGM/commit/750f8cc2dd467fb05a85792b3db321e5a385680f", "message": "Simplify some logic\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>", "committedDate": "2020-09-24T18:51:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY0MzY0OQ==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r494643649", "bodyText": "Coloured leather helm to match the team picker pls \ud83d\ude4f", "author": "Pugzy", "createdAt": "2020-09-24T22:23:49Z", "path": "core/src/main/java/tc/oc/pgm/stats/TeamStatsInventoryMenuItem.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package tc.oc.pgm.stats;\n+\n+import static tc.oc.pgm.stats.StatsMatchModule.numberComponent;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import net.kyori.text.Component;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Material;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.inventory.ClickType;\n+import org.bukkit.inventory.ItemFlag;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.menu.InventoryMenu;\n+import tc.oc.pgm.menu.InventoryMenuItem;\n+import tc.oc.pgm.menu.InventoryMenuUtils;\n+import tc.oc.pgm.util.bukkit.BukkitUtils;\n+import tc.oc.pgm.util.text.TextTranslations;\n+\n+public class TeamStatsInventoryMenuItem implements InventoryMenuItem {\n+\n+  private final Competitor team;\n+  private final InventoryMenu teamSubGUI;\n+\n+  private final TextColor RESET = TextColor.WHITE;\n+\n+  TeamStatsInventoryMenuItem(Match match, Competitor team) {\n+    this.team = team;\n+    this.teamSubGUI =\n+        InventoryMenuUtils.prettyMenu(\n+            match,\n+            TranslatableComponent.of(\"match.stats.title\"),\n+            team.getPlayers().stream()\n+                .map(PlayerStatsInventoryMenuItem::new)\n+                .collect(Collectors.toList()));\n+  }\n+\n+  @Override\n+  public Component getName() {\n+    return TranslatableComponent.of(\"match.stats.team\", team.getName());\n+  }\n+\n+  @Override\n+  public ChatColor getColor() {\n+    return ChatColor.valueOf(team.getColor().name());\n+  }\n+\n+  @Override\n+  public List<String> getLore(MatchPlayer player) {\n+\n+    StatsMatchModule smm = player.getMatch().needModule(StatsMatchModule.class);\n+    List<String> lore = new ArrayList<>();\n+    int teamKills = 0;\n+    int teamDeaths = 0;\n+    double damageDone = 0;\n+    double damageTaken = 0;\n+    double bowDamage = 0;\n+    int shotsTaken = 0;\n+    int shotsHit = 0;\n+    for (MatchPlayer teamPlayer : team.getPlayers()) {\n+      PlayerStats stats = smm.getPlayerStat(teamPlayer.getId());\n+      teamKills += stats.getKills();\n+      teamDeaths += stats.getDeaths();\n+      damageDone += stats.getDamageDone();\n+      damageTaken += stats.getDamageTaken();\n+      bowDamage += stats.getBowDamage();\n+      shotsTaken += stats.getShotsTaken();\n+      shotsHit += stats.getShotsHit();\n+    }\n+\n+    double teamKD = teamDeaths == 0 ? teamKills : teamKills / (double) teamDeaths;\n+    double teamBowAcc = shotsTaken == 0 ? Double.NaN : shotsHit / (shotsTaken / (double) 100);\n+    double teamDamageGiven = damageDone;\n+    double bowDamageGiven = bowDamage;\n+    double teamDamageTaken = damageTaken;\n+\n+    Component killLore =\n+        TranslatableComponent.of(\n+            \"match.stats.kills.concise\", RESET, numberComponent(teamKills, TextColor.GREEN));\n+    Component deathLore =\n+        TranslatableComponent.of(\n+            \"match.stats.deaths.concise\", RESET, numberComponent(teamDeaths, TextColor.RED));\n+    Component kdLore =\n+        TranslatableComponent.of(\n+            \"match.stats.kd.concise\", RESET, numberComponent(teamKD, TextColor.GREEN));\n+    Component damageLore =\n+        TranslatableComponent.of(\n+            \"match.stats.damage.concise\",\n+            RESET,\n+            numberComponent(teamDamageGiven, TextColor.GREEN),\n+            numberComponent(bowDamageGiven, TextColor.YELLOW),\n+            numberComponent(teamDamageTaken, TextColor.RED));\n+    Component bowLore =\n+        TranslatableComponent.of(\n+            \"match.stats.bow.concise\",\n+            RESET,\n+            numberComponent(shotsTaken, TextColor.YELLOW),\n+            numberComponent(teamBowAcc, TextColor.YELLOW));\n+\n+    Player bukkit = player.getBukkit();\n+\n+    lore.add(TextTranslations.translateLegacy(killLore, bukkit));\n+    lore.add(TextTranslations.translateLegacy(deathLore, bukkit));\n+    lore.add(TextTranslations.translateLegacy(kdLore, bukkit));\n+    lore.add(TextTranslations.translateLegacy(damageLore, bukkit));\n+    lore.add(TextTranslations.translateLegacy(bowLore, bukkit));\n+\n+    return lore;\n+  }\n+\n+  @Override\n+  public Material getMaterial(MatchPlayer player) {\n+    return Material.WOOL;", "originalCommit": "750f8cc2dd467fb05a85792b3db321e5a385680f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc4MjA3Mg==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r494782072", "bodyText": "I would not make this a helmet, people will think it's the team picker. Maybe chestplate or leggings (boots should be used for leaving even tho that's not on this version of pgm)", "author": "Pablete1234", "createdAt": "2020-09-25T06:49:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY0MzY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgyMTM5Mw==", "url": "https://github.com/PGMDev/PGM/pull/598#discussion_r494821393", "bodyText": "I think leggings look weird, but chest plates is a good idea!", "author": "KingOfSquares", "createdAt": "2020-09-25T08:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY0MzY0OQ=="}], "type": "inlineReview"}, {"oid": "6fa972328f46315e9f79662366b85fb9d59061c5", "url": "https://github.com/PGMDev/PGM/commit/6fa972328f46315e9f79662366b85fb9d59061c5", "message": "Change the icon for team stats to colored chestplates\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>", "committedDate": "2020-10-03T14:04:42Z", "type": "forcePushed"}, {"oid": "85b095862a57297c9ad3870265062919954e235e", "url": "https://github.com/PGMDev/PGM/commit/85b095862a57297c9ad3870265062919954e235e", "message": "Change the icon for team stats to colored chestplates\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>", "committedDate": "2020-10-07T22:00:53Z", "type": "forcePushed"}, {"oid": "12008984ec8877d1c2c9f229d330d3f0e006ebf9", "url": "https://github.com/PGMDev/PGM/commit/12008984ec8877d1c2c9f229d330d3f0e006ebf9", "message": "Verbose stats\n- Rip commit history\n\n- Also includes a refactor of InventoryMenu\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nFix some logic and prepare for longestFlagHold\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nAdd longest flag hold\n- some pretty stuff\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nEven prettier\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nReady for release\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nRemove old code\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nReviews and some javadoc\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nMake inventory title a Component\n instead of TranslatableComponent\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nVerbose stats\n- Rip commit history\n\n- Also includes a refactor of InventoryMenu\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nFix some logic and prepare for longestFlagHold\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nAdd longest flag hold\n- some pretty stuff\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nEven prettier\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nReady for release\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nRemove old code\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nReviews and some javadoc\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nCleanup\n- TranslatableComponent -> Component\n- Remove some old debug stuff\n- Fix some typos and javadoc stuff\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nPass all formatted doubles as doubles instead of Strings\n- Determine if a number is an int or double in StatsMatchModule#numberComponent\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nUse translatable instead of String\n- Rename hotbar task in PlayerStats\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nOnly display verbose stats if all competitors are Teams\n-Format\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nCorrectly parse doubles++\n- Fix page bug in InventoryMenuUtils#prettyMenu\n- Only display damage done if verbose stats is enabled\n- fix bad code in StatsMatchModule#getBasicStatsMessage\n- fix bad casting in StatsMatchModule#numberComponent\n- make sure damages used in StatsMatchModule#onMatchEnd uses the formatted damage numbers\n- limit ability to fetch unformatted doubles from PlayerStats\n- Fix flag stats\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nMove formatting of doubles\n- Into StatsMatchModule#numberComponent\n- If a stat is NaN it is displayed as \"-\"\n- Revert change to PlayerComponent(will be its own PR)\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nMove out PlayerStats to its own class\n- change access to stat values\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nTeamInventoryMenuItem -> TeamStatsInventoryMenuItem\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nSimplify some logic\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nChange the icon for team stats to colored chestplates\n\nSigned-off-by: KingSimon <simonmorland@gmail.com>\n\nClean up\n\nSigned-off-by: KingSimon <manmusic979@gmail.com>\nSigned-off-by: KingSimon <simonmorland@gmail.com>", "committedDate": "2020-11-18T00:35:04Z", "type": "commit"}, {"oid": "03e2e7557c67fac5bdbb8c16ea18f9e421d4e325", "url": "https://github.com/PGMDev/PGM/commit/03e2e7557c67fac5bdbb8c16ea18f9e421d4e325", "message": "Fix destroyable stat\n- remove detour in InventoryMenu\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-11-18T00:35:04Z", "type": "commit"}, {"oid": "4b89d2f9c1edce64c3815e9254b2214ce92099e0", "url": "https://github.com/PGMDev/PGM/commit/4b89d2f9c1edce64c3815e9254b2214ce92099e0", "message": "Fix translations\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-11-18T00:35:04Z", "type": "commit"}, {"oid": "d2794840330c68f509b7d3c3c7dde9239c0b38b5", "url": "https://github.com/PGMDev/PGM/commit/d2794840330c68f509b7d3c3c7dde9239c0b38b5", "message": "Remove verbose damage stat\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-11-18T00:35:04Z", "type": "commit"}, {"oid": "0e6b1d91798526638fb48439ef110a9ed754405b", "url": "https://github.com/PGMDev/PGM/commit/0e6b1d91798526638fb48439ef110a9ed754405b", "message": "Revert \"Remove verbose damage stat\"\n\nThis reverts commit 7ad26b070c44e7062a32d2d06ab13806edec45c8.", "committedDate": "2020-11-18T00:35:04Z", "type": "commit"}, {"oid": "a5070cfed393d387e7732f28b79721bd52e1d074", "url": "https://github.com/PGMDev/PGM/commit/a5070cfed393d387e7732f28b79721bd52e1d074", "message": "Shorten big numbers\n- Stats like damage can get really big and needs to be shortened to fit on the screen\n- Tweak the translation syntax of the verbose damage stat\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-11-18T00:35:04Z", "type": "forcePushed"}, {"oid": "c0c5df3b35f815c34017ec1284b5ffe95decb561", "url": "https://github.com/PGMDev/PGM/commit/c0c5df3b35f815c34017ec1284b5ffe95decb561", "message": "Shorten big numbers\n                                                         - Stats like damage can get really big and needs to be shortened to fit on the screen\n                                                         - Tweak the translation syntax of the verbose damage stat\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-11-18T00:36:34Z", "type": "commit"}, {"oid": "c0c5df3b35f815c34017ec1284b5ffe95decb561", "url": "https://github.com/PGMDev/PGM/commit/c0c5df3b35f815c34017ec1284b5ffe95decb561", "message": "Shorten big numbers\n                                                         - Stats like damage can get really big and needs to be shortened to fit on the screen\n                                                         - Tweak the translation syntax of the verbose damage stat\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-11-18T00:36:34Z", "type": "forcePushed"}, {"oid": "c8d2237982c14f94b953a174c9c9fd3ac167b3d8", "url": "https://github.com/PGMDev/PGM/commit/c8d2237982c14f94b953a174c9c9fd3ac167b3d8", "message": "Actually fix translation\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-11-18T00:38:31Z", "type": "commit"}]}