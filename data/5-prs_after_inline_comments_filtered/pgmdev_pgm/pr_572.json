{"pr_number": 572, "pr_title": "Implement legacy tab", "pr_createdAt": "2020-07-24T21:43:19Z", "pr_url": "https://github.com/PGMDev/PGM/pull/572", "timeline": [{"oid": "5007347c7c36382cc4ff04eff54e4c145c5ec898", "url": "https://github.com/PGMDev/PGM/commit/5007347c7c36382cc4ff04eff54e4c145c5ec898", "message": "Implement legacy tab\n\nSigned-off-by: Pablete1234 <pabloherrerapalacio@gmail.com>", "committedDate": "2020-07-25T03:22:40Z", "type": "forcePushed"}, {"oid": "35b867de6f57226daec9998ada5d6c7d98b3acc4", "url": "https://github.com/PGMDev/PGM/commit/35b867de6f57226daec9998ada5d6c7d98b3acc4", "message": "Implement legacy tab\n\nSigned-off-by: Pablete1234 <pabloherrerapalacio@gmail.com>", "committedDate": "2020-07-25T03:33:48Z", "type": "forcePushed"}, {"oid": "eafe1e11fcbffac8f9d30ddfabb4c94449936b30", "url": "https://github.com/PGMDev/PGM/commit/eafe1e11fcbffac8f9d30ddfabb4c94449936b30", "message": "Implement legacy tab\n\nSigned-off-by: Pablete1234 <pabloherrerapalacio@gmail.com>", "committedDate": "2020-07-25T03:55:35Z", "type": "commit"}, {"oid": "eafe1e11fcbffac8f9d30ddfabb4c94449936b30", "url": "https://github.com/PGMDev/PGM/commit/eafe1e11fcbffac8f9d30ddfabb4c94449936b30", "message": "Implement legacy tab\n\nSigned-off-by: Pablete1234 <pabloherrerapalacio@gmail.com>", "committedDate": "2020-07-25T03:55:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQxMTM5Mg==", "url": "https://github.com/PGMDev/PGM/pull/572#discussion_r460411392", "bodyText": "Can we use PGM scheduler primitives?", "author": "Electroid", "createdAt": "2020-07-25T14:41:28Z", "path": "core/src/main/java/tc/oc/pgm/tablist/LegacyMatchTabDisplay.java", "diffHunk": "@@ -0,0 +1,419 @@\n+package tc.oc.pgm.tablist;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.TreeSet;\n+import net.kyori.text.TextComponent;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.kyori.text.format.TextDecoration;\n+import org.bukkit.ChatColor;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.HandlerList;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.player.PlayerJoinEvent;\n+import org.bukkit.event.player.PlayerLocaleChangeEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.scheduler.BukkitTask;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.party.Party;\n+import tc.oc.pgm.api.party.event.PartyRenameEvent;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.events.PlayerVanishEvent;\n+import tc.oc.pgm.events.PlayerJoinMatchEvent;\n+import tc.oc.pgm.events.PlayerPartyChangeEvent;\n+import tc.oc.pgm.ffa.FreeForAllMatchModule;\n+import tc.oc.pgm.ffa.Tribute;\n+import tc.oc.pgm.teams.Team;\n+import tc.oc.pgm.teams.events.TeamResizeEvent;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.ViaUtils;\n+import tc.oc.pgm.util.named.NameStyle;\n+import tc.oc.pgm.util.tablist.TabDisplay;\n+import tc.oc.pgm.util.text.TextTranslations;\n+import tc.oc.pgm.util.text.types.PlayerComponent;\n+\n+/** 1.7 legacy tablist implementation */\n+public class LegacyMatchTabDisplay implements Listener {\n+\n+  private static final int WIDTH = 3;\n+\n+  // Maximum players that can be listed per team in non-compact mode, which is\n+  // the full height minus the header, blank row, and team header.\n+  private static final int MAX_TEAM_SIZE = TabDisplay.HEIGHT - 3;\n+\n+  // Number of players below the max before changing back to non-compact mode\n+  private static final int COMPACT_MODE_HYSTERESIS = 2;\n+\n+  private final PGM pgm;\n+  private final TabDisplay tabDisplay;\n+  private BukkitTask timeUpdateTask;\n+  private BukkitTask deferredRenderTask;", "originalCommit": "eafe1e11fcbffac8f9d30ddfabb4c94449936b30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQxMTQ1MQ==", "url": "https://github.com/PGMDev/PGM/pull/572#discussion_r460411451", "bodyText": ">", "author": "Electroid", "createdAt": "2020-07-25T14:41:59Z", "path": "core/src/main/java/tc/oc/pgm/tablist/LegacyMatchTabDisplay.java", "diffHunk": "@@ -0,0 +1,419 @@\n+package tc.oc.pgm.tablist;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.TreeSet;\n+import net.kyori.text.TextComponent;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.kyori.text.format.TextDecoration;\n+import org.bukkit.ChatColor;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.HandlerList;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.player.PlayerJoinEvent;\n+import org.bukkit.event.player.PlayerLocaleChangeEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.scheduler.BukkitTask;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.party.Party;\n+import tc.oc.pgm.api.party.event.PartyRenameEvent;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.events.PlayerVanishEvent;\n+import tc.oc.pgm.events.PlayerJoinMatchEvent;\n+import tc.oc.pgm.events.PlayerPartyChangeEvent;\n+import tc.oc.pgm.ffa.FreeForAllMatchModule;\n+import tc.oc.pgm.ffa.Tribute;\n+import tc.oc.pgm.teams.Team;\n+import tc.oc.pgm.teams.events.TeamResizeEvent;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.ViaUtils;\n+import tc.oc.pgm.util.named.NameStyle;\n+import tc.oc.pgm.util.tablist.TabDisplay;\n+import tc.oc.pgm.util.text.TextTranslations;\n+import tc.oc.pgm.util.text.types.PlayerComponent;\n+\n+/** 1.7 legacy tablist implementation */\n+public class LegacyMatchTabDisplay implements Listener {\n+\n+  private static final int WIDTH = 3;\n+\n+  // Maximum players that can be listed per team in non-compact mode, which is\n+  // the full height minus the header, blank row, and team header.\n+  private static final int MAX_TEAM_SIZE = TabDisplay.HEIGHT - 3;\n+\n+  // Number of players below the max before changing back to non-compact mode\n+  private static final int COMPACT_MODE_HYSTERESIS = 2;\n+\n+  private final PGM pgm;\n+  private final TabDisplay tabDisplay;\n+  private BukkitTask timeUpdateTask;\n+  private BukkitTask deferredRenderTask;\n+\n+  // True: use all columns as a single list of all players\n+  // False: use a full column for each team\n+  private boolean compact;\n+\n+  public LegacyMatchTabDisplay(PGM pgm) {\n+    this.pgm = pgm;\n+    this.tabDisplay = new TabDisplay(pgm, WIDTH);\n+  }\n+\n+  public void enable() {\n+    this.tabDisplay.enable();\n+\n+    for (Player viewer : this.pgm.getServer().getOnlinePlayers()) {\n+      if (ViaUtils.getProtocolVersion(viewer) != ViaUtils.VERSION_1_7) return;", "originalCommit": "eafe1e11fcbffac8f9d30ddfabb4c94449936b30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQxMTQ5Mg==", "url": "https://github.com/PGMDev/PGM/pull/572#discussion_r460411492", "bodyText": "> Same for all these checks, if someone we can allow 1.6 players then why not", "author": "Electroid", "createdAt": "2020-07-25T14:42:38Z", "path": "core/src/main/java/tc/oc/pgm/tablist/LegacyMatchTabDisplay.java", "diffHunk": "@@ -0,0 +1,419 @@\n+package tc.oc.pgm.tablist;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.TreeSet;\n+import net.kyori.text.TextComponent;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.kyori.text.format.TextDecoration;\n+import org.bukkit.ChatColor;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.HandlerList;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.player.PlayerJoinEvent;\n+import org.bukkit.event.player.PlayerLocaleChangeEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.scheduler.BukkitTask;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.party.Party;\n+import tc.oc.pgm.api.party.event.PartyRenameEvent;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.events.PlayerVanishEvent;\n+import tc.oc.pgm.events.PlayerJoinMatchEvent;\n+import tc.oc.pgm.events.PlayerPartyChangeEvent;\n+import tc.oc.pgm.ffa.FreeForAllMatchModule;\n+import tc.oc.pgm.ffa.Tribute;\n+import tc.oc.pgm.teams.Team;\n+import tc.oc.pgm.teams.events.TeamResizeEvent;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.ViaUtils;\n+import tc.oc.pgm.util.named.NameStyle;\n+import tc.oc.pgm.util.tablist.TabDisplay;\n+import tc.oc.pgm.util.text.TextTranslations;\n+import tc.oc.pgm.util.text.types.PlayerComponent;\n+\n+/** 1.7 legacy tablist implementation */\n+public class LegacyMatchTabDisplay implements Listener {\n+\n+  private static final int WIDTH = 3;\n+\n+  // Maximum players that can be listed per team in non-compact mode, which is\n+  // the full height minus the header, blank row, and team header.\n+  private static final int MAX_TEAM_SIZE = TabDisplay.HEIGHT - 3;\n+\n+  // Number of players below the max before changing back to non-compact mode\n+  private static final int COMPACT_MODE_HYSTERESIS = 2;\n+\n+  private final PGM pgm;\n+  private final TabDisplay tabDisplay;\n+  private BukkitTask timeUpdateTask;\n+  private BukkitTask deferredRenderTask;\n+\n+  // True: use all columns as a single list of all players\n+  // False: use a full column for each team\n+  private boolean compact;\n+\n+  public LegacyMatchTabDisplay(PGM pgm) {\n+    this.pgm = pgm;\n+    this.tabDisplay = new TabDisplay(pgm, WIDTH);\n+  }\n+\n+  public void enable() {\n+    this.tabDisplay.enable();\n+\n+    for (Player viewer : this.pgm.getServer().getOnlinePlayers()) {\n+      if (ViaUtils.getProtocolVersion(viewer) != ViaUtils.VERSION_1_7) return;\n+      this.tabDisplay.addViewer(viewer);\n+    }\n+\n+    this.pgm.getServer().getPluginManager().registerEvents(this, this.pgm);\n+    this.timeUpdateTask =\n+        this.pgm\n+            .getServer()\n+            .getScheduler()\n+            .runTaskTimer(\n+                this.pgm,\n+                () -> {\n+                  Iterator<Match> matches = PGM.get().getMatchManager().getMatches();\n+                  if (matches.hasNext()) {\n+                    for (MatchPlayer viewer : matches.next().getPlayers()) {\n+                      LegacyMatchTabDisplay.this.renderTime(viewer);\n+                    }\n+                  }\n+                },\n+                0,\n+                20);\n+  }\n+\n+  public void disable() {\n+    if (this.deferredRenderTask != null) {\n+      this.deferredRenderTask.cancel();\n+      this.deferredRenderTask = null;\n+    }\n+\n+    this.timeUpdateTask.cancel();\n+    this.timeUpdateTask = null;\n+\n+    HandlerList.unregisterAll(this);\n+    this.tabDisplay.disable();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onPlayerJoin(PlayerJoinEvent event) {\n+    if (ViaUtils.getProtocolVersion(event.getPlayer()) != ViaUtils.VERSION_1_7) return;", "originalCommit": "eafe1e11fcbffac8f9d30ddfabb4c94449936b30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQxMTYwMw==", "url": "https://github.com/PGMDev/PGM/pull/572#discussion_r460411603", "bodyText": "TBH I think we can leave this out. If too many, just show the first one.", "author": "Electroid", "createdAt": "2020-07-25T14:44:00Z", "path": "core/src/main/java/tc/oc/pgm/tablist/LegacyMatchTabDisplay.java", "diffHunk": "@@ -0,0 +1,419 @@\n+package tc.oc.pgm.tablist;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.TreeSet;\n+import net.kyori.text.TextComponent;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.kyori.text.format.TextDecoration;\n+import org.bukkit.ChatColor;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.HandlerList;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.player.PlayerJoinEvent;\n+import org.bukkit.event.player.PlayerLocaleChangeEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.scheduler.BukkitTask;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.party.Party;\n+import tc.oc.pgm.api.party.event.PartyRenameEvent;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.events.PlayerVanishEvent;\n+import tc.oc.pgm.events.PlayerJoinMatchEvent;\n+import tc.oc.pgm.events.PlayerPartyChangeEvent;\n+import tc.oc.pgm.ffa.FreeForAllMatchModule;\n+import tc.oc.pgm.ffa.Tribute;\n+import tc.oc.pgm.teams.Team;\n+import tc.oc.pgm.teams.events.TeamResizeEvent;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.ViaUtils;\n+import tc.oc.pgm.util.named.NameStyle;\n+import tc.oc.pgm.util.tablist.TabDisplay;\n+import tc.oc.pgm.util.text.TextTranslations;\n+import tc.oc.pgm.util.text.types.PlayerComponent;\n+\n+/** 1.7 legacy tablist implementation */\n+public class LegacyMatchTabDisplay implements Listener {\n+\n+  private static final int WIDTH = 3;\n+\n+  // Maximum players that can be listed per team in non-compact mode, which is\n+  // the full height minus the header, blank row, and team header.\n+  private static final int MAX_TEAM_SIZE = TabDisplay.HEIGHT - 3;\n+\n+  // Number of players below the max before changing back to non-compact mode\n+  private static final int COMPACT_MODE_HYSTERESIS = 2;\n+\n+  private final PGM pgm;\n+  private final TabDisplay tabDisplay;\n+  private BukkitTask timeUpdateTask;\n+  private BukkitTask deferredRenderTask;\n+\n+  // True: use all columns as a single list of all players\n+  // False: use a full column for each team\n+  private boolean compact;\n+\n+  public LegacyMatchTabDisplay(PGM pgm) {\n+    this.pgm = pgm;\n+    this.tabDisplay = new TabDisplay(pgm, WIDTH);\n+  }\n+\n+  public void enable() {\n+    this.tabDisplay.enable();\n+\n+    for (Player viewer : this.pgm.getServer().getOnlinePlayers()) {\n+      if (ViaUtils.getProtocolVersion(viewer) != ViaUtils.VERSION_1_7) return;\n+      this.tabDisplay.addViewer(viewer);\n+    }\n+\n+    this.pgm.getServer().getPluginManager().registerEvents(this, this.pgm);\n+    this.timeUpdateTask =\n+        this.pgm\n+            .getServer()\n+            .getScheduler()\n+            .runTaskTimer(\n+                this.pgm,\n+                () -> {\n+                  Iterator<Match> matches = PGM.get().getMatchManager().getMatches();\n+                  if (matches.hasNext()) {\n+                    for (MatchPlayer viewer : matches.next().getPlayers()) {\n+                      LegacyMatchTabDisplay.this.renderTime(viewer);\n+                    }\n+                  }\n+                },\n+                0,\n+                20);\n+  }\n+\n+  public void disable() {\n+    if (this.deferredRenderTask != null) {\n+      this.deferredRenderTask.cancel();\n+      this.deferredRenderTask = null;\n+    }\n+\n+    this.timeUpdateTask.cancel();\n+    this.timeUpdateTask = null;\n+\n+    HandlerList.unregisterAll(this);\n+    this.tabDisplay.disable();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onPlayerJoin(PlayerJoinEvent event) {\n+    if (ViaUtils.getProtocolVersion(event.getPlayer()) != ViaUtils.VERSION_1_7) return;\n+    this.tabDisplay.addViewer(event.getPlayer());\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onPlayerQuit(PlayerQuitEvent event) {\n+    if (PGM.get().getMatchManager().getMatch(event.getPlayer()) != null) {\n+      this.deferredRender();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onPlayerJoinMatch(final PlayerJoinMatchEvent event) {\n+    this.deferredRender();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onPlayerTeamChange(PlayerPartyChangeEvent event) {\n+    this.deferredRender();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onTeamRename(PartyRenameEvent event) {\n+    this.deferredRender();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onTeamResize(TeamResizeEvent event) {\n+    this.deferredRender();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerVanish(PlayerVanishEvent event) {\n+    this.deferredRender();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerLocaleChange(PlayerLocaleChangeEvent event) {\n+    MatchPlayer player = PGM.get().getMatchManager().getPlayer(event.getPlayer());\n+    if (player != null) {\n+      this.render(player);\n+    }\n+  }\n+\n+  public void deferredRender() {\n+    if (this.deferredRenderTask != null) return;\n+\n+    // Render one tick later so the effects of the event are visible, and so multiple updates are\n+    // batched\n+    this.deferredRenderTask =\n+        PGM.get()\n+            .getServer()\n+            .getScheduler()\n+            .runTask(\n+                PGM.get(),\n+                () -> {\n+                  Match last = null;\n+                  Iterator<Match> it = PGM.get().getMatchManager().getMatches();\n+                  while (it.hasNext()) last = it.next();\n+                  if (last != null) LegacyMatchTabDisplay.this.render(last);\n+                  LegacyMatchTabDisplay.this.deferredRenderTask = null;\n+                });\n+  }\n+\n+  public void render(Match match) {\n+    int largestTeam = 0;\n+    for (Competitor team : match.getCompetitors()) {\n+      if (team.getPlayers().size() > largestTeam) {\n+        largestTeam = team.getPlayers().size();\n+      }\n+    }\n+\n+    // Have a margin between switching modes, so it doesn't flicker back and forth\n+    this.compact =\n+        match.getCompetitors().size() > WIDTH\n+            || largestTeam > MAX_TEAM_SIZE\n+            || (this.compact && largestTeam > MAX_TEAM_SIZE - COMPACT_MODE_HYSTERESIS);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      this.render(viewer);\n+    }\n+  }\n+\n+  public void render(MatchPlayer viewer) {\n+    if (viewer.getProtocolVersion() != ViaUtils.VERSION_1_7) return;\n+\n+    Player bukkit = viewer.getBukkit();\n+    MapInfo mapInfo = viewer.getMatch().getMap();\n+\n+    // Show map name in the top left corner, taking a very rough guess at the length limit.\n+    // We could maybe use ChatUtils.pixelWidth() in the future for more accuracy.\n+    String mapName = mapInfo.getName();\n+    if (mapName.length() > 15) {\n+      mapName = mapName.substring(0, 14) + \"...\";\n+    }\n+    this.tabDisplay.set(bukkit, 0, 0, ChatColor.AQUA + mapName);\n+\n+    // If there is exactly one map author, show their name in the top middle slot.\n+    // Multiple names will surely not fit, so showing none of them is the only fair thing.\n+    if (mapInfo.getAuthors().size() == 1) {\n+      this.tabDisplay.set(\n+          bukkit,\n+          1,\n+          0,\n+          TextTranslations.translateLegacy(\n+              TranslatableComponent.of(\n+                  \"misc.by\",\n+                  TextColor.DARK_GRAY,\n+                  TextComponent.of(\n+                      mapInfo.getAuthors().iterator().next().getNameLegacy(), TextColor.GRAY)),\n+              viewer.getBukkit()));\n+    } else {\n+      this.tabDisplay.set(\n+          bukkit,\n+          1,\n+          0,\n+          TextTranslations.translateLegacy(\n+              TranslatableComponent.of(\n+                  \"tablist.authors.tooMany\",", "originalCommit": "eafe1e11fcbffac8f9d30ddfabb4c94449936b30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ4OTYwNQ==", "url": "https://github.com/PGMDev/PGM/pull/572#discussion_r460489605", "bodyText": "Showing first author, would be unfair for the other authors on there", "author": "Pablete1234", "createdAt": "2020-07-26T07:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQxMTYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQxMTcxOA==", "url": "https://github.com/PGMDev/PGM/pull/572#discussion_r460411718", "bodyText": "<=", "author": "Electroid", "createdAt": "2020-07-25T14:45:17Z", "path": "core/src/main/java/tc/oc/pgm/tablist/MatchTabManager.java", "diffHunk": "@@ -117,7 +122,8 @@ protected void invalidate(MatchPlayer player) {\n \n   @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n   public void onJoin(PlayerJoinEvent event) {\n-    TabView view = this.getView(event.getPlayer());\n+    if (ViaUtils.getProtocolVersion(event.getPlayer()) == ViaUtils.VERSION_1_7) return;", "originalCommit": "eafe1e11fcbffac8f9d30ddfabb4c94449936b30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "da21445d845465bed8bd3388f6efdcc8a833efe9", "url": "https://github.com/PGMDev/PGM/commit/da21445d845465bed8bd3388f6efdcc8a833efe9", "message": "Make sure current match works properly\n\nSigned-off-by: Pablete1234 <pabloherrerapalacio@gmail.com>", "committedDate": "2020-07-26T12:52:57Z", "type": "commit"}, {"oid": "da21445d845465bed8bd3388f6efdcc8a833efe9", "url": "https://github.com/PGMDev/PGM/commit/da21445d845465bed8bd3388f6efdcc8a833efe9", "message": "Make sure current match works properly\n\nSigned-off-by: Pablete1234 <pabloherrerapalacio@gmail.com>", "committedDate": "2020-07-26T12:52:57Z", "type": "forcePushed"}, {"oid": "b16654780277c867f8fd0ab7e0c85962e7a7133d", "url": "https://github.com/PGMDev/PGM/commit/b16654780277c867f8fd0ab7e0c85962e7a7133d", "message": "Fix translation key for command hint\n\nSigned-off-by: Pablete1234 <pabloherrerapalacio@gmail.com>", "committedDate": "2020-07-26T15:42:46Z", "type": "commit"}, {"oid": "b16654780277c867f8fd0ab7e0c85962e7a7133d", "url": "https://github.com/PGMDev/PGM/commit/b16654780277c867f8fd0ab7e0c85962e7a7133d", "message": "Fix translation key for command hint\n\nSigned-off-by: Pablete1234 <pabloherrerapalacio@gmail.com>", "committedDate": "2020-07-26T15:42:46Z", "type": "forcePushed"}]}