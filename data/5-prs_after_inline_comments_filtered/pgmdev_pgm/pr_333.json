{"pr_number": 333, "pr_title": "WIP: Add moderation commands", "pr_createdAt": "2020-02-23T09:36:47Z", "pr_url": "https://github.com/PGMDev/PGM/pull/333", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2MjIwNg==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383562206", "bodyText": "Do we really need this? Why not just use VERBOSE ?", "author": "Electroid", "createdAt": "2020-02-24T22:51:48Z", "path": "src/main/java/tc/oc/named/NameStyle.java", "diffHunk": "@@ -12,7 +12,8 @@\n   TAB(\n       true, true, true, true, true, false, true,\n       true), // Color, flair, friend status, nick status, death status\n-  VERBOSE(true, true, true, true, true, true, false, true); // Fancy plus nickname\n+  VERBOSE(true, true, true, true, true, true, false, true), // Fancy plus nickname\n+  CONCISE(true, true, true, true, true, true, false, false); // Verbose, but removes teleport", "originalCommit": "d407e34f89b63fc049ded76b12e0aa5673b60805", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MTcwNQ==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383581705", "bodyText": "If you're getting banned or kicked, a \"teleport to this player\" makes no sense", "author": "Pablete1234", "createdAt": "2020-02-24T23:48:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2MjIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2Mjk3MQ==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383562971", "bodyText": "No need for a MODERATION, just do String KICK = ROOT + \".kick\";", "author": "Electroid", "createdAt": "2020-02-24T22:53:40Z", "path": "src/main/java/tc/oc/pgm/api/Permissions.java", "diffHunk": "@@ -31,6 +31,13 @@\n   String STAFF = ROOT + \".staff\"; // Considered apart of the staff team\n   String RELOAD = ROOT + \".reload\"; // Reload the PGM configuration\n \n+  // Individual permissions related to moderation\n+  String MODERATION = ROOT + \".moderation\"; // General node for moderation", "originalCommit": "d407e34f89b63fc049ded76b12e0aa5673b60805", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2Njc5MA==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383566790", "bodyText": "Also make sure MOD has these permissions as default.", "author": "Electroid", "createdAt": "2020-02-24T23:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2Mjk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2Mzk0Nw==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383563947", "bodyText": "Not sure what the -w flag does, it's ambiguous.", "author": "Electroid", "createdAt": "2020-02-24T22:56:09Z", "path": "src/main/java/tc/oc/pgm/community/ModerationCommands.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package tc.oc.pgm.community;\n+\n+import app.ashcon.intake.Command;\n+import app.ashcon.intake.parametric.annotation.Switch;\n+import app.ashcon.intake.parametric.annotation.Text;\n+import com.google.common.collect.Lists;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.BanList;\n+import org.bukkit.Bukkit;\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+import tc.oc.component.Component;\n+import tc.oc.component.render.ComponentRenderers;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.component.types.PersonalizedTranslatable;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.chat.Sound;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.events.PlayerPunishmentEvent;\n+import tc.oc.pgm.events.PlayerTimedPunishmentEvent;\n+import tc.oc.pgm.listeners.ChatDispatcher;\n+import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.Components;\n+import tc.oc.util.components.PeriodFormats;\n+\n+public class ModerationCommands {\n+\n+  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n+\n+  private static final Component WARN_SYMBOL =\n+      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n+  private static final Component BROADCAST_DIV =\n+      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n+  private static final Component CONSOLE_NAME =\n+      new PersonalizedTranslatable(\"console\")\n+          .getPersonalizedText()\n+          .color(ChatColor.DARK_AQUA)\n+          .italic(true);\n+\n+  private final ChatDispatcher chat;\n+\n+  public ModerationCommands(ChatDispatcher chat) {\n+    this.chat = chat;\n+  }\n+\n+  @Command(\n+      aliases = {\"staff\", \"mods\", \"admins\"},\n+      desc = \"List the online staff members\")\n+  public void staff(CommandSender sender, Match match) {\n+    // List of online staff based off of permission\n+    List<Component> onlineStaff =\n+        match.getPlayers().stream()\n+            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n+            .map(player -> player.getStyledName(NameStyle.FANCY))\n+            .collect(Collectors.toList());\n+\n+    // FORMAT: Online Staff ({count}): {names}\n+    Component staffCount =\n+        new PersonalizedText(Integer.toString(onlineStaff.size()))\n+            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n+\n+    Component content =\n+        onlineStaff.isEmpty()\n+            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n+                .getPersonalizedText()\n+                .color(ChatColor.RED)\n+            : new Component(\n+                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+\n+    Component staff =\n+        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+            .getPersonalizedText()\n+            .color(ChatColor.GRAY);\n+\n+    // Send message\n+    sender.sendMessage(staff);\n+  }\n+\n+  @Command(\n+      aliases = {\"mute\", \"m\"},\n+      usage = \"<player> <reason> -s (silent) -w (warn)\",\n+      desc = \"Mute a player\",\n+      perms = Permissions.MUTE)\n+  public void mute(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent,\n+      @Switch('w') boolean warn) {", "originalCommit": "d407e34f89b63fc049ded76b12e0aa5673b60805", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MzY3MA==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383583670", "bodyText": "If it should also send the mute message as a warn to the player (title/dragon noise).\nEquivalent to doing 2 commands at once:\n/mute player reason\n/warn player reason", "author": "Pablete1234", "createdAt": "2020-02-24T23:54:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2Mzk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NDE0OA==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383564148", "bodyText": "What's the point of a silent mute?", "author": "Electroid", "createdAt": "2020-02-24T22:56:34Z", "path": "src/main/java/tc/oc/pgm/community/ModerationCommands.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package tc.oc.pgm.community;\n+\n+import app.ashcon.intake.Command;\n+import app.ashcon.intake.parametric.annotation.Switch;\n+import app.ashcon.intake.parametric.annotation.Text;\n+import com.google.common.collect.Lists;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.BanList;\n+import org.bukkit.Bukkit;\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+import tc.oc.component.Component;\n+import tc.oc.component.render.ComponentRenderers;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.component.types.PersonalizedTranslatable;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.chat.Sound;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.events.PlayerPunishmentEvent;\n+import tc.oc.pgm.events.PlayerTimedPunishmentEvent;\n+import tc.oc.pgm.listeners.ChatDispatcher;\n+import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.Components;\n+import tc.oc.util.components.PeriodFormats;\n+\n+public class ModerationCommands {\n+\n+  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n+\n+  private static final Component WARN_SYMBOL =\n+      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n+  private static final Component BROADCAST_DIV =\n+      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n+  private static final Component CONSOLE_NAME =\n+      new PersonalizedTranslatable(\"console\")\n+          .getPersonalizedText()\n+          .color(ChatColor.DARK_AQUA)\n+          .italic(true);\n+\n+  private final ChatDispatcher chat;\n+\n+  public ModerationCommands(ChatDispatcher chat) {\n+    this.chat = chat;\n+  }\n+\n+  @Command(\n+      aliases = {\"staff\", \"mods\", \"admins\"},\n+      desc = \"List the online staff members\")\n+  public void staff(CommandSender sender, Match match) {\n+    // List of online staff based off of permission\n+    List<Component> onlineStaff =\n+        match.getPlayers().stream()\n+            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n+            .map(player -> player.getStyledName(NameStyle.FANCY))\n+            .collect(Collectors.toList());\n+\n+    // FORMAT: Online Staff ({count}): {names}\n+    Component staffCount =\n+        new PersonalizedText(Integer.toString(onlineStaff.size()))\n+            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n+\n+    Component content =\n+        onlineStaff.isEmpty()\n+            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n+                .getPersonalizedText()\n+                .color(ChatColor.RED)\n+            : new Component(\n+                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+\n+    Component staff =\n+        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+            .getPersonalizedText()\n+            .color(ChatColor.GRAY);\n+\n+    // Send message\n+    sender.sendMessage(staff);\n+  }\n+\n+  @Command(\n+      aliases = {\"mute\", \"m\"},\n+      usage = \"<player> <reason> -s (silent) -w (warn)\",\n+      desc = \"Mute a player\",\n+      perms = Permissions.MUTE)\n+  public void mute(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent,", "originalCommit": "d407e34f89b63fc049ded76b12e0aa5673b60805", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4NDMzMw==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383584333", "bodyText": "Not telling the whole server you have muted someone.\nAll punishments, if not silent, send a global message announcing the punishment, like: \"Mod punishment Player for reason\"", "author": "Pablete1234", "createdAt": "2020-02-24T23:56:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NDE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NTIwOA==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383565208", "bodyText": "Should this be a Cache instead? Maybe only keep reports for the last hour? If the server stays up for a day, doesn't make sense to show reports from the previous day.", "author": "Electroid", "createdAt": "2020-02-24T22:59:18Z", "path": "src/main/java/tc/oc/pgm/community/ReportCommands.java", "diffHunk": "@@ -27,22 +35,26 @@\n import tc.oc.pgm.api.setting.SettingKey;\n import tc.oc.pgm.api.setting.SettingValue;\n import tc.oc.pgm.events.PlayerReportEvent;\n-import tc.oc.util.components.Components;\n+import tc.oc.pgm.util.PrettyPaginatedComponentResults;\n+import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.PeriodFormats;\n \n-public class ModerationCommands {\n+public class ReportCommands {\n+\n+  private static final Sound REPORT_NOTIFY_SOUND = new Sound(\"random.pop\", 1f, 1.2f);\n \n   private static final int REPORT_COOLDOWN_SECONDS = 15;\n \n-  private static final Cache<UUID, Instant> LAST_REPORT_SENT =\n+  private final Cache<UUID, Instant> LAST_REPORT_SENT =\n       CacheBuilder.newBuilder().expireAfterWrite(REPORT_COOLDOWN_SECONDS, TimeUnit.SECONDS).build();\n \n-  private static final Sound REPORT_NOTIFY_SOUND = new Sound(\"random.pop\", 1f, 1.2f);\n+  private final List<Report> RECENT_REPORTS = Lists.newArrayList();", "originalCommit": "d407e34f89b63fc049ded76b12e0aa5673b60805", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NTYyNQ==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383565625", "bodyText": "I think this can be simplified to Instant.compare(getTimeSent(), o.getTimeSent())", "author": "Electroid", "createdAt": "2020-02-24T23:00:27Z", "path": "src/main/java/tc/oc/pgm/community/ReportCommands.java", "diffHunk": "@@ -125,35 +144,125 @@ public static void report(\n   }\n \n   @Command(\n-      aliases = {\"staff\", \"mods\", \"admins\"},\n-      desc = \"List the online staff members\")\n-  public void staff(CommandSender sender, Match match) {\n-    // List of online staff\n-    List<Component> onlineStaff =\n-        match.getPlayers().stream()\n-            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n-            .map(player -> player.getStyledName(NameStyle.FANCY))\n-            .collect(Collectors.toList());\n-\n-    // FORMAT: Online Staff ({count}): {names}\n-    Component staffCount =\n-        new PersonalizedText(Integer.toString(onlineStaff.size()))\n-            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n-\n-    Component content =\n-        onlineStaff.isEmpty()\n-            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n-                .getPersonalizedText()\n-                .color(ChatColor.RED)\n-            : new Component(\n-                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+      aliases = {\"reports\", \"reps\", \"reporthistory\"},\n+      desc = \"Display a list of recent reports\",\n+      usage = \"(page) -t [target player]\",\n+      flags = \"t\",\n+      perms = Permissions.STAFF)\n+  public void reportHistory(\n+      Audience audience,\n+      CommandSender sender,\n+      @Default(\"1\") int page,\n+      @Fallback(Type.NULL) @Switch('t') String target)\n+      throws CommandException {\n+    if (RECENT_REPORTS.isEmpty()) {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\"moderation.reports.none\")\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+      return;\n+    }\n+\n+    List<Report> reportList = RECENT_REPORTS;\n+    if (target != null) {\n+      reportList =\n+          RECENT_REPORTS.stream()\n+              .filter(r -> r.getId().equalsIgnoreCase(target))\n+              .collect(Collectors.toList());\n+    }\n \n-    Component staff =\n-        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+    Collections.sort(reportList); // Sort list so most recent show up first\n+\n+    Component headerResultCount =\n+        new PersonalizedText(Long.toString(reportList.size())).color(ChatColor.RED);\n+\n+    int perPage = 6;\n+    int pages = (reportList.size() + perPage - 1) / perPage;\n+\n+    Component pageNum =\n+        new PersonalizedTranslatable(\n+                \"command.paginatedResult.page\",\n+                new PersonalizedText(Integer.toString(page)).color(ChatColor.RED),\n+                new PersonalizedText(Integer.toString(pages)).color(ChatColor.RED))\n+            .add(ChatColor.AQUA);\n+\n+    Component header =\n+        new PersonalizedTranslatable(\"moderation.reports.header\", headerResultCount, pageNum)\n             .getPersonalizedText()\n             .color(ChatColor.GRAY);\n \n-    // Send message\n-    sender.sendMessage(staff);\n+    Component formattedHeader =\n+        new PersonalizedText(\n+            ComponentUtils.horizontalLineHeading(\n+                ComponentRenderers.toLegacyText(header, sender), ChatColor.RED));\n+\n+    new PrettyPaginatedComponentResults<Report>(formattedHeader, perPage) {\n+      @Override\n+      public Component format(Report data, int index) {\n+        Component timeAgo =\n+            PeriodFormats.relativePastApproximate(\n+                    org.joda.time.Instant.ofEpochMilli(data.getTimeSent().toEpochMilli()))\n+                .color(ChatColor.DARK_AQUA);\n+        Component hover =\n+            new PersonalizedTranslatable(\"moderation.reports.hover\", data.getSenderName())\n+                .getPersonalizedText()\n+                .color(ChatColor.GRAY);\n+        Component formatted =\n+            new PersonalizedTranslatable(\n+                \"moderation.reports.format\",\n+                timeAgo,\n+                data.getTargetName(),\n+                new PersonalizedText(data.getReason()).italic(true).color(ChatColor.WHITE));\n+\n+        return formatted.hoverEvent(Action.SHOW_TEXT, hover.render(sender));\n+      }\n+    }.display(audience, reportList, page);\n+  }\n+\n+  public static class Report implements Comparable<Report> {\n+    private final String id;\n+    private final String reason;\n+    private final Component targetName;\n+    private final Component sender;\n+    private final Instant timeSent;\n+\n+    public Report(String id, String reason, Component targetName, Component sender) {\n+      this.id = id;\n+      this.reason = reason;\n+      this.targetName = targetName;\n+      this.sender = sender;\n+      this.timeSent = Instant.now();\n+    }\n+\n+    public String getId() {\n+      return id;\n+    }\n+\n+    public String getReason() {\n+      return reason;\n+    }\n+\n+    public Component getTargetName() {\n+      return targetName;\n+    }\n+\n+    public Component getSenderName() {\n+      return sender;\n+    }\n+\n+    public Instant getTimeSent() {\n+      return timeSent;\n+    }\n+\n+    @Override\n+    public int compareTo(Report o) {\n+      if (getTimeSent().equals(o.getTimeSent())) {\n+        return 0;\n+      } else if (getTimeSent().isBefore(o.getTimeSent())) {\n+        return 1;\n+      } else {\n+        return -1;\n+      }", "originalCommit": "d407e34f89b63fc049ded76b12e0aa5673b60805", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MjkxMw==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383582913", "bodyText": "Can be simplified to return timeSent.compareTo(o.timeSent);", "author": "Pablete1234", "createdAt": "2020-02-24T23:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NTYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NTkzOA==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383565938", "bodyText": "Keep all of these files, including events, in the tc.oc.pgm.community package.\nSo this would be tc.oc.pgm.community.events", "author": "Electroid", "createdAt": "2020-02-24T23:01:11Z", "path": "src/main/java/tc/oc/pgm/events/PlayerPunishmentEvent.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package tc.oc.pgm.events;", "originalCommit": "d407e34f89b63fc049ded76b12e0aa5673b60805", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NjMyOA==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383566328", "bodyText": "Instead of having 2 events, remove this and add a Duration field to PlayerPunishmentEvent.\nIf the ban is permanent, then the Duration is MAX_VALUE.", "author": "Electroid", "createdAt": "2020-02-24T23:02:17Z", "path": "src/main/java/tc/oc/pgm/events/PlayerTimedPunishmentEvent.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package tc.oc.pgm.events;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import org.bukkit.command.CommandSender;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.ModerationCommands.PunishmentType;\n+\n+/** Called when a punishment that expires after a duration of time is created * */\n+public class PlayerTimedPunishmentEvent extends PlayerPunishmentEvent {", "originalCommit": "d407e34f89b63fc049ded76b12e0aa5673b60805", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NzUxNA==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383867514", "bodyText": "This will punish the player with Duration.ZERO, shouldn't this be defined with Duration.MAX_VALUE?", "author": "Electroid", "createdAt": "2020-02-25T13:09:47Z", "path": "src/main/java/tc/oc/pgm/community/commands/ModerationCommands.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package tc.oc.pgm.community.commands;\n+\n+import app.ashcon.intake.Command;\n+import app.ashcon.intake.parametric.annotation.Switch;\n+import app.ashcon.intake.parametric.annotation.Text;\n+import com.google.common.collect.Lists;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.BanList;\n+import org.bukkit.Bukkit;\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+import tc.oc.component.Component;\n+import tc.oc.component.render.ComponentRenderers;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.component.types.PersonalizedTranslatable;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.chat.Sound;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.events.PlayerPunishmentEvent;\n+import tc.oc.pgm.listeners.ChatDispatcher;\n+import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.Components;\n+import tc.oc.util.components.PeriodFormats;\n+\n+public class ModerationCommands {\n+\n+  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n+\n+  private static final Component WARN_SYMBOL =\n+      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n+  private static final Component BROADCAST_DIV =\n+      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n+  private static final Component CONSOLE_NAME =\n+      new PersonalizedTranslatable(\"console\")\n+          .getPersonalizedText()\n+          .color(ChatColor.DARK_AQUA)\n+          .italic(true);\n+\n+  private final ChatDispatcher chat;\n+\n+  public ModerationCommands(ChatDispatcher chat) {\n+    this.chat = chat;\n+  }\n+\n+  @Command(\n+      aliases = {\"staff\", \"mods\", \"admins\"},\n+      desc = \"List the online staff members\")\n+  public void staff(CommandSender sender, Match match) {\n+    // List of online staff based off of permission\n+    List<Component> onlineStaff =\n+        match.getPlayers().stream()\n+            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n+            .map(player -> player.getStyledName(NameStyle.FANCY))\n+            .collect(Collectors.toList());\n+\n+    // FORMAT: Online Staff ({count}): {names}\n+    Component staffCount =\n+        new PersonalizedText(Integer.toString(onlineStaff.size()))\n+            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n+\n+    Component content =\n+        onlineStaff.isEmpty()\n+            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n+                .getPersonalizedText()\n+                .color(ChatColor.RED)\n+            : new Component(\n+                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+\n+    Component staff =\n+        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+            .getPersonalizedText()\n+            .color(ChatColor.GRAY);\n+\n+    // Send message\n+    sender.sendMessage(staff);\n+  }\n+\n+  @Command(\n+      aliases = {\"mute\", \"m\"},\n+      usage = \"<player> <reason> -s (silent) -w (warn)\",\n+      desc = \"Mute a player\",\n+      perms = Permissions.MUTE)\n+  public void mute(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent,\n+      @Switch('w') boolean warn) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+\n+    if (chat.isMuted(targetMatchPlayer)) {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.mute.existing\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+      return;\n+    }\n+\n+    // if -w flag, also warn the player but don't broadcast warning\n+    if (warn) {\n+      warn(sender, target, match, reason, true);\n+    }\n+\n+    if (punish(PunishmentType.MUTE, targetMatchPlayer, sender, reason, silent)) {\n+      chat.addMuted(targetMatchPlayer);\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"unmute\", \"um\"},\n+      usage = \"<player>\",\n+      desc = \"Unmute a player\",\n+      perms = Permissions.MUTE)\n+  public void unMute(CommandSender sender, Player target, Match match) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (chat.isMuted(targetMatchPlayer)) {\n+      chat.removeMuted(targetMatchPlayer);\n+\n+      targetMatchPlayer.sendMessage(\n+          new PersonalizedTranslatable(\"moderation.unmute.target\")\n+              .getPersonalizedText()\n+              .color(ChatColor.GREEN));\n+\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.unmute.sender\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .color(ChatColor.GRAY));\n+    } else {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.unmute.none\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"warn\", \"w\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Warn a player for bad behavior\",\n+      perms = Permissions.WARN)\n+  public void warn(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+\n+    if (punish(PunishmentType.WARN, targetMatchPlayer, sender, reason, silent)) {\n+      sendWarning(targetMatchPlayer, reason);\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"kick\", \"k\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Kick a player from the server\",\n+      perms = Permissions.KICK)\n+  public void kick(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (punish(PunishmentType.KICK, targetMatchPlayer, sender, reason, silent)) {\n+      target.kickPlayer(\n+          formatPunishmentScreen(\n+              PunishmentType.KICK, formatPunisherName(sender, match), reason, null));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"ban\", \"permban\", \"pb\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Ban a player from the server forever\",\n+      perms = Permissions.BAN)\n+  public void ban(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    Component senderName = formatPunisherName(sender, match);\n+    if (punish(PunishmentType.BAN, targetMatchPlayer, sender, reason, silent)) {", "originalCommit": "e53fa85e5c58273ff3917c108dadd05a836b6396", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAwMDUwNA==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r384000504", "bodyText": "I should have made a comment regarding this, but from what I understand there is no Duration.MAX_VALUE See here\nBut basically I\u2019m using the logic so that: if a punishment has a duration then it must be able to expire, otherwise a zero value represents infinity.", "author": "applenick", "createdAt": "2020-02-25T16:58:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NzUxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4ODQ0Mw==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r384088443", "bodyText": "Ah ok, that works", "author": "Electroid", "createdAt": "2020-02-25T19:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NzUxNA=="}], "type": "inlineReview"}, {"oid": "a4293abcff754bfdcc456c77698ba27b892da98a", "url": "https://github.com/PGMDev/PGM/commit/a4293abcff754bfdcc456c77698ba27b892da98a", "message": "Add moderation commands\n\nSigned-off-by: applenick <applenick@users.noreply.github.com>", "committedDate": "2020-02-26T08:10:56Z", "type": "commit"}, {"oid": "a4293abcff754bfdcc456c77698ba27b892da98a", "url": "https://github.com/PGMDev/PGM/commit/a4293abcff754bfdcc456c77698ba27b892da98a", "message": "Add moderation commands\n\nSigned-off-by: applenick <applenick@users.noreply.github.com>", "committedDate": "2020-02-26T08:10:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMzMTM2MQ==", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r384331361", "bodyText": "Just commenting for visibility", "author": "applenick", "createdAt": "2020-02-26T08:19:03Z", "path": "core/src/main/java/tc/oc/pgm/community/commands/ModerationCommands.java", "diffHunk": "@@ -0,0 +1,495 @@\n+package tc.oc.pgm.community.commands;\n+\n+import app.ashcon.intake.Command;\n+import app.ashcon.intake.CommandException;\n+import app.ashcon.intake.parametric.annotation.Switch;\n+import app.ashcon.intake.parametric.annotation.Text;\n+import com.google.common.collect.Lists;\n+import com.google.common.net.InetAddresses;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.BanList;\n+import org.bukkit.Bukkit;\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.chat.Sound;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.events.PlayerPunishmentEvent;\n+import tc.oc.pgm.listeners.ChatDispatcher;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentRenderers;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.PeriodFormats;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.named.NameStyle;\n+\n+public class ModerationCommands {\n+\n+  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n+\n+  private static final Component WARN_SYMBOL =\n+      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n+  private static final Component BROADCAST_DIV =\n+      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n+  private static final Component CONSOLE_NAME =\n+      new PersonalizedTranslatable(\"console\")\n+          .getPersonalizedText()\n+          .color(ChatColor.DARK_AQUA)\n+          .italic(true);\n+\n+  private final ChatDispatcher chat;\n+\n+  public ModerationCommands(ChatDispatcher chat) {\n+    this.chat = chat;\n+  }\n+\n+  @Command(\n+      aliases = {\"staff\", \"mods\", \"admins\"},\n+      desc = \"List the online staff members\")\n+  public void staff(CommandSender sender, Match match) {\n+    // List of online staff based off of permission\n+    List<Component> onlineStaff =\n+        match.getPlayers().stream()\n+            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n+            .map(player -> player.getStyledName(NameStyle.FANCY))\n+            .collect(Collectors.toList());\n+\n+    // FORMAT: Online Staff ({count}): {names}\n+    Component staffCount =\n+        new PersonalizedText(Integer.toString(onlineStaff.size()))\n+            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n+\n+    Component content =\n+        onlineStaff.isEmpty()\n+            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n+                .getPersonalizedText()\n+                .color(ChatColor.RED)\n+            : new Component(\n+                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+\n+    Component staff =\n+        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+            .getPersonalizedText()\n+            .color(ChatColor.GRAY);\n+\n+    // Send message\n+    sender.sendMessage(staff);\n+  }\n+\n+  @Command(\n+      aliases = {\"mute\", \"m\"},\n+      usage = \"<player> <reason> -s (silent) -w (warn)\",\n+      desc = \"Mute a player\",\n+      perms = Permissions.MUTE)\n+  public void mute(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent,\n+      @Switch('w') boolean warn) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+\n+    if (chat.isMuted(targetMatchPlayer)) {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.mute.existing\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+      return;\n+    }\n+\n+    // if -w flag, also warn the player but don't broadcast warning\n+    if (warn) {\n+      warn(sender, target, match, reason, true);\n+    }\n+\n+    if (punish(PunishmentType.MUTE, targetMatchPlayer, sender, reason, silent)) {\n+      chat.addMuted(targetMatchPlayer);\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"unmute\", \"um\"},\n+      usage = \"<player>\",\n+      desc = \"Unmute a player\",\n+      perms = Permissions.MUTE)\n+  public void unMute(CommandSender sender, Player target, Match match) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (chat.isMuted(targetMatchPlayer)) {\n+      chat.removeMuted(targetMatchPlayer);\n+\n+      targetMatchPlayer.sendMessage(\n+          new PersonalizedTranslatable(\"moderation.unmute.target\")\n+              .getPersonalizedText()\n+              .color(ChatColor.GREEN));\n+\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.unmute.sender\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .color(ChatColor.GRAY));\n+    } else {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.unmute.none\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"warn\", \"w\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Warn a player for bad behavior\",\n+      perms = Permissions.WARN)\n+  public void warn(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+\n+    if (punish(PunishmentType.WARN, targetMatchPlayer, sender, reason, silent)) {\n+      sendWarning(targetMatchPlayer, reason);\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"kick\", \"k\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Kick a player from the server\",\n+      perms = Permissions.KICK)\n+  public void kick(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (punish(PunishmentType.KICK, targetMatchPlayer, sender, reason, silent)) {\n+      target.kickPlayer(\n+          formatPunishmentScreen(\n+              PunishmentType.KICK, formatPunisherName(sender, match), reason, null));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"ban\", \"permban\", \"pb\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Ban a player from the server forever\",\n+      perms = Permissions.BAN)\n+  public void ban(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    Component senderName = formatPunisherName(sender, match);\n+    if (punish(PunishmentType.BAN, targetMatchPlayer, sender, reason, silent)) {\n+      banPlayer(target, reason, senderName, null);\n+      target.kickPlayer(formatPunishmentScreen(PunishmentType.BAN, senderName, reason, null));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"tempban\", \"tban\", \"tb\"},\n+      usage = \"<player> <time> <reason> -s (silent)\",\n+      desc = \"Ban a player from the server for a period of time\",\n+      perms = Permissions.BAN)\n+  public void tempBan(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      Duration banLength,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (punish(PunishmentType.BAN, targetMatchPlayer, sender, reason, banLength, silent)) {\n+      banPlayer(target, reason, formatPunisherName(sender, match), Instant.now().plus(banLength));\n+      target.kickPlayer(\n+          formatPunishmentScreen(\n+              PunishmentType.BAN, formatPunisherName(sender, match), reason, banLength));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"ipban\", \"banip\", \"ipb\"},\n+      usage = \"<player|ip address> <reason>\",\n+      desc = \"IP Ban a player from the server\",\n+      perms = Permissions.BAN)\n+  public void ipBan(", "originalCommit": "a4293abcff754bfdcc456c77698ba27b892da98a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}