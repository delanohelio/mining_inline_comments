{"pr_number": 351, "pr_title": "Reintroduce fireworks ", "pr_createdAt": "2020-03-02T07:31:41Z", "pr_url": "https://github.com/PGMDev/PGM/pull/351", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUyNzQ1Nw==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r386527457", "bodyText": "It never made any sense to make these configurable, just make these static variables.", "author": "Electroid", "createdAt": "2020-03-02T17:09:32Z", "path": "core/src/main/java/tc/oc/pgm/Config.java", "diffHunk": "@@ -478,4 +478,39 @@ public static boolean isAppealVisible() {\n       return getAppealMessage().length() > 0;\n     }\n   }\n+\n+  public static class Fireworks {\n+\n+    public static class Postmatch {\n+      public static boolean enabled() {\n+        return getConfiguration().getBoolean(\"fireworks.post-match.enabled\", false);\n+      }\n+\n+      public static int number() {\n+        return Math.max(1, getConfiguration().getInt(\"fireworks.post-match.number\", 5));\n+      }\n+\n+      public static int delay() {\n+        return Math.max(0, getConfiguration().getInt(\"fireworks.post-match.delay\", 40));\n+      }\n+\n+      public static int frequency() {\n+        return Math.max(1, getConfiguration().getInt(\"fireworks.post-match.frequency\", 40));\n+      }\n+\n+      public static int iterations() {\n+        return Math.max(1, getConfiguration().getInt(\"fireworks.post-match.iterations\", 15));\n+      }\n+\n+      public static int power() {\n+        return Math.max(0, getConfiguration().getInt(\"fireworks.post-match.power\", 2));\n+      }\n+    }", "originalCommit": "8fe6feab617a46d75195e3bf2e3a99f46071d6a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczMDAyNw==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r386730027", "bodyText": "post-match fireworks are barely used tho. Even pgm 1.9+ never used it except for arcade, ctw/dtc servers never used them", "author": "Pablete1234", "createdAt": "2020-03-03T00:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUyNzQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUyNzk5OA==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r386527998", "bodyText": "Simple: fireworks.enabled", "author": "Electroid", "createdAt": "2020-03-02T17:10:32Z", "path": "core/src/main/java/tc/oc/pgm/Config.java", "diffHunk": "@@ -478,4 +478,39 @@ public static boolean isAppealVisible() {\n       return getAppealMessage().length() > 0;\n     }\n   }\n+\n+  public static class Fireworks {\n+\n+    public static class Postmatch {\n+      public static boolean enabled() {\n+        return getConfiguration().getBoolean(\"fireworks.post-match.enabled\", false);\n+      }\n+\n+      public static int number() {\n+        return Math.max(1, getConfiguration().getInt(\"fireworks.post-match.number\", 5));\n+      }\n+\n+      public static int delay() {\n+        return Math.max(0, getConfiguration().getInt(\"fireworks.post-match.delay\", 40));\n+      }\n+\n+      public static int frequency() {\n+        return Math.max(1, getConfiguration().getInt(\"fireworks.post-match.frequency\", 40));\n+      }\n+\n+      public static int iterations() {\n+        return Math.max(1, getConfiguration().getInt(\"fireworks.post-match.iterations\", 15));\n+      }\n+\n+      public static int power() {\n+        return Math.max(0, getConfiguration().getInt(\"fireworks.post-match.power\", 2));\n+      }\n+    }\n+\n+    public static class Goals {\n+      public static boolean enabled() {\n+        return getConfiguration().getBoolean(\"fireworks.goals.enabled\", false);\n+      }\n+    }", "originalCommit": "8fe6feab617a46d75195e3bf2e3a99f46071d6a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUyODE5Ng==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r386528196", "bodyText": "Can be moved to the MatchModule", "author": "Electroid", "createdAt": "2020-03-02T17:10:57Z", "path": "core/src/main/java/tc/oc/pgm/fireworks/FireworkUtil.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package tc.oc.pgm.fireworks;\n+\n+import com.google.common.base.Preconditions;\n+import javax.annotation.Nonnull;\n+import org.bukkit.Bukkit;\n+import org.bukkit.FireworkEffect;\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.block.Block;\n+import org.bukkit.entity.EntityType;\n+import org.bukkit.entity.Firework;\n+import org.bukkit.inventory.meta.FireworkMeta;\n+\n+public class FireworkUtil {\n+\n+  public static @Nonnull Firework spawnFirework(", "originalCommit": "8fe6feab617a46d75195e3bf2e3a99f46071d6a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUyODUxNA==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r386528514", "bodyText": "Don't we have some Locations or LocationUtil class?", "author": "Electroid", "createdAt": "2020-03-02T17:11:31Z", "path": "core/src/main/java/tc/oc/pgm/fireworks/FireworkUtil.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package tc.oc.pgm.fireworks;\n+\n+import com.google.common.base.Preconditions;\n+import javax.annotation.Nonnull;\n+import org.bukkit.Bukkit;\n+import org.bukkit.FireworkEffect;\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.block.Block;\n+import org.bukkit.entity.EntityType;\n+import org.bukkit.entity.Firework;\n+import org.bukkit.inventory.meta.FireworkMeta;\n+\n+public class FireworkUtil {\n+\n+  public static @Nonnull Firework spawnFirework(\n+      @Nonnull Location location, @Nonnull FireworkEffect effect, int power) {\n+    Preconditions.checkNotNull(location, \"location\");\n+    Preconditions.checkNotNull(effect, \"firework effect\");\n+    Preconditions.checkArgument(power >= 0, \"power must be positive\");\n+\n+    FireworkMeta meta = (FireworkMeta) Bukkit.getItemFactory().getItemMeta(Material.FIREWORK);\n+    meta.setPower(power);\n+    meta.addEffect(effect);\n+\n+    Firework firework = (Firework) location.getWorld().spawnEntity(location, EntityType.FIREWORK);\n+    firework.setFireworkMeta(meta);\n+\n+    return firework;\n+  }\n+\n+  public static @Nonnull Location getOpenSpaceAbove(@Nonnull Location location) {", "originalCommit": "8fe6feab617a46d75195e3bf2e3a99f46071d6a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2ODM2Mw==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r386768363", "bodyText": "@Electroid I was unable to find a Locations or LocationUtil class. Perhaps you have some guidance on this? I placed both of the FireworkUtil methods into the FireworkMatchModule for now.", "author": "applenick", "createdAt": "2020-03-03T02:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUyODUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUyOTY0Nw==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r386529647", "bodyText": "Integrate this into a FireworksMatchModule implements MatchModule, Listener", "author": "Electroid", "createdAt": "2020-03-02T17:13:33Z", "path": "core/src/main/java/tc/oc/pgm/fireworks/ObjectivesFireworkListener.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package tc.oc.pgm.fireworks;\n+\n+import org.bukkit.Color;\n+import org.bukkit.FireworkEffect;\n+import org.bukkit.FireworkEffect.Type;\n+import org.bukkit.Location;\n+import org.bukkit.World;\n+import org.bukkit.block.Block;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.controlpoint.events.ControllerChangeEvent;\n+import tc.oc.pgm.core.CoreLeakEvent;\n+import tc.oc.pgm.destroyable.DestroyableDestroyedEvent;\n+import tc.oc.pgm.flag.event.FlagCaptureEvent;\n+import tc.oc.pgm.regions.Bounds;\n+import tc.oc.pgm.regions.Region;\n+import tc.oc.pgm.wool.PlayerWoolPlaceEvent;\n+import tc.oc.util.bukkit.BukkitUtils;\n+import tc.oc.util.bukkit.block.BlockVectors;\n+\n+public class ObjectivesFireworkListener implements Listener {", "originalCommit": "8fe6feab617a46d75195e3bf2e3a99f46071d6a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUyOTgzMA==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r386529830", "bodyText": "There can just be 1 fireworks MatchModule, handle both event and post-match", "author": "Electroid", "createdAt": "2020-03-02T17:13:56Z", "path": "core/src/main/java/tc/oc/pgm/fireworks/PostMatchFireworkMatchModule.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package tc.oc.pgm.fireworks;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.bukkit.Color;\n+import org.bukkit.FireworkEffect;\n+import org.bukkit.FireworkEffect.Type;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.scheduler.BukkitTask;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.util.bukkit.BukkitUtils;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class PostMatchFireworkMatchModule implements MatchModule, Listener {", "originalCommit": "8fe6feab617a46d75195e3bf2e3a99f46071d6a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUzMDQ3OA==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r386530478", "bodyText": "Don't use BukkitTask, instead Match#getScheduler(MatchScope.LOADED)", "author": "Electroid", "createdAt": "2020-03-02T17:15:15Z", "path": "core/src/main/java/tc/oc/pgm/fireworks/PostMatchFireworkMatchModule.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package tc.oc.pgm.fireworks;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.bukkit.Color;\n+import org.bukkit.FireworkEffect;\n+import org.bukkit.FireworkEffect.Type;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.scheduler.BukkitTask;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.util.bukkit.BukkitUtils;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class PostMatchFireworkMatchModule implements MatchModule, Listener {\n+\n+  private BukkitTask task;", "originalCommit": "8fe6feab617a46d75195e3bf2e3a99f46071d6a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUzMDc0Nw==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r386530747", "bodyText": "Seems like you do already, so no need to store the BukkitTask, it will get canceled automatically.", "author": "Electroid", "createdAt": "2020-03-02T17:15:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUzMDQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDU1OA==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r388930558", "bodyText": "Should be static, and follow the static variable naming rules: ITERATION_COUNT", "author": "Electroid", "createdAt": "2020-03-06T14:24:30Z", "path": "core/src/main/java/tc/oc/pgm/fireworks/FireworkMatchModule.java", "diffHunk": "@@ -0,0 +1,237 @@\n+package tc.oc.pgm.fireworks;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nonnull;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Color;\n+import org.bukkit.FireworkEffect;\n+import org.bukkit.FireworkEffect.Type;\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.World;\n+import org.bukkit.block.Block;\n+import org.bukkit.entity.EntityType;\n+import org.bukkit.entity.Firework;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.inventory.meta.FireworkMeta;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.controlpoint.events.ControllerChangeEvent;\n+import tc.oc.pgm.core.CoreLeakEvent;\n+import tc.oc.pgm.destroyable.DestroyableDestroyedEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.flag.event.FlagCaptureEvent;\n+import tc.oc.pgm.regions.Bounds;\n+import tc.oc.pgm.regions.Region;\n+import tc.oc.pgm.wool.PlayerWoolPlaceEvent;\n+import tc.oc.util.bukkit.BukkitUtils;\n+import tc.oc.util.bukkit.block.BlockVectors;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class FireworkMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n+\n+  private final boolean postEnabled = Config.Fireworks.postMatchEnabled();\n+  private final boolean goalsEnabled = Config.Fireworks.goalsEnabled();\n+  private final int number = 5;\n+  private final int delay = 40;\n+  private final int frequency = 40;\n+  private final int iterationCount = 15;\n+  private final int power = 2;", "originalCommit": "0cb4c0a44e1f847fd59b6e24a27288dbd8fe0030", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMTEzOQ==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r388931139", "bodyText": "What are these magic numbers? They should probably be static variables too.", "author": "Electroid", "createdAt": "2020-03-06T14:25:33Z", "path": "core/src/main/java/tc/oc/pgm/fireworks/FireworkMatchModule.java", "diffHunk": "@@ -0,0 +1,237 @@\n+package tc.oc.pgm.fireworks;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nonnull;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Color;\n+import org.bukkit.FireworkEffect;\n+import org.bukkit.FireworkEffect.Type;\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.World;\n+import org.bukkit.block.Block;\n+import org.bukkit.entity.EntityType;\n+import org.bukkit.entity.Firework;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.inventory.meta.FireworkMeta;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.controlpoint.events.ControllerChangeEvent;\n+import tc.oc.pgm.core.CoreLeakEvent;\n+import tc.oc.pgm.destroyable.DestroyableDestroyedEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.flag.event.FlagCaptureEvent;\n+import tc.oc.pgm.regions.Bounds;\n+import tc.oc.pgm.regions.Region;\n+import tc.oc.pgm.wool.PlayerWoolPlaceEvent;\n+import tc.oc.util.bukkit.BukkitUtils;\n+import tc.oc.util.bukkit.block.BlockVectors;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class FireworkMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n+\n+  private final boolean postEnabled = Config.Fireworks.postMatchEnabled();\n+  private final boolean goalsEnabled = Config.Fireworks.goalsEnabled();\n+  private final int number = 5;\n+  private final int delay = 40;\n+  private final int frequency = 40;\n+  private final int iterationCount = 15;\n+  private final int power = 2;\n+\n+  public FireworkMatchModule(Match match) {\n+    this.match = match;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onMatchEnd(final MatchFinishEvent event) {\n+    if (!postEnabled) return;\n+    match\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskTimer(delay, frequency, new FireworkRunner(event.getWinners()));\n+  }\n+\n+  public static List<FireworkEffect.Type> AVAILABLE_TYPES =\n+      ImmutableList.<FireworkEffect.Type>builder()\n+          .add(Type.BALL)\n+          .add(Type.BALL_LARGE)\n+          .add(Type.BURST)\n+          .add(Type.STAR)\n+          .build();\n+\n+  public class FireworkRunner implements Runnable {\n+    private final Set<Color> colors;\n+    private final Collection<Competitor> winners;\n+    private int iterations = 0;\n+\n+    public FireworkRunner(Collection<Competitor> winners) {\n+      this.winners = winners;\n+      this.colors =\n+          winners.stream()\n+              .map(winner -> BukkitUtils.colorOf(winner.getColor()))\n+              .collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    public void run() {\n+      if (this.iterations < iterationCount) {\n+        // Build this list fresh every time, because MatchPlayers can unload, but Competitors can't.\n+        final List<MatchPlayer> players =\n+            winners.stream().flatMap(c -> c.getPlayers().stream()).collect(Collectors.toList());\n+        Collections.shuffle(players);\n+\n+        for (int i = 0; i < players.size() && i < number; i++) {\n+          MatchPlayer player = players.get(i);\n+\n+          Type type = AVAILABLE_TYPES.get(match.getRandom().nextInt(AVAILABLE_TYPES.size()));\n+\n+          FireworkEffect effect =\n+              FireworkEffect.builder()\n+                  .with(type)\n+                  .withFlicker()\n+                  .withColor(this.colors)\n+                  .withFade(Color.BLACK)\n+                  .build();\n+\n+          spawnFirework(player.getBukkit().getLocation(), effect, power);\n+        }\n+      }\n+      this.iterations++;\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onWoolPlace(final PlayerWoolPlaceEvent event) {\n+    if (goalsEnabled && event.getWool().isVisible()) {\n+      this.spawnFireworkDisplay(\n+          BlockVectors.center(event.getBlock()), event.getWool().getDyeColor().getColor(), 6, 2, 2);\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onCoreLeak(final CoreLeakEvent event) {\n+    if (goalsEnabled && event.getCore().isVisible()) {\n+      this.spawnFireworkDisplay(\n+          event.getMatch().getWorld(),\n+          event.getCore().getCasingRegion(),\n+          event.getCore().getColor(),\n+          8,\n+          1.5,\n+          2);", "originalCommit": "0cb4c0a44e1f847fd59b6e24a27288dbd8fe0030", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMjIyNQ==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r388932225", "bodyText": "Also, why do we need static numbers? Can these variables not be derived by the size, location, etc.. of the objective?", "author": "Electroid", "createdAt": "2020-03-06T14:27:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMTEzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNzE4MQ==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r389217181", "bodyText": "@Electroid To be honest I haven\u2019t looked into why these numbers were set. As I stated in the original PR, most of this came right from the ProjectAres repo. So my guess is that these numbers are most likely fine tuned to how OCN saw fit, and I doubt much has changed in regards to the objective types since.\nWhen I performed testing of these changes everything worked really nicely, so I don\u2019t really see a need to change them/risk having them look bad. If you want I can make these static variables as you suggested, but anything custom may take some time (I don\u2019t have much free time for the next week).\nLet me know what you would like me to do. Thanks!", "author": "applenick", "createdAt": "2020-03-07T02:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMTEzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI2MTMzOQ==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r389261339", "bodyText": "Hmm, that's okay for now, we can skip over the magic numbers", "author": "Electroid", "createdAt": "2020-03-07T15:16:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMTEzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMTI0OA==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r388931248", "bodyText": "Magic numbers.", "author": "Electroid", "createdAt": "2020-03-06T14:25:43Z", "path": "core/src/main/java/tc/oc/pgm/fireworks/FireworkMatchModule.java", "diffHunk": "@@ -0,0 +1,237 @@\n+package tc.oc.pgm.fireworks;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nonnull;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Color;\n+import org.bukkit.FireworkEffect;\n+import org.bukkit.FireworkEffect.Type;\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.World;\n+import org.bukkit.block.Block;\n+import org.bukkit.entity.EntityType;\n+import org.bukkit.entity.Firework;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.inventory.meta.FireworkMeta;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.controlpoint.events.ControllerChangeEvent;\n+import tc.oc.pgm.core.CoreLeakEvent;\n+import tc.oc.pgm.destroyable.DestroyableDestroyedEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.flag.event.FlagCaptureEvent;\n+import tc.oc.pgm.regions.Bounds;\n+import tc.oc.pgm.regions.Region;\n+import tc.oc.pgm.wool.PlayerWoolPlaceEvent;\n+import tc.oc.util.bukkit.BukkitUtils;\n+import tc.oc.util.bukkit.block.BlockVectors;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class FireworkMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n+\n+  private final boolean postEnabled = Config.Fireworks.postMatchEnabled();\n+  private final boolean goalsEnabled = Config.Fireworks.goalsEnabled();\n+  private final int number = 5;\n+  private final int delay = 40;\n+  private final int frequency = 40;\n+  private final int iterationCount = 15;\n+  private final int power = 2;\n+\n+  public FireworkMatchModule(Match match) {\n+    this.match = match;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onMatchEnd(final MatchFinishEvent event) {\n+    if (!postEnabled) return;\n+    match\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskTimer(delay, frequency, new FireworkRunner(event.getWinners()));\n+  }\n+\n+  public static List<FireworkEffect.Type> AVAILABLE_TYPES =\n+      ImmutableList.<FireworkEffect.Type>builder()\n+          .add(Type.BALL)\n+          .add(Type.BALL_LARGE)\n+          .add(Type.BURST)\n+          .add(Type.STAR)\n+          .build();\n+\n+  public class FireworkRunner implements Runnable {\n+    private final Set<Color> colors;\n+    private final Collection<Competitor> winners;\n+    private int iterations = 0;\n+\n+    public FireworkRunner(Collection<Competitor> winners) {\n+      this.winners = winners;\n+      this.colors =\n+          winners.stream()\n+              .map(winner -> BukkitUtils.colorOf(winner.getColor()))\n+              .collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    public void run() {\n+      if (this.iterations < iterationCount) {\n+        // Build this list fresh every time, because MatchPlayers can unload, but Competitors can't.\n+        final List<MatchPlayer> players =\n+            winners.stream().flatMap(c -> c.getPlayers().stream()).collect(Collectors.toList());\n+        Collections.shuffle(players);\n+\n+        for (int i = 0; i < players.size() && i < number; i++) {\n+          MatchPlayer player = players.get(i);\n+\n+          Type type = AVAILABLE_TYPES.get(match.getRandom().nextInt(AVAILABLE_TYPES.size()));\n+\n+          FireworkEffect effect =\n+              FireworkEffect.builder()\n+                  .with(type)\n+                  .withFlicker()\n+                  .withColor(this.colors)\n+                  .withFade(Color.BLACK)\n+                  .build();\n+\n+          spawnFirework(player.getBukkit().getLocation(), effect, power);\n+        }\n+      }\n+      this.iterations++;\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onWoolPlace(final PlayerWoolPlaceEvent event) {\n+    if (goalsEnabled && event.getWool().isVisible()) {\n+      this.spawnFireworkDisplay(\n+          BlockVectors.center(event.getBlock()), event.getWool().getDyeColor().getColor(), 6, 2, 2);\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onCoreLeak(final CoreLeakEvent event) {\n+    if (goalsEnabled && event.getCore().isVisible()) {\n+      this.spawnFireworkDisplay(\n+          event.getMatch().getWorld(),\n+          event.getCore().getCasingRegion(),\n+          event.getCore().getColor(),\n+          8,\n+          1.5,\n+          2);\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onDestroyableBreak(final DestroyableDestroyedEvent event) {\n+    if (goalsEnabled && event.getDestroyable().isVisible()) {\n+      this.spawnFireworkDisplay(\n+          event.getMatch().getWorld(),\n+          event.getDestroyable().getBlockRegion(),\n+          event.getDestroyable().getColor(),\n+          4,\n+          3,\n+          2);", "originalCommit": "0cb4c0a44e1f847fd59b6e24a27288dbd8fe0030", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMTY1Ng==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r388931656", "bodyText": "We don't use @Nonnull, only @Nullable, so they can be removed here.", "author": "Electroid", "createdAt": "2020-03-06T14:26:22Z", "path": "core/src/main/java/tc/oc/pgm/fireworks/FireworkMatchModule.java", "diffHunk": "@@ -0,0 +1,237 @@\n+package tc.oc.pgm.fireworks;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nonnull;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Color;\n+import org.bukkit.FireworkEffect;\n+import org.bukkit.FireworkEffect.Type;\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.World;\n+import org.bukkit.block.Block;\n+import org.bukkit.entity.EntityType;\n+import org.bukkit.entity.Firework;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.inventory.meta.FireworkMeta;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.controlpoint.events.ControllerChangeEvent;\n+import tc.oc.pgm.core.CoreLeakEvent;\n+import tc.oc.pgm.destroyable.DestroyableDestroyedEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.flag.event.FlagCaptureEvent;\n+import tc.oc.pgm.regions.Bounds;\n+import tc.oc.pgm.regions.Region;\n+import tc.oc.pgm.wool.PlayerWoolPlaceEvent;\n+import tc.oc.util.bukkit.BukkitUtils;\n+import tc.oc.util.bukkit.block.BlockVectors;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class FireworkMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n+\n+  private final boolean postEnabled = Config.Fireworks.postMatchEnabled();\n+  private final boolean goalsEnabled = Config.Fireworks.goalsEnabled();\n+  private final int number = 5;\n+  private final int delay = 40;\n+  private final int frequency = 40;\n+  private final int iterationCount = 15;\n+  private final int power = 2;\n+\n+  public FireworkMatchModule(Match match) {\n+    this.match = match;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onMatchEnd(final MatchFinishEvent event) {\n+    if (!postEnabled) return;\n+    match\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskTimer(delay, frequency, new FireworkRunner(event.getWinners()));\n+  }\n+\n+  public static List<FireworkEffect.Type> AVAILABLE_TYPES =\n+      ImmutableList.<FireworkEffect.Type>builder()\n+          .add(Type.BALL)\n+          .add(Type.BALL_LARGE)\n+          .add(Type.BURST)\n+          .add(Type.STAR)\n+          .build();\n+\n+  public class FireworkRunner implements Runnable {\n+    private final Set<Color> colors;\n+    private final Collection<Competitor> winners;\n+    private int iterations = 0;\n+\n+    public FireworkRunner(Collection<Competitor> winners) {\n+      this.winners = winners;\n+      this.colors =\n+          winners.stream()\n+              .map(winner -> BukkitUtils.colorOf(winner.getColor()))\n+              .collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    public void run() {\n+      if (this.iterations < iterationCount) {\n+        // Build this list fresh every time, because MatchPlayers can unload, but Competitors can't.\n+        final List<MatchPlayer> players =\n+            winners.stream().flatMap(c -> c.getPlayers().stream()).collect(Collectors.toList());\n+        Collections.shuffle(players);\n+\n+        for (int i = 0; i < players.size() && i < number; i++) {\n+          MatchPlayer player = players.get(i);\n+\n+          Type type = AVAILABLE_TYPES.get(match.getRandom().nextInt(AVAILABLE_TYPES.size()));\n+\n+          FireworkEffect effect =\n+              FireworkEffect.builder()\n+                  .with(type)\n+                  .withFlicker()\n+                  .withColor(this.colors)\n+                  .withFade(Color.BLACK)\n+                  .build();\n+\n+          spawnFirework(player.getBukkit().getLocation(), effect, power);\n+        }\n+      }\n+      this.iterations++;\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onWoolPlace(final PlayerWoolPlaceEvent event) {\n+    if (goalsEnabled && event.getWool().isVisible()) {\n+      this.spawnFireworkDisplay(\n+          BlockVectors.center(event.getBlock()), event.getWool().getDyeColor().getColor(), 6, 2, 2);\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onCoreLeak(final CoreLeakEvent event) {\n+    if (goalsEnabled && event.getCore().isVisible()) {\n+      this.spawnFireworkDisplay(\n+          event.getMatch().getWorld(),\n+          event.getCore().getCasingRegion(),\n+          event.getCore().getColor(),\n+          8,\n+          1.5,\n+          2);\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onDestroyableBreak(final DestroyableDestroyedEvent event) {\n+    if (goalsEnabled && event.getDestroyable().isVisible()) {\n+      this.spawnFireworkDisplay(\n+          event.getMatch().getWorld(),\n+          event.getDestroyable().getBlockRegion(),\n+          event.getDestroyable().getColor(),\n+          4,\n+          3,\n+          2);\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onHillCapture(final ControllerChangeEvent event) {\n+    if (goalsEnabled && event.getControlPoint().isVisible() && event.getNewController() != null) {\n+      this.spawnFireworkDisplay(\n+          event.getMatch().getWorld(),\n+          event.getControlPoint().getCaptureRegion(),\n+          BukkitUtils.colorOf(event.getNewController().getColor()),\n+          8,\n+          1,\n+          2);\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onFlagCapture(final FlagCaptureEvent event) {\n+    if (goalsEnabled && event.getGoal().isVisible()) {\n+      this.spawnFireworkDisplay(\n+          event.getMatch().getWorld(),\n+          event.getNet().getRegion(),\n+          event.getGoal().getDyeColor().getColor(),\n+          6,\n+          1,\n+          2);\n+    }\n+  }\n+\n+  public void spawnFireworkDisplay(\n+      Location center, Color color, int count, double radius, int power) {\n+    FireworkEffect effect =\n+        FireworkEffect.builder()\n+            .with(Type.BURST)\n+            .withFlicker()\n+            .withColor(color)\n+            .withFade(Color.BLACK)\n+            .build();\n+\n+    for (int i = 0; i < count; i++) {\n+      double angle = 2 * Math.PI / count * i;\n+      double dx = radius * Math.cos(angle);\n+      double dz = radius * Math.sin(angle);\n+      Location baseLocation = center.clone().add(dx, 0, dz);\n+\n+      Block block = baseLocation.getBlock();\n+      if (block == null || !block.getType().isOccluding()) {\n+        spawnFirework(getOpenSpaceAbove(baseLocation), effect, power);\n+      }\n+    }\n+  }\n+\n+  public void spawnFireworkDisplay(\n+      World world, Region region, Color color, int count, double radiusMultiplier, int power) {\n+    final Bounds bound = region.getBounds();\n+    final double radius = bound.getMax().subtract(bound.getMin()).multiply(0.5).length();\n+    final Location center = bound.getMin().getMidpoint(bound.getMax()).toLocation(world);\n+    this.spawnFireworkDisplay(center, color, count, radiusMultiplier * radius, power);\n+  }\n+\n+  public static @Nonnull Firework spawnFirework(\n+      @Nonnull Location location, @Nonnull FireworkEffect effect, int power) {\n+    Preconditions.checkNotNull(location, \"location\");\n+    Preconditions.checkNotNull(effect, \"firework effect\");\n+    Preconditions.checkArgument(power >= 0, \"power must be positive\");\n+\n+    FireworkMeta meta = (FireworkMeta) Bukkit.getItemFactory().getItemMeta(Material.FIREWORK);\n+    meta.setPower(power);\n+    meta.addEffect(effect);\n+\n+    Firework firework = (Firework) location.getWorld().spawnEntity(location, EntityType.FIREWORK);\n+    firework.setFireworkMeta(meta);\n+\n+    return firework;\n+  }\n+\n+  public static @Nonnull Location getOpenSpaceAbove(@Nonnull Location location) {", "originalCommit": "0cb4c0a44e1f847fd59b6e24a27288dbd8fe0030", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMjQyNw==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r388932427", "bodyText": "private static class", "author": "Electroid", "createdAt": "2020-03-06T14:27:42Z", "path": "core/src/main/java/tc/oc/pgm/fireworks/FireworkMatchModule.java", "diffHunk": "@@ -0,0 +1,237 @@\n+package tc.oc.pgm.fireworks;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nonnull;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Color;\n+import org.bukkit.FireworkEffect;\n+import org.bukkit.FireworkEffect.Type;\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.World;\n+import org.bukkit.block.Block;\n+import org.bukkit.entity.EntityType;\n+import org.bukkit.entity.Firework;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.inventory.meta.FireworkMeta;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.controlpoint.events.ControllerChangeEvent;\n+import tc.oc.pgm.core.CoreLeakEvent;\n+import tc.oc.pgm.destroyable.DestroyableDestroyedEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.flag.event.FlagCaptureEvent;\n+import tc.oc.pgm.regions.Bounds;\n+import tc.oc.pgm.regions.Region;\n+import tc.oc.pgm.wool.PlayerWoolPlaceEvent;\n+import tc.oc.util.bukkit.BukkitUtils;\n+import tc.oc.util.bukkit.block.BlockVectors;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class FireworkMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n+\n+  private final boolean postEnabled = Config.Fireworks.postMatchEnabled();\n+  private final boolean goalsEnabled = Config.Fireworks.goalsEnabled();\n+  private final int number = 5;\n+  private final int delay = 40;\n+  private final int frequency = 40;\n+  private final int iterationCount = 15;\n+  private final int power = 2;\n+\n+  public FireworkMatchModule(Match match) {\n+    this.match = match;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onMatchEnd(final MatchFinishEvent event) {\n+    if (!postEnabled) return;\n+    match\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskTimer(delay, frequency, new FireworkRunner(event.getWinners()));\n+  }\n+\n+  public static List<FireworkEffect.Type> AVAILABLE_TYPES =\n+      ImmutableList.<FireworkEffect.Type>builder()\n+          .add(Type.BALL)\n+          .add(Type.BALL_LARGE)\n+          .add(Type.BURST)\n+          .add(Type.STAR)\n+          .build();\n+\n+  public class FireworkRunner implements Runnable {", "originalCommit": "0cb4c0a44e1f847fd59b6e24a27288dbd8fe0030", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMjYwOA==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r388932608", "bodyText": "FIREWORK_TYPES", "author": "Electroid", "createdAt": "2020-03-06T14:28:02Z", "path": "core/src/main/java/tc/oc/pgm/fireworks/FireworkMatchModule.java", "diffHunk": "@@ -0,0 +1,237 @@\n+package tc.oc.pgm.fireworks;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nonnull;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Color;\n+import org.bukkit.FireworkEffect;\n+import org.bukkit.FireworkEffect.Type;\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.World;\n+import org.bukkit.block.Block;\n+import org.bukkit.entity.EntityType;\n+import org.bukkit.entity.Firework;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.inventory.meta.FireworkMeta;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.controlpoint.events.ControllerChangeEvent;\n+import tc.oc.pgm.core.CoreLeakEvent;\n+import tc.oc.pgm.destroyable.DestroyableDestroyedEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.flag.event.FlagCaptureEvent;\n+import tc.oc.pgm.regions.Bounds;\n+import tc.oc.pgm.regions.Region;\n+import tc.oc.pgm.wool.PlayerWoolPlaceEvent;\n+import tc.oc.util.bukkit.BukkitUtils;\n+import tc.oc.util.bukkit.block.BlockVectors;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class FireworkMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n+\n+  private final boolean postEnabled = Config.Fireworks.postMatchEnabled();\n+  private final boolean goalsEnabled = Config.Fireworks.goalsEnabled();\n+  private final int number = 5;\n+  private final int delay = 40;\n+  private final int frequency = 40;\n+  private final int iterationCount = 15;\n+  private final int power = 2;\n+\n+  public FireworkMatchModule(Match match) {\n+    this.match = match;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onMatchEnd(final MatchFinishEvent event) {\n+    if (!postEnabled) return;\n+    match\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskTimer(delay, frequency, new FireworkRunner(event.getWinners()));\n+  }\n+\n+  public static List<FireworkEffect.Type> AVAILABLE_TYPES =", "originalCommit": "0cb4c0a44e1f847fd59b6e24a27288dbd8fe0030", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMjEyMA==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r389302120", "bodyText": "This doesn't seem like it belongs in this commit, should make another one to change this factory for the method reference to the constructor", "author": "Pablete1234", "createdAt": "2020-03-07T18:27:49Z", "path": "core/src/main/java/tc/oc/pgm/observers/ObserverToolsMatchModule.java", "diffHunk": "@@ -36,13 +34,6 @@\n @ListenerScope(MatchScope.LOADED)\n public class ObserverToolsMatchModule implements MatchModule, Listener {\n \n-  public static class Factory implements MatchModuleFactory<ObserverToolsMatchModule> {\n-    @Override\n-    public ObserverToolsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n-      return new ObserverToolsMatchModule(match);\n-    }\n-  }\n-\n   // Slot where tool item is placed", "originalCommit": "0cb4c0a44e1f847fd59b6e24a27288dbd8fe0030", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMjIyMw==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r389302223", "bodyText": "Oh whoops, should have double checked \ud83e\udd26\u200d\u2642.\nThanks for catching that @Pablete1234! I have an upcoming PR that will include that change.", "author": "applenick", "createdAt": "2020-03-07T18:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMjEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQyNzYxNw==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r389427617", "bodyText": "Could use some better naming or descriptions (i'm not 100% sure if i got them all right or i mixed any of them up):\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static final int NUMBER = 5;\n          \n          \n            \n              private static final int DELAY = 40;\n          \n          \n            \n              private static final int FREQUENCY = 40;\n          \n          \n            \n              private static final int ITERATION_COUNT = 15;\n          \n          \n            \n              private static final int POWER = 2;\n          \n          \n            \n              private static final int MAX_ROCKET_COUNT = 5; // Maximum rockets to throw at once, one per player\n          \n          \n            \n              private static final int INITIAL_DELAY = 40; // Ticks before starting to throw rockets\n          \n          \n            \n              private static final int FREQUENCY = 40; // Ticks between rocket throws\n          \n          \n            \n              private static final int ITERATION_COUNT = 15; // Amount of times rockets are thrown\n          \n          \n            \n              private static final int ROCKET_POWER = 2; // Power of the rockets, 1 = low, 2 = medium, 3 = high", "author": "Pablete1234", "createdAt": "2020-03-09T01:11:59Z", "path": "core/src/main/java/tc/oc/pgm/fireworks/FireworkMatchModule.java", "diffHunk": "@@ -0,0 +1,259 @@\n+package tc.oc.pgm.fireworks;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nonnull;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Color;\n+import org.bukkit.FireworkEffect;\n+import org.bukkit.FireworkEffect.Type;\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.World;\n+import org.bukkit.block.Block;\n+import org.bukkit.entity.EntityType;\n+import org.bukkit.entity.Firework;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.inventory.meta.FireworkMeta;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.controlpoint.events.ControllerChangeEvent;\n+import tc.oc.pgm.core.CoreLeakEvent;\n+import tc.oc.pgm.destroyable.DestroyableDestroyedEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.flag.event.FlagCaptureEvent;\n+import tc.oc.pgm.regions.Bounds;\n+import tc.oc.pgm.regions.Region;\n+import tc.oc.pgm.wool.PlayerWoolPlaceEvent;\n+import tc.oc.util.bukkit.BukkitUtils;\n+import tc.oc.util.bukkit.block.BlockVectors;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class FireworkMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n+\n+  private static final boolean POST_ENABLED = Config.Fireworks.postMatchEnabled();\n+  private static final boolean GOALS_ENABLED = Config.Fireworks.goalsEnabled();\n+\n+  private static final int NUMBER = 5;\n+  private static final int DELAY = 40;\n+  private static final int FREQUENCY = 40;\n+  private static final int ITERATION_COUNT = 15;\n+  private static final int POWER = 2;", "originalCommit": "a71f52f974eaaeac9e0a03a131532916b0cb6a3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc3MjIyMA==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r390772220", "bodyText": "Great suggestion @Pablete1234! I\u2019ll take care of this as soon as I can, sorry for the delay.", "author": "applenick", "createdAt": "2020-03-11T06:47:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQyNzYxNw=="}], "type": "inlineReview"}, {"oid": "927f12f85831cfc8659029da7566a8f1eebfd86e", "url": "https://github.com/PGMDev/PGM/commit/927f12f85831cfc8659029da7566a8f1eebfd86e", "message": "Reintroduce fireworks\n* Add FireworkMatchModule - allows for objective fireworks and post-match victory fireworks\n\nSigned-off-by: applenick <applenick@users.noreply.github.com>", "committedDate": "2020-03-11T23:57:44Z", "type": "commit"}, {"oid": "927f12f85831cfc8659029da7566a8f1eebfd86e", "url": "https://github.com/PGMDev/PGM/commit/927f12f85831cfc8659029da7566a8f1eebfd86e", "message": "Reintroduce fireworks\n* Add FireworkMatchModule - allows for objective fireworks and post-match victory fireworks\n\nSigned-off-by: applenick <applenick@users.noreply.github.com>", "committedDate": "2020-03-11T23:57:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwOTk1MQ==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r391709951", "bodyText": "TBH, if there are all just \"magic\" numbers, then let's skip the static variables.\nNice in theory, but there's way too many vars here.", "author": "Electroid", "createdAt": "2020-03-12T15:41:35Z", "path": "core/src/main/java/tc/oc/pgm/fireworks/FireworkMatchModule.java", "diffHunk": "@@ -0,0 +1,258 @@\n+package tc.oc.pgm.fireworks;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Color;\n+import org.bukkit.FireworkEffect;\n+import org.bukkit.FireworkEffect.Type;\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.World;\n+import org.bukkit.block.Block;\n+import org.bukkit.entity.EntityType;\n+import org.bukkit.entity.Firework;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.inventory.meta.FireworkMeta;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.controlpoint.events.ControllerChangeEvent;\n+import tc.oc.pgm.core.CoreLeakEvent;\n+import tc.oc.pgm.destroyable.DestroyableDestroyedEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.flag.event.FlagCaptureEvent;\n+import tc.oc.pgm.regions.Bounds;\n+import tc.oc.pgm.regions.Region;\n+import tc.oc.pgm.wool.PlayerWoolPlaceEvent;\n+import tc.oc.util.bukkit.BukkitUtils;\n+import tc.oc.util.bukkit.block.BlockVectors;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class FireworkMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n+\n+  private static final boolean POST_ENABLED = Config.Fireworks.postMatchEnabled();\n+  private static final boolean GOALS_ENABLED = Config.Fireworks.goalsEnabled();\n+\n+  private static final int ROCKET_COUNT = 5; // Maximum rockets to launch at once, one per player\n+  private static final int INITIAL_DELAY = 40; // Ticks before starting to launch rockets\n+  private static final int FREQUENCY = 40; // Ticks between rocket launches\n+  private static final int ITERATION_COUNT = 15; // Amount of times rockets are launched\n+  private static final int ROCKET_POWER =\n+      2; // Power applied to rockets (how high they go), 1 = low, 2 = medium, 3 = high\n+\n+  private static final int WOOL_PLACE_COUNT = 6;\n+  private static final double WOOL_PLACE_RADIUS = 2;\n+\n+  private static final int CORE_LEAK_COUNT = 8;\n+  private static final double CORE_LEAK_RADIUS = 1.5;\n+\n+  private static final int DESTROYABLE_BREAK_COUNT = 4;\n+  private static final double DESTROYABLE_BREAK_RADIUS = 3;\n+\n+  private static final int CONTROL_POINT_COUNT = 8;\n+  private static final double CONTROL_POINT_RADIUS = 1;\n+\n+  private static final int FLAG_CAPTURE_COUNT = 6;\n+  private static final double FLAG_CAPTURE_RADIUS = 1;", "originalCommit": "927f12f85831cfc8659029da7566a8f1eebfd86e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MTkyMQ==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r391891921", "bodyText": "I'd much rather have them as variables than magic numbers. If we ever feel like changing them it's much easier to have it this way", "author": "Pablete1234", "createdAt": "2020-03-12T21:02:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwOTk1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3NzI4NQ==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r392377285", "bodyText": "@Electroid I agree with @Pablete1234. It is rather excessive for magic numbers, but personally I feel it\u2019s more organized and understandable for new contributors who may want to adjust them later on.\nIf you dislike them all at the top of the file, I can move each respective pair above the event they\u2019re related to like:\n...\nprivate static final int CORE_LEAK_COUNT = 8;\nprivate static final double CORE_LEAK_RADIUS = 1.5;\n\n @EventHandler(priority = EventPriority.MONITOR)\n   public void onCoreLeak(final CoreLeakEvent event) {\n     if (GOALS_ENABLED && event.getCore().isVisible()) {\n       this.spawnFireworkDisplay(\n           event.getMatch().getWorld(),\n           event.getCore().getCasingRegion(),\n           event.getCore().getColor(),\n           CORE_LEAK_COUNT,\n           CORE_LEAK_RADIUS,\n           ROCKET_POWER);\n     }\n   }", "author": "applenick", "createdAt": "2020-03-13T17:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwOTk1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU5OTIzNw==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r392599237", "bodyText": "@applenick Go ahead and make that change, then ready to go", "author": "Electroid", "createdAt": "2020-03-14T16:08:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwOTk1MQ=="}], "type": "inlineReview"}, {"oid": "be6a541069fe2adf68664e56ddd114965425d2d8", "url": "https://github.com/PGMDev/PGM/commit/be6a541069fe2adf68664e56ddd114965425d2d8", "message": "Organize objective variables\n\nSigned-off-by: applenick <applenick@users.noreply.github.com>", "committedDate": "2020-03-14T17:12:47Z", "type": "commit"}, {"oid": "159c314647394f156bf3cbf417ab3205f1eedd11", "url": "https://github.com/PGMDev/PGM/commit/159c314647394f156bf3cbf417ab3205f1eedd11", "message": "Merge branch 'master' into fireworks", "committedDate": "2020-03-14T17:15:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYwNjAzOA==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r392606038", "bodyText": "Post match default is false? Why not true?", "author": "Electroid", "createdAt": "2020-03-14T17:46:47Z", "path": "core/src/main/java/tc/oc/pgm/Config.java", "diffHunk": "@@ -477,4 +477,15 @@ public static boolean isAppealVisible() {\n       return getAppealMessage().length() > 0;\n     }\n   }\n+\n+  public static class Fireworks {\n+\n+    public static boolean postMatchEnabled() {\n+      return getConfiguration().getBoolean(\"fireworks.post-match\", false);", "originalCommit": "159c314647394f156bf3cbf417ab3205f1eedd11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYwNjIwMA==", "url": "https://github.com/PGMDev/PGM/pull/351#discussion_r392606200", "bodyText": "It was suggested above by @Pablete1234 to have it default false. Personally I would have it as true. Want me to adjust it?", "author": "applenick", "createdAt": "2020-03-14T17:49:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYwNjAzOA=="}], "type": "inlineReview"}, {"oid": "6ba6361b9839cb30180b4d3bc7c74179e84f018e", "url": "https://github.com/PGMDev/PGM/commit/6ba6361b9839cb30180b4d3bc7c74179e84f018e", "message": "Adjust post-match config default\n\nSigned-off-by: applenick <applenick@users.noreply.github.com>", "committedDate": "2020-03-14T18:03:20Z", "type": "commit"}]}