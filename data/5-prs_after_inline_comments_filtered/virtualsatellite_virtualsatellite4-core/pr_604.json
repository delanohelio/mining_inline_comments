{"pr_number": 604, "pr_title": "Add csv requirement import", "pr_createdAt": "2020-05-13T15:09:57Z", "pr_url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604", "timeline": [{"oid": "2a56117f19b17b81d7652080341ad8c5b98a7594", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/2a56117f19b17b81d7652080341ad8c5b98a7594", "message": "Merge remote-tracking branch 'origin/development' into feature/task_216-Add_CSV_requirement_import", "committedDate": "2019-08-15T08:57:19Z", "type": "commit"}, {"oid": "0bc0e64f85e809616e5b4b6813dbc18d155bbb19", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/0bc0e64f85e809616e5b4b6813dbc18d155bbb19", "message": "Create CSV req importer signature and test - (Task #216)", "committedDate": "2019-08-15T13:44:08Z", "type": "commit"}, {"oid": "e143ab5e8e48b1a0902202d2c49f0b7e79739141", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/e143ab5e8e48b1a0902202d2c49f0b7e79739141", "message": "Implement CSV import - (Task #216)", "committedDate": "2019-08-15T16:06:28Z", "type": "commit"}, {"oid": "49d4f85e164e0c1a6837eb0b7106a485424a147b", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/49d4f85e164e0c1a6837eb0b7106a485424a147b", "message": "Add basic import wizrad to perfrom req CSV import - (Task #216)", "committedDate": "2019-08-19T15:01:39Z", "type": "commit"}, {"oid": "26146853b767e926ef3bd972d7df9d664c802583", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/26146853b767e926ef3bd972d7df9d664c802583", "message": "Give new requirement type name and its attributes a type - (Task #216)", "committedDate": "2019-08-19T15:19:18Z", "type": "commit"}, {"oid": "a1fd7656f6cd22ee1403bfac16dbc4979c423620", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/a1fd7656f6cd22ee1403bfac16dbc4979c423620", "message": "Update csv requirement import to map columns to attributes - (Task #216)", "committedDate": "2019-09-03T14:31:56Z", "type": "commit"}, {"oid": "654a99f6930d13a35cb53bf6b8c866c4b1baa5aa", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/654a99f6930d13a35cb53bf6b8c866c4b1baa5aa", "message": "Improve enumeration handling - (Task #216)", "committedDate": "2019-09-03T15:30:08Z", "type": "commit"}, {"oid": "9222afb704288ee25c1d09f902266467e1ad9fdc", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/9222afb704288ee25c1d09f902266467e1ad9fdc", "message": "Fix column index handling in import - (Task #216)", "committedDate": "2019-09-04T07:29:46Z", "type": "commit"}, {"oid": "21cd7ce61809edfa4fc3dfc9b6439f472da74419", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/21cd7ce61809edfa4fc3dfc9b6439f472da74419", "message": "Fix version numbers in requirements projects - (Task #216)", "committedDate": "2019-09-04T07:59:16Z", "type": "commit"}, {"oid": "24cf935af15fc563e8df2b285746b34acc5660a2", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/24cf935af15fc563e8df2b285746b34acc5660a2", "message": "Fix spot bugs and surefire warnings - (Task #216)", "committedDate": "2019-09-04T08:54:06Z", "type": "commit"}, {"oid": "e77dbf0859b659399d3136cb4fc6f2877224983a", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/e77dbf0859b659399d3136cb4fc6f2877224983a", "message": "Merge branch 'feature/task_127-Requirements_concept_UI' into\nfeature/task_216-Add_CSV_requirement_import\n\nConflicts:\n\tde.dlr.sc.virsat.model.extension.requirements.test/src-gen/de/dlr/sc/virsat/model/extension/requirements/test/AllTestsGen.java", "committedDate": "2019-09-04T14:28:19Z", "type": "commit"}, {"oid": "bf6869424c7c64ebd0bf8f620413e99fecd42d76", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/bf6869424c7c64ebd0bf8f620413e99fecd42d76", "message": "Add csv importer tests to test suite - (Task #216)", "committedDate": "2019-09-04T14:44:34Z", "type": "commit"}, {"oid": "0f12cc453df4012684e7370cb8a32bb3d3aca6e4", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/0f12cc453df4012684e7370cb8a32bb3d3aca6e4", "message": "Merge branch 'feature/task_127-Requirements_concept_UI' into\nfeature/task_216-Add_CSV_requirement_import\n\nConflicts:\n\tde.dlr.sc.virsat.model.extension.requirements.ui/META-INF/MANIFEST.MF\n\tde.dlr.sc.virsat.model.extension.requirements.ui/plugin.xml\n\tde.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/Activator.java\n\tde.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/celleditor/RequirementsAttributeValuePerColumnEditingSupport.java", "committedDate": "2019-09-10T11:06:31Z", "type": "commit"}, {"oid": "90a6b8557ba5820b7deb6f9db0bc729298b6f71d", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/90a6b8557ba5820b7deb6f9db0bc729298b6f71d", "message": "IMprove description layout - (Task #216)", "committedDate": "2019-09-10T12:14:45Z", "type": "commit"}, {"oid": "388815f5544ac2e5612a1fde5ec652db7612788b", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/388815f5544ac2e5612a1fde5ec652db7612788b", "message": "Fix some configuration erros of CSV import - (Task #274)", "committedDate": "2019-09-12T10:29:11Z", "type": "commit"}, {"oid": "a8f69f12ea73dd9b29ce9401cd888469f661e893", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/a8f69f12ea73dd9b29ce9401cd888469f661e893", "message": "Merge UI branch updates - (Task #216)", "committedDate": "2019-09-12T10:36:01Z", "type": "commit"}, {"oid": "457211309f54acb7b110ecb0aec5cb4876d410e1", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/457211309f54acb7b110ecb0aec5cb4876d410e1", "message": "Connect incomplete extensions to their requirement - (Task #216)", "committedDate": "2019-09-12T16:21:26Z", "type": "commit"}, {"oid": "8adf6672bf4156d973d5812a2c0504bd312339cc", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/8adf6672bf4156d973d5812a2c0504bd312339cc", "message": "Use correct listener for text widgets - (Task #216)", "committedDate": "2019-09-12T16:25:30Z", "type": "commit"}, {"oid": "ba9b091f527862a9ee6201913d55ffef08aa4256", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/ba9b091f527862a9ee6201913d55ffef08aa4256", "message": "Improve name handling of imported requirements - (Task #216)", "committedDate": "2019-09-13T12:57:54Z", "type": "commit"}, {"oid": "692006b6e369a9b9c519e8619022308681d33899", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/692006b6e369a9b9c519e8619022308681d33899", "message": "Merge branch 'development' into\nfeature/task_216-Add_CSV_requirement_import\n\nConflicts:\n\tde.dlr.sc.virsat.model.extension.requirements.test/src/de/dlr/sc/virsat/model/extension/requirements/test/AllTests.java\n\tde.dlr.sc.virsat.model.extension.requirements/META-INF/MANIFEST.MF", "committedDate": "2020-02-13T20:53:22Z", "type": "commit"}, {"oid": "23f62f2f310f1c2aa15e72addbce4399ca8fcf2c", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/23f62f2f310f1c2aa15e72addbce4399ca8fcf2c", "message": "Update generated xtend files - (Task #216)", "committedDate": "2020-02-14T08:27:26Z", "type": "commit"}, {"oid": "742f01995a9b8a5e3e0b31cc50d602e3f1350658", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/742f01995a9b8a5e3e0b31cc50d602e3f1350658", "message": "Merge branch 'development' into\nfeature/task_216-Add_CSV_requirement_import\n\nConflicts:\n\tde.dlr.sc.virsat.model.concept.test/xtend-gen/de/dlr/sc/virsat/model/concept/generator/dmf/GenerateDmfCategoriesTest.java\n\tde.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/model/Requirement.java\n\tde.dlr.sc.virsat.uiengine.ui/src/de/dlr/sc/virsat/uiengine/ui/wizard/AImportExportPage.java", "committedDate": "2020-05-13T12:51:29Z", "type": "commit"}, {"oid": "653b5b6d2ca06d717dedabfbe7b8a3ac9c387b68", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/653b5b6d2ca06d717dedabfbe7b8a3ac9c387b68", "message": "Fix potential NPE - Task #216", "committedDate": "2020-05-13T14:52:32Z", "type": "commit"}, {"oid": "eae68d618cc8f478996fff7a5d20ca75487cfa6e", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/eae68d618cc8f478996fff7a5d20ca75487cfa6e", "message": "Fix spot bugs fix - task #216", "committedDate": "2020-05-13T15:08:22Z", "type": "commit"}, {"oid": "c281a7ccfe7634c067d9f003c0eee40e6a14a5aa", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/c281a7ccfe7634c067d9f003c0eee40e6a14a5aa", "message": "Some minor fixes - task #216", "committedDate": "2020-05-13T15:30:01Z", "type": "commit"}, {"oid": "ac5887355afdc5f00ab4f4d17ac6552d10f6339b", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/ac5887355afdc5f00ab4f4d17ac6552d10f6339b", "message": "Add option to specify last data line - #216", "committedDate": "2020-05-13T15:58:43Z", "type": "commit"}, {"oid": "6011202ef23135d8a2ec66ff1571fcf917d2aa27", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/6011202ef23135d8a2ec66ff1571fcf917d2aa27", "message": "Make last data line specification optional - task #216", "committedDate": "2020-05-13T16:11:38Z", "type": "commit"}, {"oid": "33fb91aa1454b1614082570e73d031084fc659b7", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/33fb91aa1454b1614082570e73d031084fc659b7", "message": "FIx spotbux errors - task #216", "committedDate": "2020-05-13T16:38:39Z", "type": "commit"}, {"oid": "8ee1c3fc771538a09fd0009c96580b6db77def30", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/8ee1c3fc771538a09fd0009c96580b6db77def30", "message": "Fix failing tests - task #216", "committedDate": "2020-05-13T16:43:31Z", "type": "commit"}, {"oid": "f869134e98d9fc0e87d39a3dae58791eae71dfdc", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/f869134e98d9fc0e87d39a3dae58791eae71dfdc", "message": "Fix broken merge - task#216", "committedDate": "2020-05-13T17:14:50Z", "type": "commit"}, {"oid": "9e1132529295b286aed2e07e2acc4b059a2747d1", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/9e1132529295b286aed2e07e2acc4b059a2747d1", "message": "Add test for enum creation from data - (Task #216)", "committedDate": "2020-07-01T10:09:22Z", "type": "commit"}, {"oid": "6318f6ed87741459d09d8d7b42215c73502f303d", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/6318f6ed87741459d09d8d7b42215c73502f303d", "message": "Merge remote-tracking branch 'origin/development' into feature/task_216-Add_CSV_requirement_import", "committedDate": "2020-07-01T10:11:45Z", "type": "commit"}, {"oid": "455d0b54367731e384c7b98f93fbb30c8b565360", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/455d0b54367731e384c7b98f93fbb30c8b565360", "message": "Merge remote-tracking branch 'origin/development' into feature/task_216-Add_CSV_requirement_import", "committedDate": "2020-07-02T14:52:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyNjk5OQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449226999", "bodyText": "This seems to be the name of your json file in all your test cases maybe make it a private static final?", "author": "SaMuellerDLR", "createdAt": "2020-07-02T19:32:23Z", "path": "de.dlr.sc.virsat.model.extension.requirements.test/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvFileReaderTest.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import static org.junit.Assert.assertEquals;\r\n+\r\n+import java.io.File;\r\n+import java.io.IOException;\r\n+import java.nio.file.Files;\r\n+import java.nio.file.Path;\r\n+import java.nio.file.Paths;\r\n+import java.util.Arrays;\r\n+import java.util.List;\r\n+\r\n+import org.junit.Test;\r\n+\r\n+/**\r\n+ * Test for the CSV file reader\r\n+ *\r\n+ */\r\n+public class CsvFileReaderTest {\r\n+\t\r\n+\tprivate static final String HEADER_1 = \"Header1\";\r\n+\tprivate static final String HEADER_2 = \"Header2\";\r\n+\tprivate static final String HEADER_3 = \"Header3\";\r\n+\t\r\n+\tprivate static final String REQ_ATT_1 = \"att1\";\r\n+\tprivate static final String REQ_ATT_2 = \"att2\";\r\n+\tprivate static final String REQ_ATT_3 = \"att3\";\r\n+\t\r\n+\tprivate static final String SEPERATOR = \";\";\r\n+\t\r\n+\t@Test\r\n+\tpublic void testReadCsvFile() throws IOException {\r\n+\t\t\r\n+\t\tfinal String JSON_FILE_NAME = \"dummy.csv\";\r\n+\t\tPath inputPath = Files.createTempDirectory(\"csvTest\");\r\n+\t\tPath csvFilePath = Paths.get(inputPath.toString() + File.separator + JSON_FILE_NAME);\r\n+\t\t\r\n+\t\tList<String> csvContent = Arrays.asList(HEADER_1 + SEPERATOR + HEADER_2 + SEPERATOR + HEADER_3,\r\n+\t\t\t\tREQ_ATT_1 + SEPERATOR + REQ_ATT_2 + SEPERATOR + REQ_ATT_3);\r\n+\t\t\r\n+\t\tFiles.write(csvFilePath, csvContent);\r\n+\t\t\r\n+\t\tCsvFileReader reader = new CsvFileReader();\r\n+\t\t\r\n+\t\tList<List<String>> importedCsvContent = reader.readCsvFile(csvFilePath.toString(), 0, -1);\r\n+\t\t\r\n+\t\tassertEquals(\"Number of lines not correct\", 2, importedCsvContent.size());\r\n+\t\t\r\n+\t\tList<String> header = importedCsvContent.get(0);\r\n+\t\tassertEquals(\"Header not correct\", header.get(0), HEADER_1);\r\n+\t\tassertEquals(\"Header not correct\", header.get(1), HEADER_2);\r\n+\t\tassertEquals(\"Header not correct\", header.get(2), HEADER_3);\r\n+\t\t\r\n+\t\tList<String> reqLine = importedCsvContent.get(1);\r\n+\t\tassertEquals(\"Req att not correct\", reqLine.get(0), REQ_ATT_1);\r\n+\t\tassertEquals(\"Req att not correct\", reqLine.get(1), REQ_ATT_2);\r\n+\t\tassertEquals(\"Req att not correct\", reqLine.get(2), REQ_ATT_3);\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testReadCsvFileWithNewLine() throws IOException {\r\n+\t\t\r\n+\t\tfinal String JSON_FILE_NAME = \"dummy.csv\";\r\n+\t\tPath inputPath = Files.createTempDirectory(\"csvTest\");\r\n+\t\tPath csvFilePath = Paths.get(inputPath.toString() + File.separator + JSON_FILE_NAME);\r\n+\t\t\r\n+\t\t//Requirement is spread over two rows:\r\n+\t\tList<String> csvContent = Arrays.asList(HEADER_1 + SEPERATOR + HEADER_2 + SEPERATOR + HEADER_3,\r\n+\t\t\t\tREQ_ATT_1 + SEPERATOR, REQ_ATT_2 + SEPERATOR + REQ_ATT_3);\r\n+\t\t\r\n+\t\tFiles.write(csvFilePath, csvContent);\r\n+\t\t\r\n+\t\tCsvFileReader reader = new CsvFileReader();\r\n+\t\t\r\n+\t\tList<List<String>> importedCsvContent = reader.readCsvFile(csvFilePath.toString(), 0, -1);\r\n+\t\t\r\n+\t\tassertEquals(\"Number of lines not correct\", 2, importedCsvContent.size());\r\n+\t\t\r\n+\t\tList<String> header = importedCsvContent.get(0);\r\n+\t\tassertEquals(\"Header not correct\", header.get(0), HEADER_1);\r\n+\t\tassertEquals(\"Header not correct\", header.get(1), HEADER_2);\r\n+\t\tassertEquals(\"Header not correct\", header.get(2), HEADER_3);\r\n+\t\t\r\n+\t\tList<String> reqLine = importedCsvContent.get(1);\r\n+\t\tassertEquals(\"Req att not correct\", reqLine.get(0), REQ_ATT_1);\r\n+\t\tassertEquals(\"Req att not correct\", reqLine.get(1), REQ_ATT_2);\r\n+\t\tassertEquals(\"Req att not correct\", reqLine.get(2), REQ_ATT_3);\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testReadCsvHeadline() throws IOException {\r\n+\t\t\r\n+\t\tfinal String JSON_FILE_NAME = \"dummy.csv\";\r\n+\t\tPath inputPath = Files.createTempDirectory(\"csvTest\");\r\n+\t\tPath csvFilePath = Paths.get(inputPath.toString() + File.separator + JSON_FILE_NAME);\r\n+\t\t\r\n+\t\tList<String> csvContent = Arrays.asList(HEADER_1 + SEPERATOR + HEADER_2 + SEPERATOR + HEADER_3,\r\n+\t\t\t\tREQ_ATT_1 + SEPERATOR + REQ_ATT_2 + SEPERATOR + REQ_ATT_3);\r\n+\t\t\r\n+\t\tFiles.write(csvFilePath, csvContent);\r\n+\t\t\r\n+\t\tCsvFileReader reader = new CsvFileReader(\";\", 0, 1, 2);\r\n+\t\t\r\n+\t\tList<String> importedCsvHeader = reader.readCsvHeadline(csvFilePath.toString());\r\n+\t\t\r\n+\t\tassertEquals(\"Header not correct\", importedCsvHeader.get(0), HEADER_1);\r\n+\t\tassertEquals(\"Header not correct\", importedCsvHeader.get(1), HEADER_2);\r\n+\t\tassertEquals(\"Header not correct\", importedCsvHeader.get(2), HEADER_3);\r\n+\t\t\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testReadCsvData() throws IOException {\r\n+\t\t\r\n+\t\tfinal String JSON_FILE_NAME = \"dummy.csv\";\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyODYzMQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449228631", "bodyText": "I thought we usually write assertions in the positive (e.g. Header correct). Please check so we are consistent here.", "author": "SaMuellerDLR", "createdAt": "2020-07-02T19:36:10Z", "path": "de.dlr.sc.virsat.model.extension.requirements.test/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvFileReaderTest.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import static org.junit.Assert.assertEquals;\r\n+\r\n+import java.io.File;\r\n+import java.io.IOException;\r\n+import java.nio.file.Files;\r\n+import java.nio.file.Path;\r\n+import java.nio.file.Paths;\r\n+import java.util.Arrays;\r\n+import java.util.List;\r\n+\r\n+import org.junit.Test;\r\n+\r\n+/**\r\n+ * Test for the CSV file reader\r\n+ *\r\n+ */\r\n+public class CsvFileReaderTest {\r\n+\t\r\n+\tprivate static final String HEADER_1 = \"Header1\";\r\n+\tprivate static final String HEADER_2 = \"Header2\";\r\n+\tprivate static final String HEADER_3 = \"Header3\";\r\n+\t\r\n+\tprivate static final String REQ_ATT_1 = \"att1\";\r\n+\tprivate static final String REQ_ATT_2 = \"att2\";\r\n+\tprivate static final String REQ_ATT_3 = \"att3\";\r\n+\t\r\n+\tprivate static final String SEPERATOR = \";\";\r\n+\t\r\n+\t@Test\r\n+\tpublic void testReadCsvFile() throws IOException {\r\n+\t\t\r\n+\t\tfinal String JSON_FILE_NAME = \"dummy.csv\";\r\n+\t\tPath inputPath = Files.createTempDirectory(\"csvTest\");\r\n+\t\tPath csvFilePath = Paths.get(inputPath.toString() + File.separator + JSON_FILE_NAME);\r\n+\t\t\r\n+\t\tList<String> csvContent = Arrays.asList(HEADER_1 + SEPERATOR + HEADER_2 + SEPERATOR + HEADER_3,\r\n+\t\t\t\tREQ_ATT_1 + SEPERATOR + REQ_ATT_2 + SEPERATOR + REQ_ATT_3);\r\n+\t\t\r\n+\t\tFiles.write(csvFilePath, csvContent);\r\n+\t\t\r\n+\t\tCsvFileReader reader = new CsvFileReader();\r\n+\t\t\r\n+\t\tList<List<String>> importedCsvContent = reader.readCsvFile(csvFilePath.toString(), 0, -1);\r\n+\t\t\r\n+\t\tassertEquals(\"Number of lines not correct\", 2, importedCsvContent.size());\r\n+\t\t\r\n+\t\tList<String> header = importedCsvContent.get(0);\r\n+\t\tassertEquals(\"Header not correct\", header.get(0), HEADER_1);\r\n+\t\tassertEquals(\"Header not correct\", header.get(1), HEADER_2);\r\n+\t\tassertEquals(\"Header not correct\", header.get(2), HEADER_3);\r\n+\t\t\r\n+\t\tList<String> reqLine = importedCsvContent.get(1);\r\n+\t\tassertEquals(\"Req att not correct\", reqLine.get(0), REQ_ATT_1);\r\n+\t\tassertEquals(\"Req att not correct\", reqLine.get(1), REQ_ATT_2);\r\n+\t\tassertEquals(\"Req att not correct\", reqLine.get(2), REQ_ATT_3);\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testReadCsvFileWithNewLine() throws IOException {\r\n+\t\t\r\n+\t\tfinal String JSON_FILE_NAME = \"dummy.csv\";\r\n+\t\tPath inputPath = Files.createTempDirectory(\"csvTest\");\r\n+\t\tPath csvFilePath = Paths.get(inputPath.toString() + File.separator + JSON_FILE_NAME);\r\n+\t\t\r\n+\t\t//Requirement is spread over two rows:\r\n+\t\tList<String> csvContent = Arrays.asList(HEADER_1 + SEPERATOR + HEADER_2 + SEPERATOR + HEADER_3,\r\n+\t\t\t\tREQ_ATT_1 + SEPERATOR, REQ_ATT_2 + SEPERATOR + REQ_ATT_3);\r\n+\t\t\r\n+\t\tFiles.write(csvFilePath, csvContent);\r\n+\t\t\r\n+\t\tCsvFileReader reader = new CsvFileReader();\r\n+\t\t\r\n+\t\tList<List<String>> importedCsvContent = reader.readCsvFile(csvFilePath.toString(), 0, -1);\r\n+\t\t\r\n+\t\tassertEquals(\"Number of lines not correct\", 2, importedCsvContent.size());\r\n+\t\t\r\n+\t\tList<String> header = importedCsvContent.get(0);\r\n+\t\tassertEquals(\"Header not correct\", header.get(0), HEADER_1);\r\n+\t\tassertEquals(\"Header not correct\", header.get(1), HEADER_2);\r\n+\t\tassertEquals(\"Header not correct\", header.get(2), HEADER_3);\r\n+\t\t\r\n+\t\tList<String> reqLine = importedCsvContent.get(1);\r\n+\t\tassertEquals(\"Req att not correct\", reqLine.get(0), REQ_ATT_1);\r\n+\t\tassertEquals(\"Req att not correct\", reqLine.get(1), REQ_ATT_2);\r\n+\t\tassertEquals(\"Req att not correct\", reqLine.get(2), REQ_ATT_3);\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testReadCsvHeadline() throws IOException {\r\n+\t\t\r\n+\t\tfinal String JSON_FILE_NAME = \"dummy.csv\";\r\n+\t\tPath inputPath = Files.createTempDirectory(\"csvTest\");\r\n+\t\tPath csvFilePath = Paths.get(inputPath.toString() + File.separator + JSON_FILE_NAME);\r\n+\t\t\r\n+\t\tList<String> csvContent = Arrays.asList(HEADER_1 + SEPERATOR + HEADER_2 + SEPERATOR + HEADER_3,\r\n+\t\t\t\tREQ_ATT_1 + SEPERATOR + REQ_ATT_2 + SEPERATOR + REQ_ATT_3);\r\n+\t\t\r\n+\t\tFiles.write(csvFilePath, csvContent);\r\n+\t\t\r\n+\t\tCsvFileReader reader = new CsvFileReader(\";\", 0, 1, 2);\r\n+\t\t\r\n+\t\tList<String> importedCsvHeader = reader.readCsvHeadline(csvFilePath.toString());\r\n+\t\t\r\n+\t\tassertEquals(\"Header not correct\", importedCsvHeader.get(0), HEADER_1);\r\n+\t\tassertEquals(\"Header not correct\", importedCsvHeader.get(1), HEADER_2);\r\n+\t\tassertEquals(\"Header not correct\", importedCsvHeader.get(2), HEADER_3);\r\n+\t\t\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testReadCsvData() throws IOException {\r\n+\t\t\r\n+\t\tfinal String JSON_FILE_NAME = \"dummy.csv\";\r\n+\t\tPath inputPath = Files.createTempDirectory(\"csvTest\");\r\n+\t\tPath csvFilePath = Paths.get(inputPath.toString() + File.separator + JSON_FILE_NAME);\r\n+\t\t\r\n+\t\tList<String> csvContent = Arrays.asList(HEADER_1 + SEPERATOR + HEADER_2 + SEPERATOR + HEADER_3,\r\n+\t\t\t\tREQ_ATT_1 + SEPERATOR + REQ_ATT_2 + SEPERATOR + REQ_ATT_3);\r\n+\t\t\r\n+\t\tFiles.write(csvFilePath, csvContent);\r\n+\t\t\r\n+\t\tCsvFileReader reader = new CsvFileReader(\";\", 0, 0, 2);  //Asume header is also data for now\r\n+\t\t\r\n+\t\tList<List<String>> importedCsvContent = reader.readCsvData(csvFilePath.toString());\r\n+\t\t\r\n+\t\tList<String> header = importedCsvContent.get(0);\r\n+\t\t\r\n+\t\tassertEquals(\"Header not correct\", header.get(0), HEADER_1);\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyOTI2NA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449229264", "bodyText": "Maybe this is just github, but the newlining looks weird here.", "author": "SaMuellerDLR", "createdAt": "2020-07-02T19:37:40Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvFileReqTypeSelectionPage.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Text;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfigurationCollection;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage;\r\n+\r\n+/**\r\n+ * A page to select a CSV file to import and the target model element\r\n+ *\r\n+ */\r\n+public class CsvFileReqTypeSelectionPage extends AImportExportPage implements ModifyListener {\r\n+\r\n+\tprivate static final String[] FILE_EXTENSIONS = { \"*.csv\" };\r\n+\tprotected static final int COLUMNS = 2;\r\n+\tprotected static final int WITH_TEXT = 200;\r\n+\r\n+\tprivate static final String SPARATOR_INPUT_LABEL = \"Column sperator:\";\r\n+\tprivate static final String DEFAULT_SEPARATOR = \";\";\r\n+\r\n+\tprivate static final String HEADER_LINE_LABEL = \"CSV header line number:\";\r\n+\tprivate static final String DATA_LINE_START_LABEL = \"CSV start data line number:\";\r\n+\tprivate static final String DATA_LINE_END_LABEL = \"CSV end data line number (Optional):\";\r\n+\r\n+\tprivate Text seperatorField;\r\n+\tprivate Text headerNumberField;\r\n+\tprivate Text dataNumberStartField;\r\n+\tprivate Text dataNumberEndField;\r\n+\t\r\n+\tprivate CsvTypeReviewPage typeReviewPage;\r\n+\tprivate CsvImportWizard wizard;\r\n+\r\n+\tprotected List<String> csvHeader;\r\n+\tprotected RequirementType reqType;\r\n+\r\n+\t/**\r\n+\t * Standard constructor\r\n+\t * \r\n+\t * @param model\r\n+\t *            the root model\r\n+\t * @param containingWizard the containing wizard\r\n+\t * @param typeReviewPage\r\n+\t * \t\t\t  the page that recieves the requirement type\r\n+\t */\r\n+\tprotected CsvFileReqTypeSelectionPage(IContainer model, CsvImportWizard containingWizard, CsvTypeReviewPage typeReviewPage) {\r\n+\t\tsuper(\"Requirements CSV Import\");\r\n+\t\tsetTitle(\"Requirements CSV Import\");\r\n+\t\tsetModel(model);\r\n+\t\tthis.typeReviewPage = typeReviewPage;\r\n+\t\tthis.wizard = containingWizard;\r\n+\t\tsetDescription(\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxNTE1NQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449315155", "bodyText": "It was eclipse auto formatting... fixed it.", "author": "franzTobiasDLR", "createdAt": "2020-07-02T23:58:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyOTI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyOTQ1Mw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449229453", "bodyText": "Since the string here appears twice, maybe put it into a constant?", "author": "SaMuellerDLR", "createdAt": "2020-07-02T19:38:09Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvFileReqTypeSelectionPage.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Text;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfigurationCollection;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage;\r\n+\r\n+/**\r\n+ * A page to select a CSV file to import and the target model element\r\n+ *\r\n+ */\r\n+public class CsvFileReqTypeSelectionPage extends AImportExportPage implements ModifyListener {\r\n+\r\n+\tprivate static final String[] FILE_EXTENSIONS = { \"*.csv\" };\r\n+\tprotected static final int COLUMNS = 2;\r\n+\tprotected static final int WITH_TEXT = 200;\r\n+\r\n+\tprivate static final String SPARATOR_INPUT_LABEL = \"Column sperator:\";\r\n+\tprivate static final String DEFAULT_SEPARATOR = \";\";\r\n+\r\n+\tprivate static final String HEADER_LINE_LABEL = \"CSV header line number:\";\r\n+\tprivate static final String DATA_LINE_START_LABEL = \"CSV start data line number:\";\r\n+\tprivate static final String DATA_LINE_END_LABEL = \"CSV end data line number (Optional):\";\r\n+\r\n+\tprivate Text seperatorField;\r\n+\tprivate Text headerNumberField;\r\n+\tprivate Text dataNumberStartField;\r\n+\tprivate Text dataNumberEndField;\r\n+\t\r\n+\tprivate CsvTypeReviewPage typeReviewPage;\r\n+\tprivate CsvImportWizard wizard;\r\n+\r\n+\tprotected List<String> csvHeader;\r\n+\tprotected RequirementType reqType;\r\n+\r\n+\t/**\r\n+\t * Standard constructor\r\n+\t * \r\n+\t * @param model\r\n+\t *            the root model\r\n+\t * @param containingWizard the containing wizard\r\n+\t * @param typeReviewPage\r\n+\t * \t\t\t  the page that recieves the requirement type\r\n+\t */\r\n+\tprotected CsvFileReqTypeSelectionPage(IContainer model, CsvImportWizard containingWizard, CsvTypeReviewPage typeReviewPage) {\r\n+\t\tsuper(\"Requirements CSV Import\");\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzMDcwMA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449230700", "bodyText": "We could improve the readability here. I propose something like:\nString categoryFqn = ((CategoryAssignment) selection).getType().getFullQualifiedName();\nreturn categoryFqn.equals(RequirementsConfiguration.FULL_QUALIFIED_CATEGORY_NAME) \n        || ategoryFqn.equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME)", "author": "SaMuellerDLR", "createdAt": "2020-07-02T19:41:11Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvFileReqTypeSelectionPage.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Text;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfigurationCollection;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage;\r\n+\r\n+/**\r\n+ * A page to select a CSV file to import and the target model element\r\n+ *\r\n+ */\r\n+public class CsvFileReqTypeSelectionPage extends AImportExportPage implements ModifyListener {\r\n+\r\n+\tprivate static final String[] FILE_EXTENSIONS = { \"*.csv\" };\r\n+\tprotected static final int COLUMNS = 2;\r\n+\tprotected static final int WITH_TEXT = 200;\r\n+\r\n+\tprivate static final String SPARATOR_INPUT_LABEL = \"Column sperator:\";\r\n+\tprivate static final String DEFAULT_SEPARATOR = \";\";\r\n+\r\n+\tprivate static final String HEADER_LINE_LABEL = \"CSV header line number:\";\r\n+\tprivate static final String DATA_LINE_START_LABEL = \"CSV start data line number:\";\r\n+\tprivate static final String DATA_LINE_END_LABEL = \"CSV end data line number (Optional):\";\r\n+\r\n+\tprivate Text seperatorField;\r\n+\tprivate Text headerNumberField;\r\n+\tprivate Text dataNumberStartField;\r\n+\tprivate Text dataNumberEndField;\r\n+\t\r\n+\tprivate CsvTypeReviewPage typeReviewPage;\r\n+\tprivate CsvImportWizard wizard;\r\n+\r\n+\tprotected List<String> csvHeader;\r\n+\tprotected RequirementType reqType;\r\n+\r\n+\t/**\r\n+\t * Standard constructor\r\n+\t * \r\n+\t * @param model\r\n+\t *            the root model\r\n+\t * @param containingWizard the containing wizard\r\n+\t * @param typeReviewPage\r\n+\t * \t\t\t  the page that recieves the requirement type\r\n+\t */\r\n+\tprotected CsvFileReqTypeSelectionPage(IContainer model, CsvImportWizard containingWizard, CsvTypeReviewPage typeReviewPage) {\r\n+\t\tsuper(\"Requirements CSV Import\");\r\n+\t\tsetTitle(\"Requirements CSV Import\");\r\n+\t\tsetModel(model);\r\n+\t\tthis.typeReviewPage = typeReviewPage;\r\n+\t\tthis.wizard = containingWizard;\r\n+\t\tsetDescription(\r\n+\t\t\t\t\"Please select a CSV file and a requirement type for the imported requirements. To create a new type, select a container configuration.\");\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\t\tsuper.createControl(parent);\r\n+\r\n+\t\tcreateFileDestinationUI();\r\n+\t\tcreateCsvPropertiesUI(parent);\r\n+\r\n+\t\tcreateTreeViewer();\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create the UI for CSV properties\r\n+\t * \r\n+\t * @param parent\r\n+\t *            the parent composite\r\n+\t */\r\n+\tprivate void createCsvPropertiesUI(Composite parent) {\r\n+\t\tComposite propertiesComposite = new Composite((Composite) getControl(), SWT.FILL);\r\n+\t\tpropertiesComposite.setLayout(new GridLayout(COLUMNS, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tpropertiesComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabel.setText(SPARATOR_INPUT_LABEL);\r\n+\r\n+\t\tseperatorField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tseperatorField.setLayoutData(data);\r\n+\t\tseperatorField.setText(DEFAULT_SEPARATOR);\r\n+\t\tseperatorField.addModifyListener(this);\r\n+\r\n+\t\tLabel labelHeaderNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelHeaderNumber.setText(HEADER_LINE_LABEL);\r\n+\r\n+\t\theaderNumberField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\theaderNumberField.setLayoutData(data);\r\n+\t\theaderNumberField.addModifyListener(this);\r\n+\t\theaderNumberField.setText(\"1\");\r\n+\r\n+\t\tLabel labelDataNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataNumber.setText(DATA_LINE_START_LABEL);\r\n+\r\n+\t\tdataNumberStartField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberStartField.setLayoutData(data);\r\n+\t\tdataNumberStartField.addModifyListener(this);\r\n+\t\tdataNumberStartField.setText(\"2\");\r\n+\t\t\r\n+\t\tLabel labelDataEndNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataEndNumber.setText(DATA_LINE_END_LABEL);\r\n+\r\n+\t\tdataNumberEndField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberEndField.setLayoutData(data);\r\n+\t\tdataNumberEndField.addModifyListener(this);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a tree viewer with filters to show only relevant tree elements for\r\n+\t * CSV import /export\r\n+\t */\r\n+\tprotected void createTreeViewer() {\r\n+\t\tTreeViewer treeViewer = createTreeUI();\r\n+\t\tVirSatFilteredWrappedTreeContentProvider filteredCp = (VirSatFilteredWrappedTreeContentProvider) treeViewer\r\n+\t\t\t\t.getContentProvider();\r\n+\t\tfilteredCp.addClassFilter(CategoryAssignment.class);\r\n+\t\tfilteredCp.addClassFilter(ArrayInstance.class);\r\n+\t\tfilteredCp.addClassFilter(ComposedPropertyInstance.class);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(\r\n+\t\t\t\tRequirementsConfigurationCollection.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic boolean isSelectionValid() {\r\n+\t\tObject selection = getSelection();\r\n+\t\tif (selection instanceof CategoryAssignment) {\r\n+\t\t\treturn ((CategoryAssignment) selection).getType().getFullQualifiedName()\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzMTI5Mg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449231292", "bodyText": "Why do we need to access the destination before the isSelectionValid() check?", "author": "SaMuellerDLR", "createdAt": "2020-07-02T19:42:33Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvFileReqTypeSelectionPage.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Text;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfigurationCollection;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage;\r\n+\r\n+/**\r\n+ * A page to select a CSV file to import and the target model element\r\n+ *\r\n+ */\r\n+public class CsvFileReqTypeSelectionPage extends AImportExportPage implements ModifyListener {\r\n+\r\n+\tprivate static final String[] FILE_EXTENSIONS = { \"*.csv\" };\r\n+\tprotected static final int COLUMNS = 2;\r\n+\tprotected static final int WITH_TEXT = 200;\r\n+\r\n+\tprivate static final String SPARATOR_INPUT_LABEL = \"Column sperator:\";\r\n+\tprivate static final String DEFAULT_SEPARATOR = \";\";\r\n+\r\n+\tprivate static final String HEADER_LINE_LABEL = \"CSV header line number:\";\r\n+\tprivate static final String DATA_LINE_START_LABEL = \"CSV start data line number:\";\r\n+\tprivate static final String DATA_LINE_END_LABEL = \"CSV end data line number (Optional):\";\r\n+\r\n+\tprivate Text seperatorField;\r\n+\tprivate Text headerNumberField;\r\n+\tprivate Text dataNumberStartField;\r\n+\tprivate Text dataNumberEndField;\r\n+\t\r\n+\tprivate CsvTypeReviewPage typeReviewPage;\r\n+\tprivate CsvImportWizard wizard;\r\n+\r\n+\tprotected List<String> csvHeader;\r\n+\tprotected RequirementType reqType;\r\n+\r\n+\t/**\r\n+\t * Standard constructor\r\n+\t * \r\n+\t * @param model\r\n+\t *            the root model\r\n+\t * @param containingWizard the containing wizard\r\n+\t * @param typeReviewPage\r\n+\t * \t\t\t  the page that recieves the requirement type\r\n+\t */\r\n+\tprotected CsvFileReqTypeSelectionPage(IContainer model, CsvImportWizard containingWizard, CsvTypeReviewPage typeReviewPage) {\r\n+\t\tsuper(\"Requirements CSV Import\");\r\n+\t\tsetTitle(\"Requirements CSV Import\");\r\n+\t\tsetModel(model);\r\n+\t\tthis.typeReviewPage = typeReviewPage;\r\n+\t\tthis.wizard = containingWizard;\r\n+\t\tsetDescription(\r\n+\t\t\t\t\"Please select a CSV file and a requirement type for the imported requirements. To create a new type, select a container configuration.\");\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\t\tsuper.createControl(parent);\r\n+\r\n+\t\tcreateFileDestinationUI();\r\n+\t\tcreateCsvPropertiesUI(parent);\r\n+\r\n+\t\tcreateTreeViewer();\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create the UI for CSV properties\r\n+\t * \r\n+\t * @param parent\r\n+\t *            the parent composite\r\n+\t */\r\n+\tprivate void createCsvPropertiesUI(Composite parent) {\r\n+\t\tComposite propertiesComposite = new Composite((Composite) getControl(), SWT.FILL);\r\n+\t\tpropertiesComposite.setLayout(new GridLayout(COLUMNS, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tpropertiesComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabel.setText(SPARATOR_INPUT_LABEL);\r\n+\r\n+\t\tseperatorField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tseperatorField.setLayoutData(data);\r\n+\t\tseperatorField.setText(DEFAULT_SEPARATOR);\r\n+\t\tseperatorField.addModifyListener(this);\r\n+\r\n+\t\tLabel labelHeaderNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelHeaderNumber.setText(HEADER_LINE_LABEL);\r\n+\r\n+\t\theaderNumberField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\theaderNumberField.setLayoutData(data);\r\n+\t\theaderNumberField.addModifyListener(this);\r\n+\t\theaderNumberField.setText(\"1\");\r\n+\r\n+\t\tLabel labelDataNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataNumber.setText(DATA_LINE_START_LABEL);\r\n+\r\n+\t\tdataNumberStartField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberStartField.setLayoutData(data);\r\n+\t\tdataNumberStartField.addModifyListener(this);\r\n+\t\tdataNumberStartField.setText(\"2\");\r\n+\t\t\r\n+\t\tLabel labelDataEndNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataEndNumber.setText(DATA_LINE_END_LABEL);\r\n+\r\n+\t\tdataNumberEndField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberEndField.setLayoutData(data);\r\n+\t\tdataNumberEndField.addModifyListener(this);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a tree viewer with filters to show only relevant tree elements for\r\n+\t * CSV import /export\r\n+\t */\r\n+\tprotected void createTreeViewer() {\r\n+\t\tTreeViewer treeViewer = createTreeUI();\r\n+\t\tVirSatFilteredWrappedTreeContentProvider filteredCp = (VirSatFilteredWrappedTreeContentProvider) treeViewer\r\n+\t\t\t\t.getContentProvider();\r\n+\t\tfilteredCp.addClassFilter(CategoryAssignment.class);\r\n+\t\tfilteredCp.addClassFilter(ArrayInstance.class);\r\n+\t\tfilteredCp.addClassFilter(ComposedPropertyInstance.class);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(\r\n+\t\t\t\tRequirementsConfigurationCollection.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic boolean isSelectionValid() {\r\n+\t\tObject selection = getSelection();\r\n+\t\tif (selection instanceof CategoryAssignment) {\r\n+\t\t\treturn ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t.equals(RequirementsConfiguration.FULL_QUALIFIED_CATEGORY_NAME)\r\n+\t\t\t\t\t|| ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t\t\t.equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME);\r\n+\t\t}\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tprotected String[] getSupportedFileEndings() {\r\n+\t\treturn FILE_EXTENSIONS;\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage#isComplete()\r\n+\t */\r\n+\t@Override\r\n+\tpublic boolean isComplete() {\r\n+\r\n+\t\tif (isDestinationSelected && isCurrentPage()) {\r\n+\t\t\tif (!headerNumberField.getText().equals(\"\") & !seperatorField.getText().equals(\"\") \r\n+\t\t\t\t& !dataNumberStartField.getText().equals(\"\")) {\r\n+\r\n+\t\t\t\tfinal String destination = getDestination();\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzMTU1OA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449231558", "bodyText": "Looks like some copy & paste.", "author": "SaMuellerDLR", "createdAt": "2020-07-02T19:43:13Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvFileReqTypeSelectionPage.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Text;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfigurationCollection;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage;\r\n+\r\n+/**\r\n+ * A page to select a CSV file to import and the target model element\r\n+ *\r\n+ */\r\n+public class CsvFileReqTypeSelectionPage extends AImportExportPage implements ModifyListener {\r\n+\r\n+\tprivate static final String[] FILE_EXTENSIONS = { \"*.csv\" };\r\n+\tprotected static final int COLUMNS = 2;\r\n+\tprotected static final int WITH_TEXT = 200;\r\n+\r\n+\tprivate static final String SPARATOR_INPUT_LABEL = \"Column sperator:\";\r\n+\tprivate static final String DEFAULT_SEPARATOR = \";\";\r\n+\r\n+\tprivate static final String HEADER_LINE_LABEL = \"CSV header line number:\";\r\n+\tprivate static final String DATA_LINE_START_LABEL = \"CSV start data line number:\";\r\n+\tprivate static final String DATA_LINE_END_LABEL = \"CSV end data line number (Optional):\";\r\n+\r\n+\tprivate Text seperatorField;\r\n+\tprivate Text headerNumberField;\r\n+\tprivate Text dataNumberStartField;\r\n+\tprivate Text dataNumberEndField;\r\n+\t\r\n+\tprivate CsvTypeReviewPage typeReviewPage;\r\n+\tprivate CsvImportWizard wizard;\r\n+\r\n+\tprotected List<String> csvHeader;\r\n+\tprotected RequirementType reqType;\r\n+\r\n+\t/**\r\n+\t * Standard constructor\r\n+\t * \r\n+\t * @param model\r\n+\t *            the root model\r\n+\t * @param containingWizard the containing wizard\r\n+\t * @param typeReviewPage\r\n+\t * \t\t\t  the page that recieves the requirement type\r\n+\t */\r\n+\tprotected CsvFileReqTypeSelectionPage(IContainer model, CsvImportWizard containingWizard, CsvTypeReviewPage typeReviewPage) {\r\n+\t\tsuper(\"Requirements CSV Import\");\r\n+\t\tsetTitle(\"Requirements CSV Import\");\r\n+\t\tsetModel(model);\r\n+\t\tthis.typeReviewPage = typeReviewPage;\r\n+\t\tthis.wizard = containingWizard;\r\n+\t\tsetDescription(\r\n+\t\t\t\t\"Please select a CSV file and a requirement type for the imported requirements. To create a new type, select a container configuration.\");\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\t\tsuper.createControl(parent);\r\n+\r\n+\t\tcreateFileDestinationUI();\r\n+\t\tcreateCsvPropertiesUI(parent);\r\n+\r\n+\t\tcreateTreeViewer();\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create the UI for CSV properties\r\n+\t * \r\n+\t * @param parent\r\n+\t *            the parent composite\r\n+\t */\r\n+\tprivate void createCsvPropertiesUI(Composite parent) {\r\n+\t\tComposite propertiesComposite = new Composite((Composite) getControl(), SWT.FILL);\r\n+\t\tpropertiesComposite.setLayout(new GridLayout(COLUMNS, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tpropertiesComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabel.setText(SPARATOR_INPUT_LABEL);\r\n+\r\n+\t\tseperatorField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tseperatorField.setLayoutData(data);\r\n+\t\tseperatorField.setText(DEFAULT_SEPARATOR);\r\n+\t\tseperatorField.addModifyListener(this);\r\n+\r\n+\t\tLabel labelHeaderNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelHeaderNumber.setText(HEADER_LINE_LABEL);\r\n+\r\n+\t\theaderNumberField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\theaderNumberField.setLayoutData(data);\r\n+\t\theaderNumberField.addModifyListener(this);\r\n+\t\theaderNumberField.setText(\"1\");\r\n+\r\n+\t\tLabel labelDataNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataNumber.setText(DATA_LINE_START_LABEL);\r\n+\r\n+\t\tdataNumberStartField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberStartField.setLayoutData(data);\r\n+\t\tdataNumberStartField.addModifyListener(this);\r\n+\t\tdataNumberStartField.setText(\"2\");\r\n+\t\t\r\n+\t\tLabel labelDataEndNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataEndNumber.setText(DATA_LINE_END_LABEL);\r\n+\r\n+\t\tdataNumberEndField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberEndField.setLayoutData(data);\r\n+\t\tdataNumberEndField.addModifyListener(this);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a tree viewer with filters to show only relevant tree elements for\r\n+\t * CSV import /export\r\n+\t */\r\n+\tprotected void createTreeViewer() {\r\n+\t\tTreeViewer treeViewer = createTreeUI();\r\n+\t\tVirSatFilteredWrappedTreeContentProvider filteredCp = (VirSatFilteredWrappedTreeContentProvider) treeViewer\r\n+\t\t\t\t.getContentProvider();\r\n+\t\tfilteredCp.addClassFilter(CategoryAssignment.class);\r\n+\t\tfilteredCp.addClassFilter(ArrayInstance.class);\r\n+\t\tfilteredCp.addClassFilter(ComposedPropertyInstance.class);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(\r\n+\t\t\t\tRequirementsConfigurationCollection.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic boolean isSelectionValid() {\r\n+\t\tObject selection = getSelection();\r\n+\t\tif (selection instanceof CategoryAssignment) {\r\n+\t\t\treturn ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t.equals(RequirementsConfiguration.FULL_QUALIFIED_CATEGORY_NAME)\r\n+\t\t\t\t\t|| ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t\t\t.equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME);\r\n+\t\t}\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tprotected String[] getSupportedFileEndings() {\r\n+\t\treturn FILE_EXTENSIONS;\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage#isComplete()\r\n+\t */\r\n+\t@Override\r\n+\tpublic boolean isComplete() {\r\n+\r\n+\t\tif (isDestinationSelected && isCurrentPage()) {\r\n+\t\t\tif (!headerNumberField.getText().equals(\"\") & !seperatorField.getText().equals(\"\") \r\n+\t\t\t\t& !dataNumberStartField.getText().equals(\"\")) {\r\n+\r\n+\t\t\t\tfinal String destination = getDestination();\r\n+\t\r\n+\t\t\t\tif (isSelectionValid()) {\r\n+\t\t\t\t\tCategoryAssignment selection = (CategoryAssignment) getSelection();\r\n+\t\t\t\t\tRepository repository = VirSatResourceSet.getVirSatResourceSet(selection).getRepository();\r\n+\t\t\t\t\tActiveConceptHelper activeConceptHelper = new ActiveConceptHelper(repository);\r\n+\t\t\t\t\tConcept activeReqConcept = activeConceptHelper.getConcept(de.dlr.sc.virsat.model.extension.requirements.Activator.getPluginId());\r\n+\t\t\t\r\n+\t\t\t\t\ttry {\r\n+\t\t\t\t\t\twizard.getReader().setSeparator(getSeparator());\r\n+\t\t\t\t\t\twizard.getReader().setHeaderLine(getHeaderLineNumber());\r\n+\t\t\t\t\t\tcsvHeader = wizard.getReader().readCsvHeadline(destination);\r\n+\t\t\t\t\t} catch (IOException e) {\r\n+\t\t\t\t\t\tStatus status = new Status(Status.ERROR, Activator.getPluginId(),\r\n+\t\t\t\t\t\t\t\t\"CatiaImportWizard: Failed to perform import! Selected file not valid!\", e);\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzMTkyNw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449231927", "bodyText": "Is it really alright that we have the try catch on this level? If we get an error here, how we can still return true?", "author": "SaMuellerDLR", "createdAt": "2020-07-02T19:44:08Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvFileReqTypeSelectionPage.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Text;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfigurationCollection;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage;\r\n+\r\n+/**\r\n+ * A page to select a CSV file to import and the target model element\r\n+ *\r\n+ */\r\n+public class CsvFileReqTypeSelectionPage extends AImportExportPage implements ModifyListener {\r\n+\r\n+\tprivate static final String[] FILE_EXTENSIONS = { \"*.csv\" };\r\n+\tprotected static final int COLUMNS = 2;\r\n+\tprotected static final int WITH_TEXT = 200;\r\n+\r\n+\tprivate static final String SPARATOR_INPUT_LABEL = \"Column sperator:\";\r\n+\tprivate static final String DEFAULT_SEPARATOR = \";\";\r\n+\r\n+\tprivate static final String HEADER_LINE_LABEL = \"CSV header line number:\";\r\n+\tprivate static final String DATA_LINE_START_LABEL = \"CSV start data line number:\";\r\n+\tprivate static final String DATA_LINE_END_LABEL = \"CSV end data line number (Optional):\";\r\n+\r\n+\tprivate Text seperatorField;\r\n+\tprivate Text headerNumberField;\r\n+\tprivate Text dataNumberStartField;\r\n+\tprivate Text dataNumberEndField;\r\n+\t\r\n+\tprivate CsvTypeReviewPage typeReviewPage;\r\n+\tprivate CsvImportWizard wizard;\r\n+\r\n+\tprotected List<String> csvHeader;\r\n+\tprotected RequirementType reqType;\r\n+\r\n+\t/**\r\n+\t * Standard constructor\r\n+\t * \r\n+\t * @param model\r\n+\t *            the root model\r\n+\t * @param containingWizard the containing wizard\r\n+\t * @param typeReviewPage\r\n+\t * \t\t\t  the page that recieves the requirement type\r\n+\t */\r\n+\tprotected CsvFileReqTypeSelectionPage(IContainer model, CsvImportWizard containingWizard, CsvTypeReviewPage typeReviewPage) {\r\n+\t\tsuper(\"Requirements CSV Import\");\r\n+\t\tsetTitle(\"Requirements CSV Import\");\r\n+\t\tsetModel(model);\r\n+\t\tthis.typeReviewPage = typeReviewPage;\r\n+\t\tthis.wizard = containingWizard;\r\n+\t\tsetDescription(\r\n+\t\t\t\t\"Please select a CSV file and a requirement type for the imported requirements. To create a new type, select a container configuration.\");\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\t\tsuper.createControl(parent);\r\n+\r\n+\t\tcreateFileDestinationUI();\r\n+\t\tcreateCsvPropertiesUI(parent);\r\n+\r\n+\t\tcreateTreeViewer();\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create the UI for CSV properties\r\n+\t * \r\n+\t * @param parent\r\n+\t *            the parent composite\r\n+\t */\r\n+\tprivate void createCsvPropertiesUI(Composite parent) {\r\n+\t\tComposite propertiesComposite = new Composite((Composite) getControl(), SWT.FILL);\r\n+\t\tpropertiesComposite.setLayout(new GridLayout(COLUMNS, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tpropertiesComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabel.setText(SPARATOR_INPUT_LABEL);\r\n+\r\n+\t\tseperatorField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tseperatorField.setLayoutData(data);\r\n+\t\tseperatorField.setText(DEFAULT_SEPARATOR);\r\n+\t\tseperatorField.addModifyListener(this);\r\n+\r\n+\t\tLabel labelHeaderNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelHeaderNumber.setText(HEADER_LINE_LABEL);\r\n+\r\n+\t\theaderNumberField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\theaderNumberField.setLayoutData(data);\r\n+\t\theaderNumberField.addModifyListener(this);\r\n+\t\theaderNumberField.setText(\"1\");\r\n+\r\n+\t\tLabel labelDataNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataNumber.setText(DATA_LINE_START_LABEL);\r\n+\r\n+\t\tdataNumberStartField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberStartField.setLayoutData(data);\r\n+\t\tdataNumberStartField.addModifyListener(this);\r\n+\t\tdataNumberStartField.setText(\"2\");\r\n+\t\t\r\n+\t\tLabel labelDataEndNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataEndNumber.setText(DATA_LINE_END_LABEL);\r\n+\r\n+\t\tdataNumberEndField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberEndField.setLayoutData(data);\r\n+\t\tdataNumberEndField.addModifyListener(this);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a tree viewer with filters to show only relevant tree elements for\r\n+\t * CSV import /export\r\n+\t */\r\n+\tprotected void createTreeViewer() {\r\n+\t\tTreeViewer treeViewer = createTreeUI();\r\n+\t\tVirSatFilteredWrappedTreeContentProvider filteredCp = (VirSatFilteredWrappedTreeContentProvider) treeViewer\r\n+\t\t\t\t.getContentProvider();\r\n+\t\tfilteredCp.addClassFilter(CategoryAssignment.class);\r\n+\t\tfilteredCp.addClassFilter(ArrayInstance.class);\r\n+\t\tfilteredCp.addClassFilter(ComposedPropertyInstance.class);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(\r\n+\t\t\t\tRequirementsConfigurationCollection.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic boolean isSelectionValid() {\r\n+\t\tObject selection = getSelection();\r\n+\t\tif (selection instanceof CategoryAssignment) {\r\n+\t\t\treturn ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t.equals(RequirementsConfiguration.FULL_QUALIFIED_CATEGORY_NAME)\r\n+\t\t\t\t\t|| ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t\t\t.equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME);\r\n+\t\t}\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tprotected String[] getSupportedFileEndings() {\r\n+\t\treturn FILE_EXTENSIONS;\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage#isComplete()\r\n+\t */\r\n+\t@Override\r\n+\tpublic boolean isComplete() {\r\n+\r\n+\t\tif (isDestinationSelected && isCurrentPage()) {\r\n+\t\t\tif (!headerNumberField.getText().equals(\"\") & !seperatorField.getText().equals(\"\") \r\n+\t\t\t\t& !dataNumberStartField.getText().equals(\"\")) {\r\n+\r\n+\t\t\t\tfinal String destination = getDestination();\r\n+\t\r\n+\t\t\t\tif (isSelectionValid()) {\r\n+\t\t\t\t\tCategoryAssignment selection = (CategoryAssignment) getSelection();\r\n+\t\t\t\t\tRepository repository = VirSatResourceSet.getVirSatResourceSet(selection).getRepository();\r\n+\t\t\t\t\tActiveConceptHelper activeConceptHelper = new ActiveConceptHelper(repository);\r\n+\t\t\t\t\tConcept activeReqConcept = activeConceptHelper.getConcept(de.dlr.sc.virsat.model.extension.requirements.Activator.getPluginId());\r\n+\t\t\t\r\n+\t\t\t\t\ttry {\r\n+\t\t\t\t\t\twizard.getReader().setSeparator(getSeparator());\r\n+\t\t\t\t\t\twizard.getReader().setHeaderLine(getHeaderLineNumber());\r\n+\t\t\t\t\t\tcsvHeader = wizard.getReader().readCsvHeadline(destination);\r\n+\t\t\t\t\t} catch (IOException e) {\r\n+\t\t\t\t\t\tStatus status = new Status(Status.ERROR, Activator.getPluginId(),\r\n+\t\t\t\t\t\t\t\t\"CatiaImportWizard: Failed to perform import! Selected file not valid!\", e);\r\n+\t\t\t\t\t\tStatusManager.getManager().handle(status, StatusManager.LOG | StatusManager.SHOW);\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxNzUwOQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449317509", "bodyText": "I'm now returning false in case of a catched exception.", "author": "franzTobiasDLR", "createdAt": "2020-07-03T00:09:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzMTkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzMzk4Mw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449233983", "bodyText": "Can be simplified similar to the above.", "author": "SaMuellerDLR", "createdAt": "2020-07-02T19:49:02Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvFileReqTypeSelectionPage.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Text;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfigurationCollection;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage;\r\n+\r\n+/**\r\n+ * A page to select a CSV file to import and the target model element\r\n+ *\r\n+ */\r\n+public class CsvFileReqTypeSelectionPage extends AImportExportPage implements ModifyListener {\r\n+\r\n+\tprivate static final String[] FILE_EXTENSIONS = { \"*.csv\" };\r\n+\tprotected static final int COLUMNS = 2;\r\n+\tprotected static final int WITH_TEXT = 200;\r\n+\r\n+\tprivate static final String SPARATOR_INPUT_LABEL = \"Column sperator:\";\r\n+\tprivate static final String DEFAULT_SEPARATOR = \";\";\r\n+\r\n+\tprivate static final String HEADER_LINE_LABEL = \"CSV header line number:\";\r\n+\tprivate static final String DATA_LINE_START_LABEL = \"CSV start data line number:\";\r\n+\tprivate static final String DATA_LINE_END_LABEL = \"CSV end data line number (Optional):\";\r\n+\r\n+\tprivate Text seperatorField;\r\n+\tprivate Text headerNumberField;\r\n+\tprivate Text dataNumberStartField;\r\n+\tprivate Text dataNumberEndField;\r\n+\t\r\n+\tprivate CsvTypeReviewPage typeReviewPage;\r\n+\tprivate CsvImportWizard wizard;\r\n+\r\n+\tprotected List<String> csvHeader;\r\n+\tprotected RequirementType reqType;\r\n+\r\n+\t/**\r\n+\t * Standard constructor\r\n+\t * \r\n+\t * @param model\r\n+\t *            the root model\r\n+\t * @param containingWizard the containing wizard\r\n+\t * @param typeReviewPage\r\n+\t * \t\t\t  the page that recieves the requirement type\r\n+\t */\r\n+\tprotected CsvFileReqTypeSelectionPage(IContainer model, CsvImportWizard containingWizard, CsvTypeReviewPage typeReviewPage) {\r\n+\t\tsuper(\"Requirements CSV Import\");\r\n+\t\tsetTitle(\"Requirements CSV Import\");\r\n+\t\tsetModel(model);\r\n+\t\tthis.typeReviewPage = typeReviewPage;\r\n+\t\tthis.wizard = containingWizard;\r\n+\t\tsetDescription(\r\n+\t\t\t\t\"Please select a CSV file and a requirement type for the imported requirements. To create a new type, select a container configuration.\");\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\t\tsuper.createControl(parent);\r\n+\r\n+\t\tcreateFileDestinationUI();\r\n+\t\tcreateCsvPropertiesUI(parent);\r\n+\r\n+\t\tcreateTreeViewer();\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create the UI for CSV properties\r\n+\t * \r\n+\t * @param parent\r\n+\t *            the parent composite\r\n+\t */\r\n+\tprivate void createCsvPropertiesUI(Composite parent) {\r\n+\t\tComposite propertiesComposite = new Composite((Composite) getControl(), SWT.FILL);\r\n+\t\tpropertiesComposite.setLayout(new GridLayout(COLUMNS, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tpropertiesComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabel.setText(SPARATOR_INPUT_LABEL);\r\n+\r\n+\t\tseperatorField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tseperatorField.setLayoutData(data);\r\n+\t\tseperatorField.setText(DEFAULT_SEPARATOR);\r\n+\t\tseperatorField.addModifyListener(this);\r\n+\r\n+\t\tLabel labelHeaderNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelHeaderNumber.setText(HEADER_LINE_LABEL);\r\n+\r\n+\t\theaderNumberField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\theaderNumberField.setLayoutData(data);\r\n+\t\theaderNumberField.addModifyListener(this);\r\n+\t\theaderNumberField.setText(\"1\");\r\n+\r\n+\t\tLabel labelDataNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataNumber.setText(DATA_LINE_START_LABEL);\r\n+\r\n+\t\tdataNumberStartField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberStartField.setLayoutData(data);\r\n+\t\tdataNumberStartField.addModifyListener(this);\r\n+\t\tdataNumberStartField.setText(\"2\");\r\n+\t\t\r\n+\t\tLabel labelDataEndNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataEndNumber.setText(DATA_LINE_END_LABEL);\r\n+\r\n+\t\tdataNumberEndField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberEndField.setLayoutData(data);\r\n+\t\tdataNumberEndField.addModifyListener(this);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a tree viewer with filters to show only relevant tree elements for\r\n+\t * CSV import /export\r\n+\t */\r\n+\tprotected void createTreeViewer() {\r\n+\t\tTreeViewer treeViewer = createTreeUI();\r\n+\t\tVirSatFilteredWrappedTreeContentProvider filteredCp = (VirSatFilteredWrappedTreeContentProvider) treeViewer\r\n+\t\t\t\t.getContentProvider();\r\n+\t\tfilteredCp.addClassFilter(CategoryAssignment.class);\r\n+\t\tfilteredCp.addClassFilter(ArrayInstance.class);\r\n+\t\tfilteredCp.addClassFilter(ComposedPropertyInstance.class);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(\r\n+\t\t\t\tRequirementsConfigurationCollection.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic boolean isSelectionValid() {\r\n+\t\tObject selection = getSelection();\r\n+\t\tif (selection instanceof CategoryAssignment) {\r\n+\t\t\treturn ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t.equals(RequirementsConfiguration.FULL_QUALIFIED_CATEGORY_NAME)\r\n+\t\t\t\t\t|| ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t\t\t.equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME);\r\n+\t\t}\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tprotected String[] getSupportedFileEndings() {\r\n+\t\treturn FILE_EXTENSIONS;\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage#isComplete()\r\n+\t */\r\n+\t@Override\r\n+\tpublic boolean isComplete() {\r\n+\r\n+\t\tif (isDestinationSelected && isCurrentPage()) {\r\n+\t\t\tif (!headerNumberField.getText().equals(\"\") & !seperatorField.getText().equals(\"\") \r\n+\t\t\t\t& !dataNumberStartField.getText().equals(\"\")) {\r\n+\r\n+\t\t\t\tfinal String destination = getDestination();\r\n+\t\r\n+\t\t\t\tif (isSelectionValid()) {\r\n+\t\t\t\t\tCategoryAssignment selection = (CategoryAssignment) getSelection();\r\n+\t\t\t\t\tRepository repository = VirSatResourceSet.getVirSatResourceSet(selection).getRepository();\r\n+\t\t\t\t\tActiveConceptHelper activeConceptHelper = new ActiveConceptHelper(repository);\r\n+\t\t\t\t\tConcept activeReqConcept = activeConceptHelper.getConcept(de.dlr.sc.virsat.model.extension.requirements.Activator.getPluginId());\r\n+\t\t\t\r\n+\t\t\t\t\ttry {\r\n+\t\t\t\t\t\twizard.getReader().setSeparator(getSeparator());\r\n+\t\t\t\t\t\twizard.getReader().setHeaderLine(getHeaderLineNumber());\r\n+\t\t\t\t\t\tcsvHeader = wizard.getReader().readCsvHeadline(destination);\r\n+\t\t\t\t\t} catch (IOException e) {\r\n+\t\t\t\t\t\tStatus status = new Status(Status.ERROR, Activator.getPluginId(),\r\n+\t\t\t\t\t\t\t\t\"CatiaImportWizard: Failed to perform import! Selected file not valid!\", e);\r\n+\t\t\t\t\t\tStatusManager.getManager().handle(status, StatusManager.LOG | StatusManager.SHOW);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tif (selection.getType().getFullQualifiedName().equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME)) {\r\n+\t\t\t\t\t\ttypeReviewPage.setInput(csvHeader, new RequirementType(selection));\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\tif (selection.getType().getFullQualifiedName().equals(RequirementsConfiguration.FULL_QUALIFIED_CATEGORY_NAME)) {\r\n+\t\t\t\t\t\treqType = wizard.getImporter().prepareRequirementType(activeReqConcept, csvHeader);\r\n+\t\t\t\t\t\ttypeReviewPage.setInput(csvHeader, reqType);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\t\treturn true;\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t}\r\n+\t\t}\r\n+\r\n+\t\treturn false;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Get the CSV separator\r\n+\t * @return the separator string\r\n+\t */\r\n+\tpublic String getSeparator() {\r\n+\t\treturn seperatorField.getText();\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Get the line number of the header\r\n+\t * @return the integer header line number\r\n+\t */\r\n+\tpublic int getHeaderLineNumber() {\r\n+\t\treturn Integer.parseInt(headerNumberField.getText()) - 1;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Get the line number of the first data\r\n+\t * @return the line number as integer\r\n+\t */\r\n+\tpublic int getFristDataLineNumber() {\r\n+\t\treturn Integer.parseInt(dataNumberStartField.getText()) - 1;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Get the line number of the first data\r\n+\t * @return the line number as integer\r\n+\t */\r\n+\tpublic int getLastDataLineNumber() {\r\n+\t\tString value = dataNumberEndField.getText();\r\n+\t\tif (value.equals(\"\")) {\r\n+\t\t\treturn -1;\r\n+\t\t} else {\r\n+\t\t\treturn Integer.parseInt(value) - 1;\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see de.dlr.sc.virsat.uiengine.ui.wizard.ATreeViewerPage#getSelection()\r\n+\t */\r\n+\t@Override\r\n+\tpublic Object getSelection() {\r\n+\t\tObject selected = super.getSelection();\r\n+\t\tif (selected instanceof ComposedPropertyInstance) {\r\n+\t\t\tselected = ((ComposedPropertyInstance) selected).getTypeInstance();\r\n+\t\t}\r\n+\t\treturn selected;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Get the selected requirement type \r\n+\t * @return the requirement type for import\r\n+\t */\r\n+\tpublic RequirementType getRequirementsImportType() {\r\n+\t\tObject selection = getSelection();\r\n+\t\tif (selection instanceof CategoryAssignment) {\r\n+\t\t\tif (((CategoryAssignment) selection).getType().getFullQualifiedName()\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzNTQxNg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449235416", "bodyText": "Weird newlining", "author": "SaMuellerDLR", "createdAt": "2020-07-02T19:52:28Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvImportTargetSelectionPage.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.AssemblyTree;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.ConfigurationTree;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.ElementConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.ElementOccurence;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementGroup;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsSpecification;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.ATreeViewerPage;\r\n+\r\n+/**\r\n+ * A page to select a requirement type for imported requirements\r\n+ *\r\n+ */\r\n+public class CsvImportTargetSelectionPage extends ATreeViewerPage {\r\n+\r\n+\t/**\r\n+\t * Default constructor\r\n+\t * @param model the model\r\n+\t */\r\n+\tprotected CsvImportTargetSelectionPage(IContainer model) {\r\n+\t\tsuper(\"Import Target Selection\");\r\n+\t\tsetTitle(\"Import Target Selection\");\r\n+\t\tsetModel(model);\r\n+\t\tsetDescription(\r\n+\t\t\t\t\"Please select a requirement specification element in which the requirements should be imported to.\");\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzNTUyMg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449235522", "bodyText": "Lets make this a constant as well.", "author": "SaMuellerDLR", "createdAt": "2020-07-02T19:52:45Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvImportTargetSelectionPage.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.AssemblyTree;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.ConfigurationTree;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.ElementConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.ElementOccurence;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementGroup;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsSpecification;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.ATreeViewerPage;\r\n+\r\n+/**\r\n+ * A page to select a requirement type for imported requirements\r\n+ *\r\n+ */\r\n+public class CsvImportTargetSelectionPage extends ATreeViewerPage {\r\n+\r\n+\t/**\r\n+\t * Default constructor\r\n+\t * @param model the model\r\n+\t */\r\n+\tprotected CsvImportTargetSelectionPage(IContainer model) {\r\n+\t\tsuper(\"Import Target Selection\");\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzNTY2MQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449235661", "bodyText": "Can also be simplified (see comment in other class)", "author": "SaMuellerDLR", "createdAt": "2020-07-02T19:53:05Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvImportTargetSelectionPage.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.AssemblyTree;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.ConfigurationTree;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.ElementConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.ElementOccurence;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementGroup;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsSpecification;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.ATreeViewerPage;\r\n+\r\n+/**\r\n+ * A page to select a requirement type for imported requirements\r\n+ *\r\n+ */\r\n+public class CsvImportTargetSelectionPage extends ATreeViewerPage {\r\n+\r\n+\t/**\r\n+\t * Default constructor\r\n+\t * @param model the model\r\n+\t */\r\n+\tprotected CsvImportTargetSelectionPage(IContainer model) {\r\n+\t\tsuper(\"Import Target Selection\");\r\n+\t\tsetTitle(\"Import Target Selection\");\r\n+\t\tsetModel(model);\r\n+\t\tsetDescription(\r\n+\t\t\t\t\"Please select a requirement specification element in which the requirements should be imported to.\");\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\t\tsuper.createControl(parent);\r\n+\t\tcreateTreeViewer();\r\n+\t}\r\n+\t\r\n+\t\r\n+\t/**\r\n+\t * Create a tree viewer with filters to show only relevant tree target elements \r\n+\t */\r\n+\tprotected void createTreeViewer() {\r\n+\t\tTreeViewer treeViewer = createTreeUI();\r\n+\t\tVirSatFilteredWrappedTreeContentProvider filteredCp = (VirSatFilteredWrappedTreeContentProvider) treeViewer\r\n+\t\t\t\t.getContentProvider();\r\n+\t\tfilteredCp.addClassFilter(CategoryAssignment.class);\r\n+\t\tfilteredCp.addClassFilter(ArrayInstance.class);\r\n+\t\tfilteredCp.addClassFilter(ComposedPropertyInstance.class);\r\n+\r\n+\t\tfilteredCp.addStructuralElementIdFilter(ConfigurationTree.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(ElementConfiguration.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(AssemblyTree.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(ElementOccurence.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\t\tfilteredCp.addCategoryIdFilter(RequirementsSpecification.FULL_QUALIFIED_CATEGORY_NAME);\r\n+\t}\r\n+\t\r\n+\t\r\n+\t@Override\r\n+\tpublic boolean isSelectionValid() {\r\n+\t\tObject selection = getSelection();\r\n+\t\tif (selection instanceof CategoryAssignment) {\r\n+\t\t\treturn ((CategoryAssignment) selection).getType().getFullQualifiedName()\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzNTk3MA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449235970", "bodyText": "Copy & paste leftover.", "author": "SaMuellerDLR", "createdAt": "2020-07-02T19:53:46Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvImportWizard.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.resources.IResource;\r\n+import org.eclipse.core.resources.ResourcesPlugin;\r\n+import org.eclipse.core.runtime.CoreException;\r\n+import org.eclipse.core.runtime.IProgressMonitor;\r\n+import org.eclipse.core.runtime.IStatus;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.core.runtime.SubMonitor;\r\n+import org.eclipse.core.runtime.jobs.Job;\r\n+import org.eclipse.emf.common.command.Command;\r\n+import org.eclipse.jface.dialogs.DialogSettings;\r\n+import org.eclipse.jface.dialogs.IDialogSettings;\r\n+import org.eclipse.jface.viewers.IStructuredSelection;\r\n+import org.eclipse.jface.wizard.Wizard;\r\n+import org.eclipse.ui.IWorkbench;\r\n+import org.eclipse.ui.IWorkbenchWizard;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.concept.list.IBeanList;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.extension.requirements.csv.CsvFileReader;\r\n+import de.dlr.sc.virsat.model.extension.requirements.csv.CsvRequirementsImporter;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementGroup;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementObject;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsSpecification;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.editingDomain.VirSatEditingDomainRegistry;\r\n+import de.dlr.sc.virsat.project.editingDomain.VirSatTransactionalEditingDomain;\r\n+\r\n+/**\r\n+ * A wizard for the import of requirements from a CSV file\r\n+ *\r\n+ */\r\n+public class CsvImportWizard extends Wizard implements IWorkbenchWizard {\r\n+\r\n+\tpublic static final String ID = \"de.dlr.sc.virsat.model.extension.requirements.ui.wizard.csvImport\";\r\n+\tprivate static final int NUMBER_PROGRESS_TICKS = 3;\r\n+\r\n+\tprivate CsvFileReqTypeSelectionPage importPage;\r\n+\tprivate CsvTypeReviewPage reviewTypePage;\r\n+\tprivate CsvImportTargetSelectionPage targetSelectionPage;\r\n+\tprivate IContainer model;\r\n+\r\n+\tprivate CsvFileReader reader;\r\n+\tprivate CsvRequirementsImporter importer;\r\n+\r\n+\t/**\r\n+\t * Default constructor\r\n+\t */\r\n+\tpublic CsvImportWizard() {\r\n+\t\tsuper();\r\n+\r\n+\t\t// Setup persistency\r\n+\t\tIDialogSettings pluginSettings = Activator.getDefault().getDialogSettings();\r\n+\t\tIDialogSettings wizardSettings = pluginSettings.getSection(ID);\r\n+\t\tif (wizardSettings == null) {\r\n+\t\t\twizardSettings = new DialogSettings(ID);\r\n+\t\t\tpluginSettings.addSection(wizardSettings);\r\n+\t\t}\r\n+\t\tsetDialogSettings(wizardSettings);\r\n+\t\treader = new CsvFileReader();\r\n+\t\timporter = new CsvRequirementsImporter();\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void init(IWorkbench workbench, IStructuredSelection selection) {\r\n+\t\tthis.model = ResourcesPlugin.getWorkspace().getRoot();\r\n+\t\tsetNeedsProgressMonitor(true);\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic boolean performFinish() {\r\n+\r\n+\t\t// Get target list of requirements\r\n+\t\tfinal IBeanList<RequirementObject> targetedReqList;\r\n+\t\tfinal CategoryAssignment selectedSpec = (CategoryAssignment) targetSelectionPage.getSelection();\r\n+\t\tif (selectedSpec.getType().getFullQualifiedName()\r\n+\t\t\t\t.equals(RequirementsSpecification.FULL_QUALIFIED_CATEGORY_NAME)) {\r\n+\t\t\ttargetedReqList = new RequirementsSpecification(selectedSpec).getRequirements();\r\n+\t\t} else if (selectedSpec.getType().getFullQualifiedName()\r\n+\t\t\t\t.equals(RequirementGroup.FULL_QUALIFIED_CATEGORY_NAME)) {\r\n+\t\t\ttargetedReqList = new RequirementGroup(selectedSpec).getChildren();\r\n+\t\t} else {\r\n+\t\t\ttargetedReqList = null;\r\n+\t\t}\r\n+\t\tfinal CategoryAssignment reqConfiguration = (CategoryAssignment) importPage.getSelection();\r\n+\t\tfinal String selectedFilePath = importPage.getDestination();\r\n+\t\treader.setDataStartLine(importPage.getFristDataLineNumber());\r\n+\t\treader.setDataEndLine(importPage.getLastDataLineNumber());\r\n+\t\tMap<Integer, RequirementAttribute> attributeMapping = reviewTypePage.getAttributeMapping();\r\n+\r\n+\t\t// Do the import\r\n+\t\tJob importJob = new Job(\"Performing Requirements CSV Import\") {\r\n+\t\t\t@Override\r\n+\t\t\tprotected IStatus run(IProgressMonitor monitor) {\r\n+\t\t\t\tSubMonitor importSubMonitor = SubMonitor.convert(monitor, NUMBER_PROGRESS_TICKS);\r\n+\t\t\t\ttry {\r\n+\t\t\t\t\tList<List<String>> csvContentMatrix = reader.readCsvData(selectedFilePath);\r\n+\t\t\t\t\timportSubMonitor.worked(1);\r\n+\r\n+\t\t\t\t\tCommand importCommand;\r\n+\t\t\t\t\tVirSatTransactionalEditingDomain editingDomain = VirSatEditingDomainRegistry.INSTANCE\r\n+\t\t\t\t\t\t\t.getEd(selectedSpec);\r\n+\t\t\t\t\tif (reqConfiguration.getType().getFullQualifiedName()\r\n+\t\t\t\t\t\t\t.equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME)) {\r\n+\t\t\t\t\t\timportCommand = importer.loadRequirements(editingDomain, csvContentMatrix, targetedReqList,\r\n+\t\t\t\t\t\t\t\tattributeMapping, new RequirementType(reqConfiguration));\r\n+\t\t\t\t\t} else {\r\n+\t\t\t\t\t\timportCommand = importer.loadRequirements(editingDomain, csvContentMatrix, targetedReqList,\r\n+\t\t\t\t\t\t\t\tattributeMapping, new RequirementsConfiguration(reqConfiguration),\r\n+\t\t\t\t\t\t\t\treviewTypePage.getRequirementType());\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\teditingDomain.getVirSatCommandStack().execute(importCommand);\r\n+\t\t\t\t\timportSubMonitor.worked(1);\r\n+\r\n+\t\t\t\t\tResourcesPlugin.getWorkspace().getRoot().refreshLocal(IResource.DEPTH_INFINITE, null);\r\n+\t\t\t\t\timportSubMonitor.worked(1);\r\n+\r\n+\t\t\t\t\treturn Status.OK_STATUS;\r\n+\t\t\t\t} catch (IOException | CoreException e) {\r\n+\t\t\t\t\tStatus status = new Status(Status.ERROR, Activator.getPluginId(),\r\n+\t\t\t\t\t\t\t\"CatiaImportWizard: Failed to perform import!\", e);\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzNjg2Mw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449236863", "bodyText": "Lets make this a constant.", "author": "SaMuellerDLR", "createdAt": "2020-07-02T19:55:53Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvTypeReviewPage.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import org.eclipse.jface.wizard.WizardPage;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.custom.CCombo;\r\n+import org.eclipse.swt.custom.TableEditor;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.events.SelectionListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Table;\r\n+import org.eclipse.swt.widgets.TableColumn;\r\n+import org.eclipse.swt.widgets.TableItem;\r\n+import org.eclipse.swt.widgets.Text;\r\n+\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+\r\n+/**\r\n+ * A wizard page to review the requirement type which is used for imports\r\n+ *\r\n+ */\r\n+public class CsvTypeReviewPage extends WizardPage implements SelectionListener, ModifyListener {\r\n+\r\n+\tprivate static final String COLUMN_NAME_LABEL = \"Column\";\r\n+\tprivate static final String COLUMN_TYPE_LABEL = \"Type\";\r\n+\r\n+\tprivate static final String TYPE_NAME_LABEL = \"Type Name\";\r\n+\tprivate static final int WITH_TEXT = 400;\r\n+\r\n+\tprivate static final int COLUMN_NAME_WIDTH = 300;\r\n+\tprivate static final int COLUMN_TYPE_WIDTH = 200;\r\n+\r\n+\tprivate static final List<String> ATTRIBUTE_TYPES = new ArrayList<String>(\r\n+\t\t\tArrays.asList(RequirementAttribute.TYPE_Boolean_NAME, RequirementAttribute.TYPE_Date_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Enumeration_NAME, RequirementAttribute.TYPE_Identifier_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Integer_NAME, RequirementAttribute.TYPE_Real_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_String_NAME));\r\n+\r\n+\tprivate static final int TYPE_COLUMN_INDEX = 1;\r\n+\tprivate static final String TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR = \"::\";\r\n+\r\n+\tprivate Text typeNameText;\r\n+\r\n+\tprivate Table table;\r\n+\tprivate List<TableItem> tableItems = new ArrayList<TableItem>();\r\n+\tprivate List<CCombo> editors = new ArrayList<CCombo>();\r\n+\r\n+\tprivate Map<Integer, RequirementAttribute> mapColumnIndexToAttributeType = new HashMap<>();\r\n+\tprivate RequirementType requirementType;\r\n+\tprivate boolean isNewType;\r\n+\r\n+\t/**\r\n+\t * Constructor\r\n+\t */\r\n+\tprotected CsvTypeReviewPage() {\r\n+\t\tsuper(\"Requirement Type Review\");\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzNzIwOQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449237209", "bodyText": "typeNameText.setEditable(isNewType);", "author": "SaMuellerDLR", "createdAt": "2020-07-02T19:56:39Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvTypeReviewPage.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import org.eclipse.jface.wizard.WizardPage;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.custom.CCombo;\r\n+import org.eclipse.swt.custom.TableEditor;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.events.SelectionListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Table;\r\n+import org.eclipse.swt.widgets.TableColumn;\r\n+import org.eclipse.swt.widgets.TableItem;\r\n+import org.eclipse.swt.widgets.Text;\r\n+\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+\r\n+/**\r\n+ * A wizard page to review the requirement type which is used for imports\r\n+ *\r\n+ */\r\n+public class CsvTypeReviewPage extends WizardPage implements SelectionListener, ModifyListener {\r\n+\r\n+\tprivate static final String COLUMN_NAME_LABEL = \"Column\";\r\n+\tprivate static final String COLUMN_TYPE_LABEL = \"Type\";\r\n+\r\n+\tprivate static final String TYPE_NAME_LABEL = \"Type Name\";\r\n+\tprivate static final int WITH_TEXT = 400;\r\n+\r\n+\tprivate static final int COLUMN_NAME_WIDTH = 300;\r\n+\tprivate static final int COLUMN_TYPE_WIDTH = 200;\r\n+\r\n+\tprivate static final List<String> ATTRIBUTE_TYPES = new ArrayList<String>(\r\n+\t\t\tArrays.asList(RequirementAttribute.TYPE_Boolean_NAME, RequirementAttribute.TYPE_Date_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Enumeration_NAME, RequirementAttribute.TYPE_Identifier_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Integer_NAME, RequirementAttribute.TYPE_Real_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_String_NAME));\r\n+\r\n+\tprivate static final int TYPE_COLUMN_INDEX = 1;\r\n+\tprivate static final String TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR = \"::\";\r\n+\r\n+\tprivate Text typeNameText;\r\n+\r\n+\tprivate Table table;\r\n+\tprivate List<TableItem> tableItems = new ArrayList<TableItem>();\r\n+\tprivate List<CCombo> editors = new ArrayList<CCombo>();\r\n+\r\n+\tprivate Map<Integer, RequirementAttribute> mapColumnIndexToAttributeType = new HashMap<>();\r\n+\tprivate RequirementType requirementType;\r\n+\tprivate boolean isNewType;\r\n+\r\n+\t/**\r\n+\t * Constructor\r\n+\t */\r\n+\tprotected CsvTypeReviewPage() {\r\n+\t\tsuper(\"Requirement Type Review\");\r\n+\t\tsetTitle(\"Requirement Type Review\");\r\n+\t\tsetDescription(\"Check the selected import type for the requirements.\");\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see\r\n+\t * org.eclipse.jface.dialogs.IDialogPage#createControl(org.eclipse.swt.widgets.\r\n+\t * Composite)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\r\n+\t\tComposite content = new Composite(parent, SWT.NONE);\r\n+\t\tcontent.setLayout(new GridLayout());\r\n+\t\tcontent.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_HORIZONTAL));\r\n+\t\tsetControl(content);\r\n+\r\n+\t\tComposite typeNameComposite = new Composite(content, SWT.NONE);\r\n+\t\ttypeNameComposite.setLayout(new GridLayout(2, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\ttypeNameComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(typeNameComposite, SWT.NONE);\r\n+\t\tlabel.setText(TYPE_NAME_LABEL);\r\n+\r\n+\t\ttypeNameText = new Text(typeNameComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tGridData dataText = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\ttypeNameText.setLayoutData(dataText);\r\n+\t\ttypeNameText.addSelectionListener(this);\r\n+\t\ttypeNameText.addModifyListener(this);\r\n+\r\n+\t\ttable = new Table(content, SWT.CHECK | SWT.BORDER | SWT.H_SCROLL);\r\n+\t\ttable.setLayout(new GridLayout());\r\n+\t\ttable.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL));\r\n+\t\ttable.setHeaderVisible(true);\r\n+\t\ttable.addSelectionListener(this);\r\n+\r\n+\t\tTableColumn columnColumnName = new TableColumn(table, SWT.NULL);\r\n+\t\tcolumnColumnName.setWidth(COLUMN_NAME_WIDTH);\r\n+\t\tcolumnColumnName.setText(COLUMN_NAME_LABEL);\r\n+\r\n+\t\tTableColumn columnType = new TableColumn(table, SWT.NONE | SWT.DROP_DOWN);\r\n+\t\tcolumnType.setText(COLUMN_TYPE_LABEL);\r\n+\t\tcolumnType.setWidth(COLUMN_TYPE_WIDTH);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Sets the input for the mapping table\r\n+\t * \r\n+\t * @param columnNames\r\n+\t *            a list of columns in the file\r\n+\t * @param requirementType\r\n+\t *            an existing requirement type\r\n+\t */\r\n+\tpublic void setInput(List<String> columnNames, RequirementType requirementType) {\r\n+\t\tthis.requirementType = requirementType;\r\n+\t\tthis.typeNameText.setText(requirementType.getName());\r\n+\t\tisNewType = requirementType.getTypeInstance().eContainer() == null;\r\n+\t\tif (!isNewType) {\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMyNDQ1OQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449324459", "bodyText": "Damn... what did I do", "author": "franzTobiasDLR", "createdAt": "2020-07-03T00:43:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzNzIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzODY2Mw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449238663", "bodyText": "Maybe we could encapsulate this into a small method that takes requirementType and attribute to give back the separated text?", "author": "SaMuellerDLR", "createdAt": "2020-07-02T20:00:00Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvTypeReviewPage.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import org.eclipse.jface.wizard.WizardPage;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.custom.CCombo;\r\n+import org.eclipse.swt.custom.TableEditor;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.events.SelectionListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Table;\r\n+import org.eclipse.swt.widgets.TableColumn;\r\n+import org.eclipse.swt.widgets.TableItem;\r\n+import org.eclipse.swt.widgets.Text;\r\n+\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+\r\n+/**\r\n+ * A wizard page to review the requirement type which is used for imports\r\n+ *\r\n+ */\r\n+public class CsvTypeReviewPage extends WizardPage implements SelectionListener, ModifyListener {\r\n+\r\n+\tprivate static final String COLUMN_NAME_LABEL = \"Column\";\r\n+\tprivate static final String COLUMN_TYPE_LABEL = \"Type\";\r\n+\r\n+\tprivate static final String TYPE_NAME_LABEL = \"Type Name\";\r\n+\tprivate static final int WITH_TEXT = 400;\r\n+\r\n+\tprivate static final int COLUMN_NAME_WIDTH = 300;\r\n+\tprivate static final int COLUMN_TYPE_WIDTH = 200;\r\n+\r\n+\tprivate static final List<String> ATTRIBUTE_TYPES = new ArrayList<String>(\r\n+\t\t\tArrays.asList(RequirementAttribute.TYPE_Boolean_NAME, RequirementAttribute.TYPE_Date_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Enumeration_NAME, RequirementAttribute.TYPE_Identifier_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Integer_NAME, RequirementAttribute.TYPE_Real_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_String_NAME));\r\n+\r\n+\tprivate static final int TYPE_COLUMN_INDEX = 1;\r\n+\tprivate static final String TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR = \"::\";\r\n+\r\n+\tprivate Text typeNameText;\r\n+\r\n+\tprivate Table table;\r\n+\tprivate List<TableItem> tableItems = new ArrayList<TableItem>();\r\n+\tprivate List<CCombo> editors = new ArrayList<CCombo>();\r\n+\r\n+\tprivate Map<Integer, RequirementAttribute> mapColumnIndexToAttributeType = new HashMap<>();\r\n+\tprivate RequirementType requirementType;\r\n+\tprivate boolean isNewType;\r\n+\r\n+\t/**\r\n+\t * Constructor\r\n+\t */\r\n+\tprotected CsvTypeReviewPage() {\r\n+\t\tsuper(\"Requirement Type Review\");\r\n+\t\tsetTitle(\"Requirement Type Review\");\r\n+\t\tsetDescription(\"Check the selected import type for the requirements.\");\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see\r\n+\t * org.eclipse.jface.dialogs.IDialogPage#createControl(org.eclipse.swt.widgets.\r\n+\t * Composite)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\r\n+\t\tComposite content = new Composite(parent, SWT.NONE);\r\n+\t\tcontent.setLayout(new GridLayout());\r\n+\t\tcontent.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_HORIZONTAL));\r\n+\t\tsetControl(content);\r\n+\r\n+\t\tComposite typeNameComposite = new Composite(content, SWT.NONE);\r\n+\t\ttypeNameComposite.setLayout(new GridLayout(2, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\ttypeNameComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(typeNameComposite, SWT.NONE);\r\n+\t\tlabel.setText(TYPE_NAME_LABEL);\r\n+\r\n+\t\ttypeNameText = new Text(typeNameComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tGridData dataText = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\ttypeNameText.setLayoutData(dataText);\r\n+\t\ttypeNameText.addSelectionListener(this);\r\n+\t\ttypeNameText.addModifyListener(this);\r\n+\r\n+\t\ttable = new Table(content, SWT.CHECK | SWT.BORDER | SWT.H_SCROLL);\r\n+\t\ttable.setLayout(new GridLayout());\r\n+\t\ttable.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL));\r\n+\t\ttable.setHeaderVisible(true);\r\n+\t\ttable.addSelectionListener(this);\r\n+\r\n+\t\tTableColumn columnColumnName = new TableColumn(table, SWT.NULL);\r\n+\t\tcolumnColumnName.setWidth(COLUMN_NAME_WIDTH);\r\n+\t\tcolumnColumnName.setText(COLUMN_NAME_LABEL);\r\n+\r\n+\t\tTableColumn columnType = new TableColumn(table, SWT.NONE | SWT.DROP_DOWN);\r\n+\t\tcolumnType.setText(COLUMN_TYPE_LABEL);\r\n+\t\tcolumnType.setWidth(COLUMN_TYPE_WIDTH);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Sets the input for the mapping table\r\n+\t * \r\n+\t * @param columnNames\r\n+\t *            a list of columns in the file\r\n+\t * @param requirementType\r\n+\t *            an existing requirement type\r\n+\t */\r\n+\tpublic void setInput(List<String> columnNames, RequirementType requirementType) {\r\n+\t\tthis.requirementType = requirementType;\r\n+\t\tthis.typeNameText.setText(requirementType.getName());\r\n+\t\tisNewType = requirementType.getTypeInstance().eContainer() == null;\r\n+\t\tif (!isNewType) {\r\n+\t\t\ttypeNameText.setEditable(false);\r\n+\t\t} else {\r\n+\t\t\ttypeNameText.setEditable(true);\r\n+\t\t}\r\n+\r\n+\t\ttable.clearAll();\r\n+\r\n+\t\tfor (String column : columnNames) {\r\n+\t\t\tInteger index = columnNames.indexOf(column);\r\n+\t\t\tTableItem item;\r\n+\t\t\tif (tableItems.size() <= index) {\r\n+\t\t\t\titem = new TableItem(table, SWT.NULL);\r\n+\t\t\t\ttableItems.add(item);\r\n+\t\t\t} else {\r\n+\t\t\t\titem = tableItems.get(index);\r\n+\t\t\t}\r\n+\t\t\titem.setText(0, column);\r\n+\r\n+\t\t\tif (isNewType) {\r\n+\t\t\t\titem.setText(TYPE_COLUMN_INDEX, requirementType.getAttributes().get(index).getType());\r\n+\t\t\t\titem.setChecked(true);\r\n+\t\t\t\tcreateDropDownEditor(item, ATTRIBUTE_TYPES);\r\n+\t\t\t} else {\r\n+\t\t\t\tif (index < requirementType.getAttributes().size()) {\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX,\r\n+\t\t\t\t\t\t\trequirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzOTg4Mw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449239883", "bodyText": "editor.setEditable(item.getChecked())", "author": "SaMuellerDLR", "createdAt": "2020-07-02T20:03:00Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvTypeReviewPage.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import org.eclipse.jface.wizard.WizardPage;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.custom.CCombo;\r\n+import org.eclipse.swt.custom.TableEditor;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.events.SelectionListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Table;\r\n+import org.eclipse.swt.widgets.TableColumn;\r\n+import org.eclipse.swt.widgets.TableItem;\r\n+import org.eclipse.swt.widgets.Text;\r\n+\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+\r\n+/**\r\n+ * A wizard page to review the requirement type which is used for imports\r\n+ *\r\n+ */\r\n+public class CsvTypeReviewPage extends WizardPage implements SelectionListener, ModifyListener {\r\n+\r\n+\tprivate static final String COLUMN_NAME_LABEL = \"Column\";\r\n+\tprivate static final String COLUMN_TYPE_LABEL = \"Type\";\r\n+\r\n+\tprivate static final String TYPE_NAME_LABEL = \"Type Name\";\r\n+\tprivate static final int WITH_TEXT = 400;\r\n+\r\n+\tprivate static final int COLUMN_NAME_WIDTH = 300;\r\n+\tprivate static final int COLUMN_TYPE_WIDTH = 200;\r\n+\r\n+\tprivate static final List<String> ATTRIBUTE_TYPES = new ArrayList<String>(\r\n+\t\t\tArrays.asList(RequirementAttribute.TYPE_Boolean_NAME, RequirementAttribute.TYPE_Date_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Enumeration_NAME, RequirementAttribute.TYPE_Identifier_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Integer_NAME, RequirementAttribute.TYPE_Real_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_String_NAME));\r\n+\r\n+\tprivate static final int TYPE_COLUMN_INDEX = 1;\r\n+\tprivate static final String TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR = \"::\";\r\n+\r\n+\tprivate Text typeNameText;\r\n+\r\n+\tprivate Table table;\r\n+\tprivate List<TableItem> tableItems = new ArrayList<TableItem>();\r\n+\tprivate List<CCombo> editors = new ArrayList<CCombo>();\r\n+\r\n+\tprivate Map<Integer, RequirementAttribute> mapColumnIndexToAttributeType = new HashMap<>();\r\n+\tprivate RequirementType requirementType;\r\n+\tprivate boolean isNewType;\r\n+\r\n+\t/**\r\n+\t * Constructor\r\n+\t */\r\n+\tprotected CsvTypeReviewPage() {\r\n+\t\tsuper(\"Requirement Type Review\");\r\n+\t\tsetTitle(\"Requirement Type Review\");\r\n+\t\tsetDescription(\"Check the selected import type for the requirements.\");\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see\r\n+\t * org.eclipse.jface.dialogs.IDialogPage#createControl(org.eclipse.swt.widgets.\r\n+\t * Composite)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\r\n+\t\tComposite content = new Composite(parent, SWT.NONE);\r\n+\t\tcontent.setLayout(new GridLayout());\r\n+\t\tcontent.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_HORIZONTAL));\r\n+\t\tsetControl(content);\r\n+\r\n+\t\tComposite typeNameComposite = new Composite(content, SWT.NONE);\r\n+\t\ttypeNameComposite.setLayout(new GridLayout(2, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\ttypeNameComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(typeNameComposite, SWT.NONE);\r\n+\t\tlabel.setText(TYPE_NAME_LABEL);\r\n+\r\n+\t\ttypeNameText = new Text(typeNameComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tGridData dataText = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\ttypeNameText.setLayoutData(dataText);\r\n+\t\ttypeNameText.addSelectionListener(this);\r\n+\t\ttypeNameText.addModifyListener(this);\r\n+\r\n+\t\ttable = new Table(content, SWT.CHECK | SWT.BORDER | SWT.H_SCROLL);\r\n+\t\ttable.setLayout(new GridLayout());\r\n+\t\ttable.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL));\r\n+\t\ttable.setHeaderVisible(true);\r\n+\t\ttable.addSelectionListener(this);\r\n+\r\n+\t\tTableColumn columnColumnName = new TableColumn(table, SWT.NULL);\r\n+\t\tcolumnColumnName.setWidth(COLUMN_NAME_WIDTH);\r\n+\t\tcolumnColumnName.setText(COLUMN_NAME_LABEL);\r\n+\r\n+\t\tTableColumn columnType = new TableColumn(table, SWT.NONE | SWT.DROP_DOWN);\r\n+\t\tcolumnType.setText(COLUMN_TYPE_LABEL);\r\n+\t\tcolumnType.setWidth(COLUMN_TYPE_WIDTH);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Sets the input for the mapping table\r\n+\t * \r\n+\t * @param columnNames\r\n+\t *            a list of columns in the file\r\n+\t * @param requirementType\r\n+\t *            an existing requirement type\r\n+\t */\r\n+\tpublic void setInput(List<String> columnNames, RequirementType requirementType) {\r\n+\t\tthis.requirementType = requirementType;\r\n+\t\tthis.typeNameText.setText(requirementType.getName());\r\n+\t\tisNewType = requirementType.getTypeInstance().eContainer() == null;\r\n+\t\tif (!isNewType) {\r\n+\t\t\ttypeNameText.setEditable(false);\r\n+\t\t} else {\r\n+\t\t\ttypeNameText.setEditable(true);\r\n+\t\t}\r\n+\r\n+\t\ttable.clearAll();\r\n+\r\n+\t\tfor (String column : columnNames) {\r\n+\t\t\tInteger index = columnNames.indexOf(column);\r\n+\t\t\tTableItem item;\r\n+\t\t\tif (tableItems.size() <= index) {\r\n+\t\t\t\titem = new TableItem(table, SWT.NULL);\r\n+\t\t\t\ttableItems.add(item);\r\n+\t\t\t} else {\r\n+\t\t\t\titem = tableItems.get(index);\r\n+\t\t\t}\r\n+\t\t\titem.setText(0, column);\r\n+\r\n+\t\t\tif (isNewType) {\r\n+\t\t\t\titem.setText(TYPE_COLUMN_INDEX, requirementType.getAttributes().get(index).getType());\r\n+\t\t\t\titem.setChecked(true);\r\n+\t\t\t\tcreateDropDownEditor(item, ATTRIBUTE_TYPES);\r\n+\t\t\t} else {\r\n+\t\t\t\tif (index < requirementType.getAttributes().size()) {\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX,\r\n+\t\t\t\t\t\t\trequirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR\r\n+\t\t\t\t\t\t\t\t\t+ requirementType.getAttributes().get(index).getName());\r\n+\t\t\t\t\titem.setChecked(true);\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\titem.setChecked(false);\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX, \"\");\r\n+\t\t\t\t}\r\n+\t\t\t\t// If we use an exiting type then just try to map them from the attribute index\r\n+\t\t\t\tcreateDropDownEditor(item, requirementType.getAttributes().stream().map(\r\n+\t\t\t\t\t\tatt -> requirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR + att.getName())\r\n+\t\t\t\t\t\t.collect(Collectors.toList()));\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Method to create a drop down editor for the type column\r\n+\t * \r\n+\t * @param item\r\n+\t *            the item for which the editor should be created\r\n+\t * @param options\r\n+\t *            the input options\r\n+\t */\r\n+\tprivate void createDropDownEditor(TableItem item, List<String> options) {\r\n+\t\tint index = tableItems.indexOf(item);\r\n+\t\tCCombo typeDropdown;\r\n+\t\tif (editors.size() > index) {\r\n+\t\t\ttypeDropdown = editors.get(index);\r\n+\t\t\ttypeDropdown.removeAll();\r\n+\t\t} else {\r\n+\t\t\ttypeDropdown = new CCombo(table, SWT.NONE);\r\n+\t\t\teditors.add(typeDropdown);\r\n+\t\t}\r\n+\t\ttypeDropdown.setText(item.getText(TYPE_COLUMN_INDEX));\r\n+\t\tfor (String option : options) {\r\n+\t\t\ttypeDropdown.add(option);\r\n+\t\t}\r\n+\t\tfinal TableEditor editor = new TableEditor(table);\r\n+\t\teditor.grabHorizontal = true;\r\n+\t\teditor.setEditor(typeDropdown, item, TYPE_COLUMN_INDEX);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Get the mapping of columns to their attribute in specified requirement type\r\n+\t * \r\n+\t * @return a map of the column index to their attribute definition type\r\n+\t */\r\n+\tpublic Map<Integer, RequirementAttribute> getAttributeMapping() {\r\n+\r\n+\t\tfor (TableItem item : tableItems) {\r\n+\t\t\tInteger index = tableItems.indexOf(item);\r\n+\r\n+\t\t\tif (item.getChecked()) {\r\n+\t\t\t\tif (isNewType) {\r\n+\t\t\t\t\tString selectedType = editors.get(index).getText();\r\n+\r\n+\t\t\t\t\tRequirementAttribute correspondingAtt = requirementType.getAttributes().get(index);\r\n+\r\n+\t\t\t\t\t// Check if type is new and valid and then add it to the new requirement type\r\n+\t\t\t\t\tif (ATTRIBUTE_TYPES.contains(selectedType) && !selectedType.equals(correspondingAtt.getType())) {\r\n+\t\t\t\t\t\tcorrespondingAtt.setType(selectedType);\r\n+\t\t\t\t\t}\r\n+\r\n+\t\t\t\t\t// Add corresponding attribute to mapping\r\n+\t\t\t\t\tmapColumnIndexToAttributeType.put(index, correspondingAtt);\r\n+\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\tString inputString = editors.get(index).getText();\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tRequirementAttribute selectedAttribute = getSelectedAttribute(inputString);\r\n+\t\t\t\t\tif (selectedAttribute != null) {\r\n+\t\t\t\t\t\tmapColumnIndexToAttributeType.put(index, selectedAttribute);\r\n+\t\t\t\t\t}\r\n+\r\n+\t\t\t\t}\r\n+\t\t\t} \r\n+\r\n+\t\t}\r\n+\r\n+\t\treturn mapColumnIndexToAttributeType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Get the configured requirement type for the import\r\n+\t * \r\n+\t * @return the requirement type\r\n+\t */\r\n+\tpublic RequirementType getRequirementType() {\r\n+\t\tif (isNewType) {\r\n+\t\t\tfor (RequirementAttribute att : requirementType.getAttributes()) {\r\n+\t\t\t\tif (!mapColumnIndexToAttributeType.containsValue(att)) {\r\n+\t\t\t\t\trequirementType.getAttributes().remove(att);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\treturn requirementType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Parse the attribute from the editor input string\r\n+\t * \r\n+\t * @param inputString\r\n+\t *            the editor input string\r\n+\t * @return the attibute\r\n+\t */\r\n+\tprivate RequirementAttribute getSelectedAttribute(String inputString) {\r\n+\r\n+\t\t// Remove context indication from attribute\r\n+\t\tinputString = inputString.replace(requirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR, \"\");\r\n+\r\n+\t\tfor (RequirementAttribute att : requirementType.getAttributes()) {\r\n+\r\n+\t\t\tif (att.getName().equals(inputString)) {\r\n+\t\t\t\treturn att;\r\n+\t\t\t}\r\n+\r\n+\t\t}\r\n+\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see org.eclipse.swt.events.SelectionListener#widgetSelected(org.eclipse.swt.\r\n+\t * events.SelectionEvent)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void widgetSelected(SelectionEvent e) {\r\n+\t\tif (e.getSource().equals(table) && e.detail == SWT.CHECK) {\r\n+\t\t\tTableItem item = (TableItem) e.item;\r\n+\t\t\tCCombo editor = editors.get(tableItems.indexOf(item));\r\n+\t\t\tif (item.getChecked()) {\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0MDQ2OA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449240468", "bodyText": "Whats up with the weird javadoc (non-javadcoc?) comments here?", "author": "SaMuellerDLR", "createdAt": "2020-07-02T20:04:24Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvTypeReviewPage.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import org.eclipse.jface.wizard.WizardPage;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.custom.CCombo;\r\n+import org.eclipse.swt.custom.TableEditor;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.events.SelectionListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Table;\r\n+import org.eclipse.swt.widgets.TableColumn;\r\n+import org.eclipse.swt.widgets.TableItem;\r\n+import org.eclipse.swt.widgets.Text;\r\n+\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+\r\n+/**\r\n+ * A wizard page to review the requirement type which is used for imports\r\n+ *\r\n+ */\r\n+public class CsvTypeReviewPage extends WizardPage implements SelectionListener, ModifyListener {\r\n+\r\n+\tprivate static final String COLUMN_NAME_LABEL = \"Column\";\r\n+\tprivate static final String COLUMN_TYPE_LABEL = \"Type\";\r\n+\r\n+\tprivate static final String TYPE_NAME_LABEL = \"Type Name\";\r\n+\tprivate static final int WITH_TEXT = 400;\r\n+\r\n+\tprivate static final int COLUMN_NAME_WIDTH = 300;\r\n+\tprivate static final int COLUMN_TYPE_WIDTH = 200;\r\n+\r\n+\tprivate static final List<String> ATTRIBUTE_TYPES = new ArrayList<String>(\r\n+\t\t\tArrays.asList(RequirementAttribute.TYPE_Boolean_NAME, RequirementAttribute.TYPE_Date_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Enumeration_NAME, RequirementAttribute.TYPE_Identifier_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Integer_NAME, RequirementAttribute.TYPE_Real_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_String_NAME));\r\n+\r\n+\tprivate static final int TYPE_COLUMN_INDEX = 1;\r\n+\tprivate static final String TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR = \"::\";\r\n+\r\n+\tprivate Text typeNameText;\r\n+\r\n+\tprivate Table table;\r\n+\tprivate List<TableItem> tableItems = new ArrayList<TableItem>();\r\n+\tprivate List<CCombo> editors = new ArrayList<CCombo>();\r\n+\r\n+\tprivate Map<Integer, RequirementAttribute> mapColumnIndexToAttributeType = new HashMap<>();\r\n+\tprivate RequirementType requirementType;\r\n+\tprivate boolean isNewType;\r\n+\r\n+\t/**\r\n+\t * Constructor\r\n+\t */\r\n+\tprotected CsvTypeReviewPage() {\r\n+\t\tsuper(\"Requirement Type Review\");\r\n+\t\tsetTitle(\"Requirement Type Review\");\r\n+\t\tsetDescription(\"Check the selected import type for the requirements.\");\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see\r\n+\t * org.eclipse.jface.dialogs.IDialogPage#createControl(org.eclipse.swt.widgets.\r\n+\t * Composite)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\r\n+\t\tComposite content = new Composite(parent, SWT.NONE);\r\n+\t\tcontent.setLayout(new GridLayout());\r\n+\t\tcontent.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_HORIZONTAL));\r\n+\t\tsetControl(content);\r\n+\r\n+\t\tComposite typeNameComposite = new Composite(content, SWT.NONE);\r\n+\t\ttypeNameComposite.setLayout(new GridLayout(2, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\ttypeNameComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(typeNameComposite, SWT.NONE);\r\n+\t\tlabel.setText(TYPE_NAME_LABEL);\r\n+\r\n+\t\ttypeNameText = new Text(typeNameComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tGridData dataText = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\ttypeNameText.setLayoutData(dataText);\r\n+\t\ttypeNameText.addSelectionListener(this);\r\n+\t\ttypeNameText.addModifyListener(this);\r\n+\r\n+\t\ttable = new Table(content, SWT.CHECK | SWT.BORDER | SWT.H_SCROLL);\r\n+\t\ttable.setLayout(new GridLayout());\r\n+\t\ttable.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL));\r\n+\t\ttable.setHeaderVisible(true);\r\n+\t\ttable.addSelectionListener(this);\r\n+\r\n+\t\tTableColumn columnColumnName = new TableColumn(table, SWT.NULL);\r\n+\t\tcolumnColumnName.setWidth(COLUMN_NAME_WIDTH);\r\n+\t\tcolumnColumnName.setText(COLUMN_NAME_LABEL);\r\n+\r\n+\t\tTableColumn columnType = new TableColumn(table, SWT.NONE | SWT.DROP_DOWN);\r\n+\t\tcolumnType.setText(COLUMN_TYPE_LABEL);\r\n+\t\tcolumnType.setWidth(COLUMN_TYPE_WIDTH);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Sets the input for the mapping table\r\n+\t * \r\n+\t * @param columnNames\r\n+\t *            a list of columns in the file\r\n+\t * @param requirementType\r\n+\t *            an existing requirement type\r\n+\t */\r\n+\tpublic void setInput(List<String> columnNames, RequirementType requirementType) {\r\n+\t\tthis.requirementType = requirementType;\r\n+\t\tthis.typeNameText.setText(requirementType.getName());\r\n+\t\tisNewType = requirementType.getTypeInstance().eContainer() == null;\r\n+\t\tif (!isNewType) {\r\n+\t\t\ttypeNameText.setEditable(false);\r\n+\t\t} else {\r\n+\t\t\ttypeNameText.setEditable(true);\r\n+\t\t}\r\n+\r\n+\t\ttable.clearAll();\r\n+\r\n+\t\tfor (String column : columnNames) {\r\n+\t\t\tInteger index = columnNames.indexOf(column);\r\n+\t\t\tTableItem item;\r\n+\t\t\tif (tableItems.size() <= index) {\r\n+\t\t\t\titem = new TableItem(table, SWT.NULL);\r\n+\t\t\t\ttableItems.add(item);\r\n+\t\t\t} else {\r\n+\t\t\t\titem = tableItems.get(index);\r\n+\t\t\t}\r\n+\t\t\titem.setText(0, column);\r\n+\r\n+\t\t\tif (isNewType) {\r\n+\t\t\t\titem.setText(TYPE_COLUMN_INDEX, requirementType.getAttributes().get(index).getType());\r\n+\t\t\t\titem.setChecked(true);\r\n+\t\t\t\tcreateDropDownEditor(item, ATTRIBUTE_TYPES);\r\n+\t\t\t} else {\r\n+\t\t\t\tif (index < requirementType.getAttributes().size()) {\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX,\r\n+\t\t\t\t\t\t\trequirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR\r\n+\t\t\t\t\t\t\t\t\t+ requirementType.getAttributes().get(index).getName());\r\n+\t\t\t\t\titem.setChecked(true);\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\titem.setChecked(false);\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX, \"\");\r\n+\t\t\t\t}\r\n+\t\t\t\t// If we use an exiting type then just try to map them from the attribute index\r\n+\t\t\t\tcreateDropDownEditor(item, requirementType.getAttributes().stream().map(\r\n+\t\t\t\t\t\tatt -> requirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR + att.getName())\r\n+\t\t\t\t\t\t.collect(Collectors.toList()));\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Method to create a drop down editor for the type column\r\n+\t * \r\n+\t * @param item\r\n+\t *            the item for which the editor should be created\r\n+\t * @param options\r\n+\t *            the input options\r\n+\t */\r\n+\tprivate void createDropDownEditor(TableItem item, List<String> options) {\r\n+\t\tint index = tableItems.indexOf(item);\r\n+\t\tCCombo typeDropdown;\r\n+\t\tif (editors.size() > index) {\r\n+\t\t\ttypeDropdown = editors.get(index);\r\n+\t\t\ttypeDropdown.removeAll();\r\n+\t\t} else {\r\n+\t\t\ttypeDropdown = new CCombo(table, SWT.NONE);\r\n+\t\t\teditors.add(typeDropdown);\r\n+\t\t}\r\n+\t\ttypeDropdown.setText(item.getText(TYPE_COLUMN_INDEX));\r\n+\t\tfor (String option : options) {\r\n+\t\t\ttypeDropdown.add(option);\r\n+\t\t}\r\n+\t\tfinal TableEditor editor = new TableEditor(table);\r\n+\t\teditor.grabHorizontal = true;\r\n+\t\teditor.setEditor(typeDropdown, item, TYPE_COLUMN_INDEX);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Get the mapping of columns to their attribute in specified requirement type\r\n+\t * \r\n+\t * @return a map of the column index to their attribute definition type\r\n+\t */\r\n+\tpublic Map<Integer, RequirementAttribute> getAttributeMapping() {\r\n+\r\n+\t\tfor (TableItem item : tableItems) {\r\n+\t\t\tInteger index = tableItems.indexOf(item);\r\n+\r\n+\t\t\tif (item.getChecked()) {\r\n+\t\t\t\tif (isNewType) {\r\n+\t\t\t\t\tString selectedType = editors.get(index).getText();\r\n+\r\n+\t\t\t\t\tRequirementAttribute correspondingAtt = requirementType.getAttributes().get(index);\r\n+\r\n+\t\t\t\t\t// Check if type is new and valid and then add it to the new requirement type\r\n+\t\t\t\t\tif (ATTRIBUTE_TYPES.contains(selectedType) && !selectedType.equals(correspondingAtt.getType())) {\r\n+\t\t\t\t\t\tcorrespondingAtt.setType(selectedType);\r\n+\t\t\t\t\t}\r\n+\r\n+\t\t\t\t\t// Add corresponding attribute to mapping\r\n+\t\t\t\t\tmapColumnIndexToAttributeType.put(index, correspondingAtt);\r\n+\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\tString inputString = editors.get(index).getText();\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tRequirementAttribute selectedAttribute = getSelectedAttribute(inputString);\r\n+\t\t\t\t\tif (selectedAttribute != null) {\r\n+\t\t\t\t\t\tmapColumnIndexToAttributeType.put(index, selectedAttribute);\r\n+\t\t\t\t\t}\r\n+\r\n+\t\t\t\t}\r\n+\t\t\t} \r\n+\r\n+\t\t}\r\n+\r\n+\t\treturn mapColumnIndexToAttributeType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Get the configured requirement type for the import\r\n+\t * \r\n+\t * @return the requirement type\r\n+\t */\r\n+\tpublic RequirementType getRequirementType() {\r\n+\t\tif (isNewType) {\r\n+\t\t\tfor (RequirementAttribute att : requirementType.getAttributes()) {\r\n+\t\t\t\tif (!mapColumnIndexToAttributeType.containsValue(att)) {\r\n+\t\t\t\t\trequirementType.getAttributes().remove(att);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\treturn requirementType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Parse the attribute from the editor input string\r\n+\t * \r\n+\t * @param inputString\r\n+\t *            the editor input string\r\n+\t * @return the attibute\r\n+\t */\r\n+\tprivate RequirementAttribute getSelectedAttribute(String inputString) {\r\n+\r\n+\t\t// Remove context indication from attribute\r\n+\t\tinputString = inputString.replace(requirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR, \"\");\r\n+\r\n+\t\tfor (RequirementAttribute att : requirementType.getAttributes()) {\r\n+\r\n+\t\t\tif (att.getName().equals(inputString)) {\r\n+\t\t\t\treturn att;\r\n+\t\t\t}\r\n+\r\n+\t\t}\r\n+\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see org.eclipse.swt.events.SelectionListener#widgetSelected(org.eclipse.swt.\r\n+\t * events.SelectionEvent)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void widgetSelected(SelectionEvent e) {\r\n+\t\tif (e.getSource().equals(table) && e.detail == SWT.CHECK) {\r\n+\t\t\tTableItem item = (TableItem) e.item;\r\n+\t\t\tCCombo editor = editors.get(tableItems.indexOf(item));\r\n+\t\t\tif (item.getChecked()) {\r\n+\t\t\t\teditor.setEditable(true);\r\n+\t\t\t} else {\r\n+\t\t\t\teditor.setEditable(false);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\t\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see\r\n+\t * org.eclipse.swt.events.SelectionListener#widgetDefaultSelected(org.eclipse.\r\n+\t * swt.events.SelectionEvent)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void widgetDefaultSelected(SelectionEvent e) {\r\n+\t\t\r\n+\t}\r\n+\r\n+\t/* (non-Javadoc)\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMyNjczMw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449326733", "bodyText": "It's generated methods from eclipse... Method overwrites from super classes, getter/ setters and delegate forwardings and so on... Eclipse can generate quite some stuff... But its adding these comments.", "author": "franzTobiasDLR", "createdAt": "2020-07-03T00:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0MDQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0MTAzMA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449241030", "bodyText": "I dont remember the difference between these two methods. Doesnt this need to be redicated to widgetSelected?", "author": "SaMuellerDLR", "createdAt": "2020-07-02T20:05:44Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvTypeReviewPage.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import org.eclipse.jface.wizard.WizardPage;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.custom.CCombo;\r\n+import org.eclipse.swt.custom.TableEditor;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.events.SelectionListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Table;\r\n+import org.eclipse.swt.widgets.TableColumn;\r\n+import org.eclipse.swt.widgets.TableItem;\r\n+import org.eclipse.swt.widgets.Text;\r\n+\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+\r\n+/**\r\n+ * A wizard page to review the requirement type which is used for imports\r\n+ *\r\n+ */\r\n+public class CsvTypeReviewPage extends WizardPage implements SelectionListener, ModifyListener {\r\n+\r\n+\tprivate static final String COLUMN_NAME_LABEL = \"Column\";\r\n+\tprivate static final String COLUMN_TYPE_LABEL = \"Type\";\r\n+\r\n+\tprivate static final String TYPE_NAME_LABEL = \"Type Name\";\r\n+\tprivate static final int WITH_TEXT = 400;\r\n+\r\n+\tprivate static final int COLUMN_NAME_WIDTH = 300;\r\n+\tprivate static final int COLUMN_TYPE_WIDTH = 200;\r\n+\r\n+\tprivate static final List<String> ATTRIBUTE_TYPES = new ArrayList<String>(\r\n+\t\t\tArrays.asList(RequirementAttribute.TYPE_Boolean_NAME, RequirementAttribute.TYPE_Date_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Enumeration_NAME, RequirementAttribute.TYPE_Identifier_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Integer_NAME, RequirementAttribute.TYPE_Real_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_String_NAME));\r\n+\r\n+\tprivate static final int TYPE_COLUMN_INDEX = 1;\r\n+\tprivate static final String TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR = \"::\";\r\n+\r\n+\tprivate Text typeNameText;\r\n+\r\n+\tprivate Table table;\r\n+\tprivate List<TableItem> tableItems = new ArrayList<TableItem>();\r\n+\tprivate List<CCombo> editors = new ArrayList<CCombo>();\r\n+\r\n+\tprivate Map<Integer, RequirementAttribute> mapColumnIndexToAttributeType = new HashMap<>();\r\n+\tprivate RequirementType requirementType;\r\n+\tprivate boolean isNewType;\r\n+\r\n+\t/**\r\n+\t * Constructor\r\n+\t */\r\n+\tprotected CsvTypeReviewPage() {\r\n+\t\tsuper(\"Requirement Type Review\");\r\n+\t\tsetTitle(\"Requirement Type Review\");\r\n+\t\tsetDescription(\"Check the selected import type for the requirements.\");\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see\r\n+\t * org.eclipse.jface.dialogs.IDialogPage#createControl(org.eclipse.swt.widgets.\r\n+\t * Composite)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\r\n+\t\tComposite content = new Composite(parent, SWT.NONE);\r\n+\t\tcontent.setLayout(new GridLayout());\r\n+\t\tcontent.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_HORIZONTAL));\r\n+\t\tsetControl(content);\r\n+\r\n+\t\tComposite typeNameComposite = new Composite(content, SWT.NONE);\r\n+\t\ttypeNameComposite.setLayout(new GridLayout(2, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\ttypeNameComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(typeNameComposite, SWT.NONE);\r\n+\t\tlabel.setText(TYPE_NAME_LABEL);\r\n+\r\n+\t\ttypeNameText = new Text(typeNameComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tGridData dataText = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\ttypeNameText.setLayoutData(dataText);\r\n+\t\ttypeNameText.addSelectionListener(this);\r\n+\t\ttypeNameText.addModifyListener(this);\r\n+\r\n+\t\ttable = new Table(content, SWT.CHECK | SWT.BORDER | SWT.H_SCROLL);\r\n+\t\ttable.setLayout(new GridLayout());\r\n+\t\ttable.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL));\r\n+\t\ttable.setHeaderVisible(true);\r\n+\t\ttable.addSelectionListener(this);\r\n+\r\n+\t\tTableColumn columnColumnName = new TableColumn(table, SWT.NULL);\r\n+\t\tcolumnColumnName.setWidth(COLUMN_NAME_WIDTH);\r\n+\t\tcolumnColumnName.setText(COLUMN_NAME_LABEL);\r\n+\r\n+\t\tTableColumn columnType = new TableColumn(table, SWT.NONE | SWT.DROP_DOWN);\r\n+\t\tcolumnType.setText(COLUMN_TYPE_LABEL);\r\n+\t\tcolumnType.setWidth(COLUMN_TYPE_WIDTH);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Sets the input for the mapping table\r\n+\t * \r\n+\t * @param columnNames\r\n+\t *            a list of columns in the file\r\n+\t * @param requirementType\r\n+\t *            an existing requirement type\r\n+\t */\r\n+\tpublic void setInput(List<String> columnNames, RequirementType requirementType) {\r\n+\t\tthis.requirementType = requirementType;\r\n+\t\tthis.typeNameText.setText(requirementType.getName());\r\n+\t\tisNewType = requirementType.getTypeInstance().eContainer() == null;\r\n+\t\tif (!isNewType) {\r\n+\t\t\ttypeNameText.setEditable(false);\r\n+\t\t} else {\r\n+\t\t\ttypeNameText.setEditable(true);\r\n+\t\t}\r\n+\r\n+\t\ttable.clearAll();\r\n+\r\n+\t\tfor (String column : columnNames) {\r\n+\t\t\tInteger index = columnNames.indexOf(column);\r\n+\t\t\tTableItem item;\r\n+\t\t\tif (tableItems.size() <= index) {\r\n+\t\t\t\titem = new TableItem(table, SWT.NULL);\r\n+\t\t\t\ttableItems.add(item);\r\n+\t\t\t} else {\r\n+\t\t\t\titem = tableItems.get(index);\r\n+\t\t\t}\r\n+\t\t\titem.setText(0, column);\r\n+\r\n+\t\t\tif (isNewType) {\r\n+\t\t\t\titem.setText(TYPE_COLUMN_INDEX, requirementType.getAttributes().get(index).getType());\r\n+\t\t\t\titem.setChecked(true);\r\n+\t\t\t\tcreateDropDownEditor(item, ATTRIBUTE_TYPES);\r\n+\t\t\t} else {\r\n+\t\t\t\tif (index < requirementType.getAttributes().size()) {\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX,\r\n+\t\t\t\t\t\t\trequirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR\r\n+\t\t\t\t\t\t\t\t\t+ requirementType.getAttributes().get(index).getName());\r\n+\t\t\t\t\titem.setChecked(true);\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\titem.setChecked(false);\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX, \"\");\r\n+\t\t\t\t}\r\n+\t\t\t\t// If we use an exiting type then just try to map them from the attribute index\r\n+\t\t\t\tcreateDropDownEditor(item, requirementType.getAttributes().stream().map(\r\n+\t\t\t\t\t\tatt -> requirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR + att.getName())\r\n+\t\t\t\t\t\t.collect(Collectors.toList()));\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Method to create a drop down editor for the type column\r\n+\t * \r\n+\t * @param item\r\n+\t *            the item for which the editor should be created\r\n+\t * @param options\r\n+\t *            the input options\r\n+\t */\r\n+\tprivate void createDropDownEditor(TableItem item, List<String> options) {\r\n+\t\tint index = tableItems.indexOf(item);\r\n+\t\tCCombo typeDropdown;\r\n+\t\tif (editors.size() > index) {\r\n+\t\t\ttypeDropdown = editors.get(index);\r\n+\t\t\ttypeDropdown.removeAll();\r\n+\t\t} else {\r\n+\t\t\ttypeDropdown = new CCombo(table, SWT.NONE);\r\n+\t\t\teditors.add(typeDropdown);\r\n+\t\t}\r\n+\t\ttypeDropdown.setText(item.getText(TYPE_COLUMN_INDEX));\r\n+\t\tfor (String option : options) {\r\n+\t\t\ttypeDropdown.add(option);\r\n+\t\t}\r\n+\t\tfinal TableEditor editor = new TableEditor(table);\r\n+\t\teditor.grabHorizontal = true;\r\n+\t\teditor.setEditor(typeDropdown, item, TYPE_COLUMN_INDEX);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Get the mapping of columns to their attribute in specified requirement type\r\n+\t * \r\n+\t * @return a map of the column index to their attribute definition type\r\n+\t */\r\n+\tpublic Map<Integer, RequirementAttribute> getAttributeMapping() {\r\n+\r\n+\t\tfor (TableItem item : tableItems) {\r\n+\t\t\tInteger index = tableItems.indexOf(item);\r\n+\r\n+\t\t\tif (item.getChecked()) {\r\n+\t\t\t\tif (isNewType) {\r\n+\t\t\t\t\tString selectedType = editors.get(index).getText();\r\n+\r\n+\t\t\t\t\tRequirementAttribute correspondingAtt = requirementType.getAttributes().get(index);\r\n+\r\n+\t\t\t\t\t// Check if type is new and valid and then add it to the new requirement type\r\n+\t\t\t\t\tif (ATTRIBUTE_TYPES.contains(selectedType) && !selectedType.equals(correspondingAtt.getType())) {\r\n+\t\t\t\t\t\tcorrespondingAtt.setType(selectedType);\r\n+\t\t\t\t\t}\r\n+\r\n+\t\t\t\t\t// Add corresponding attribute to mapping\r\n+\t\t\t\t\tmapColumnIndexToAttributeType.put(index, correspondingAtt);\r\n+\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\tString inputString = editors.get(index).getText();\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tRequirementAttribute selectedAttribute = getSelectedAttribute(inputString);\r\n+\t\t\t\t\tif (selectedAttribute != null) {\r\n+\t\t\t\t\t\tmapColumnIndexToAttributeType.put(index, selectedAttribute);\r\n+\t\t\t\t\t}\r\n+\r\n+\t\t\t\t}\r\n+\t\t\t} \r\n+\r\n+\t\t}\r\n+\r\n+\t\treturn mapColumnIndexToAttributeType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Get the configured requirement type for the import\r\n+\t * \r\n+\t * @return the requirement type\r\n+\t */\r\n+\tpublic RequirementType getRequirementType() {\r\n+\t\tif (isNewType) {\r\n+\t\t\tfor (RequirementAttribute att : requirementType.getAttributes()) {\r\n+\t\t\t\tif (!mapColumnIndexToAttributeType.containsValue(att)) {\r\n+\t\t\t\t\trequirementType.getAttributes().remove(att);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\treturn requirementType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Parse the attribute from the editor input string\r\n+\t * \r\n+\t * @param inputString\r\n+\t *            the editor input string\r\n+\t * @return the attibute\r\n+\t */\r\n+\tprivate RequirementAttribute getSelectedAttribute(String inputString) {\r\n+\r\n+\t\t// Remove context indication from attribute\r\n+\t\tinputString = inputString.replace(requirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR, \"\");\r\n+\r\n+\t\tfor (RequirementAttribute att : requirementType.getAttributes()) {\r\n+\r\n+\t\t\tif (att.getName().equals(inputString)) {\r\n+\t\t\t\treturn att;\r\n+\t\t\t}\r\n+\r\n+\t\t}\r\n+\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see org.eclipse.swt.events.SelectionListener#widgetSelected(org.eclipse.swt.\r\n+\t * events.SelectionEvent)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void widgetSelected(SelectionEvent e) {\r\n+\t\tif (e.getSource().equals(table) && e.detail == SWT.CHECK) {\r\n+\t\t\tTableItem item = (TableItem) e.item;\r\n+\t\t\tCCombo editor = editors.get(tableItems.indexOf(item));\r\n+\t\t\tif (item.getChecked()) {\r\n+\t\t\t\teditor.setEditable(true);\r\n+\t\t\t} else {\r\n+\t\t\t\teditor.setEditable(false);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\t\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see\r\n+\t * org.eclipse.swt.events.SelectionListener#widgetDefaultSelected(org.eclipse.\r\n+\t * swt.events.SelectionEvent)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void widgetDefaultSelected(SelectionEvent e) {\r\n+\t\t\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMyNjU5Nw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449326597", "bodyText": "Guess we can ignore the methode: https://stackoverflow.com/questions/9254310/java-swt-widgetselected-vs-widgetdefaultselected", "author": "franzTobiasDLR", "createdAt": "2020-07-03T00:54:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0MTAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0NDA2OQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449244069", "bodyText": "Maybe req.get(0) would make it clearer that we are talking about the first column here.", "author": "SaMuellerDLR", "createdAt": "2020-07-02T20:13:04Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvRequirementsImporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Map.Entry;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.emf.common.command.CompoundCommand;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.model.concept.list.IBeanList;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.Activator;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.AttributeValue;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.EnumerationLiteral;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementObject;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+\r\n+/**\r\n+ * A class that imports requirements from a CSV file\r\n+ *\r\n+ */\r\n+public class CsvRequirementsImporter {\r\n+\r\n+\tprotected EditingDomain editingDomain;\r\n+\tprotected Concept reqConcept;\r\n+\r\n+\tprivate static final String REQ_TYPE_NAME = \"CCVImportedRequirementType\";\r\n+\tprivate static final String REQ_EXTENSION_IDENTIFIER_PREFIX = \"-extension\";\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param importType\r\n+\t *            the requirement type of the imported requirements\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementType importType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tif (reqConcept == null) {\r\n+\t\t\tthis.reqConcept = getReqConcept(importType.getTypeInstance());\r\n+\t\t}\r\n+\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\r\n+\t\t// Read the actual requirements\r\n+\t\tfor (List<String> req : csvContentMatrix) {\r\n+\t\t\tint lineNumber = csvContentMatrix.indexOf(req);\r\n+\t\t\tRequirement newReqElement = createRequirement(importType, lineNumber);\r\n+\r\n+\t\t\t//If the first columns of a requirement are empty then values from previous lines are used\r\n+\t\t\tString attribute = req.iterator().next();\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMyNzg0OA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449327848", "bodyText": "We're not only talking about the first column here... But all columns (starting from left) that do not have a value", "author": "franzTobiasDLR", "createdAt": "2020-07-03T01:00:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0NDA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0NDY1Mg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449244652", "bodyText": "SCV = CSV?", "author": "SaMuellerDLR", "createdAt": "2020-07-02T20:14:32Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvRequirementsImporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Map.Entry;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.emf.common.command.CompoundCommand;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.model.concept.list.IBeanList;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.Activator;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.AttributeValue;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.EnumerationLiteral;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementObject;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+\r\n+/**\r\n+ * A class that imports requirements from a CSV file\r\n+ *\r\n+ */\r\n+public class CsvRequirementsImporter {\r\n+\r\n+\tprotected EditingDomain editingDomain;\r\n+\tprotected Concept reqConcept;\r\n+\r\n+\tprivate static final String REQ_TYPE_NAME = \"CCVImportedRequirementType\";\r\n+\tprivate static final String REQ_EXTENSION_IDENTIFIER_PREFIX = \"-extension\";\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param importType\r\n+\t *            the requirement type of the imported requirements\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementType importType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tif (reqConcept == null) {\r\n+\t\t\tthis.reqConcept = getReqConcept(importType.getTypeInstance());\r\n+\t\t}\r\n+\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\r\n+\t\t// Read the actual requirements\r\n+\t\tfor (List<String> req : csvContentMatrix) {\r\n+\t\t\tint lineNumber = csvContentMatrix.indexOf(req);\r\n+\t\t\tRequirement newReqElement = createRequirement(importType, lineNumber);\r\n+\r\n+\t\t\t//If the first columns of a requirement are empty then values from previous lines are used\r\n+\t\t\tString attribute = req.iterator().next();\r\n+\t\t\twhile (attribute.equals(\"\")) {\r\n+\t\t\t\tint currentAttributeIndex = req.indexOf(attribute);\r\n+\t\t\t\tString repeatedValue = csvContentMatrix.get(lineNumber - 1).get(currentAttributeIndex);\r\n+\t\t\t\tif (attributeMapping.get(currentAttributeIndex) != null && attributeMapping.get(currentAttributeIndex).getType().equals(RequirementAttribute.TYPE_Identifier_NAME)) {\r\n+\t\t\t\t\trepeatedValue += REQ_EXTENSION_IDENTIFIER_PREFIX;\r\n+\t\t\t\t}\r\n+\t\t\t\treq.set(currentAttributeIndex, repeatedValue);\r\n+\t\t\t\tattribute = req.get(currentAttributeIndex + 1);\r\n+\t\t\t}\r\n+\t\r\n+\t\t\t//Needed because req.indexOf(attValue) does not work if columns have the same value\r\n+\t\t\tint currentIndex = 0;\r\n+\t\t\tfor (String attValue : req) {\r\n+\t\t\t\tRequirementAttribute mappedAttribute = attributeMapping.get(currentIndex);\r\n+\r\n+\t\t\t\tif (mappedAttribute != null) {\r\n+\t\t\t\t\tsetAttributeValue(newReqElement, attValue, mappedAttribute);\r\n+\t\t\t\t}\r\n+\t\t\t\tcurrentIndex++;\r\n+\t\t\t}\r\n+\t\t\tnewReqElement.updateNameFromAttributes();\r\n+\t\t\timportCommand.append(targetSpecificationList.add(editingDomain, newReqElement));\r\n+\t\t}\r\n+\r\n+\t\treturn importCommand;\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0NjE2Mg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449246162", "bodyText": "Cleaning the literalName looks like repeated logic from the Requirement class.\nMaybe we can extract this into a helper method.", "author": "SaMuellerDLR", "createdAt": "2020-07-02T20:18:11Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvRequirementsImporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Map.Entry;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.emf.common.command.CompoundCommand;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.model.concept.list.IBeanList;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.Activator;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.AttributeValue;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.EnumerationLiteral;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementObject;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+\r\n+/**\r\n+ * A class that imports requirements from a CSV file\r\n+ *\r\n+ */\r\n+public class CsvRequirementsImporter {\r\n+\r\n+\tprotected EditingDomain editingDomain;\r\n+\tprotected Concept reqConcept;\r\n+\r\n+\tprivate static final String REQ_TYPE_NAME = \"CCVImportedRequirementType\";\r\n+\tprivate static final String REQ_EXTENSION_IDENTIFIER_PREFIX = \"-extension\";\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param importType\r\n+\t *            the requirement type of the imported requirements\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementType importType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tif (reqConcept == null) {\r\n+\t\t\tthis.reqConcept = getReqConcept(importType.getTypeInstance());\r\n+\t\t}\r\n+\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\r\n+\t\t// Read the actual requirements\r\n+\t\tfor (List<String> req : csvContentMatrix) {\r\n+\t\t\tint lineNumber = csvContentMatrix.indexOf(req);\r\n+\t\t\tRequirement newReqElement = createRequirement(importType, lineNumber);\r\n+\r\n+\t\t\t//If the first columns of a requirement are empty then values from previous lines are used\r\n+\t\t\tString attribute = req.iterator().next();\r\n+\t\t\twhile (attribute.equals(\"\")) {\r\n+\t\t\t\tint currentAttributeIndex = req.indexOf(attribute);\r\n+\t\t\t\tString repeatedValue = csvContentMatrix.get(lineNumber - 1).get(currentAttributeIndex);\r\n+\t\t\t\tif (attributeMapping.get(currentAttributeIndex) != null && attributeMapping.get(currentAttributeIndex).getType().equals(RequirementAttribute.TYPE_Identifier_NAME)) {\r\n+\t\t\t\t\trepeatedValue += REQ_EXTENSION_IDENTIFIER_PREFIX;\r\n+\t\t\t\t}\r\n+\t\t\t\treq.set(currentAttributeIndex, repeatedValue);\r\n+\t\t\t\tattribute = req.get(currentAttributeIndex + 1);\r\n+\t\t\t}\r\n+\t\r\n+\t\t\t//Needed because req.indexOf(attValue) does not work if columns have the same value\r\n+\t\t\tint currentIndex = 0;\r\n+\t\t\tfor (String attValue : req) {\r\n+\t\t\t\tRequirementAttribute mappedAttribute = attributeMapping.get(currentIndex);\r\n+\r\n+\t\t\t\tif (mappedAttribute != null) {\r\n+\t\t\t\t\tsetAttributeValue(newReqElement, attValue, mappedAttribute);\r\n+\t\t\t\t}\r\n+\t\t\t\tcurrentIndex++;\r\n+\t\t\t}\r\n+\t\t\tnewReqElement.updateNameFromAttributes();\r\n+\t\t\timportCommand.append(targetSpecificationList.add(editingDomain, newReqElement));\r\n+\t\t}\r\n+\r\n+\t\treturn importCommand;\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param newImportTypeContainer\r\n+\t *            the requirement configuration in which the new type element should\r\n+\t *            be added into\r\n+\t * @param nonPersistedType\r\n+\t *            A new requirement type that is not yet persisted\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementsConfiguration newImportTypeContainer, RequirementType nonPersistedType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tthis.reqConcept = getReqConcept(newImportTypeContainer.getTypeInstance());\r\n+\r\n+\t\t// Create a requirement type for the import\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\t\tcustomizeReqTypeFromData(nonPersistedType, csvContentMatrix, attributeMapping);\r\n+\t\tRequirementType reqType = createReqType(importCommand, newImportTypeContainer, nonPersistedType);\r\n+\r\n+\t\timportCommand.append(\r\n+\t\t\t\tloadRequirements(editingDomain, csvContentMatrix, targetSpecificationList, attributeMapping, reqType));\r\n+\r\n+\t\treturn importCommand;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Creates a requirement type from a list of attribute names. Does not create a\r\n+\t * command or persist the element yet\r\n+\t * \r\n+\t * @param reqConcept\r\n+\t *            the active concept\r\n+\t * @param attributeNames\r\n+\t *            a list of attribute names\r\n+\t * @return the new type\r\n+\t */\r\n+\tpublic RequirementType prepareRequirementType(Concept reqConcept, List<String> attributeNames) {\r\n+\t\tthis.reqConcept = reqConcept;\r\n+\t\tRequirementType newReqType = new RequirementType(reqConcept);\r\n+\t\tnewReqType.setName(REQ_TYPE_NAME);\r\n+\t\tfor (String attName : attributeNames) {\r\n+\t\t\tRequirementAttribute attDef = new RequirementAttribute(reqConcept);\r\n+\t\t\tattDef.setName(attName.replace(\" \", \"\"));\r\n+\t\t\tattDef.setType(RequirementAttribute.TYPE_String_NAME);\r\n+\t\t\tnewReqType.getAttributes().add(attDef);\r\n+\t\t}\r\n+\t\treturn newReqType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a requirement and set its type\r\n+\t * \r\n+\t *            the containing list of requirements\r\n+\t * @param reqType\r\n+\t *            the requirement type\r\n+\t * @param lineNumber \r\n+\t * \t\t\t  the line index of the requirement\r\n+\t * @return the new requirement\r\n+\t */\r\n+\tprotected Requirement createRequirement(RequirementType reqType, int lineNumber) {\r\n+\t\tRequirement requirement = new Requirement(reqConcept);\r\n+\t\trequirement.setReqType(reqType);\r\n+\t\trequirement.setName(reqType.getName() + lineNumber);\r\n+\t\tfor (RequirementAttribute att : reqType.getAttributes()) {\r\n+\t\t\tAttributeValue attValue = new AttributeValue(reqConcept);\r\n+\t\t\tattValue.setName(att.getName());\r\n+\t\t\tattValue.setAttType(att);\r\n+\t\t\trequirement.getElements().add(attValue);\r\n+\t\t}\r\n+\t\treturn requirement;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a attribute value within a requirement\r\n+\t * \r\n+\t * @param requirement\r\n+\t *            the requirement to edit\r\n+\t * @param value\r\n+\t *            the value to be added to the attribute\r\n+\t * @param attDef the attribute definition\r\n+\t */\r\n+\tprotected void setAttributeValue(Requirement requirement, String value,\r\n+\t\t\tRequirementAttribute attDef) {\r\n+\t\tfor (AttributeValue att : requirement.getElements()) {\r\n+\t\t\tRequirementAttribute type = att.getAttType();\r\n+\t\t\tif (type.equals(attDef)) {\r\n+\t\t\t\tatt.setValue(value);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * create a requirement type with a given number of attributes\r\n+\t * \r\n+\t * @param importCommand\r\n+\t *            the import command which should contain this creation operation\r\n+\t * @param container\r\n+\t *            the container element in which the new type should be added into\r\n+\t * @param newReqType\r\n+\t *            a new not yet persited requirement type\r\n+\t * @return the new requirement type\r\n+\t */\r\n+\tprotected RequirementType createReqType(CompoundCommand importCommand, RequirementsConfiguration container,\r\n+\t\t\tRequirementType newReqType) {\r\n+\r\n+\t\timportCommand.append(container.getTypeDefinitions().add(editingDomain, newReqType));\r\n+\t\treturn newReqType;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Update a new requirement type from a set of CSV data\r\n+\t * @param type the not yet persisted requirement type\r\n+\t * @param csvContentMatrix the CSV data\r\n+\t * @param attributeMapping the mapping of column index to attribute\r\n+\t */\r\n+\tprotected void customizeReqTypeFromData(RequirementType type, List<List<String>> csvContentMatrix, Map<Integer, RequirementAttribute> attributeMapping) {\r\n+\t\tfor (RequirementAttribute att : type.getAttributes()) {\r\n+\t\t\t\r\n+\t\t\tif (att.getType().equals(RequirementAttribute.TYPE_Enumeration_NAME)) {\r\n+\t\t\t\t\r\n+\t\t\t\tInteger columnIndexOfAttribute = null;\r\n+\t\t\t\tfor (Entry<Integer, RequirementAttribute> entry : attributeMapping.entrySet()) {\r\n+\t\t\t\t\tif (entry.getValue().equals(att)) {\r\n+\t\t\t\t\t\tcolumnIndexOfAttribute = entry.getKey();\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tif (columnIndexOfAttribute != null) {\r\n+\t\t\t\t\tSet<String> enumerationLiteralValues = new HashSet<>();\r\n+\t\t\t\t\tfor (List<String> reg : csvContentMatrix) {\r\n+\t\t\t\t\t\tif (reg.size() > columnIndexOfAttribute) {\r\n+\t\t\t\t\t\t\tenumerationLiteralValues.add(reg.get(columnIndexOfAttribute));\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\tfor (String literal : enumerationLiteralValues) {\r\n+\t\t\t\t\t\tif (!literal.equals(\"\")) {\r\n+\t\t\t\t\t\t\tEnumerationLiteral literalBean = new EnumerationLiteral(reqConcept);\r\n+\t\t\t\t\t\t\tString literalName = literal.replaceAll(\" \", \"\");\r\n+\t\t\t\t\t\t\tliteralName = literalName.replaceAll(\"-\", \"\");\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0ODk2OA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449248968", "bodyText": "map(EnumerationLiteral::getName)", "author": "SaMuellerDLR", "createdAt": "2020-07-02T20:24:51Z", "path": "de.dlr.sc.virsat.model.extension.requirements.test/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvRequirementsImporterTest.java", "diffHunk": "@@ -0,0 +1,601 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import org.eclipse.core.runtime.CoreException;\r\n+import org.eclipse.emf.common.command.Command;\r\n+import org.eclipse.emf.transaction.RecordingCommand;\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+import de.dlr.sc.virsat.concept.unittest.util.test.AConceptProjectTestCase;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.ConfigurationTree;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.ElementConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.EnumerationLiteral;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementGroup;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfigurationCollection;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsSpecification;\r\n+\r\n+/**\r\n+ * The test class for the requirements importer\r\n+ *\r\n+ */\r\n+public class CsvRequirementsImporterTest extends AConceptProjectTestCase {\r\n+\r\n+\tprivate static final String NAME_HEADER_NAME = \"Name\";\r\n+\tprivate static final String NAME_HEADER_ID = \"ID\";\r\n+\tprivate static final String NAME_HEADER_DES = \"Description\";\r\n+\tprivate static final String NAME_HEADER_VALUE = \"Value\";\r\n+\t\r\n+\tprivate static final String ATT_1_NAME = \"att1Name\";\r\n+\tprivate static final String ATT_2_NAME = \"att2Name\";\r\n+\tprivate static final String ATT_3_NAME = \"att3Name\";\r\n+\r\n+\tprivate static final String ATT_1_ID = \"att1ID\";\r\n+\tprivate static final String ATT_2_ID = \"att2ID\";\r\n+\tprivate static final String ATT_3_ID = \"att3ID\";\r\n+\r\n+\tprivate static final String ATT_1_DESCRIPTION = \"att1des\";\r\n+\tprivate static final String ATT_2_DESCRIPTION = \"att2des\";\r\n+\tprivate static final String ATT_3_DESCRIPTION = \"att3des\";\r\n+\r\n+\tprivate static final String ATT_1_CATEGORY = \"AOCS\";\r\n+\tprivate static final double ATT_2_VALUE = 322.23;\r\n+\r\n+\tprivate Concept requirementsConcept;\r\n+\tprivate Concept conceptPS;\r\n+\r\n+\tprivate RequirementAttribute attributeName;\r\n+\tprivate RequirementAttribute attributeID;\r\n+\tprivate RequirementAttribute attributeDescription;\r\n+\tprivate RequirementAttribute attributeCategory;\r\n+\tprivate RequirementAttribute attributeValue;\r\n+\t\r\n+\tprivate RequirementsSpecification targetSpec;\r\n+\tprivate RequirementGroup targetSpecGroup;\r\n+\tprivate RequirementType reqImportType;\r\n+\tprivate RequirementsConfiguration configuration;\r\n+\tprivate StructuralElementInstance reqContainerSEI;\r\n+\tprivate StructuralElementInstance rccSEI;\r\n+\t\r\n+\t@Before\r\n+\tpublic void setUp() throws CoreException {\r\n+\t\tsuper.setUp();\r\n+\t\trequirementsConcept = loadConceptFromPlugin(\"de.dlr.sc.virsat.model.extension.requirements\");\r\n+\t\tconceptPS = loadConceptFromPlugin(\"de.dlr.sc.virsat.model.extension.ps\");\r\n+\t\taddEditingDomainAndRepository();\r\n+\t\teditingDomain.getVirSatCommandStack().execute(new RecordingCommand(editingDomain) {\r\n+\t\t\t@Override\r\n+\t\t\tprotected void doExecute() {\r\n+\t\t\t\trepository.getActiveConcepts().add(requirementsConcept);\r\n+\t\t\t\tConfigurationTree configurationTree = new ConfigurationTree(conceptPS);\r\n+\t\t\t\tElementConfiguration reqContainer = new ElementConfiguration(conceptPS);\r\n+\t\t\t\tRequirementsConfigurationCollection rcc = new RequirementsConfigurationCollection(requirementsConcept);\r\n+\t\t\t\tconfigurationTree.add(reqContainer);\r\n+\t\t\t\treqContainerSEI = reqContainer.getStructuralElementInstance();\r\n+\t\t\t\trccSEI = rcc.getStructuralElementInstance();\r\n+\t\t\t\trepository.getRootEntities().add(reqContainerSEI);\r\n+\t\t\t\trepository.getRootEntities().add(rccSEI);\r\n+\t\t\t\teditingDomain.getResourceSet().getAndAddStructuralElementInstanceResource(reqContainerSEI);\r\n+\t\t\t\teditingDomain.getResourceSet().getAndAddStructuralElementInstanceResource(rccSEI);\r\n+\t\t\t}\r\n+\t\t});\r\n+\t\teditingDomain.saveAll();\r\n+\t}\r\n+\r\n+\t@Test\r\n+\tpublic void testLoadRequirementsToRequirementSpecification() {\r\n+\t\t\r\n+\t\teditingDomain.getVirSatCommandStack().execute(new RecordingCommand(editingDomain) {\r\n+\t\t\t@Override\r\n+\t\t\tprotected void doExecute() {\r\n+\t\t\t\ttargetSpec = new RequirementsSpecification(requirementsConcept);\r\n+\t\t\t\treqContainerSEI.getCategoryAssignments().clear();\r\n+\t\t\t\treqContainerSEI.getCategoryAssignments().add(targetSpec.getTypeInstance());\r\n+\t\t\t\treqImportType = createReqTypeWith3Attributes();\r\n+\t\t\t}\r\n+\t\t});\r\n+\t\tList<List<String>> csvContentMatrix = createCSVContentMatrix();\r\n+\t\tMap<Integer, RequirementAttribute> mapping = new HashMap<>();\r\n+\t\tfor (RequirementAttribute att : reqImportType.getAttributes()) {\r\n+\t\t\tint index = reqImportType.getAttributes().indexOf(att);\r\n+\t\t\tmapping.put(index, att);\r\n+\t\t}\r\n+\r\n+\t\tCsvRequirementsImporter importer = new CsvRequirementsImporter();\r\n+\t\tCommand importCommand = importer.loadRequirements(editingDomain, csvContentMatrix, targetSpec.getRequirements(),\r\n+\t\t\t\tmapping, reqImportType);\r\n+\t\teditingDomain.getVirSatCommandStack().execute(importCommand);\r\n+\t\t\r\n+\t\tfinal int numberSimpleAtt = 3;\r\n+\t\tRequirement importedReq1 = (Requirement) targetSpec.getRequirements().get(0);\r\n+\t\tRequirement importedReq2 = (Requirement) targetSpec.getRequirements().get(1);\r\n+\t\tRequirement importedReq3 = (Requirement) targetSpec.getRequirements().get(2);\r\n+\t\t\r\n+\t\tassertEquals(\"Requirement type not set\", importedReq1.getReqType(), reqImportType);\r\n+\t\tassertEquals(\"Requirement type not set\", importedReq2.getReqType(), reqImportType);\r\n+\t\tassertEquals(\"Requirement type not set\", importedReq3.getReqType(), reqImportType);\r\n+\t\t\r\n+\t\tassertEquals(\"Should only import first relvant elements for specified types\", \r\n+\t\t\t\timportedReq1.getElements().size(), numberSimpleAtt);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq1.getElements().get(0).getValue(), ATT_1_NAME);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq1.getElements().get(1).getValue(), ATT_1_ID);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq1.getElements().get(2).getValue(), ATT_1_DESCRIPTION);\r\n+\t\t\r\n+\t\tassertEquals(\"Should only import first relvant elements for specified types\", \r\n+\t\t\t\timportedReq2.getElements().size(), numberSimpleAtt);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq2.getElements().get(0).getValue(), ATT_2_NAME);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq2.getElements().get(1).getValue(), ATT_2_ID);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq2.getElements().get(2).getValue(), ATT_2_DESCRIPTION);\r\n+\t\t\r\n+\t\tassertEquals(\"Should only import first relvant elements for specified types\", \r\n+\t\t\t\timportedReq3.getElements().size(), numberSimpleAtt);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq3.getElements().get(0).getValue(), ATT_3_NAME);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq3.getElements().get(1).getValue(), ATT_3_ID);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq3.getElements().get(2).getValue(), ATT_3_DESCRIPTION);\r\n+\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testLoadRequirementsToRequirementGroup() {\r\n+\r\n+\t\teditingDomain.getVirSatCommandStack().execute(new RecordingCommand(editingDomain) {\r\n+\t\t\t@Override\r\n+\t\t\tprotected void doExecute() {\r\n+\t\t\t\ttargetSpecGroup = new RequirementGroup(requirementsConcept);\r\n+\t\t\t\treqContainerSEI.getCategoryAssignments().clear();\r\n+\t\t\t\treqContainerSEI.getCategoryAssignments().add(targetSpecGroup.getTypeInstance());\r\n+\t\t\t\treqImportType = createReqTypeWith3Attributes();\r\n+\t\t\t}\r\n+\t\t});\r\n+\t\tList<List<String>> csvContentMatrix = createCSVContentMatrix();\r\n+\t\tMap<Integer, RequirementAttribute> mapping = new HashMap<>();\r\n+\t\tfor (RequirementAttribute att : reqImportType.getAttributes()) {\r\n+\t\t\tint index = reqImportType.getAttributes().indexOf(att);\r\n+\t\t\tmapping.put(index, att);\r\n+\t\t}\r\n+\r\n+\t\tCsvRequirementsImporter importer = new CsvRequirementsImporter();\r\n+\t\tCommand importCommand = importer.loadRequirements(editingDomain, csvContentMatrix, targetSpecGroup.getChildren(),\r\n+\t\t\t\tmapping, reqImportType);\r\n+\t\teditingDomain.getVirSatCommandStack().execute(importCommand);\r\n+\t\t\r\n+\t\tfinal int numberSimpleAtt = 3;\r\n+\t\tRequirement importedReq1 = (Requirement) targetSpecGroup.getChildren().get(0);\r\n+\t\tRequirement importedReq2 = (Requirement) targetSpecGroup.getChildren().get(1);\r\n+\t\tRequirement importedReq3 = (Requirement) targetSpecGroup.getChildren().get(2);\r\n+\t\t\r\n+\t\tassertEquals(\"Requirement type not set\", importedReq1.getReqType(), reqImportType);\r\n+\t\tassertEquals(\"Requirement type not set\", importedReq2.getReqType(), reqImportType);\r\n+\t\tassertEquals(\"Requirement type not set\", importedReq3.getReqType(), reqImportType);\r\n+\t\t\r\n+\t\tassertEquals(\"Should only import first relvant elements for specified types\", \r\n+\t\t\t\timportedReq1.getElements().size(), numberSimpleAtt);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq1.getElements().get(0).getValue(), ATT_1_NAME);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq1.getElements().get(1).getValue(), ATT_1_ID);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq1.getElements().get(2).getValue(), ATT_1_DESCRIPTION);\r\n+\t\t\r\n+\t\tassertEquals(\"Should only import first relvant elements for specified types\", \r\n+\t\t\t\timportedReq2.getElements().size(), numberSimpleAtt);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq2.getElements().get(0).getValue(), ATT_2_NAME);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq2.getElements().get(1).getValue(), ATT_2_ID);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq2.getElements().get(2).getValue(), ATT_2_DESCRIPTION);\r\n+\t\t\r\n+\t\tassertEquals(\"Should only import first relvant elements for specified types\", \r\n+\t\t\t\timportedReq3.getElements().size(), numberSimpleAtt);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq3.getElements().get(0).getValue(), ATT_3_NAME);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq3.getElements().get(1).getValue(), ATT_3_ID);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq3.getElements().get(2).getValue(), ATT_3_DESCRIPTION);\r\n+\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testLoadRequirementsWithEnumeration() {\r\n+\r\n+\t\teditingDomain.getVirSatCommandStack().execute(new RecordingCommand(editingDomain) {\r\n+\t\t\t@Override\r\n+\t\t\tprotected void doExecute() {\r\n+\t\t\t\ttargetSpec = new RequirementsSpecification(requirementsConcept);\r\n+\t\t\t\treqContainerSEI.getCategoryAssignments().clear();\r\n+\t\t\t\treqContainerSEI.getCategoryAssignments().add(targetSpec.getTypeInstance());\r\n+\t\t\t\treqImportType = createReqTypeWithCategory();\r\n+\t\t\t}\r\n+\t\t});\r\n+\t\tList<List<String>> csvContentMatrix = createCSVContentMatrix();\r\n+\t\tMap<Integer, RequirementAttribute> mapping = new HashMap<>();\r\n+\t\tfor (RequirementAttribute att : reqImportType.getAttributes()) {\r\n+\t\t\tint index = reqImportType.getAttributes().indexOf(att);\r\n+\t\t\tmapping.put(index, att);\r\n+\t\t}\r\n+\r\n+\t\tCsvRequirementsImporter importer = new CsvRequirementsImporter();\r\n+\t\tCommand importCommand = importer.loadRequirements(editingDomain, csvContentMatrix, targetSpec.getRequirements(),\r\n+\t\t\t\tmapping, reqImportType);\r\n+\t\teditingDomain.getVirSatCommandStack().execute(importCommand);\r\n+\t\t\r\n+\t\tfinal int numberExpectedAtt = 4;\r\n+\t\tfinal int indexCategory = 3;\r\n+\t\tRequirement importedReq1 = (Requirement) targetSpec.getRequirements().get(0);\r\n+\t\t\r\n+\t\tassertEquals(\"Requirement type not set\", importedReq1.getReqType(), reqImportType);\r\n+\t\t\r\n+\t\tassertEquals(\"Number attributes is not correct\", \r\n+\t\t\t\timportedReq1.getElements().size(), numberExpectedAtt);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq1.getElements().get(0).getValue(), ATT_1_NAME);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq1.getElements().get(1).getValue(), ATT_1_ID);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq1.getElements().get(2).getValue(), ATT_1_DESCRIPTION);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq1.getElements().get(indexCategory).getValue(), ATT_1_CATEGORY);\r\n+\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testLoadRequirementsWithDoubleValue() {\r\n+\r\n+\t\teditingDomain.getVirSatCommandStack().execute(new RecordingCommand(editingDomain) {\r\n+\t\t\t@Override\r\n+\t\t\tprotected void doExecute() {\r\n+\t\t\t\ttargetSpec = new RequirementsSpecification(requirementsConcept);\r\n+\t\t\t\treqContainerSEI.getCategoryAssignments().clear();\r\n+\t\t\t\treqContainerSEI.getCategoryAssignments().add(targetSpec.getTypeInstance());\r\n+\t\t\t\treqImportType = createReqTypeWithDoubleValue();\r\n+\t\t\t}\r\n+\t\t});\r\n+\t\tList<List<String>> csvContentMatrix = createCSVContentMatrix();\r\n+\t\tMap<Integer, RequirementAttribute> mapping = new HashMap<>();\r\n+\t\tfor (RequirementAttribute att : reqImportType.getAttributes()) {\r\n+\t\t\tint index = reqImportType.getAttributes().indexOf(att);\r\n+\t\t\tmapping.put(index, att);\r\n+\t\t}\r\n+\r\n+\t\tCsvRequirementsImporter importer = new CsvRequirementsImporter();\r\n+\t\tCommand importCommand = importer.loadRequirements(editingDomain, csvContentMatrix, targetSpec.getRequirements(),\r\n+\t\t\t\tmapping, reqImportType);\r\n+\t\teditingDomain.getVirSatCommandStack().execute(importCommand);\r\n+\t\t\r\n+\t\tfinal int numberExpectedAtt = 4;\r\n+\t\tfinal int indexCategory = 3;\r\n+\t\tRequirement importedReq2 = (Requirement) targetSpec.getRequirements().get(1);\r\n+\t\t\r\n+\t\tassertEquals(\"Requirement type not set\", importedReq2.getReqType(), reqImportType);\r\n+\t\t\r\n+\t\tassertEquals(\"Number attributes is not correct\", \r\n+\t\t\t\timportedReq2.getElements().size(), numberExpectedAtt);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq2.getElements().get(0).getValue(), ATT_2_NAME);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq2.getElements().get(1).getValue(), ATT_2_ID);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq2.getElements().get(2).getValue(), ATT_2_DESCRIPTION);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq2.getElements().get(indexCategory).getValue(), ATT_2_VALUE + \"\");\r\n+\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testLoadRequirementsWithoutType() {\r\n+\r\n+\t\teditingDomain.getVirSatCommandStack().execute(new RecordingCommand(editingDomain) {\r\n+\t\t\t@Override\r\n+\t\t\tprotected void doExecute() {\r\n+\t\t\t\ttargetSpec = new RequirementsSpecification(requirementsConcept);\r\n+\t\t\t\treqContainerSEI.getCategoryAssignments().clear();\r\n+\t\t\t\treqContainerSEI.getCategoryAssignments().add(targetSpec.getTypeInstance());\r\n+\t\t\t\tconfiguration = new RequirementsConfiguration(requirementsConcept);\r\n+\t\t\t\trccSEI.getCategoryAssignments().add(configuration.getTypeInstance());\r\n+\t\t\t}\r\n+\t\t});\r\n+\t\t\r\n+\t\tList<List<String>> csvContentMatrix = createCSVContentMatrix(true);\r\n+\t\tMap<Integer, RequirementAttribute> mapping = new HashMap<>();\r\n+\r\n+\t\tCsvRequirementsImporter importer = new CsvRequirementsImporter();\r\n+\t\tRequirementType newType = importer.prepareRequirementType(requirementsConcept, csvContentMatrix.get(0));\r\n+\t\tfor (RequirementAttribute att : newType.getAttributes()) {\r\n+\t\t\tint index = newType.getAttributes().indexOf(att);\r\n+\t\t\tmapping.put(index, att);\r\n+\t\t}\r\n+\t\t\r\n+\t\tcsvContentMatrix.remove(0); //remove header line\r\n+\t\tCommand importCommand = importer.loadRequirements(editingDomain, csvContentMatrix, targetSpec.getRequirements(),\r\n+\t\t\t\tmapping, configuration, newType);\r\n+\t\teditingDomain.getVirSatCommandStack().execute(importCommand);\r\n+\t\t\r\n+\t\tfinal int numberExpectedAtt = 4;\r\n+\t\tfinal int indexValueAtt = 3;\r\n+\t\tRequirement importedReq = (Requirement) targetSpec.getRequirements().get(0);\r\n+\t\t\r\n+\r\n+\t\tRequirementType importedReqType = importedReq.getReqType();\r\n+\t\tassertEquals(\"Type created\", importedReqType, configuration.getTypeDefinitions().get(0));\r\n+\t\tassertEquals(\"Number of attributes added correctly\", importedReqType.getAttributes().size(), numberExpectedAtt);\r\n+\t\tassertEquals(\"Attributes should be called as CSV header\", importedReqType.getAttributes().get(0).getName(), NAME_HEADER_NAME);\r\n+\t\tassertEquals(\"Attributes should be called as CSV header\", importedReqType.getAttributes().get(1).getName(), NAME_HEADER_ID);\r\n+\t\tassertEquals(\"Attributes should be called as CSV header\", importedReqType.getAttributes().get(2).getName(), NAME_HEADER_DES);\r\n+\t\tassertEquals(\"Attributes should be called as CSV header\", importedReqType.getAttributes().get(indexValueAtt).getName(), NAME_HEADER_VALUE);\r\n+\r\n+\t\t//Check imported values\r\n+\t\tRequirement importedReq1 = (Requirement) targetSpec.getRequirements().get(0);\r\n+\t\tRequirement importedReq2 = (Requirement) targetSpec.getRequirements().get(1);\r\n+\t\tRequirement importedReq3 = (Requirement) targetSpec.getRequirements().get(2);\r\n+\t\t\r\n+\t\tassertEquals(\"Should match number of max elements\", \r\n+\t\t\t\timportedReq1.getElements().size(), numberExpectedAtt);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq1.getElements().get(0).getValue(), ATT_1_NAME);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq1.getElements().get(1).getValue(), ATT_1_ID);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq1.getElements().get(2).getValue(), ATT_1_DESCRIPTION);\r\n+\t\t\r\n+\t\tassertEquals(\"Should match number of max elements\", \r\n+\t\t\t\timportedReq2.getElements().size(), numberExpectedAtt);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq2.getElements().get(0).getValue(), ATT_2_NAME);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq2.getElements().get(1).getValue(), ATT_2_ID);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq2.getElements().get(2).getValue(), ATT_2_DESCRIPTION);\r\n+\t\t\r\n+\t\tassertEquals(\"Should match number of max elements\", \r\n+\t\t\t\timportedReq3.getElements().size(), numberExpectedAtt);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq3.getElements().get(0).getValue(), ATT_3_NAME);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq3.getElements().get(1).getValue(), ATT_3_ID);\r\n+\t\tassertEquals(\"Attribute not contained\", importedReq3.getElements().get(2).getValue(), ATT_3_DESCRIPTION);\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testTypeCreationWithEnumeration() {\r\n+\r\n+\t\teditingDomain.getVirSatCommandStack().execute(new RecordingCommand(editingDomain) {\r\n+\t\t\t@Override\r\n+\t\t\tprotected void doExecute() {\r\n+\t\t\t\ttargetSpec = new RequirementsSpecification(requirementsConcept);\r\n+\t\t\t\treqContainerSEI.getCategoryAssignments().clear();\r\n+\t\t\t\treqContainerSEI.getCategoryAssignments().add(targetSpec.getTypeInstance());\r\n+\t\t\t\tconfiguration = new RequirementsConfiguration(requirementsConcept);\r\n+\t\t\t\trccSEI.getCategoryAssignments().add(configuration.getTypeInstance());\r\n+\t\t\t}\r\n+\t\t});\r\n+\t\t\r\n+\t\tList<List<String>> csvContentMatrix = createCSVContentMatrix(true);\r\n+\t\tMap<Integer, RequirementAttribute> mapping = new HashMap<>();\r\n+\r\n+\t\tCsvRequirementsImporter importer = new CsvRequirementsImporter();\r\n+\t\t\r\n+\t\t// Get basic type suggestion from importer\r\n+\t\tRequirementType newType = importer.prepareRequirementType(requirementsConcept, csvContentMatrix.get(0));\r\n+\t\tfor (RequirementAttribute att : newType.getAttributes()) {\r\n+\t\t\tint index = newType.getAttributes().indexOf(att);\r\n+\t\t\tmapping.put(index, att);\r\n+\t\t}\r\n+\t\t// Customize to our wishes, change one attribute to enumeration type\r\n+\t\tRequirementAttribute attType = newType.getAttributes().get(0);\r\n+\t\tattType.setType(RequirementAttribute.TYPE_Enumeration_NAME);\r\n+\t\t// Get enumeration literals from the data to import\r\n+\t\tcsvContentMatrix.remove(0); //remove header line\r\n+\t\timporter.customizeReqTypeFromData(newType, csvContentMatrix, mapping);\r\n+\t\t\r\n+\t\tfinal int EXPECTED_LITERAL_NUMBER = 3; // Three data lines, each name is added as enumeration literal\r\n+\t\tassertEquals(EXPECTED_LITERAL_NUMBER, attType.getEnumeration().getLiterals().size());\r\n+\t\t\r\n+\t\tList<String> literals =  attType.getEnumeration().getLiterals().stream().\r\n+\t\t\tmap(literal -> literal.getName()).\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM1Mzg1MA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r448353850", "bodyText": "Let's add a newline at the end", "author": "andriikovalov-dlr", "createdAt": "2020-07-01T13:14:11Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/Activator.java", "diffHunk": "@@ -61,6 +63,12 @@ public static Activator getDefault() {\n \tpublic static String getPluginId() {\r\n \t\treturn pluginId;\r\n \t}\r\n-\r\n-}\r\n-\r\n+\t/**\r\n+\t * Sets the plugin id \r\n+\t *\r\n+\t * @param pluginId the plugin id\r\n+\t */\r\n+\tprivate static void setPluginId(String pluginId) {\r\n+\t\tActivator.pluginId = pluginId;\r\n+\t}\r\n+}", "originalCommit": "6318f6ed87741459d09d8d7b42215c73502f303d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM1NDk0MQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r448354941", "bodyText": "Let's add a newline", "author": "andriikovalov-dlr", "createdAt": "2020-07-01T13:15:50Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/Activator.java", "diffHunk": "@@ -59,6 +54,12 @@ public static Activator getDefault() {\n \tpublic static String getPluginId() {\r\n \t\treturn pluginId;\r\n \t}\r\n-\r\n-}\r\n-\r\n+\t/**\r\n+\t * Sets the plugin id \r\n+\t *\r\n+\t * @param pluginId the plugin id\r\n+\t */\r\n+\tprivate static void setPluginId(String pluginId) {\r\n+\t\tActivator.pluginId = pluginId;\r\n+\t}\r\n+}", "originalCommit": "6318f6ed87741459d09d8d7b42215c73502f303d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM2MzQ3Nw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r448363477", "bodyText": "I suggest you either chain a non-regex replace like .replace(\" \", \"\").replace(\"-\", \"\").replace(\"_\", \"\") or make a regex class like .replaceAll(\"[ \\-_]\", \"\") (not sure about escaping)", "author": "andriikovalov-dlr", "createdAt": "2020-07-01T13:29:18Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/model/Requirement.java", "diffHunk": "@@ -86,6 +86,10 @@ protected String getNameFromAttributes() {\n \t\t\t\tnewReqName.append(child.getValue());\r\n \t\t\t}\r\n \t\t}\r\n-\t\treturn newReqName.toString();\r\n+\t\tString reqIdentifierName = newReqName.toString();\r\n+\t\treqIdentifierName = reqIdentifierName.replaceAll(\" \", \"\");\r", "originalCommit": "6318f6ed87741459d09d8d7b42215c73502f303d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc5NjkyMA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r448796920", "bodyText": "Maybe change to super.isComplete() && isDestinationSelected?", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T07:18:03Z", "path": "de.dlr.sc.virsat.uiengine.ui/src/de/dlr/sc/virsat/uiengine/ui/wizard/AImportExportPage.java", "diffHunk": "@@ -228,18 +145,12 @@ public String getDestination() {\n \t}\r\n \r\n \t/**\r\n-\t * Checks if this page is complete\r\n+\t * Checks if the page has been sufficiently filled with user data\r\n \t * \r\n-\t * @return true if the page is complete\r\n-\t */\r\n-\tpublic boolean isSelectionValid() {\r\n-\t\treturn true;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * @param model set the model\r\n+\t * @return true iff the page is complete\r\n \t */\r\n-\tpublic void setModel(Object model) {\r\n-\t\tthis.model = model;\r\n+\tpublic boolean isComplete() {\r\n+\t\treturn isDestinationSelected && isSelectionValid();\r", "originalCommit": "6318f6ed87741459d09d8d7b42215c73502f303d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgxMjA0MA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r448812040", "bodyText": "Shall we maybe create a variable for CA type name so that we don't need to get it twice?", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T07:47:32Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvFileReqTypeSelectionPage.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Text;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfigurationCollection;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage;\r\n+\r\n+/**\r\n+ * A page to select a CSV file to import and the target model element\r\n+ *\r\n+ */\r\n+public class CsvFileReqTypeSelectionPage extends AImportExportPage implements ModifyListener {\r\n+\r\n+\tprivate static final String[] FILE_EXTENSIONS = { \"*.csv\" };\r\n+\tprotected static final int COLUMNS = 2;\r\n+\tprotected static final int WITH_TEXT = 200;\r\n+\r\n+\tprivate static final String SPARATOR_INPUT_LABEL = \"Column sperator:\";\r\n+\tprivate static final String DEFAULT_SEPARATOR = \";\";\r\n+\r\n+\tprivate static final String HEADER_LINE_LABEL = \"CSV header line number:\";\r\n+\tprivate static final String DATA_LINE_START_LABEL = \"CSV start data line number:\";\r\n+\tprivate static final String DATA_LINE_END_LABEL = \"CSV end data line number (Optional):\";\r\n+\r\n+\tprivate Text seperatorField;\r\n+\tprivate Text headerNumberField;\r\n+\tprivate Text dataNumberStartField;\r\n+\tprivate Text dataNumberEndField;\r\n+\t\r\n+\tprivate CsvTypeReviewPage typeReviewPage;\r\n+\tprivate CsvImportWizard wizard;\r\n+\r\n+\tprotected List<String> csvHeader;\r\n+\tprotected RequirementType reqType;\r\n+\r\n+\t/**\r\n+\t * Standard constructor\r\n+\t * \r\n+\t * @param model\r\n+\t *            the root model\r\n+\t * @param containingWizard the containing wizard\r\n+\t * @param typeReviewPage\r\n+\t * \t\t\t  the page that recieves the requirement type\r\n+\t */\r\n+\tprotected CsvFileReqTypeSelectionPage(IContainer model, CsvImportWizard containingWizard, CsvTypeReviewPage typeReviewPage) {\r\n+\t\tsuper(\"Requirements CSV Import\");\r\n+\t\tsetTitle(\"Requirements CSV Import\");\r\n+\t\tsetModel(model);\r\n+\t\tthis.typeReviewPage = typeReviewPage;\r\n+\t\tthis.wizard = containingWizard;\r\n+\t\tsetDescription(\r\n+\t\t\t\t\"Please select a CSV file and a requirement type for the imported requirements. To create a new type, select a container configuration.\");\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\t\tsuper.createControl(parent);\r\n+\r\n+\t\tcreateFileDestinationUI();\r\n+\t\tcreateCsvPropertiesUI(parent);\r\n+\r\n+\t\tcreateTreeViewer();\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create the UI for CSV properties\r\n+\t * \r\n+\t * @param parent\r\n+\t *            the parent composite\r\n+\t */\r\n+\tprivate void createCsvPropertiesUI(Composite parent) {\r\n+\t\tComposite propertiesComposite = new Composite((Composite) getControl(), SWT.FILL);\r\n+\t\tpropertiesComposite.setLayout(new GridLayout(COLUMNS, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tpropertiesComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabel.setText(SPARATOR_INPUT_LABEL);\r\n+\r\n+\t\tseperatorField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tseperatorField.setLayoutData(data);\r\n+\t\tseperatorField.setText(DEFAULT_SEPARATOR);\r\n+\t\tseperatorField.addModifyListener(this);\r\n+\r\n+\t\tLabel labelHeaderNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelHeaderNumber.setText(HEADER_LINE_LABEL);\r\n+\r\n+\t\theaderNumberField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\theaderNumberField.setLayoutData(data);\r\n+\t\theaderNumberField.addModifyListener(this);\r\n+\t\theaderNumberField.setText(\"1\");\r\n+\r\n+\t\tLabel labelDataNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataNumber.setText(DATA_LINE_START_LABEL);\r\n+\r\n+\t\tdataNumberStartField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberStartField.setLayoutData(data);\r\n+\t\tdataNumberStartField.addModifyListener(this);\r\n+\t\tdataNumberStartField.setText(\"2\");\r\n+\t\t\r\n+\t\tLabel labelDataEndNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataEndNumber.setText(DATA_LINE_END_LABEL);\r\n+\r\n+\t\tdataNumberEndField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberEndField.setLayoutData(data);\r\n+\t\tdataNumberEndField.addModifyListener(this);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a tree viewer with filters to show only relevant tree elements for\r\n+\t * CSV import /export\r\n+\t */\r\n+\tprotected void createTreeViewer() {\r\n+\t\tTreeViewer treeViewer = createTreeUI();\r\n+\t\tVirSatFilteredWrappedTreeContentProvider filteredCp = (VirSatFilteredWrappedTreeContentProvider) treeViewer\r\n+\t\t\t\t.getContentProvider();\r\n+\t\tfilteredCp.addClassFilter(CategoryAssignment.class);\r\n+\t\tfilteredCp.addClassFilter(ArrayInstance.class);\r\n+\t\tfilteredCp.addClassFilter(ComposedPropertyInstance.class);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(\r\n+\t\t\t\tRequirementsConfigurationCollection.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic boolean isSelectionValid() {\r\n+\t\tObject selection = getSelection();\r\n+\t\tif (selection instanceof CategoryAssignment) {\r\n+\t\t\treturn ((CategoryAssignment) selection).getType().getFullQualifiedName()\r", "originalCommit": "6318f6ed87741459d09d8d7b42215c73502f303d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg2NTk4MA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r448865980", "bodyText": "I suggest we insert the override annotation and remove the javadoc", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T09:18:23Z", "path": "de.dlr.sc.virsat.uiengine.ui/src/de/dlr/sc/virsat/uiengine/ui/wizard/AImportExportPage.java", "diffHunk": "@@ -228,18 +145,12 @@ public String getDestination() {\n \t}\r\n \r\n \t/**\r\n-\t * Checks if this page is complete\r\n+\t * Checks if the page has been sufficiently filled with user data\r\n \t * \r\n-\t * @return true if the page is complete\r\n-\t */\r\n-\tpublic boolean isSelectionValid() {\r\n-\t\treturn true;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * @param model set the model\r\n+\t * @return true iff the page is complete\r\n \t */\r\n-\tpublic void setModel(Object model) {\r\n-\t\tthis.model = model;\r\n+\tpublic boolean isComplete() {\r", "originalCommit": "6318f6ed87741459d09d8d7b42215c73502f303d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg2Njg4MA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r448866880", "bodyText": "Let's remove this useless comment", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T09:19:58Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvFileReqTypeSelectionPage.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Text;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfigurationCollection;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage;\r\n+\r\n+/**\r\n+ * A page to select a CSV file to import and the target model element\r\n+ *\r\n+ */\r\n+public class CsvFileReqTypeSelectionPage extends AImportExportPage implements ModifyListener {\r\n+\r\n+\tprivate static final String[] FILE_EXTENSIONS = { \"*.csv\" };\r\n+\tprotected static final int COLUMNS = 2;\r\n+\tprotected static final int WITH_TEXT = 200;\r\n+\r\n+\tprivate static final String SPARATOR_INPUT_LABEL = \"Column sperator:\";\r\n+\tprivate static final String DEFAULT_SEPARATOR = \";\";\r\n+\r\n+\tprivate static final String HEADER_LINE_LABEL = \"CSV header line number:\";\r\n+\tprivate static final String DATA_LINE_START_LABEL = \"CSV start data line number:\";\r\n+\tprivate static final String DATA_LINE_END_LABEL = \"CSV end data line number (Optional):\";\r\n+\r\n+\tprivate Text seperatorField;\r\n+\tprivate Text headerNumberField;\r\n+\tprivate Text dataNumberStartField;\r\n+\tprivate Text dataNumberEndField;\r\n+\t\r\n+\tprivate CsvTypeReviewPage typeReviewPage;\r\n+\tprivate CsvImportWizard wizard;\r\n+\r\n+\tprotected List<String> csvHeader;\r\n+\tprotected RequirementType reqType;\r\n+\r\n+\t/**\r\n+\t * Standard constructor\r\n+\t * \r\n+\t * @param model\r\n+\t *            the root model\r\n+\t * @param containingWizard the containing wizard\r\n+\t * @param typeReviewPage\r\n+\t * \t\t\t  the page that recieves the requirement type\r\n+\t */\r\n+\tprotected CsvFileReqTypeSelectionPage(IContainer model, CsvImportWizard containingWizard, CsvTypeReviewPage typeReviewPage) {\r\n+\t\tsuper(\"Requirements CSV Import\");\r\n+\t\tsetTitle(\"Requirements CSV Import\");\r\n+\t\tsetModel(model);\r\n+\t\tthis.typeReviewPage = typeReviewPage;\r\n+\t\tthis.wizard = containingWizard;\r\n+\t\tsetDescription(\r\n+\t\t\t\t\"Please select a CSV file and a requirement type for the imported requirements. To create a new type, select a container configuration.\");\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\t\tsuper.createControl(parent);\r\n+\r\n+\t\tcreateFileDestinationUI();\r\n+\t\tcreateCsvPropertiesUI(parent);\r\n+\r\n+\t\tcreateTreeViewer();\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create the UI for CSV properties\r\n+\t * \r\n+\t * @param parent\r\n+\t *            the parent composite\r\n+\t */\r\n+\tprivate void createCsvPropertiesUI(Composite parent) {\r\n+\t\tComposite propertiesComposite = new Composite((Composite) getControl(), SWT.FILL);\r\n+\t\tpropertiesComposite.setLayout(new GridLayout(COLUMNS, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tpropertiesComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabel.setText(SPARATOR_INPUT_LABEL);\r\n+\r\n+\t\tseperatorField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tseperatorField.setLayoutData(data);\r\n+\t\tseperatorField.setText(DEFAULT_SEPARATOR);\r\n+\t\tseperatorField.addModifyListener(this);\r\n+\r\n+\t\tLabel labelHeaderNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelHeaderNumber.setText(HEADER_LINE_LABEL);\r\n+\r\n+\t\theaderNumberField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\theaderNumberField.setLayoutData(data);\r\n+\t\theaderNumberField.addModifyListener(this);\r\n+\t\theaderNumberField.setText(\"1\");\r\n+\r\n+\t\tLabel labelDataNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataNumber.setText(DATA_LINE_START_LABEL);\r\n+\r\n+\t\tdataNumberStartField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberStartField.setLayoutData(data);\r\n+\t\tdataNumberStartField.addModifyListener(this);\r\n+\t\tdataNumberStartField.setText(\"2\");\r\n+\t\t\r\n+\t\tLabel labelDataEndNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataEndNumber.setText(DATA_LINE_END_LABEL);\r\n+\r\n+\t\tdataNumberEndField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberEndField.setLayoutData(data);\r\n+\t\tdataNumberEndField.addModifyListener(this);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a tree viewer with filters to show only relevant tree elements for\r\n+\t * CSV import /export\r\n+\t */\r\n+\tprotected void createTreeViewer() {\r\n+\t\tTreeViewer treeViewer = createTreeUI();\r\n+\t\tVirSatFilteredWrappedTreeContentProvider filteredCp = (VirSatFilteredWrappedTreeContentProvider) treeViewer\r\n+\t\t\t\t.getContentProvider();\r\n+\t\tfilteredCp.addClassFilter(CategoryAssignment.class);\r\n+\t\tfilteredCp.addClassFilter(ArrayInstance.class);\r\n+\t\tfilteredCp.addClassFilter(ComposedPropertyInstance.class);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(\r\n+\t\t\t\tRequirementsConfigurationCollection.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic boolean isSelectionValid() {\r\n+\t\tObject selection = getSelection();\r\n+\t\tif (selection instanceof CategoryAssignment) {\r\n+\t\t\treturn ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t.equals(RequirementsConfiguration.FULL_QUALIFIED_CATEGORY_NAME)\r\n+\t\t\t\t\t|| ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t\t\t.equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME);\r\n+\t\t}\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tprotected String[] getSupportedFileEndings() {\r\n+\t\treturn FILE_EXTENSIONS;\r\n+\t}\r\n+\r\n+\t/*\r", "originalCommit": "6318f6ed87741459d09d8d7b42215c73502f303d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1MjQ3Mw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449052473", "bodyText": "Since the nested if doesn't have an else or anything after it, I suggest adding it into the first if. Also let's use && instead of &", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T14:41:54Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvFileReqTypeSelectionPage.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Text;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfigurationCollection;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage;\r\n+\r\n+/**\r\n+ * A page to select a CSV file to import and the target model element\r\n+ *\r\n+ */\r\n+public class CsvFileReqTypeSelectionPage extends AImportExportPage implements ModifyListener {\r\n+\r\n+\tprivate static final String[] FILE_EXTENSIONS = { \"*.csv\" };\r\n+\tprotected static final int COLUMNS = 2;\r\n+\tprotected static final int WITH_TEXT = 200;\r\n+\r\n+\tprivate static final String SPARATOR_INPUT_LABEL = \"Column sperator:\";\r\n+\tprivate static final String DEFAULT_SEPARATOR = \";\";\r\n+\r\n+\tprivate static final String HEADER_LINE_LABEL = \"CSV header line number:\";\r\n+\tprivate static final String DATA_LINE_START_LABEL = \"CSV start data line number:\";\r\n+\tprivate static final String DATA_LINE_END_LABEL = \"CSV end data line number (Optional):\";\r\n+\r\n+\tprivate Text seperatorField;\r\n+\tprivate Text headerNumberField;\r\n+\tprivate Text dataNumberStartField;\r\n+\tprivate Text dataNumberEndField;\r\n+\t\r\n+\tprivate CsvTypeReviewPage typeReviewPage;\r\n+\tprivate CsvImportWizard wizard;\r\n+\r\n+\tprotected List<String> csvHeader;\r\n+\tprotected RequirementType reqType;\r\n+\r\n+\t/**\r\n+\t * Standard constructor\r\n+\t * \r\n+\t * @param model\r\n+\t *            the root model\r\n+\t * @param containingWizard the containing wizard\r\n+\t * @param typeReviewPage\r\n+\t * \t\t\t  the page that recieves the requirement type\r\n+\t */\r\n+\tprotected CsvFileReqTypeSelectionPage(IContainer model, CsvImportWizard containingWizard, CsvTypeReviewPage typeReviewPage) {\r\n+\t\tsuper(\"Requirements CSV Import\");\r\n+\t\tsetTitle(\"Requirements CSV Import\");\r\n+\t\tsetModel(model);\r\n+\t\tthis.typeReviewPage = typeReviewPage;\r\n+\t\tthis.wizard = containingWizard;\r\n+\t\tsetDescription(\r\n+\t\t\t\t\"Please select a CSV file and a requirement type for the imported requirements. To create a new type, select a container configuration.\");\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\t\tsuper.createControl(parent);\r\n+\r\n+\t\tcreateFileDestinationUI();\r\n+\t\tcreateCsvPropertiesUI(parent);\r\n+\r\n+\t\tcreateTreeViewer();\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create the UI for CSV properties\r\n+\t * \r\n+\t * @param parent\r\n+\t *            the parent composite\r\n+\t */\r\n+\tprivate void createCsvPropertiesUI(Composite parent) {\r\n+\t\tComposite propertiesComposite = new Composite((Composite) getControl(), SWT.FILL);\r\n+\t\tpropertiesComposite.setLayout(new GridLayout(COLUMNS, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tpropertiesComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabel.setText(SPARATOR_INPUT_LABEL);\r\n+\r\n+\t\tseperatorField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tseperatorField.setLayoutData(data);\r\n+\t\tseperatorField.setText(DEFAULT_SEPARATOR);\r\n+\t\tseperatorField.addModifyListener(this);\r\n+\r\n+\t\tLabel labelHeaderNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelHeaderNumber.setText(HEADER_LINE_LABEL);\r\n+\r\n+\t\theaderNumberField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\theaderNumberField.setLayoutData(data);\r\n+\t\theaderNumberField.addModifyListener(this);\r\n+\t\theaderNumberField.setText(\"1\");\r\n+\r\n+\t\tLabel labelDataNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataNumber.setText(DATA_LINE_START_LABEL);\r\n+\r\n+\t\tdataNumberStartField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberStartField.setLayoutData(data);\r\n+\t\tdataNumberStartField.addModifyListener(this);\r\n+\t\tdataNumberStartField.setText(\"2\");\r\n+\t\t\r\n+\t\tLabel labelDataEndNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataEndNumber.setText(DATA_LINE_END_LABEL);\r\n+\r\n+\t\tdataNumberEndField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberEndField.setLayoutData(data);\r\n+\t\tdataNumberEndField.addModifyListener(this);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a tree viewer with filters to show only relevant tree elements for\r\n+\t * CSV import /export\r\n+\t */\r\n+\tprotected void createTreeViewer() {\r\n+\t\tTreeViewer treeViewer = createTreeUI();\r\n+\t\tVirSatFilteredWrappedTreeContentProvider filteredCp = (VirSatFilteredWrappedTreeContentProvider) treeViewer\r\n+\t\t\t\t.getContentProvider();\r\n+\t\tfilteredCp.addClassFilter(CategoryAssignment.class);\r\n+\t\tfilteredCp.addClassFilter(ArrayInstance.class);\r\n+\t\tfilteredCp.addClassFilter(ComposedPropertyInstance.class);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(\r\n+\t\t\t\tRequirementsConfigurationCollection.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic boolean isSelectionValid() {\r\n+\t\tObject selection = getSelection();\r\n+\t\tif (selection instanceof CategoryAssignment) {\r\n+\t\t\treturn ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t.equals(RequirementsConfiguration.FULL_QUALIFIED_CATEGORY_NAME)\r\n+\t\t\t\t\t|| ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t\t\t.equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME);\r\n+\t\t}\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tprotected String[] getSupportedFileEndings() {\r\n+\t\treturn FILE_EXTENSIONS;\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage#isComplete()\r\n+\t */\r\n+\t@Override\r\n+\tpublic boolean isComplete() {\r\n+\r\n+\t\tif (isDestinationSelected && isCurrentPage()) {\r\n+\t\t\tif (!headerNumberField.getText().equals(\"\") & !seperatorField.getText().equals(\"\") \r", "originalCommit": "6318f6ed87741459d09d8d7b42215c73502f303d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1NTY5Mg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449055692", "bodyText": "This can also be moved to the first if", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T14:46:42Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvFileReqTypeSelectionPage.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Text;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfigurationCollection;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage;\r\n+\r\n+/**\r\n+ * A page to select a CSV file to import and the target model element\r\n+ *\r\n+ */\r\n+public class CsvFileReqTypeSelectionPage extends AImportExportPage implements ModifyListener {\r\n+\r\n+\tprivate static final String[] FILE_EXTENSIONS = { \"*.csv\" };\r\n+\tprotected static final int COLUMNS = 2;\r\n+\tprotected static final int WITH_TEXT = 200;\r\n+\r\n+\tprivate static final String SPARATOR_INPUT_LABEL = \"Column sperator:\";\r\n+\tprivate static final String DEFAULT_SEPARATOR = \";\";\r\n+\r\n+\tprivate static final String HEADER_LINE_LABEL = \"CSV header line number:\";\r\n+\tprivate static final String DATA_LINE_START_LABEL = \"CSV start data line number:\";\r\n+\tprivate static final String DATA_LINE_END_LABEL = \"CSV end data line number (Optional):\";\r\n+\r\n+\tprivate Text seperatorField;\r\n+\tprivate Text headerNumberField;\r\n+\tprivate Text dataNumberStartField;\r\n+\tprivate Text dataNumberEndField;\r\n+\t\r\n+\tprivate CsvTypeReviewPage typeReviewPage;\r\n+\tprivate CsvImportWizard wizard;\r\n+\r\n+\tprotected List<String> csvHeader;\r\n+\tprotected RequirementType reqType;\r\n+\r\n+\t/**\r\n+\t * Standard constructor\r\n+\t * \r\n+\t * @param model\r\n+\t *            the root model\r\n+\t * @param containingWizard the containing wizard\r\n+\t * @param typeReviewPage\r\n+\t * \t\t\t  the page that recieves the requirement type\r\n+\t */\r\n+\tprotected CsvFileReqTypeSelectionPage(IContainer model, CsvImportWizard containingWizard, CsvTypeReviewPage typeReviewPage) {\r\n+\t\tsuper(\"Requirements CSV Import\");\r\n+\t\tsetTitle(\"Requirements CSV Import\");\r\n+\t\tsetModel(model);\r\n+\t\tthis.typeReviewPage = typeReviewPage;\r\n+\t\tthis.wizard = containingWizard;\r\n+\t\tsetDescription(\r\n+\t\t\t\t\"Please select a CSV file and a requirement type for the imported requirements. To create a new type, select a container configuration.\");\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\t\tsuper.createControl(parent);\r\n+\r\n+\t\tcreateFileDestinationUI();\r\n+\t\tcreateCsvPropertiesUI(parent);\r\n+\r\n+\t\tcreateTreeViewer();\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create the UI for CSV properties\r\n+\t * \r\n+\t * @param parent\r\n+\t *            the parent composite\r\n+\t */\r\n+\tprivate void createCsvPropertiesUI(Composite parent) {\r\n+\t\tComposite propertiesComposite = new Composite((Composite) getControl(), SWT.FILL);\r\n+\t\tpropertiesComposite.setLayout(new GridLayout(COLUMNS, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tpropertiesComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabel.setText(SPARATOR_INPUT_LABEL);\r\n+\r\n+\t\tseperatorField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tseperatorField.setLayoutData(data);\r\n+\t\tseperatorField.setText(DEFAULT_SEPARATOR);\r\n+\t\tseperatorField.addModifyListener(this);\r\n+\r\n+\t\tLabel labelHeaderNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelHeaderNumber.setText(HEADER_LINE_LABEL);\r\n+\r\n+\t\theaderNumberField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\theaderNumberField.setLayoutData(data);\r\n+\t\theaderNumberField.addModifyListener(this);\r\n+\t\theaderNumberField.setText(\"1\");\r\n+\r\n+\t\tLabel labelDataNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataNumber.setText(DATA_LINE_START_LABEL);\r\n+\r\n+\t\tdataNumberStartField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberStartField.setLayoutData(data);\r\n+\t\tdataNumberStartField.addModifyListener(this);\r\n+\t\tdataNumberStartField.setText(\"2\");\r\n+\t\t\r\n+\t\tLabel labelDataEndNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataEndNumber.setText(DATA_LINE_END_LABEL);\r\n+\r\n+\t\tdataNumberEndField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberEndField.setLayoutData(data);\r\n+\t\tdataNumberEndField.addModifyListener(this);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a tree viewer with filters to show only relevant tree elements for\r\n+\t * CSV import /export\r\n+\t */\r\n+\tprotected void createTreeViewer() {\r\n+\t\tTreeViewer treeViewer = createTreeUI();\r\n+\t\tVirSatFilteredWrappedTreeContentProvider filteredCp = (VirSatFilteredWrappedTreeContentProvider) treeViewer\r\n+\t\t\t\t.getContentProvider();\r\n+\t\tfilteredCp.addClassFilter(CategoryAssignment.class);\r\n+\t\tfilteredCp.addClassFilter(ArrayInstance.class);\r\n+\t\tfilteredCp.addClassFilter(ComposedPropertyInstance.class);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(\r\n+\t\t\t\tRequirementsConfigurationCollection.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic boolean isSelectionValid() {\r\n+\t\tObject selection = getSelection();\r\n+\t\tif (selection instanceof CategoryAssignment) {\r\n+\t\t\treturn ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t.equals(RequirementsConfiguration.FULL_QUALIFIED_CATEGORY_NAME)\r\n+\t\t\t\t\t|| ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t\t\t.equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME);\r\n+\t\t}\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tprotected String[] getSupportedFileEndings() {\r\n+\t\treturn FILE_EXTENSIONS;\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage#isComplete()\r\n+\t */\r\n+\t@Override\r\n+\tpublic boolean isComplete() {\r\n+\r\n+\t\tif (isDestinationSelected && isCurrentPage()) {\r\n+\t\t\tif (!headerNumberField.getText().equals(\"\") & !seperatorField.getText().equals(\"\") \r\n+\t\t\t\t& !dataNumberStartField.getText().equals(\"\")) {\r\n+\r\n+\t\t\t\tfinal String destination = getDestination();\r\n+\t\r\n+\t\t\t\tif (isSelectionValid()) {\r", "originalCommit": "6318f6ed87741459d09d8d7b42215c73502f303d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4MTIwOQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449081209", "bodyText": "return false?", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T15:24:36Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvFileReqTypeSelectionPage.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Text;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfigurationCollection;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage;\r\n+\r\n+/**\r\n+ * A page to select a CSV file to import and the target model element\r\n+ *\r\n+ */\r\n+public class CsvFileReqTypeSelectionPage extends AImportExportPage implements ModifyListener {\r\n+\r\n+\tprivate static final String[] FILE_EXTENSIONS = { \"*.csv\" };\r\n+\tprotected static final int COLUMNS = 2;\r\n+\tprotected static final int WITH_TEXT = 200;\r\n+\r\n+\tprivate static final String SPARATOR_INPUT_LABEL = \"Column sperator:\";\r\n+\tprivate static final String DEFAULT_SEPARATOR = \";\";\r\n+\r\n+\tprivate static final String HEADER_LINE_LABEL = \"CSV header line number:\";\r\n+\tprivate static final String DATA_LINE_START_LABEL = \"CSV start data line number:\";\r\n+\tprivate static final String DATA_LINE_END_LABEL = \"CSV end data line number (Optional):\";\r\n+\r\n+\tprivate Text seperatorField;\r\n+\tprivate Text headerNumberField;\r\n+\tprivate Text dataNumberStartField;\r\n+\tprivate Text dataNumberEndField;\r\n+\t\r\n+\tprivate CsvTypeReviewPage typeReviewPage;\r\n+\tprivate CsvImportWizard wizard;\r\n+\r\n+\tprotected List<String> csvHeader;\r\n+\tprotected RequirementType reqType;\r\n+\r\n+\t/**\r\n+\t * Standard constructor\r\n+\t * \r\n+\t * @param model\r\n+\t *            the root model\r\n+\t * @param containingWizard the containing wizard\r\n+\t * @param typeReviewPage\r\n+\t * \t\t\t  the page that recieves the requirement type\r\n+\t */\r\n+\tprotected CsvFileReqTypeSelectionPage(IContainer model, CsvImportWizard containingWizard, CsvTypeReviewPage typeReviewPage) {\r\n+\t\tsuper(\"Requirements CSV Import\");\r\n+\t\tsetTitle(\"Requirements CSV Import\");\r\n+\t\tsetModel(model);\r\n+\t\tthis.typeReviewPage = typeReviewPage;\r\n+\t\tthis.wizard = containingWizard;\r\n+\t\tsetDescription(\r\n+\t\t\t\t\"Please select a CSV file and a requirement type for the imported requirements. To create a new type, select a container configuration.\");\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\t\tsuper.createControl(parent);\r\n+\r\n+\t\tcreateFileDestinationUI();\r\n+\t\tcreateCsvPropertiesUI(parent);\r\n+\r\n+\t\tcreateTreeViewer();\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create the UI for CSV properties\r\n+\t * \r\n+\t * @param parent\r\n+\t *            the parent composite\r\n+\t */\r\n+\tprivate void createCsvPropertiesUI(Composite parent) {\r\n+\t\tComposite propertiesComposite = new Composite((Composite) getControl(), SWT.FILL);\r\n+\t\tpropertiesComposite.setLayout(new GridLayout(COLUMNS, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tpropertiesComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabel.setText(SPARATOR_INPUT_LABEL);\r\n+\r\n+\t\tseperatorField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tseperatorField.setLayoutData(data);\r\n+\t\tseperatorField.setText(DEFAULT_SEPARATOR);\r\n+\t\tseperatorField.addModifyListener(this);\r\n+\r\n+\t\tLabel labelHeaderNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelHeaderNumber.setText(HEADER_LINE_LABEL);\r\n+\r\n+\t\theaderNumberField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\theaderNumberField.setLayoutData(data);\r\n+\t\theaderNumberField.addModifyListener(this);\r\n+\t\theaderNumberField.setText(\"1\");\r\n+\r\n+\t\tLabel labelDataNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataNumber.setText(DATA_LINE_START_LABEL);\r\n+\r\n+\t\tdataNumberStartField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberStartField.setLayoutData(data);\r\n+\t\tdataNumberStartField.addModifyListener(this);\r\n+\t\tdataNumberStartField.setText(\"2\");\r\n+\t\t\r\n+\t\tLabel labelDataEndNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataEndNumber.setText(DATA_LINE_END_LABEL);\r\n+\r\n+\t\tdataNumberEndField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberEndField.setLayoutData(data);\r\n+\t\tdataNumberEndField.addModifyListener(this);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a tree viewer with filters to show only relevant tree elements for\r\n+\t * CSV import /export\r\n+\t */\r\n+\tprotected void createTreeViewer() {\r\n+\t\tTreeViewer treeViewer = createTreeUI();\r\n+\t\tVirSatFilteredWrappedTreeContentProvider filteredCp = (VirSatFilteredWrappedTreeContentProvider) treeViewer\r\n+\t\t\t\t.getContentProvider();\r\n+\t\tfilteredCp.addClassFilter(CategoryAssignment.class);\r\n+\t\tfilteredCp.addClassFilter(ArrayInstance.class);\r\n+\t\tfilteredCp.addClassFilter(ComposedPropertyInstance.class);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(\r\n+\t\t\t\tRequirementsConfigurationCollection.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic boolean isSelectionValid() {\r\n+\t\tObject selection = getSelection();\r\n+\t\tif (selection instanceof CategoryAssignment) {\r\n+\t\t\treturn ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t.equals(RequirementsConfiguration.FULL_QUALIFIED_CATEGORY_NAME)\r\n+\t\t\t\t\t|| ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t\t\t.equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME);\r\n+\t\t}\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tprotected String[] getSupportedFileEndings() {\r\n+\t\treturn FILE_EXTENSIONS;\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage#isComplete()\r\n+\t */\r\n+\t@Override\r\n+\tpublic boolean isComplete() {\r\n+\r\n+\t\tif (isDestinationSelected && isCurrentPage()) {\r\n+\t\t\tif (!headerNumberField.getText().equals(\"\") & !seperatorField.getText().equals(\"\") \r\n+\t\t\t\t& !dataNumberStartField.getText().equals(\"\")) {\r\n+\r\n+\t\t\t\tfinal String destination = getDestination();\r\n+\t\r\n+\t\t\t\tif (isSelectionValid()) {\r\n+\t\t\t\t\tCategoryAssignment selection = (CategoryAssignment) getSelection();\r\n+\t\t\t\t\tRepository repository = VirSatResourceSet.getVirSatResourceSet(selection).getRepository();\r\n+\t\t\t\t\tActiveConceptHelper activeConceptHelper = new ActiveConceptHelper(repository);\r\n+\t\t\t\t\tConcept activeReqConcept = activeConceptHelper.getConcept(de.dlr.sc.virsat.model.extension.requirements.Activator.getPluginId());\r\n+\t\t\t\r\n+\t\t\t\t\ttry {\r\n+\t\t\t\t\t\twizard.getReader().setSeparator(getSeparator());\r\n+\t\t\t\t\t\twizard.getReader().setHeaderLine(getHeaderLineNumber());\r\n+\t\t\t\t\t\tcsvHeader = wizard.getReader().readCsvHeadline(destination);\r\n+\t\t\t\t\t} catch (IOException e) {\r\n+\t\t\t\t\t\tStatus status = new Status(Status.ERROR, Activator.getPluginId(),\r\n+\t\t\t\t\t\t\t\t\"CatiaImportWizard: Failed to perform import! Selected file not valid!\", e);\r\n+\t\t\t\t\t\tStatusManager.getManager().handle(status, StatusManager.LOG | StatusManager.SHOW);\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4NDQ5MA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449084490", "bodyText": "Hmm, I'm not sure this should be a part of a check, it's executed on every selection change. Ideally we would do it on the transition to the next page, but apparently there is no easy way to do it.", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T15:27:50Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvFileReqTypeSelectionPage.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Text;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfigurationCollection;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage;\r\n+\r\n+/**\r\n+ * A page to select a CSV file to import and the target model element\r\n+ *\r\n+ */\r\n+public class CsvFileReqTypeSelectionPage extends AImportExportPage implements ModifyListener {\r\n+\r\n+\tprivate static final String[] FILE_EXTENSIONS = { \"*.csv\" };\r\n+\tprotected static final int COLUMNS = 2;\r\n+\tprotected static final int WITH_TEXT = 200;\r\n+\r\n+\tprivate static final String SPARATOR_INPUT_LABEL = \"Column sperator:\";\r\n+\tprivate static final String DEFAULT_SEPARATOR = \";\";\r\n+\r\n+\tprivate static final String HEADER_LINE_LABEL = \"CSV header line number:\";\r\n+\tprivate static final String DATA_LINE_START_LABEL = \"CSV start data line number:\";\r\n+\tprivate static final String DATA_LINE_END_LABEL = \"CSV end data line number (Optional):\";\r\n+\r\n+\tprivate Text seperatorField;\r\n+\tprivate Text headerNumberField;\r\n+\tprivate Text dataNumberStartField;\r\n+\tprivate Text dataNumberEndField;\r\n+\t\r\n+\tprivate CsvTypeReviewPage typeReviewPage;\r\n+\tprivate CsvImportWizard wizard;\r\n+\r\n+\tprotected List<String> csvHeader;\r\n+\tprotected RequirementType reqType;\r\n+\r\n+\t/**\r\n+\t * Standard constructor\r\n+\t * \r\n+\t * @param model\r\n+\t *            the root model\r\n+\t * @param containingWizard the containing wizard\r\n+\t * @param typeReviewPage\r\n+\t * \t\t\t  the page that recieves the requirement type\r\n+\t */\r\n+\tprotected CsvFileReqTypeSelectionPage(IContainer model, CsvImportWizard containingWizard, CsvTypeReviewPage typeReviewPage) {\r\n+\t\tsuper(\"Requirements CSV Import\");\r\n+\t\tsetTitle(\"Requirements CSV Import\");\r\n+\t\tsetModel(model);\r\n+\t\tthis.typeReviewPage = typeReviewPage;\r\n+\t\tthis.wizard = containingWizard;\r\n+\t\tsetDescription(\r\n+\t\t\t\t\"Please select a CSV file and a requirement type for the imported requirements. To create a new type, select a container configuration.\");\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\t\tsuper.createControl(parent);\r\n+\r\n+\t\tcreateFileDestinationUI();\r\n+\t\tcreateCsvPropertiesUI(parent);\r\n+\r\n+\t\tcreateTreeViewer();\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create the UI for CSV properties\r\n+\t * \r\n+\t * @param parent\r\n+\t *            the parent composite\r\n+\t */\r\n+\tprivate void createCsvPropertiesUI(Composite parent) {\r\n+\t\tComposite propertiesComposite = new Composite((Composite) getControl(), SWT.FILL);\r\n+\t\tpropertiesComposite.setLayout(new GridLayout(COLUMNS, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tpropertiesComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabel.setText(SPARATOR_INPUT_LABEL);\r\n+\r\n+\t\tseperatorField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tseperatorField.setLayoutData(data);\r\n+\t\tseperatorField.setText(DEFAULT_SEPARATOR);\r\n+\t\tseperatorField.addModifyListener(this);\r\n+\r\n+\t\tLabel labelHeaderNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelHeaderNumber.setText(HEADER_LINE_LABEL);\r\n+\r\n+\t\theaderNumberField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\theaderNumberField.setLayoutData(data);\r\n+\t\theaderNumberField.addModifyListener(this);\r\n+\t\theaderNumberField.setText(\"1\");\r\n+\r\n+\t\tLabel labelDataNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataNumber.setText(DATA_LINE_START_LABEL);\r\n+\r\n+\t\tdataNumberStartField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberStartField.setLayoutData(data);\r\n+\t\tdataNumberStartField.addModifyListener(this);\r\n+\t\tdataNumberStartField.setText(\"2\");\r\n+\t\t\r\n+\t\tLabel labelDataEndNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataEndNumber.setText(DATA_LINE_END_LABEL);\r\n+\r\n+\t\tdataNumberEndField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberEndField.setLayoutData(data);\r\n+\t\tdataNumberEndField.addModifyListener(this);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a tree viewer with filters to show only relevant tree elements for\r\n+\t * CSV import /export\r\n+\t */\r\n+\tprotected void createTreeViewer() {\r\n+\t\tTreeViewer treeViewer = createTreeUI();\r\n+\t\tVirSatFilteredWrappedTreeContentProvider filteredCp = (VirSatFilteredWrappedTreeContentProvider) treeViewer\r\n+\t\t\t\t.getContentProvider();\r\n+\t\tfilteredCp.addClassFilter(CategoryAssignment.class);\r\n+\t\tfilteredCp.addClassFilter(ArrayInstance.class);\r\n+\t\tfilteredCp.addClassFilter(ComposedPropertyInstance.class);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(\r\n+\t\t\t\tRequirementsConfigurationCollection.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic boolean isSelectionValid() {\r\n+\t\tObject selection = getSelection();\r\n+\t\tif (selection instanceof CategoryAssignment) {\r\n+\t\t\treturn ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t.equals(RequirementsConfiguration.FULL_QUALIFIED_CATEGORY_NAME)\r\n+\t\t\t\t\t|| ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t\t\t.equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME);\r\n+\t\t}\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tprotected String[] getSupportedFileEndings() {\r\n+\t\treturn FILE_EXTENSIONS;\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage#isComplete()\r\n+\t */\r\n+\t@Override\r\n+\tpublic boolean isComplete() {\r\n+\r\n+\t\tif (isDestinationSelected && isCurrentPage()) {\r\n+\t\t\tif (!headerNumberField.getText().equals(\"\") & !seperatorField.getText().equals(\"\") \r\n+\t\t\t\t& !dataNumberStartField.getText().equals(\"\")) {\r\n+\r\n+\t\t\t\tfinal String destination = getDestination();\r\n+\t\r\n+\t\t\t\tif (isSelectionValid()) {\r\n+\t\t\t\t\tCategoryAssignment selection = (CategoryAssignment) getSelection();\r\n+\t\t\t\t\tRepository repository = VirSatResourceSet.getVirSatResourceSet(selection).getRepository();\r\n+\t\t\t\t\tActiveConceptHelper activeConceptHelper = new ActiveConceptHelper(repository);\r\n+\t\t\t\t\tConcept activeReqConcept = activeConceptHelper.getConcept(de.dlr.sc.virsat.model.extension.requirements.Activator.getPluginId());\r\n+\t\t\t\r\n+\t\t\t\t\ttry {\r\n+\t\t\t\t\t\twizard.getReader().setSeparator(getSeparator());\r\n+\t\t\t\t\t\twizard.getReader().setHeaderLine(getHeaderLineNumber());\r\n+\t\t\t\t\t\tcsvHeader = wizard.getReader().readCsvHeadline(destination);\r\n+\t\t\t\t\t} catch (IOException e) {\r\n+\t\t\t\t\t\tStatus status = new Status(Status.ERROR, Activator.getPluginId(),\r\n+\t\t\t\t\t\t\t\t\"CatiaImportWizard: Failed to perform import! Selected file not valid!\", e);\r\n+\t\t\t\t\t\tStatusManager.getManager().handle(status, StatusManager.LOG | StatusManager.SHOW);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tif (selection.getType().getFullQualifiedName().equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME)) {\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4NjgyNg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449086826", "bodyText": "Maybe we can do it vice versa - ask for the selection of this page from the next page in create controls?", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T15:29:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4NDQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMyMDQ3MQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449320471", "bodyText": "Actually that's how I had it before... Thats why there was this unsued getter methode left... The problem then is that the page is not properly updated if you back to the first and then back to the second page because the page was already created with the old values. I actually like the push-princeple here... And I don't think a selection change will happen that often?", "author": "franzTobiasDLR", "createdAt": "2020-07-03T00:23:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4NDQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4OTAxNA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449089014", "bodyText": "Useless comment", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T15:31:36Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvFileReqTypeSelectionPage.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Text;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfigurationCollection;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage;\r\n+\r\n+/**\r\n+ * A page to select a CSV file to import and the target model element\r\n+ *\r\n+ */\r\n+public class CsvFileReqTypeSelectionPage extends AImportExportPage implements ModifyListener {\r\n+\r\n+\tprivate static final String[] FILE_EXTENSIONS = { \"*.csv\" };\r\n+\tprotected static final int COLUMNS = 2;\r\n+\tprotected static final int WITH_TEXT = 200;\r\n+\r\n+\tprivate static final String SPARATOR_INPUT_LABEL = \"Column sperator:\";\r\n+\tprivate static final String DEFAULT_SEPARATOR = \";\";\r\n+\r\n+\tprivate static final String HEADER_LINE_LABEL = \"CSV header line number:\";\r\n+\tprivate static final String DATA_LINE_START_LABEL = \"CSV start data line number:\";\r\n+\tprivate static final String DATA_LINE_END_LABEL = \"CSV end data line number (Optional):\";\r\n+\r\n+\tprivate Text seperatorField;\r\n+\tprivate Text headerNumberField;\r\n+\tprivate Text dataNumberStartField;\r\n+\tprivate Text dataNumberEndField;\r\n+\t\r\n+\tprivate CsvTypeReviewPage typeReviewPage;\r\n+\tprivate CsvImportWizard wizard;\r\n+\r\n+\tprotected List<String> csvHeader;\r\n+\tprotected RequirementType reqType;\r\n+\r\n+\t/**\r\n+\t * Standard constructor\r\n+\t * \r\n+\t * @param model\r\n+\t *            the root model\r\n+\t * @param containingWizard the containing wizard\r\n+\t * @param typeReviewPage\r\n+\t * \t\t\t  the page that recieves the requirement type\r\n+\t */\r\n+\tprotected CsvFileReqTypeSelectionPage(IContainer model, CsvImportWizard containingWizard, CsvTypeReviewPage typeReviewPage) {\r\n+\t\tsuper(\"Requirements CSV Import\");\r\n+\t\tsetTitle(\"Requirements CSV Import\");\r\n+\t\tsetModel(model);\r\n+\t\tthis.typeReviewPage = typeReviewPage;\r\n+\t\tthis.wizard = containingWizard;\r\n+\t\tsetDescription(\r\n+\t\t\t\t\"Please select a CSV file and a requirement type for the imported requirements. To create a new type, select a container configuration.\");\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\t\tsuper.createControl(parent);\r\n+\r\n+\t\tcreateFileDestinationUI();\r\n+\t\tcreateCsvPropertiesUI(parent);\r\n+\r\n+\t\tcreateTreeViewer();\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create the UI for CSV properties\r\n+\t * \r\n+\t * @param parent\r\n+\t *            the parent composite\r\n+\t */\r\n+\tprivate void createCsvPropertiesUI(Composite parent) {\r\n+\t\tComposite propertiesComposite = new Composite((Composite) getControl(), SWT.FILL);\r\n+\t\tpropertiesComposite.setLayout(new GridLayout(COLUMNS, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tpropertiesComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabel.setText(SPARATOR_INPUT_LABEL);\r\n+\r\n+\t\tseperatorField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tseperatorField.setLayoutData(data);\r\n+\t\tseperatorField.setText(DEFAULT_SEPARATOR);\r\n+\t\tseperatorField.addModifyListener(this);\r\n+\r\n+\t\tLabel labelHeaderNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelHeaderNumber.setText(HEADER_LINE_LABEL);\r\n+\r\n+\t\theaderNumberField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\theaderNumberField.setLayoutData(data);\r\n+\t\theaderNumberField.addModifyListener(this);\r\n+\t\theaderNumberField.setText(\"1\");\r\n+\r\n+\t\tLabel labelDataNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataNumber.setText(DATA_LINE_START_LABEL);\r\n+\r\n+\t\tdataNumberStartField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberStartField.setLayoutData(data);\r\n+\t\tdataNumberStartField.addModifyListener(this);\r\n+\t\tdataNumberStartField.setText(\"2\");\r\n+\t\t\r\n+\t\tLabel labelDataEndNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataEndNumber.setText(DATA_LINE_END_LABEL);\r\n+\r\n+\t\tdataNumberEndField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberEndField.setLayoutData(data);\r\n+\t\tdataNumberEndField.addModifyListener(this);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a tree viewer with filters to show only relevant tree elements for\r\n+\t * CSV import /export\r\n+\t */\r\n+\tprotected void createTreeViewer() {\r\n+\t\tTreeViewer treeViewer = createTreeUI();\r\n+\t\tVirSatFilteredWrappedTreeContentProvider filteredCp = (VirSatFilteredWrappedTreeContentProvider) treeViewer\r\n+\t\t\t\t.getContentProvider();\r\n+\t\tfilteredCp.addClassFilter(CategoryAssignment.class);\r\n+\t\tfilteredCp.addClassFilter(ArrayInstance.class);\r\n+\t\tfilteredCp.addClassFilter(ComposedPropertyInstance.class);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(\r\n+\t\t\t\tRequirementsConfigurationCollection.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic boolean isSelectionValid() {\r\n+\t\tObject selection = getSelection();\r\n+\t\tif (selection instanceof CategoryAssignment) {\r\n+\t\t\treturn ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t.equals(RequirementsConfiguration.FULL_QUALIFIED_CATEGORY_NAME)\r\n+\t\t\t\t\t|| ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t\t\t.equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME);\r\n+\t\t}\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tprotected String[] getSupportedFileEndings() {\r\n+\t\treturn FILE_EXTENSIONS;\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage#isComplete()\r\n+\t */\r\n+\t@Override\r\n+\tpublic boolean isComplete() {\r\n+\r\n+\t\tif (isDestinationSelected && isCurrentPage()) {\r\n+\t\t\tif (!headerNumberField.getText().equals(\"\") & !seperatorField.getText().equals(\"\") \r\n+\t\t\t\t& !dataNumberStartField.getText().equals(\"\")) {\r\n+\r\n+\t\t\t\tfinal String destination = getDestination();\r\n+\t\r\n+\t\t\t\tif (isSelectionValid()) {\r\n+\t\t\t\t\tCategoryAssignment selection = (CategoryAssignment) getSelection();\r\n+\t\t\t\t\tRepository repository = VirSatResourceSet.getVirSatResourceSet(selection).getRepository();\r\n+\t\t\t\t\tActiveConceptHelper activeConceptHelper = new ActiveConceptHelper(repository);\r\n+\t\t\t\t\tConcept activeReqConcept = activeConceptHelper.getConcept(de.dlr.sc.virsat.model.extension.requirements.Activator.getPluginId());\r\n+\t\t\t\r\n+\t\t\t\t\ttry {\r\n+\t\t\t\t\t\twizard.getReader().setSeparator(getSeparator());\r\n+\t\t\t\t\t\twizard.getReader().setHeaderLine(getHeaderLineNumber());\r\n+\t\t\t\t\t\tcsvHeader = wizard.getReader().readCsvHeadline(destination);\r\n+\t\t\t\t\t} catch (IOException e) {\r\n+\t\t\t\t\t\tStatus status = new Status(Status.ERROR, Activator.getPluginId(),\r\n+\t\t\t\t\t\t\t\t\"CatiaImportWizard: Failed to perform import! Selected file not valid!\", e);\r\n+\t\t\t\t\t\tStatusManager.getManager().handle(status, StatusManager.LOG | StatusManager.SHOW);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tif (selection.getType().getFullQualifiedName().equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME)) {\r\n+\t\t\t\t\t\ttypeReviewPage.setInput(csvHeader, new RequirementType(selection));\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\tif (selection.getType().getFullQualifiedName().equals(RequirementsConfiguration.FULL_QUALIFIED_CATEGORY_NAME)) {\r\n+\t\t\t\t\t\treqType = wizard.getImporter().prepareRequirementType(activeReqConcept, csvHeader);\r\n+\t\t\t\t\t\ttypeReviewPage.setInput(csvHeader, reqType);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\t\treturn true;\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t}\r\n+\t\t}\r\n+\r\n+\t\treturn false;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Get the CSV separator\r\n+\t * @return the separator string\r\n+\t */\r\n+\tpublic String getSeparator() {\r\n+\t\treturn seperatorField.getText();\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Get the line number of the header\r\n+\t * @return the integer header line number\r\n+\t */\r\n+\tpublic int getHeaderLineNumber() {\r\n+\t\treturn Integer.parseInt(headerNumberField.getText()) - 1;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Get the line number of the first data\r\n+\t * @return the line number as integer\r\n+\t */\r\n+\tpublic int getFristDataLineNumber() {\r\n+\t\treturn Integer.parseInt(dataNumberStartField.getText()) - 1;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Get the line number of the first data\r\n+\t * @return the line number as integer\r\n+\t */\r\n+\tpublic int getLastDataLineNumber() {\r\n+\t\tString value = dataNumberEndField.getText();\r\n+\t\tif (value.equals(\"\")) {\r\n+\t\t\treturn -1;\r\n+\t\t} else {\r\n+\t\t\treturn Integer.parseInt(value) - 1;\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see de.dlr.sc.virsat.uiengine.ui.wizard.ATreeViewerPage#getSelection()\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA5MjE0MQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449092141", "bodyText": "Unused method?", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T15:34:17Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvFileReqTypeSelectionPage.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Text;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfigurationCollection;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage;\r\n+\r\n+/**\r\n+ * A page to select a CSV file to import and the target model element\r\n+ *\r\n+ */\r\n+public class CsvFileReqTypeSelectionPage extends AImportExportPage implements ModifyListener {\r\n+\r\n+\tprivate static final String[] FILE_EXTENSIONS = { \"*.csv\" };\r\n+\tprotected static final int COLUMNS = 2;\r\n+\tprotected static final int WITH_TEXT = 200;\r\n+\r\n+\tprivate static final String SPARATOR_INPUT_LABEL = \"Column sperator:\";\r\n+\tprivate static final String DEFAULT_SEPARATOR = \";\";\r\n+\r\n+\tprivate static final String HEADER_LINE_LABEL = \"CSV header line number:\";\r\n+\tprivate static final String DATA_LINE_START_LABEL = \"CSV start data line number:\";\r\n+\tprivate static final String DATA_LINE_END_LABEL = \"CSV end data line number (Optional):\";\r\n+\r\n+\tprivate Text seperatorField;\r\n+\tprivate Text headerNumberField;\r\n+\tprivate Text dataNumberStartField;\r\n+\tprivate Text dataNumberEndField;\r\n+\t\r\n+\tprivate CsvTypeReviewPage typeReviewPage;\r\n+\tprivate CsvImportWizard wizard;\r\n+\r\n+\tprotected List<String> csvHeader;\r\n+\tprotected RequirementType reqType;\r\n+\r\n+\t/**\r\n+\t * Standard constructor\r\n+\t * \r\n+\t * @param model\r\n+\t *            the root model\r\n+\t * @param containingWizard the containing wizard\r\n+\t * @param typeReviewPage\r\n+\t * \t\t\t  the page that recieves the requirement type\r\n+\t */\r\n+\tprotected CsvFileReqTypeSelectionPage(IContainer model, CsvImportWizard containingWizard, CsvTypeReviewPage typeReviewPage) {\r\n+\t\tsuper(\"Requirements CSV Import\");\r\n+\t\tsetTitle(\"Requirements CSV Import\");\r\n+\t\tsetModel(model);\r\n+\t\tthis.typeReviewPage = typeReviewPage;\r\n+\t\tthis.wizard = containingWizard;\r\n+\t\tsetDescription(\r\n+\t\t\t\t\"Please select a CSV file and a requirement type for the imported requirements. To create a new type, select a container configuration.\");\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\t\tsuper.createControl(parent);\r\n+\r\n+\t\tcreateFileDestinationUI();\r\n+\t\tcreateCsvPropertiesUI(parent);\r\n+\r\n+\t\tcreateTreeViewer();\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create the UI for CSV properties\r\n+\t * \r\n+\t * @param parent\r\n+\t *            the parent composite\r\n+\t */\r\n+\tprivate void createCsvPropertiesUI(Composite parent) {\r\n+\t\tComposite propertiesComposite = new Composite((Composite) getControl(), SWT.FILL);\r\n+\t\tpropertiesComposite.setLayout(new GridLayout(COLUMNS, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tpropertiesComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabel.setText(SPARATOR_INPUT_LABEL);\r\n+\r\n+\t\tseperatorField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tseperatorField.setLayoutData(data);\r\n+\t\tseperatorField.setText(DEFAULT_SEPARATOR);\r\n+\t\tseperatorField.addModifyListener(this);\r\n+\r\n+\t\tLabel labelHeaderNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelHeaderNumber.setText(HEADER_LINE_LABEL);\r\n+\r\n+\t\theaderNumberField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\theaderNumberField.setLayoutData(data);\r\n+\t\theaderNumberField.addModifyListener(this);\r\n+\t\theaderNumberField.setText(\"1\");\r\n+\r\n+\t\tLabel labelDataNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataNumber.setText(DATA_LINE_START_LABEL);\r\n+\r\n+\t\tdataNumberStartField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberStartField.setLayoutData(data);\r\n+\t\tdataNumberStartField.addModifyListener(this);\r\n+\t\tdataNumberStartField.setText(\"2\");\r\n+\t\t\r\n+\t\tLabel labelDataEndNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataEndNumber.setText(DATA_LINE_END_LABEL);\r\n+\r\n+\t\tdataNumberEndField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberEndField.setLayoutData(data);\r\n+\t\tdataNumberEndField.addModifyListener(this);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a tree viewer with filters to show only relevant tree elements for\r\n+\t * CSV import /export\r\n+\t */\r\n+\tprotected void createTreeViewer() {\r\n+\t\tTreeViewer treeViewer = createTreeUI();\r\n+\t\tVirSatFilteredWrappedTreeContentProvider filteredCp = (VirSatFilteredWrappedTreeContentProvider) treeViewer\r\n+\t\t\t\t.getContentProvider();\r\n+\t\tfilteredCp.addClassFilter(CategoryAssignment.class);\r\n+\t\tfilteredCp.addClassFilter(ArrayInstance.class);\r\n+\t\tfilteredCp.addClassFilter(ComposedPropertyInstance.class);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(\r\n+\t\t\t\tRequirementsConfigurationCollection.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic boolean isSelectionValid() {\r\n+\t\tObject selection = getSelection();\r\n+\t\tif (selection instanceof CategoryAssignment) {\r\n+\t\t\treturn ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t.equals(RequirementsConfiguration.FULL_QUALIFIED_CATEGORY_NAME)\r\n+\t\t\t\t\t|| ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t\t\t.equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME);\r\n+\t\t}\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tprotected String[] getSupportedFileEndings() {\r\n+\t\treturn FILE_EXTENSIONS;\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage#isComplete()\r\n+\t */\r\n+\t@Override\r\n+\tpublic boolean isComplete() {\r\n+\r\n+\t\tif (isDestinationSelected && isCurrentPage()) {\r\n+\t\t\tif (!headerNumberField.getText().equals(\"\") & !seperatorField.getText().equals(\"\") \r\n+\t\t\t\t& !dataNumberStartField.getText().equals(\"\")) {\r\n+\r\n+\t\t\t\tfinal String destination = getDestination();\r\n+\t\r\n+\t\t\t\tif (isSelectionValid()) {\r\n+\t\t\t\t\tCategoryAssignment selection = (CategoryAssignment) getSelection();\r\n+\t\t\t\t\tRepository repository = VirSatResourceSet.getVirSatResourceSet(selection).getRepository();\r\n+\t\t\t\t\tActiveConceptHelper activeConceptHelper = new ActiveConceptHelper(repository);\r\n+\t\t\t\t\tConcept activeReqConcept = activeConceptHelper.getConcept(de.dlr.sc.virsat.model.extension.requirements.Activator.getPluginId());\r\n+\t\t\t\r\n+\t\t\t\t\ttry {\r\n+\t\t\t\t\t\twizard.getReader().setSeparator(getSeparator());\r\n+\t\t\t\t\t\twizard.getReader().setHeaderLine(getHeaderLineNumber());\r\n+\t\t\t\t\t\tcsvHeader = wizard.getReader().readCsvHeadline(destination);\r\n+\t\t\t\t\t} catch (IOException e) {\r\n+\t\t\t\t\t\tStatus status = new Status(Status.ERROR, Activator.getPluginId(),\r\n+\t\t\t\t\t\t\t\t\"CatiaImportWizard: Failed to perform import! Selected file not valid!\", e);\r\n+\t\t\t\t\t\tStatusManager.getManager().handle(status, StatusManager.LOG | StatusManager.SHOW);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tif (selection.getType().getFullQualifiedName().equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME)) {\r\n+\t\t\t\t\t\ttypeReviewPage.setInput(csvHeader, new RequirementType(selection));\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\tif (selection.getType().getFullQualifiedName().equals(RequirementsConfiguration.FULL_QUALIFIED_CATEGORY_NAME)) {\r\n+\t\t\t\t\t\treqType = wizard.getImporter().prepareRequirementType(activeReqConcept, csvHeader);\r\n+\t\t\t\t\t\ttypeReviewPage.setInput(csvHeader, reqType);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\t\treturn true;\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t}\r\n+\t\t}\r\n+\r\n+\t\treturn false;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Get the CSV separator\r\n+\t * @return the separator string\r\n+\t */\r\n+\tpublic String getSeparator() {\r\n+\t\treturn seperatorField.getText();\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Get the line number of the header\r\n+\t * @return the integer header line number\r\n+\t */\r\n+\tpublic int getHeaderLineNumber() {\r\n+\t\treturn Integer.parseInt(headerNumberField.getText()) - 1;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Get the line number of the first data\r\n+\t * @return the line number as integer\r\n+\t */\r\n+\tpublic int getFristDataLineNumber() {\r\n+\t\treturn Integer.parseInt(dataNumberStartField.getText()) - 1;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Get the line number of the first data\r\n+\t * @return the line number as integer\r\n+\t */\r\n+\tpublic int getLastDataLineNumber() {\r\n+\t\tString value = dataNumberEndField.getText();\r\n+\t\tif (value.equals(\"\")) {\r\n+\t\t\treturn -1;\r\n+\t\t} else {\r\n+\t\t\treturn Integer.parseInt(value) - 1;\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see de.dlr.sc.virsat.uiengine.ui.wizard.ATreeViewerPage#getSelection()\r\n+\t */\r\n+\t@Override\r\n+\tpublic Object getSelection() {\r\n+\t\tObject selected = super.getSelection();\r\n+\t\tif (selected instanceof ComposedPropertyInstance) {\r\n+\t\t\tselected = ((ComposedPropertyInstance) selected).getTypeInstance();\r\n+\t\t}\r\n+\t\treturn selected;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Get the selected requirement type \r\n+\t * @return the requirement type for import\r\n+\t */\r\n+\tpublic RequirementType getRequirementsImportType() {\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEwNjc1NQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449106755", "bodyText": "Shall we maybe take this (and other defaults) from the CsvFileReader? Or vice versa remove defaults there, and set all the fields explicitly from the defaults in this page?", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T15:46:23Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvFileReqTypeSelectionPage.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Text;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfigurationCollection;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage;\r\n+\r\n+/**\r\n+ * A page to select a CSV file to import and the target model element\r\n+ *\r\n+ */\r\n+public class CsvFileReqTypeSelectionPage extends AImportExportPage implements ModifyListener {\r\n+\r\n+\tprivate static final String[] FILE_EXTENSIONS = { \"*.csv\" };\r\n+\tprotected static final int COLUMNS = 2;\r\n+\tprotected static final int WITH_TEXT = 200;\r\n+\r\n+\tprivate static final String SPARATOR_INPUT_LABEL = \"Column sperator:\";\r\n+\tprivate static final String DEFAULT_SEPARATOR = \";\";\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEwNzgxMA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449107810", "bodyText": "I think this is redundant", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T15:47:15Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvFileReqTypeSelectionPage.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Text;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfigurationCollection;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage;\r\n+\r\n+/**\r\n+ * A page to select a CSV file to import and the target model element\r\n+ *\r\n+ */\r\n+public class CsvFileReqTypeSelectionPage extends AImportExportPage implements ModifyListener {\r\n+\r\n+\tprivate static final String[] FILE_EXTENSIONS = { \"*.csv\" };\r\n+\tprotected static final int COLUMNS = 2;\r\n+\tprotected static final int WITH_TEXT = 200;\r\n+\r\n+\tprivate static final String SPARATOR_INPUT_LABEL = \"Column sperator:\";\r\n+\tprivate static final String DEFAULT_SEPARATOR = \";\";\r\n+\r\n+\tprivate static final String HEADER_LINE_LABEL = \"CSV header line number:\";\r\n+\tprivate static final String DATA_LINE_START_LABEL = \"CSV start data line number:\";\r\n+\tprivate static final String DATA_LINE_END_LABEL = \"CSV end data line number (Optional):\";\r\n+\r\n+\tprivate Text seperatorField;\r\n+\tprivate Text headerNumberField;\r\n+\tprivate Text dataNumberStartField;\r\n+\tprivate Text dataNumberEndField;\r\n+\t\r\n+\tprivate CsvTypeReviewPage typeReviewPage;\r\n+\tprivate CsvImportWizard wizard;\r\n+\r\n+\tprotected List<String> csvHeader;\r\n+\tprotected RequirementType reqType;\r\n+\r\n+\t/**\r\n+\t * Standard constructor\r\n+\t * \r\n+\t * @param model\r\n+\t *            the root model\r\n+\t * @param containingWizard the containing wizard\r\n+\t * @param typeReviewPage\r\n+\t * \t\t\t  the page that recieves the requirement type\r\n+\t */\r\n+\tprotected CsvFileReqTypeSelectionPage(IContainer model, CsvImportWizard containingWizard, CsvTypeReviewPage typeReviewPage) {\r\n+\t\tsuper(\"Requirements CSV Import\");\r\n+\t\tsetTitle(\"Requirements CSV Import\");\r\n+\t\tsetModel(model);\r\n+\t\tthis.typeReviewPage = typeReviewPage;\r\n+\t\tthis.wizard = containingWizard;\r\n+\t\tsetDescription(\r\n+\t\t\t\t\"Please select a CSV file and a requirement type for the imported requirements. To create a new type, select a container configuration.\");\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\t\tsuper.createControl(parent);\r\n+\r\n+\t\tcreateFileDestinationUI();\r\n+\t\tcreateCsvPropertiesUI(parent);\r\n+\r\n+\t\tcreateTreeViewer();\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create the UI for CSV properties\r\n+\t * \r\n+\t * @param parent\r\n+\t *            the parent composite\r\n+\t */\r\n+\tprivate void createCsvPropertiesUI(Composite parent) {\r\n+\t\tComposite propertiesComposite = new Composite((Composite) getControl(), SWT.FILL);\r\n+\t\tpropertiesComposite.setLayout(new GridLayout(COLUMNS, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tpropertiesComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabel.setText(SPARATOR_INPUT_LABEL);\r\n+\r\n+\t\tseperatorField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tseperatorField.setLayoutData(data);\r\n+\t\tseperatorField.setText(DEFAULT_SEPARATOR);\r\n+\t\tseperatorField.addModifyListener(this);\r\n+\r\n+\t\tLabel labelHeaderNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelHeaderNumber.setText(HEADER_LINE_LABEL);\r\n+\r\n+\t\theaderNumberField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\theaderNumberField.setLayoutData(data);\r\n+\t\theaderNumberField.addModifyListener(this);\r\n+\t\theaderNumberField.setText(\"1\");\r\n+\r\n+\t\tLabel labelDataNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataNumber.setText(DATA_LINE_START_LABEL);\r\n+\r\n+\t\tdataNumberStartField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberStartField.setLayoutData(data);\r\n+\t\tdataNumberStartField.addModifyListener(this);\r\n+\t\tdataNumberStartField.setText(\"2\");\r\n+\t\t\r\n+\t\tLabel labelDataEndNumber = new Label(propertiesComposite, SWT.NONE);\r\n+\t\tlabelDataEndNumber.setText(DATA_LINE_END_LABEL);\r\n+\r\n+\t\tdataNumberEndField = new Text(propertiesComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tdata = new GridData(GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdataNumberEndField.setLayoutData(data);\r\n+\t\tdataNumberEndField.addModifyListener(this);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a tree viewer with filters to show only relevant tree elements for\r\n+\t * CSV import /export\r\n+\t */\r\n+\tprotected void createTreeViewer() {\r\n+\t\tTreeViewer treeViewer = createTreeUI();\r\n+\t\tVirSatFilteredWrappedTreeContentProvider filteredCp = (VirSatFilteredWrappedTreeContentProvider) treeViewer\r\n+\t\t\t\t.getContentProvider();\r\n+\t\tfilteredCp.addClassFilter(CategoryAssignment.class);\r\n+\t\tfilteredCp.addClassFilter(ArrayInstance.class);\r\n+\t\tfilteredCp.addClassFilter(ComposedPropertyInstance.class);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(\r\n+\t\t\t\tRequirementsConfigurationCollection.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic boolean isSelectionValid() {\r\n+\t\tObject selection = getSelection();\r\n+\t\tif (selection instanceof CategoryAssignment) {\r\n+\t\t\treturn ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t.equals(RequirementsConfiguration.FULL_QUALIFIED_CATEGORY_NAME)\r\n+\t\t\t\t\t|| ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t\t\t.equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME);\r\n+\t\t}\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tprotected String[] getSupportedFileEndings() {\r\n+\t\treturn FILE_EXTENSIONS;\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage#isComplete()\r\n+\t */\r\n+\t@Override\r\n+\tpublic boolean isComplete() {\r\n+\r\n+\t\tif (isDestinationSelected && isCurrentPage()) {\r\n+\t\t\tif (!headerNumberField.getText().equals(\"\") & !seperatorField.getText().equals(\"\") \r\n+\t\t\t\t& !dataNumberStartField.getText().equals(\"\")) {\r\n+\r\n+\t\t\t\tfinal String destination = getDestination();\r\n+\t\r\n+\t\t\t\tif (isSelectionValid()) {\r\n+\t\t\t\t\tCategoryAssignment selection = (CategoryAssignment) getSelection();\r\n+\t\t\t\t\tRepository repository = VirSatResourceSet.getVirSatResourceSet(selection).getRepository();\r\n+\t\t\t\t\tActiveConceptHelper activeConceptHelper = new ActiveConceptHelper(repository);\r\n+\t\t\t\t\tConcept activeReqConcept = activeConceptHelper.getConcept(de.dlr.sc.virsat.model.extension.requirements.Activator.getPluginId());\r\n+\t\t\t\r\n+\t\t\t\t\ttry {\r\n+\t\t\t\t\t\twizard.getReader().setSeparator(getSeparator());\r\n+\t\t\t\t\t\twizard.getReader().setHeaderLine(getHeaderLineNumber());\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxNzIxNw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449317217", "bodyText": "What do you mean is redundant?", "author": "franzTobiasDLR", "createdAt": "2020-07-03T00:08:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEwNzgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNDYyMw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449114623", "bodyText": "Where do all these comments come from?", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T15:54:58Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvTypeReviewPage.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import org.eclipse.jface.wizard.WizardPage;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.custom.CCombo;\r\n+import org.eclipse.swt.custom.TableEditor;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.events.SelectionListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Table;\r\n+import org.eclipse.swt.widgets.TableColumn;\r\n+import org.eclipse.swt.widgets.TableItem;\r\n+import org.eclipse.swt.widgets.Text;\r\n+\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+\r\n+/**\r\n+ * A wizard page to review the requirement type which is used for imports\r\n+ *\r\n+ */\r\n+public class CsvTypeReviewPage extends WizardPage implements SelectionListener, ModifyListener {\r\n+\r\n+\tprivate static final String COLUMN_NAME_LABEL = \"Column\";\r\n+\tprivate static final String COLUMN_TYPE_LABEL = \"Type\";\r\n+\r\n+\tprivate static final String TYPE_NAME_LABEL = \"Type Name\";\r\n+\tprivate static final int WITH_TEXT = 400;\r\n+\r\n+\tprivate static final int COLUMN_NAME_WIDTH = 300;\r\n+\tprivate static final int COLUMN_TYPE_WIDTH = 200;\r\n+\r\n+\tprivate static final List<String> ATTRIBUTE_TYPES = new ArrayList<String>(\r\n+\t\t\tArrays.asList(RequirementAttribute.TYPE_Boolean_NAME, RequirementAttribute.TYPE_Date_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Enumeration_NAME, RequirementAttribute.TYPE_Identifier_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Integer_NAME, RequirementAttribute.TYPE_Real_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_String_NAME));\r\n+\r\n+\tprivate static final int TYPE_COLUMN_INDEX = 1;\r\n+\tprivate static final String TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR = \"::\";\r\n+\r\n+\tprivate Text typeNameText;\r\n+\r\n+\tprivate Table table;\r\n+\tprivate List<TableItem> tableItems = new ArrayList<TableItem>();\r\n+\tprivate List<CCombo> editors = new ArrayList<CCombo>();\r\n+\r\n+\tprivate Map<Integer, RequirementAttribute> mapColumnIndexToAttributeType = new HashMap<>();\r\n+\tprivate RequirementType requirementType;\r\n+\tprivate boolean isNewType;\r\n+\r\n+\t/**\r\n+\t * Constructor\r\n+\t */\r\n+\tprotected CsvTypeReviewPage() {\r\n+\t\tsuper(\"Requirement Type Review\");\r\n+\t\tsetTitle(\"Requirement Type Review\");\r\n+\t\tsetDescription(\"Check the selected import type for the requirements.\");\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see\r\n+\t * org.eclipse.jface.dialogs.IDialogPage#createControl(org.eclipse.swt.widgets.\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMyNDI3Mw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449324273", "bodyText": "It's generated methods from eclipse... Method overwrites from super classes, getter/ setters and delegate forwardings and so on... Eclipse can generate quite some stuff... But its adding these comments.", "author": "franzTobiasDLR", "createdAt": "2020-07-03T00:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNDYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyMTU5Nw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449121597", "bodyText": "This adds a maintenance effort if we need to add more types. Maybe we need to add a helper method to enum bean that would return all enum values?", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T16:05:35Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvTypeReviewPage.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import org.eclipse.jface.wizard.WizardPage;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.custom.CCombo;\r\n+import org.eclipse.swt.custom.TableEditor;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.events.SelectionListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Table;\r\n+import org.eclipse.swt.widgets.TableColumn;\r\n+import org.eclipse.swt.widgets.TableItem;\r\n+import org.eclipse.swt.widgets.Text;\r\n+\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+\r\n+/**\r\n+ * A wizard page to review the requirement type which is used for imports\r\n+ *\r\n+ */\r\n+public class CsvTypeReviewPage extends WizardPage implements SelectionListener, ModifyListener {\r\n+\r\n+\tprivate static final String COLUMN_NAME_LABEL = \"Column\";\r\n+\tprivate static final String COLUMN_TYPE_LABEL = \"Type\";\r\n+\r\n+\tprivate static final String TYPE_NAME_LABEL = \"Type Name\";\r\n+\tprivate static final int WITH_TEXT = 400;\r\n+\r\n+\tprivate static final int COLUMN_NAME_WIDTH = 300;\r\n+\tprivate static final int COLUMN_TYPE_WIDTH = 200;\r\n+\r\n+\tprivate static final List<String> ATTRIBUTE_TYPES = new ArrayList<String>(\r\n+\t\t\tArrays.asList(RequirementAttribute.TYPE_Boolean_NAME, RequirementAttribute.TYPE_Date_NAME,\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ0NDU0MA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449444540", "bodyText": "Yes I agree, we should do that! But let's maybe do that in an additional PR?", "author": "franzTobiasDLR", "createdAt": "2020-07-03T08:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyMTU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyNjk0Mg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449126942", "bodyText": "Maybe use an indexed for? This will break on repeated strings (if this can happen)", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T16:14:33Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvTypeReviewPage.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import org.eclipse.jface.wizard.WizardPage;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.custom.CCombo;\r\n+import org.eclipse.swt.custom.TableEditor;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.events.SelectionListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Table;\r\n+import org.eclipse.swt.widgets.TableColumn;\r\n+import org.eclipse.swt.widgets.TableItem;\r\n+import org.eclipse.swt.widgets.Text;\r\n+\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+\r\n+/**\r\n+ * A wizard page to review the requirement type which is used for imports\r\n+ *\r\n+ */\r\n+public class CsvTypeReviewPage extends WizardPage implements SelectionListener, ModifyListener {\r\n+\r\n+\tprivate static final String COLUMN_NAME_LABEL = \"Column\";\r\n+\tprivate static final String COLUMN_TYPE_LABEL = \"Type\";\r\n+\r\n+\tprivate static final String TYPE_NAME_LABEL = \"Type Name\";\r\n+\tprivate static final int WITH_TEXT = 400;\r\n+\r\n+\tprivate static final int COLUMN_NAME_WIDTH = 300;\r\n+\tprivate static final int COLUMN_TYPE_WIDTH = 200;\r\n+\r\n+\tprivate static final List<String> ATTRIBUTE_TYPES = new ArrayList<String>(\r\n+\t\t\tArrays.asList(RequirementAttribute.TYPE_Boolean_NAME, RequirementAttribute.TYPE_Date_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Enumeration_NAME, RequirementAttribute.TYPE_Identifier_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Integer_NAME, RequirementAttribute.TYPE_Real_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_String_NAME));\r\n+\r\n+\tprivate static final int TYPE_COLUMN_INDEX = 1;\r\n+\tprivate static final String TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR = \"::\";\r\n+\r\n+\tprivate Text typeNameText;\r\n+\r\n+\tprivate Table table;\r\n+\tprivate List<TableItem> tableItems = new ArrayList<TableItem>();\r\n+\tprivate List<CCombo> editors = new ArrayList<CCombo>();\r\n+\r\n+\tprivate Map<Integer, RequirementAttribute> mapColumnIndexToAttributeType = new HashMap<>();\r\n+\tprivate RequirementType requirementType;\r\n+\tprivate boolean isNewType;\r\n+\r\n+\t/**\r\n+\t * Constructor\r\n+\t */\r\n+\tprotected CsvTypeReviewPage() {\r\n+\t\tsuper(\"Requirement Type Review\");\r\n+\t\tsetTitle(\"Requirement Type Review\");\r\n+\t\tsetDescription(\"Check the selected import type for the requirements.\");\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see\r\n+\t * org.eclipse.jface.dialogs.IDialogPage#createControl(org.eclipse.swt.widgets.\r\n+\t * Composite)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\r\n+\t\tComposite content = new Composite(parent, SWT.NONE);\r\n+\t\tcontent.setLayout(new GridLayout());\r\n+\t\tcontent.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_HORIZONTAL));\r\n+\t\tsetControl(content);\r\n+\r\n+\t\tComposite typeNameComposite = new Composite(content, SWT.NONE);\r\n+\t\ttypeNameComposite.setLayout(new GridLayout(2, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\ttypeNameComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(typeNameComposite, SWT.NONE);\r\n+\t\tlabel.setText(TYPE_NAME_LABEL);\r\n+\r\n+\t\ttypeNameText = new Text(typeNameComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tGridData dataText = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\ttypeNameText.setLayoutData(dataText);\r\n+\t\ttypeNameText.addSelectionListener(this);\r\n+\t\ttypeNameText.addModifyListener(this);\r\n+\r\n+\t\ttable = new Table(content, SWT.CHECK | SWT.BORDER | SWT.H_SCROLL);\r\n+\t\ttable.setLayout(new GridLayout());\r\n+\t\ttable.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL));\r\n+\t\ttable.setHeaderVisible(true);\r\n+\t\ttable.addSelectionListener(this);\r\n+\r\n+\t\tTableColumn columnColumnName = new TableColumn(table, SWT.NULL);\r\n+\t\tcolumnColumnName.setWidth(COLUMN_NAME_WIDTH);\r\n+\t\tcolumnColumnName.setText(COLUMN_NAME_LABEL);\r\n+\r\n+\t\tTableColumn columnType = new TableColumn(table, SWT.NONE | SWT.DROP_DOWN);\r\n+\t\tcolumnType.setText(COLUMN_TYPE_LABEL);\r\n+\t\tcolumnType.setWidth(COLUMN_TYPE_WIDTH);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Sets the input for the mapping table\r\n+\t * \r\n+\t * @param columnNames\r\n+\t *            a list of columns in the file\r\n+\t * @param requirementType\r\n+\t *            an existing requirement type\r\n+\t */\r\n+\tpublic void setInput(List<String> columnNames, RequirementType requirementType) {\r\n+\t\tthis.requirementType = requirementType;\r\n+\t\tthis.typeNameText.setText(requirementType.getName());\r\n+\t\tisNewType = requirementType.getTypeInstance().eContainer() == null;\r\n+\t\tif (!isNewType) {\r\n+\t\t\ttypeNameText.setEditable(false);\r\n+\t\t} else {\r\n+\t\t\ttypeNameText.setEditable(true);\r\n+\t\t}\r\n+\r\n+\t\ttable.clearAll();\r\n+\r\n+\t\tfor (String column : columnNames) {\r\n+\t\t\tInteger index = columnNames.indexOf(column);\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMDA3Nw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449130077", "bodyText": "What's the point of reusing old tableItems from the previous input? Shall we maybe clear them too?", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T16:19:41Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvTypeReviewPage.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import org.eclipse.jface.wizard.WizardPage;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.custom.CCombo;\r\n+import org.eclipse.swt.custom.TableEditor;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.events.SelectionListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Table;\r\n+import org.eclipse.swt.widgets.TableColumn;\r\n+import org.eclipse.swt.widgets.TableItem;\r\n+import org.eclipse.swt.widgets.Text;\r\n+\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+\r\n+/**\r\n+ * A wizard page to review the requirement type which is used for imports\r\n+ *\r\n+ */\r\n+public class CsvTypeReviewPage extends WizardPage implements SelectionListener, ModifyListener {\r\n+\r\n+\tprivate static final String COLUMN_NAME_LABEL = \"Column\";\r\n+\tprivate static final String COLUMN_TYPE_LABEL = \"Type\";\r\n+\r\n+\tprivate static final String TYPE_NAME_LABEL = \"Type Name\";\r\n+\tprivate static final int WITH_TEXT = 400;\r\n+\r\n+\tprivate static final int COLUMN_NAME_WIDTH = 300;\r\n+\tprivate static final int COLUMN_TYPE_WIDTH = 200;\r\n+\r\n+\tprivate static final List<String> ATTRIBUTE_TYPES = new ArrayList<String>(\r\n+\t\t\tArrays.asList(RequirementAttribute.TYPE_Boolean_NAME, RequirementAttribute.TYPE_Date_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Enumeration_NAME, RequirementAttribute.TYPE_Identifier_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Integer_NAME, RequirementAttribute.TYPE_Real_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_String_NAME));\r\n+\r\n+\tprivate static final int TYPE_COLUMN_INDEX = 1;\r\n+\tprivate static final String TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR = \"::\";\r\n+\r\n+\tprivate Text typeNameText;\r\n+\r\n+\tprivate Table table;\r\n+\tprivate List<TableItem> tableItems = new ArrayList<TableItem>();\r\n+\tprivate List<CCombo> editors = new ArrayList<CCombo>();\r\n+\r\n+\tprivate Map<Integer, RequirementAttribute> mapColumnIndexToAttributeType = new HashMap<>();\r\n+\tprivate RequirementType requirementType;\r\n+\tprivate boolean isNewType;\r\n+\r\n+\t/**\r\n+\t * Constructor\r\n+\t */\r\n+\tprotected CsvTypeReviewPage() {\r\n+\t\tsuper(\"Requirement Type Review\");\r\n+\t\tsetTitle(\"Requirement Type Review\");\r\n+\t\tsetDescription(\"Check the selected import type for the requirements.\");\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see\r\n+\t * org.eclipse.jface.dialogs.IDialogPage#createControl(org.eclipse.swt.widgets.\r\n+\t * Composite)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\r\n+\t\tComposite content = new Composite(parent, SWT.NONE);\r\n+\t\tcontent.setLayout(new GridLayout());\r\n+\t\tcontent.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_HORIZONTAL));\r\n+\t\tsetControl(content);\r\n+\r\n+\t\tComposite typeNameComposite = new Composite(content, SWT.NONE);\r\n+\t\ttypeNameComposite.setLayout(new GridLayout(2, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\ttypeNameComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(typeNameComposite, SWT.NONE);\r\n+\t\tlabel.setText(TYPE_NAME_LABEL);\r\n+\r\n+\t\ttypeNameText = new Text(typeNameComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tGridData dataText = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\ttypeNameText.setLayoutData(dataText);\r\n+\t\ttypeNameText.addSelectionListener(this);\r\n+\t\ttypeNameText.addModifyListener(this);\r\n+\r\n+\t\ttable = new Table(content, SWT.CHECK | SWT.BORDER | SWT.H_SCROLL);\r\n+\t\ttable.setLayout(new GridLayout());\r\n+\t\ttable.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL));\r\n+\t\ttable.setHeaderVisible(true);\r\n+\t\ttable.addSelectionListener(this);\r\n+\r\n+\t\tTableColumn columnColumnName = new TableColumn(table, SWT.NULL);\r\n+\t\tcolumnColumnName.setWidth(COLUMN_NAME_WIDTH);\r\n+\t\tcolumnColumnName.setText(COLUMN_NAME_LABEL);\r\n+\r\n+\t\tTableColumn columnType = new TableColumn(table, SWT.NONE | SWT.DROP_DOWN);\r\n+\t\tcolumnType.setText(COLUMN_TYPE_LABEL);\r\n+\t\tcolumnType.setWidth(COLUMN_TYPE_WIDTH);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Sets the input for the mapping table\r\n+\t * \r\n+\t * @param columnNames\r\n+\t *            a list of columns in the file\r\n+\t * @param requirementType\r\n+\t *            an existing requirement type\r\n+\t */\r\n+\tpublic void setInput(List<String> columnNames, RequirementType requirementType) {\r\n+\t\tthis.requirementType = requirementType;\r\n+\t\tthis.typeNameText.setText(requirementType.getName());\r\n+\t\tisNewType = requirementType.getTypeInstance().eContainer() == null;\r\n+\t\tif (!isNewType) {\r\n+\t\t\ttypeNameText.setEditable(false);\r\n+\t\t} else {\r\n+\t\t\ttypeNameText.setEditable(true);\r\n+\t\t}\r\n+\r\n+\t\ttable.clearAll();\r\n+\r\n+\t\tfor (String column : columnNames) {\r\n+\t\t\tInteger index = columnNames.indexOf(column);\r\n+\t\t\tTableItem item;\r\n+\t\t\tif (tableItems.size() <= index) {\r\n+\t\t\t\titem = new TableItem(table, SWT.NULL);\r\n+\t\t\t\ttableItems.add(item);\r\n+\t\t\t} else {\r\n+\t\t\t\titem = tableItems.get(index);\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMTUwNg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449131506", "bodyText": "Also the table has been cleared, I speculate that these are \"dangling\" items and may not appear in the table", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T16:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMDA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ3OTIxNA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449479214", "bodyText": "Well, actually they do... And I didn't find a way to proparly clear the items and editors.... Just tried it again with all kind of remove, clear and repaint methods of SWT... The table will always show the initial table items and editors... Guess the table is not designed for beeing recreated dynamically", "author": "franzTobiasDLR", "createdAt": "2020-07-03T09:24:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMDA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MzcyNA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449173724", "bodyText": "Here also why are we reusing editors instead of clearing and creating new? This would simplify the code", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T17:39:45Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvTypeReviewPage.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import org.eclipse.jface.wizard.WizardPage;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.custom.CCombo;\r\n+import org.eclipse.swt.custom.TableEditor;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.events.SelectionListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Table;\r\n+import org.eclipse.swt.widgets.TableColumn;\r\n+import org.eclipse.swt.widgets.TableItem;\r\n+import org.eclipse.swt.widgets.Text;\r\n+\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+\r\n+/**\r\n+ * A wizard page to review the requirement type which is used for imports\r\n+ *\r\n+ */\r\n+public class CsvTypeReviewPage extends WizardPage implements SelectionListener, ModifyListener {\r\n+\r\n+\tprivate static final String COLUMN_NAME_LABEL = \"Column\";\r\n+\tprivate static final String COLUMN_TYPE_LABEL = \"Type\";\r\n+\r\n+\tprivate static final String TYPE_NAME_LABEL = \"Type Name\";\r\n+\tprivate static final int WITH_TEXT = 400;\r\n+\r\n+\tprivate static final int COLUMN_NAME_WIDTH = 300;\r\n+\tprivate static final int COLUMN_TYPE_WIDTH = 200;\r\n+\r\n+\tprivate static final List<String> ATTRIBUTE_TYPES = new ArrayList<String>(\r\n+\t\t\tArrays.asList(RequirementAttribute.TYPE_Boolean_NAME, RequirementAttribute.TYPE_Date_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Enumeration_NAME, RequirementAttribute.TYPE_Identifier_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Integer_NAME, RequirementAttribute.TYPE_Real_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_String_NAME));\r\n+\r\n+\tprivate static final int TYPE_COLUMN_INDEX = 1;\r\n+\tprivate static final String TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR = \"::\";\r\n+\r\n+\tprivate Text typeNameText;\r\n+\r\n+\tprivate Table table;\r\n+\tprivate List<TableItem> tableItems = new ArrayList<TableItem>();\r\n+\tprivate List<CCombo> editors = new ArrayList<CCombo>();\r\n+\r\n+\tprivate Map<Integer, RequirementAttribute> mapColumnIndexToAttributeType = new HashMap<>();\r\n+\tprivate RequirementType requirementType;\r\n+\tprivate boolean isNewType;\r\n+\r\n+\t/**\r\n+\t * Constructor\r\n+\t */\r\n+\tprotected CsvTypeReviewPage() {\r\n+\t\tsuper(\"Requirement Type Review\");\r\n+\t\tsetTitle(\"Requirement Type Review\");\r\n+\t\tsetDescription(\"Check the selected import type for the requirements.\");\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see\r\n+\t * org.eclipse.jface.dialogs.IDialogPage#createControl(org.eclipse.swt.widgets.\r\n+\t * Composite)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\r\n+\t\tComposite content = new Composite(parent, SWT.NONE);\r\n+\t\tcontent.setLayout(new GridLayout());\r\n+\t\tcontent.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_HORIZONTAL));\r\n+\t\tsetControl(content);\r\n+\r\n+\t\tComposite typeNameComposite = new Composite(content, SWT.NONE);\r\n+\t\ttypeNameComposite.setLayout(new GridLayout(2, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\ttypeNameComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(typeNameComposite, SWT.NONE);\r\n+\t\tlabel.setText(TYPE_NAME_LABEL);\r\n+\r\n+\t\ttypeNameText = new Text(typeNameComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tGridData dataText = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\ttypeNameText.setLayoutData(dataText);\r\n+\t\ttypeNameText.addSelectionListener(this);\r\n+\t\ttypeNameText.addModifyListener(this);\r\n+\r\n+\t\ttable = new Table(content, SWT.CHECK | SWT.BORDER | SWT.H_SCROLL);\r\n+\t\ttable.setLayout(new GridLayout());\r\n+\t\ttable.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL));\r\n+\t\ttable.setHeaderVisible(true);\r\n+\t\ttable.addSelectionListener(this);\r\n+\r\n+\t\tTableColumn columnColumnName = new TableColumn(table, SWT.NULL);\r\n+\t\tcolumnColumnName.setWidth(COLUMN_NAME_WIDTH);\r\n+\t\tcolumnColumnName.setText(COLUMN_NAME_LABEL);\r\n+\r\n+\t\tTableColumn columnType = new TableColumn(table, SWT.NONE | SWT.DROP_DOWN);\r\n+\t\tcolumnType.setText(COLUMN_TYPE_LABEL);\r\n+\t\tcolumnType.setWidth(COLUMN_TYPE_WIDTH);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Sets the input for the mapping table\r\n+\t * \r\n+\t * @param columnNames\r\n+\t *            a list of columns in the file\r\n+\t * @param requirementType\r\n+\t *            an existing requirement type\r\n+\t */\r\n+\tpublic void setInput(List<String> columnNames, RequirementType requirementType) {\r\n+\t\tthis.requirementType = requirementType;\r\n+\t\tthis.typeNameText.setText(requirementType.getName());\r\n+\t\tisNewType = requirementType.getTypeInstance().eContainer() == null;\r\n+\t\tif (!isNewType) {\r\n+\t\t\ttypeNameText.setEditable(false);\r\n+\t\t} else {\r\n+\t\t\ttypeNameText.setEditable(true);\r\n+\t\t}\r\n+\r\n+\t\ttable.clearAll();\r\n+\r\n+\t\tfor (String column : columnNames) {\r\n+\t\t\tInteger index = columnNames.indexOf(column);\r\n+\t\t\tTableItem item;\r\n+\t\t\tif (tableItems.size() <= index) {\r\n+\t\t\t\titem = new TableItem(table, SWT.NULL);\r\n+\t\t\t\ttableItems.add(item);\r\n+\t\t\t} else {\r\n+\t\t\t\titem = tableItems.get(index);\r\n+\t\t\t}\r\n+\t\t\titem.setText(0, column);\r\n+\r\n+\t\t\tif (isNewType) {\r\n+\t\t\t\titem.setText(TYPE_COLUMN_INDEX, requirementType.getAttributes().get(index).getType());\r\n+\t\t\t\titem.setChecked(true);\r\n+\t\t\t\tcreateDropDownEditor(item, ATTRIBUTE_TYPES);\r\n+\t\t\t} else {\r\n+\t\t\t\tif (index < requirementType.getAttributes().size()) {\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX,\r\n+\t\t\t\t\t\t\trequirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR\r\n+\t\t\t\t\t\t\t\t\t+ requirementType.getAttributes().get(index).getName());\r\n+\t\t\t\t\titem.setChecked(true);\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\titem.setChecked(false);\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX, \"\");\r\n+\t\t\t\t}\r\n+\t\t\t\t// If we use an exiting type then just try to map them from the attribute index\r\n+\t\t\t\tcreateDropDownEditor(item, requirementType.getAttributes().stream().map(\r\n+\t\t\t\t\t\tatt -> requirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR + att.getName())\r\n+\t\t\t\t\t\t.collect(Collectors.toList()));\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Method to create a drop down editor for the type column\r\n+\t * \r\n+\t * @param item\r\n+\t *            the item for which the editor should be created\r\n+\t * @param options\r\n+\t *            the input options\r\n+\t */\r\n+\tprivate void createDropDownEditor(TableItem item, List<String> options) {\r\n+\t\tint index = tableItems.indexOf(item);\r\n+\t\tCCombo typeDropdown;\r\n+\t\tif (editors.size() > index) {\r\n+\t\t\ttypeDropdown = editors.get(index);\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ3OTQ3NQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449479475", "bodyText": "Because SWT is weird :D See above", "author": "franzTobiasDLR", "createdAt": "2020-07-03T09:24:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MzcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5NzU2Ng==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449197566", "bodyText": "Here maybe also use an indexed for loop", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T18:27:51Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvTypeReviewPage.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import org.eclipse.jface.wizard.WizardPage;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.custom.CCombo;\r\n+import org.eclipse.swt.custom.TableEditor;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.events.SelectionListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Table;\r\n+import org.eclipse.swt.widgets.TableColumn;\r\n+import org.eclipse.swt.widgets.TableItem;\r\n+import org.eclipse.swt.widgets.Text;\r\n+\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+\r\n+/**\r\n+ * A wizard page to review the requirement type which is used for imports\r\n+ *\r\n+ */\r\n+public class CsvTypeReviewPage extends WizardPage implements SelectionListener, ModifyListener {\r\n+\r\n+\tprivate static final String COLUMN_NAME_LABEL = \"Column\";\r\n+\tprivate static final String COLUMN_TYPE_LABEL = \"Type\";\r\n+\r\n+\tprivate static final String TYPE_NAME_LABEL = \"Type Name\";\r\n+\tprivate static final int WITH_TEXT = 400;\r\n+\r\n+\tprivate static final int COLUMN_NAME_WIDTH = 300;\r\n+\tprivate static final int COLUMN_TYPE_WIDTH = 200;\r\n+\r\n+\tprivate static final List<String> ATTRIBUTE_TYPES = new ArrayList<String>(\r\n+\t\t\tArrays.asList(RequirementAttribute.TYPE_Boolean_NAME, RequirementAttribute.TYPE_Date_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Enumeration_NAME, RequirementAttribute.TYPE_Identifier_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Integer_NAME, RequirementAttribute.TYPE_Real_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_String_NAME));\r\n+\r\n+\tprivate static final int TYPE_COLUMN_INDEX = 1;\r\n+\tprivate static final String TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR = \"::\";\r\n+\r\n+\tprivate Text typeNameText;\r\n+\r\n+\tprivate Table table;\r\n+\tprivate List<TableItem> tableItems = new ArrayList<TableItem>();\r\n+\tprivate List<CCombo> editors = new ArrayList<CCombo>();\r\n+\r\n+\tprivate Map<Integer, RequirementAttribute> mapColumnIndexToAttributeType = new HashMap<>();\r\n+\tprivate RequirementType requirementType;\r\n+\tprivate boolean isNewType;\r\n+\r\n+\t/**\r\n+\t * Constructor\r\n+\t */\r\n+\tprotected CsvTypeReviewPage() {\r\n+\t\tsuper(\"Requirement Type Review\");\r\n+\t\tsetTitle(\"Requirement Type Review\");\r\n+\t\tsetDescription(\"Check the selected import type for the requirements.\");\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see\r\n+\t * org.eclipse.jface.dialogs.IDialogPage#createControl(org.eclipse.swt.widgets.\r\n+\t * Composite)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\r\n+\t\tComposite content = new Composite(parent, SWT.NONE);\r\n+\t\tcontent.setLayout(new GridLayout());\r\n+\t\tcontent.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_HORIZONTAL));\r\n+\t\tsetControl(content);\r\n+\r\n+\t\tComposite typeNameComposite = new Composite(content, SWT.NONE);\r\n+\t\ttypeNameComposite.setLayout(new GridLayout(2, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\ttypeNameComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(typeNameComposite, SWT.NONE);\r\n+\t\tlabel.setText(TYPE_NAME_LABEL);\r\n+\r\n+\t\ttypeNameText = new Text(typeNameComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tGridData dataText = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\ttypeNameText.setLayoutData(dataText);\r\n+\t\ttypeNameText.addSelectionListener(this);\r\n+\t\ttypeNameText.addModifyListener(this);\r\n+\r\n+\t\ttable = new Table(content, SWT.CHECK | SWT.BORDER | SWT.H_SCROLL);\r\n+\t\ttable.setLayout(new GridLayout());\r\n+\t\ttable.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL));\r\n+\t\ttable.setHeaderVisible(true);\r\n+\t\ttable.addSelectionListener(this);\r\n+\r\n+\t\tTableColumn columnColumnName = new TableColumn(table, SWT.NULL);\r\n+\t\tcolumnColumnName.setWidth(COLUMN_NAME_WIDTH);\r\n+\t\tcolumnColumnName.setText(COLUMN_NAME_LABEL);\r\n+\r\n+\t\tTableColumn columnType = new TableColumn(table, SWT.NONE | SWT.DROP_DOWN);\r\n+\t\tcolumnType.setText(COLUMN_TYPE_LABEL);\r\n+\t\tcolumnType.setWidth(COLUMN_TYPE_WIDTH);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Sets the input for the mapping table\r\n+\t * \r\n+\t * @param columnNames\r\n+\t *            a list of columns in the file\r\n+\t * @param requirementType\r\n+\t *            an existing requirement type\r\n+\t */\r\n+\tpublic void setInput(List<String> columnNames, RequirementType requirementType) {\r\n+\t\tthis.requirementType = requirementType;\r\n+\t\tthis.typeNameText.setText(requirementType.getName());\r\n+\t\tisNewType = requirementType.getTypeInstance().eContainer() == null;\r\n+\t\tif (!isNewType) {\r\n+\t\t\ttypeNameText.setEditable(false);\r\n+\t\t} else {\r\n+\t\t\ttypeNameText.setEditable(true);\r\n+\t\t}\r\n+\r\n+\t\ttable.clearAll();\r\n+\r\n+\t\tfor (String column : columnNames) {\r\n+\t\t\tInteger index = columnNames.indexOf(column);\r\n+\t\t\tTableItem item;\r\n+\t\t\tif (tableItems.size() <= index) {\r\n+\t\t\t\titem = new TableItem(table, SWT.NULL);\r\n+\t\t\t\ttableItems.add(item);\r\n+\t\t\t} else {\r\n+\t\t\t\titem = tableItems.get(index);\r\n+\t\t\t}\r\n+\t\t\titem.setText(0, column);\r\n+\r\n+\t\t\tif (isNewType) {\r\n+\t\t\t\titem.setText(TYPE_COLUMN_INDEX, requirementType.getAttributes().get(index).getType());\r\n+\t\t\t\titem.setChecked(true);\r\n+\t\t\t\tcreateDropDownEditor(item, ATTRIBUTE_TYPES);\r\n+\t\t\t} else {\r\n+\t\t\t\tif (index < requirementType.getAttributes().size()) {\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX,\r\n+\t\t\t\t\t\t\trequirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR\r\n+\t\t\t\t\t\t\t\t\t+ requirementType.getAttributes().get(index).getName());\r\n+\t\t\t\t\titem.setChecked(true);\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\titem.setChecked(false);\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX, \"\");\r\n+\t\t\t\t}\r\n+\t\t\t\t// If we use an exiting type then just try to map them from the attribute index\r\n+\t\t\t\tcreateDropDownEditor(item, requirementType.getAttributes().stream().map(\r\n+\t\t\t\t\t\tatt -> requirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR + att.getName())\r\n+\t\t\t\t\t\t.collect(Collectors.toList()));\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Method to create a drop down editor for the type column\r\n+\t * \r\n+\t * @param item\r\n+\t *            the item for which the editor should be created\r\n+\t * @param options\r\n+\t *            the input options\r\n+\t */\r\n+\tprivate void createDropDownEditor(TableItem item, List<String> options) {\r\n+\t\tint index = tableItems.indexOf(item);\r\n+\t\tCCombo typeDropdown;\r\n+\t\tif (editors.size() > index) {\r\n+\t\t\ttypeDropdown = editors.get(index);\r\n+\t\t\ttypeDropdown.removeAll();\r\n+\t\t} else {\r\n+\t\t\ttypeDropdown = new CCombo(table, SWT.NONE);\r\n+\t\t\teditors.add(typeDropdown);\r\n+\t\t}\r\n+\t\ttypeDropdown.setText(item.getText(TYPE_COLUMN_INDEX));\r\n+\t\tfor (String option : options) {\r\n+\t\t\ttypeDropdown.add(option);\r\n+\t\t}\r\n+\t\tfinal TableEditor editor = new TableEditor(table);\r\n+\t\teditor.grabHorizontal = true;\r\n+\t\teditor.setEditor(typeDropdown, item, TYPE_COLUMN_INDEX);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Get the mapping of columns to their attribute in specified requirement type\r\n+\t * \r\n+\t * @return a map of the column index to their attribute definition type\r\n+\t */\r\n+\tpublic Map<Integer, RequirementAttribute> getAttributeMapping() {\r\n+\r\n+\t\tfor (TableItem item : tableItems) {\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMTY2MQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449201661", "bodyText": "Weird comment", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T18:36:35Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvTypeReviewPage.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import org.eclipse.jface.wizard.WizardPage;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.custom.CCombo;\r\n+import org.eclipse.swt.custom.TableEditor;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.events.SelectionListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Table;\r\n+import org.eclipse.swt.widgets.TableColumn;\r\n+import org.eclipse.swt.widgets.TableItem;\r\n+import org.eclipse.swt.widgets.Text;\r\n+\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+\r\n+/**\r\n+ * A wizard page to review the requirement type which is used for imports\r\n+ *\r\n+ */\r\n+public class CsvTypeReviewPage extends WizardPage implements SelectionListener, ModifyListener {\r\n+\r\n+\tprivate static final String COLUMN_NAME_LABEL = \"Column\";\r\n+\tprivate static final String COLUMN_TYPE_LABEL = \"Type\";\r\n+\r\n+\tprivate static final String TYPE_NAME_LABEL = \"Type Name\";\r\n+\tprivate static final int WITH_TEXT = 400;\r\n+\r\n+\tprivate static final int COLUMN_NAME_WIDTH = 300;\r\n+\tprivate static final int COLUMN_TYPE_WIDTH = 200;\r\n+\r\n+\tprivate static final List<String> ATTRIBUTE_TYPES = new ArrayList<String>(\r\n+\t\t\tArrays.asList(RequirementAttribute.TYPE_Boolean_NAME, RequirementAttribute.TYPE_Date_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Enumeration_NAME, RequirementAttribute.TYPE_Identifier_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Integer_NAME, RequirementAttribute.TYPE_Real_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_String_NAME));\r\n+\r\n+\tprivate static final int TYPE_COLUMN_INDEX = 1;\r\n+\tprivate static final String TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR = \"::\";\r\n+\r\n+\tprivate Text typeNameText;\r\n+\r\n+\tprivate Table table;\r\n+\tprivate List<TableItem> tableItems = new ArrayList<TableItem>();\r\n+\tprivate List<CCombo> editors = new ArrayList<CCombo>();\r\n+\r\n+\tprivate Map<Integer, RequirementAttribute> mapColumnIndexToAttributeType = new HashMap<>();\r\n+\tprivate RequirementType requirementType;\r\n+\tprivate boolean isNewType;\r\n+\r\n+\t/**\r\n+\t * Constructor\r\n+\t */\r\n+\tprotected CsvTypeReviewPage() {\r\n+\t\tsuper(\"Requirement Type Review\");\r\n+\t\tsetTitle(\"Requirement Type Review\");\r\n+\t\tsetDescription(\"Check the selected import type for the requirements.\");\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see\r\n+\t * org.eclipse.jface.dialogs.IDialogPage#createControl(org.eclipse.swt.widgets.\r\n+\t * Composite)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\r\n+\t\tComposite content = new Composite(parent, SWT.NONE);\r\n+\t\tcontent.setLayout(new GridLayout());\r\n+\t\tcontent.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_HORIZONTAL));\r\n+\t\tsetControl(content);\r\n+\r\n+\t\tComposite typeNameComposite = new Composite(content, SWT.NONE);\r\n+\t\ttypeNameComposite.setLayout(new GridLayout(2, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\ttypeNameComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(typeNameComposite, SWT.NONE);\r\n+\t\tlabel.setText(TYPE_NAME_LABEL);\r\n+\r\n+\t\ttypeNameText = new Text(typeNameComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tGridData dataText = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\ttypeNameText.setLayoutData(dataText);\r\n+\t\ttypeNameText.addSelectionListener(this);\r\n+\t\ttypeNameText.addModifyListener(this);\r\n+\r\n+\t\ttable = new Table(content, SWT.CHECK | SWT.BORDER | SWT.H_SCROLL);\r\n+\t\ttable.setLayout(new GridLayout());\r\n+\t\ttable.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL));\r\n+\t\ttable.setHeaderVisible(true);\r\n+\t\ttable.addSelectionListener(this);\r\n+\r\n+\t\tTableColumn columnColumnName = new TableColumn(table, SWT.NULL);\r\n+\t\tcolumnColumnName.setWidth(COLUMN_NAME_WIDTH);\r\n+\t\tcolumnColumnName.setText(COLUMN_NAME_LABEL);\r\n+\r\n+\t\tTableColumn columnType = new TableColumn(table, SWT.NONE | SWT.DROP_DOWN);\r\n+\t\tcolumnType.setText(COLUMN_TYPE_LABEL);\r\n+\t\tcolumnType.setWidth(COLUMN_TYPE_WIDTH);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Sets the input for the mapping table\r\n+\t * \r\n+\t * @param columnNames\r\n+\t *            a list of columns in the file\r\n+\t * @param requirementType\r\n+\t *            an existing requirement type\r\n+\t */\r\n+\tpublic void setInput(List<String> columnNames, RequirementType requirementType) {\r\n+\t\tthis.requirementType = requirementType;\r\n+\t\tthis.typeNameText.setText(requirementType.getName());\r\n+\t\tisNewType = requirementType.getTypeInstance().eContainer() == null;\r\n+\t\tif (!isNewType) {\r\n+\t\t\ttypeNameText.setEditable(false);\r\n+\t\t} else {\r\n+\t\t\ttypeNameText.setEditable(true);\r\n+\t\t}\r\n+\r\n+\t\ttable.clearAll();\r\n+\r\n+\t\tfor (String column : columnNames) {\r\n+\t\t\tInteger index = columnNames.indexOf(column);\r\n+\t\t\tTableItem item;\r\n+\t\t\tif (tableItems.size() <= index) {\r\n+\t\t\t\titem = new TableItem(table, SWT.NULL);\r\n+\t\t\t\ttableItems.add(item);\r\n+\t\t\t} else {\r\n+\t\t\t\titem = tableItems.get(index);\r\n+\t\t\t}\r\n+\t\t\titem.setText(0, column);\r\n+\r\n+\t\t\tif (isNewType) {\r\n+\t\t\t\titem.setText(TYPE_COLUMN_INDEX, requirementType.getAttributes().get(index).getType());\r\n+\t\t\t\titem.setChecked(true);\r\n+\t\t\t\tcreateDropDownEditor(item, ATTRIBUTE_TYPES);\r\n+\t\t\t} else {\r\n+\t\t\t\tif (index < requirementType.getAttributes().size()) {\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX,\r\n+\t\t\t\t\t\t\trequirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR\r\n+\t\t\t\t\t\t\t\t\t+ requirementType.getAttributes().get(index).getName());\r\n+\t\t\t\t\titem.setChecked(true);\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\titem.setChecked(false);\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX, \"\");\r\n+\t\t\t\t}\r\n+\t\t\t\t// If we use an exiting type then just try to map them from the attribute index\r\n+\t\t\t\tcreateDropDownEditor(item, requirementType.getAttributes().stream().map(\r\n+\t\t\t\t\t\tatt -> requirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR + att.getName())\r\n+\t\t\t\t\t\t.collect(Collectors.toList()));\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Method to create a drop down editor for the type column\r\n+\t * \r\n+\t * @param item\r\n+\t *            the item for which the editor should be created\r\n+\t * @param options\r\n+\t *            the input options\r\n+\t */\r\n+\tprivate void createDropDownEditor(TableItem item, List<String> options) {\r\n+\t\tint index = tableItems.indexOf(item);\r\n+\t\tCCombo typeDropdown;\r\n+\t\tif (editors.size() > index) {\r\n+\t\t\ttypeDropdown = editors.get(index);\r\n+\t\t\ttypeDropdown.removeAll();\r\n+\t\t} else {\r\n+\t\t\ttypeDropdown = new CCombo(table, SWT.NONE);\r\n+\t\t\teditors.add(typeDropdown);\r\n+\t\t}\r\n+\t\ttypeDropdown.setText(item.getText(TYPE_COLUMN_INDEX));\r\n+\t\tfor (String option : options) {\r\n+\t\t\ttypeDropdown.add(option);\r\n+\t\t}\r\n+\t\tfinal TableEditor editor = new TableEditor(table);\r\n+\t\teditor.grabHorizontal = true;\r\n+\t\teditor.setEditor(typeDropdown, item, TYPE_COLUMN_INDEX);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Get the mapping of columns to their attribute in specified requirement type\r\n+\t * \r\n+\t * @return a map of the column index to their attribute definition type\r\n+\t */\r\n+\tpublic Map<Integer, RequirementAttribute> getAttributeMapping() {\r\n+\r\n+\t\tfor (TableItem item : tableItems) {\r\n+\t\t\tInteger index = tableItems.indexOf(item);\r\n+\r\n+\t\t\tif (item.getChecked()) {\r\n+\t\t\t\tif (isNewType) {\r\n+\t\t\t\t\tString selectedType = editors.get(index).getText();\r\n+\r\n+\t\t\t\t\tRequirementAttribute correspondingAtt = requirementType.getAttributes().get(index);\r\n+\r\n+\t\t\t\t\t// Check if type is new and valid and then add it to the new requirement type\r\n+\t\t\t\t\tif (ATTRIBUTE_TYPES.contains(selectedType) && !selectedType.equals(correspondingAtt.getType())) {\r\n+\t\t\t\t\t\tcorrespondingAtt.setType(selectedType);\r\n+\t\t\t\t\t}\r\n+\r\n+\t\t\t\t\t// Add corresponding attribute to mapping\r\n+\t\t\t\t\tmapColumnIndexToAttributeType.put(index, correspondingAtt);\r\n+\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\tString inputString = editors.get(index).getText();\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tRequirementAttribute selectedAttribute = getSelectedAttribute(inputString);\r\n+\t\t\t\t\tif (selectedAttribute != null) {\r\n+\t\t\t\t\t\tmapColumnIndexToAttributeType.put(index, selectedAttribute);\r\n+\t\t\t\t\t}\r\n+\r\n+\t\t\t\t}\r\n+\t\t\t} \r\n+\r\n+\t\t}\r\n+\r\n+\t\treturn mapColumnIndexToAttributeType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Get the configured requirement type for the import\r\n+\t * \r\n+\t * @return the requirement type\r\n+\t */\r\n+\tpublic RequirementType getRequirementType() {\r\n+\t\tif (isNewType) {\r\n+\t\t\tfor (RequirementAttribute att : requirementType.getAttributes()) {\r\n+\t\t\t\tif (!mapColumnIndexToAttributeType.containsValue(att)) {\r\n+\t\t\t\t\trequirementType.getAttributes().remove(att);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\treturn requirementType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Parse the attribute from the editor input string\r\n+\t * \r\n+\t * @param inputString\r\n+\t *            the editor input string\r\n+\t * @return the attibute\r\n+\t */\r\n+\tprivate RequirementAttribute getSelectedAttribute(String inputString) {\r\n+\r\n+\t\t// Remove context indication from attribute\r\n+\t\tinputString = inputString.replace(requirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR, \"\");\r\n+\r\n+\t\tfor (RequirementAttribute att : requirementType.getAttributes()) {\r\n+\r\n+\t\t\tif (att.getName().equals(inputString)) {\r\n+\t\t\t\treturn att;\r\n+\t\t\t}\r\n+\r\n+\t\t}\r\n+\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see org.eclipse.swt.events.SelectionListener#widgetSelected(org.eclipse.swt.\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMTc1OQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449201759", "bodyText": "Strange comment", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T18:36:47Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvTypeReviewPage.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import org.eclipse.jface.wizard.WizardPage;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.custom.CCombo;\r\n+import org.eclipse.swt.custom.TableEditor;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.events.SelectionListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Table;\r\n+import org.eclipse.swt.widgets.TableColumn;\r\n+import org.eclipse.swt.widgets.TableItem;\r\n+import org.eclipse.swt.widgets.Text;\r\n+\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+\r\n+/**\r\n+ * A wizard page to review the requirement type which is used for imports\r\n+ *\r\n+ */\r\n+public class CsvTypeReviewPage extends WizardPage implements SelectionListener, ModifyListener {\r\n+\r\n+\tprivate static final String COLUMN_NAME_LABEL = \"Column\";\r\n+\tprivate static final String COLUMN_TYPE_LABEL = \"Type\";\r\n+\r\n+\tprivate static final String TYPE_NAME_LABEL = \"Type Name\";\r\n+\tprivate static final int WITH_TEXT = 400;\r\n+\r\n+\tprivate static final int COLUMN_NAME_WIDTH = 300;\r\n+\tprivate static final int COLUMN_TYPE_WIDTH = 200;\r\n+\r\n+\tprivate static final List<String> ATTRIBUTE_TYPES = new ArrayList<String>(\r\n+\t\t\tArrays.asList(RequirementAttribute.TYPE_Boolean_NAME, RequirementAttribute.TYPE_Date_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Enumeration_NAME, RequirementAttribute.TYPE_Identifier_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Integer_NAME, RequirementAttribute.TYPE_Real_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_String_NAME));\r\n+\r\n+\tprivate static final int TYPE_COLUMN_INDEX = 1;\r\n+\tprivate static final String TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR = \"::\";\r\n+\r\n+\tprivate Text typeNameText;\r\n+\r\n+\tprivate Table table;\r\n+\tprivate List<TableItem> tableItems = new ArrayList<TableItem>();\r\n+\tprivate List<CCombo> editors = new ArrayList<CCombo>();\r\n+\r\n+\tprivate Map<Integer, RequirementAttribute> mapColumnIndexToAttributeType = new HashMap<>();\r\n+\tprivate RequirementType requirementType;\r\n+\tprivate boolean isNewType;\r\n+\r\n+\t/**\r\n+\t * Constructor\r\n+\t */\r\n+\tprotected CsvTypeReviewPage() {\r\n+\t\tsuper(\"Requirement Type Review\");\r\n+\t\tsetTitle(\"Requirement Type Review\");\r\n+\t\tsetDescription(\"Check the selected import type for the requirements.\");\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see\r\n+\t * org.eclipse.jface.dialogs.IDialogPage#createControl(org.eclipse.swt.widgets.\r\n+\t * Composite)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\r\n+\t\tComposite content = new Composite(parent, SWT.NONE);\r\n+\t\tcontent.setLayout(new GridLayout());\r\n+\t\tcontent.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_HORIZONTAL));\r\n+\t\tsetControl(content);\r\n+\r\n+\t\tComposite typeNameComposite = new Composite(content, SWT.NONE);\r\n+\t\ttypeNameComposite.setLayout(new GridLayout(2, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\ttypeNameComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(typeNameComposite, SWT.NONE);\r\n+\t\tlabel.setText(TYPE_NAME_LABEL);\r\n+\r\n+\t\ttypeNameText = new Text(typeNameComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tGridData dataText = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\ttypeNameText.setLayoutData(dataText);\r\n+\t\ttypeNameText.addSelectionListener(this);\r\n+\t\ttypeNameText.addModifyListener(this);\r\n+\r\n+\t\ttable = new Table(content, SWT.CHECK | SWT.BORDER | SWT.H_SCROLL);\r\n+\t\ttable.setLayout(new GridLayout());\r\n+\t\ttable.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL));\r\n+\t\ttable.setHeaderVisible(true);\r\n+\t\ttable.addSelectionListener(this);\r\n+\r\n+\t\tTableColumn columnColumnName = new TableColumn(table, SWT.NULL);\r\n+\t\tcolumnColumnName.setWidth(COLUMN_NAME_WIDTH);\r\n+\t\tcolumnColumnName.setText(COLUMN_NAME_LABEL);\r\n+\r\n+\t\tTableColumn columnType = new TableColumn(table, SWT.NONE | SWT.DROP_DOWN);\r\n+\t\tcolumnType.setText(COLUMN_TYPE_LABEL);\r\n+\t\tcolumnType.setWidth(COLUMN_TYPE_WIDTH);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Sets the input for the mapping table\r\n+\t * \r\n+\t * @param columnNames\r\n+\t *            a list of columns in the file\r\n+\t * @param requirementType\r\n+\t *            an existing requirement type\r\n+\t */\r\n+\tpublic void setInput(List<String> columnNames, RequirementType requirementType) {\r\n+\t\tthis.requirementType = requirementType;\r\n+\t\tthis.typeNameText.setText(requirementType.getName());\r\n+\t\tisNewType = requirementType.getTypeInstance().eContainer() == null;\r\n+\t\tif (!isNewType) {\r\n+\t\t\ttypeNameText.setEditable(false);\r\n+\t\t} else {\r\n+\t\t\ttypeNameText.setEditable(true);\r\n+\t\t}\r\n+\r\n+\t\ttable.clearAll();\r\n+\r\n+\t\tfor (String column : columnNames) {\r\n+\t\t\tInteger index = columnNames.indexOf(column);\r\n+\t\t\tTableItem item;\r\n+\t\t\tif (tableItems.size() <= index) {\r\n+\t\t\t\titem = new TableItem(table, SWT.NULL);\r\n+\t\t\t\ttableItems.add(item);\r\n+\t\t\t} else {\r\n+\t\t\t\titem = tableItems.get(index);\r\n+\t\t\t}\r\n+\t\t\titem.setText(0, column);\r\n+\r\n+\t\t\tif (isNewType) {\r\n+\t\t\t\titem.setText(TYPE_COLUMN_INDEX, requirementType.getAttributes().get(index).getType());\r\n+\t\t\t\titem.setChecked(true);\r\n+\t\t\t\tcreateDropDownEditor(item, ATTRIBUTE_TYPES);\r\n+\t\t\t} else {\r\n+\t\t\t\tif (index < requirementType.getAttributes().size()) {\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX,\r\n+\t\t\t\t\t\t\trequirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR\r\n+\t\t\t\t\t\t\t\t\t+ requirementType.getAttributes().get(index).getName());\r\n+\t\t\t\t\titem.setChecked(true);\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\titem.setChecked(false);\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX, \"\");\r\n+\t\t\t\t}\r\n+\t\t\t\t// If we use an exiting type then just try to map them from the attribute index\r\n+\t\t\t\tcreateDropDownEditor(item, requirementType.getAttributes().stream().map(\r\n+\t\t\t\t\t\tatt -> requirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR + att.getName())\r\n+\t\t\t\t\t\t.collect(Collectors.toList()));\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Method to create a drop down editor for the type column\r\n+\t * \r\n+\t * @param item\r\n+\t *            the item for which the editor should be created\r\n+\t * @param options\r\n+\t *            the input options\r\n+\t */\r\n+\tprivate void createDropDownEditor(TableItem item, List<String> options) {\r\n+\t\tint index = tableItems.indexOf(item);\r\n+\t\tCCombo typeDropdown;\r\n+\t\tif (editors.size() > index) {\r\n+\t\t\ttypeDropdown = editors.get(index);\r\n+\t\t\ttypeDropdown.removeAll();\r\n+\t\t} else {\r\n+\t\t\ttypeDropdown = new CCombo(table, SWT.NONE);\r\n+\t\t\teditors.add(typeDropdown);\r\n+\t\t}\r\n+\t\ttypeDropdown.setText(item.getText(TYPE_COLUMN_INDEX));\r\n+\t\tfor (String option : options) {\r\n+\t\t\ttypeDropdown.add(option);\r\n+\t\t}\r\n+\t\tfinal TableEditor editor = new TableEditor(table);\r\n+\t\teditor.grabHorizontal = true;\r\n+\t\teditor.setEditor(typeDropdown, item, TYPE_COLUMN_INDEX);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Get the mapping of columns to their attribute in specified requirement type\r\n+\t * \r\n+\t * @return a map of the column index to their attribute definition type\r\n+\t */\r\n+\tpublic Map<Integer, RequirementAttribute> getAttributeMapping() {\r\n+\r\n+\t\tfor (TableItem item : tableItems) {\r\n+\t\t\tInteger index = tableItems.indexOf(item);\r\n+\r\n+\t\t\tif (item.getChecked()) {\r\n+\t\t\t\tif (isNewType) {\r\n+\t\t\t\t\tString selectedType = editors.get(index).getText();\r\n+\r\n+\t\t\t\t\tRequirementAttribute correspondingAtt = requirementType.getAttributes().get(index);\r\n+\r\n+\t\t\t\t\t// Check if type is new and valid and then add it to the new requirement type\r\n+\t\t\t\t\tif (ATTRIBUTE_TYPES.contains(selectedType) && !selectedType.equals(correspondingAtt.getType())) {\r\n+\t\t\t\t\t\tcorrespondingAtt.setType(selectedType);\r\n+\t\t\t\t\t}\r\n+\r\n+\t\t\t\t\t// Add corresponding attribute to mapping\r\n+\t\t\t\t\tmapColumnIndexToAttributeType.put(index, correspondingAtt);\r\n+\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\tString inputString = editors.get(index).getText();\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tRequirementAttribute selectedAttribute = getSelectedAttribute(inputString);\r\n+\t\t\t\t\tif (selectedAttribute != null) {\r\n+\t\t\t\t\t\tmapColumnIndexToAttributeType.put(index, selectedAttribute);\r\n+\t\t\t\t\t}\r\n+\r\n+\t\t\t\t}\r\n+\t\t\t} \r\n+\r\n+\t\t}\r\n+\r\n+\t\treturn mapColumnIndexToAttributeType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Get the configured requirement type for the import\r\n+\t * \r\n+\t * @return the requirement type\r\n+\t */\r\n+\tpublic RequirementType getRequirementType() {\r\n+\t\tif (isNewType) {\r\n+\t\t\tfor (RequirementAttribute att : requirementType.getAttributes()) {\r\n+\t\t\t\tif (!mapColumnIndexToAttributeType.containsValue(att)) {\r\n+\t\t\t\t\trequirementType.getAttributes().remove(att);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\treturn requirementType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Parse the attribute from the editor input string\r\n+\t * \r\n+\t * @param inputString\r\n+\t *            the editor input string\r\n+\t * @return the attibute\r\n+\t */\r\n+\tprivate RequirementAttribute getSelectedAttribute(String inputString) {\r\n+\r\n+\t\t// Remove context indication from attribute\r\n+\t\tinputString = inputString.replace(requirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR, \"\");\r\n+\r\n+\t\tfor (RequirementAttribute att : requirementType.getAttributes()) {\r\n+\r\n+\t\t\tif (att.getName().equals(inputString)) {\r\n+\t\t\t\treturn att;\r\n+\t\t\t}\r\n+\r\n+\t\t}\r\n+\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see org.eclipse.swt.events.SelectionListener#widgetSelected(org.eclipse.swt.\r\n+\t * events.SelectionEvent)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void widgetSelected(SelectionEvent e) {\r\n+\t\tif (e.getSource().equals(table) && e.detail == SWT.CHECK) {\r\n+\t\t\tTableItem item = (TableItem) e.item;\r\n+\t\t\tCCombo editor = editors.get(tableItems.indexOf(item));\r\n+\t\t\tif (item.getChecked()) {\r\n+\t\t\t\teditor.setEditable(true);\r\n+\t\t\t} else {\r\n+\t\t\t\teditor.setEditable(false);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\t\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see\r\n+\t * org.eclipse.swt.events.SelectionListener#widgetDefaultSelected(org.eclipse.\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMTgzMg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449201832", "bodyText": "Unusual comment", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T18:36:57Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvTypeReviewPage.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import org.eclipse.jface.wizard.WizardPage;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.custom.CCombo;\r\n+import org.eclipse.swt.custom.TableEditor;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.events.SelectionListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Table;\r\n+import org.eclipse.swt.widgets.TableColumn;\r\n+import org.eclipse.swt.widgets.TableItem;\r\n+import org.eclipse.swt.widgets.Text;\r\n+\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+\r\n+/**\r\n+ * A wizard page to review the requirement type which is used for imports\r\n+ *\r\n+ */\r\n+public class CsvTypeReviewPage extends WizardPage implements SelectionListener, ModifyListener {\r\n+\r\n+\tprivate static final String COLUMN_NAME_LABEL = \"Column\";\r\n+\tprivate static final String COLUMN_TYPE_LABEL = \"Type\";\r\n+\r\n+\tprivate static final String TYPE_NAME_LABEL = \"Type Name\";\r\n+\tprivate static final int WITH_TEXT = 400;\r\n+\r\n+\tprivate static final int COLUMN_NAME_WIDTH = 300;\r\n+\tprivate static final int COLUMN_TYPE_WIDTH = 200;\r\n+\r\n+\tprivate static final List<String> ATTRIBUTE_TYPES = new ArrayList<String>(\r\n+\t\t\tArrays.asList(RequirementAttribute.TYPE_Boolean_NAME, RequirementAttribute.TYPE_Date_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Enumeration_NAME, RequirementAttribute.TYPE_Identifier_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Integer_NAME, RequirementAttribute.TYPE_Real_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_String_NAME));\r\n+\r\n+\tprivate static final int TYPE_COLUMN_INDEX = 1;\r\n+\tprivate static final String TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR = \"::\";\r\n+\r\n+\tprivate Text typeNameText;\r\n+\r\n+\tprivate Table table;\r\n+\tprivate List<TableItem> tableItems = new ArrayList<TableItem>();\r\n+\tprivate List<CCombo> editors = new ArrayList<CCombo>();\r\n+\r\n+\tprivate Map<Integer, RequirementAttribute> mapColumnIndexToAttributeType = new HashMap<>();\r\n+\tprivate RequirementType requirementType;\r\n+\tprivate boolean isNewType;\r\n+\r\n+\t/**\r\n+\t * Constructor\r\n+\t */\r\n+\tprotected CsvTypeReviewPage() {\r\n+\t\tsuper(\"Requirement Type Review\");\r\n+\t\tsetTitle(\"Requirement Type Review\");\r\n+\t\tsetDescription(\"Check the selected import type for the requirements.\");\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see\r\n+\t * org.eclipse.jface.dialogs.IDialogPage#createControl(org.eclipse.swt.widgets.\r\n+\t * Composite)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\r\n+\t\tComposite content = new Composite(parent, SWT.NONE);\r\n+\t\tcontent.setLayout(new GridLayout());\r\n+\t\tcontent.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_HORIZONTAL));\r\n+\t\tsetControl(content);\r\n+\r\n+\t\tComposite typeNameComposite = new Composite(content, SWT.NONE);\r\n+\t\ttypeNameComposite.setLayout(new GridLayout(2, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\ttypeNameComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(typeNameComposite, SWT.NONE);\r\n+\t\tlabel.setText(TYPE_NAME_LABEL);\r\n+\r\n+\t\ttypeNameText = new Text(typeNameComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tGridData dataText = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\ttypeNameText.setLayoutData(dataText);\r\n+\t\ttypeNameText.addSelectionListener(this);\r\n+\t\ttypeNameText.addModifyListener(this);\r\n+\r\n+\t\ttable = new Table(content, SWT.CHECK | SWT.BORDER | SWT.H_SCROLL);\r\n+\t\ttable.setLayout(new GridLayout());\r\n+\t\ttable.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL));\r\n+\t\ttable.setHeaderVisible(true);\r\n+\t\ttable.addSelectionListener(this);\r\n+\r\n+\t\tTableColumn columnColumnName = new TableColumn(table, SWT.NULL);\r\n+\t\tcolumnColumnName.setWidth(COLUMN_NAME_WIDTH);\r\n+\t\tcolumnColumnName.setText(COLUMN_NAME_LABEL);\r\n+\r\n+\t\tTableColumn columnType = new TableColumn(table, SWT.NONE | SWT.DROP_DOWN);\r\n+\t\tcolumnType.setText(COLUMN_TYPE_LABEL);\r\n+\t\tcolumnType.setWidth(COLUMN_TYPE_WIDTH);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Sets the input for the mapping table\r\n+\t * \r\n+\t * @param columnNames\r\n+\t *            a list of columns in the file\r\n+\t * @param requirementType\r\n+\t *            an existing requirement type\r\n+\t */\r\n+\tpublic void setInput(List<String> columnNames, RequirementType requirementType) {\r\n+\t\tthis.requirementType = requirementType;\r\n+\t\tthis.typeNameText.setText(requirementType.getName());\r\n+\t\tisNewType = requirementType.getTypeInstance().eContainer() == null;\r\n+\t\tif (!isNewType) {\r\n+\t\t\ttypeNameText.setEditable(false);\r\n+\t\t} else {\r\n+\t\t\ttypeNameText.setEditable(true);\r\n+\t\t}\r\n+\r\n+\t\ttable.clearAll();\r\n+\r\n+\t\tfor (String column : columnNames) {\r\n+\t\t\tInteger index = columnNames.indexOf(column);\r\n+\t\t\tTableItem item;\r\n+\t\t\tif (tableItems.size() <= index) {\r\n+\t\t\t\titem = new TableItem(table, SWT.NULL);\r\n+\t\t\t\ttableItems.add(item);\r\n+\t\t\t} else {\r\n+\t\t\t\titem = tableItems.get(index);\r\n+\t\t\t}\r\n+\t\t\titem.setText(0, column);\r\n+\r\n+\t\t\tif (isNewType) {\r\n+\t\t\t\titem.setText(TYPE_COLUMN_INDEX, requirementType.getAttributes().get(index).getType());\r\n+\t\t\t\titem.setChecked(true);\r\n+\t\t\t\tcreateDropDownEditor(item, ATTRIBUTE_TYPES);\r\n+\t\t\t} else {\r\n+\t\t\t\tif (index < requirementType.getAttributes().size()) {\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX,\r\n+\t\t\t\t\t\t\trequirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR\r\n+\t\t\t\t\t\t\t\t\t+ requirementType.getAttributes().get(index).getName());\r\n+\t\t\t\t\titem.setChecked(true);\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\titem.setChecked(false);\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX, \"\");\r\n+\t\t\t\t}\r\n+\t\t\t\t// If we use an exiting type then just try to map them from the attribute index\r\n+\t\t\t\tcreateDropDownEditor(item, requirementType.getAttributes().stream().map(\r\n+\t\t\t\t\t\tatt -> requirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR + att.getName())\r\n+\t\t\t\t\t\t.collect(Collectors.toList()));\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Method to create a drop down editor for the type column\r\n+\t * \r\n+\t * @param item\r\n+\t *            the item for which the editor should be created\r\n+\t * @param options\r\n+\t *            the input options\r\n+\t */\r\n+\tprivate void createDropDownEditor(TableItem item, List<String> options) {\r\n+\t\tint index = tableItems.indexOf(item);\r\n+\t\tCCombo typeDropdown;\r\n+\t\tif (editors.size() > index) {\r\n+\t\t\ttypeDropdown = editors.get(index);\r\n+\t\t\ttypeDropdown.removeAll();\r\n+\t\t} else {\r\n+\t\t\ttypeDropdown = new CCombo(table, SWT.NONE);\r\n+\t\t\teditors.add(typeDropdown);\r\n+\t\t}\r\n+\t\ttypeDropdown.setText(item.getText(TYPE_COLUMN_INDEX));\r\n+\t\tfor (String option : options) {\r\n+\t\t\ttypeDropdown.add(option);\r\n+\t\t}\r\n+\t\tfinal TableEditor editor = new TableEditor(table);\r\n+\t\teditor.grabHorizontal = true;\r\n+\t\teditor.setEditor(typeDropdown, item, TYPE_COLUMN_INDEX);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Get the mapping of columns to their attribute in specified requirement type\r\n+\t * \r\n+\t * @return a map of the column index to their attribute definition type\r\n+\t */\r\n+\tpublic Map<Integer, RequirementAttribute> getAttributeMapping() {\r\n+\r\n+\t\tfor (TableItem item : tableItems) {\r\n+\t\t\tInteger index = tableItems.indexOf(item);\r\n+\r\n+\t\t\tif (item.getChecked()) {\r\n+\t\t\t\tif (isNewType) {\r\n+\t\t\t\t\tString selectedType = editors.get(index).getText();\r\n+\r\n+\t\t\t\t\tRequirementAttribute correspondingAtt = requirementType.getAttributes().get(index);\r\n+\r\n+\t\t\t\t\t// Check if type is new and valid and then add it to the new requirement type\r\n+\t\t\t\t\tif (ATTRIBUTE_TYPES.contains(selectedType) && !selectedType.equals(correspondingAtt.getType())) {\r\n+\t\t\t\t\t\tcorrespondingAtt.setType(selectedType);\r\n+\t\t\t\t\t}\r\n+\r\n+\t\t\t\t\t// Add corresponding attribute to mapping\r\n+\t\t\t\t\tmapColumnIndexToAttributeType.put(index, correspondingAtt);\r\n+\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\tString inputString = editors.get(index).getText();\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tRequirementAttribute selectedAttribute = getSelectedAttribute(inputString);\r\n+\t\t\t\t\tif (selectedAttribute != null) {\r\n+\t\t\t\t\t\tmapColumnIndexToAttributeType.put(index, selectedAttribute);\r\n+\t\t\t\t\t}\r\n+\r\n+\t\t\t\t}\r\n+\t\t\t} \r\n+\r\n+\t\t}\r\n+\r\n+\t\treturn mapColumnIndexToAttributeType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Get the configured requirement type for the import\r\n+\t * \r\n+\t * @return the requirement type\r\n+\t */\r\n+\tpublic RequirementType getRequirementType() {\r\n+\t\tif (isNewType) {\r\n+\t\t\tfor (RequirementAttribute att : requirementType.getAttributes()) {\r\n+\t\t\t\tif (!mapColumnIndexToAttributeType.containsValue(att)) {\r\n+\t\t\t\t\trequirementType.getAttributes().remove(att);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\treturn requirementType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Parse the attribute from the editor input string\r\n+\t * \r\n+\t * @param inputString\r\n+\t *            the editor input string\r\n+\t * @return the attibute\r\n+\t */\r\n+\tprivate RequirementAttribute getSelectedAttribute(String inputString) {\r\n+\r\n+\t\t// Remove context indication from attribute\r\n+\t\tinputString = inputString.replace(requirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR, \"\");\r\n+\r\n+\t\tfor (RequirementAttribute att : requirementType.getAttributes()) {\r\n+\r\n+\t\t\tif (att.getName().equals(inputString)) {\r\n+\t\t\t\treturn att;\r\n+\t\t\t}\r\n+\r\n+\t\t}\r\n+\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see org.eclipse.swt.events.SelectionListener#widgetSelected(org.eclipse.swt.\r\n+\t * events.SelectionEvent)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void widgetSelected(SelectionEvent e) {\r\n+\t\tif (e.getSource().equals(table) && e.detail == SWT.CHECK) {\r\n+\t\t\tTableItem item = (TableItem) e.item;\r\n+\t\t\tCCombo editor = editors.get(tableItems.indexOf(item));\r\n+\t\t\tif (item.getChecked()) {\r\n+\t\t\t\teditor.setEditable(true);\r\n+\t\t\t} else {\r\n+\t\t\t\teditor.setEditable(false);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\t\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see\r\n+\t * org.eclipse.swt.events.SelectionListener#widgetDefaultSelected(org.eclipse.\r\n+\t * swt.events.SelectionEvent)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void widgetDefaultSelected(SelectionEvent e) {\r\n+\t\t\r\n+\t}\r\n+\r\n+\t/* (non-Javadoc)\r\n+\t * @see org.eclipse.swt.events.ModifyListener#modifyText(org.eclipse.swt.events.ModifyEvent)\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMzUwMg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449203502", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tif (item.getChecked()) {\n          \n          \n            \n            \t\t\t\teditor.setEditable(true);\n          \n          \n            \n            \t\t\t} else {\n          \n          \n            \n            \t\t\t\teditor.setEditable(false);\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t\teditor.setEditable(item.getChecked());", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T18:40:33Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvTypeReviewPage.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import org.eclipse.jface.wizard.WizardPage;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.custom.CCombo;\r\n+import org.eclipse.swt.custom.TableEditor;\r\n+import org.eclipse.swt.events.ModifyEvent;\r\n+import org.eclipse.swt.events.ModifyListener;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.events.SelectionListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Table;\r\n+import org.eclipse.swt.widgets.TableColumn;\r\n+import org.eclipse.swt.widgets.TableItem;\r\n+import org.eclipse.swt.widgets.Text;\r\n+\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+\r\n+/**\r\n+ * A wizard page to review the requirement type which is used for imports\r\n+ *\r\n+ */\r\n+public class CsvTypeReviewPage extends WizardPage implements SelectionListener, ModifyListener {\r\n+\r\n+\tprivate static final String COLUMN_NAME_LABEL = \"Column\";\r\n+\tprivate static final String COLUMN_TYPE_LABEL = \"Type\";\r\n+\r\n+\tprivate static final String TYPE_NAME_LABEL = \"Type Name\";\r\n+\tprivate static final int WITH_TEXT = 400;\r\n+\r\n+\tprivate static final int COLUMN_NAME_WIDTH = 300;\r\n+\tprivate static final int COLUMN_TYPE_WIDTH = 200;\r\n+\r\n+\tprivate static final List<String> ATTRIBUTE_TYPES = new ArrayList<String>(\r\n+\t\t\tArrays.asList(RequirementAttribute.TYPE_Boolean_NAME, RequirementAttribute.TYPE_Date_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Enumeration_NAME, RequirementAttribute.TYPE_Identifier_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_Integer_NAME, RequirementAttribute.TYPE_Real_NAME,\r\n+\t\t\t\t\tRequirementAttribute.TYPE_String_NAME));\r\n+\r\n+\tprivate static final int TYPE_COLUMN_INDEX = 1;\r\n+\tprivate static final String TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR = \"::\";\r\n+\r\n+\tprivate Text typeNameText;\r\n+\r\n+\tprivate Table table;\r\n+\tprivate List<TableItem> tableItems = new ArrayList<TableItem>();\r\n+\tprivate List<CCombo> editors = new ArrayList<CCombo>();\r\n+\r\n+\tprivate Map<Integer, RequirementAttribute> mapColumnIndexToAttributeType = new HashMap<>();\r\n+\tprivate RequirementType requirementType;\r\n+\tprivate boolean isNewType;\r\n+\r\n+\t/**\r\n+\t * Constructor\r\n+\t */\r\n+\tprotected CsvTypeReviewPage() {\r\n+\t\tsuper(\"Requirement Type Review\");\r\n+\t\tsetTitle(\"Requirement Type Review\");\r\n+\t\tsetDescription(\"Check the selected import type for the requirements.\");\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see\r\n+\t * org.eclipse.jface.dialogs.IDialogPage#createControl(org.eclipse.swt.widgets.\r\n+\t * Composite)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\r\n+\t\tComposite content = new Composite(parent, SWT.NONE);\r\n+\t\tcontent.setLayout(new GridLayout());\r\n+\t\tcontent.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_HORIZONTAL));\r\n+\t\tsetControl(content);\r\n+\r\n+\t\tComposite typeNameComposite = new Composite(content, SWT.NONE);\r\n+\t\ttypeNameComposite.setLayout(new GridLayout(2, false));\r\n+\t\tGridData data = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\ttypeNameComposite.setLayoutData(data);\r\n+\r\n+\t\tLabel label = new Label(typeNameComposite, SWT.NONE);\r\n+\t\tlabel.setText(TYPE_NAME_LABEL);\r\n+\r\n+\t\ttypeNameText = new Text(typeNameComposite, SWT.SINGLE | SWT.BORDER);\r\n+\t\tGridData dataText = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.GRAB_HORIZONTAL);\r\n+\t\tdata.horizontalAlignment = SWT.END;\r\n+\t\tdata.widthHint = WITH_TEXT;\r\n+\t\ttypeNameText.setLayoutData(dataText);\r\n+\t\ttypeNameText.addSelectionListener(this);\r\n+\t\ttypeNameText.addModifyListener(this);\r\n+\r\n+\t\ttable = new Table(content, SWT.CHECK | SWT.BORDER | SWT.H_SCROLL);\r\n+\t\ttable.setLayout(new GridLayout());\r\n+\t\ttable.setLayoutData(new GridData(GridData.FILL_BOTH | GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL));\r\n+\t\ttable.setHeaderVisible(true);\r\n+\t\ttable.addSelectionListener(this);\r\n+\r\n+\t\tTableColumn columnColumnName = new TableColumn(table, SWT.NULL);\r\n+\t\tcolumnColumnName.setWidth(COLUMN_NAME_WIDTH);\r\n+\t\tcolumnColumnName.setText(COLUMN_NAME_LABEL);\r\n+\r\n+\t\tTableColumn columnType = new TableColumn(table, SWT.NONE | SWT.DROP_DOWN);\r\n+\t\tcolumnType.setText(COLUMN_TYPE_LABEL);\r\n+\t\tcolumnType.setWidth(COLUMN_TYPE_WIDTH);\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Sets the input for the mapping table\r\n+\t * \r\n+\t * @param columnNames\r\n+\t *            a list of columns in the file\r\n+\t * @param requirementType\r\n+\t *            an existing requirement type\r\n+\t */\r\n+\tpublic void setInput(List<String> columnNames, RequirementType requirementType) {\r\n+\t\tthis.requirementType = requirementType;\r\n+\t\tthis.typeNameText.setText(requirementType.getName());\r\n+\t\tisNewType = requirementType.getTypeInstance().eContainer() == null;\r\n+\t\tif (!isNewType) {\r\n+\t\t\ttypeNameText.setEditable(false);\r\n+\t\t} else {\r\n+\t\t\ttypeNameText.setEditable(true);\r\n+\t\t}\r\n+\r\n+\t\ttable.clearAll();\r\n+\r\n+\t\tfor (String column : columnNames) {\r\n+\t\t\tInteger index = columnNames.indexOf(column);\r\n+\t\t\tTableItem item;\r\n+\t\t\tif (tableItems.size() <= index) {\r\n+\t\t\t\titem = new TableItem(table, SWT.NULL);\r\n+\t\t\t\ttableItems.add(item);\r\n+\t\t\t} else {\r\n+\t\t\t\titem = tableItems.get(index);\r\n+\t\t\t}\r\n+\t\t\titem.setText(0, column);\r\n+\r\n+\t\t\tif (isNewType) {\r\n+\t\t\t\titem.setText(TYPE_COLUMN_INDEX, requirementType.getAttributes().get(index).getType());\r\n+\t\t\t\titem.setChecked(true);\r\n+\t\t\t\tcreateDropDownEditor(item, ATTRIBUTE_TYPES);\r\n+\t\t\t} else {\r\n+\t\t\t\tif (index < requirementType.getAttributes().size()) {\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX,\r\n+\t\t\t\t\t\t\trequirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR\r\n+\t\t\t\t\t\t\t\t\t+ requirementType.getAttributes().get(index).getName());\r\n+\t\t\t\t\titem.setChecked(true);\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\titem.setChecked(false);\r\n+\t\t\t\t\titem.setText(TYPE_COLUMN_INDEX, \"\");\r\n+\t\t\t\t}\r\n+\t\t\t\t// If we use an exiting type then just try to map them from the attribute index\r\n+\t\t\t\tcreateDropDownEditor(item, requirementType.getAttributes().stream().map(\r\n+\t\t\t\t\t\tatt -> requirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR + att.getName())\r\n+\t\t\t\t\t\t.collect(Collectors.toList()));\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Method to create a drop down editor for the type column\r\n+\t * \r\n+\t * @param item\r\n+\t *            the item for which the editor should be created\r\n+\t * @param options\r\n+\t *            the input options\r\n+\t */\r\n+\tprivate void createDropDownEditor(TableItem item, List<String> options) {\r\n+\t\tint index = tableItems.indexOf(item);\r\n+\t\tCCombo typeDropdown;\r\n+\t\tif (editors.size() > index) {\r\n+\t\t\ttypeDropdown = editors.get(index);\r\n+\t\t\ttypeDropdown.removeAll();\r\n+\t\t} else {\r\n+\t\t\ttypeDropdown = new CCombo(table, SWT.NONE);\r\n+\t\t\teditors.add(typeDropdown);\r\n+\t\t}\r\n+\t\ttypeDropdown.setText(item.getText(TYPE_COLUMN_INDEX));\r\n+\t\tfor (String option : options) {\r\n+\t\t\ttypeDropdown.add(option);\r\n+\t\t}\r\n+\t\tfinal TableEditor editor = new TableEditor(table);\r\n+\t\teditor.grabHorizontal = true;\r\n+\t\teditor.setEditor(typeDropdown, item, TYPE_COLUMN_INDEX);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Get the mapping of columns to their attribute in specified requirement type\r\n+\t * \r\n+\t * @return a map of the column index to their attribute definition type\r\n+\t */\r\n+\tpublic Map<Integer, RequirementAttribute> getAttributeMapping() {\r\n+\r\n+\t\tfor (TableItem item : tableItems) {\r\n+\t\t\tInteger index = tableItems.indexOf(item);\r\n+\r\n+\t\t\tif (item.getChecked()) {\r\n+\t\t\t\tif (isNewType) {\r\n+\t\t\t\t\tString selectedType = editors.get(index).getText();\r\n+\r\n+\t\t\t\t\tRequirementAttribute correspondingAtt = requirementType.getAttributes().get(index);\r\n+\r\n+\t\t\t\t\t// Check if type is new and valid and then add it to the new requirement type\r\n+\t\t\t\t\tif (ATTRIBUTE_TYPES.contains(selectedType) && !selectedType.equals(correspondingAtt.getType())) {\r\n+\t\t\t\t\t\tcorrespondingAtt.setType(selectedType);\r\n+\t\t\t\t\t}\r\n+\r\n+\t\t\t\t\t// Add corresponding attribute to mapping\r\n+\t\t\t\t\tmapColumnIndexToAttributeType.put(index, correspondingAtt);\r\n+\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\tString inputString = editors.get(index).getText();\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tRequirementAttribute selectedAttribute = getSelectedAttribute(inputString);\r\n+\t\t\t\t\tif (selectedAttribute != null) {\r\n+\t\t\t\t\t\tmapColumnIndexToAttributeType.put(index, selectedAttribute);\r\n+\t\t\t\t\t}\r\n+\r\n+\t\t\t\t}\r\n+\t\t\t} \r\n+\r\n+\t\t}\r\n+\r\n+\t\treturn mapColumnIndexToAttributeType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Get the configured requirement type for the import\r\n+\t * \r\n+\t * @return the requirement type\r\n+\t */\r\n+\tpublic RequirementType getRequirementType() {\r\n+\t\tif (isNewType) {\r\n+\t\t\tfor (RequirementAttribute att : requirementType.getAttributes()) {\r\n+\t\t\t\tif (!mapColumnIndexToAttributeType.containsValue(att)) {\r\n+\t\t\t\t\trequirementType.getAttributes().remove(att);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\treturn requirementType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Parse the attribute from the editor input string\r\n+\t * \r\n+\t * @param inputString\r\n+\t *            the editor input string\r\n+\t * @return the attibute\r\n+\t */\r\n+\tprivate RequirementAttribute getSelectedAttribute(String inputString) {\r\n+\r\n+\t\t// Remove context indication from attribute\r\n+\t\tinputString = inputString.replace(requirementType.getName() + TYPE_LABEL_REQUIREMENT_ATTRIBUTE_SEPARATOR, \"\");\r\n+\r\n+\t\tfor (RequirementAttribute att : requirementType.getAttributes()) {\r\n+\r\n+\t\t\tif (att.getName().equals(inputString)) {\r\n+\t\t\t\treturn att;\r\n+\t\t\t}\r\n+\r\n+\t\t}\r\n+\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\t/*\r\n+\t * (non-Javadoc)\r\n+\t * \r\n+\t * @see org.eclipse.swt.events.SelectionListener#widgetSelected(org.eclipse.swt.\r\n+\t * events.SelectionEvent)\r\n+\t */\r\n+\t@Override\r\n+\tpublic void widgetSelected(SelectionEvent e) {\r\n+\t\tif (e.getSource().equals(table) && e.detail == SWT.CHECK) {\r\n+\t\t\tTableItem item = (TableItem) e.item;\r\n+\t\t\tCCombo editor = editors.get(tableItems.indexOf(item));\r\n+\t\t\tif (item.getChecked()) {\r\n+\t\t\t\teditor.setEditable(true);\r\n+\t\t\t} else {\r\n+\t\t\t\teditor.setEditable(false);\r\n+\t\t\t}\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIxMTAwNA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449211004", "bodyText": "Can be simplified by extracting ((CategoryAssignment) selection).getType().getFullQualifiedName() into a variable", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T18:56:52Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvImportTargetSelectionPage.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.AssemblyTree;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.ConfigurationTree;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.ElementConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.ElementOccurence;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementGroup;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsSpecification;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.ATreeViewerPage;\r\n+\r\n+/**\r\n+ * A page to select a requirement type for imported requirements\r\n+ *\r\n+ */\r\n+public class CsvImportTargetSelectionPage extends ATreeViewerPage {\r\n+\r\n+\t/**\r\n+\t * Default constructor\r\n+\t * @param model the model\r\n+\t */\r\n+\tprotected CsvImportTargetSelectionPage(IContainer model) {\r\n+\t\tsuper(\"Import Target Selection\");\r\n+\t\tsetTitle(\"Import Target Selection\");\r\n+\t\tsetModel(model);\r\n+\t\tsetDescription(\r\n+\t\t\t\t\"Please select a requirement specification element in which the requirements should be imported to.\");\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\t\tsuper.createControl(parent);\r\n+\t\tcreateTreeViewer();\r\n+\t}\r\n+\t\r\n+\t\r\n+\t/**\r\n+\t * Create a tree viewer with filters to show only relevant tree target elements \r\n+\t */\r\n+\tprotected void createTreeViewer() {\r\n+\t\tTreeViewer treeViewer = createTreeUI();\r\n+\t\tVirSatFilteredWrappedTreeContentProvider filteredCp = (VirSatFilteredWrappedTreeContentProvider) treeViewer\r\n+\t\t\t\t.getContentProvider();\r\n+\t\tfilteredCp.addClassFilter(CategoryAssignment.class);\r\n+\t\tfilteredCp.addClassFilter(ArrayInstance.class);\r\n+\t\tfilteredCp.addClassFilter(ComposedPropertyInstance.class);\r\n+\r\n+\t\tfilteredCp.addStructuralElementIdFilter(ConfigurationTree.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(ElementConfiguration.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(AssemblyTree.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(ElementOccurence.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\t\tfilteredCp.addCategoryIdFilter(RequirementsSpecification.FULL_QUALIFIED_CATEGORY_NAME);\r\n+\t}\r\n+\t\r\n+\t\r\n+\t@Override\r\n+\tpublic boolean isSelectionValid() {\r\n+\t\tObject selection = getSelection();\r\n+\t\tif (selection instanceof CategoryAssignment) {\r\n+\t\t\treturn ((CategoryAssignment) selection).getType().getFullQualifiedName()\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIxMjU4MQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449212581", "bodyText": "Hmm, can it be selected? I only see a filter for RequirementsSpecification", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T19:00:07Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvImportTargetSelectionPage.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.jface.viewers.TreeViewer;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ArrayInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.AssemblyTree;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.ConfigurationTree;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.ElementConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.ps.model.ElementOccurence;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementGroup;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsSpecification;\r\n+import de.dlr.sc.virsat.project.ui.contentProvider.VirSatFilteredWrappedTreeContentProvider;\r\n+import de.dlr.sc.virsat.uiengine.ui.wizard.ATreeViewerPage;\r\n+\r\n+/**\r\n+ * A page to select a requirement type for imported requirements\r\n+ *\r\n+ */\r\n+public class CsvImportTargetSelectionPage extends ATreeViewerPage {\r\n+\r\n+\t/**\r\n+\t * Default constructor\r\n+\t * @param model the model\r\n+\t */\r\n+\tprotected CsvImportTargetSelectionPage(IContainer model) {\r\n+\t\tsuper(\"Import Target Selection\");\r\n+\t\tsetTitle(\"Import Target Selection\");\r\n+\t\tsetModel(model);\r\n+\t\tsetDescription(\r\n+\t\t\t\t\"Please select a requirement specification element in which the requirements should be imported to.\");\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void createControl(Composite parent) {\r\n+\t\tsuper.createControl(parent);\r\n+\t\tcreateTreeViewer();\r\n+\t}\r\n+\t\r\n+\t\r\n+\t/**\r\n+\t * Create a tree viewer with filters to show only relevant tree target elements \r\n+\t */\r\n+\tprotected void createTreeViewer() {\r\n+\t\tTreeViewer treeViewer = createTreeUI();\r\n+\t\tVirSatFilteredWrappedTreeContentProvider filteredCp = (VirSatFilteredWrappedTreeContentProvider) treeViewer\r\n+\t\t\t\t.getContentProvider();\r\n+\t\tfilteredCp.addClassFilter(CategoryAssignment.class);\r\n+\t\tfilteredCp.addClassFilter(ArrayInstance.class);\r\n+\t\tfilteredCp.addClassFilter(ComposedPropertyInstance.class);\r\n+\r\n+\t\tfilteredCp.addStructuralElementIdFilter(ConfigurationTree.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(ElementConfiguration.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(AssemblyTree.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\t\tfilteredCp.addStructuralElementIdFilter(ElementOccurence.FULL_QUALIFIED_STRUCTURAL_ELEMENT_NAME);\r\n+\t\tfilteredCp.addCategoryIdFilter(RequirementsSpecification.FULL_QUALIFIED_CATEGORY_NAME);\r\n+\t}\r\n+\t\r\n+\t\r\n+\t@Override\r\n+\tpublic boolean isSelectionValid() {\r\n+\t\tObject selection = getSelection();\r\n+\t\tif (selection instanceof CategoryAssignment) {\r\n+\t\t\treturn ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t.equals(RequirementsSpecification.FULL_QUALIFIED_CATEGORY_NAME)\r\n+\t\t\t\t\t|| ((CategoryAssignment) selection).getType().getFullQualifiedName()\r\n+\t\t\t\t\t\t\t.equals(RequirementGroup.FULL_QUALIFIED_CATEGORY_NAME);\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIxODI2OA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449218268", "bodyText": "I suggest we don't pass this, but use getWizard() in the importPage", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T19:12:23Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvImportWizard.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.resources.IResource;\r\n+import org.eclipse.core.resources.ResourcesPlugin;\r\n+import org.eclipse.core.runtime.CoreException;\r\n+import org.eclipse.core.runtime.IProgressMonitor;\r\n+import org.eclipse.core.runtime.IStatus;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.core.runtime.SubMonitor;\r\n+import org.eclipse.core.runtime.jobs.Job;\r\n+import org.eclipse.emf.common.command.Command;\r\n+import org.eclipse.jface.dialogs.DialogSettings;\r\n+import org.eclipse.jface.dialogs.IDialogSettings;\r\n+import org.eclipse.jface.viewers.IStructuredSelection;\r\n+import org.eclipse.jface.wizard.Wizard;\r\n+import org.eclipse.ui.IWorkbench;\r\n+import org.eclipse.ui.IWorkbenchWizard;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.concept.list.IBeanList;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.extension.requirements.csv.CsvFileReader;\r\n+import de.dlr.sc.virsat.model.extension.requirements.csv.CsvRequirementsImporter;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementGroup;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementObject;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsSpecification;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.editingDomain.VirSatEditingDomainRegistry;\r\n+import de.dlr.sc.virsat.project.editingDomain.VirSatTransactionalEditingDomain;\r\n+\r\n+/**\r\n+ * A wizard for the import of requirements from a CSV file\r\n+ *\r\n+ */\r\n+public class CsvImportWizard extends Wizard implements IWorkbenchWizard {\r\n+\r\n+\tpublic static final String ID = \"de.dlr.sc.virsat.model.extension.requirements.ui.wizard.csvImport\";\r\n+\tprivate static final int NUMBER_PROGRESS_TICKS = 3;\r\n+\r\n+\tprivate CsvFileReqTypeSelectionPage importPage;\r\n+\tprivate CsvTypeReviewPage reviewTypePage;\r\n+\tprivate CsvImportTargetSelectionPage targetSelectionPage;\r\n+\tprivate IContainer model;\r\n+\r\n+\tprivate CsvFileReader reader;\r\n+\tprivate CsvRequirementsImporter importer;\r\n+\r\n+\t/**\r\n+\t * Default constructor\r\n+\t */\r\n+\tpublic CsvImportWizard() {\r\n+\t\tsuper();\r\n+\r\n+\t\t// Setup persistency\r\n+\t\tIDialogSettings pluginSettings = Activator.getDefault().getDialogSettings();\r\n+\t\tIDialogSettings wizardSettings = pluginSettings.getSection(ID);\r\n+\t\tif (wizardSettings == null) {\r\n+\t\t\twizardSettings = new DialogSettings(ID);\r\n+\t\t\tpluginSettings.addSection(wizardSettings);\r\n+\t\t}\r\n+\t\tsetDialogSettings(wizardSettings);\r\n+\t\treader = new CsvFileReader();\r\n+\t\timporter = new CsvRequirementsImporter();\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void init(IWorkbench workbench, IStructuredSelection selection) {\r\n+\t\tthis.model = ResourcesPlugin.getWorkspace().getRoot();\r\n+\t\tsetNeedsProgressMonitor(true);\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic boolean performFinish() {\r\n+\r\n+\t\t// Get target list of requirements\r\n+\t\tfinal IBeanList<RequirementObject> targetedReqList;\r\n+\t\tfinal CategoryAssignment selectedSpec = (CategoryAssignment) targetSelectionPage.getSelection();\r\n+\t\tif (selectedSpec.getType().getFullQualifiedName()\r\n+\t\t\t\t.equals(RequirementsSpecification.FULL_QUALIFIED_CATEGORY_NAME)) {\r\n+\t\t\ttargetedReqList = new RequirementsSpecification(selectedSpec).getRequirements();\r\n+\t\t} else if (selectedSpec.getType().getFullQualifiedName()\r\n+\t\t\t\t.equals(RequirementGroup.FULL_QUALIFIED_CATEGORY_NAME)) {\r\n+\t\t\ttargetedReqList = new RequirementGroup(selectedSpec).getChildren();\r\n+\t\t} else {\r\n+\t\t\ttargetedReqList = null;\r\n+\t\t}\r\n+\t\tfinal CategoryAssignment reqConfiguration = (CategoryAssignment) importPage.getSelection();\r\n+\t\tfinal String selectedFilePath = importPage.getDestination();\r\n+\t\treader.setDataStartLine(importPage.getFristDataLineNumber());\r\n+\t\treader.setDataEndLine(importPage.getLastDataLineNumber());\r\n+\t\tMap<Integer, RequirementAttribute> attributeMapping = reviewTypePage.getAttributeMapping();\r\n+\r\n+\t\t// Do the import\r\n+\t\tJob importJob = new Job(\"Performing Requirements CSV Import\") {\r\n+\t\t\t@Override\r\n+\t\t\tprotected IStatus run(IProgressMonitor monitor) {\r\n+\t\t\t\tSubMonitor importSubMonitor = SubMonitor.convert(monitor, NUMBER_PROGRESS_TICKS);\r\n+\t\t\t\ttry {\r\n+\t\t\t\t\tList<List<String>> csvContentMatrix = reader.readCsvData(selectedFilePath);\r\n+\t\t\t\t\timportSubMonitor.worked(1);\r\n+\r\n+\t\t\t\t\tCommand importCommand;\r\n+\t\t\t\t\tVirSatTransactionalEditingDomain editingDomain = VirSatEditingDomainRegistry.INSTANCE\r\n+\t\t\t\t\t\t\t.getEd(selectedSpec);\r\n+\t\t\t\t\tif (reqConfiguration.getType().getFullQualifiedName()\r\n+\t\t\t\t\t\t\t.equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME)) {\r\n+\t\t\t\t\t\timportCommand = importer.loadRequirements(editingDomain, csvContentMatrix, targetedReqList,\r\n+\t\t\t\t\t\t\t\tattributeMapping, new RequirementType(reqConfiguration));\r\n+\t\t\t\t\t} else {\r\n+\t\t\t\t\t\timportCommand = importer.loadRequirements(editingDomain, csvContentMatrix, targetedReqList,\r\n+\t\t\t\t\t\t\t\tattributeMapping, new RequirementsConfiguration(reqConfiguration),\r\n+\t\t\t\t\t\t\t\treviewTypePage.getRequirementType());\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\teditingDomain.getVirSatCommandStack().execute(importCommand);\r\n+\t\t\t\t\timportSubMonitor.worked(1);\r\n+\r\n+\t\t\t\t\tResourcesPlugin.getWorkspace().getRoot().refreshLocal(IResource.DEPTH_INFINITE, null);\r\n+\t\t\t\t\timportSubMonitor.worked(1);\r\n+\r\n+\t\t\t\t\treturn Status.OK_STATUS;\r\n+\t\t\t\t} catch (IOException | CoreException e) {\r\n+\t\t\t\t\tStatus status = new Status(Status.ERROR, Activator.getPluginId(),\r\n+\t\t\t\t\t\t\t\"CatiaImportWizard: Failed to perform import!\", e);\r\n+\t\t\t\t\tStatusManager.getManager().handle(status, StatusManager.LOG | StatusManager.SHOW);\r\n+\t\t\t\t\treturn Status.CANCEL_STATUS;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t};\r\n+\t\timportJob.schedule();\r\n+\r\n+\t\treturn true;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void addPages() {\r\n+\t\treviewTypePage = new CsvTypeReviewPage();\r\n+\t\timportPage = new CsvFileReqTypeSelectionPage(model, this, reviewTypePage);\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIxODU3Mw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449218573", "bodyText": "I suggest we remove these javadocs for getters and setters, they don't add any value", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T19:13:06Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvImportWizard.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.resources.IResource;\r\n+import org.eclipse.core.resources.ResourcesPlugin;\r\n+import org.eclipse.core.runtime.CoreException;\r\n+import org.eclipse.core.runtime.IProgressMonitor;\r\n+import org.eclipse.core.runtime.IStatus;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.core.runtime.SubMonitor;\r\n+import org.eclipse.core.runtime.jobs.Job;\r\n+import org.eclipse.emf.common.command.Command;\r\n+import org.eclipse.jface.dialogs.DialogSettings;\r\n+import org.eclipse.jface.dialogs.IDialogSettings;\r\n+import org.eclipse.jface.viewers.IStructuredSelection;\r\n+import org.eclipse.jface.wizard.Wizard;\r\n+import org.eclipse.ui.IWorkbench;\r\n+import org.eclipse.ui.IWorkbenchWizard;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.concept.list.IBeanList;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.extension.requirements.csv.CsvFileReader;\r\n+import de.dlr.sc.virsat.model.extension.requirements.csv.CsvRequirementsImporter;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementGroup;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementObject;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsSpecification;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.editingDomain.VirSatEditingDomainRegistry;\r\n+import de.dlr.sc.virsat.project.editingDomain.VirSatTransactionalEditingDomain;\r\n+\r\n+/**\r\n+ * A wizard for the import of requirements from a CSV file\r\n+ *\r\n+ */\r\n+public class CsvImportWizard extends Wizard implements IWorkbenchWizard {\r\n+\r\n+\tpublic static final String ID = \"de.dlr.sc.virsat.model.extension.requirements.ui.wizard.csvImport\";\r\n+\tprivate static final int NUMBER_PROGRESS_TICKS = 3;\r\n+\r\n+\tprivate CsvFileReqTypeSelectionPage importPage;\r\n+\tprivate CsvTypeReviewPage reviewTypePage;\r\n+\tprivate CsvImportTargetSelectionPage targetSelectionPage;\r\n+\tprivate IContainer model;\r\n+\r\n+\tprivate CsvFileReader reader;\r\n+\tprivate CsvRequirementsImporter importer;\r\n+\r\n+\t/**\r\n+\t * Default constructor\r\n+\t */\r\n+\tpublic CsvImportWizard() {\r\n+\t\tsuper();\r\n+\r\n+\t\t// Setup persistency\r\n+\t\tIDialogSettings pluginSettings = Activator.getDefault().getDialogSettings();\r\n+\t\tIDialogSettings wizardSettings = pluginSettings.getSection(ID);\r\n+\t\tif (wizardSettings == null) {\r\n+\t\t\twizardSettings = new DialogSettings(ID);\r\n+\t\t\tpluginSettings.addSection(wizardSettings);\r\n+\t\t}\r\n+\t\tsetDialogSettings(wizardSettings);\r\n+\t\treader = new CsvFileReader();\r\n+\t\timporter = new CsvRequirementsImporter();\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void init(IWorkbench workbench, IStructuredSelection selection) {\r\n+\t\tthis.model = ResourcesPlugin.getWorkspace().getRoot();\r\n+\t\tsetNeedsProgressMonitor(true);\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic boolean performFinish() {\r\n+\r\n+\t\t// Get target list of requirements\r\n+\t\tfinal IBeanList<RequirementObject> targetedReqList;\r\n+\t\tfinal CategoryAssignment selectedSpec = (CategoryAssignment) targetSelectionPage.getSelection();\r\n+\t\tif (selectedSpec.getType().getFullQualifiedName()\r\n+\t\t\t\t.equals(RequirementsSpecification.FULL_QUALIFIED_CATEGORY_NAME)) {\r\n+\t\t\ttargetedReqList = new RequirementsSpecification(selectedSpec).getRequirements();\r\n+\t\t} else if (selectedSpec.getType().getFullQualifiedName()\r\n+\t\t\t\t.equals(RequirementGroup.FULL_QUALIFIED_CATEGORY_NAME)) {\r\n+\t\t\ttargetedReqList = new RequirementGroup(selectedSpec).getChildren();\r\n+\t\t} else {\r\n+\t\t\ttargetedReqList = null;\r\n+\t\t}\r\n+\t\tfinal CategoryAssignment reqConfiguration = (CategoryAssignment) importPage.getSelection();\r\n+\t\tfinal String selectedFilePath = importPage.getDestination();\r\n+\t\treader.setDataStartLine(importPage.getFristDataLineNumber());\r\n+\t\treader.setDataEndLine(importPage.getLastDataLineNumber());\r\n+\t\tMap<Integer, RequirementAttribute> attributeMapping = reviewTypePage.getAttributeMapping();\r\n+\r\n+\t\t// Do the import\r\n+\t\tJob importJob = new Job(\"Performing Requirements CSV Import\") {\r\n+\t\t\t@Override\r\n+\t\t\tprotected IStatus run(IProgressMonitor monitor) {\r\n+\t\t\t\tSubMonitor importSubMonitor = SubMonitor.convert(monitor, NUMBER_PROGRESS_TICKS);\r\n+\t\t\t\ttry {\r\n+\t\t\t\t\tList<List<String>> csvContentMatrix = reader.readCsvData(selectedFilePath);\r\n+\t\t\t\t\timportSubMonitor.worked(1);\r\n+\r\n+\t\t\t\t\tCommand importCommand;\r\n+\t\t\t\t\tVirSatTransactionalEditingDomain editingDomain = VirSatEditingDomainRegistry.INSTANCE\r\n+\t\t\t\t\t\t\t.getEd(selectedSpec);\r\n+\t\t\t\t\tif (reqConfiguration.getType().getFullQualifiedName()\r\n+\t\t\t\t\t\t\t.equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME)) {\r\n+\t\t\t\t\t\timportCommand = importer.loadRequirements(editingDomain, csvContentMatrix, targetedReqList,\r\n+\t\t\t\t\t\t\t\tattributeMapping, new RequirementType(reqConfiguration));\r\n+\t\t\t\t\t} else {\r\n+\t\t\t\t\t\timportCommand = importer.loadRequirements(editingDomain, csvContentMatrix, targetedReqList,\r\n+\t\t\t\t\t\t\t\tattributeMapping, new RequirementsConfiguration(reqConfiguration),\r\n+\t\t\t\t\t\t\t\treviewTypePage.getRequirementType());\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\teditingDomain.getVirSatCommandStack().execute(importCommand);\r\n+\t\t\t\t\timportSubMonitor.worked(1);\r\n+\r\n+\t\t\t\t\tResourcesPlugin.getWorkspace().getRoot().refreshLocal(IResource.DEPTH_INFINITE, null);\r\n+\t\t\t\t\timportSubMonitor.worked(1);\r\n+\r\n+\t\t\t\t\treturn Status.OK_STATUS;\r\n+\t\t\t\t} catch (IOException | CoreException e) {\r\n+\t\t\t\t\tStatus status = new Status(Status.ERROR, Activator.getPluginId(),\r\n+\t\t\t\t\t\t\t\"CatiaImportWizard: Failed to perform import!\", e);\r\n+\t\t\t\t\tStatusManager.getManager().handle(status, StatusManager.LOG | StatusManager.SHOW);\r\n+\t\t\t\t\treturn Status.CANCEL_STATUS;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t};\r\n+\t\timportJob.schedule();\r\n+\r\n+\t\treturn true;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void addPages() {\r\n+\t\treviewTypePage = new CsvTypeReviewPage();\r\n+\t\timportPage = new CsvFileReqTypeSelectionPage(model, this, reviewTypePage);\r\n+\t\taddPage(importPage);\r\n+\t\taddPage(reviewTypePage);\r\n+\t\ttargetSelectionPage = new CsvImportTargetSelectionPage(model);\r\n+\t\taddPage(targetSelectionPage);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * @return the reader\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyMDExNA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449220114", "bodyText": "Why is everything final?", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T19:16:26Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvImportWizard.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.wizard;\r\n+\r\n+import java.io.IOException;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+import org.eclipse.core.resources.IContainer;\r\n+import org.eclipse.core.resources.IResource;\r\n+import org.eclipse.core.resources.ResourcesPlugin;\r\n+import org.eclipse.core.runtime.CoreException;\r\n+import org.eclipse.core.runtime.IProgressMonitor;\r\n+import org.eclipse.core.runtime.IStatus;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.core.runtime.SubMonitor;\r\n+import org.eclipse.core.runtime.jobs.Job;\r\n+import org.eclipse.emf.common.command.Command;\r\n+import org.eclipse.jface.dialogs.DialogSettings;\r\n+import org.eclipse.jface.dialogs.IDialogSettings;\r\n+import org.eclipse.jface.viewers.IStructuredSelection;\r\n+import org.eclipse.jface.wizard.Wizard;\r\n+import org.eclipse.ui.IWorkbench;\r\n+import org.eclipse.ui.IWorkbenchWizard;\r\n+import org.eclipse.ui.statushandlers.StatusManager;\r\n+\r\n+import de.dlr.sc.virsat.model.concept.list.IBeanList;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.extension.requirements.csv.CsvFileReader;\r\n+import de.dlr.sc.virsat.model.extension.requirements.csv.CsvRequirementsImporter;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementGroup;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementObject;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsSpecification;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.Activator;\r\n+import de.dlr.sc.virsat.project.editingDomain.VirSatEditingDomainRegistry;\r\n+import de.dlr.sc.virsat.project.editingDomain.VirSatTransactionalEditingDomain;\r\n+\r\n+/**\r\n+ * A wizard for the import of requirements from a CSV file\r\n+ *\r\n+ */\r\n+public class CsvImportWizard extends Wizard implements IWorkbenchWizard {\r\n+\r\n+\tpublic static final String ID = \"de.dlr.sc.virsat.model.extension.requirements.ui.wizard.csvImport\";\r\n+\tprivate static final int NUMBER_PROGRESS_TICKS = 3;\r\n+\r\n+\tprivate CsvFileReqTypeSelectionPage importPage;\r\n+\tprivate CsvTypeReviewPage reviewTypePage;\r\n+\tprivate CsvImportTargetSelectionPage targetSelectionPage;\r\n+\tprivate IContainer model;\r\n+\r\n+\tprivate CsvFileReader reader;\r\n+\tprivate CsvRequirementsImporter importer;\r\n+\r\n+\t/**\r\n+\t * Default constructor\r\n+\t */\r\n+\tpublic CsvImportWizard() {\r\n+\t\tsuper();\r\n+\r\n+\t\t// Setup persistency\r\n+\t\tIDialogSettings pluginSettings = Activator.getDefault().getDialogSettings();\r\n+\t\tIDialogSettings wizardSettings = pluginSettings.getSection(ID);\r\n+\t\tif (wizardSettings == null) {\r\n+\t\t\twizardSettings = new DialogSettings(ID);\r\n+\t\t\tpluginSettings.addSection(wizardSettings);\r\n+\t\t}\r\n+\t\tsetDialogSettings(wizardSettings);\r\n+\t\treader = new CsvFileReader();\r\n+\t\timporter = new CsvRequirementsImporter();\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void init(IWorkbench workbench, IStructuredSelection selection) {\r\n+\t\tthis.model = ResourcesPlugin.getWorkspace().getRoot();\r\n+\t\tsetNeedsProgressMonitor(true);\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic boolean performFinish() {\r\n+\r\n+\t\t// Get target list of requirements\r\n+\t\tfinal IBeanList<RequirementObject> targetedReqList;\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMyMjA5Ng==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449322096", "bodyText": "Because otherwise it cannot be used in the Job-subcluss", "author": "franzTobiasDLR", "createdAt": "2020-07-03T00:31:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyMDExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyNjY0OQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449226649", "bodyText": "Let's rename it to something like fillEnumAttributes", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T19:31:29Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvRequirementsImporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Map.Entry;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.emf.common.command.CompoundCommand;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.model.concept.list.IBeanList;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.Activator;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.AttributeValue;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.EnumerationLiteral;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementObject;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+\r\n+/**\r\n+ * A class that imports requirements from a CSV file\r\n+ *\r\n+ */\r\n+public class CsvRequirementsImporter {\r\n+\r\n+\tprotected EditingDomain editingDomain;\r\n+\tprotected Concept reqConcept;\r\n+\r\n+\tprivate static final String REQ_TYPE_NAME = \"CCVImportedRequirementType\";\r\n+\tprivate static final String REQ_EXTENSION_IDENTIFIER_PREFIX = \"-extension\";\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param importType\r\n+\t *            the requirement type of the imported requirements\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementType importType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tif (reqConcept == null) {\r\n+\t\t\tthis.reqConcept = getReqConcept(importType.getTypeInstance());\r\n+\t\t}\r\n+\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\r\n+\t\t// Read the actual requirements\r\n+\t\tfor (List<String> req : csvContentMatrix) {\r\n+\t\t\tint lineNumber = csvContentMatrix.indexOf(req);\r\n+\t\t\tRequirement newReqElement = createRequirement(importType, lineNumber);\r\n+\r\n+\t\t\t//If the first columns of a requirement are empty then values from previous lines are used\r\n+\t\t\tString attribute = req.iterator().next();\r\n+\t\t\twhile (attribute.equals(\"\")) {\r\n+\t\t\t\tint currentAttributeIndex = req.indexOf(attribute);\r\n+\t\t\t\tString repeatedValue = csvContentMatrix.get(lineNumber - 1).get(currentAttributeIndex);\r\n+\t\t\t\tif (attributeMapping.get(currentAttributeIndex) != null && attributeMapping.get(currentAttributeIndex).getType().equals(RequirementAttribute.TYPE_Identifier_NAME)) {\r\n+\t\t\t\t\trepeatedValue += REQ_EXTENSION_IDENTIFIER_PREFIX;\r\n+\t\t\t\t}\r\n+\t\t\t\treq.set(currentAttributeIndex, repeatedValue);\r\n+\t\t\t\tattribute = req.get(currentAttributeIndex + 1);\r\n+\t\t\t}\r\n+\t\r\n+\t\t\t//Needed because req.indexOf(attValue) does not work if columns have the same value\r\n+\t\t\tint currentIndex = 0;\r\n+\t\t\tfor (String attValue : req) {\r\n+\t\t\t\tRequirementAttribute mappedAttribute = attributeMapping.get(currentIndex);\r\n+\r\n+\t\t\t\tif (mappedAttribute != null) {\r\n+\t\t\t\t\tsetAttributeValue(newReqElement, attValue, mappedAttribute);\r\n+\t\t\t\t}\r\n+\t\t\t\tcurrentIndex++;\r\n+\t\t\t}\r\n+\t\t\tnewReqElement.updateNameFromAttributes();\r\n+\t\t\timportCommand.append(targetSpecificationList.add(editingDomain, newReqElement));\r\n+\t\t}\r\n+\r\n+\t\treturn importCommand;\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param newImportTypeContainer\r\n+\t *            the requirement configuration in which the new type element should\r\n+\t *            be added into\r\n+\t * @param nonPersistedType\r\n+\t *            A new requirement type that is not yet persisted\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementsConfiguration newImportTypeContainer, RequirementType nonPersistedType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tthis.reqConcept = getReqConcept(newImportTypeContainer.getTypeInstance());\r\n+\r\n+\t\t// Create a requirement type for the import\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\t\tcustomizeReqTypeFromData(nonPersistedType, csvContentMatrix, attributeMapping);\r\n+\t\tRequirementType reqType = createReqType(importCommand, newImportTypeContainer, nonPersistedType);\r\n+\r\n+\t\timportCommand.append(\r\n+\t\t\t\tloadRequirements(editingDomain, csvContentMatrix, targetSpecificationList, attributeMapping, reqType));\r\n+\r\n+\t\treturn importCommand;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Creates a requirement type from a list of attribute names. Does not create a\r\n+\t * command or persist the element yet\r\n+\t * \r\n+\t * @param reqConcept\r\n+\t *            the active concept\r\n+\t * @param attributeNames\r\n+\t *            a list of attribute names\r\n+\t * @return the new type\r\n+\t */\r\n+\tpublic RequirementType prepareRequirementType(Concept reqConcept, List<String> attributeNames) {\r\n+\t\tthis.reqConcept = reqConcept;\r\n+\t\tRequirementType newReqType = new RequirementType(reqConcept);\r\n+\t\tnewReqType.setName(REQ_TYPE_NAME);\r\n+\t\tfor (String attName : attributeNames) {\r\n+\t\t\tRequirementAttribute attDef = new RequirementAttribute(reqConcept);\r\n+\t\t\tattDef.setName(attName.replace(\" \", \"\"));\r\n+\t\t\tattDef.setType(RequirementAttribute.TYPE_String_NAME);\r\n+\t\t\tnewReqType.getAttributes().add(attDef);\r\n+\t\t}\r\n+\t\treturn newReqType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a requirement and set its type\r\n+\t * \r\n+\t *            the containing list of requirements\r\n+\t * @param reqType\r\n+\t *            the requirement type\r\n+\t * @param lineNumber \r\n+\t * \t\t\t  the line index of the requirement\r\n+\t * @return the new requirement\r\n+\t */\r\n+\tprotected Requirement createRequirement(RequirementType reqType, int lineNumber) {\r\n+\t\tRequirement requirement = new Requirement(reqConcept);\r\n+\t\trequirement.setReqType(reqType);\r\n+\t\trequirement.setName(reqType.getName() + lineNumber);\r\n+\t\tfor (RequirementAttribute att : reqType.getAttributes()) {\r\n+\t\t\tAttributeValue attValue = new AttributeValue(reqConcept);\r\n+\t\t\tattValue.setName(att.getName());\r\n+\t\t\tattValue.setAttType(att);\r\n+\t\t\trequirement.getElements().add(attValue);\r\n+\t\t}\r\n+\t\treturn requirement;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a attribute value within a requirement\r\n+\t * \r\n+\t * @param requirement\r\n+\t *            the requirement to edit\r\n+\t * @param value\r\n+\t *            the value to be added to the attribute\r\n+\t * @param attDef the attribute definition\r\n+\t */\r\n+\tprotected void setAttributeValue(Requirement requirement, String value,\r\n+\t\t\tRequirementAttribute attDef) {\r\n+\t\tfor (AttributeValue att : requirement.getElements()) {\r\n+\t\t\tRequirementAttribute type = att.getAttType();\r\n+\t\t\tif (type.equals(attDef)) {\r\n+\t\t\t\tatt.setValue(value);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * create a requirement type with a given number of attributes\r\n+\t * \r\n+\t * @param importCommand\r\n+\t *            the import command which should contain this creation operation\r\n+\t * @param container\r\n+\t *            the container element in which the new type should be added into\r\n+\t * @param newReqType\r\n+\t *            a new not yet persited requirement type\r\n+\t * @return the new requirement type\r\n+\t */\r\n+\tprotected RequirementType createReqType(CompoundCommand importCommand, RequirementsConfiguration container,\r\n+\t\t\tRequirementType newReqType) {\r\n+\r\n+\t\timportCommand.append(container.getTypeDefinitions().add(editingDomain, newReqType));\r\n+\t\treturn newReqType;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Update a new requirement type from a set of CSV data\r\n+\t * @param type the not yet persisted requirement type\r\n+\t * @param csvContentMatrix the CSV data\r\n+\t * @param attributeMapping the mapping of column index to attribute\r\n+\t */\r\n+\tprotected void customizeReqTypeFromData(RequirementType type, List<List<String>> csvContentMatrix, Map<Integer, RequirementAttribute> attributeMapping) {\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyNjkzMg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449226932", "bodyText": "I think it can't be null because whatever is not in the map would have been removed", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T19:32:15Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvRequirementsImporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Map.Entry;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.emf.common.command.CompoundCommand;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.model.concept.list.IBeanList;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.Activator;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.AttributeValue;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.EnumerationLiteral;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementObject;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+\r\n+/**\r\n+ * A class that imports requirements from a CSV file\r\n+ *\r\n+ */\r\n+public class CsvRequirementsImporter {\r\n+\r\n+\tprotected EditingDomain editingDomain;\r\n+\tprotected Concept reqConcept;\r\n+\r\n+\tprivate static final String REQ_TYPE_NAME = \"CCVImportedRequirementType\";\r\n+\tprivate static final String REQ_EXTENSION_IDENTIFIER_PREFIX = \"-extension\";\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param importType\r\n+\t *            the requirement type of the imported requirements\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementType importType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tif (reqConcept == null) {\r\n+\t\t\tthis.reqConcept = getReqConcept(importType.getTypeInstance());\r\n+\t\t}\r\n+\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\r\n+\t\t// Read the actual requirements\r\n+\t\tfor (List<String> req : csvContentMatrix) {\r\n+\t\t\tint lineNumber = csvContentMatrix.indexOf(req);\r\n+\t\t\tRequirement newReqElement = createRequirement(importType, lineNumber);\r\n+\r\n+\t\t\t//If the first columns of a requirement are empty then values from previous lines are used\r\n+\t\t\tString attribute = req.iterator().next();\r\n+\t\t\twhile (attribute.equals(\"\")) {\r\n+\t\t\t\tint currentAttributeIndex = req.indexOf(attribute);\r\n+\t\t\t\tString repeatedValue = csvContentMatrix.get(lineNumber - 1).get(currentAttributeIndex);\r\n+\t\t\t\tif (attributeMapping.get(currentAttributeIndex) != null && attributeMapping.get(currentAttributeIndex).getType().equals(RequirementAttribute.TYPE_Identifier_NAME)) {\r\n+\t\t\t\t\trepeatedValue += REQ_EXTENSION_IDENTIFIER_PREFIX;\r\n+\t\t\t\t}\r\n+\t\t\t\treq.set(currentAttributeIndex, repeatedValue);\r\n+\t\t\t\tattribute = req.get(currentAttributeIndex + 1);\r\n+\t\t\t}\r\n+\t\r\n+\t\t\t//Needed because req.indexOf(attValue) does not work if columns have the same value\r\n+\t\t\tint currentIndex = 0;\r\n+\t\t\tfor (String attValue : req) {\r\n+\t\t\t\tRequirementAttribute mappedAttribute = attributeMapping.get(currentIndex);\r\n+\r\n+\t\t\t\tif (mappedAttribute != null) {\r\n+\t\t\t\t\tsetAttributeValue(newReqElement, attValue, mappedAttribute);\r\n+\t\t\t\t}\r\n+\t\t\t\tcurrentIndex++;\r\n+\t\t\t}\r\n+\t\t\tnewReqElement.updateNameFromAttributes();\r\n+\t\t\timportCommand.append(targetSpecificationList.add(editingDomain, newReqElement));\r\n+\t\t}\r\n+\r\n+\t\treturn importCommand;\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param newImportTypeContainer\r\n+\t *            the requirement configuration in which the new type element should\r\n+\t *            be added into\r\n+\t * @param nonPersistedType\r\n+\t *            A new requirement type that is not yet persisted\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementsConfiguration newImportTypeContainer, RequirementType nonPersistedType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tthis.reqConcept = getReqConcept(newImportTypeContainer.getTypeInstance());\r\n+\r\n+\t\t// Create a requirement type for the import\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\t\tcustomizeReqTypeFromData(nonPersistedType, csvContentMatrix, attributeMapping);\r\n+\t\tRequirementType reqType = createReqType(importCommand, newImportTypeContainer, nonPersistedType);\r\n+\r\n+\t\timportCommand.append(\r\n+\t\t\t\tloadRequirements(editingDomain, csvContentMatrix, targetSpecificationList, attributeMapping, reqType));\r\n+\r\n+\t\treturn importCommand;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Creates a requirement type from a list of attribute names. Does not create a\r\n+\t * command or persist the element yet\r\n+\t * \r\n+\t * @param reqConcept\r\n+\t *            the active concept\r\n+\t * @param attributeNames\r\n+\t *            a list of attribute names\r\n+\t * @return the new type\r\n+\t */\r\n+\tpublic RequirementType prepareRequirementType(Concept reqConcept, List<String> attributeNames) {\r\n+\t\tthis.reqConcept = reqConcept;\r\n+\t\tRequirementType newReqType = new RequirementType(reqConcept);\r\n+\t\tnewReqType.setName(REQ_TYPE_NAME);\r\n+\t\tfor (String attName : attributeNames) {\r\n+\t\t\tRequirementAttribute attDef = new RequirementAttribute(reqConcept);\r\n+\t\t\tattDef.setName(attName.replace(\" \", \"\"));\r\n+\t\t\tattDef.setType(RequirementAttribute.TYPE_String_NAME);\r\n+\t\t\tnewReqType.getAttributes().add(attDef);\r\n+\t\t}\r\n+\t\treturn newReqType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a requirement and set its type\r\n+\t * \r\n+\t *            the containing list of requirements\r\n+\t * @param reqType\r\n+\t *            the requirement type\r\n+\t * @param lineNumber \r\n+\t * \t\t\t  the line index of the requirement\r\n+\t * @return the new requirement\r\n+\t */\r\n+\tprotected Requirement createRequirement(RequirementType reqType, int lineNumber) {\r\n+\t\tRequirement requirement = new Requirement(reqConcept);\r\n+\t\trequirement.setReqType(reqType);\r\n+\t\trequirement.setName(reqType.getName() + lineNumber);\r\n+\t\tfor (RequirementAttribute att : reqType.getAttributes()) {\r\n+\t\t\tAttributeValue attValue = new AttributeValue(reqConcept);\r\n+\t\t\tattValue.setName(att.getName());\r\n+\t\t\tattValue.setAttType(att);\r\n+\t\t\trequirement.getElements().add(attValue);\r\n+\t\t}\r\n+\t\treturn requirement;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a attribute value within a requirement\r\n+\t * \r\n+\t * @param requirement\r\n+\t *            the requirement to edit\r\n+\t * @param value\r\n+\t *            the value to be added to the attribute\r\n+\t * @param attDef the attribute definition\r\n+\t */\r\n+\tprotected void setAttributeValue(Requirement requirement, String value,\r\n+\t\t\tRequirementAttribute attDef) {\r\n+\t\tfor (AttributeValue att : requirement.getElements()) {\r\n+\t\t\tRequirementAttribute type = att.getAttType();\r\n+\t\t\tif (type.equals(attDef)) {\r\n+\t\t\t\tatt.setValue(value);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * create a requirement type with a given number of attributes\r\n+\t * \r\n+\t * @param importCommand\r\n+\t *            the import command which should contain this creation operation\r\n+\t * @param container\r\n+\t *            the container element in which the new type should be added into\r\n+\t * @param newReqType\r\n+\t *            a new not yet persited requirement type\r\n+\t * @return the new requirement type\r\n+\t */\r\n+\tprotected RequirementType createReqType(CompoundCommand importCommand, RequirementsConfiguration container,\r\n+\t\t\tRequirementType newReqType) {\r\n+\r\n+\t\timportCommand.append(container.getTypeDefinitions().add(editingDomain, newReqType));\r\n+\t\treturn newReqType;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Update a new requirement type from a set of CSV data\r\n+\t * @param type the not yet persisted requirement type\r\n+\t * @param csvContentMatrix the CSV data\r\n+\t * @param attributeMapping the mapping of column index to attribute\r\n+\t */\r\n+\tprotected void customizeReqTypeFromData(RequirementType type, List<List<String>> csvContentMatrix, Map<Integer, RequirementAttribute> attributeMapping) {\r\n+\t\tfor (RequirementAttribute att : type.getAttributes()) {\r\n+\t\t\t\r\n+\t\t\tif (att.getType().equals(RequirementAttribute.TYPE_Enumeration_NAME)) {\r\n+\t\t\t\t\r\n+\t\t\t\tInteger columnIndexOfAttribute = null;\r\n+\t\t\t\tfor (Entry<Integer, RequirementAttribute> entry : attributeMapping.entrySet()) {\r\n+\t\t\t\t\tif (entry.getValue().equals(att)) {\r\n+\t\t\t\t\t\tcolumnIndexOfAttribute = entry.getKey();\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tif (columnIndexOfAttribute != null) {\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyNzQzMQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449227431", "bodyText": "I think it's easier to iterate over map entries and check if attribute is enum", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T19:33:19Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvRequirementsImporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Map.Entry;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.emf.common.command.CompoundCommand;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.model.concept.list.IBeanList;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.Activator;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.AttributeValue;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.EnumerationLiteral;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementObject;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+\r\n+/**\r\n+ * A class that imports requirements from a CSV file\r\n+ *\r\n+ */\r\n+public class CsvRequirementsImporter {\r\n+\r\n+\tprotected EditingDomain editingDomain;\r\n+\tprotected Concept reqConcept;\r\n+\r\n+\tprivate static final String REQ_TYPE_NAME = \"CCVImportedRequirementType\";\r\n+\tprivate static final String REQ_EXTENSION_IDENTIFIER_PREFIX = \"-extension\";\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param importType\r\n+\t *            the requirement type of the imported requirements\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementType importType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tif (reqConcept == null) {\r\n+\t\t\tthis.reqConcept = getReqConcept(importType.getTypeInstance());\r\n+\t\t}\r\n+\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\r\n+\t\t// Read the actual requirements\r\n+\t\tfor (List<String> req : csvContentMatrix) {\r\n+\t\t\tint lineNumber = csvContentMatrix.indexOf(req);\r\n+\t\t\tRequirement newReqElement = createRequirement(importType, lineNumber);\r\n+\r\n+\t\t\t//If the first columns of a requirement are empty then values from previous lines are used\r\n+\t\t\tString attribute = req.iterator().next();\r\n+\t\t\twhile (attribute.equals(\"\")) {\r\n+\t\t\t\tint currentAttributeIndex = req.indexOf(attribute);\r\n+\t\t\t\tString repeatedValue = csvContentMatrix.get(lineNumber - 1).get(currentAttributeIndex);\r\n+\t\t\t\tif (attributeMapping.get(currentAttributeIndex) != null && attributeMapping.get(currentAttributeIndex).getType().equals(RequirementAttribute.TYPE_Identifier_NAME)) {\r\n+\t\t\t\t\trepeatedValue += REQ_EXTENSION_IDENTIFIER_PREFIX;\r\n+\t\t\t\t}\r\n+\t\t\t\treq.set(currentAttributeIndex, repeatedValue);\r\n+\t\t\t\tattribute = req.get(currentAttributeIndex + 1);\r\n+\t\t\t}\r\n+\t\r\n+\t\t\t//Needed because req.indexOf(attValue) does not work if columns have the same value\r\n+\t\t\tint currentIndex = 0;\r\n+\t\t\tfor (String attValue : req) {\r\n+\t\t\t\tRequirementAttribute mappedAttribute = attributeMapping.get(currentIndex);\r\n+\r\n+\t\t\t\tif (mappedAttribute != null) {\r\n+\t\t\t\t\tsetAttributeValue(newReqElement, attValue, mappedAttribute);\r\n+\t\t\t\t}\r\n+\t\t\t\tcurrentIndex++;\r\n+\t\t\t}\r\n+\t\t\tnewReqElement.updateNameFromAttributes();\r\n+\t\t\timportCommand.append(targetSpecificationList.add(editingDomain, newReqElement));\r\n+\t\t}\r\n+\r\n+\t\treturn importCommand;\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param newImportTypeContainer\r\n+\t *            the requirement configuration in which the new type element should\r\n+\t *            be added into\r\n+\t * @param nonPersistedType\r\n+\t *            A new requirement type that is not yet persisted\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementsConfiguration newImportTypeContainer, RequirementType nonPersistedType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tthis.reqConcept = getReqConcept(newImportTypeContainer.getTypeInstance());\r\n+\r\n+\t\t// Create a requirement type for the import\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\t\tcustomizeReqTypeFromData(nonPersistedType, csvContentMatrix, attributeMapping);\r\n+\t\tRequirementType reqType = createReqType(importCommand, newImportTypeContainer, nonPersistedType);\r\n+\r\n+\t\timportCommand.append(\r\n+\t\t\t\tloadRequirements(editingDomain, csvContentMatrix, targetSpecificationList, attributeMapping, reqType));\r\n+\r\n+\t\treturn importCommand;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Creates a requirement type from a list of attribute names. Does not create a\r\n+\t * command or persist the element yet\r\n+\t * \r\n+\t * @param reqConcept\r\n+\t *            the active concept\r\n+\t * @param attributeNames\r\n+\t *            a list of attribute names\r\n+\t * @return the new type\r\n+\t */\r\n+\tpublic RequirementType prepareRequirementType(Concept reqConcept, List<String> attributeNames) {\r\n+\t\tthis.reqConcept = reqConcept;\r\n+\t\tRequirementType newReqType = new RequirementType(reqConcept);\r\n+\t\tnewReqType.setName(REQ_TYPE_NAME);\r\n+\t\tfor (String attName : attributeNames) {\r\n+\t\t\tRequirementAttribute attDef = new RequirementAttribute(reqConcept);\r\n+\t\t\tattDef.setName(attName.replace(\" \", \"\"));\r\n+\t\t\tattDef.setType(RequirementAttribute.TYPE_String_NAME);\r\n+\t\t\tnewReqType.getAttributes().add(attDef);\r\n+\t\t}\r\n+\t\treturn newReqType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a requirement and set its type\r\n+\t * \r\n+\t *            the containing list of requirements\r\n+\t * @param reqType\r\n+\t *            the requirement type\r\n+\t * @param lineNumber \r\n+\t * \t\t\t  the line index of the requirement\r\n+\t * @return the new requirement\r\n+\t */\r\n+\tprotected Requirement createRequirement(RequirementType reqType, int lineNumber) {\r\n+\t\tRequirement requirement = new Requirement(reqConcept);\r\n+\t\trequirement.setReqType(reqType);\r\n+\t\trequirement.setName(reqType.getName() + lineNumber);\r\n+\t\tfor (RequirementAttribute att : reqType.getAttributes()) {\r\n+\t\t\tAttributeValue attValue = new AttributeValue(reqConcept);\r\n+\t\t\tattValue.setName(att.getName());\r\n+\t\t\tattValue.setAttType(att);\r\n+\t\t\trequirement.getElements().add(attValue);\r\n+\t\t}\r\n+\t\treturn requirement;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a attribute value within a requirement\r\n+\t * \r\n+\t * @param requirement\r\n+\t *            the requirement to edit\r\n+\t * @param value\r\n+\t *            the value to be added to the attribute\r\n+\t * @param attDef the attribute definition\r\n+\t */\r\n+\tprotected void setAttributeValue(Requirement requirement, String value,\r\n+\t\t\tRequirementAttribute attDef) {\r\n+\t\tfor (AttributeValue att : requirement.getElements()) {\r\n+\t\t\tRequirementAttribute type = att.getAttType();\r\n+\t\t\tif (type.equals(attDef)) {\r\n+\t\t\t\tatt.setValue(value);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * create a requirement type with a given number of attributes\r\n+\t * \r\n+\t * @param importCommand\r\n+\t *            the import command which should contain this creation operation\r\n+\t * @param container\r\n+\t *            the container element in which the new type should be added into\r\n+\t * @param newReqType\r\n+\t *            a new not yet persited requirement type\r\n+\t * @return the new requirement type\r\n+\t */\r\n+\tprotected RequirementType createReqType(CompoundCommand importCommand, RequirementsConfiguration container,\r\n+\t\t\tRequirementType newReqType) {\r\n+\r\n+\t\timportCommand.append(container.getTypeDefinitions().add(editingDomain, newReqType));\r\n+\t\treturn newReqType;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Update a new requirement type from a set of CSV data\r\n+\t * @param type the not yet persisted requirement type\r\n+\t * @param csvContentMatrix the CSV data\r\n+\t * @param attributeMapping the mapping of column index to attribute\r\n+\t */\r\n+\tprotected void customizeReqTypeFromData(RequirementType type, List<List<String>> csvContentMatrix, Map<Integer, RequirementAttribute> attributeMapping) {\r\n+\t\tfor (RequirementAttribute att : type.getAttributes()) {\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyOTE2Mg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449229162", "bodyText": "I suggest you either chain a non-regex replace or use regex class (like in another comment)", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T19:37:26Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvRequirementsImporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Map.Entry;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.emf.common.command.CompoundCommand;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.model.concept.list.IBeanList;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.Activator;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.AttributeValue;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.EnumerationLiteral;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementObject;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+\r\n+/**\r\n+ * A class that imports requirements from a CSV file\r\n+ *\r\n+ */\r\n+public class CsvRequirementsImporter {\r\n+\r\n+\tprotected EditingDomain editingDomain;\r\n+\tprotected Concept reqConcept;\r\n+\r\n+\tprivate static final String REQ_TYPE_NAME = \"CCVImportedRequirementType\";\r\n+\tprivate static final String REQ_EXTENSION_IDENTIFIER_PREFIX = \"-extension\";\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param importType\r\n+\t *            the requirement type of the imported requirements\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementType importType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tif (reqConcept == null) {\r\n+\t\t\tthis.reqConcept = getReqConcept(importType.getTypeInstance());\r\n+\t\t}\r\n+\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\r\n+\t\t// Read the actual requirements\r\n+\t\tfor (List<String> req : csvContentMatrix) {\r\n+\t\t\tint lineNumber = csvContentMatrix.indexOf(req);\r\n+\t\t\tRequirement newReqElement = createRequirement(importType, lineNumber);\r\n+\r\n+\t\t\t//If the first columns of a requirement are empty then values from previous lines are used\r\n+\t\t\tString attribute = req.iterator().next();\r\n+\t\t\twhile (attribute.equals(\"\")) {\r\n+\t\t\t\tint currentAttributeIndex = req.indexOf(attribute);\r\n+\t\t\t\tString repeatedValue = csvContentMatrix.get(lineNumber - 1).get(currentAttributeIndex);\r\n+\t\t\t\tif (attributeMapping.get(currentAttributeIndex) != null && attributeMapping.get(currentAttributeIndex).getType().equals(RequirementAttribute.TYPE_Identifier_NAME)) {\r\n+\t\t\t\t\trepeatedValue += REQ_EXTENSION_IDENTIFIER_PREFIX;\r\n+\t\t\t\t}\r\n+\t\t\t\treq.set(currentAttributeIndex, repeatedValue);\r\n+\t\t\t\tattribute = req.get(currentAttributeIndex + 1);\r\n+\t\t\t}\r\n+\t\r\n+\t\t\t//Needed because req.indexOf(attValue) does not work if columns have the same value\r\n+\t\t\tint currentIndex = 0;\r\n+\t\t\tfor (String attValue : req) {\r\n+\t\t\t\tRequirementAttribute mappedAttribute = attributeMapping.get(currentIndex);\r\n+\r\n+\t\t\t\tif (mappedAttribute != null) {\r\n+\t\t\t\t\tsetAttributeValue(newReqElement, attValue, mappedAttribute);\r\n+\t\t\t\t}\r\n+\t\t\t\tcurrentIndex++;\r\n+\t\t\t}\r\n+\t\t\tnewReqElement.updateNameFromAttributes();\r\n+\t\t\timportCommand.append(targetSpecificationList.add(editingDomain, newReqElement));\r\n+\t\t}\r\n+\r\n+\t\treturn importCommand;\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param newImportTypeContainer\r\n+\t *            the requirement configuration in which the new type element should\r\n+\t *            be added into\r\n+\t * @param nonPersistedType\r\n+\t *            A new requirement type that is not yet persisted\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementsConfiguration newImportTypeContainer, RequirementType nonPersistedType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tthis.reqConcept = getReqConcept(newImportTypeContainer.getTypeInstance());\r\n+\r\n+\t\t// Create a requirement type for the import\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\t\tcustomizeReqTypeFromData(nonPersistedType, csvContentMatrix, attributeMapping);\r\n+\t\tRequirementType reqType = createReqType(importCommand, newImportTypeContainer, nonPersistedType);\r\n+\r\n+\t\timportCommand.append(\r\n+\t\t\t\tloadRequirements(editingDomain, csvContentMatrix, targetSpecificationList, attributeMapping, reqType));\r\n+\r\n+\t\treturn importCommand;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Creates a requirement type from a list of attribute names. Does not create a\r\n+\t * command or persist the element yet\r\n+\t * \r\n+\t * @param reqConcept\r\n+\t *            the active concept\r\n+\t * @param attributeNames\r\n+\t *            a list of attribute names\r\n+\t * @return the new type\r\n+\t */\r\n+\tpublic RequirementType prepareRequirementType(Concept reqConcept, List<String> attributeNames) {\r\n+\t\tthis.reqConcept = reqConcept;\r\n+\t\tRequirementType newReqType = new RequirementType(reqConcept);\r\n+\t\tnewReqType.setName(REQ_TYPE_NAME);\r\n+\t\tfor (String attName : attributeNames) {\r\n+\t\t\tRequirementAttribute attDef = new RequirementAttribute(reqConcept);\r\n+\t\t\tattDef.setName(attName.replace(\" \", \"\"));\r\n+\t\t\tattDef.setType(RequirementAttribute.TYPE_String_NAME);\r\n+\t\t\tnewReqType.getAttributes().add(attDef);\r\n+\t\t}\r\n+\t\treturn newReqType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a requirement and set its type\r\n+\t * \r\n+\t *            the containing list of requirements\r\n+\t * @param reqType\r\n+\t *            the requirement type\r\n+\t * @param lineNumber \r\n+\t * \t\t\t  the line index of the requirement\r\n+\t * @return the new requirement\r\n+\t */\r\n+\tprotected Requirement createRequirement(RequirementType reqType, int lineNumber) {\r\n+\t\tRequirement requirement = new Requirement(reqConcept);\r\n+\t\trequirement.setReqType(reqType);\r\n+\t\trequirement.setName(reqType.getName() + lineNumber);\r\n+\t\tfor (RequirementAttribute att : reqType.getAttributes()) {\r\n+\t\t\tAttributeValue attValue = new AttributeValue(reqConcept);\r\n+\t\t\tattValue.setName(att.getName());\r\n+\t\t\tattValue.setAttType(att);\r\n+\t\t\trequirement.getElements().add(attValue);\r\n+\t\t}\r\n+\t\treturn requirement;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a attribute value within a requirement\r\n+\t * \r\n+\t * @param requirement\r\n+\t *            the requirement to edit\r\n+\t * @param value\r\n+\t *            the value to be added to the attribute\r\n+\t * @param attDef the attribute definition\r\n+\t */\r\n+\tprotected void setAttributeValue(Requirement requirement, String value,\r\n+\t\t\tRequirementAttribute attDef) {\r\n+\t\tfor (AttributeValue att : requirement.getElements()) {\r\n+\t\t\tRequirementAttribute type = att.getAttType();\r\n+\t\t\tif (type.equals(attDef)) {\r\n+\t\t\t\tatt.setValue(value);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * create a requirement type with a given number of attributes\r\n+\t * \r\n+\t * @param importCommand\r\n+\t *            the import command which should contain this creation operation\r\n+\t * @param container\r\n+\t *            the container element in which the new type should be added into\r\n+\t * @param newReqType\r\n+\t *            a new not yet persited requirement type\r\n+\t * @return the new requirement type\r\n+\t */\r\n+\tprotected RequirementType createReqType(CompoundCommand importCommand, RequirementsConfiguration container,\r\n+\t\t\tRequirementType newReqType) {\r\n+\r\n+\t\timportCommand.append(container.getTypeDefinitions().add(editingDomain, newReqType));\r\n+\t\treturn newReqType;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Update a new requirement type from a set of CSV data\r\n+\t * @param type the not yet persisted requirement type\r\n+\t * @param csvContentMatrix the CSV data\r\n+\t * @param attributeMapping the mapping of column index to attribute\r\n+\t */\r\n+\tprotected void customizeReqTypeFromData(RequirementType type, List<List<String>> csvContentMatrix, Map<Integer, RequirementAttribute> attributeMapping) {\r\n+\t\tfor (RequirementAttribute att : type.getAttributes()) {\r\n+\t\t\t\r\n+\t\t\tif (att.getType().equals(RequirementAttribute.TYPE_Enumeration_NAME)) {\r\n+\t\t\t\t\r\n+\t\t\t\tInteger columnIndexOfAttribute = null;\r\n+\t\t\t\tfor (Entry<Integer, RequirementAttribute> entry : attributeMapping.entrySet()) {\r\n+\t\t\t\t\tif (entry.getValue().equals(att)) {\r\n+\t\t\t\t\t\tcolumnIndexOfAttribute = entry.getKey();\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\tif (columnIndexOfAttribute != null) {\r\n+\t\t\t\t\tSet<String> enumerationLiteralValues = new HashSet<>();\r\n+\t\t\t\t\tfor (List<String> reg : csvContentMatrix) {\r\n+\t\t\t\t\t\tif (reg.size() > columnIndexOfAttribute) {\r\n+\t\t\t\t\t\t\tenumerationLiteralValues.add(reg.get(columnIndexOfAttribute));\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\tfor (String literal : enumerationLiteralValues) {\r\n+\t\t\t\t\t\tif (!literal.equals(\"\")) {\r\n+\t\t\t\t\t\t\tEnumerationLiteral literalBean = new EnumerationLiteral(reqConcept);\r\n+\t\t\t\t\t\t\tString literalName = literal.replaceAll(\" \", \"\");\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0ODM2Ng==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449248366", "bodyText": "CSV?", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T20:23:22Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvRequirementsImporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Map.Entry;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.emf.common.command.CompoundCommand;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.model.concept.list.IBeanList;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.Activator;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.AttributeValue;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.EnumerationLiteral;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementObject;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+\r\n+/**\r\n+ * A class that imports requirements from a CSV file\r\n+ *\r\n+ */\r\n+public class CsvRequirementsImporter {\r\n+\r\n+\tprotected EditingDomain editingDomain;\r\n+\tprotected Concept reqConcept;\r\n+\r\n+\tprivate static final String REQ_TYPE_NAME = \"CCVImportedRequirementType\";\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0OTcxNg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449249716", "bodyText": "Not sure this is a useful method, I would put this one line directly into loadRequirements where it's called", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T20:26:32Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvRequirementsImporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Map.Entry;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.emf.common.command.CompoundCommand;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.model.concept.list.IBeanList;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.Activator;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.AttributeValue;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.EnumerationLiteral;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementObject;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+\r\n+/**\r\n+ * A class that imports requirements from a CSV file\r\n+ *\r\n+ */\r\n+public class CsvRequirementsImporter {\r\n+\r\n+\tprotected EditingDomain editingDomain;\r\n+\tprotected Concept reqConcept;\r\n+\r\n+\tprivate static final String REQ_TYPE_NAME = \"CCVImportedRequirementType\";\r\n+\tprivate static final String REQ_EXTENSION_IDENTIFIER_PREFIX = \"-extension\";\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param importType\r\n+\t *            the requirement type of the imported requirements\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementType importType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tif (reqConcept == null) {\r\n+\t\t\tthis.reqConcept = getReqConcept(importType.getTypeInstance());\r\n+\t\t}\r\n+\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\r\n+\t\t// Read the actual requirements\r\n+\t\tfor (List<String> req : csvContentMatrix) {\r\n+\t\t\tint lineNumber = csvContentMatrix.indexOf(req);\r\n+\t\t\tRequirement newReqElement = createRequirement(importType, lineNumber);\r\n+\r\n+\t\t\t//If the first columns of a requirement are empty then values from previous lines are used\r\n+\t\t\tString attribute = req.iterator().next();\r\n+\t\t\twhile (attribute.equals(\"\")) {\r\n+\t\t\t\tint currentAttributeIndex = req.indexOf(attribute);\r\n+\t\t\t\tString repeatedValue = csvContentMatrix.get(lineNumber - 1).get(currentAttributeIndex);\r\n+\t\t\t\tif (attributeMapping.get(currentAttributeIndex) != null && attributeMapping.get(currentAttributeIndex).getType().equals(RequirementAttribute.TYPE_Identifier_NAME)) {\r\n+\t\t\t\t\trepeatedValue += REQ_EXTENSION_IDENTIFIER_PREFIX;\r\n+\t\t\t\t}\r\n+\t\t\t\treq.set(currentAttributeIndex, repeatedValue);\r\n+\t\t\t\tattribute = req.get(currentAttributeIndex + 1);\r\n+\t\t\t}\r\n+\t\r\n+\t\t\t//Needed because req.indexOf(attValue) does not work if columns have the same value\r\n+\t\t\tint currentIndex = 0;\r\n+\t\t\tfor (String attValue : req) {\r\n+\t\t\t\tRequirementAttribute mappedAttribute = attributeMapping.get(currentIndex);\r\n+\r\n+\t\t\t\tif (mappedAttribute != null) {\r\n+\t\t\t\t\tsetAttributeValue(newReqElement, attValue, mappedAttribute);\r\n+\t\t\t\t}\r\n+\t\t\t\tcurrentIndex++;\r\n+\t\t\t}\r\n+\t\t\tnewReqElement.updateNameFromAttributes();\r\n+\t\t\timportCommand.append(targetSpecificationList.add(editingDomain, newReqElement));\r\n+\t\t}\r\n+\r\n+\t\treturn importCommand;\r\n+\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param newImportTypeContainer\r\n+\t *            the requirement configuration in which the new type element should\r\n+\t *            be added into\r\n+\t * @param nonPersistedType\r\n+\t *            A new requirement type that is not yet persisted\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementsConfiguration newImportTypeContainer, RequirementType nonPersistedType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tthis.reqConcept = getReqConcept(newImportTypeContainer.getTypeInstance());\r\n+\r\n+\t\t// Create a requirement type for the import\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\t\tcustomizeReqTypeFromData(nonPersistedType, csvContentMatrix, attributeMapping);\r\n+\t\tRequirementType reqType = createReqType(importCommand, newImportTypeContainer, nonPersistedType);\r\n+\r\n+\t\timportCommand.append(\r\n+\t\t\t\tloadRequirements(editingDomain, csvContentMatrix, targetSpecificationList, attributeMapping, reqType));\r\n+\r\n+\t\treturn importCommand;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Creates a requirement type from a list of attribute names. Does not create a\r\n+\t * command or persist the element yet\r\n+\t * \r\n+\t * @param reqConcept\r\n+\t *            the active concept\r\n+\t * @param attributeNames\r\n+\t *            a list of attribute names\r\n+\t * @return the new type\r\n+\t */\r\n+\tpublic RequirementType prepareRequirementType(Concept reqConcept, List<String> attributeNames) {\r\n+\t\tthis.reqConcept = reqConcept;\r\n+\t\tRequirementType newReqType = new RequirementType(reqConcept);\r\n+\t\tnewReqType.setName(REQ_TYPE_NAME);\r\n+\t\tfor (String attName : attributeNames) {\r\n+\t\t\tRequirementAttribute attDef = new RequirementAttribute(reqConcept);\r\n+\t\t\tattDef.setName(attName.replace(\" \", \"\"));\r\n+\t\t\tattDef.setType(RequirementAttribute.TYPE_String_NAME);\r\n+\t\t\tnewReqType.getAttributes().add(attDef);\r\n+\t\t}\r\n+\t\treturn newReqType;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a requirement and set its type\r\n+\t * \r\n+\t *            the containing list of requirements\r\n+\t * @param reqType\r\n+\t *            the requirement type\r\n+\t * @param lineNumber \r\n+\t * \t\t\t  the line index of the requirement\r\n+\t * @return the new requirement\r\n+\t */\r\n+\tprotected Requirement createRequirement(RequirementType reqType, int lineNumber) {\r\n+\t\tRequirement requirement = new Requirement(reqConcept);\r\n+\t\trequirement.setReqType(reqType);\r\n+\t\trequirement.setName(reqType.getName() + lineNumber);\r\n+\t\tfor (RequirementAttribute att : reqType.getAttributes()) {\r\n+\t\t\tAttributeValue attValue = new AttributeValue(reqConcept);\r\n+\t\t\tattValue.setName(att.getName());\r\n+\t\t\tattValue.setAttType(att);\r\n+\t\t\trequirement.getElements().add(attValue);\r\n+\t\t}\r\n+\t\treturn requirement;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a attribute value within a requirement\r\n+\t * \r\n+\t * @param requirement\r\n+\t *            the requirement to edit\r\n+\t * @param value\r\n+\t *            the value to be added to the attribute\r\n+\t * @param attDef the attribute definition\r\n+\t */\r\n+\tprotected void setAttributeValue(Requirement requirement, String value,\r\n+\t\t\tRequirementAttribute attDef) {\r\n+\t\tfor (AttributeValue att : requirement.getElements()) {\r\n+\t\t\tRequirementAttribute type = att.getAttType();\r\n+\t\t\tif (type.equals(attDef)) {\r\n+\t\t\t\tatt.setValue(value);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * create a requirement type with a given number of attributes\r\n+\t * \r\n+\t * @param importCommand\r\n+\t *            the import command which should contain this creation operation\r\n+\t * @param container\r\n+\t *            the container element in which the new type should be added into\r\n+\t * @param newReqType\r\n+\t *            a new not yet persited requirement type\r\n+\t * @return the new requirement type\r\n+\t */\r\n+\tprotected RequirementType createReqType(CompoundCommand importCommand, RequirementsConfiguration container,\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI1MjU1NQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449252555", "bodyText": "I suggest an indexed for loop, indexOf is linear time", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T20:33:00Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvRequirementsImporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Map.Entry;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.emf.common.command.CompoundCommand;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.model.concept.list.IBeanList;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.Activator;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.AttributeValue;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.EnumerationLiteral;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementObject;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+\r\n+/**\r\n+ * A class that imports requirements from a CSV file\r\n+ *\r\n+ */\r\n+public class CsvRequirementsImporter {\r\n+\r\n+\tprotected EditingDomain editingDomain;\r\n+\tprotected Concept reqConcept;\r\n+\r\n+\tprivate static final String REQ_TYPE_NAME = \"CCVImportedRequirementType\";\r\n+\tprivate static final String REQ_EXTENSION_IDENTIFIER_PREFIX = \"-extension\";\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param importType\r\n+\t *            the requirement type of the imported requirements\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementType importType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tif (reqConcept == null) {\r\n+\t\t\tthis.reqConcept = getReqConcept(importType.getTypeInstance());\r\n+\t\t}\r\n+\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\r\n+\t\t// Read the actual requirements\r\n+\t\tfor (List<String> req : csvContentMatrix) {\r\n+\t\t\tint lineNumber = csvContentMatrix.indexOf(req);\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI1NjUwNA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449256504", "bodyText": "Potential out of bounds exception if it happens in row 0", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T20:42:32Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvRequirementsImporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Map.Entry;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.emf.common.command.CompoundCommand;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.model.concept.list.IBeanList;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.Activator;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.AttributeValue;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.EnumerationLiteral;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementObject;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+\r\n+/**\r\n+ * A class that imports requirements from a CSV file\r\n+ *\r\n+ */\r\n+public class CsvRequirementsImporter {\r\n+\r\n+\tprotected EditingDomain editingDomain;\r\n+\tprotected Concept reqConcept;\r\n+\r\n+\tprivate static final String REQ_TYPE_NAME = \"CCVImportedRequirementType\";\r\n+\tprivate static final String REQ_EXTENSION_IDENTIFIER_PREFIX = \"-extension\";\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param importType\r\n+\t *            the requirement type of the imported requirements\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementType importType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tif (reqConcept == null) {\r\n+\t\t\tthis.reqConcept = getReqConcept(importType.getTypeInstance());\r\n+\t\t}\r\n+\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\r\n+\t\t// Read the actual requirements\r\n+\t\tfor (List<String> req : csvContentMatrix) {\r\n+\t\t\tint lineNumber = csvContentMatrix.indexOf(req);\r\n+\t\t\tRequirement newReqElement = createRequirement(importType, lineNumber);\r\n+\r\n+\t\t\t//If the first columns of a requirement are empty then values from previous lines are used\r\n+\t\t\tString attribute = req.iterator().next();\r\n+\t\t\twhile (attribute.equals(\"\")) {\r\n+\t\t\t\tint currentAttributeIndex = req.indexOf(attribute);\r\n+\t\t\t\tString repeatedValue = csvContentMatrix.get(lineNumber - 1).get(currentAttributeIndex);\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI1ODg5NQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449258895", "bodyText": "I don't get this logic, what if my ID attribute is in the last column?", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T20:48:42Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvRequirementsImporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Map.Entry;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.emf.common.command.CompoundCommand;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.model.concept.list.IBeanList;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.Activator;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.AttributeValue;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.EnumerationLiteral;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementObject;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+\r\n+/**\r\n+ * A class that imports requirements from a CSV file\r\n+ *\r\n+ */\r\n+public class CsvRequirementsImporter {\r\n+\r\n+\tprotected EditingDomain editingDomain;\r\n+\tprotected Concept reqConcept;\r\n+\r\n+\tprivate static final String REQ_TYPE_NAME = \"CCVImportedRequirementType\";\r\n+\tprivate static final String REQ_EXTENSION_IDENTIFIER_PREFIX = \"-extension\";\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param importType\r\n+\t *            the requirement type of the imported requirements\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementType importType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tif (reqConcept == null) {\r\n+\t\t\tthis.reqConcept = getReqConcept(importType.getTypeInstance());\r\n+\t\t}\r\n+\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\r\n+\t\t// Read the actual requirements\r\n+\t\tfor (List<String> req : csvContentMatrix) {\r\n+\t\t\tint lineNumber = csvContentMatrix.indexOf(req);\r\n+\t\t\tRequirement newReqElement = createRequirement(importType, lineNumber);\r\n+\r\n+\t\t\t//If the first columns of a requirement are empty then values from previous lines are used\r\n+\t\t\tString attribute = req.iterator().next();\r\n+\t\t\twhile (attribute.equals(\"\")) {\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMyODU4Mg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449328582", "bodyText": "Well apprently the system engineers simply add a new line in their excel cheet and if they have an extenison to a requiremnt... This is then considered as part of the one in the line above. and only the values starting from this column are used then", "author": "franzTobiasDLR", "createdAt": "2020-07-03T01:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI1ODg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI1OTY2Nw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449259667", "bodyText": "If I have multiple lines with empty field, I will get chained \"-extensions\", is it okay?", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T20:50:33Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvRequirementsImporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Map.Entry;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.emf.common.command.CompoundCommand;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.model.concept.list.IBeanList;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.Activator;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.AttributeValue;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.EnumerationLiteral;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementObject;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+\r\n+/**\r\n+ * A class that imports requirements from a CSV file\r\n+ *\r\n+ */\r\n+public class CsvRequirementsImporter {\r\n+\r\n+\tprotected EditingDomain editingDomain;\r\n+\tprotected Concept reqConcept;\r\n+\r\n+\tprivate static final String REQ_TYPE_NAME = \"CCVImportedRequirementType\";\r\n+\tprivate static final String REQ_EXTENSION_IDENTIFIER_PREFIX = \"-extension\";\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param importType\r\n+\t *            the requirement type of the imported requirements\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementType importType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tif (reqConcept == null) {\r\n+\t\t\tthis.reqConcept = getReqConcept(importType.getTypeInstance());\r\n+\t\t}\r\n+\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\r\n+\t\t// Read the actual requirements\r\n+\t\tfor (List<String> req : csvContentMatrix) {\r\n+\t\t\tint lineNumber = csvContentMatrix.indexOf(req);\r\n+\t\t\tRequirement newReqElement = createRequirement(importType, lineNumber);\r\n+\r\n+\t\t\t//If the first columns of a requirement are empty then values from previous lines are used\r\n+\t\t\tString attribute = req.iterator().next();\r\n+\t\t\twhile (attribute.equals(\"\")) {\r\n+\t\t\t\tint currentAttributeIndex = req.indexOf(attribute);\r\n+\t\t\t\tString repeatedValue = csvContentMatrix.get(lineNumber - 1).get(currentAttributeIndex);\r\n+\t\t\t\tif (attributeMapping.get(currentAttributeIndex) != null && attributeMapping.get(currentAttributeIndex).getType().equals(RequirementAttribute.TYPE_Identifier_NAME)) {\r\n+\t\t\t\t\trepeatedValue += REQ_EXTENSION_IDENTIFIER_PREFIX;\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMyODkxOA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449328918", "bodyText": "Yes, that's fine", "author": "franzTobiasDLR", "createdAt": "2020-07-03T01:05:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI1OTY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI1OTg2OQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449259869", "bodyText": "How about an indexed for?", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T20:51:01Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvRequirementsImporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Map.Entry;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.emf.common.command.CompoundCommand;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.model.concept.list.IBeanList;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.extension.requirements.Activator;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.AttributeValue;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.EnumerationLiteral;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementAttribute;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementObject;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementType;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.RequirementsConfiguration;\r\n+import de.dlr.sc.virsat.project.resources.VirSatResourceSet;\r\n+\r\n+/**\r\n+ * A class that imports requirements from a CSV file\r\n+ *\r\n+ */\r\n+public class CsvRequirementsImporter {\r\n+\r\n+\tprotected EditingDomain editingDomain;\r\n+\tprotected Concept reqConcept;\r\n+\r\n+\tprivate static final String REQ_TYPE_NAME = \"CCVImportedRequirementType\";\r\n+\tprivate static final String REQ_EXTENSION_IDENTIFIER_PREFIX = \"-extension\";\r\n+\r\n+\t/**\r\n+\t * The function to load requirement contents from a given SCV file to an exiting\r\n+\t * requirement specification\r\n+\t * \r\n+\t * @param editingDomain\r\n+\t *            the editing domain in which the import should be performed\r\n+\t * @param csvContentMatrix\r\n+\t *            the CSV content matrix\r\n+\t * @param targetSpecificationList\r\n+\t *            the specification list where the requirements should be imported\r\n+\t *            into\r\n+\t * @param attributeMapping\r\n+\t *            the mapping of column index to attribute\r\n+\t * @param importType\r\n+\t *            the requirement type of the imported requirements\r\n+\t * @return the compound command that can be performed to import the requirements\r\n+\t */\r\n+\tpublic CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<String>> csvContentMatrix,\r\n+\t\t\tIBeanList<RequirementObject> targetSpecificationList, Map<Integer, RequirementAttribute> attributeMapping,\r\n+\t\t\tRequirementType importType) {\r\n+\r\n+\t\tthis.editingDomain = editingDomain;\r\n+\t\tif (reqConcept == null) {\r\n+\t\t\tthis.reqConcept = getReqConcept(importType.getTypeInstance());\r\n+\t\t}\r\n+\r\n+\t\tCompoundCommand importCommand = new CompoundCommand();\r\n+\r\n+\t\t// Read the actual requirements\r\n+\t\tfor (List<String> req : csvContentMatrix) {\r\n+\t\t\tint lineNumber = csvContentMatrix.indexOf(req);\r\n+\t\t\tRequirement newReqElement = createRequirement(importType, lineNumber);\r\n+\r\n+\t\t\t//If the first columns of a requirement are empty then values from previous lines are used\r\n+\t\t\tString attribute = req.iterator().next();\r\n+\t\t\twhile (attribute.equals(\"\")) {\r\n+\t\t\t\tint currentAttributeIndex = req.indexOf(attribute);\r\n+\t\t\t\tString repeatedValue = csvContentMatrix.get(lineNumber - 1).get(currentAttributeIndex);\r\n+\t\t\t\tif (attributeMapping.get(currentAttributeIndex) != null && attributeMapping.get(currentAttributeIndex).getType().equals(RequirementAttribute.TYPE_Identifier_NAME)) {\r\n+\t\t\t\t\trepeatedValue += REQ_EXTENSION_IDENTIFIER_PREFIX;\r\n+\t\t\t\t}\r\n+\t\t\t\treq.set(currentAttributeIndex, repeatedValue);\r\n+\t\t\t\tattribute = req.get(currentAttributeIndex + 1);\r\n+\t\t\t}\r\n+\t\r\n+\t\t\t//Needed because req.indexOf(attValue) does not work if columns have the same value\r\n+\t\t\tint currentIndex = 0;\r\n+\t\t\tfor (String attValue : req) {\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2NDA1OQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449264059", "bodyText": "I would rather use an existing CSV library to be honest", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T21:01:42Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvFileReader.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.FileReader;\r\n+import java.io.IOException;\r\n+import java.nio.file.Path;\r\n+import java.nio.file.Paths;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.List;\r\n+\r\n+/**\r\n+ * A class to read a CSV file and pars it to lists\r\n+ *\r\n+ */\r\n+public class CsvFileReader {\r", "originalCommit": "455d0b54367731e384c7b98f93fbb30c8b565360", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2NDczOA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449264738", "bodyText": "That doesn't read the whole file twice", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T21:03:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2NDA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2Njg3OA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449266878", "bodyText": "https://stackoverflow.com/questions/14274259/read-csv-with-scanner/24950812#24950812", "author": "andriikovalov-dlr", "createdAt": "2020-07-02T21:08:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2NDA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMzEwMg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449313102", "bodyText": "Guess, I have to agree... My CsvReader is really not at all standard compliant...", "author": "franzTobiasDLR", "createdAt": "2020-07-02T23:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2NDA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgxNjE0NA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r449816144", "bodyText": "I'm using apache commons csv parser now ;) And updated it to not read the file multiple times", "author": "franzTobiasDLR", "createdAt": "2020-07-05T00:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2NDA1OQ=="}], "type": "inlineReview"}, {"oid": "17b53e5e62a7a9a662b3cbbba99d35911ad7bd43", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/17b53e5e62a7a9a662b3cbbba99d35911ad7bd43", "message": "Applied code improvements suggested in review - (Task #216)", "committedDate": "2020-07-03T01:16:33Z", "type": "commit"}, {"oid": "67ebc18745145d06d702363a6ae97ea1308b89ec", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/67ebc18745145d06d702363a6ae97ea1308b89ec", "message": "Merge remote-tracking branch 'origin/development' into feature/task_216-Add_CSV_import_of_a_r", "committedDate": "2020-07-03T08:00:44Z", "type": "commit"}, {"oid": "ebbaba724fc66fe4b0012588bc9f2fcc9f0fd449", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/ebbaba724fc66fe4b0012588bc9f2fcc9f0fd449", "message": "Apply further suggestions from review - (Task #216)", "committedDate": "2020-07-03T08:59:14Z", "type": "commit"}, {"oid": "0770cb96c67875198b167ef405863eb5e8e1e8de", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/0770cb96c67875198b167ef405863eb5e8e1e8de", "message": "Merge branch 'feature/task_216-Add_CSV_requirement_import' of https://github.com/virtualsatellite/VirtualSatellite4-Core.git into feature/task_216-Add_CSV_requirement_import", "committedDate": "2020-07-03T08:59:38Z", "type": "commit"}, {"oid": "869fccba012e49d68f30e0b356eba827bf75890d", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/869fccba012e49d68f30e0b356eba827bf75890d", "message": "Extract filling repeated values to a new method - (Task #216)", "committedDate": "2020-07-03T12:17:09Z", "type": "commit"}, {"oid": "f244a79540f381749c1dd5ca4bf9e854b445c82b", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/f244a79540f381749c1dd5ca4bf9e854b445c82b", "message": "Add external lib for csv handling - (Task #216)", "committedDate": "2020-07-03T12:20:44Z", "type": "commit"}, {"oid": "6fe88aa68a47536ba137165bfcf30de273f942d7", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/6fe88aa68a47536ba137165bfcf30de273f942d7", "message": "Add first version of import with external lib - (Task #216)", "committedDate": "2020-07-04T22:08:27Z", "type": "commit"}, {"oid": "6d677aee32f623c2d87de2fc59ca1317678869b2", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/6d677aee32f623c2d87de2fc59ca1317678869b2", "message": "Remove wrong test case", "committedDate": "2020-07-04T22:23:56Z", "type": "commit"}, {"oid": "a0040a6053cc0743099d1732ae41be4ac5f6f761", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/a0040a6053cc0743099d1732ae41be4ac5f6f761", "message": "Decouple parsing from reading reqs - (Task #216)", "committedDate": "2020-07-04T23:29:04Z", "type": "commit"}, {"oid": "bcedd2251c8bc53f54bf3bb9305f890237219877", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/bcedd2251c8bc53f54bf3bb9305f890237219877", "message": "Rename CSV importer to importer - (Task #216)", "committedDate": "2020-07-05T00:13:08Z", "type": "commit"}, {"oid": "763bd896cef43bc69581c7977522b154f2a74d65", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/763bd896cef43bc69581c7977522b154f2a74d65", "message": "Only import req attributes with named column - (Task #216)", "committedDate": "2020-07-05T00:13:37Z", "type": "commit"}, {"oid": "398bc4741f27843c89b6a071fb3c3a97bce3108d", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/398bc4741f27843c89b6a071fb3c3a97bce3108d", "message": "Some minor refactorings - (Task #216)", "committedDate": "2020-07-05T00:44:39Z", "type": "commit"}, {"oid": "a3e0b490b952df23fe8709a2818cefbfebd7ef39", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/a3e0b490b952df23fe8709a2818cefbfebd7ef39", "message": "Fix spot bugs warnings - (Task #216)", "committedDate": "2020-07-05T22:00:01Z", "type": "commit"}, {"oid": "427e2a8ae7bec03d6c28158c03dde65c9148a521", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/427e2a8ae7bec03d6c28158c03dde65c9148a521", "message": "Import lib to req test fragement - (Task #216)", "committedDate": "2020-07-05T22:03:35Z", "type": "commit"}, {"oid": "9b6a2a009c995a885085ad496756db573e2a7de1", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/9b6a2a009c995a885085ad496756db573e2a7de1", "message": "Some lib configuration fixes - (Task #216)", "committedDate": "2020-07-05T23:19:04Z", "type": "commit"}, {"oid": "a9ed0d0242ff67be417e3f43f3098f96a09cf536", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/a9ed0d0242ff67be417e3f43f3098f96a09cf536", "message": "Explictly close reader after importing CSV - (Task #216)", "committedDate": "2020-07-05T23:19:39Z", "type": "commit"}, {"oid": "acc9360bca6cedbbe78513975bebd48974d682bc", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/acc9360bca6cedbbe78513975bebd48974d682bc", "message": "Improve test coverage of reader - (Task #216)", "committedDate": "2020-07-06T00:45:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyNzcxNA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450027714", "bodyText": "It kind of feels misleading that we allow seperator to be any string but only use the first character to actually do the separation.", "author": "SaMuellerDLR", "createdAt": "2020-07-06T07:17:40Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvFileReader.java", "diffHunk": "@@ -52,21 +57,57 @@ public CsvFileReader() {\n \t * @param dataEndLine the number of the last data line (starting from 0)\r\n \t */\r\n \tpublic CsvFileReader(String separator, int headerLine, int dataStartLine, int dataEndLine) {\r\n-\t\tthis.separator = separator + REGEX_ESCAPE_SPLIT;\r\n+\t\tthis.separator = separator;\r\n \t\tthis.headerLine = headerLine;\r\n \t\tthis.dataStartLine = dataStartLine;\r\n \t\tthis.dataEndLine = dataEndLine;\r\n \t}\r\n \t\r\n+\t/**\r\n+\t * Parse the given CSV file\r\n+\t * @param filePath the path of the file as string\r\n+\t * @throws IOException throws an exception if the file could not be loaded\r\n+\t */\r\n+\tpublic boolean parseFile(String filePath) {\r\n+\t\tPath csvFilePath = Paths.get(filePath);\r\n+\t\ttry {\r\n+\t\t\tfr = new FileReader(csvFilePath.toFile());\r\n+\t\t\trecords = CSVFormat.EXCEL.withDelimiter(getSeparator().charAt(0)).parse(fr);\r", "originalCommit": "acc9360bca6cedbbe78513975bebd48974d682bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyOTM3Mg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450029372", "bodyText": "I dont see a RequirementHelperTest :D", "author": "SaMuellerDLR", "createdAt": "2020-07-06T07:21:23Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/util/RequirementHelper.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.util;\r\n+\r\n+/**\r\n+ * Helper class for the import of requirements\r\n+ *\r\n+ */\r\n+public class RequirementHelper {\r", "originalCommit": "acc9360bca6cedbbe78513975bebd48974d682bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAyOTU1NQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450029555", "bodyText": "Some superfluous whitespace.", "author": "SaMuellerDLR", "createdAt": "2020-07-06T07:21:47Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/util/RequirementHelper.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.util;\r\n+\r\n+/**\r\n+ * Helper class for the import of requirements\r\n+ *\r\n+ */\r\n+public class RequirementHelper {\r\n+\t\r\n+\t/**\r\n+\t * Clean the name of an entity by removing all invalid chars\r\n+\t * \r\n+\t * @param rawName the name to be cleaned\r\n+\t * @return the clean name \r\n+\t */\r\n+\tpublic String cleanEntityName(String rawName) {\r\n+\t\treturn rawName.replaceAll(\" \", \"\").replaceAll(\"-\", \"\").replaceAll(\"_\", \"\");\r\n+\t}\r\n+\t\r", "originalCommit": "acc9360bca6cedbbe78513975bebd48974d682bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8b6c23870513f6d1fc28d5e5dc6680e63bb05f54", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/8b6c23870513f6d1fc28d5e5dc6680e63bb05f54", "message": "Add test for requirement helper - (Task #216)", "committedDate": "2020-07-06T07:44:38Z", "type": "commit"}, {"oid": "5ec9d86c048a891c38f63ad395f2d11272d0db24", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/5ec9d86c048a891c38f63ad395f2d11272d0db24", "message": "Change seperator type to char - (Task #216)", "committedDate": "2020-07-06T08:11:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0MDU4NA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450140584", "bodyText": "Im missing the registration of this class in the AllTests. Though maybe I am somehow overlooking it?", "author": "SaMuellerDLR", "createdAt": "2020-07-06T10:50:38Z", "path": "de.dlr.sc.virsat.model.extension.requirements.test/src/de/dlr/sc/virsat/model/extension/requirements/util/RequirementHelperTest.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.util;\r\n+\r\n+import static org.junit.Assert.assertEquals;\r\n+\r\n+import org.junit.Test;\r\n+\r\n+/**\r\n+ * Test class for the requirements helper\r\n+ *\r\n+ */\r\n+public class RequirementHelperTest {\r", "originalCommit": "5ec9d86c048a891c38f63ad395f2d11272d0db24", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8a5a3b565e5e0d171bad11fd20b5a72d19b5819b", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/8a5a3b565e5e0d171bad11fd20b5a72d19b5819b", "message": "Added missing registration of new test class - (Task #216)", "committedDate": "2020-07-06T11:27:15Z", "type": "commit"}, {"oid": "f35211b4fccedc57fede9db2d5c17cd12d18c378", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/f35211b4fccedc57fede9db2d5c17cd12d18c378", "message": "Add csv lib to external lib feature - (Task #216)", "committedDate": "2020-07-06T12:03:35Z", "type": "commit"}, {"oid": "3d323a346c4af1169174822e16d0c467670abce4", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/3d323a346c4af1169174822e16d0c467670abce4", "message": "Fix test registration for helper class - (Task #216)", "committedDate": "2020-07-06T15:05:24Z", "type": "commit"}, {"oid": "17e78dde695f3ff237cc6e9be2bb6a00a668ed4e", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/17e78dde695f3ff237cc6e9be2bb6a00a668ed4e", "message": "Update about html file in external lib project - (Task #216)", "committedDate": "2020-07-06T15:10:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE3ODg2OA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450178868", "bodyText": "RequirementHelperTest?", "author": "andriikovalov-dlr", "createdAt": "2020-07-06T12:14:02Z", "path": "de.dlr.sc.virsat.model.extension.requirements.test/src/de/dlr/sc/virsat/model/extension/requirements/test/AllTests.java", "diffHunk": "@@ -30,8 +31,9 @@\n \r\n @SuiteClasses({\t\r\n \tCsvFileReaderTest.class,\r\n-\tCsvRequirementsImporterTest.class,\r\n-\tInitializeRequirementCommandTest.class\r\n+\tRequirementsImporterTest.class,\r\n+\tInitializeRequirementCommandTest.class,\r\n+\tRequirementHelper.class\r", "originalCommit": "f35211b4fccedc57fede9db2d5c17cd12d18c378", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIyNjk4NA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450226984", "bodyText": "Why are we creating two different bean objects instead of something like\nreqType = new RequirementType(selection);\ntypeReviewPage.setInput(csvHeader, reqType);", "author": "andriikovalov-dlr", "createdAt": "2020-07-06T13:39:44Z", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/wizard/CsvFileReqTypeSelectionPage.java", "diffHunk": "@@ -187,59 +183,57 @@ public boolean isSelectionValid() {\n \t\treturn FILE_EXTENSIONS;\r\n \t}\r\n \r\n-\t/*\r\n-\t * (non-Javadoc)\r\n-\t * \r\n-\t * @see de.dlr.sc.virsat.uiengine.ui.wizard.AImportExportPage#isComplete()\r\n-\t */\r\n \t@Override\r\n \tpublic boolean isComplete() {\r\n \r\n-\t\tif (isDestinationSelected && isCurrentPage()) {\r\n-\t\t\tif (!headerNumberField.getText().equals(\"\") & !seperatorField.getText().equals(\"\") \r\n-\t\t\t\t& !dataNumberStartField.getText().equals(\"\")) {\r\n-\r\n-\t\t\t\tfinal String destination = getDestination();\r\n-\t\r\n-\t\t\t\tif (isSelectionValid()) {\r\n-\t\t\t\t\tCategoryAssignment selection = (CategoryAssignment) getSelection();\r\n-\t\t\t\t\tRepository repository = VirSatResourceSet.getVirSatResourceSet(selection).getRepository();\r\n-\t\t\t\t\tActiveConceptHelper activeConceptHelper = new ActiveConceptHelper(repository);\r\n-\t\t\t\t\tConcept activeReqConcept = activeConceptHelper.getConcept(de.dlr.sc.virsat.model.extension.requirements.Activator.getPluginId());\r\n+\t\tif (isDestinationSelected \r\n+\t\t\t\t&& isCurrentPage() \r\n+\t\t\t\t&& !headerNumberField.getText().equals(\"\")\r\n+\t\t\t\t&& seperatorField.getText().length() == 1   //Only allow exactly one char\r\n+\t\t\t\t&& !dataNumberStartField.getText().equals(\"\")\r\n+\t\t\t\t&& isSelectionValid()) {\r\n+\r\n+\t\t\tCategoryAssignment selection = (CategoryAssignment) getSelection();\r\n+\t\t\tRepository repository = VirSatResourceSet.getVirSatResourceSet(selection).getRepository();\r\n+\t\t\tActiveConceptHelper activeConceptHelper = new ActiveConceptHelper(repository);\r\n+\t\t\tConcept activeReqConcept = activeConceptHelper\r\n+\t\t\t\t\t.getConcept(de.dlr.sc.virsat.model.extension.requirements.Activator.getPluginId());\r\n+\t\t\t\r\n+\t\t\t// Configure CSV reader\r\n+\t\t\tfinal String destination = getDestination();\r\n+\t\t\tCsvFileReader reader = getWizard().getReader();\r\n+\t\t\treader.setSeparator(getSeparator());\r\n+\t\t\treader.setHeaderLine(getHeaderLineNumber());\r\n+\t\t\t\r\n+\t\t\t//Do the parsing\r\n+\t\t\tif (!reader.parseFile(destination)) {\r\n+\t\t\t\tStatus status = new Status(Status.ERROR, Activator.getPluginId(),\r\n+\t\t\t\t\t\t\"CSVImportWizard: Failed to perform parsing of CSV file!\");\r\n+\t\t\t\tStatusManager.getManager().handle(status, StatusManager.LOG | StatusManager.SHOW);\r\n+\t\t\t\treturn false;\r\n+\t\t\t} \r\n \t\t\t\r\n-\t\t\t\t\ttry {\r\n-\t\t\t\t\t\twizard.getReader().setSeparator(getSeparator());\r\n-\t\t\t\t\t\twizard.getReader().setHeaderLine(getHeaderLineNumber());\r\n-\t\t\t\t\t\tcsvHeader = wizard.getReader().readCsvHeadline(destination);\r\n-\t\t\t\t\t} catch (IOException e) {\r\n-\t\t\t\t\t\tStatus status = new Status(Status.ERROR, Activator.getPluginId(),\r\n-\t\t\t\t\t\t\t\t\"CatiaImportWizard: Failed to perform import! Selected file not valid!\", e);\r\n-\t\t\t\t\t\tStatusManager.getManager().handle(status, StatusManager.LOG | StatusManager.SHOW);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tif (selection.getType().getFullQualifiedName().equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME)) {\r\n-\t\t\t\t\t\ttypeReviewPage.setInput(csvHeader, new RequirementType(selection));\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tif (selection.getType().getFullQualifiedName().equals(RequirementsConfiguration.FULL_QUALIFIED_CATEGORY_NAME)) {\r\n-\t\t\t\t\t\treqType = wizard.getImporter().prepareRequirementType(activeReqConcept, csvHeader);\r\n-\t\t\t\t\t\ttypeReviewPage.setInput(csvHeader, reqType);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\t\treturn true;\r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n+\t\t\tcsvHeader = reader.readCsvHeadline();\r\n+\t\t\tif (selection.getType().getFullQualifiedName().equals(RequirementType.FULL_QUALIFIED_CATEGORY_NAME)) {\r\n+\t\t\t\ttypeReviewPage.setInput(csvHeader, new RequirementType(selection));\r", "originalCommit": "f35211b4fccedc57fede9db2d5c17cd12d18c378", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwNTY2OA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450505668", "bodyText": "Because we want differnt behavior depending on what kind of element was selected. If a configration container was selcted then we want our importer to create the type for us... Then selection is not even of type RequirementsType... So we cannot create a bean of this type", "author": "franzTobiasDLR", "createdAt": "2020-07-06T22:10:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIyNjk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY1NzIzMQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450657231", "bodyText": "Sure, I understand this, I mean when the selection is RequirementType, we are creating two different beans on the same underlying CA (which is a selection).\nShall we maybe move this line typeReviewPage.setInput(csvHeader, reqType); after the ifs?", "author": "andriikovalov-dlr", "createdAt": "2020-07-07T07:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIyNjk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY5MjA2NQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450692065", "bodyText": "Ah yes, didn't see that", "author": "franzTobiasDLR", "createdAt": "2020-07-07T08:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIyNjk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI4NzU5OQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450287599", "bodyText": "This may forward an iterator one line which could lead to skipping the first line of contents, an additional test case would be nice, where we read the header and then the contents", "author": "andriikovalov-dlr", "createdAt": "2020-07-06T15:07:20Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvFileReader.java", "diffHunk": "@@ -51,22 +56,58 @@ public CsvFileReader() {\n \t * @param dataStartLine the number of the first data line (starting from 0)\r\n \t * @param dataEndLine the number of the last data line (starting from 0)\r\n \t */\r\n-\tpublic CsvFileReader(String separator, int headerLine, int dataStartLine, int dataEndLine) {\r\n-\t\tthis.separator = separator + REGEX_ESCAPE_SPLIT;\r\n+\tpublic CsvFileReader(char separator, int headerLine, int dataStartLine, int dataEndLine) {\r\n+\t\tthis.separator = separator;\r\n \t\tthis.headerLine = headerLine;\r\n \t\tthis.dataStartLine = dataStartLine;\r\n \t\tthis.dataEndLine = dataEndLine;\r\n \t}\r\n \t\r\n+\t/**\r\n+\t * Parse the given CSV file\r\n+\t * @param filePath the path of the file as string\r\n+\t * @throws IOException throws an exception if the file could not be loaded\r\n+\t */\r\n+\tpublic boolean parseFile(String filePath) {\r\n+\t\tPath csvFilePath = Paths.get(filePath);\r\n+\t\ttry {\r\n+\t\t\tfr = new FileReader(csvFilePath.toFile());\r\n+\t\t\trecords = CSVFormat.EXCEL.withDelimiter(getSeparator()).parse(fr);\r\n+\t\t} catch (IOException e) {\r\n+\t\t\tActivator.getDefault().getLog().error(\"Failed to open file ti import\", e);\r\n+\t\t\treturn false;\r\n+\t\t} \r\n+\t\t\r\n+\t\treturn true;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Close the file stream of the current CSV file\r\n+\t * \r\n+\t * @return true if the file could be closed properly, false otherwise\r\n+\t */\r\n+\tpublic boolean closeFile() {\r\n+\t\tif (fr == null) {\r\n+\t\t\treturn false;\r\n+\t\t} \r\n+\t\ttry {\r\n+\t\t\tfr.close();\r\n+\t\t} catch (IOException e) {\r\n+\t\t\tActivator.getDefault().getLog().error(\"Failed to close file to import\", e);\r\n+\t\t\treturn false;\r\n+\t\t}\r\n+\t\treturn true;\r\n+\t}\r\n+\t\r\n \t/**\r\n \t * Read the headline of CSV file\r\n \t * \r\n \t * @param filePath the path to the CSV file\r\n \t * @return the list of columns\r\n \t * @throws IOException throws exception if file could not be read\r\n \t */\r\n-\tpublic List<String> readCsvHeadline(String filePath) throws IOException {\r\n-\t\treturn readCsvFile(filePath, headerLine, headerLine).get(0);\r\n+\tpublic List<String> readCsvHeadline() {\r", "originalCommit": "f35211b4fccedc57fede9db2d5c17cd12d18c378", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwNjE3OA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450506178", "bodyText": "Changed implementation again to parsing the file with every read to reset the iterator", "author": "franzTobiasDLR", "createdAt": "2020-07-06T22:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI4NzU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMwMDMwMw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450300303", "bodyText": "This looks like a potential infinite loop if your line is 0 and the first column is empty", "author": "andriikovalov-dlr", "createdAt": "2020-07-06T15:26:06Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/RequirementsImporter.java", "diffHunk": "@@ -137,15 +126,39 @@ public CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<S\n \r\n \t\t// Create a requirement type for the import\r\n \t\tCompoundCommand importCommand = new CompoundCommand();\r\n-\t\tcustomizeReqTypeFromData(nonPersistedType, csvContentMatrix, attributeMapping);\r\n-\t\tRequirementType reqType = createReqType(importCommand, newImportTypeContainer, nonPersistedType);\r\n-\r\n-\t\timportCommand.append(\r\n-\t\t\t\tloadRequirements(editingDomain, csvContentMatrix, targetSpecificationList, attributeMapping, reqType));\r\n+\t\tfillEnumAttributes(nonPersistedType, csvContentMatrix, attributeMapping);\r\n+\t\timportCommand.append(newImportTypeContainer.getTypeDefinitions().add(editingDomain, nonPersistedType));\r\n+\t\timportCommand.append(loadRequirements(editingDomain, csvContentMatrix, targetSpecificationList, attributeMapping, nonPersistedType));\r\n \r\n \t\treturn importCommand;\r\n \t}\r\n \r\n+\t/**\r\n+\t * In case the first columns of data are empty, data from the previous data line have to be repeated. This method\r\n+\t * then fills these values into the current line\r\n+\t * \r\n+\t * @param contentMatrix the matrix of requirements data\r\n+\t * @param attributeMapping the mapping of requirements\r\n+\t * @param lineNumber the current line number that is supposed to be filled up\r\n+\t * @param requirement the current requirement data\r\n+\t */\r\n+\tprivate void addRepeatedValuesFromPreviousLine(List<List<String>> contentMatrix,\r\n+\t\t\tMap<Integer, RequirementAttribute> attributeMapping, int lineNumber, List<String> requirement) {\r\n+\t\t//If the first columns of a requirement are empty then values from previous lines are used\r\n+\t\tString attribute = requirement.get(0);\r\n+\t\twhile (attribute.equals(\"\")) {\r\n+\t\t\tif (lineNumber > 0) {\r", "originalCommit": "f35211b4fccedc57fede9db2d5c17cd12d18c378", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMwNDk5NA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450304994", "bodyText": "I suggest to move the if out of the while, and do an indexed for with break instead of a while", "author": "andriikovalov-dlr", "createdAt": "2020-07-06T15:32:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMwMDMwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMyNTExNg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450325116", "bodyText": "Or a while with an index variable", "author": "andriikovalov-dlr", "createdAt": "2020-07-06T16:04:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMwMDMwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMyNTkwNg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450325906", "bodyText": "Or move this logic of filling empty cells in identifier columns into a separate method like the one for gathering enum values", "author": "andriikovalov-dlr", "createdAt": "2020-07-06T16:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMwMDMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMxMzAyNA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450313024", "bodyText": "Another potential for an infinite loop - say you have first two columns empty, and the first is not Identifier, so you don't change it, and on the next column requirement.indexOf(attribute) will give you the first column again, so I strongly recommend an indexed for instead of calling indexOf", "author": "andriikovalov-dlr", "createdAt": "2020-07-06T15:45:05Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/RequirementsImporter.java", "diffHunk": "@@ -137,15 +126,39 @@ public CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<S\n \r\n \t\t// Create a requirement type for the import\r\n \t\tCompoundCommand importCommand = new CompoundCommand();\r\n-\t\tcustomizeReqTypeFromData(nonPersistedType, csvContentMatrix, attributeMapping);\r\n-\t\tRequirementType reqType = createReqType(importCommand, newImportTypeContainer, nonPersistedType);\r\n-\r\n-\t\timportCommand.append(\r\n-\t\t\t\tloadRequirements(editingDomain, csvContentMatrix, targetSpecificationList, attributeMapping, reqType));\r\n+\t\tfillEnumAttributes(nonPersistedType, csvContentMatrix, attributeMapping);\r\n+\t\timportCommand.append(newImportTypeContainer.getTypeDefinitions().add(editingDomain, nonPersistedType));\r\n+\t\timportCommand.append(loadRequirements(editingDomain, csvContentMatrix, targetSpecificationList, attributeMapping, nonPersistedType));\r\n \r\n \t\treturn importCommand;\r\n \t}\r\n \r\n+\t/**\r\n+\t * In case the first columns of data are empty, data from the previous data line have to be repeated. This method\r\n+\t * then fills these values into the current line\r\n+\t * \r\n+\t * @param contentMatrix the matrix of requirements data\r\n+\t * @param attributeMapping the mapping of requirements\r\n+\t * @param lineNumber the current line number that is supposed to be filled up\r\n+\t * @param requirement the current requirement data\r\n+\t */\r\n+\tprivate void addRepeatedValuesFromPreviousLine(List<List<String>> contentMatrix,\r\n+\t\t\tMap<Integer, RequirementAttribute> attributeMapping, int lineNumber, List<String> requirement) {\r\n+\t\t//If the first columns of a requirement are empty then values from previous lines are used\r\n+\t\tString attribute = requirement.get(0);\r\n+\t\twhile (attribute.equals(\"\")) {\r\n+\t\t\tif (lineNumber > 0) {\r\n+\t\t\t\tint currentAttributeIndex = requirement.indexOf(attribute);\r\n+\t\t\t\tString repeatedValue = contentMatrix.get(lineNumber - 1).get(currentAttributeIndex);\r\n+\t\t\t\tif (attributeMapping.get(currentAttributeIndex) != null && attributeMapping.get(currentAttributeIndex).getType().equals(RequirementAttribute.TYPE_Identifier_NAME)) {\r", "originalCommit": "f35211b4fccedc57fede9db2d5c17cd12d18c378", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM0NzA3MQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450347071", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tPath csvFilePath = Paths.get(inputPath.toString() + File.separator + JSON_FILE_NAME);\n          \n          \n            \n            \t\tPath csvFilePath = Paths.get(inputPath.toString(), JSON_FILE_NAME);", "author": "andriikovalov-dlr", "createdAt": "2020-07-06T16:39:33Z", "path": "de.dlr.sc.virsat.model.extension.requirements.test/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvFileReaderTest.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.io.File;\r\n+import java.io.IOException;\r\n+import java.nio.file.Files;\r\n+import java.nio.file.Path;\r\n+import java.nio.file.Paths;\r\n+import java.util.Arrays;\r\n+import java.util.List;\r\n+\r\n+import org.junit.Test;\r\n+\r\n+/**\r\n+ * Test for the CSV file reader\r\n+ *\r\n+ */\r\n+public class CsvFileReaderTest {\r\n+\t\r\n+\tprivate static final String HEADER_1 = \"Header1\";\r\n+\tprivate static final String HEADER_2 = \"Header2\";\r\n+\tprivate static final String HEADER_3 = \"Header3\";\r\n+\t\r\n+\tprivate static final String REQ_ATT_1 = \"att1\";\r\n+\tprivate static final String REQ_ATT_2 = \"att2\";\r\n+\tprivate static final String REQ_ATT_3 = \"att3\";\r\n+\t\r\n+\tprivate static final int HEADER_LINE = 0;\r\n+\tprivate static final int START_LINE = 1;\r\n+\tprivate static final int END_LINE = 2;\r\n+\t\r\n+\tprivate static final char SEPERATOR = ';';\r\n+\t\r\n+\tprivate static final String JSON_FILE_NAME = \"dummy.csv\";\r\n+\t\r\n+\t@Test\r\n+\tpublic void testReadCsvFile() throws IOException {\r\n+\t\t\r\n+\t\tPath inputPath = Files.createTempDirectory(\"csvTest\");\r\n+\t\tPath csvFilePath = Paths.get(inputPath.toString() + File.separator + JSON_FILE_NAME);\r\n+\t\t\r\n+\t\tList<String> csvContent = Arrays.asList(HEADER_1 + SEPERATOR + HEADER_2 + SEPERATOR + HEADER_3,\r\n+\t\t\t\tREQ_ATT_1 + SEPERATOR + REQ_ATT_2 + SEPERATOR + REQ_ATT_3);\r\n+\t\t\r\n+\t\tFiles.write(csvFilePath, csvContent);\r\n+\t\t\r\n+\t\tCsvFileReader reader = new CsvFileReader();\r\n+\t\tassertEquals(\"Default seperator should be semicolon\", SEPERATOR, reader.getSeparator());\r\n+\t\t\r\n+\t\tassertTrue(\"File should exist\", reader.parseFile(csvFilePath.toString()));\r\n+\t\tList<List<String>> importedCsvContent = reader.readCsvFile(0, -1);\r\n+\t\tassertTrue(\"File should be closed properly\", reader.closeFile());\r\n+\t\t\r\n+\t\tassertEquals(\"Number of lines correct\", 2, importedCsvContent.size());\r\n+\t\t\r\n+\t\tList<String> header = importedCsvContent.get(0);\r\n+\t\tassertEquals(\"Header correct\", header.get(0), HEADER_1);\r\n+\t\tassertEquals(\"Header correct\", header.get(1), HEADER_2);\r\n+\t\tassertEquals(\"Header correct\", header.get(2), HEADER_3);\r\n+\t\t\r\n+\t\tList<String> reqLine = importedCsvContent.get(1);\r\n+\t\tassertEquals(\"Req att correct\", reqLine.get(0), REQ_ATT_1);\r\n+\t\tassertEquals(\"Req att correct\", reqLine.get(1), REQ_ATT_2);\r\n+\t\tassertEquals(\"Req att correct\", reqLine.get(2), REQ_ATT_3);\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testReadCsvHeadline() throws IOException {\r\n+\t\t\r\n+\t\tPath inputPath = Files.createTempDirectory(\"csvTest\");\r\n+\t\tPath csvFilePath = Paths.get(inputPath.toString() + File.separator + JSON_FILE_NAME);\r", "originalCommit": "f35211b4fccedc57fede9db2d5c17cd12d18c378", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM0OTQ4NA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450349484", "bodyText": "Why not create temp files instead of temp directories?", "author": "andriikovalov-dlr", "createdAt": "2020-07-06T16:43:31Z", "path": "de.dlr.sc.virsat.model.extension.requirements.test/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvFileReaderTest.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.csv;\r\n+\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.io.File;\r\n+import java.io.IOException;\r\n+import java.nio.file.Files;\r\n+import java.nio.file.Path;\r\n+import java.nio.file.Paths;\r\n+import java.util.Arrays;\r\n+import java.util.List;\r\n+\r\n+import org.junit.Test;\r\n+\r\n+/**\r\n+ * Test for the CSV file reader\r\n+ *\r\n+ */\r\n+public class CsvFileReaderTest {\r\n+\t\r\n+\tprivate static final String HEADER_1 = \"Header1\";\r\n+\tprivate static final String HEADER_2 = \"Header2\";\r\n+\tprivate static final String HEADER_3 = \"Header3\";\r\n+\t\r\n+\tprivate static final String REQ_ATT_1 = \"att1\";\r\n+\tprivate static final String REQ_ATT_2 = \"att2\";\r\n+\tprivate static final String REQ_ATT_3 = \"att3\";\r\n+\t\r\n+\tprivate static final int HEADER_LINE = 0;\r\n+\tprivate static final int START_LINE = 1;\r\n+\tprivate static final int END_LINE = 2;\r\n+\t\r\n+\tprivate static final char SEPERATOR = ';';\r\n+\t\r\n+\tprivate static final String JSON_FILE_NAME = \"dummy.csv\";\r\n+\t\r\n+\t@Test\r\n+\tpublic void testReadCsvFile() throws IOException {\r\n+\t\t\r\n+\t\tPath inputPath = Files.createTempDirectory(\"csvTest\");\r\n+\t\tPath csvFilePath = Paths.get(inputPath.toString() + File.separator + JSON_FILE_NAME);\r\n+\t\t\r\n+\t\tList<String> csvContent = Arrays.asList(HEADER_1 + SEPERATOR + HEADER_2 + SEPERATOR + HEADER_3,\r\n+\t\t\t\tREQ_ATT_1 + SEPERATOR + REQ_ATT_2 + SEPERATOR + REQ_ATT_3);\r\n+\t\t\r\n+\t\tFiles.write(csvFilePath, csvContent);\r\n+\t\t\r\n+\t\tCsvFileReader reader = new CsvFileReader();\r\n+\t\tassertEquals(\"Default seperator should be semicolon\", SEPERATOR, reader.getSeparator());\r\n+\t\t\r\n+\t\tassertTrue(\"File should exist\", reader.parseFile(csvFilePath.toString()));\r\n+\t\tList<List<String>> importedCsvContent = reader.readCsvFile(0, -1);\r\n+\t\tassertTrue(\"File should be closed properly\", reader.closeFile());\r\n+\t\t\r\n+\t\tassertEquals(\"Number of lines correct\", 2, importedCsvContent.size());\r\n+\t\t\r\n+\t\tList<String> header = importedCsvContent.get(0);\r\n+\t\tassertEquals(\"Header correct\", header.get(0), HEADER_1);\r\n+\t\tassertEquals(\"Header correct\", header.get(1), HEADER_2);\r\n+\t\tassertEquals(\"Header correct\", header.get(2), HEADER_3);\r\n+\t\t\r\n+\t\tList<String> reqLine = importedCsvContent.get(1);\r\n+\t\tassertEquals(\"Req att correct\", reqLine.get(0), REQ_ATT_1);\r\n+\t\tassertEquals(\"Req att correct\", reqLine.get(1), REQ_ATT_2);\r\n+\t\tassertEquals(\"Req att correct\", reqLine.get(2), REQ_ATT_3);\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testReadCsvHeadline() throws IOException {\r\n+\t\t\r\n+\t\tPath inputPath = Files.createTempDirectory(\"csvTest\");\r\n+\t\tPath csvFilePath = Paths.get(inputPath.toString() + File.separator + JSON_FILE_NAME);\r\n+\t\t\r\n+\t\tList<String> csvContent = Arrays.asList(HEADER_1 + SEPERATOR + HEADER_2 + SEPERATOR + HEADER_3,\r\n+\t\t\t\tREQ_ATT_1 + SEPERATOR + REQ_ATT_2 + SEPERATOR + REQ_ATT_3);\r\n+\t\t\r\n+\t\tFiles.write(csvFilePath, csvContent);\r\n+\t\t\r\n+\t\t// Configure reader via setters\r\n+\t\tCsvFileReader reader = new CsvFileReader();\r\n+\t\treader.setSeparator(SEPERATOR);\r\n+\t\treader.setHeaderLine(HEADER_LINE);\r\n+\t\treader.setDataStartLine(START_LINE);\r\n+\t\treader.setDataEndLine(END_LINE);\r\n+\t\t\r\n+\t\tassertEquals(\"File section set correctly\", HEADER_LINE, reader.getHeaderLine());\r\n+\t\tassertEquals(\"File section set correctly\", START_LINE, reader.getDataStartLine());\r\n+\t\tassertEquals(\"File section set correctly\", END_LINE, reader.getDataEndLine());\r\n+\t\tassertEquals(\"Seperator set correctly\", SEPERATOR, reader.getSeparator());\r\n+\t\t\r\n+\t\treader.parseFile(csvFilePath.toString());\r\n+\t\tList<String> importedCsvHeader = reader.readCsvHeadline();\r\n+\t\treader.closeFile();\r\n+\t\t\r\n+\t\tassertEquals(\"Header correct\", importedCsvHeader.get(0), HEADER_1);\r\n+\t\tassertEquals(\"Header correct\", importedCsvHeader.get(1), HEADER_2);\r\n+\t\tassertEquals(\"Header correct\", importedCsvHeader.get(2), HEADER_3);\r\n+\t\t\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testReadCsvData() throws IOException {\r\n+\t\t\r\n+\t\tPath inputPath = Files.createTempDirectory(\"csvTest\");\r", "originalCommit": "f35211b4fccedc57fede9db2d5c17cd12d18c378", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9dd95080b61ec20dd69d3704c8dbedc884fe7793", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/9dd95080b61ec20dd69d3704c8dbedc884fe7793", "message": "Combine parsing and reading of file - (Task #216)", "committedDate": "2020-07-06T21:54:51Z", "type": "commit"}, {"oid": "df3bb7441cc0b2e7d13ddf3d877139af8bac99dd", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/df3bb7441cc0b2e7d13ddf3d877139af8bac99dd", "message": "Use tmp file instead of tmp folder - (Task #216)", "committedDate": "2020-07-06T22:04:02Z", "type": "commit"}, {"oid": "447dcade0a40ad4d7b0a55413e760c2be34fe488", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/447dcade0a40ad4d7b0a55413e760c2be34fe488", "message": "Some loop handling improvements in importer - (Task #216)", "committedDate": "2020-07-06T22:29:17Z", "type": "commit"}, {"oid": "1d0ce27695e719f85ccdfa62aac2c514c7fe0e2c", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/1d0ce27695e719f85ccdfa62aac2c514c7fe0e2c", "message": "Fix spotbugs error again - (Task #216)", "committedDate": "2020-07-06T22:56:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU0MzU5OQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450543599", "bodyText": "I would strongly recomment using try-with-resources here: https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html\nIt would look like this:\ntry (FileReader fr = new FileReader(csvFilePath.toFile())) {\n...\n}\n\nIt takes care of closing the resource both in case of a failure and a success.", "author": "SaMuellerDLR", "createdAt": "2020-07-07T00:16:37Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/CsvFileReader.java", "diffHunk": "@@ -126,29 +85,35 @@ public boolean closeFile() {\n \t * @param startLine the first line number to read\r\n \t * @param endLine the last line number to read\r\n \t * @return the CSV content as matrix of two lists\r\n+\t * @throws IOException \r\n \t */\r\n-\tpublic List<List<String>> readCsvFile(int startLine, int endLine) {\r\n+\tpublic List<List<String>> readCsvFile(String filePath, int startLine, int endLine) throws IOException {\r\n \t\tList<List<String>> csvContentMatrix = new ArrayList<List<String>>();\r\n-\t\t\r\n-\t\tif (records == null) {\r\n-\t\t\treturn csvContentMatrix;\r\n-\t\t}\r\n-\t\t\r\n-\t\tint lineNumber = 0;\r\n-\t\tfor (CSVRecord record : records) {\r\n-\t\t\tif (lineNumber >= startLine) {\r\n-\t\t\t\tList<String> reqData = new ArrayList<String>();\r\n-\t\t\t\tfor (String att : record) {\r\n-\t\t\t\t\treqData.add(att);\r\n+\t\tPath csvFilePath = Paths.get(filePath);\r\n+\r\n+\t\tFileReader fr = new FileReader(csvFilePath.toFile());\r\n+\t\ttry {\r", "originalCommit": "1d0ce27695e719f85ccdfa62aac2c514c7fe0e2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU0Mzk1Nw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/604#discussion_r450543957", "bodyText": "Duplication of attributeMapping.get(index). Lets put it into a variable.", "author": "SaMuellerDLR", "createdAt": "2020-07-07T00:17:58Z", "path": "de.dlr.sc.virsat.model.extension.requirements/src/de/dlr/sc/virsat/model/extension/requirements/csv/RequirementsImporter.java", "diffHunk": "@@ -144,17 +144,20 @@ public CompoundCommand loadRequirements(EditingDomain editingDomain, List<List<S\n \t */\r\n \tprivate void addRepeatedValuesFromPreviousLine(List<List<String>> contentMatrix,\r\n \t\t\tMap<Integer, RequirementAttribute> attributeMapping, int lineNumber, List<String> requirement) {\r\n-\t\t//If the first columns of a requirement are empty then values from previous lines are used\r\n-\t\tString attribute = requirement.get(0);\r\n-\t\twhile (attribute.equals(\"\")) {\r\n-\t\t\tif (lineNumber > 0) {\r\n-\t\t\t\tint currentAttributeIndex = requirement.indexOf(attribute);\r\n-\t\t\t\tString repeatedValue = contentMatrix.get(lineNumber - 1).get(currentAttributeIndex);\r\n-\t\t\t\tif (attributeMapping.get(currentAttributeIndex) != null && attributeMapping.get(currentAttributeIndex).getType().equals(RequirementAttribute.TYPE_Identifier_NAME)) {\r\n-\t\t\t\t\trepeatedValue += REQ_EXTENSION_IDENTIFIER_PREFIX;\r\n+\t\tif (lineNumber > 0) {\r\n+\t\t\t//If the first columns of a requirement are empty then values from previous lines are used\r\n+\t\t\tfor (int index = 0; index < requirement.size(); index++) {\r\n+\t\t\t\tif (!requirement.get(index).equals(\"\")) {\r\n+\t\t\t\t\tbreak;\r\n \t\t\t\t}\r\n-\t\t\t\trequirement.set(currentAttributeIndex, repeatedValue);\r\n-\t\t\t\tattribute = requirement.get(currentAttributeIndex + 1);\r\n+\t\t\t\t//Get value of last line\r\n+\t\t\t\tString repeatedValueOldLine = contentMatrix.get(lineNumber - 1).get(index);\r\n+\t\t\t\t//If attribute is an index then append extension to make data unique\r\n+\t\t\t\tif (attributeMapping.get(index) != null && attributeMapping.get(index).getType().equals(RequirementAttribute.TYPE_Identifier_NAME)) {\r", "originalCommit": "1d0ce27695e719f85ccdfa62aac2c514c7fe0e2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5674986aaa16a22467fe85ac726ab0021f02f0fb", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/5674986aaa16a22467fe85ac726ab0021f02f0fb", "message": "Use try with resource closeing - (Task #216)", "committedDate": "2020-07-07T07:54:06Z", "type": "commit"}, {"oid": "2518efc9cb688e74b2ecdff3dcc6b15cc093d7ba", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/2518efc9cb688e74b2ecdff3dcc6b15cc093d7ba", "message": "Use variable instead of douplicated get statment - (Task #216)", "committedDate": "2020-07-07T07:56:48Z", "type": "commit"}, {"oid": "d14a17a2387a7241b64a635088590bf47fbc49e5", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/d14a17a2387a7241b64a635088590bf47fbc49e5", "message": "Reuse bean instead of creating two new beans - (Task #216)", "committedDate": "2020-07-07T08:23:13Z", "type": "commit"}]}