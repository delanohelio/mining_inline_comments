{"pr_number": 507, "pr_title": "Adjusting Expression Evaluator in Calculations for Set Functions", "pr_createdAt": "2020-02-27T09:36:36Z", "pr_url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507", "timeline": [{"oid": "0a1692d0047b776a2e3daaedf6a5a40abe25eea2", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/0a1692d0047b776a2e3daaedf6a5a40abe25eea2", "message": "Refactored BeanTreeTraverser - (Task #497)\n\n- generalized Traverser to work with any kind of object not just beans.\nThis is needed as preparation for making it work with pure SEIs as well.\n- Added new functionality to know level of nesting and level of matches.\nWill be needed for set functions in computations\n- Added new test cases\n- Added hamcrest lib to test fragment\n\n---\nTask #497: Adjust CEFX calculations to summarize masses and power across\nempty system elements", "committedDate": "2020-02-24T16:55:42Z", "type": "commit"}, {"oid": "80dfe032193cc5781225cd7f94e92206e0a2228a", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/80dfe032193cc5781225cd7f94e92206e0a2228a", "message": "Added TreeTraverser to Expression Evaluation - (Task #497)\n\n- Now evaluating Set functions on semantic levels rather than technical\nlevels.\n- Fixed VirSatEcoreUtil to use resolve flag in method as intended\n- Added new static variable for infinite nesting\n\n---\nTask #497: Adjust CEFX calculations to summarize masses and power across\nempty system elements", "committedDate": "2020-02-25T10:01:14Z", "type": "commit"}, {"oid": "c34314e9499c8df85204d311ac70f49121a11c1c", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/c34314e9499c8df85204d311ac70f49121a11c1c", "message": "Added test case for checking traverser in evaluator - (Task #497)\n\n- Added test case to check for correct semantic level detection\n- Minor fixes to code to react correctly on comparing matched vs.\nrequired levels of nesting.\n\n---\nTask #497: Adjust CEFX calculations to summarize masses and power across\nempty system elements", "committedDate": "2020-02-25T13:02:40Z", "type": "commit"}, {"oid": "de12f09fddb2e272bd21eb953c96ba2e10232940", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/de12f09fddb2e272bd21eb953c96ba2e10232940", "message": "Minor fixes to expression evaluator - (Task #497)\n\n- Fixed issue with cyclic dependencies when e.g. summarizing properties\nwhich are in the same category as the equation including the\nset-function.\n\n---\nTask #497: Adjust CEFX calculations to summarize masses and power across\nempty system elements", "committedDate": "2020-02-26T13:48:19Z", "type": "commit"}, {"oid": "59a03162bd96812e948e9fa406ed4c84eac6473d", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/59a03162bd96812e948e9fa406ed4c84eac6473d", "message": "Added missing test cases for the Sei Helper - (Task #497)\n\n- A test Case was missing for the get deep children method.\n\n---\nTask #497: Adjust CEFX calculations to summarize masses and power across\nempty system elements", "committedDate": "2020-02-27T12:01:13Z", "type": "commit"}, {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "message": "Adjusted documentation - (Task #497)\n\n- Gave a not ont he emaning of depth.\n\n---\nTask #497: Adjust CEFX calculations to summarize masses and power across\nempty system elements", "committedDate": "2020-02-27T13:12:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU4NTgyMg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385585822", "bodyText": "Would it maybe be sufficient to just check\nif (obj instanceof Result) { Result other = (Result) obj; return matchingLevel == other.matchingLevel && nestingLevel == other.nestingLevel && Objects.equals(sei, other.sei); } else { return false; }\nThat should cover all the cases.", "author": "SaMuellerDLR", "createdAt": "2020-02-28T09:20:26Z", "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+\r\n+import java.util.HashMap;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Objects;\r\n+\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElement;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralFactory;\r\n+\r\n+import static org.hamcrest.Matchers.contains;\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertThat;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+public class TreeTraverserTest {\r\n+\r\n+\tStructuralElement se;\r\n+\t\r\n+\tStructuralElementInstance seiRoot;\r\n+\tStructuralElementInstance seiChild1;\r\n+\tStructuralElementInstance seiChild1Child;\r\n+\tStructuralElementInstance seiChild1ChildChild;\r\n+\tStructuralElementInstance seiChild2;\r\n+\tStructuralElementInstance seiChild2Child;\r\n+\tStructuralElementInstance seiChild2ChildChild;\r\n+\t\r\n+\t@Before\r\n+\tpublic void setUp() throws Exception {\r\n+\t\tStructuralElement se = StructuralFactory.eINSTANCE.createStructuralElement();\r\n+\t\t\r\n+\t\tseiRoot = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\t\r\n+\t\tse.setIsApplicableForAll(true);\r\n+\t\t\r\n+\t\tseiRoot.setType(se);\r\n+\t\tseiChild1.setType(se);\r\n+\t\tseiChild1Child.setType(se);\r\n+\t\tseiChild1ChildChild.setType(se);\r\n+\t\tseiChild2.setType(se);\r\n+\t\tseiChild2Child.setType(se);\r\n+\t\tseiChild2ChildChild.setType(se);\r\n+\t\t\r\n+\t\tseiRoot.getChildren().add(seiChild1);\r\n+\t\tseiRoot.getChildren().add(seiChild2);\r\n+\t\tseiChild1.getChildren().add(seiChild1Child);\r\n+\t\tseiChild2.getChildren().add(seiChild2Child);\r\n+\t\tseiChild1Child.getChildren().add(seiChild1ChildChild);\r\n+\t\tseiChild2Child.getChildren().add(seiChild2ChildChild);\r\n+\t\t\r\n+\t\t// Now set names for the 2 level and for the 3 level,\r\n+\t\t// Try to find them and check if the traverser reacts as expected\r\n+\t\tseiRoot.setName(\"Root\");\r\n+\t\tseiChild1Child.setName(\"ChildOf1\");\r\n+\t\tseiChild2Child.setName(\"ChildOf2\");\r\n+\t\tseiChild1ChildChild.setName(\"DoubleChildOf1\");\r\n+\t\tseiChild2ChildChild.setName(\"DoubleChildOf2\");\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Class to capture the results from the tree traversing\r\n+\t */\r\n+\tclass Result {\r\n+\t\t\r\n+\t\t@Override\r\n+\t\tpublic int hashCode() {\r\n+\t\t\tfinal int prime = 31;\r\n+\t\t\tint result = 1;\r\n+\t\t\tresult = prime * result + Objects.hash(matchingLevel, nestingLevel, sei);\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\t@Override\r\n+\t\tpublic boolean equals(Object obj) {\r\n+\t\t\tif (this == obj) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t} else if (obj == null) {\r", "originalCommit": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0NTE0Mw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r386445143", "bodyText": "Well, the code present is auto coded by the eclipse ide.  The result is basically the same, but there is a difference in performance. Since performance is not an issue in this test case, and in particular not with this object i don't mind changing it.", "author": "PhilMFischer", "createdAt": "2020-03-02T15:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU4NTgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU4NjM1Ng==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385586356", "bodyText": "Can we move these to the top of the Result class so the reader directly knows whats encapsualted by it?", "author": "SaMuellerDLR", "createdAt": "2020-02-28T09:21:35Z", "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+\r\n+import java.util.HashMap;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Objects;\r\n+\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElement;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralFactory;\r\n+\r\n+import static org.hamcrest.Matchers.contains;\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertThat;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+public class TreeTraverserTest {\r\n+\r\n+\tStructuralElement se;\r\n+\t\r\n+\tStructuralElementInstance seiRoot;\r\n+\tStructuralElementInstance seiChild1;\r\n+\tStructuralElementInstance seiChild1Child;\r\n+\tStructuralElementInstance seiChild1ChildChild;\r\n+\tStructuralElementInstance seiChild2;\r\n+\tStructuralElementInstance seiChild2Child;\r\n+\tStructuralElementInstance seiChild2ChildChild;\r\n+\t\r\n+\t@Before\r\n+\tpublic void setUp() throws Exception {\r\n+\t\tStructuralElement se = StructuralFactory.eINSTANCE.createStructuralElement();\r\n+\t\t\r\n+\t\tseiRoot = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\t\r\n+\t\tse.setIsApplicableForAll(true);\r\n+\t\t\r\n+\t\tseiRoot.setType(se);\r\n+\t\tseiChild1.setType(se);\r\n+\t\tseiChild1Child.setType(se);\r\n+\t\tseiChild1ChildChild.setType(se);\r\n+\t\tseiChild2.setType(se);\r\n+\t\tseiChild2Child.setType(se);\r\n+\t\tseiChild2ChildChild.setType(se);\r\n+\t\t\r\n+\t\tseiRoot.getChildren().add(seiChild1);\r\n+\t\tseiRoot.getChildren().add(seiChild2);\r\n+\t\tseiChild1.getChildren().add(seiChild1Child);\r\n+\t\tseiChild2.getChildren().add(seiChild2Child);\r\n+\t\tseiChild1Child.getChildren().add(seiChild1ChildChild);\r\n+\t\tseiChild2Child.getChildren().add(seiChild2ChildChild);\r\n+\t\t\r\n+\t\t// Now set names for the 2 level and for the 3 level,\r\n+\t\t// Try to find them and check if the traverser reacts as expected\r\n+\t\tseiRoot.setName(\"Root\");\r\n+\t\tseiChild1Child.setName(\"ChildOf1\");\r\n+\t\tseiChild2Child.setName(\"ChildOf2\");\r\n+\t\tseiChild1ChildChild.setName(\"DoubleChildOf1\");\r\n+\t\tseiChild2ChildChild.setName(\"DoubleChildOf2\");\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Class to capture the results from the tree traversing\r\n+\t */\r\n+\tclass Result {\r\n+\t\t\r\n+\t\t@Override\r\n+\t\tpublic int hashCode() {\r\n+\t\t\tfinal int prime = 31;\r\n+\t\t\tint result = 1;\r\n+\t\t\tresult = prime * result + Objects.hash(matchingLevel, nestingLevel, sei);\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\t@Override\r\n+\t\tpublic boolean equals(Object obj) {\r\n+\t\t\tif (this == obj) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t} else if (obj == null) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else if (getClass() != obj.getClass()) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else {\r\n+\t\t\t\tResult other = (Result) obj;\r\n+\t\t\t\treturn matchingLevel == other.matchingLevel && nestingLevel == other.nestingLevel && Objects.equals(sei, other.sei);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\t\r\n+\t\tResult(StructuralElementInstance sei, int processedLevel, int matchedLevel) {\r\n+\t\t\tthis.sei = sei;\r\n+\t\t\tthis.nestingLevel = processedLevel;\r\n+\t\t\tthis.matchingLevel = matchedLevel;\r\n+\t\t}\r", "originalCommit": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0NTQ4Nw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r386445487", "bodyText": "yes done.", "author": "PhilMFischer", "createdAt": "2020-03-02T15:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU4NjM1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwMjA0Nw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385602047", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\n          \n          \n            \n             * Interface for plugging different logic into {@link TreeTraverser}", "author": "andriikovalov-dlr", "createdAt": "2020-02-28T09:54:16Z", "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r", "originalCommit": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwNjQ3Mg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385606472", "bodyText": "Let's rename processedLevel to treeLevel", "author": "andriikovalov-dlr", "createdAt": "2020-02-28T10:02:42Z", "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r\n+ * For example for building a tree consisting only of nodes with a certain Category attached\r\n+ * @param <TYPE> The type for which the matcher should apply\r\n+ */\r\n+public interface ITreeTraverserMatcher<TYPE> {\r\n+\r\n+\t/**\r\n+\t * Checks if the passed treeNode bean matches the desired criteria\r\n+\t * @param treeNode node bean to check\r\n+\t * @return true if this node matches, false otherwise\r\n+\t */\r\n+\tboolean isMatching(TYPE treeNode);\r\n+\t\r\n+\t/**\r\n+\t * Processes the found match\r\n+\t * @param treeNode a matching tree node\r\n+\t * @param matchingParent the closest parent of the node that also matches the criteria.\r\n+\t *        Can be null if the node does not have a matching parent\r\n+\t */\r\n+\tvoid processMatch(TYPE treeNode, TYPE matchingParent);\r\n+\t\r\n+\t/**\r\n+\t * This method tells if the children of the current node should be processed or not.\r\n+\t * \r\n+\t * Default behavior is that all children are processed.\r\n+\t * @param treeNode the node of which the children should be processed or not.\r\n+\t * @param isMatching the matching result which the traverser evaluated before.\r\n+\t * @return true in case the children should be processed. false in case not.\r\n+\t */\r\n+\tdefault boolean continueTraverseChildren(TYPE treeNode, boolean isMatching, int processedLevel, int matchedLevel) {\r", "originalCommit": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0NjE3MQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r386446171", "bodyText": "Good suggestion.", "author": "PhilMFischer", "createdAt": "2020-03-02T15:04:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwNjQ3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwNjY2OQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385606669", "bodyText": "Let's also add javadoc for missing parameters", "author": "andriikovalov-dlr", "createdAt": "2020-02-28T10:03:06Z", "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r\n+ * For example for building a tree consisting only of nodes with a certain Category attached\r\n+ * @param <TYPE> The type for which the matcher should apply\r\n+ */\r\n+public interface ITreeTraverserMatcher<TYPE> {\r\n+\r\n+\t/**\r\n+\t * Checks if the passed treeNode bean matches the desired criteria\r\n+\t * @param treeNode node bean to check\r\n+\t * @return true if this node matches, false otherwise\r\n+\t */\r\n+\tboolean isMatching(TYPE treeNode);\r\n+\t\r\n+\t/**\r\n+\t * Processes the found match\r\n+\t * @param treeNode a matching tree node\r\n+\t * @param matchingParent the closest parent of the node that also matches the criteria.\r\n+\t *        Can be null if the node does not have a matching parent\r\n+\t */\r\n+\tvoid processMatch(TYPE treeNode, TYPE matchingParent);\r\n+\t\r\n+\t/**\r\n+\t * This method tells if the children of the current node should be processed or not.\r\n+\t * \r\n+\t * Default behavior is that all children are processed.\r\n+\t * @param treeNode the node of which the children should be processed or not.\r\n+\t * @param isMatching the matching result which the traverser evaluated before.\r\n+\t * @return true in case the children should be processed. false in case not.\r\n+\t */\r\n+\tdefault boolean continueTraverseChildren(TYPE treeNode, boolean isMatching, int processedLevel, int matchedLevel) {\r", "originalCommit": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0Nzk2Nw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r386447967", "bodyText": "It is a bit strange checkstyle is not complaining. but probably since the method is that small, it does not expect a javadoc at all.", "author": "PhilMFischer", "createdAt": "2020-03-02T15:07:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwNjY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUxNTEzMw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r386515133", "bodyText": "Yes, it's just one line, checkstyle doesn't require a javadoc. But since it's an interface method, it's good to have all parameters explained", "author": "andriikovalov-dlr", "createdAt": "2020-03-02T16:49:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwNjY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwODAxNw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385608017", "bodyText": "Let's rename processedLevel to treeLevel", "author": "andriikovalov-dlr", "createdAt": "2020-02-28T10:05:48Z", "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverser.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+/**\r\n+ * Class for traversing a tree of structural element instances and calling\r\n+ * callback functions of a given matcher for matching nodes\r\n+ * @param <TYPE> the type of object the traverser should act on\r\n+ */\r\n+public class TreeTraverser<TYPE> {\r\n+\t\r\n+\tprotected ITreeTraverserMatcher<TYPE> matcher;\r\n+\t\r\n+\t/**\r\n+\t * Traverses the tree starting from the given root\r\n+\t * calling {@link IBeanStructuralTreeTraverserMatcher#isMatching(IBeanStructuralElementInstance)}\r\n+\t * on all nodes and {@link IBeanStructuralTreeTraverserMatcher#processMatch(IBeanStructuralElementInstance, IBeanStructuralElementInstance)}\r\n+\t * on all found matches\r\n+\t * @param root traverse the subtree of this bean\r\n+\t * @param matcher matcher for callbacks\r\n+\t */\r\n+\tpublic void traverse(TYPE root, ITreeTraverserMatcher<TYPE> matcher) {\r\n+\t\tthis.matcher = matcher;\r\n+\t\ttraverseRecursive(root, null, 0, 0);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Traverse a subtree of a given node\r\n+\t * @param node the node from where to start traversing\r\n+\t * @param matchingParent the closest matching parent of node (or null)\r\n+\t */\r\n+\tprotected void traverseRecursive(TYPE node, TYPE matchingParent, int processedLevel, int matchingLevel) {\r", "originalCommit": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYxMTAwNg==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385611006", "bodyText": "Outdated javadoc", "author": "andriikovalov-dlr", "createdAt": "2020-02-28T10:12:02Z", "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverser.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+/**\r\n+ * Class for traversing a tree of structural element instances and calling\r\n+ * callback functions of a given matcher for matching nodes\r\n+ * @param <TYPE> the type of object the traverser should act on\r\n+ */\r\n+public class TreeTraverser<TYPE> {\r\n+\t\r\n+\tprotected ITreeTraverserMatcher<TYPE> matcher;\r\n+\t\r\n+\t/**\r\n+\t * Traverses the tree starting from the given root\r\n+\t * calling {@link IBeanStructuralTreeTraverserMatcher#isMatching(IBeanStructuralElementInstance)}\r", "originalCommit": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYxMjA0Ng==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385612046", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\n          \n          \n            \n             * Interface for plugging different logic into {@link TreeTraverser}", "author": "andriikovalov-dlr", "createdAt": "2020-02-28T10:14:13Z", "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/IStructuralElementInstanceTreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r", "originalCommit": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYyNzA3NQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385627075", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tpublic boolean continueTraverseChildren(IBeanStructuralElementInstance treeNode, boolean isMatching, int nestingLevel, int matchingLevel) {\n          \n          \n            \n            \t\t\tpublic boolean continueTraverseChildren(IBeanStructuralElementInstance treeNode, boolean isMatching, int treeLevel, int matchingLevel) {", "author": "andriikovalov-dlr", "createdAt": "2020-02-28T10:46:08Z", "path": "de.dlr.sc.virsat.model.extension.tests.test/src/de/dlr/sc/virsat/model/concept/types/structural/tree/BeanStructuralTreeTraverserTest.java", "diffHunk": "@@ -111,7 +111,7 @@ public void testSomeMatchWithLimitedRecusion() {\n \t\t\r\n \t\tMockMatcher matcher = new MockMatcher(node -> node.getName().endsWith(\"matches\")) {\r\n \t\t\t@Override\r\n-\t\t\tpublic boolean continueTraverseChildren(IBeanStructuralElementInstance treeNode, boolean isMatching) {\r\n+\t\t\tpublic boolean continueTraverseChildren(IBeanStructuralElementInstance treeNode, boolean isMatching, int nestingLevel, int matchingLevel) {\r", "originalCommit": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY1NzY5MQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385657691", "bodyText": "Do we even need this class now?", "author": "andriikovalov-dlr", "createdAt": "2020-02-28T11:58:57Z", "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/types/structural/tree/BeanStructuralTreeTraverser.java", "diffHunk": "@@ -11,55 +11,11 @@\n package de.dlr.sc.virsat.model.concept.types.structural.tree;\r\n \r\n import de.dlr.sc.virsat.model.concept.types.structural.IBeanStructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.tree.TreeTraverser;\r\n \r\n /**\r\n  * Class for traversing a tree of structural element instances and calling\r\n  * callback functions of a given matcher for matching nodes\r\n  */\r\n-public class BeanStructuralTreeTraverser {\r\n-\t\r\n-\tprivate IBeanStructuralTreeTraverserMatcher matcher;\r\n-\t\r\n-\t/**\r\n-\t * Traverses the tree starting from the given root\r\n-\t * calling {@link IBeanStructuralTreeTraverserMatcher#isMatching(IBeanStructuralElementInstance)}\r\n-\t * on all nodes and {@link IBeanStructuralTreeTraverserMatcher#processMatch(IBeanStructuralElementInstance, IBeanStructuralElementInstance)}\r\n-\t * on all found matches\r\n-\t * @param root traverse the subtree of this bean\r\n-\t * @param matcher matcher for callbacks\r\n-\t */\r\n-\tpublic void traverse(IBeanStructuralElementInstance root, IBeanStructuralTreeTraverserMatcher matcher) {\r\n-\t\tthis.matcher = matcher;\r\n-\t\ttraverseRecursive(root, null);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Traverse a subtree of a given node\r\n-\t * @param node the node from where to start traversing\r\n-\t * @param matchingParent the closest matching parent of node (or null)\r\n-\t */\r\n-\tprivate void traverseRecursive(IBeanStructuralElementInstance node, IBeanStructuralElementInstance matchingParent) {\r\n-\t\t// Remember the parent of the previous recursion\r\n-\t\tIBeanStructuralElementInstance nextParent = matchingParent;\r\n-\t\t\r\n-\t\t// First check if the traverser found a match.\r\n-\t\t// if yes start processing it, by handing over the node as well as its parent.\r\n-\t\t// This is e.g. needed by the visualization to create the tree nodes for the\r\n-\t\t// protobuf data model which can be transmitted to another visualization client.\r\n-\t\t// then remember the current node as the next parent to hand over the correct parent\r\n-\t\t// when processing the children.\r\n-\t\tboolean isMatching = matcher.isMatching(node);\r\n-\t\tif (isMatching) {\r\n-\t\t\tmatcher.processMatch(node, matchingParent);\r\n-\t\t\tnextParent = node;\r\n-\t\t}\r\n-\t\t\r\n-\t\t// Now check if the children should be processed.\r\n-\t\t// if yes recursively loop over all of them.\r\n-\t\tif (matcher.continueTraverseChildren(node, isMatching)) {\r\n-\t\t\tfor (IBeanStructuralElementInstance child : node.getChildren(IBeanStructuralElementInstance.class)) {\r\n-\t\t\t\ttraverseRecursive(child, nextParent);\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n+public class BeanStructuralTreeTraverser extends TreeTraverser<IBeanStructuralElementInstance> {\r", "originalCommit": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ1MjUyOQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r386452529", "bodyText": "Only for backwards compatibility, because it has been exposed API, and i am not sure about all places where it has been used.", "author": "PhilMFischer", "createdAt": "2020-03-02T15:14:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY1NzY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3ODU3NA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385678574", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t// Nothing special has to be processed with the SEIs that have Set functions in their calculations\n          \n          \n            \n            \t\t\t\t// Processing is done in the isMatching method", "author": "andriikovalov-dlr", "createdAt": "2020-02-28T12:51:40Z", "path": "de.dlr.sc.virsat.model.calculation/src/de/dlr/sc/virsat/model/calculation/compute/ExpressionHelper.java", "diffHunk": "@@ -293,67 +287,89 @@ public IExpressionResult caseAOpRightExpression(AOpRightExpression object) {\n \r\n \t/**\r\n \t * Gets a list of a all type instances that the passed set function would use as input\r\n-\t * @param object the set function\r\n+\t * @param setFunction the set function\r\n \t * @return  a list of all type instances the set function will use for its computation and is thus dependent on\r\n \t */\r\n-\tprivate List<ATypeInstance> getSetFunctionInput(SetFunction object) {\r\n-\t\tATypeDefinition typeDefinition = object.getTypeDefinition();\r\n-\t\tString filterName = object.getFilterName();\r\n+\tprivate List<ATypeInstance> getSetFunctionInput(SetFunction setFunction) {\r\n+\t\tATypeDefinition typeDefinition = setFunction.getTypeDefinition();\r\n+\t\tString filterName = setFunction.getFilterName();\r\n \t\tboolean filterForName = filterName != null && !filterName.equals(\"\");\r\n \r\n \t\t// Grab the structural element instance the set function belongs to\r\n-\t\tStructuralElementInstance sei = getStructuralElementInstance(object);\r\n+\t\tStructuralElementInstance sei = getStructuralElementInstance(setFunction);\r\n \t\tif (sei == null) {\r\n \t\t\treturn new ArrayList<>();\r\n \t\t}\r\n \r\n-\t\t// Find all applicable instances that are directly or indirectly contained by the sei\r\n-\t\tList<EObject> containers = new ArrayList<>();\r\n-\t\tcontainers.add(sei);\r\n-\t\tcontainers.addAll(StructuralElementInstanceHelper.getDeepChildren(sei, object.getDepth(), 0));\r\n-\r\n+\t\t// Store the inputs to the set function\r\n \t\tList<ATypeInstance> inputs = new ArrayList<>();\r\n-\t\t\r\n+\r\n \t\t// Find all child seis that also compute the set function\r\n-\t\tSet<StructuralElementInstance> childrenWithSetFunction = getChildrenWithSetFunction(sei, object, inputs);\r\n-\r\n-\t\tTreeIterator<Object> treeIter = EcoreUtil.getAllProperContents(containers, true);\r\n-\t\twhile (treeIter.hasNext()) {\r\n-\t\t\tObject potentialATypeInstance = treeIter.next();\r\n-\t\t\tif (potentialATypeInstance instanceof ATypeInstance) {\r\n-\t\t\t\tATypeInstance aTypeInstance = (ATypeInstance) potentialATypeInstance;\r\n-\r\n-\t\t\t\tboolean correctType = aTypeInstance.getType() == typeDefinition;\r\n-\t\t\t\tboolean notComputedByChild = !childrenWithSetFunction.contains(getStructuralElementInstance(aTypeInstance));\r\n-\r\n-\t\t\t\tif (correctType && notComputedByChild) {\r\n-\t\t\t\t\t// For composed property instances we have to get the category assignment\r\n-\t\t\t\t\t// to be able to work with them\r\n-\t\t\t\t\tif (aTypeInstance instanceof ComposedPropertyInstance) {\r\n-\t\t\t\t\t\taTypeInstance = ((ComposedPropertyInstance) aTypeInstance).getTypeInstance();\r\n-\t\t\t\t\t}\r\n+\t\tSet<StructuralElementInstance> childrenWithSetFunction = getChildrenWithSetFunction(sei, setFunction, inputs);\r\n+\t\t\r\n+\t\t// Get the CA in which the current Set resides. All TypeInstances of this category shall not be\r\n+\t\t// part of the inputs to be processed by this SetFunction. Accordingly they have to be removed\r\n+\t\t// from the Set's inputs\r\n+\t\tCategoryAssignment currentCa = VirSatEcoreUtil.getEContainerOfClass(setFunction, CategoryAssignment.class);\r\n+\t\t\r\n+\t\t// Find all applicable TypeInstances that are directly or indirectly contained by the sei\r\n+\t\tTreeTraverser<StructuralElementInstance> treeTraverser = new TreeTraverser<>();\r\n+\t\ttreeTraverser.traverse(sei, new IStructuralElementInstanceTreeTraverserMatcher() {\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean isMatching(StructuralElementInstance treeSei) {\r\n+\t\t\t\tboolean isMatching = false;\r\n+\t\t\t\t// Get all nested TypeInstances to the current treeSei and see if one\r\n+\t\t\t\t// is matching to the definition of what is referenced by the SET function\r\n+\t\t\t\tList<CategoryAssignment> currentCas = new LinkedList<>(treeSei.getCategoryAssignments());\r\n+\t\t\t\tcurrentCas.remove(currentCa);\r\n+\t\t\t\tCollection<ATypeInstance> typeInstances = VirSatEcoreUtil.getAllContentsOfType(currentCas, ATypeInstance.class, true);\r\n+\t\t\t\ttypeInstances.addAll(currentCas);\r\n+\t\t\t\t\r\n+\t\t\t\t// Loop over all identified ATypeInstances\r\n+\t\t\t\tfor (ATypeInstance aTypeInstance : typeInstances) {\r\n+\t\t\t\t\tboolean correctType = aTypeInstance.getType() == typeDefinition;\r\n+\t\t\t\t\tboolean notComputedByChild = !childrenWithSetFunction.contains(treeSei);\r\n+\t\t\t\t\tif (correctType && notComputedByChild) {\r\n+\t\t\t\t\t\t// For composed property instances we have to get the category assignment\r\n+\t\t\t\t\t\t// to be able to work with them, thus try to decompose it\r\n+\t\t\t\t\t\tATypeInstance decomposedTypeInstance = aTypeInstance;\r\n+\t\t\t\t\t\tif (decomposedTypeInstance instanceof ComposedPropertyInstance) {\r\n+\t\t\t\t\t\t\tdecomposedTypeInstance = ((ComposedPropertyInstance) aTypeInstance).getTypeInstance();\r\n+\t\t\t\t\t\t}\r\n \r\n-\t\t\t\t\tboolean correctName = !filterForName || hasCorrectName(aTypeInstance, filterName);\r\n-\t\t\t\t\tif (correctName) {\r\n-\t\t\t\t\t\tinputs.add(aTypeInstance);\r\n+\t\t\t\t\t\t// In case a name filter is set for the Set function make sure to apply it.\r\n+\t\t\t\t\t\t// If all properties are correct, remember the decomposed Type Instance as an input\r\n+\t\t\t\t\t\t// remember that we definitely had a match and continue with all the other items and check\r\n+\t\t\t\t\t\t// if they are potential inputs. Saving the match is important, so that the tree traverser\r\n+\t\t\t\t\t\t// can count the levels of nesting and levels of matches correctly\t\t\t\t\t\t\r\n+\t\t\t\t\t\tboolean correctName = !filterForName || hasCorrectName(decomposedTypeInstance, filterName);\r\n+\t\t\t\t\t\tif (correctName) {\r\n+\t\t\t\t\t\t\tinputs.add(decomposedTypeInstance);\r\n+\t\t\t\t\t\t\tisMatching = true;\r\n+\t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\t// return the result to decide if the current node will be counted\r\n+\t\t\t\t// for the matching levels or not\r\n+\t\t\t\treturn isMatching;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean continueTraverseChildren(StructuralElementInstance treeNode, boolean isMatching, int processedLevel, int matchedLevel) {\r\n+\t\t\t\t// Compare the depth of found matches with the depth set by the set function\r\n+\t\t\t\tint targetDepth = setFunction.getDepth();\r\n+\t\t\t\tboolean isDepthInfinite = targetDepth == AAdvancedFunctionOp.DEPTH_INFINITE;\r\n+\t\t\t\tboolean isDepthNotReached =  matchedLevel <= targetDepth; \r\n+\t\t\t\treturn isDepthInfinite || isDepthNotReached;\r\n \t\t\t}\r\n-\t\t}\r\n \r\n-\t\t// Get the CA in which the current Set resides. All TypeInstances of this category shall not be\r\n-\t\t// part of the inputs to be processed by this SetFunction. Accordingly they have to be removed\r\n-\t\t// from the Set's inputs\r\n-\t\tCategoryAssignment currentCa = VirSatEcoreUtil.getEContainerOfClass(object, CategoryAssignment.class);\r\n-\t\tif (currentCa != null) {\r\n-\t\t\tfor (APropertyInstance pi : currentCa.getPropertyInstances()) {\r\n-\t\t\t\tinputs.remove(pi);\r\n-\t\t\t\tif (pi instanceof ComposedPropertyInstance) {\r\n-\t\t\t\t\tComposedPropertyInstance cpi = (ComposedPropertyInstance) pi;\r\n-\t\t\t\t\tinputs.remove(cpi.getTypeInstance());\r\n-\t\t\t\t}\r\n+\t\t\t@Override\r\n+\t\t\tpublic void processMatch(StructuralElementInstance treeNode, StructuralElementInstance matchingParent) {\r\n+\t\t\t\t// Nothing special has to be processed with the SEIs that have Set functions in their calculations\r", "originalCommit": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MTA3MA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385681070", "bodyText": "Line 390, let's also change -1 to AAdvancedFunctionOp.DEPTH_INFINITE", "author": "andriikovalov-dlr", "createdAt": "2020-02-28T12:57:47Z", "path": "de.dlr.sc.virsat.model.calculation/src/de/dlr/sc/virsat/model/calculation/compute/ExpressionHelper.java", "diffHunk": "@@ -293,67 +287,89 @@ public IExpressionResult caseAOpRightExpression(AOpRightExpression object) {\n \r\n \t/**\r\n \t * Gets a list of a all type instances that the passed set function would use as input\r\n-\t * @param object the set function\r\n+\t * @param setFunction the set function\r\n \t * @return  a list of all type instances the set function will use for its computation and is thus dependent on\r\n \t */\r\n-\tprivate List<ATypeInstance> getSetFunctionInput(SetFunction object) {\r\n-\t\tATypeDefinition typeDefinition = object.getTypeDefinition();\r\n-\t\tString filterName = object.getFilterName();\r\n+\tprivate List<ATypeInstance> getSetFunctionInput(SetFunction setFunction) {\r\n+\t\tATypeDefinition typeDefinition = setFunction.getTypeDefinition();\r\n+\t\tString filterName = setFunction.getFilterName();\r\n \t\tboolean filterForName = filterName != null && !filterName.equals(\"\");\r\n \r\n \t\t// Grab the structural element instance the set function belongs to\r\n-\t\tStructuralElementInstance sei = getStructuralElementInstance(object);\r\n+\t\tStructuralElementInstance sei = getStructuralElementInstance(setFunction);\r\n \t\tif (sei == null) {\r\n \t\t\treturn new ArrayList<>();\r\n \t\t}\r\n \r\n-\t\t// Find all applicable instances that are directly or indirectly contained by the sei\r\n-\t\tList<EObject> containers = new ArrayList<>();\r\n-\t\tcontainers.add(sei);\r\n-\t\tcontainers.addAll(StructuralElementInstanceHelper.getDeepChildren(sei, object.getDepth(), 0));\r\n-\r\n+\t\t// Store the inputs to the set function\r\n \t\tList<ATypeInstance> inputs = new ArrayList<>();\r\n-\t\t\r\n+\r\n \t\t// Find all child seis that also compute the set function\r\n-\t\tSet<StructuralElementInstance> childrenWithSetFunction = getChildrenWithSetFunction(sei, object, inputs);\r\n-\r\n-\t\tTreeIterator<Object> treeIter = EcoreUtil.getAllProperContents(containers, true);\r\n-\t\twhile (treeIter.hasNext()) {\r\n-\t\t\tObject potentialATypeInstance = treeIter.next();\r\n-\t\t\tif (potentialATypeInstance instanceof ATypeInstance) {\r\n-\t\t\t\tATypeInstance aTypeInstance = (ATypeInstance) potentialATypeInstance;\r\n-\r\n-\t\t\t\tboolean correctType = aTypeInstance.getType() == typeDefinition;\r\n-\t\t\t\tboolean notComputedByChild = !childrenWithSetFunction.contains(getStructuralElementInstance(aTypeInstance));\r\n-\r\n-\t\t\t\tif (correctType && notComputedByChild) {\r\n-\t\t\t\t\t// For composed property instances we have to get the category assignment\r\n-\t\t\t\t\t// to be able to work with them\r\n-\t\t\t\t\tif (aTypeInstance instanceof ComposedPropertyInstance) {\r\n-\t\t\t\t\t\taTypeInstance = ((ComposedPropertyInstance) aTypeInstance).getTypeInstance();\r\n-\t\t\t\t\t}\r\n+\t\tSet<StructuralElementInstance> childrenWithSetFunction = getChildrenWithSetFunction(sei, setFunction, inputs);\r\n+\t\t\r\n+\t\t// Get the CA in which the current Set resides. All TypeInstances of this category shall not be\r\n+\t\t// part of the inputs to be processed by this SetFunction. Accordingly they have to be removed\r\n+\t\t// from the Set's inputs\r\n+\t\tCategoryAssignment currentCa = VirSatEcoreUtil.getEContainerOfClass(setFunction, CategoryAssignment.class);\r\n+\t\t\r\n+\t\t// Find all applicable TypeInstances that are directly or indirectly contained by the sei\r\n+\t\tTreeTraverser<StructuralElementInstance> treeTraverser = new TreeTraverser<>();\r\n+\t\ttreeTraverser.traverse(sei, new IStructuralElementInstanceTreeTraverserMatcher() {\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean isMatching(StructuralElementInstance treeSei) {\r\n+\t\t\t\tboolean isMatching = false;\r\n+\t\t\t\t// Get all nested TypeInstances to the current treeSei and see if one\r\n+\t\t\t\t// is matching to the definition of what is referenced by the SET function\r\n+\t\t\t\tList<CategoryAssignment> currentCas = new LinkedList<>(treeSei.getCategoryAssignments());\r\n+\t\t\t\tcurrentCas.remove(currentCa);\r\n+\t\t\t\tCollection<ATypeInstance> typeInstances = VirSatEcoreUtil.getAllContentsOfType(currentCas, ATypeInstance.class, true);\r\n+\t\t\t\ttypeInstances.addAll(currentCas);\r\n+\t\t\t\t\r\n+\t\t\t\t// Loop over all identified ATypeInstances\r\n+\t\t\t\tfor (ATypeInstance aTypeInstance : typeInstances) {\r\n+\t\t\t\t\tboolean correctType = aTypeInstance.getType() == typeDefinition;\r\n+\t\t\t\t\tboolean notComputedByChild = !childrenWithSetFunction.contains(treeSei);\r\n+\t\t\t\t\tif (correctType && notComputedByChild) {\r\n+\t\t\t\t\t\t// For composed property instances we have to get the category assignment\r\n+\t\t\t\t\t\t// to be able to work with them, thus try to decompose it\r\n+\t\t\t\t\t\tATypeInstance decomposedTypeInstance = aTypeInstance;\r\n+\t\t\t\t\t\tif (decomposedTypeInstance instanceof ComposedPropertyInstance) {\r\n+\t\t\t\t\t\t\tdecomposedTypeInstance = ((ComposedPropertyInstance) aTypeInstance).getTypeInstance();\r\n+\t\t\t\t\t\t}\r\n \r\n-\t\t\t\t\tboolean correctName = !filterForName || hasCorrectName(aTypeInstance, filterName);\r\n-\t\t\t\t\tif (correctName) {\r\n-\t\t\t\t\t\tinputs.add(aTypeInstance);\r\n+\t\t\t\t\t\t// In case a name filter is set for the Set function make sure to apply it.\r\n+\t\t\t\t\t\t// If all properties are correct, remember the decomposed Type Instance as an input\r\n+\t\t\t\t\t\t// remember that we definitely had a match and continue with all the other items and check\r\n+\t\t\t\t\t\t// if they are potential inputs. Saving the match is important, so that the tree traverser\r\n+\t\t\t\t\t\t// can count the levels of nesting and levels of matches correctly\t\t\t\t\t\t\r\n+\t\t\t\t\t\tboolean correctName = !filterForName || hasCorrectName(decomposedTypeInstance, filterName);\r\n+\t\t\t\t\t\tif (correctName) {\r\n+\t\t\t\t\t\t\tinputs.add(decomposedTypeInstance);\r\n+\t\t\t\t\t\t\tisMatching = true;\r\n+\t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\t// return the result to decide if the current node will be counted\r\n+\t\t\t\t// for the matching levels or not\r\n+\t\t\t\treturn isMatching;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean continueTraverseChildren(StructuralElementInstance treeNode, boolean isMatching, int processedLevel, int matchedLevel) {\r\n+\t\t\t\t// Compare the depth of found matches with the depth set by the set function\r\n+\t\t\t\tint targetDepth = setFunction.getDepth();\r\n+\t\t\t\tboolean isDepthInfinite = targetDepth == AAdvancedFunctionOp.DEPTH_INFINITE;\r\n+\t\t\t\tboolean isDepthNotReached =  matchedLevel <= targetDepth; \r\n+\t\t\t\treturn isDepthInfinite || isDepthNotReached;\r\n \t\t\t}\r\n-\t\t}\r\n \r\n-\t\t// Get the CA in which the current Set resides. All TypeInstances of this category shall not be\r\n-\t\t// part of the inputs to be processed by this SetFunction. Accordingly they have to be removed\r\n-\t\t// from the Set's inputs\r\n-\t\tCategoryAssignment currentCa = VirSatEcoreUtil.getEContainerOfClass(object, CategoryAssignment.class);\r\n-\t\tif (currentCa != null) {\r\n-\t\t\tfor (APropertyInstance pi : currentCa.getPropertyInstances()) {\r\n-\t\t\t\tinputs.remove(pi);\r\n-\t\t\t\tif (pi instanceof ComposedPropertyInstance) {\r\n-\t\t\t\t\tComposedPropertyInstance cpi = (ComposedPropertyInstance) pi;\r\n-\t\t\t\t\tinputs.remove(cpi.getTypeInstance());\r\n-\t\t\t\t}\r\n+\t\t\t@Override\r\n+\t\t\tpublic void processMatch(StructuralElementInstance treeNode, StructuralElementInstance matchingParent) {\r\n+\t\t\t\t// Nothing special has to be processed with the SEIs that have Set functions in their calculations\r\n \t\t\t}\r\n-\t\t}\r\n+\t\t});\r\n \r\n \t\treturn inputs;\r\n \t}\r", "originalCommit": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5Mjk0NA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385692944", "bodyText": "Not immediately clear what it matches. I suggest we either check it explicitly like return treeNode != seiChild1 && treenode != seiChild2 or check a special name like \"MISMATCH\", and set it to mismatching elements.", "author": "andriikovalov-dlr", "createdAt": "2020-02-28T13:25:05Z", "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+\r\n+import java.util.HashMap;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Objects;\r\n+\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElement;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralFactory;\r\n+\r\n+import static org.hamcrest.Matchers.contains;\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertThat;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+public class TreeTraverserTest {\r\n+\r\n+\tStructuralElement se;\r\n+\t\r\n+\tStructuralElementInstance seiRoot;\r\n+\tStructuralElementInstance seiChild1;\r\n+\tStructuralElementInstance seiChild1Child;\r\n+\tStructuralElementInstance seiChild1ChildChild;\r\n+\tStructuralElementInstance seiChild2;\r\n+\tStructuralElementInstance seiChild2Child;\r\n+\tStructuralElementInstance seiChild2ChildChild;\r\n+\t\r\n+\t@Before\r\n+\tpublic void setUp() throws Exception {\r\n+\t\tStructuralElement se = StructuralFactory.eINSTANCE.createStructuralElement();\r\n+\t\t\r\n+\t\tseiRoot = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\t\r\n+\t\tse.setIsApplicableForAll(true);\r\n+\t\t\r\n+\t\tseiRoot.setType(se);\r\n+\t\tseiChild1.setType(se);\r\n+\t\tseiChild1Child.setType(se);\r\n+\t\tseiChild1ChildChild.setType(se);\r\n+\t\tseiChild2.setType(se);\r\n+\t\tseiChild2Child.setType(se);\r\n+\t\tseiChild2ChildChild.setType(se);\r\n+\t\t\r\n+\t\tseiRoot.getChildren().add(seiChild1);\r\n+\t\tseiRoot.getChildren().add(seiChild2);\r\n+\t\tseiChild1.getChildren().add(seiChild1Child);\r\n+\t\tseiChild2.getChildren().add(seiChild2Child);\r\n+\t\tseiChild1Child.getChildren().add(seiChild1ChildChild);\r\n+\t\tseiChild2Child.getChildren().add(seiChild2ChildChild);\r\n+\t\t\r\n+\t\t// Now set names for the 2 level and for the 3 level,\r\n+\t\t// Try to find them and check if the traverser reacts as expected\r\n+\t\tseiRoot.setName(\"Root\");\r\n+\t\tseiChild1Child.setName(\"ChildOf1\");\r\n+\t\tseiChild2Child.setName(\"ChildOf2\");\r\n+\t\tseiChild1ChildChild.setName(\"DoubleChildOf1\");\r\n+\t\tseiChild2ChildChild.setName(\"DoubleChildOf2\");\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Class to capture the results from the tree traversing\r\n+\t */\r\n+\tclass Result {\r\n+\t\t\r\n+\t\t@Override\r\n+\t\tpublic int hashCode() {\r\n+\t\t\tfinal int prime = 31;\r\n+\t\t\tint result = 1;\r\n+\t\t\tresult = prime * result + Objects.hash(matchingLevel, nestingLevel, sei);\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\t@Override\r\n+\t\tpublic boolean equals(Object obj) {\r\n+\t\t\tif (this == obj) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t} else if (obj == null) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else if (getClass() != obj.getClass()) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else {\r\n+\t\t\t\tResult other = (Result) obj;\r\n+\t\t\t\treturn matchingLevel == other.matchingLevel && nestingLevel == other.nestingLevel && Objects.equals(sei, other.sei);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\t\r\n+\t\tResult(StructuralElementInstance sei, int processedLevel, int matchedLevel) {\r\n+\t\t\tthis.sei = sei;\r\n+\t\t\tthis.nestingLevel = processedLevel;\r\n+\t\t\tthis.matchingLevel = matchedLevel;\r\n+\t\t}\r\n+\r\n+\t\tStructuralElementInstance sei;\r\n+\t\tint nestingLevel;\r\n+\t\tint matchingLevel;\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testTraverse() {\r\n+\t\tList<Result> traverseResults = new LinkedList<>();\r\n+\t\tMap<StructuralElementInstance, StructuralElementInstance> mapToParentResults = new HashMap<>();\r\n+\t\t\r\n+\t\tTreeTraverser<StructuralElementInstance> traverser = new TreeTraverser<>();\r\n+\t\t\r\n+\t\ttraverser.traverse(seiRoot, new IStructuralElementInstanceTreeTraverserMatcher() {\r\n+\t\t\t@Override\r\n+\t\t\tpublic void processMatch(StructuralElementInstance treeNode, StructuralElementInstance matchingParent) {\r\n+\t\t\t\tmapToParentResults.put(treeNode, matchingParent);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean isMatching(StructuralElementInstance treeNode) {\r\n+\t\t\t\treturn treeNode.getName() != null;\r", "originalCommit": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5NDQ3OQ==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385694479", "bodyText": "Shall we also add tree level and match level as parameters here?", "author": "andriikovalov-dlr", "createdAt": "2020-02-28T13:28:13Z", "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r\n+ * For example for building a tree consisting only of nodes with a certain Category attached\r\n+ * @param <TYPE> The type for which the matcher should apply\r\n+ */\r\n+public interface ITreeTraverserMatcher<TYPE> {\r\n+\r\n+\t/**\r\n+\t * Checks if the passed treeNode bean matches the desired criteria\r\n+\t * @param treeNode node bean to check\r\n+\t * @return true if this node matches, false otherwise\r\n+\t */\r\n+\tboolean isMatching(TYPE treeNode);\r\n+\t\r\n+\t/**\r\n+\t * Processes the found match\r\n+\t * @param treeNode a matching tree node\r\n+\t * @param matchingParent the closest parent of the node that also matches the criteria.\r\n+\t *        Can be null if the node does not have a matching parent\r\n+\t */\r\n+\tvoid processMatch(TYPE treeNode, TYPE matchingParent);\r", "originalCommit": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ1OTg5Nw==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r386459897", "bodyText": "I thought about that one as well, but wanted to keep it to as minimal change as needed. thus i would argues for no, for the moment.", "author": "PhilMFischer", "createdAt": "2020-03-02T15:26:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5NDQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5ODMxOA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385698318", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tboolean isChild2Child = treeNode == seiChild2Child;\n          \n          \n            \n            \t\t\t\treturn !isChild2Child && IStructuralElementInstanceTreeTraverserMatcher.super.continueTraverseChildren(treeNode, isMatching, nestingLevel, matchingLevel);\n          \n          \n            \n            \t\t\t\treturn treeNode != seiChild2Child;", "author": "andriikovalov-dlr", "createdAt": "2020-02-28T13:36:46Z", "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+\r\n+import java.util.HashMap;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Objects;\r\n+\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElement;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralFactory;\r\n+\r\n+import static org.hamcrest.Matchers.contains;\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertThat;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+public class TreeTraverserTest {\r\n+\r\n+\tStructuralElement se;\r\n+\t\r\n+\tStructuralElementInstance seiRoot;\r\n+\tStructuralElementInstance seiChild1;\r\n+\tStructuralElementInstance seiChild1Child;\r\n+\tStructuralElementInstance seiChild1ChildChild;\r\n+\tStructuralElementInstance seiChild2;\r\n+\tStructuralElementInstance seiChild2Child;\r\n+\tStructuralElementInstance seiChild2ChildChild;\r\n+\t\r\n+\t@Before\r\n+\tpublic void setUp() throws Exception {\r\n+\t\tStructuralElement se = StructuralFactory.eINSTANCE.createStructuralElement();\r\n+\t\t\r\n+\t\tseiRoot = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\t\r\n+\t\tse.setIsApplicableForAll(true);\r\n+\t\t\r\n+\t\tseiRoot.setType(se);\r\n+\t\tseiChild1.setType(se);\r\n+\t\tseiChild1Child.setType(se);\r\n+\t\tseiChild1ChildChild.setType(se);\r\n+\t\tseiChild2.setType(se);\r\n+\t\tseiChild2Child.setType(se);\r\n+\t\tseiChild2ChildChild.setType(se);\r\n+\t\t\r\n+\t\tseiRoot.getChildren().add(seiChild1);\r\n+\t\tseiRoot.getChildren().add(seiChild2);\r\n+\t\tseiChild1.getChildren().add(seiChild1Child);\r\n+\t\tseiChild2.getChildren().add(seiChild2Child);\r\n+\t\tseiChild1Child.getChildren().add(seiChild1ChildChild);\r\n+\t\tseiChild2Child.getChildren().add(seiChild2ChildChild);\r\n+\t\t\r\n+\t\t// Now set names for the 2 level and for the 3 level,\r\n+\t\t// Try to find them and check if the traverser reacts as expected\r\n+\t\tseiRoot.setName(\"Root\");\r\n+\t\tseiChild1Child.setName(\"ChildOf1\");\r\n+\t\tseiChild2Child.setName(\"ChildOf2\");\r\n+\t\tseiChild1ChildChild.setName(\"DoubleChildOf1\");\r\n+\t\tseiChild2ChildChild.setName(\"DoubleChildOf2\");\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Class to capture the results from the tree traversing\r\n+\t */\r\n+\tclass Result {\r\n+\t\t\r\n+\t\t@Override\r\n+\t\tpublic int hashCode() {\r\n+\t\t\tfinal int prime = 31;\r\n+\t\t\tint result = 1;\r\n+\t\t\tresult = prime * result + Objects.hash(matchingLevel, nestingLevel, sei);\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\t@Override\r\n+\t\tpublic boolean equals(Object obj) {\r\n+\t\t\tif (this == obj) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t} else if (obj == null) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else if (getClass() != obj.getClass()) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else {\r\n+\t\t\t\tResult other = (Result) obj;\r\n+\t\t\t\treturn matchingLevel == other.matchingLevel && nestingLevel == other.nestingLevel && Objects.equals(sei, other.sei);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\t\r\n+\t\tResult(StructuralElementInstance sei, int processedLevel, int matchedLevel) {\r\n+\t\t\tthis.sei = sei;\r\n+\t\t\tthis.nestingLevel = processedLevel;\r\n+\t\t\tthis.matchingLevel = matchedLevel;\r\n+\t\t}\r\n+\r\n+\t\tStructuralElementInstance sei;\r\n+\t\tint nestingLevel;\r\n+\t\tint matchingLevel;\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testTraverse() {\r\n+\t\tList<Result> traverseResults = new LinkedList<>();\r\n+\t\tMap<StructuralElementInstance, StructuralElementInstance> mapToParentResults = new HashMap<>();\r\n+\t\t\r\n+\t\tTreeTraverser<StructuralElementInstance> traverser = new TreeTraverser<>();\r\n+\t\t\r\n+\t\ttraverser.traverse(seiRoot, new IStructuralElementInstanceTreeTraverserMatcher() {\r\n+\t\t\t@Override\r\n+\t\t\tpublic void processMatch(StructuralElementInstance treeNode, StructuralElementInstance matchingParent) {\r\n+\t\t\t\tmapToParentResults.put(treeNode, matchingParent);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean isMatching(StructuralElementInstance treeNode) {\r\n+\t\t\t\treturn treeNode.getName() != null;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean continueTraverseChildren(StructuralElementInstance treeNode, boolean isMatching, int nestingLevel, int matchingLevel) {\r\n+\t\t\t\ttraverseResults.add(new Result(treeNode, nestingLevel, matchingLevel));\r\n+\t\t\t\t\r\n+\t\t\t\t// Try to make sure that the seiChild2ChildChild which is theoretically correct, still does not get found\r\n+\t\t\t\tboolean isChild2Child = treeNode == seiChild2Child;\r\n+\t\t\t\treturn !isChild2Child && IStructuralElementInstanceTreeTraverserMatcher.super.continueTraverseChildren(treeNode, isMatching, nestingLevel, matchingLevel);\r", "originalCommit": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ2MjM1MA==", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r386462350", "bodyText": "The former one, has the default implementation of the interface connected to the test. Thus a change to the default implementation would be captured here. I prefer leaving it as it is, but i added a comment, why the statement has to be that complex.", "author": "PhilMFischer", "createdAt": "2020-03-02T15:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5ODMxOA=="}], "type": "inlineReview"}, {"oid": "b3ad412e5af4ab271317d16264d679731c53cb70", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/b3ad412e5af4ab271317d16264d679731c53cb70", "message": "Changes due to review comments - (Task #497)\n\n- Adjusted some a java doc.\n- made some minor code modifications to improve readability.\n\n---\nTask #497: Adjust CEFX calculations to summarize masses and power across\nempty system elements", "committedDate": "2020-03-02T15:32:13Z", "type": "commit"}]}