{"pr_number": 2752, "pr_title": "[GEOT-6313]: Fixes wrapping on RenderingTransformation", "pr_createdAt": "2020-01-15T14:07:19Z", "pr_url": "https://github.com/geotools/geotools/pull/2752", "timeline": [{"oid": "8bdcb7062072488470ff2818aa92a775cc647a80", "url": "https://github.com/geotools/geotools/commit/8bdcb7062072488470ff2818aa92a775cc647a80", "message": "[GEOT-6313]: Fixes wrapping on RenderingTransformation", "committedDate": "2020-01-15T14:11:50Z", "type": "forcePushed"}, {"oid": "29bd0c7e8340182faf7317738d8a1da9283c7707", "url": "https://github.com/geotools/geotools/commit/29bd0c7e8340182faf7317738d8a1da9283c7707", "message": "[GEOT-6313]: Fixes wrapping on RenderingTransformation", "committedDate": "2020-01-15T14:14:43Z", "type": "forcePushed"}, {"oid": "0453c5f934afeff74078b792522dac4db4e876bb", "url": "https://github.com/geotools/geotools/commit/0453c5f934afeff74078b792522dac4db4e876bb", "message": "[GEOT-6313]: Fixes wrapping on RenderingTransformation", "committedDate": "2020-01-15T14:18:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMxOTQ2NQ==", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367319465", "bodyText": "Good catch, ROI.add does not modify the current ROI, it builds a new one.", "author": "aaime", "createdAt": "2020-01-16T09:43:44Z", "path": "modules/library/coverage/src/main/java/org/geotools/coverage/processing/operation/Mosaic.java", "diffHunk": "@@ -972,15 +972,16 @@ protected RenderedImage createRenderedImage(\n                 } else if (rois[i] == null) {\n                     // no ROI, the image is full\n                     RenderedImage ri = sources[i].getRenderedImage();\n-                    finalROI.add(\n-                            new ROIShape(\n-                                    new Rectangle2D.Double(\n-                                            ri.getMinX(),\n-                                            ri.getMinY(),\n-                                            ri.getWidth(),\n-                                            ri.getHeight())));\n+                    finalROI =", "originalCommit": "0453c5f934afeff74078b792522dac4db4e876bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMDQzMA==", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367320430", "bodyText": "Confused, any reason not to use a fullCircles and avoid the divisions later?", "author": "aaime", "createdAt": "2020-01-16T09:45:49Z", "path": "modules/library/main/src/main/java/org/geotools/renderer/crs/ProjectionHandler.java", "diffHunk": "@@ -343,29 +306,132 @@ private void addTransformedEnvelope(ReferencedEnvelope re, List<ReferencedEnvelo\n         // have no idea at all) we don't actually split, but add elements\n         List<ReferencedEnvelope> envelopes = new ArrayList<ReferencedEnvelope>();\n         envelopes.add(re);\n-        if (re.getMinX() < -180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            re.getMinX() + 360,\n-                            Math.min(re.getMaxX() + 360, 180),\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n-        if (re.getMaxX() > 180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            Math.max(re.getMinX() - 360, -180),\n-                            re.getMaxX() - 360,\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n+        adjustEnvelope(re, envelopes, false);\n         mergeEnvelopes(envelopes);\n         reprojectEnvelopes(sourceCRS, envelopes);\n         return envelopes.stream().filter(e -> e != null).collect(Collectors.toList());\n     }\n \n+    /**\n+     * Adjust the envelope by taking into account dateline wrapping as well as multiple spans of the\n+     * whole world extent. When transform flag is true, the envelopes will be transformed before\n+     * being returned\n+     */\n+    private void adjustEnvelope(\n+            ReferencedEnvelope re, List<ReferencedEnvelope> envelopes, boolean transform)\n+            throws TransformException, FactoryException {\n+        CoordinateReferenceSystem crs = re.getCoordinateReferenceSystem();\n+        boolean isLatLon = CRS.getAxisOrder(crs) == CRS.AxisOrder.NORTH_EAST;\n+        double minX = isLatLon ? re.getMinY() : re.getMinX();\n+        double maxX = isLatLon ? re.getMaxY() : re.getMaxX();\n+        double minY = isLatLon ? re.getMinX() : re.getMinY();\n+        double maxY = isLatLon ? re.getMaxX() : re.getMaxY();\n+        double extent = maxX - minX;\n+        List<ReferencedEnvelope> envelopesToBeAdded = new ArrayList<>();\n+        if (extent > 360) {\n+            // at least one whole world use case -> requested data covers the full world:\n+            // let's set a -180,180 bbox.\n+            // the wrapping projectionHandler and the gridCoverageReaders\n+            // will do proper clones / intersections afterwards\n+            minX = -180;\n+            maxX = 180;\n+            // Create a whole world envelope taking into account latLon/lonLat\n+            ReferencedEnvelope envelope =\n+                    new ReferencedEnvelope(\n+                            isLatLon ? minY : minX,\n+                            isLatLon ? maxY : maxX,\n+                            isLatLon ? minX : minY,\n+                            isLatLon ? maxX : maxY,\n+                            crs);\n+            envelopesToBeAdded.add(envelope);\n+        } else {\n+            // let's do some adjustments to \"shift\" the request around -180, 180 interval:\n+            // we basically add or subtract 360\u00b0 N times\n+            // 1) let's count how many halfCircles (a 180\u00b0 span) we are away from the zero\n+\n+            // 2) add/subtract 360\u00b0 N times to move forward/backward the request, also\n+            // keeping into account whether we are crossing the dateline or not\n+            // (halfCircles % 2)\n+\n+            // 3) add/subtract the original extent to get the other value of the interval\n+            // in order to move the whole window (Note that the extent won't be > 360\u00b0\n+            // since we are inside the \"else\")\n+\n+            int halfCircles = 0;\n+            if (minX < -180) {\n+                halfCircles = (int) ((Math.abs(minX) / 180));", "originalCommit": "0453c5f934afeff74078b792522dac4db4e876bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyOTgyOA==", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367329828", "bodyText": "I'm using the halfCircles for the (halfCircles % 2) part which introduces an eventual +1 when the number of halfCircles is odd.", "author": "dromagnoli", "createdAt": "2020-01-16T10:04:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMDQzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2NzYyNg==", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367367626", "bodyText": "Cool, could you add comments to explain this better then? For next time someone looks at the code.", "author": "aaime", "createdAt": "2020-01-16T11:29:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMDQzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2OTU0Mw==", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367369543", "bodyText": "Yep. point 2) of the comment was reporting that. I'm going to explain it better", "author": "dromagnoli", "createdAt": "2020-01-16T11:33:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMDQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMTE4Mw==", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367321183", "bodyText": "Isn't this triggering every time (maxX - minX) > 180? Doesn't mean the dateline has been crossed though.", "author": "aaime", "createdAt": "2020-01-16T09:47:26Z", "path": "modules/library/main/src/main/java/org/geotools/renderer/crs/ProjectionHandler.java", "diffHunk": "@@ -343,29 +306,132 @@ private void addTransformedEnvelope(ReferencedEnvelope re, List<ReferencedEnvelo\n         // have no idea at all) we don't actually split, but add elements\n         List<ReferencedEnvelope> envelopes = new ArrayList<ReferencedEnvelope>();\n         envelopes.add(re);\n-        if (re.getMinX() < -180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            re.getMinX() + 360,\n-                            Math.min(re.getMaxX() + 360, 180),\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n-        if (re.getMaxX() > 180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            Math.max(re.getMinX() - 360, -180),\n-                            re.getMaxX() - 360,\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n+        adjustEnvelope(re, envelopes, false);\n         mergeEnvelopes(envelopes);\n         reprojectEnvelopes(sourceCRS, envelopes);\n         return envelopes.stream().filter(e -> e != null).collect(Collectors.toList());\n     }\n \n+    /**\n+     * Adjust the envelope by taking into account dateline wrapping as well as multiple spans of the\n+     * whole world extent. When transform flag is true, the envelopes will be transformed before\n+     * being returned\n+     */\n+    private void adjustEnvelope(\n+            ReferencedEnvelope re, List<ReferencedEnvelope> envelopes, boolean transform)\n+            throws TransformException, FactoryException {\n+        CoordinateReferenceSystem crs = re.getCoordinateReferenceSystem();\n+        boolean isLatLon = CRS.getAxisOrder(crs) == CRS.AxisOrder.NORTH_EAST;\n+        double minX = isLatLon ? re.getMinY() : re.getMinX();\n+        double maxX = isLatLon ? re.getMaxY() : re.getMaxX();\n+        double minY = isLatLon ? re.getMinX() : re.getMinY();\n+        double maxY = isLatLon ? re.getMaxX() : re.getMaxY();\n+        double extent = maxX - minX;\n+        List<ReferencedEnvelope> envelopesToBeAdded = new ArrayList<>();\n+        if (extent > 360) {\n+            // at least one whole world use case -> requested data covers the full world:\n+            // let's set a -180,180 bbox.\n+            // the wrapping projectionHandler and the gridCoverageReaders\n+            // will do proper clones / intersections afterwards\n+            minX = -180;\n+            maxX = 180;\n+            // Create a whole world envelope taking into account latLon/lonLat\n+            ReferencedEnvelope envelope =\n+                    new ReferencedEnvelope(\n+                            isLatLon ? minY : minX,\n+                            isLatLon ? maxY : maxX,\n+                            isLatLon ? minX : minY,\n+                            isLatLon ? maxX : maxY,\n+                            crs);\n+            envelopesToBeAdded.add(envelope);\n+        } else {\n+            // let's do some adjustments to \"shift\" the request around -180, 180 interval:\n+            // we basically add or subtract 360\u00b0 N times\n+            // 1) let's count how many halfCircles (a 180\u00b0 span) we are away from the zero\n+\n+            // 2) add/subtract 360\u00b0 N times to move forward/backward the request, also\n+            // keeping into account whether we are crossing the dateline or not\n+            // (halfCircles % 2)\n+\n+            // 3) add/subtract the original extent to get the other value of the interval\n+            // in order to move the whole window (Note that the extent won't be > 360\u00b0\n+            // since we are inside the \"else\")\n+\n+            int halfCircles = 0;\n+            if (minX < -180) {\n+                halfCircles = (int) ((Math.abs(minX) / 180));\n+                minX += (360 * ((halfCircles / 2) + (halfCircles % 2)));\n+                maxX = minX + extent;\n+            } else if (minX > 180) {\n+                halfCircles = (int) (minX / 180);\n+                minX -= (360 * ((halfCircles / 2) + (halfCircles % 2)));\n+                maxX = minX + extent;\n+            } else if (maxX < -180) {\n+                halfCircles = (int) (Math.abs(maxX) / 180);\n+                maxX += (360 * ((halfCircles / 2) + (halfCircles % 2)));\n+                minX = maxX - extent;\n+            } else if (maxX > 180) {\n+                halfCircles = (int) (Math.abs(maxX) / 180);\n+                maxX -= (360 * ((halfCircles / 2) + (halfCircles % 2)));\n+                minX = maxX - extent;\n+            }\n+\n+            if ((int) (minX / 180) < (int) (maxX / 180)) {", "originalCommit": "0453c5f934afeff74078b792522dac4db4e876bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMzNjk3OQ==", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367336979", "bodyText": "I will double check but I don't think so.\nWe are already excluding at least that maxX - minX > 360 (we are in the else) and we have already shifted the values to be in the range -180, 180 plus some extent adjustment.\na case like [-91, 91] will be 0 < 0 not triggering.\na case like [-1, 181] will be 0 < 1 triggering.\na case like [-181, 1] will be -1 < 0 triggering.\nI think it should work but let me know if I have missed some cases here.", "author": "dromagnoli", "createdAt": "2020-01-16T10:19:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMTE4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2NzcwNQ==", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367367705", "bodyText": "Same as above, add comments.", "author": "aaime", "createdAt": "2020-01-16T11:29:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMTE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMzYwOQ==", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367323609", "bodyText": "Uh, this is going vertical (format wise)... could you use a \"convert anonymous to inner\" and move this block to its own inner class?", "author": "aaime", "createdAt": "2020-01-16T09:52:14Z", "path": "modules/library/render/src/main/java/org/geotools/renderer/lite/StreamingRenderer.java", "diffHunk": "@@ -2326,18 +2325,49 @@ protected GridCoverage2D readCoverage(\n                                 GridGeometry2D readGG)\n                                 throws IOException {\n                             Interpolation interpolation = getRenderingInterpolation(layer);\n-                            GridCoverageReaderHelper helper;\n+                            RenderingHints interpolationHints =\n+                                    new RenderingHints(JAI.KEY_INTERPOLATION, interpolation);\n+                            final GridCoverageRenderer gcr;\n                             try {\n-                                helper =\n-                                        new GridCoverageReaderHelper(\n+                                // Use the original screenSize", "originalCommit": "0453c5f934afeff74078b792522dac4db4e876bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMzOTIzMw==", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367339233", "bodyText": "roger", "author": "dromagnoli", "createdAt": "2020-01-16T10:23:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMzYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMzgwNA==", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367323804", "bodyText": "Is this actually true if the advanced projection handling is off though?", "author": "aaime", "createdAt": "2020-01-16T09:52:38Z", "path": "modules/library/render/src/main/java/org/geotools/renderer/lite/StreamingRenderer.java", "diffHunk": "@@ -2326,18 +2325,49 @@ protected GridCoverage2D readCoverage(\n                                 GridGeometry2D readGG)\n                                 throws IOException {\n                             Interpolation interpolation = getRenderingInterpolation(layer);\n-                            GridCoverageReaderHelper helper;\n+                            RenderingHints interpolationHints =\n+                                    new RenderingHints(JAI.KEY_INTERPOLATION, interpolation);\n+                            final GridCoverageRenderer gcr;\n                             try {\n-                                helper =\n-                                        new GridCoverageReaderHelper(\n+                                // Use the original screenSize\n+                                // the GridCoverageRenderer will take care of eventual gutter or", "originalCommit": "0453c5f934afeff74078b792522dac4db4e876bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2NjQzNw==", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367366437", "bodyText": "I have found another place where it's raising issues... backing to the original gridgeometry usage", "author": "dromagnoli", "createdAt": "2020-01-16T11:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMzgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyNTE1OA==", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367325158", "bodyText": "Could you add a good set of tests inside ProjectionHandlerTest covering all the possible cases handled here?", "author": "aaime", "createdAt": "2020-01-16T09:55:24Z", "path": "modules/library/main/src/main/java/org/geotools/renderer/crs/ProjectionHandler.java", "diffHunk": "@@ -343,29 +306,132 @@ private void addTransformedEnvelope(ReferencedEnvelope re, List<ReferencedEnvelo\n         // have no idea at all) we don't actually split, but add elements\n         List<ReferencedEnvelope> envelopes = new ArrayList<ReferencedEnvelope>();\n         envelopes.add(re);\n-        if (re.getMinX() < -180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            re.getMinX() + 360,\n-                            Math.min(re.getMaxX() + 360, 180),\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n-        if (re.getMaxX() > 180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            Math.max(re.getMinX() - 360, -180),\n-                            re.getMaxX() - 360,\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n+        adjustEnvelope(re, envelopes, false);\n         mergeEnvelopes(envelopes);\n         reprojectEnvelopes(sourceCRS, envelopes);\n         return envelopes.stream().filter(e -> e != null).collect(Collectors.toList());\n     }\n \n+    /**\n+     * Adjust the envelope by taking into account dateline wrapping as well as multiple spans of the\n+     * whole world extent. When transform flag is true, the envelopes will be transformed before\n+     * being returned\n+     */\n+    private void adjustEnvelope(", "originalCommit": "0453c5f934afeff74078b792522dac4db4e876bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2NjcxNw==", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367366717", "bodyText": "will do.", "author": "dromagnoli", "createdAt": "2020-01-16T11:27:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyNTE1OA=="}], "type": "inlineReview"}, {"oid": "1f38b6136ffd7888be0af9b0aa0799091c6fc539", "url": "https://github.com/geotools/geotools/commit/1f38b6136ffd7888be0af9b0aa0799091c6fc539", "message": "[GEOT-6313]: Fixes wrapping on RenderingTransformation", "committedDate": "2020-01-16T13:52:44Z", "type": "forcePushed"}, {"oid": "f075d78917ec6c503a3b52b0959357c6247ef889", "url": "https://github.com/geotools/geotools/commit/f075d78917ec6c503a3b52b0959357c6247ef889", "message": "[GEOT-6313]: Fixes wrapping on RenderingTransformation", "committedDate": "2020-01-16T14:19:49Z", "type": "forcePushed"}, {"oid": "2610e5cfa5623670e8a3d31d96ef4dbe0d9af6ea", "url": "https://github.com/geotools/geotools/commit/2610e5cfa5623670e8a3d31d96ef4dbe0d9af6ea", "message": "[GEOT-6313]: Fixes wrapping on RenderingTransformation", "committedDate": "2020-01-17T15:56:39Z", "type": "commit"}, {"oid": "2610e5cfa5623670e8a3d31d96ef4dbe0d9af6ea", "url": "https://github.com/geotools/geotools/commit/2610e5cfa5623670e8a3d31d96ef4dbe0d9af6ea", "message": "[GEOT-6313]: Fixes wrapping on RenderingTransformation", "committedDate": "2020-01-17T15:56:39Z", "type": "forcePushed"}]}