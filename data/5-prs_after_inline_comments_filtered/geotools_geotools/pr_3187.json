{"pr_number": 3187, "pr_title": "[GEOT-6726] Add new FilteringVectorProcess", "pr_createdAt": "2020-10-22T15:58:50Z", "pr_url": "https://github.com/geotools/geotools/pull/3187", "timeline": [{"oid": "5efd106ed909fc97db2dc5c828a059ad25fb5ad6", "url": "https://github.com/geotools/geotools/commit/5efd106ed909fc97db2dc5c828a059ad25fb5ad6", "message": "[GEOT-6726] Add new FilteringVectorProcess", "committedDate": "2020-10-23T06:11:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA2MzU3Mw==", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r512063573", "bodyText": "A database in general can group over nulls, it's just a different value. IMHO this should not be hard-coded, but part of the filtering done in the SLD. If this is a hard requirement, it needs to be clearly documented, as it goes against normal practice (TBH, I would consider this behavior a bug).\nFor reference: https://learnsql.com/blog/null-values-group-clause/", "author": "aaime", "createdAt": "2020-10-26T15:45:00Z", "path": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/FilteringVectorProcess.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ *    GeoTools - The Open Source Java GIS Toolkit\n+ *    http://geotools.org\n+ *\n+ *    (C) 2020, Open Source Geospatial Foundation (OSGeo)\n+ *\n+ *    This library is free software; you can redistribute it and/or\n+ *    modify it under the terms of the GNU Lesser General Public\n+ *    License as published by the Free Software Foundation;\n+ *    version 2.1 of the License.\n+ *\n+ *    This library is distributed in the hope that it will be useful,\n+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ *    Lesser General Public License for more details.\n+ */\n+package org.geotools.process.vector;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.geotools.data.Query;\n+import org.geotools.factory.CommonFactoryFinder;\n+import org.geotools.feature.FeatureCollection;\n+import org.geotools.feature.FeatureIterator;\n+import org.geotools.feature.collection.DecoratingFeatureCollection;\n+import org.geotools.feature.collection.DecoratingFeatureIterator;\n+import org.geotools.feature.collection.PushBackFeatureIterator;\n+import org.geotools.feature.type.Types;\n+import org.geotools.filter.AttributeExpressionImpl;\n+import org.geotools.filter.SortByImpl;\n+import org.geotools.metadata.i18n.ErrorKeys;\n+import org.geotools.metadata.i18n.Errors;\n+import org.geotools.process.ProcessException;\n+import org.geotools.process.factory.DescribeParameter;\n+import org.geotools.process.factory.DescribeProcess;\n+import org.geotools.util.factory.GeoTools;\n+import org.opengis.coverage.grid.GridGeometry;\n+import org.opengis.feature.Feature;\n+import org.opengis.feature.type.FeatureType;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.FilterFactory2;\n+import org.opengis.filter.expression.PropertyName;\n+import org.opengis.filter.sort.SortBy;\n+import org.opengis.filter.sort.SortOrder;\n+import org.xml.sax.helpers.NamespaceSupport;\n+\n+@DescribeProcess(\n+    title = \"Filtering Features\",\n+    description =\n+            \"Given a collection of features for each group defined only the feature having the MIN or MAX value for the chosen attribute will be included in the final output\"\n+)\n+public class FilteringVectorProcess implements VectorProcess {\n+\n+    protected FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2(GeoTools.getDefaultHints());\n+\n+    public FeatureCollection execute(\n+            @DescribeParameter(name = \"data\", description = \"Input feature collection\")\n+                    FeatureCollection features,\n+            @DescribeParameter(\n+                        name = \"aggregation\",\n+                        description =\n+                                \"The aggregate operation to be computed, it can be MAX or MIN\",\n+                        min = 1\n+                    )\n+                    String aggregation,\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes) {\n+        try {\n+            if (features == null) {\n+                throw new ProcessException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"features\"));\n+            }\n+            if (operationAttribute == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"operationAttribute\"));\n+            }\n+            if (groupingAttributes == null || groupingAttributes.size() == 0) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"groupingAttributes\"));\n+            }\n+            if (aggregation == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"aggregation\"));\n+            }\n+            Operations op = Operations.valueOf(aggregation);\n+            FeatureType schema = features.getSchema();\n+            NamespaceSupport ns = declareNamespaces(schema);\n+            List<PropertyName> groupingPn =\n+                    groupingAttributes\n+                            .stream()\n+                            .map(\n+                                    g ->\n+                                            validatePropertyName(\n+                                                    new AttributeExpressionImpl(g, ns), schema))\n+                            .collect(Collectors.toList());\n+            PropertyName opValue =\n+                    validatePropertyName(ff.property(operationAttribute, ns), schema);\n+            return new GroupingFeatureCollection(features, groupingPn, opValue, op);\n+        } catch (IllegalArgumentException e) {\n+            throw new ProcessException(\n+                    Errors.format(ErrorKeys.BAD_PARAMETER_$2, \"aggregation\", aggregation));\n+        }\n+    }\n+\n+    public Query invertQuery(\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes,\n+            Query targetQuery,\n+            GridGeometry gridGeometry) {\n+\n+        // optimize the query adding the needed property name to it\n+\n+        List<PropertyName> properties = targetQuery.getProperties();\n+        SortBy[] sorts = targetQuery.getSortBy();\n+\n+        Query q = targetQuery != null ? new Query(targetQuery) : new Query();\n+        // add the sortBy if not present\n+        SortBy[] sortBy = buildNewSortBy(sorts, groupingAttributes);\n+        q.setSortBy(sortBy);\n+\n+        // produces new PropertyName to add to the query\n+        List<PropertyName> propertiesToAdd =\n+                Stream.of(sortBy).map(s -> s.getPropertyName()).collect(Collectors.toList());\n+        propertiesToAdd.add(ff.property(operationAttribute));\n+\n+        // eventually merge with existing ones\n+        List<PropertyName> pns = getNewProperties(propertiesToAdd, properties);\n+        q.setProperties(pns);\n+\n+        // features with null values for groupingAttributes and operationAttribute", "originalCommit": "5efd106ed909fc97db2dc5c828a059ad25fb5ad6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIyNzY0Nw==", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r513227647", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-10-28T07:27:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA2MzU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA2NzQ4NQ==", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r512067485", "bodyText": "Same as above, null is a valid grouping value, in general.", "author": "aaime", "createdAt": "2020-10-26T15:49:55Z", "path": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/FilteringVectorProcess.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ *    GeoTools - The Open Source Java GIS Toolkit\n+ *    http://geotools.org\n+ *\n+ *    (C) 2020, Open Source Geospatial Foundation (OSGeo)\n+ *\n+ *    This library is free software; you can redistribute it and/or\n+ *    modify it under the terms of the GNU Lesser General Public\n+ *    License as published by the Free Software Foundation;\n+ *    version 2.1 of the License.\n+ *\n+ *    This library is distributed in the hope that it will be useful,\n+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ *    Lesser General Public License for more details.\n+ */\n+package org.geotools.process.vector;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.geotools.data.Query;\n+import org.geotools.factory.CommonFactoryFinder;\n+import org.geotools.feature.FeatureCollection;\n+import org.geotools.feature.FeatureIterator;\n+import org.geotools.feature.collection.DecoratingFeatureCollection;\n+import org.geotools.feature.collection.DecoratingFeatureIterator;\n+import org.geotools.feature.collection.PushBackFeatureIterator;\n+import org.geotools.feature.type.Types;\n+import org.geotools.filter.AttributeExpressionImpl;\n+import org.geotools.filter.SortByImpl;\n+import org.geotools.metadata.i18n.ErrorKeys;\n+import org.geotools.metadata.i18n.Errors;\n+import org.geotools.process.ProcessException;\n+import org.geotools.process.factory.DescribeParameter;\n+import org.geotools.process.factory.DescribeProcess;\n+import org.geotools.util.factory.GeoTools;\n+import org.opengis.coverage.grid.GridGeometry;\n+import org.opengis.feature.Feature;\n+import org.opengis.feature.type.FeatureType;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.FilterFactory2;\n+import org.opengis.filter.expression.PropertyName;\n+import org.opengis.filter.sort.SortBy;\n+import org.opengis.filter.sort.SortOrder;\n+import org.xml.sax.helpers.NamespaceSupport;\n+\n+@DescribeProcess(\n+    title = \"Filtering Features\",\n+    description =\n+            \"Given a collection of features for each group defined only the feature having the MIN or MAX value for the chosen attribute will be included in the final output\"\n+)\n+public class FilteringVectorProcess implements VectorProcess {\n+\n+    protected FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2(GeoTools.getDefaultHints());\n+\n+    public FeatureCollection execute(\n+            @DescribeParameter(name = \"data\", description = \"Input feature collection\")\n+                    FeatureCollection features,\n+            @DescribeParameter(\n+                        name = \"aggregation\",\n+                        description =\n+                                \"The aggregate operation to be computed, it can be MAX or MIN\",\n+                        min = 1\n+                    )\n+                    String aggregation,\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes) {\n+        try {\n+            if (features == null) {\n+                throw new ProcessException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"features\"));\n+            }\n+            if (operationAttribute == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"operationAttribute\"));\n+            }\n+            if (groupingAttributes == null || groupingAttributes.size() == 0) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"groupingAttributes\"));\n+            }\n+            if (aggregation == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"aggregation\"));\n+            }\n+            Operations op = Operations.valueOf(aggregation);\n+            FeatureType schema = features.getSchema();\n+            NamespaceSupport ns = declareNamespaces(schema);\n+            List<PropertyName> groupingPn =\n+                    groupingAttributes\n+                            .stream()\n+                            .map(\n+                                    g ->\n+                                            validatePropertyName(\n+                                                    new AttributeExpressionImpl(g, ns), schema))\n+                            .collect(Collectors.toList());\n+            PropertyName opValue =\n+                    validatePropertyName(ff.property(operationAttribute, ns), schema);\n+            return new GroupingFeatureCollection(features, groupingPn, opValue, op);\n+        } catch (IllegalArgumentException e) {\n+            throw new ProcessException(\n+                    Errors.format(ErrorKeys.BAD_PARAMETER_$2, \"aggregation\", aggregation));\n+        }\n+    }\n+\n+    public Query invertQuery(\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes,\n+            Query targetQuery,\n+            GridGeometry gridGeometry) {\n+\n+        // optimize the query adding the needed property name to it\n+\n+        List<PropertyName> properties = targetQuery.getProperties();\n+        SortBy[] sorts = targetQuery.getSortBy();\n+\n+        Query q = targetQuery != null ? new Query(targetQuery) : new Query();\n+        // add the sortBy if not present\n+        SortBy[] sortBy = buildNewSortBy(sorts, groupingAttributes);\n+        q.setSortBy(sortBy);\n+\n+        // produces new PropertyName to add to the query\n+        List<PropertyName> propertiesToAdd =\n+                Stream.of(sortBy).map(s -> s.getPropertyName()).collect(Collectors.toList());\n+        propertiesToAdd.add(ff.property(operationAttribute));\n+\n+        // eventually merge with existing ones\n+        List<PropertyName> pns = getNewProperties(propertiesToAdd, properties);\n+        q.setProperties(pns);\n+\n+        // features with null values for groupingAttributes and operationAttribute\n+        // will not be rendered. Adding not null filters to delegate to the db.\n+        List<Filter> filters = new ArrayList<>();\n+        for (PropertyName pn : propertiesToAdd) {\n+            filters.add(ff.not(ff.isNull(pn)));\n+        }\n+        Filter original = q.getFilter();\n+        if (original != null && !original.equals(Filter.INCLUDE)) filters.add(q.getFilter());\n+        q.setFilter(ff.and(filters));\n+        return q;\n+    }\n+\n+    private SortBy[] buildNewSortBy(SortBy[] sorts, List<String> groupingAttributes) {\n+        // eventually creates new SortBy and add them to the array\n+        List<SortBy> newSorts = new ArrayList<>(groupingAttributes.size());\n+        List<PropertyName> properties =\n+                groupingAttributes.stream().map(s -> ff.property(s)).collect(Collectors.toList());\n+        for (int i = 0; i < properties.size(); i++) {\n+            PropertyName pn = properties.get(i);\n+            if (!sortByAlreadyExists(sorts, pn))\n+                newSorts.add(new SortByImpl(pn, SortOrder.ASCENDING));\n+        }\n+        if (newSorts.size() > 0) {\n+            if (sorts == null) return newSorts.toArray(new SortBy[newSorts.size()]);\n+            else return ArrayUtils.addAll(sorts, newSorts.toArray(new SortBy[newSorts.size()]));\n+        }\n+        return sorts;\n+    }\n+\n+    private List<PropertyName> getNewProperties(\n+            List<PropertyName> toAdd, List<PropertyName> originalProperties) {\n+        Set<PropertyName> properties = new HashSet<>();\n+        if (originalProperties != null) {\n+            properties.addAll(originalProperties);\n+        }\n+        if (toAdd != null) {\n+            properties.addAll(toAdd);\n+        }\n+        return new ArrayList<>(properties);\n+    }\n+\n+    private boolean sortByAlreadyExists(SortBy[] sorts, PropertyName pn) {\n+        if (sorts == null) return false;\n+        for (SortBy s : sorts) {\n+            // just checking the property name. In the context of the rendering\n+            // transformation the sortBy order doesn't matter\n+            if (s.getPropertyName().equals(pn)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private PropertyName validatePropertyName(PropertyName pn, FeatureType schema) {\n+        // checks propertyName against the schema\n+        if (pn.evaluate(schema) == null)\n+            throw new ProcessException(\n+                    \"Unable to resolve \" + pn.getPropertyName() + \" against the FeatureType\");\n+        return pn;\n+    }\n+\n+    private NamespaceSupport declareNamespaces(FeatureType type) {\n+        // retrieves Namespaces for complex features\n+        NamespaceSupport namespaceSupport = null;\n+        Map namespaces = (Map) type.getUserData().get(Types.DECLARED_NAMESPACES_MAP);\n+        if (namespaces != null) {\n+            namespaceSupport = new NamespaceSupport();\n+            for (Iterator it = namespaces.entrySet().iterator(); it.hasNext(); ) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+                String prefix = (String) entry.getKey();\n+                String namespace = (String) entry.getValue();\n+                namespaceSupport.declarePrefix(prefix, namespace);\n+            }\n+        }\n+        return namespaceSupport;\n+    }\n+\n+    /**\n+     * A FeatureCollection wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureCollection\n+            extends DecoratingFeatureCollection<FeatureType, Feature> {\n+\n+        List<PropertyName> groupingAttributes;\n+\n+        PropertyName operationAttribute;\n+\n+        Operations aggregation;\n+\n+        public GroupingFeatureCollection(\n+                FeatureCollection<FeatureType, Feature> delegate,\n+                List<PropertyName> groupingAttributes,\n+                PropertyName operationAttribute,\n+                Operations aggregation) {\n+            super(delegate);\n+            this.groupingAttributes = groupingAttributes;\n+            this.operationAttribute = operationAttribute;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public FeatureIterator<Feature> features() {\n+            return new GroupingFeatureIterator(\n+                    new PushBackFeatureIterator(delegate.features()),\n+                    groupingAttributes,\n+                    operationAttribute,\n+                    aggregation);\n+        }\n+    }\n+\n+    /**\n+     * A FeatureIterator wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureIterator extends DecoratingFeatureIterator<Feature> {\n+\n+        private List<PropertyName> groupByAttributes;\n+\n+        private PropertyName operationAttribute;\n+\n+        private Operations aggregation;\n+\n+        private Feature next;\n+\n+        /**\n+         * Wrap the provided FeatureIterator.\n+         *\n+         * @param iterator Iterator to be used as a delegate.\n+         */\n+        public GroupingFeatureIterator(\n+                PushBackFeatureIterator iterator,\n+                List<PropertyName> groupByAttributes,\n+                PropertyName operationValue,\n+                Operations aggregation) {\n+            super(iterator);\n+            this.groupByAttributes = groupByAttributes;\n+            this.operationAttribute = operationValue;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            List<Object> groupingValues = new ArrayList<>(groupByAttributes.size());\n+            Map<Object, Feature> beingFiltered = new HashMap<>();\n+            List<Double> valuesToCompare = new ArrayList<>();\n+            while (super.hasNext()) {\n+                Feature f = super.next();\n+                if (beingFiltered.size() == 0) {\n+                    // no features in the list this is the first of the group\n+                    // takes the values to check the following features if belong to the same group\n+                    // features with null values are skipped\n+                    if (addGroupingValues(groupingValues, f))\n+                        addDoubleValueFromFeature(f, valuesToCompare, beingFiltered);\n+                } else {\n+                    // is the feature in the group?\n+                    if (featureComparison(groupingValues, f)) {\n+                        addDoubleValueFromFeature(f, valuesToCompare, beingFiltered);\n+                    } else {\n+                        ((PushBackFeatureIterator) delegate).pushBack();\n+                        break;\n+                    }\n+                }\n+            }\n+            next = doFiltering(beingFiltered, valuesToCompare);\n+            return next != null;\n+        }\n+\n+        private Feature doFiltering(\n+                Map<Object, Feature> beingFiltered, List<Double> beingEvaluated) {\n+            Object key;\n+            // searches the min or max inside the values list and retrieve the feature\n+            // to be returned from the Map.\n+            if (beingFiltered.size() > 0 && beingEvaluated.size() > 0) {\n+                if (this.aggregation.equals(Operations.MIN)) key = computeMin(beingEvaluated);\n+                else key = computeMax(beingEvaluated);\n+\n+                return beingFiltered.get(key);\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        private Number computeMin(List<Double> beingEvaluated) {\n+            return Collections.min(beingEvaluated);\n+        }\n+\n+        private Number computeMax(List<Double> beingEvaluated) {\n+            return Collections.max(beingEvaluated);\n+        }\n+\n+        private boolean featureComparison(List<Object> groupingValues, Feature f) {\n+            List<Object> toCompareValues = new ArrayList<>(groupingValues.size());\n+            for (PropertyName p : groupByAttributes) {\n+                toCompareValues.add(p.evaluate(f));\n+            }\n+            if (groupingValues.size() > 0 && groupingValues.equals(toCompareValues)) return true;\n+            return false;\n+        }\n+\n+        private boolean addGroupingValues(List<Object> groupingValues, Feature f) {\n+            for (PropertyName p : groupByAttributes) {\n+                Object result = p.evaluate(f);\n+                if (result != null) groupingValues.add(p.evaluate(f));", "originalCommit": "5efd106ed909fc97db2dc5c828a059ad25fb5ad6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIyNzY5MQ==", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r513227691", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-10-28T07:27:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA2NzQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAwOTU1Ng==", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r515009556", "bodyText": "I can still see a null check in the current code, getGroupingValues method.", "author": "aaime", "createdAt": "2020-10-30T10:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA2NzQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEzMjM1Mw==", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r515132353", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-10-30T14:20:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA2NzQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3MDUxOQ==", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r512070519", "bodyText": "This is not really adding the values to the list, it's more like gathering them. Seems also dangerous, I see no cleaning happening, if a feature is skipped for any reason, the groupingValues would keep on accumulating?\nIMHO better to have this method return a feature list of values, or null if they are not found.", "author": "aaime", "createdAt": "2020-10-26T15:53:45Z", "path": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/FilteringVectorProcess.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ *    GeoTools - The Open Source Java GIS Toolkit\n+ *    http://geotools.org\n+ *\n+ *    (C) 2020, Open Source Geospatial Foundation (OSGeo)\n+ *\n+ *    This library is free software; you can redistribute it and/or\n+ *    modify it under the terms of the GNU Lesser General Public\n+ *    License as published by the Free Software Foundation;\n+ *    version 2.1 of the License.\n+ *\n+ *    This library is distributed in the hope that it will be useful,\n+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ *    Lesser General Public License for more details.\n+ */\n+package org.geotools.process.vector;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.geotools.data.Query;\n+import org.geotools.factory.CommonFactoryFinder;\n+import org.geotools.feature.FeatureCollection;\n+import org.geotools.feature.FeatureIterator;\n+import org.geotools.feature.collection.DecoratingFeatureCollection;\n+import org.geotools.feature.collection.DecoratingFeatureIterator;\n+import org.geotools.feature.collection.PushBackFeatureIterator;\n+import org.geotools.feature.type.Types;\n+import org.geotools.filter.AttributeExpressionImpl;\n+import org.geotools.filter.SortByImpl;\n+import org.geotools.metadata.i18n.ErrorKeys;\n+import org.geotools.metadata.i18n.Errors;\n+import org.geotools.process.ProcessException;\n+import org.geotools.process.factory.DescribeParameter;\n+import org.geotools.process.factory.DescribeProcess;\n+import org.geotools.util.factory.GeoTools;\n+import org.opengis.coverage.grid.GridGeometry;\n+import org.opengis.feature.Feature;\n+import org.opengis.feature.type.FeatureType;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.FilterFactory2;\n+import org.opengis.filter.expression.PropertyName;\n+import org.opengis.filter.sort.SortBy;\n+import org.opengis.filter.sort.SortOrder;\n+import org.xml.sax.helpers.NamespaceSupport;\n+\n+@DescribeProcess(\n+    title = \"Filtering Features\",\n+    description =\n+            \"Given a collection of features for each group defined only the feature having the MIN or MAX value for the chosen attribute will be included in the final output\"\n+)\n+public class FilteringVectorProcess implements VectorProcess {\n+\n+    protected FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2(GeoTools.getDefaultHints());\n+\n+    public FeatureCollection execute(\n+            @DescribeParameter(name = \"data\", description = \"Input feature collection\")\n+                    FeatureCollection features,\n+            @DescribeParameter(\n+                        name = \"aggregation\",\n+                        description =\n+                                \"The aggregate operation to be computed, it can be MAX or MIN\",\n+                        min = 1\n+                    )\n+                    String aggregation,\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes) {\n+        try {\n+            if (features == null) {\n+                throw new ProcessException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"features\"));\n+            }\n+            if (operationAttribute == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"operationAttribute\"));\n+            }\n+            if (groupingAttributes == null || groupingAttributes.size() == 0) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"groupingAttributes\"));\n+            }\n+            if (aggregation == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"aggregation\"));\n+            }\n+            Operations op = Operations.valueOf(aggregation);\n+            FeatureType schema = features.getSchema();\n+            NamespaceSupport ns = declareNamespaces(schema);\n+            List<PropertyName> groupingPn =\n+                    groupingAttributes\n+                            .stream()\n+                            .map(\n+                                    g ->\n+                                            validatePropertyName(\n+                                                    new AttributeExpressionImpl(g, ns), schema))\n+                            .collect(Collectors.toList());\n+            PropertyName opValue =\n+                    validatePropertyName(ff.property(operationAttribute, ns), schema);\n+            return new GroupingFeatureCollection(features, groupingPn, opValue, op);\n+        } catch (IllegalArgumentException e) {\n+            throw new ProcessException(\n+                    Errors.format(ErrorKeys.BAD_PARAMETER_$2, \"aggregation\", aggregation));\n+        }\n+    }\n+\n+    public Query invertQuery(\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes,\n+            Query targetQuery,\n+            GridGeometry gridGeometry) {\n+\n+        // optimize the query adding the needed property name to it\n+\n+        List<PropertyName> properties = targetQuery.getProperties();\n+        SortBy[] sorts = targetQuery.getSortBy();\n+\n+        Query q = targetQuery != null ? new Query(targetQuery) : new Query();\n+        // add the sortBy if not present\n+        SortBy[] sortBy = buildNewSortBy(sorts, groupingAttributes);\n+        q.setSortBy(sortBy);\n+\n+        // produces new PropertyName to add to the query\n+        List<PropertyName> propertiesToAdd =\n+                Stream.of(sortBy).map(s -> s.getPropertyName()).collect(Collectors.toList());\n+        propertiesToAdd.add(ff.property(operationAttribute));\n+\n+        // eventually merge with existing ones\n+        List<PropertyName> pns = getNewProperties(propertiesToAdd, properties);\n+        q.setProperties(pns);\n+\n+        // features with null values for groupingAttributes and operationAttribute\n+        // will not be rendered. Adding not null filters to delegate to the db.\n+        List<Filter> filters = new ArrayList<>();\n+        for (PropertyName pn : propertiesToAdd) {\n+            filters.add(ff.not(ff.isNull(pn)));\n+        }\n+        Filter original = q.getFilter();\n+        if (original != null && !original.equals(Filter.INCLUDE)) filters.add(q.getFilter());\n+        q.setFilter(ff.and(filters));\n+        return q;\n+    }\n+\n+    private SortBy[] buildNewSortBy(SortBy[] sorts, List<String> groupingAttributes) {\n+        // eventually creates new SortBy and add them to the array\n+        List<SortBy> newSorts = new ArrayList<>(groupingAttributes.size());\n+        List<PropertyName> properties =\n+                groupingAttributes.stream().map(s -> ff.property(s)).collect(Collectors.toList());\n+        for (int i = 0; i < properties.size(); i++) {\n+            PropertyName pn = properties.get(i);\n+            if (!sortByAlreadyExists(sorts, pn))\n+                newSorts.add(new SortByImpl(pn, SortOrder.ASCENDING));\n+        }\n+        if (newSorts.size() > 0) {\n+            if (sorts == null) return newSorts.toArray(new SortBy[newSorts.size()]);\n+            else return ArrayUtils.addAll(sorts, newSorts.toArray(new SortBy[newSorts.size()]));\n+        }\n+        return sorts;\n+    }\n+\n+    private List<PropertyName> getNewProperties(\n+            List<PropertyName> toAdd, List<PropertyName> originalProperties) {\n+        Set<PropertyName> properties = new HashSet<>();\n+        if (originalProperties != null) {\n+            properties.addAll(originalProperties);\n+        }\n+        if (toAdd != null) {\n+            properties.addAll(toAdd);\n+        }\n+        return new ArrayList<>(properties);\n+    }\n+\n+    private boolean sortByAlreadyExists(SortBy[] sorts, PropertyName pn) {\n+        if (sorts == null) return false;\n+        for (SortBy s : sorts) {\n+            // just checking the property name. In the context of the rendering\n+            // transformation the sortBy order doesn't matter\n+            if (s.getPropertyName().equals(pn)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private PropertyName validatePropertyName(PropertyName pn, FeatureType schema) {\n+        // checks propertyName against the schema\n+        if (pn.evaluate(schema) == null)\n+            throw new ProcessException(\n+                    \"Unable to resolve \" + pn.getPropertyName() + \" against the FeatureType\");\n+        return pn;\n+    }\n+\n+    private NamespaceSupport declareNamespaces(FeatureType type) {\n+        // retrieves Namespaces for complex features\n+        NamespaceSupport namespaceSupport = null;\n+        Map namespaces = (Map) type.getUserData().get(Types.DECLARED_NAMESPACES_MAP);\n+        if (namespaces != null) {\n+            namespaceSupport = new NamespaceSupport();\n+            for (Iterator it = namespaces.entrySet().iterator(); it.hasNext(); ) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+                String prefix = (String) entry.getKey();\n+                String namespace = (String) entry.getValue();\n+                namespaceSupport.declarePrefix(prefix, namespace);\n+            }\n+        }\n+        return namespaceSupport;\n+    }\n+\n+    /**\n+     * A FeatureCollection wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureCollection\n+            extends DecoratingFeatureCollection<FeatureType, Feature> {\n+\n+        List<PropertyName> groupingAttributes;\n+\n+        PropertyName operationAttribute;\n+\n+        Operations aggregation;\n+\n+        public GroupingFeatureCollection(\n+                FeatureCollection<FeatureType, Feature> delegate,\n+                List<PropertyName> groupingAttributes,\n+                PropertyName operationAttribute,\n+                Operations aggregation) {\n+            super(delegate);\n+            this.groupingAttributes = groupingAttributes;\n+            this.operationAttribute = operationAttribute;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public FeatureIterator<Feature> features() {\n+            return new GroupingFeatureIterator(\n+                    new PushBackFeatureIterator(delegate.features()),\n+                    groupingAttributes,\n+                    operationAttribute,\n+                    aggregation);\n+        }\n+    }\n+\n+    /**\n+     * A FeatureIterator wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureIterator extends DecoratingFeatureIterator<Feature> {\n+\n+        private List<PropertyName> groupByAttributes;\n+\n+        private PropertyName operationAttribute;\n+\n+        private Operations aggregation;\n+\n+        private Feature next;\n+\n+        /**\n+         * Wrap the provided FeatureIterator.\n+         *\n+         * @param iterator Iterator to be used as a delegate.\n+         */\n+        public GroupingFeatureIterator(\n+                PushBackFeatureIterator iterator,\n+                List<PropertyName> groupByAttributes,\n+                PropertyName operationValue,\n+                Operations aggregation) {\n+            super(iterator);\n+            this.groupByAttributes = groupByAttributes;\n+            this.operationAttribute = operationValue;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            List<Object> groupingValues = new ArrayList<>(groupByAttributes.size());\n+            Map<Object, Feature> beingFiltered = new HashMap<>();\n+            List<Double> valuesToCompare = new ArrayList<>();\n+            while (super.hasNext()) {\n+                Feature f = super.next();\n+                if (beingFiltered.size() == 0) {\n+                    // no features in the list this is the first of the group\n+                    // takes the values to check the following features if belong to the same group\n+                    // features with null values are skipped\n+                    if (addGroupingValues(groupingValues, f))\n+                        addDoubleValueFromFeature(f, valuesToCompare, beingFiltered);\n+                } else {\n+                    // is the feature in the group?\n+                    if (featureComparison(groupingValues, f)) {\n+                        addDoubleValueFromFeature(f, valuesToCompare, beingFiltered);\n+                    } else {\n+                        ((PushBackFeatureIterator) delegate).pushBack();\n+                        break;\n+                    }\n+                }\n+            }\n+            next = doFiltering(beingFiltered, valuesToCompare);\n+            return next != null;\n+        }\n+\n+        private Feature doFiltering(\n+                Map<Object, Feature> beingFiltered, List<Double> beingEvaluated) {\n+            Object key;\n+            // searches the min or max inside the values list and retrieve the feature\n+            // to be returned from the Map.\n+            if (beingFiltered.size() > 0 && beingEvaluated.size() > 0) {\n+                if (this.aggregation.equals(Operations.MIN)) key = computeMin(beingEvaluated);\n+                else key = computeMax(beingEvaluated);\n+\n+                return beingFiltered.get(key);\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        private Number computeMin(List<Double> beingEvaluated) {\n+            return Collections.min(beingEvaluated);\n+        }\n+\n+        private Number computeMax(List<Double> beingEvaluated) {\n+            return Collections.max(beingEvaluated);\n+        }\n+\n+        private boolean featureComparison(List<Object> groupingValues, Feature f) {\n+            List<Object> toCompareValues = new ArrayList<>(groupingValues.size());\n+            for (PropertyName p : groupByAttributes) {\n+                toCompareValues.add(p.evaluate(f));\n+            }\n+            if (groupingValues.size() > 0 && groupingValues.equals(toCompareValues)) return true;\n+            return false;\n+        }\n+\n+        private boolean addGroupingValues(List<Object> groupingValues, Feature f) {", "originalCommit": "5efd106ed909fc97db2dc5c828a059ad25fb5ad6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIyNzc2NQ==", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r513227765", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-10-28T07:27:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3MDUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3MTE1NQ==", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r512071155", "bodyText": "Why do they need to be doubles? Any object supporting equals would work as a grouping mechanism here.", "author": "aaime", "createdAt": "2020-10-26T15:54:36Z", "path": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/FilteringVectorProcess.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ *    GeoTools - The Open Source Java GIS Toolkit\n+ *    http://geotools.org\n+ *\n+ *    (C) 2020, Open Source Geospatial Foundation (OSGeo)\n+ *\n+ *    This library is free software; you can redistribute it and/or\n+ *    modify it under the terms of the GNU Lesser General Public\n+ *    License as published by the Free Software Foundation;\n+ *    version 2.1 of the License.\n+ *\n+ *    This library is distributed in the hope that it will be useful,\n+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ *    Lesser General Public License for more details.\n+ */\n+package org.geotools.process.vector;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.geotools.data.Query;\n+import org.geotools.factory.CommonFactoryFinder;\n+import org.geotools.feature.FeatureCollection;\n+import org.geotools.feature.FeatureIterator;\n+import org.geotools.feature.collection.DecoratingFeatureCollection;\n+import org.geotools.feature.collection.DecoratingFeatureIterator;\n+import org.geotools.feature.collection.PushBackFeatureIterator;\n+import org.geotools.feature.type.Types;\n+import org.geotools.filter.AttributeExpressionImpl;\n+import org.geotools.filter.SortByImpl;\n+import org.geotools.metadata.i18n.ErrorKeys;\n+import org.geotools.metadata.i18n.Errors;\n+import org.geotools.process.ProcessException;\n+import org.geotools.process.factory.DescribeParameter;\n+import org.geotools.process.factory.DescribeProcess;\n+import org.geotools.util.factory.GeoTools;\n+import org.opengis.coverage.grid.GridGeometry;\n+import org.opengis.feature.Feature;\n+import org.opengis.feature.type.FeatureType;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.FilterFactory2;\n+import org.opengis.filter.expression.PropertyName;\n+import org.opengis.filter.sort.SortBy;\n+import org.opengis.filter.sort.SortOrder;\n+import org.xml.sax.helpers.NamespaceSupport;\n+\n+@DescribeProcess(\n+    title = \"Filtering Features\",\n+    description =\n+            \"Given a collection of features for each group defined only the feature having the MIN or MAX value for the chosen attribute will be included in the final output\"\n+)\n+public class FilteringVectorProcess implements VectorProcess {\n+\n+    protected FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2(GeoTools.getDefaultHints());\n+\n+    public FeatureCollection execute(\n+            @DescribeParameter(name = \"data\", description = \"Input feature collection\")\n+                    FeatureCollection features,\n+            @DescribeParameter(\n+                        name = \"aggregation\",\n+                        description =\n+                                \"The aggregate operation to be computed, it can be MAX or MIN\",\n+                        min = 1\n+                    )\n+                    String aggregation,\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes) {\n+        try {\n+            if (features == null) {\n+                throw new ProcessException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"features\"));\n+            }\n+            if (operationAttribute == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"operationAttribute\"));\n+            }\n+            if (groupingAttributes == null || groupingAttributes.size() == 0) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"groupingAttributes\"));\n+            }\n+            if (aggregation == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"aggregation\"));\n+            }\n+            Operations op = Operations.valueOf(aggregation);\n+            FeatureType schema = features.getSchema();\n+            NamespaceSupport ns = declareNamespaces(schema);\n+            List<PropertyName> groupingPn =\n+                    groupingAttributes\n+                            .stream()\n+                            .map(\n+                                    g ->\n+                                            validatePropertyName(\n+                                                    new AttributeExpressionImpl(g, ns), schema))\n+                            .collect(Collectors.toList());\n+            PropertyName opValue =\n+                    validatePropertyName(ff.property(operationAttribute, ns), schema);\n+            return new GroupingFeatureCollection(features, groupingPn, opValue, op);\n+        } catch (IllegalArgumentException e) {\n+            throw new ProcessException(\n+                    Errors.format(ErrorKeys.BAD_PARAMETER_$2, \"aggregation\", aggregation));\n+        }\n+    }\n+\n+    public Query invertQuery(\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes,\n+            Query targetQuery,\n+            GridGeometry gridGeometry) {\n+\n+        // optimize the query adding the needed property name to it\n+\n+        List<PropertyName> properties = targetQuery.getProperties();\n+        SortBy[] sorts = targetQuery.getSortBy();\n+\n+        Query q = targetQuery != null ? new Query(targetQuery) : new Query();\n+        // add the sortBy if not present\n+        SortBy[] sortBy = buildNewSortBy(sorts, groupingAttributes);\n+        q.setSortBy(sortBy);\n+\n+        // produces new PropertyName to add to the query\n+        List<PropertyName> propertiesToAdd =\n+                Stream.of(sortBy).map(s -> s.getPropertyName()).collect(Collectors.toList());\n+        propertiesToAdd.add(ff.property(operationAttribute));\n+\n+        // eventually merge with existing ones\n+        List<PropertyName> pns = getNewProperties(propertiesToAdd, properties);\n+        q.setProperties(pns);\n+\n+        // features with null values for groupingAttributes and operationAttribute\n+        // will not be rendered. Adding not null filters to delegate to the db.\n+        List<Filter> filters = new ArrayList<>();\n+        for (PropertyName pn : propertiesToAdd) {\n+            filters.add(ff.not(ff.isNull(pn)));\n+        }\n+        Filter original = q.getFilter();\n+        if (original != null && !original.equals(Filter.INCLUDE)) filters.add(q.getFilter());\n+        q.setFilter(ff.and(filters));\n+        return q;\n+    }\n+\n+    private SortBy[] buildNewSortBy(SortBy[] sorts, List<String> groupingAttributes) {\n+        // eventually creates new SortBy and add them to the array\n+        List<SortBy> newSorts = new ArrayList<>(groupingAttributes.size());\n+        List<PropertyName> properties =\n+                groupingAttributes.stream().map(s -> ff.property(s)).collect(Collectors.toList());\n+        for (int i = 0; i < properties.size(); i++) {\n+            PropertyName pn = properties.get(i);\n+            if (!sortByAlreadyExists(sorts, pn))\n+                newSorts.add(new SortByImpl(pn, SortOrder.ASCENDING));\n+        }\n+        if (newSorts.size() > 0) {\n+            if (sorts == null) return newSorts.toArray(new SortBy[newSorts.size()]);\n+            else return ArrayUtils.addAll(sorts, newSorts.toArray(new SortBy[newSorts.size()]));\n+        }\n+        return sorts;\n+    }\n+\n+    private List<PropertyName> getNewProperties(\n+            List<PropertyName> toAdd, List<PropertyName> originalProperties) {\n+        Set<PropertyName> properties = new HashSet<>();\n+        if (originalProperties != null) {\n+            properties.addAll(originalProperties);\n+        }\n+        if (toAdd != null) {\n+            properties.addAll(toAdd);\n+        }\n+        return new ArrayList<>(properties);\n+    }\n+\n+    private boolean sortByAlreadyExists(SortBy[] sorts, PropertyName pn) {\n+        if (sorts == null) return false;\n+        for (SortBy s : sorts) {\n+            // just checking the property name. In the context of the rendering\n+            // transformation the sortBy order doesn't matter\n+            if (s.getPropertyName().equals(pn)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private PropertyName validatePropertyName(PropertyName pn, FeatureType schema) {\n+        // checks propertyName against the schema\n+        if (pn.evaluate(schema) == null)\n+            throw new ProcessException(\n+                    \"Unable to resolve \" + pn.getPropertyName() + \" against the FeatureType\");\n+        return pn;\n+    }\n+\n+    private NamespaceSupport declareNamespaces(FeatureType type) {\n+        // retrieves Namespaces for complex features\n+        NamespaceSupport namespaceSupport = null;\n+        Map namespaces = (Map) type.getUserData().get(Types.DECLARED_NAMESPACES_MAP);\n+        if (namespaces != null) {\n+            namespaceSupport = new NamespaceSupport();\n+            for (Iterator it = namespaces.entrySet().iterator(); it.hasNext(); ) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+                String prefix = (String) entry.getKey();\n+                String namespace = (String) entry.getValue();\n+                namespaceSupport.declarePrefix(prefix, namespace);\n+            }\n+        }\n+        return namespaceSupport;\n+    }\n+\n+    /**\n+     * A FeatureCollection wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureCollection\n+            extends DecoratingFeatureCollection<FeatureType, Feature> {\n+\n+        List<PropertyName> groupingAttributes;\n+\n+        PropertyName operationAttribute;\n+\n+        Operations aggregation;\n+\n+        public GroupingFeatureCollection(\n+                FeatureCollection<FeatureType, Feature> delegate,\n+                List<PropertyName> groupingAttributes,\n+                PropertyName operationAttribute,\n+                Operations aggregation) {\n+            super(delegate);\n+            this.groupingAttributes = groupingAttributes;\n+            this.operationAttribute = operationAttribute;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public FeatureIterator<Feature> features() {\n+            return new GroupingFeatureIterator(\n+                    new PushBackFeatureIterator(delegate.features()),\n+                    groupingAttributes,\n+                    operationAttribute,\n+                    aggregation);\n+        }\n+    }\n+\n+    /**\n+     * A FeatureIterator wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureIterator extends DecoratingFeatureIterator<Feature> {\n+\n+        private List<PropertyName> groupByAttributes;\n+\n+        private PropertyName operationAttribute;\n+\n+        private Operations aggregation;\n+\n+        private Feature next;\n+\n+        /**\n+         * Wrap the provided FeatureIterator.\n+         *\n+         * @param iterator Iterator to be used as a delegate.\n+         */\n+        public GroupingFeatureIterator(\n+                PushBackFeatureIterator iterator,\n+                List<PropertyName> groupByAttributes,\n+                PropertyName operationValue,\n+                Operations aggregation) {\n+            super(iterator);\n+            this.groupByAttributes = groupByAttributes;\n+            this.operationAttribute = operationValue;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            List<Object> groupingValues = new ArrayList<>(groupByAttributes.size());\n+            Map<Object, Feature> beingFiltered = new HashMap<>();\n+            List<Double> valuesToCompare = new ArrayList<>();", "originalCommit": "5efd106ed909fc97db2dc5c828a059ad25fb5ad6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIyNzgyNw==", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r513227827", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-10-28T07:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3MTE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3MTc0Ng==", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r512071746", "bodyText": "Why in the world is that? Any Comparable will do no?", "author": "aaime", "createdAt": "2020-10-26T15:55:15Z", "path": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/FilteringVectorProcess.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ *    GeoTools - The Open Source Java GIS Toolkit\n+ *    http://geotools.org\n+ *\n+ *    (C) 2020, Open Source Geospatial Foundation (OSGeo)\n+ *\n+ *    This library is free software; you can redistribute it and/or\n+ *    modify it under the terms of the GNU Lesser General Public\n+ *    License as published by the Free Software Foundation;\n+ *    version 2.1 of the License.\n+ *\n+ *    This library is distributed in the hope that it will be useful,\n+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ *    Lesser General Public License for more details.\n+ */\n+package org.geotools.process.vector;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.geotools.data.Query;\n+import org.geotools.factory.CommonFactoryFinder;\n+import org.geotools.feature.FeatureCollection;\n+import org.geotools.feature.FeatureIterator;\n+import org.geotools.feature.collection.DecoratingFeatureCollection;\n+import org.geotools.feature.collection.DecoratingFeatureIterator;\n+import org.geotools.feature.collection.PushBackFeatureIterator;\n+import org.geotools.feature.type.Types;\n+import org.geotools.filter.AttributeExpressionImpl;\n+import org.geotools.filter.SortByImpl;\n+import org.geotools.metadata.i18n.ErrorKeys;\n+import org.geotools.metadata.i18n.Errors;\n+import org.geotools.process.ProcessException;\n+import org.geotools.process.factory.DescribeParameter;\n+import org.geotools.process.factory.DescribeProcess;\n+import org.geotools.util.factory.GeoTools;\n+import org.opengis.coverage.grid.GridGeometry;\n+import org.opengis.feature.Feature;\n+import org.opengis.feature.type.FeatureType;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.FilterFactory2;\n+import org.opengis.filter.expression.PropertyName;\n+import org.opengis.filter.sort.SortBy;\n+import org.opengis.filter.sort.SortOrder;\n+import org.xml.sax.helpers.NamespaceSupport;\n+\n+@DescribeProcess(\n+    title = \"Filtering Features\",\n+    description =\n+            \"Given a collection of features for each group defined only the feature having the MIN or MAX value for the chosen attribute will be included in the final output\"\n+)\n+public class FilteringVectorProcess implements VectorProcess {\n+\n+    protected FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2(GeoTools.getDefaultHints());\n+\n+    public FeatureCollection execute(\n+            @DescribeParameter(name = \"data\", description = \"Input feature collection\")\n+                    FeatureCollection features,\n+            @DescribeParameter(\n+                        name = \"aggregation\",\n+                        description =\n+                                \"The aggregate operation to be computed, it can be MAX or MIN\",\n+                        min = 1\n+                    )\n+                    String aggregation,\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes) {\n+        try {\n+            if (features == null) {\n+                throw new ProcessException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"features\"));\n+            }\n+            if (operationAttribute == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"operationAttribute\"));\n+            }\n+            if (groupingAttributes == null || groupingAttributes.size() == 0) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"groupingAttributes\"));\n+            }\n+            if (aggregation == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"aggregation\"));\n+            }\n+            Operations op = Operations.valueOf(aggregation);\n+            FeatureType schema = features.getSchema();\n+            NamespaceSupport ns = declareNamespaces(schema);\n+            List<PropertyName> groupingPn =\n+                    groupingAttributes\n+                            .stream()\n+                            .map(\n+                                    g ->\n+                                            validatePropertyName(\n+                                                    new AttributeExpressionImpl(g, ns), schema))\n+                            .collect(Collectors.toList());\n+            PropertyName opValue =\n+                    validatePropertyName(ff.property(operationAttribute, ns), schema);\n+            return new GroupingFeatureCollection(features, groupingPn, opValue, op);\n+        } catch (IllegalArgumentException e) {\n+            throw new ProcessException(\n+                    Errors.format(ErrorKeys.BAD_PARAMETER_$2, \"aggregation\", aggregation));\n+        }\n+    }\n+\n+    public Query invertQuery(\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes,\n+            Query targetQuery,\n+            GridGeometry gridGeometry) {\n+\n+        // optimize the query adding the needed property name to it\n+\n+        List<PropertyName> properties = targetQuery.getProperties();\n+        SortBy[] sorts = targetQuery.getSortBy();\n+\n+        Query q = targetQuery != null ? new Query(targetQuery) : new Query();\n+        // add the sortBy if not present\n+        SortBy[] sortBy = buildNewSortBy(sorts, groupingAttributes);\n+        q.setSortBy(sortBy);\n+\n+        // produces new PropertyName to add to the query\n+        List<PropertyName> propertiesToAdd =\n+                Stream.of(sortBy).map(s -> s.getPropertyName()).collect(Collectors.toList());\n+        propertiesToAdd.add(ff.property(operationAttribute));\n+\n+        // eventually merge with existing ones\n+        List<PropertyName> pns = getNewProperties(propertiesToAdd, properties);\n+        q.setProperties(pns);\n+\n+        // features with null values for groupingAttributes and operationAttribute\n+        // will not be rendered. Adding not null filters to delegate to the db.\n+        List<Filter> filters = new ArrayList<>();\n+        for (PropertyName pn : propertiesToAdd) {\n+            filters.add(ff.not(ff.isNull(pn)));\n+        }\n+        Filter original = q.getFilter();\n+        if (original != null && !original.equals(Filter.INCLUDE)) filters.add(q.getFilter());\n+        q.setFilter(ff.and(filters));\n+        return q;\n+    }\n+\n+    private SortBy[] buildNewSortBy(SortBy[] sorts, List<String> groupingAttributes) {\n+        // eventually creates new SortBy and add them to the array\n+        List<SortBy> newSorts = new ArrayList<>(groupingAttributes.size());\n+        List<PropertyName> properties =\n+                groupingAttributes.stream().map(s -> ff.property(s)).collect(Collectors.toList());\n+        for (int i = 0; i < properties.size(); i++) {\n+            PropertyName pn = properties.get(i);\n+            if (!sortByAlreadyExists(sorts, pn))\n+                newSorts.add(new SortByImpl(pn, SortOrder.ASCENDING));\n+        }\n+        if (newSorts.size() > 0) {\n+            if (sorts == null) return newSorts.toArray(new SortBy[newSorts.size()]);\n+            else return ArrayUtils.addAll(sorts, newSorts.toArray(new SortBy[newSorts.size()]));\n+        }\n+        return sorts;\n+    }\n+\n+    private List<PropertyName> getNewProperties(\n+            List<PropertyName> toAdd, List<PropertyName> originalProperties) {\n+        Set<PropertyName> properties = new HashSet<>();\n+        if (originalProperties != null) {\n+            properties.addAll(originalProperties);\n+        }\n+        if (toAdd != null) {\n+            properties.addAll(toAdd);\n+        }\n+        return new ArrayList<>(properties);\n+    }\n+\n+    private boolean sortByAlreadyExists(SortBy[] sorts, PropertyName pn) {\n+        if (sorts == null) return false;\n+        for (SortBy s : sorts) {\n+            // just checking the property name. In the context of the rendering\n+            // transformation the sortBy order doesn't matter\n+            if (s.getPropertyName().equals(pn)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private PropertyName validatePropertyName(PropertyName pn, FeatureType schema) {\n+        // checks propertyName against the schema\n+        if (pn.evaluate(schema) == null)\n+            throw new ProcessException(\n+                    \"Unable to resolve \" + pn.getPropertyName() + \" against the FeatureType\");\n+        return pn;\n+    }\n+\n+    private NamespaceSupport declareNamespaces(FeatureType type) {\n+        // retrieves Namespaces for complex features\n+        NamespaceSupport namespaceSupport = null;\n+        Map namespaces = (Map) type.getUserData().get(Types.DECLARED_NAMESPACES_MAP);\n+        if (namespaces != null) {\n+            namespaceSupport = new NamespaceSupport();\n+            for (Iterator it = namespaces.entrySet().iterator(); it.hasNext(); ) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+                String prefix = (String) entry.getKey();\n+                String namespace = (String) entry.getValue();\n+                namespaceSupport.declarePrefix(prefix, namespace);\n+            }\n+        }\n+        return namespaceSupport;\n+    }\n+\n+    /**\n+     * A FeatureCollection wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureCollection\n+            extends DecoratingFeatureCollection<FeatureType, Feature> {\n+\n+        List<PropertyName> groupingAttributes;\n+\n+        PropertyName operationAttribute;\n+\n+        Operations aggregation;\n+\n+        public GroupingFeatureCollection(\n+                FeatureCollection<FeatureType, Feature> delegate,\n+                List<PropertyName> groupingAttributes,\n+                PropertyName operationAttribute,\n+                Operations aggregation) {\n+            super(delegate);\n+            this.groupingAttributes = groupingAttributes;\n+            this.operationAttribute = operationAttribute;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public FeatureIterator<Feature> features() {\n+            return new GroupingFeatureIterator(\n+                    new PushBackFeatureIterator(delegate.features()),\n+                    groupingAttributes,\n+                    operationAttribute,\n+                    aggregation);\n+        }\n+    }\n+\n+    /**\n+     * A FeatureIterator wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureIterator extends DecoratingFeatureIterator<Feature> {\n+\n+        private List<PropertyName> groupByAttributes;\n+\n+        private PropertyName operationAttribute;\n+\n+        private Operations aggregation;\n+\n+        private Feature next;\n+\n+        /**\n+         * Wrap the provided FeatureIterator.\n+         *\n+         * @param iterator Iterator to be used as a delegate.\n+         */\n+        public GroupingFeatureIterator(\n+                PushBackFeatureIterator iterator,\n+                List<PropertyName> groupByAttributes,\n+                PropertyName operationValue,\n+                Operations aggregation) {\n+            super(iterator);\n+            this.groupByAttributes = groupByAttributes;\n+            this.operationAttribute = operationValue;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            List<Object> groupingValues = new ArrayList<>(groupByAttributes.size());\n+            Map<Object, Feature> beingFiltered = new HashMap<>();\n+            List<Double> valuesToCompare = new ArrayList<>();\n+            while (super.hasNext()) {\n+                Feature f = super.next();\n+                if (beingFiltered.size() == 0) {\n+                    // no features in the list this is the first of the group\n+                    // takes the values to check the following features if belong to the same group\n+                    // features with null values are skipped\n+                    if (addGroupingValues(groupingValues, f))\n+                        addDoubleValueFromFeature(f, valuesToCompare, beingFiltered);\n+                } else {\n+                    // is the feature in the group?\n+                    if (featureComparison(groupingValues, f)) {\n+                        addDoubleValueFromFeature(f, valuesToCompare, beingFiltered);\n+                    } else {\n+                        ((PushBackFeatureIterator) delegate).pushBack();\n+                        break;\n+                    }\n+                }\n+            }\n+            next = doFiltering(beingFiltered, valuesToCompare);\n+            return next != null;\n+        }\n+\n+        private Feature doFiltering(\n+                Map<Object, Feature> beingFiltered, List<Double> beingEvaluated) {\n+            Object key;\n+            // searches the min or max inside the values list and retrieve the feature\n+            // to be returned from the Map.\n+            if (beingFiltered.size() > 0 && beingEvaluated.size() > 0) {\n+                if (this.aggregation.equals(Operations.MIN)) key = computeMin(beingEvaluated);\n+                else key = computeMax(beingEvaluated);\n+\n+                return beingFiltered.get(key);\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        private Number computeMin(List<Double> beingEvaluated) {\n+            return Collections.min(beingEvaluated);\n+        }\n+\n+        private Number computeMax(List<Double> beingEvaluated) {\n+            return Collections.max(beingEvaluated);\n+        }\n+\n+        private boolean featureComparison(List<Object> groupingValues, Feature f) {\n+            List<Object> toCompareValues = new ArrayList<>(groupingValues.size());\n+            for (PropertyName p : groupByAttributes) {\n+                toCompareValues.add(p.evaluate(f));\n+            }\n+            if (groupingValues.size() > 0 && groupingValues.equals(toCompareValues)) return true;\n+            return false;\n+        }\n+\n+        private boolean addGroupingValues(List<Object> groupingValues, Feature f) {\n+            for (PropertyName p : groupByAttributes) {\n+                Object result = p.evaluate(f);\n+                if (result != null) groupingValues.add(p.evaluate(f));\n+            }\n+            if (groupingValues.isEmpty() || groupingValues.size() < groupByAttributes.size())\n+                return false;\n+            return true;\n+        }\n+\n+        private void addDoubleValueFromFeature(\n+                Feature f, List<Double> valuesToCompare, Map<Object, Feature> beingFiltered) {\n+            Object result = this.operationAttribute.evaluate(f, Number.class);\n+            if (result instanceof Number) {\n+                Double value = ((Number) result).doubleValue();\n+                valuesToCompare.add(value);\n+                beingFiltered.put(value, f);\n+\n+            } else {\n+                if (result != null)\n+                    // not a numeric value. Throwing exception\n+                    throw new ProcessException(", "originalCommit": "5efd106ed909fc97db2dc5c828a059ad25fb5ad6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIyODM4Mw==", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r513228383", "bodyText": "Using Comparable now.  In case of ComplexFeatures the evaluation without providing a Context will return a Property. Added some code to check the type and eventually return the Property value as a comparable", "author": "taba90", "createdAt": "2020-10-28T07:29:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3MTc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3MzI3Mg==", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r512073272", "bodyText": "Accumulating features in memory like this is dangerous, could lead to OOM if the groups are large, if all the operations needed are min and max, just keep track of the current value and current feature, and replace if the new feature is \"better\" than the old one. No need to keep the entire list. Then the method could be renamed to something like \"updateSelection\" or something like that.", "author": "aaime", "createdAt": "2020-10-26T15:57:11Z", "path": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/FilteringVectorProcess.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ *    GeoTools - The Open Source Java GIS Toolkit\n+ *    http://geotools.org\n+ *\n+ *    (C) 2020, Open Source Geospatial Foundation (OSGeo)\n+ *\n+ *    This library is free software; you can redistribute it and/or\n+ *    modify it under the terms of the GNU Lesser General Public\n+ *    License as published by the Free Software Foundation;\n+ *    version 2.1 of the License.\n+ *\n+ *    This library is distributed in the hope that it will be useful,\n+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ *    Lesser General Public License for more details.\n+ */\n+package org.geotools.process.vector;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.geotools.data.Query;\n+import org.geotools.factory.CommonFactoryFinder;\n+import org.geotools.feature.FeatureCollection;\n+import org.geotools.feature.FeatureIterator;\n+import org.geotools.feature.collection.DecoratingFeatureCollection;\n+import org.geotools.feature.collection.DecoratingFeatureIterator;\n+import org.geotools.feature.collection.PushBackFeatureIterator;\n+import org.geotools.feature.type.Types;\n+import org.geotools.filter.AttributeExpressionImpl;\n+import org.geotools.filter.SortByImpl;\n+import org.geotools.metadata.i18n.ErrorKeys;\n+import org.geotools.metadata.i18n.Errors;\n+import org.geotools.process.ProcessException;\n+import org.geotools.process.factory.DescribeParameter;\n+import org.geotools.process.factory.DescribeProcess;\n+import org.geotools.util.factory.GeoTools;\n+import org.opengis.coverage.grid.GridGeometry;\n+import org.opengis.feature.Feature;\n+import org.opengis.feature.type.FeatureType;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.FilterFactory2;\n+import org.opengis.filter.expression.PropertyName;\n+import org.opengis.filter.sort.SortBy;\n+import org.opengis.filter.sort.SortOrder;\n+import org.xml.sax.helpers.NamespaceSupport;\n+\n+@DescribeProcess(\n+    title = \"Filtering Features\",\n+    description =\n+            \"Given a collection of features for each group defined only the feature having the MIN or MAX value for the chosen attribute will be included in the final output\"\n+)\n+public class FilteringVectorProcess implements VectorProcess {\n+\n+    protected FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2(GeoTools.getDefaultHints());\n+\n+    public FeatureCollection execute(\n+            @DescribeParameter(name = \"data\", description = \"Input feature collection\")\n+                    FeatureCollection features,\n+            @DescribeParameter(\n+                        name = \"aggregation\",\n+                        description =\n+                                \"The aggregate operation to be computed, it can be MAX or MIN\",\n+                        min = 1\n+                    )\n+                    String aggregation,\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes) {\n+        try {\n+            if (features == null) {\n+                throw new ProcessException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"features\"));\n+            }\n+            if (operationAttribute == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"operationAttribute\"));\n+            }\n+            if (groupingAttributes == null || groupingAttributes.size() == 0) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"groupingAttributes\"));\n+            }\n+            if (aggregation == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"aggregation\"));\n+            }\n+            Operations op = Operations.valueOf(aggregation);\n+            FeatureType schema = features.getSchema();\n+            NamespaceSupport ns = declareNamespaces(schema);\n+            List<PropertyName> groupingPn =\n+                    groupingAttributes\n+                            .stream()\n+                            .map(\n+                                    g ->\n+                                            validatePropertyName(\n+                                                    new AttributeExpressionImpl(g, ns), schema))\n+                            .collect(Collectors.toList());\n+            PropertyName opValue =\n+                    validatePropertyName(ff.property(operationAttribute, ns), schema);\n+            return new GroupingFeatureCollection(features, groupingPn, opValue, op);\n+        } catch (IllegalArgumentException e) {\n+            throw new ProcessException(\n+                    Errors.format(ErrorKeys.BAD_PARAMETER_$2, \"aggregation\", aggregation));\n+        }\n+    }\n+\n+    public Query invertQuery(\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes,\n+            Query targetQuery,\n+            GridGeometry gridGeometry) {\n+\n+        // optimize the query adding the needed property name to it\n+\n+        List<PropertyName> properties = targetQuery.getProperties();\n+        SortBy[] sorts = targetQuery.getSortBy();\n+\n+        Query q = targetQuery != null ? new Query(targetQuery) : new Query();\n+        // add the sortBy if not present\n+        SortBy[] sortBy = buildNewSortBy(sorts, groupingAttributes);\n+        q.setSortBy(sortBy);\n+\n+        // produces new PropertyName to add to the query\n+        List<PropertyName> propertiesToAdd =\n+                Stream.of(sortBy).map(s -> s.getPropertyName()).collect(Collectors.toList());\n+        propertiesToAdd.add(ff.property(operationAttribute));\n+\n+        // eventually merge with existing ones\n+        List<PropertyName> pns = getNewProperties(propertiesToAdd, properties);\n+        q.setProperties(pns);\n+\n+        // features with null values for groupingAttributes and operationAttribute\n+        // will not be rendered. Adding not null filters to delegate to the db.\n+        List<Filter> filters = new ArrayList<>();\n+        for (PropertyName pn : propertiesToAdd) {\n+            filters.add(ff.not(ff.isNull(pn)));\n+        }\n+        Filter original = q.getFilter();\n+        if (original != null && !original.equals(Filter.INCLUDE)) filters.add(q.getFilter());\n+        q.setFilter(ff.and(filters));\n+        return q;\n+    }\n+\n+    private SortBy[] buildNewSortBy(SortBy[] sorts, List<String> groupingAttributes) {\n+        // eventually creates new SortBy and add them to the array\n+        List<SortBy> newSorts = new ArrayList<>(groupingAttributes.size());\n+        List<PropertyName> properties =\n+                groupingAttributes.stream().map(s -> ff.property(s)).collect(Collectors.toList());\n+        for (int i = 0; i < properties.size(); i++) {\n+            PropertyName pn = properties.get(i);\n+            if (!sortByAlreadyExists(sorts, pn))\n+                newSorts.add(new SortByImpl(pn, SortOrder.ASCENDING));\n+        }\n+        if (newSorts.size() > 0) {\n+            if (sorts == null) return newSorts.toArray(new SortBy[newSorts.size()]);\n+            else return ArrayUtils.addAll(sorts, newSorts.toArray(new SortBy[newSorts.size()]));\n+        }\n+        return sorts;\n+    }\n+\n+    private List<PropertyName> getNewProperties(\n+            List<PropertyName> toAdd, List<PropertyName> originalProperties) {\n+        Set<PropertyName> properties = new HashSet<>();\n+        if (originalProperties != null) {\n+            properties.addAll(originalProperties);\n+        }\n+        if (toAdd != null) {\n+            properties.addAll(toAdd);\n+        }\n+        return new ArrayList<>(properties);\n+    }\n+\n+    private boolean sortByAlreadyExists(SortBy[] sorts, PropertyName pn) {\n+        if (sorts == null) return false;\n+        for (SortBy s : sorts) {\n+            // just checking the property name. In the context of the rendering\n+            // transformation the sortBy order doesn't matter\n+            if (s.getPropertyName().equals(pn)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private PropertyName validatePropertyName(PropertyName pn, FeatureType schema) {\n+        // checks propertyName against the schema\n+        if (pn.evaluate(schema) == null)\n+            throw new ProcessException(\n+                    \"Unable to resolve \" + pn.getPropertyName() + \" against the FeatureType\");\n+        return pn;\n+    }\n+\n+    private NamespaceSupport declareNamespaces(FeatureType type) {\n+        // retrieves Namespaces for complex features\n+        NamespaceSupport namespaceSupport = null;\n+        Map namespaces = (Map) type.getUserData().get(Types.DECLARED_NAMESPACES_MAP);\n+        if (namespaces != null) {\n+            namespaceSupport = new NamespaceSupport();\n+            for (Iterator it = namespaces.entrySet().iterator(); it.hasNext(); ) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+                String prefix = (String) entry.getKey();\n+                String namespace = (String) entry.getValue();\n+                namespaceSupport.declarePrefix(prefix, namespace);\n+            }\n+        }\n+        return namespaceSupport;\n+    }\n+\n+    /**\n+     * A FeatureCollection wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureCollection\n+            extends DecoratingFeatureCollection<FeatureType, Feature> {\n+\n+        List<PropertyName> groupingAttributes;\n+\n+        PropertyName operationAttribute;\n+\n+        Operations aggregation;\n+\n+        public GroupingFeatureCollection(\n+                FeatureCollection<FeatureType, Feature> delegate,\n+                List<PropertyName> groupingAttributes,\n+                PropertyName operationAttribute,\n+                Operations aggregation) {\n+            super(delegate);\n+            this.groupingAttributes = groupingAttributes;\n+            this.operationAttribute = operationAttribute;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public FeatureIterator<Feature> features() {\n+            return new GroupingFeatureIterator(\n+                    new PushBackFeatureIterator(delegate.features()),\n+                    groupingAttributes,\n+                    operationAttribute,\n+                    aggregation);\n+        }\n+    }\n+\n+    /**\n+     * A FeatureIterator wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureIterator extends DecoratingFeatureIterator<Feature> {\n+\n+        private List<PropertyName> groupByAttributes;\n+\n+        private PropertyName operationAttribute;\n+\n+        private Operations aggregation;\n+\n+        private Feature next;\n+\n+        /**\n+         * Wrap the provided FeatureIterator.\n+         *\n+         * @param iterator Iterator to be used as a delegate.\n+         */\n+        public GroupingFeatureIterator(\n+                PushBackFeatureIterator iterator,\n+                List<PropertyName> groupByAttributes,\n+                PropertyName operationValue,\n+                Operations aggregation) {\n+            super(iterator);\n+            this.groupByAttributes = groupByAttributes;\n+            this.operationAttribute = operationValue;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            List<Object> groupingValues = new ArrayList<>(groupByAttributes.size());\n+            Map<Object, Feature> beingFiltered = new HashMap<>();\n+            List<Double> valuesToCompare = new ArrayList<>();\n+            while (super.hasNext()) {\n+                Feature f = super.next();\n+                if (beingFiltered.size() == 0) {\n+                    // no features in the list this is the first of the group\n+                    // takes the values to check the following features if belong to the same group\n+                    // features with null values are skipped\n+                    if (addGroupingValues(groupingValues, f))\n+                        addDoubleValueFromFeature(f, valuesToCompare, beingFiltered);\n+                } else {\n+                    // is the feature in the group?\n+                    if (featureComparison(groupingValues, f)) {\n+                        addDoubleValueFromFeature(f, valuesToCompare, beingFiltered);\n+                    } else {\n+                        ((PushBackFeatureIterator) delegate).pushBack();\n+                        break;\n+                    }\n+                }\n+            }\n+            next = doFiltering(beingFiltered, valuesToCompare);\n+            return next != null;\n+        }\n+\n+        private Feature doFiltering(\n+                Map<Object, Feature> beingFiltered, List<Double> beingEvaluated) {\n+            Object key;\n+            // searches the min or max inside the values list and retrieve the feature\n+            // to be returned from the Map.\n+            if (beingFiltered.size() > 0 && beingEvaluated.size() > 0) {\n+                if (this.aggregation.equals(Operations.MIN)) key = computeMin(beingEvaluated);\n+                else key = computeMax(beingEvaluated);\n+\n+                return beingFiltered.get(key);\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        private Number computeMin(List<Double> beingEvaluated) {\n+            return Collections.min(beingEvaluated);\n+        }\n+\n+        private Number computeMax(List<Double> beingEvaluated) {\n+            return Collections.max(beingEvaluated);\n+        }\n+\n+        private boolean featureComparison(List<Object> groupingValues, Feature f) {\n+            List<Object> toCompareValues = new ArrayList<>(groupingValues.size());\n+            for (PropertyName p : groupByAttributes) {\n+                toCompareValues.add(p.evaluate(f));\n+            }\n+            if (groupingValues.size() > 0 && groupingValues.equals(toCompareValues)) return true;\n+            return false;\n+        }\n+\n+        private boolean addGroupingValues(List<Object> groupingValues, Feature f) {\n+            for (PropertyName p : groupByAttributes) {\n+                Object result = p.evaluate(f);\n+                if (result != null) groupingValues.add(p.evaluate(f));\n+            }\n+            if (groupingValues.isEmpty() || groupingValues.size() < groupByAttributes.size())\n+                return false;\n+            return true;\n+        }\n+\n+        private void addDoubleValueFromFeature(\n+                Feature f, List<Double> valuesToCompare, Map<Object, Feature> beingFiltered) {\n+            Object result = this.operationAttribute.evaluate(f, Number.class);\n+            if (result instanceof Number) {\n+                Double value = ((Number) result).doubleValue();\n+                valuesToCompare.add(value);", "originalCommit": "5efd106ed909fc97db2dc5c828a059ad25fb5ad6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQ5Njc5NQ==", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r512496795", "bodyText": "Thinking about it, the MinVisitor and MaxVisitor are already doing the right thing, make them visit the features one by one, get the result, reset them before visiting the next group, done.", "author": "aaime", "createdAt": "2020-10-27T08:28:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3MzI3Mg=="}], "type": "inlineReview"}, {"oid": "434db10738df37342b291be761ba43eeac3063f1", "url": "https://github.com/geotools/geotools/commit/434db10738df37342b291be761ba43eeac3063f1", "message": "[GEOT-6726] Add new FilteringVectorProcess", "committedDate": "2020-10-27T08:17:49Z", "type": "commit"}, {"oid": "081a7799f446543993e8f39c42f87a72ea77297a", "url": "https://github.com/geotools/geotools/commit/081a7799f446543993e8f39c42f87a72ea77297a", "message": "reviewer's feedback applied", "committedDate": "2020-10-28T07:07:26Z", "type": "forcePushed"}, {"oid": "15042b3e25d75e20aab7a719069662e17068229c", "url": "https://github.com/geotools/geotools/commit/15042b3e25d75e20aab7a719069662e17068229c", "message": "reviewer's feedback applied", "committedDate": "2020-10-28T07:23:03Z", "type": "forcePushed"}, {"oid": "cd137a1df27f21960236b0ad298eb6c1c9284af0", "url": "https://github.com/geotools/geotools/commit/cd137a1df27f21960236b0ad298eb6c1c9284af0", "message": "reviewer's feedback applied", "committedDate": "2020-10-30T11:18:11Z", "type": "forcePushed"}, {"oid": "2467f3f9429e0d7aa1448bb9ba5cf86d59dd4695", "url": "https://github.com/geotools/geotools/commit/2467f3f9429e0d7aa1448bb9ba5cf86d59dd4695", "message": "reviewer's feedback applied", "committedDate": "2020-10-30T11:25:34Z", "type": "commit"}, {"oid": "2467f3f9429e0d7aa1448bb9ba5cf86d59dd4695", "url": "https://github.com/geotools/geotools/commit/2467f3f9429e0d7aa1448bb9ba5cf86d59dd4695", "message": "reviewer's feedback applied", "committedDate": "2020-10-30T11:25:34Z", "type": "forcePushed"}]}