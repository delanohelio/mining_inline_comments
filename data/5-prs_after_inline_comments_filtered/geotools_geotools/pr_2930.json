{"pr_number": 2930, "pr_title": "Support mbstyle filter expressions [GEOT-6589] ", "pr_createdAt": "2020-05-13T04:59:27Z", "pr_url": "https://github.com/geotools/geotools/pull/2930", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NzMyNA==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r424177324", "bodyText": "@vickdw I was going to ask for your input here, this is my first looking into how expressions have been implemented and I wanted to take a consistent approach before changing anything substantially.\nThe above is based on the MBDecision.decisionNotEqual() which calls parse.string(json,1) as shown above. If I understand correctly the string method is willing to convert any literals (strings, numbers, booleans) to a string so we end up with a string equality check only. Rather than a numeric != numeric equality check.\nDoes this match with your understanding?", "author": "jodygarnett", "createdAt": "2020-05-13T05:16:06Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java", "diffHunk": "@@ -460,4 +468,59 @@ public Filter filter() {\n             throw new MBFormatException(\"Unsupported filter \" + json);\n         }\n     }\n+\n+    /**\n+     * Returns true if the input values are equal, false otherwise. The inputs must be numbers,\n+     * strings, or booleans, and both of the same type. Examples: [\"==\", number, number]: boolean\n+     * [\"==\", string, string]: boolean [\"==\", boolean, boolean]: boolean [\"==\", null, null]: boolean\n+     *\n+     * @return equal to expression\n+     */\n+    private Filter filterEqualTo(JSONArray array) {\n+        if (array.size() != 3) {\n+            throwUnexpectedArgumentCount(\"==\", 2);\n+        }\n+        final FilterFactory2 ff = parse.getFilterFactory();\n+        if (parse.isString(array, 1)) { // legacy filter syntax\n+            String key = parse.get(array, 1);\n+            Object value = parse.value(array, 2);\n+            return ff.equal(ff.property(key), ff.literal(value), false);\n+        } else {\n+            Expression expression1 = parse.string(array, 1);\n+            Expression expression2 = parse.string(array, 2);\n+            return ff.equal(expression1, expression2, false);\n+        }\n+    }\n+\n+    /**\n+     * Returns true if the input values are not equal, false otherwise. The inputs must be numbers,\n+     * strings, or booleans, and both of the same type. Examples:[\"!=\", number, number]: boolean\n+     * [\"!=\", string, string]: boolean [\"!=\", boolean, boolean]: boolean [\"!=\", null, null]: boolean\n+     *\n+     * @return Not equals expression\n+     */\n+    private Filter filterNotEqual(JSONArray array) {\n+        if (array.size() != 3) {\n+            throwUnexpectedArgumentCount(\"!=\", 2);\n+        }\n+        final FilterFactory2 ff = parse.getFilterFactory();\n+        if (parse.isString(array, 1)) { // legacy filter syntax\n+            String key = parse.get(json, 1);\n+            Object value = parse.value(json, 2);\n+            return ff.notEqual(ff.property(key), ff.literal(value), false);\n+        } else {\n+            // get the comparables\n+            Expression expression1 = parse.string(json, 1);\n+            Expression expression2 = parse.string(json, 2);\n+            return ff.notEqual(expression1, expression2);", "originalCommit": "922db222c01f88dd4f7b5e32e4d588b7109073ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI5OTk1NQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r425299955", "bodyText": "Yes, that is correct.", "author": "vickdw", "createdAt": "2020-05-14T17:11:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NzMyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3Nzc4MA==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r424177780", "bodyText": "This blind conversion to a string incorrectly resulted in correctly generated Expressions being represented as strings. I suspect it should be removed!", "author": "jodygarnett", "createdAt": "2020-05-13T05:18:01Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java", "diffHunk": "@@ -332,9 +332,10 @@ public String get(JSONArray json, int index) {\n         }\n         if (index < json.size() && json.get(index) instanceof String) {\n             return (String) json.get(index);\n-        }\n-        if (index < json.size() && json.get(index) instanceof JSONArray) {\n-            return MBExpression.transformExpression((JSONArray) json.get(index)).toString();\n+            //        }\n+            //        if (index < json.size() && json.get(index) instanceof JSONArray) {\n+            //            return MBExpression.transformExpression((JSONArray)\n+            // json.get(index)).toString();", "originalCommit": "922db222c01f88dd4f7b5e32e4d588b7109073ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI5OTQyMw==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r425299423", "bodyText": "I agree, this looks like a good change.", "author": "vickdw", "createdAt": "2020-05-14T17:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3Nzc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4ODcwOA==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r425288708", "bodyText": "could you put some comments in the code here (maybe an example)?  it's hard to determine what all the json.size() == X mean.\nAlso, I think get requires one argument - [\"get\", \"propName\"]", "author": "davidblasby", "createdAt": "2020-05-14T16:54:48Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBLookup.java", "diffHunk": "@@ -56,16 +56,22 @@ public Expression lookupAt() {\n     public Expression lookupGet() {\n         if (json.size() == 2 || json.size() == 3) {", "originalCommit": "2d382cee2cbc0a0c38146db31a11f48cfb7f65af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI5NjI5OQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r425296299", "bodyText": "There is actually an option, documented in the javadoc above for three arguments.\n[ \"get\", key, object]\n\nThis can be used to pull out a specific value not from the feature, but from the results of another expression.  I was really smart I may be able to turn this into an propertyname with xpath - but I am not going to do premature optimization.\nFor the library we chose the geoapi approach of format shifting the specifrication into javadocs. So you do not have to look up everything each time to see what the code is trying to implement.", "author": "jodygarnett", "createdAt": "2020-05-14T17:06:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4ODcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4OTk0OA==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r425289948", "bodyText": "looks like there is a lot of copy-and-paste code here and all the other functions.  They're all the same except the last line.", "author": "davidblasby", "createdAt": "2020-05-14T16:56:42Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java", "diffHunk": "@@ -460,4 +464,116 @@ public Filter filter() {\n             throw new MBFormatException(\"Unsupported filter \" + json);\n         }\n     }\n+\n+    /**\n+     * Returns true if the input values are equal, false otherwise. The inputs must be numbers,\n+     * strings, or booleans, and both of the same type. Examples: [\"==\", number, number]: boolean\n+     * [\"==\", string, string]: boolean [\"==\", boolean, boolean]: boolean [\"==\", null, null]: boolean\n+     *\n+     * @return equal to expression\n+     */\n+    private Filter filterEqualTo(JSONArray array) {\n+        if (array.size() != 3) {\n+            throwUnexpectedArgumentCount(\"==\", 2);\n+        }\n+        if (parse.isString(array, 1)) { // legacy filter syntax\n+            String key = parse.get(array, 1);\n+            Object value = parse.value(array, 2);\n+            return ff.equal(ff.property(key), ff.literal(value), false);\n+        } else {\n+            Expression expression1 = parse.string(array, 1);\n+            Expression expression2 = parse.string(array, 2);\n+            return ff.equal(expression1, expression2, false);\n+        }\n+    }\n+\n+    /**\n+     * Returns true if the input values are not equal, false otherwise. The inputs must be numbers,\n+     * strings, or booleans, and both of the same type. Examples:[\"!=\", number, number]: boolean\n+     * [\"!=\", string, string]: boolean [\"!=\", boolean, boolean]: boolean [\"!=\", null, null]: boolean\n+     *\n+     * @return Not equals expression\n+     */\n+    private Filter filterNotEqual(JSONArray array) {\n+        if (array.size() != 3) {\n+            throwUnexpectedArgumentCount(\"!=\", 2);\n+        }\n+        if (parse.isString(array, 1)) { // legacy filter syntax\n+            String key = parse.get(json, 1);\n+            Object value = parse.value(json, 2); // legacy filter restricted to literals\n+            return ff.notEqual(ff.property(key), ff.literal(value), false);\n+        } else {\n+            Expression expression1 = parse.string(json, 1);\n+            Expression expression2 = parse.string(json, 2);\n+            return ff.notEqual(expression1, expression2);\n+        }\n+    }\n+\n+    private Filter filterLessOrEqual(JSONArray array) {\n+        if (json.size() != 3) {", "originalCommit": "2d382cee2cbc0a0c38146db31a11f48cfb7f65af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI5OTE3MQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r425299171", "bodyText": "Yes, i could probably be smarter on this one, but for now I was trying to exactly match the MBExpression logic. The use of string to evaluate expressions is a problem and I would like to have everything consistent before fixing expressions in another pull request.\nStill I may be able to factor out a expression1(json) and expression2(json) method and make this more readable.", "author": "jodygarnett", "createdAt": "2020-05-14T17:10:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4OTk0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU2NjM5Mg==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r425566392", "bodyText": "This has now been resolved, I think the code is easier to understand.", "author": "jodygarnett", "createdAt": "2020-05-15T04:58:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4OTk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NTY2Ng==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428955666", "bodyText": "You've managed to make the grammar worse here, either fix the tense in the rest of the comment or revert", "author": "tbarsballe", "createdAt": "2020-05-21T22:47:18Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java", "diffHunk": "@@ -151,7 +183,7 @@ public MBFilter(JSONArray json, MBObjectParser parse, SemanticType semanticType)\n     /**\n      * Utility method to convert json to set of {@link SemanticType}.\n      *\n-     * <p>This method recursively calls itself to handle all and any operators.\n+     * <p>This method is recursively calls itself to handle all and any operators.", "originalCommit": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NzE3NQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428957175", "bodyText": "This doc could distinguish better between GeoTools Filters and Expressions, and Mapbox Filter Functions and Expressions. It is also unclear from this document whether or not gt-mbstyle still supports using the old syntax, or it is just included for posterity (and there's enough changes from the body of this class that I can't tell from looking at the code either - does the old syntax still function or has it actually been removed now?)", "author": "tbarsballe", "createdAt": "2020-05-21T22:52:20Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java", "diffHunk": "@@ -38,7 +39,34 @@\n  *\n  * <p>This wrapper and {@link MBFunction} are a matched set handling dynamic data.\n  *\n- * <h2>About MapBox Filter</h2>\n+ * <h2>Expression: Decision</h2>\n+ *\n+ * <p>Implementation Note:The value for any filter may be specified as an expression. The result type of an expression in\n+ * the filter property must be boolean. See {@link org.geotools.mbstyle.expression.MBExpression} for details.\n+ *\n+ * <p>The expressions in this section can be used to add conditional logic to your styles. For example, the 'case' expression\n+ * provides \"if/then/else\" logic, and 'match' allows you to map specific values of an input expression to different\n+ * output expressions.\n+ * <ul>\n+ *     <li><code>[\"!\", boolean]: boolean</code></li>\n+ *     <li><code>[\"!=\", value, value]: boolean</code></li>\n+ *     <li><code>&lt;/code></li>\n+ *     <li><code>&lt;=</code></li>\n+ *     <li><code>==</code></li>\n+ *     <li><code>&gt;</code></li>\n+ *     <li><code>&gt;=</code></li>\n+ *     <li><code>all</code></li>\n+ *     <li><code>any</code></li>\n+ *     <li><code>case</code></li>\n+ *     <li><code>coalesce</code></li>\n+ *     <li><code>match</code></li>\n+ *     <li><code>within</code></li>\n+ * </ul>\n+ *\n+ * <h2>Filter Other</h2>\n+ *\n+ * <p>Implementation Note: In previous versions of the style specification, filters were defined using the deprecated\n+ * syntax documented here.", "originalCommit": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4OTUzMQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r429089531", "bodyText": "Keeping support for the old syntax is very important, the freely available OpenMapTiles styles are based on it: https://github.com/openmaptiles/osm-bright-gl-style/blob/master/style.json#L44", "author": "aaime", "createdAt": "2020-05-22T07:35:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NzE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5MTQwOA==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r432791408", "bodyText": "It supports the old syntax, and the old test cases are preserved to ensure it stays that way.", "author": "jodygarnett", "createdAt": "2020-05-30T00:31:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NzE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5NjY2Mg==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r432796662", "bodyText": "Changed note to:\n\nImplementation Note: GeoTools also supports the depreciated syntax documented here (provided by a previous versions of the Mapbox style specification).\n\nTo be clear the \"Other filter\" format being described is indeed supported by GeoTools.", "author": "jodygarnett", "createdAt": "2020-05-30T01:17:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NzE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY2Njc0MQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r434666741", "bodyText": "@aaime I am marking this conversation as unresolved, I updated the docs to make it clear the ongoing support for \"other filter\"", "author": "jodygarnett", "createdAt": "2020-06-03T15:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NzE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1OTM1MA==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428959350", "bodyText": "Shouldn't this say \"Unsupported expression\" now, as the error message is from the perspective of the mapbox style?", "author": "tbarsballe", "createdAt": "2020-05-21T22:59:17Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java", "diffHunk": "@@ -378,86 +377,269 @@ public Filter filter() {\n         } else if (\"has\".equals(operator)) {\n             String key = parse.get(json, 1);\n             return ff.not(ff.isNull(ff.property(key)));\n-            // Comparison Filters\n-        } else if (\"==\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.equal(ff.property(key), ff.literal(value), false);\n+        }\n+        // Comparison Filters\n+        else if (\"==\".equals(operator)) {\n+            return filterEqualTo(json);\n         } else if (\"!=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.notEqual(ff.property(key), ff.literal(value), false);\n+            return filterNotEqual(json);\n         } else if (\">\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.greater(ff.property(key), ff.literal(value), false);\n+            return filterGreater(json);\n         } else if (\">=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.greaterOrEqual(ff.property(key), ff.literal(value), false);\n+            return filterGreaterOrEqual(json);\n         } else if (\"<\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.less(ff.property(key), ff.literal(value), false);\n+            return filterLess(json);\n         } else if (\"<=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.lessOrEqual(ff.property(key), ff.literal(value), false);\n-            // Set Membership Filters\n-        } else if (\"in\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Expression[] args = new Expression[json.size() - 1];\n-            args[0] = ff.property(key);\n-            for (int i = 1; i < args.length; i++) {\n-                Object value = parse.value(json, i + 1);\n-                args[i] = ff.literal(value);\n-            }\n-            Function in = ff.function(\"in\", args);\n-            return ff.equals(in, ff.literal(true));\n+            return filterLessOrEqual(json);\n+        }\n+        // Set Membership Filters\n+        else if (\"in\".equals(operator)) {\n+            return filterIn(json, true);\n         } else if (\"!in\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Expression[] args = new Expression[json.size() - 1];\n-            args[0] = ff.property(key);\n-            for (int i = 1; i < args.length; i++) {\n-                Object value = parse.value(json, i + 1);\n-                args[i] = ff.literal(value);\n-            }\n-            Function in = ff.function(\"in\", args);\n-            return ff.equals(in, ff.literal(false));\n-            // Combining Filters\n-        } else if (\"all\".equals(operator)) {\n-            List<Filter> all = new ArrayList<>();\n-            for (int i = 1; i < json.size(); i++) {\n-                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n+            return filterIn(json, false);\n+        }\n+        // Combining Filters\n+        else if (\"all\".equals(operator)) {\n+            return filterAll(json);\n+        } else if (\"any\".equals(operator)) {\n+            return filterAny(json);\n+        } else if (\"none\".equals(operator)) {\n+            return filterNone(json);\n+        }\n+        // MBExpression filters\n+        else if (\"case\".equals(operator)) {\n+            Expression caseExpr = MBExpression.transformExpression(json);\n+            return ff.equals(caseExpr, ff.literal(true));\n+        } else if (\"coalesce\".equals(operator)) {\n+            Expression coalesce = MBExpression.transformExpression(json);\n+            return ff.equals(coalesce, ff.literal(true));\n+        } else if (\"match\".equals(operator)) {\n+            Expression match = MBExpression.transformExpression(json);\n+            return ff.equals(match, ff.literal(true));\n+        } else if (\"within\".equals(operator)) {\n+            Expression within = MBExpression.transformExpression(json);\n+            return ff.equals(within, ff.literal(true));\n+        } else {\n+            throw new MBFormatException(\"Unsupported filter \" + json);", "originalCommit": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5NzA1Mw==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r432797053", "bodyText": "The code handles both cases, changing to \"Unsupported data expression or filter\"", "author": "jodygarnett", "createdAt": "2020-05-30T01:21:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1OTM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2MTA0Ng==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428961046", "bodyText": "\"value2\" instead of \"value1\"?", "author": "tbarsballe", "createdAt": "2020-05-21T23:05:04Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java", "diffHunk": "@@ -378,86 +377,269 @@ public Filter filter() {\n         } else if (\"has\".equals(operator)) {\n             String key = parse.get(json, 1);\n             return ff.not(ff.isNull(ff.property(key)));\n-            // Comparison Filters\n-        } else if (\"==\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.equal(ff.property(key), ff.literal(value), false);\n+        }\n+        // Comparison Filters\n+        else if (\"==\".equals(operator)) {\n+            return filterEqualTo(json);\n         } else if (\"!=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.notEqual(ff.property(key), ff.literal(value), false);\n+            return filterNotEqual(json);\n         } else if (\">\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.greater(ff.property(key), ff.literal(value), false);\n+            return filterGreater(json);\n         } else if (\">=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.greaterOrEqual(ff.property(key), ff.literal(value), false);\n+            return filterGreaterOrEqual(json);\n         } else if (\"<\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.less(ff.property(key), ff.literal(value), false);\n+            return filterLess(json);\n         } else if (\"<=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.lessOrEqual(ff.property(key), ff.literal(value), false);\n-            // Set Membership Filters\n-        } else if (\"in\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Expression[] args = new Expression[json.size() - 1];\n-            args[0] = ff.property(key);\n-            for (int i = 1; i < args.length; i++) {\n-                Object value = parse.value(json, i + 1);\n-                args[i] = ff.literal(value);\n-            }\n-            Function in = ff.function(\"in\", args);\n-            return ff.equals(in, ff.literal(true));\n+            return filterLessOrEqual(json);\n+        }\n+        // Set Membership Filters\n+        else if (\"in\".equals(operator)) {\n+            return filterIn(json, true);\n         } else if (\"!in\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Expression[] args = new Expression[json.size() - 1];\n-            args[0] = ff.property(key);\n-            for (int i = 1; i < args.length; i++) {\n-                Object value = parse.value(json, i + 1);\n-                args[i] = ff.literal(value);\n-            }\n-            Function in = ff.function(\"in\", args);\n-            return ff.equals(in, ff.literal(false));\n-            // Combining Filters\n-        } else if (\"all\".equals(operator)) {\n-            List<Filter> all = new ArrayList<>();\n-            for (int i = 1; i < json.size(); i++) {\n-                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n+            return filterIn(json, false);\n+        }\n+        // Combining Filters\n+        else if (\"all\".equals(operator)) {\n+            return filterAll(json);\n+        } else if (\"any\".equals(operator)) {\n+            return filterAny(json);\n+        } else if (\"none\".equals(operator)) {\n+            return filterNone(json);\n+        }\n+        // MBExpression filters\n+        else if (\"case\".equals(operator)) {\n+            Expression caseExpr = MBExpression.transformExpression(json);\n+            return ff.equals(caseExpr, ff.literal(true));\n+        } else if (\"coalesce\".equals(operator)) {\n+            Expression coalesce = MBExpression.transformExpression(json);\n+            return ff.equals(coalesce, ff.literal(true));\n+        } else if (\"match\".equals(operator)) {\n+            Expression match = MBExpression.transformExpression(json);\n+            return ff.equals(match, ff.literal(true));\n+        } else if (\"within\".equals(operator)) {\n+            Expression within = MBExpression.transformExpression(json);\n+            return ff.equals(within, ff.literal(true));\n+        } else {\n+            throw new MBFormatException(\"Unsupported filter \" + json);\n+        }\n+    }\n+\n+    private Filter filterNone(JSONArray array) {\n+        List<Filter> none = new ArrayList<>();\n+        for (int i = 1; i < array.size(); i++) {\n+            if (parse.isArray(array, i)) {\n+                // using not here so we can short circuit the and filter below\n+                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n-                    all.add(filter);\n+                    none.add(ff.not(filter));\n                 }\n+            } else {\n+                throw new MBFormatException(\n+                        \"None filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-            return ff.and(all);\n-        } else if (\"any\".equals(operator)) {\n-            List<Filter> any = new ArrayList<>();\n-            for (int i = 1; i < json.size(); i++) {\n-                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n+        }\n+        return ff.and(none);\n+    }\n+\n+    private Filter filterAny(JSONArray array) {\n+        List<Filter> any = new ArrayList<>();\n+        for (int i = 1; i < array.size(); i++) {\n+            if (parse.isArray(array, i)) {\n+                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n                     any.add(filter);\n                 }\n+            } else {\n+                throw new MBFormatException(\"Any filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-            return ff.or(any);\n-        } else if (\"none\".equals(operator)) {\n-            List<Filter> none = new ArrayList<>();\n-            for (int i = 1; i < json.size(); i++) {\n-                // using not here so we can short circuit the and filter below\n-                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n+        }\n+        return ff.or(any);\n+    }\n+\n+    private Filter filterAll(JSONArray array) {\n+        List<Filter> all = new ArrayList<>();\n+        for (int i = 1; i < array.size(); i++) {\n+            if (parse.isArray(array, i)) {\n+                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n-                    none.add(ff.not(filter));\n+                    all.add(filter);\n                 }\n+            } else {\n+                throw new MBFormatException(\"All filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-            return ff.and(none);\n+        }\n+        return ff.and(all);\n+    }\n+\n+    private Filter filterIn(JSONArray array, boolean in) {\n+        String key = parse.get(array, 1);\n+        Expression[] args = new Expression[array.size() - 1];\n+        args[0] = ff.property(key);\n+        for (int i = 1; i < args.length; i++) {\n+            Expression expression = parse.string(array, i + 1);\n+            args[i] = expression;\n+        }\n+        Function function = ff.function(\"in\", args);\n+        return ff.equals(function, ff.literal(in));\n+    }\n+\n+    private Filter filterByFeatureIdentifier(JSONArray array, String operator) {\n+        Set<FeatureId> fids = new HashSet<>();\n+        for (Object value : array.subList(2, array.size())) {\n+            if (value instanceof String) {\n+                String fid = (String) value;\n+                fids.add(ff.featureId(fid));\n+            }\n+        }\n+        if (\"has\".equals(operator) || \"in\".equals(operator)) {\n+            return ff.id(fids);\n+        } else if (\"!has\".equals(operator) || \"!in\".equals(operator)) {\n+            return ff.not(ff.id(fids));\n         } else {\n-            throw new MBFormatException(\"Unsupported filter \" + json);\n+            throw new UnsupportedOperationException(\"$id \\\"\" + operator + \"\\\" not valid\");\n+        }\n+    }\n+\n+    private Filter filterByGeometryType(JSONArray json, String operator) {\n+        List<Filter> typeFilters = new ArrayList<>();\n+        List<?> types = json.subList(2, json.size());\n+        for (Object type : types) {\n+            Filter typeFilter = null;\n+            if (type instanceof String) {\n+                typeFilter = translateType((String) type);\n+            }\n+            if (typeFilter == null) {\n+                throw new MBFormatException(\n+                        \"\\\"$type\\\" limited to Point, LineString, Polygon: \" + type);\n+            }\n+            typeFilters.add(typeFilter);\n+        }\n+        if (\"==\".equals(operator)) {\n+            if (typeFilters.size() != 1) {\n+                throw new MBFormatException(\n+                        \"[\\\"==\\\",\\\"$type\\\", ...] limited one geometry type, to test more than one use \\\"in\\\" operator.\");\n+            }\n+            return typeFilters.get(0);\n+        } else if (\"!=\".equals(operator)) {\n+            if (typeFilters.size() != 1) {\n+                throw new MBFormatException(\n+                        \"[\\\"!=\\\",\\\"$type\\\", ...] limited one geometry type, to test more than one use \\\"!in\\\" operator.\");\n+            }\n+            return ff.not(typeFilters.get(0));\n+        } else if (\"in\".equals(operator)) {\n+            return ff.or(typeFilters);\n+        } else if (\"!in\".equals(operator)) {\n+            return ff.not(ff.or(typeFilters));\n+        } else {\n+            throw new MBFormatException(\"Unsupported $type operator \\\"\" + json + \"\\\"\");\n+        }\n+    }\n+\n+    /**\n+     * Returns true if the input values are equal, false otherwise. The inputs must be numbers,\n+     * strings, or booleans, and both of the same type. Examples: [\"==\", number, number]: boolean\n+     * [\"==\", string, string]: boolean [\"==\", boolean, boolean]: boolean [\"==\", null, null]: boolean\n+     *\n+     * @return equal to expression\n+     */\n+    private Filter filterEqualTo(JSONArray array) {\n+        if (array.size() != 3) {\n+            throwUnexpectedArgumentCount(\"==\", 2);\n+        }\n+        Expression expression1 = comparisonExpression1(array);\n+        Expression expression2 = comparisonExpression2(array);\n+        return ff.equals(expression1, expression2);\n+    }\n+\n+    /**\n+     * Returns true if the input values are not equal, false otherwise. The inputs must be numbers,\n+     * strings, or booleans, and both of the same type. Examples:[\"!=\", number, number]: boolean\n+     * [\"!=\", string, string]: boolean [\"!=\", boolean, boolean]: boolean [\"!=\", null, null]: boolean\n+     *\n+     * @return Not equals expression\n+     */\n+    private Filter filterNotEqual(JSONArray array) {\n+        if (array.size() != 3) {\n+            throwUnexpectedArgumentCount(\"!=\", 2);\n+        }\n+        Expression expression1 = comparisonExpression1(array);\n+        Expression expression2 = comparisonExpression2(array);\n+        return ff.notEqual(expression1, expression2);\n+    }\n+\n+    private Filter filterLessOrEqual(JSONArray array) {\n+        if (json.size() != 3) {\n+            throwUnexpectedArgumentCount(\"<=\", 2);\n+        }\n+        Expression expression1 = comparisonExpression1(array);\n+        Expression expression2 = comparisonExpression2(array);\n+        return ff.lessOrEqual(expression1, expression2);\n+    }\n+\n+    private Filter filterLess(JSONArray array) {\n+        if (json.size() != 3) {\n+            throwUnexpectedArgumentCount(\"<\", 2);\n+        }\n+        Expression expression1 = comparisonExpression1(array);\n+        Expression expression2 = comparisonExpression2(array);\n+        return ff.less(expression1, expression2);\n+    }\n+\n+    private Filter filterGreaterOrEqual(JSONArray array) {\n+        if (json.size() != 3) {\n+            throwUnexpectedArgumentCount(\">=\", 2);\n+        }\n+        Expression expression1 = comparisonExpression1(array);\n+        Expression expression2 = comparisonExpression2(array);\n+        return ff.greaterOrEqual(expression1, expression2);\n+    }\n+\n+    private Filter filterGreater(JSONArray array) {\n+        if (json.size() != 3) {\n+            throwUnexpectedArgumentCount(\">\", 2);\n+        }\n+        Expression expression1 = comparisonExpression1(array);\n+        Expression expression2 = comparisonExpression2(array);\n+        return ff.greater(expression1, expression2);\n+    }\n+\n+    private void throwUnexpectedArgumentCount(String expression, int argCount)\n+            throws MBFormatException {\n+        throw new MBFormatException(\n+                String.format(\n+                        \"Expression \\\"%s\\\" should have exactly %d argument(s)\",\n+                        expression, argCount));\n+    }\n+\n+    /**\n+     * Comparison value1 defined as an expression (or legacy key reference).\n+     *\n+     * @param array JSON filter definition\n+     * @return Expression for comparison\n+     */\n+    private Expression comparisonExpression1(JSONArray array) {\n+        if (parse.isString(array, 1)) { // legacy filter syntax\n+            String key = parse.get(array, 1);\n+            return ff.property(key);\n+        } else {\n+            return parse.string(array, 1);\n+        }\n+    }\n+    /**\n+     * Comparison value1 defined as an expression (or legacy literal reference).", "originalCommit": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2MjAzMw==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428962033", "bodyText": "\"property expressions\" is not a term referenced anywhere in the MBStyle spec (I think the term you are looking for is data expressions - https://docs.mapbox.com/mapbox-gl-js/style-spec/expressions/#data-expressions ), and you've referred to them as just \"expressions\" elsewhere.\nPlease stick with a consistent name. The distinction between GeoTools Expressions and MapBox expressions is already confusing enough without making up terms.", "author": "tbarsballe", "createdAt": "2020-05-21T23:08:37Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFunction.java", "diffHunk": "@@ -35,7 +35,10 @@\n import org.opengis.filter.expression.Function;\n \n /**\n- * MBFunction json wrapper, allowing conversion to a GeoTools Expression.\n+ * MBFunction json wrapper, allowing conversion of function to a GeoTools Expression.\n+ *\n+ * <p>As of MapBox Style Specification v0.41.0, property expressions are the preferred approach for", "originalCommit": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5MTU5MQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r432791591", "bodyText": "Okay so data expression for mapbox style, and GeoTools Expression elsewhere.", "author": "jodygarnett", "createdAt": "2020-05-30T00:32:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2MjAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5Nzg3MQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r432797871", "bodyText": "The https://docs.mapbox.com/mapbox-gl-js/style-spec/other/#function page uses:\n\nAs of v0.41.0, property expressions is the preferred method for styling features based on zoom level or the feature's properties. Zoom and property functions are still supported, but will be phased out in a future release.", "author": "jodygarnett", "createdAt": "2020-05-30T01:30:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2MjAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgwNjY0Mg==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r432806642", "bodyText": "I had a run at consistently using:\n\n\"data expression\"\n\"GeoTools Expression\"\n\"name\" (rather than tag or propertyName)\n\"value\" for object vs \"element\" for array", "author": "jodygarnett", "createdAt": "2020-05-30T03:45:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2MjAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2Mjg4Mw==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428962883", "bodyText": "\"... not a supported\" what? This error message seems worse then before.", "author": "tbarsballe", "createdAt": "2020-05-21T23:11:19Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java", "diffHunk": "@@ -1145,11 +1150,20 @@ public Expression string(JSONArray json, int index) {\n             MBFunction function = new MBFunction(this, (JSONObject) obj);\n             return function.function(String.class);\n         } else if (obj instanceof JSONArray) {\n-            if (((JSONArray) obj).get(0) instanceof String\n-                    && MBExpression.canCreate(((JSONArray) obj).get(0).toString())) {\n-                return MBExpression.transformExpression((JSONArray) obj);\n+            JSONArray array = (JSONArray) obj;\n+            if (isString(array, 0)) {\n+                String expressionName = get(array, 0);\n+                if (MBExpression.canCreate(expressionName)) {\n+                    return MBExpression.transformExpression(array);\n+                } else {\n+                    throw new MBFormatException(\n+                            context\n+                                    + \" string unavailable: expression' \"\n+                                    + expressionName\n+                                    + \"' not supported.\");\n+                }\n             } else {\n-                throw new MBFormatException(context + \" string from JSONArray not supported\");\n+                throw new MBFormatException(context + \" string from JSONArray not a supported\");", "originalCommit": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2Mzc4OA==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428963788", "bodyText": "This doesn't add anything - why do both this method and isDefined(JSONObject json, String propertyName) exist (I see you've overloaded isDefined below, but why didn't you just overload this method instead)?", "author": "tbarsballe", "createdAt": "2020-05-21T23:14:33Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java", "diffHunk": "@@ -1426,9 +1440,74 @@ public Displacement displacement(JSONObject json, String tag, Displacement fallb\n         }\n     }\n \n-    /** @return True if the layer has the provided property explicitly provided, False otherwise. */\n+    //\n+    // structure checks\n+    //\n+    /** @return True if json has the provided property explicitly provided, False otherwise. */\n     public boolean isPropertyDefined(JSONObject json, String propertyName)\n             throws MBFormatException {\n+        return isDefined(json, propertyName);\n+    }", "originalCommit": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5OTA5NQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r432799095", "bodyText": "I liked the way the isDefined( json, propertyName) method reads better, I should clean up references to this method.", "author": "jodygarnett", "createdAt": "2020-05-30T01:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2Mzc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2NDg0NQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428964845", "bodyText": "All the int index versions of the is___ methods would benefit from a modified javadoc - arrays don't have properties, they have indices. Something like\n/** @return True if array has a value at the provided index, False otherwise. */\n\nWould make more sense", "author": "tbarsballe", "createdAt": "2020-05-21T23:18:27Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java", "diffHunk": "@@ -1426,9 +1440,74 @@ public Displacement displacement(JSONObject json, String tag, Displacement fallb\n         }\n     }\n \n-    /** @return True if the layer has the provided property explicitly provided, False otherwise. */\n+    //\n+    // structure checks\n+    //\n+    /** @return True if json has the provided property explicitly provided, False otherwise. */\n     public boolean isPropertyDefined(JSONObject json, String propertyName)\n             throws MBFormatException {\n+        return isDefined(json, propertyName);\n+    }\n+    /** @return True if json has the property explicitly provided, False otherwise. */\n+    public boolean isDefined(JSONObject json, String propertyName) throws MBFormatException {\n         return json.containsKey(propertyName) && json.get(propertyName) != null;\n     }\n+    /** @return True if array has the property explicitly provided, False otherwise. */\n+    public boolean isDefined(JSONArray json, int index) throws MBFormatException {", "originalCommit": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgwMzU2Mw==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r432803563", "bodyText": "Thanks, I have rewritten these.", "author": "jodygarnett", "createdAt": "2020-05-30T02:52:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2NDg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2NzYwNw==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428967607", "bodyText": "This change isn't much of an improvement, as either could be true.\nGiven that GT doesn't necessarily support the full set of expressions, this distinction is relevant, because the invalid and not supported have different fixes - and invalid expression is user error (most likely a misspelling), and should be simple to fix, whereas an expression that is not supported means they need to upgrade (or wait for) a version of geotools that supports the expression.\nUnfortunately I don't think there's much we can do about this - even if we maintained a list of expressions that GT didn't yet support, it would inevitably become outdated. Perhaps a more descriptive error message? Something like:\nExpression \\\"\" + name + \"\\\" invalid. It may be misspelled or not supported by this implementation\"", "author": "tbarsballe", "createdAt": "2020-05-21T23:28:42Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBExpression.java", "diffHunk": "@@ -151,24 +162,25 @@ public static MBExpression create(JSONArray json) {\n             } else if (zoom.contains(name)) {\n                 return new MBZoom(json);\n             } else {\n-                throw new MBFormatException(\"Expression \\\"\" + name + \"\\\" invalid.\");\n+                throw new MBFormatException(\"Expression \\\"\" + name + \"\\\" not supported.\");", "originalCommit": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5MjYyOQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r432792629", "bodyText": "Thanks, making the change you suggested.\nThe only positive improvement we could make here is to report the list of data expressions we do support; but that is likely to get long over time (and less useful as a result).", "author": "jodygarnett", "createdAt": "2020-05-30T00:40:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2NzYwNw=="}], "type": "inlineReview"}, {"oid": "cc24b65bb30889788a85e384a95019cd88ddb9fa", "url": "https://github.com/geotools/geotools/commit/cc24b65bb30889788a85e384a95019cd88ddb9fa", "message": "Address feedback\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-05-30T00:36:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzODIzMw==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r433338233", "bodyText": "\"data expessions are\"", "author": "tbarsballe", "createdAt": "2020-06-01T16:10:59Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFunction.java", "diffHunk": "@@ -37,8 +37,8 @@\n /**\n  * MBFunction json wrapper, allowing conversion of function to a GeoTools Expression.\n  *\n- * <p>As of MapBox Style Specification v0.41.0, property expressions are the preferred approach for\n- * dynamically styling features.\n+ * <p>As of v0.41.0, data expressions is the preferred method for styling features based on zoom", "originalCommit": "28adb9374b48562bedaea7a2081c4b242e9f7634", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM0MDkzMA==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r433340930", "bodyText": "Pretty sure splitting the closing brace from the else violates the style guide (although Travis CI seems happy with it, so I guess not?). Not really important either way.", "author": "tbarsballe", "createdAt": "2020-06-01T16:16:15Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBLookup.java", "diffHunk": "@@ -56,22 +56,26 @@ public Expression lookupAt() {\n     public Expression lookupGet() {\n         if (json.size() == 2 || json.size() == 3) {\n             if (json.size() == 2) {\n+                // Example: [\"get\", \"propertyName\"]\n                 if (parse.isString(json, 1)) {\n                     String propertyName = parse.get(json, 1);\n                     return ff.property(propertyName);\n-                } else {\n+                }\n+                // Example: [\"get\", key]\n+                else {", "originalCommit": "28adb9374b48562bedaea7a2081c4b242e9f7634", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "url": "https://github.com/geotools/geotools/commit/66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "message": "Additional MBObjectParser methods to check json object and array structure\n\nThis prevents code breaking out their own instance of checks\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:36Z", "type": "commit"}, {"oid": "ac35e8868fddcc200b7048497f96dbc77a77c8d8", "url": "https://github.com/geotools/geotools/commit/ac35e8868fddcc200b7048497f96dbc77a77c8d8", "message": "MBExpression transformExpression incorrectly used to generate string\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:36Z", "type": "commit"}, {"oid": "d864e0dc46a6666048eab4f5946a09354d8b6782", "url": "https://github.com/geotools/geotools/commit/d864e0dc46a6666048eab4f5946a09354d8b6782", "message": "Document Function stop approach as deprecated\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:36Z", "type": "commit"}, {"oid": "7d099b39f9f27458c8f91a078fd48a0713fece9e", "url": "https://github.com/geotools/geotools/commit/7d099b39f9f27458c8f91a078fd48a0713fece9e", "message": "Experiment to show how MBFilter can support use of expressions\n\nThe deprecated syntax is preserved, and documented, for backwards compatibility.\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:36Z", "type": "commit"}, {"oid": "9c0267a95ab980448a7a7c672039e87acc9b2a6e", "url": "https://github.com/geotools/geotools/commit/9c0267a95ab980448a7a7c672039e87acc9b2a6e", "message": "Cleanup to confirm existing tests still pass\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:36Z", "type": "commit"}, {"oid": "501e9bd48f3e72d6f930bbd7774e32e7f928cb92", "url": "https://github.com/geotools/geotools/commit/501e9bd48f3e72d6f930bbd7774e32e7f928cb92", "message": "document support for filter expressions\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "4746e7cf2aa0d257b4c45491a4eab4e3ce76afe1", "url": "https://github.com/geotools/geotools/commit/4746e7cf2aa0d257b4c45491a4eab4e3ce76afe1", "message": "Generate PropertyName when literal key supplied\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "ac0f153faa99add803424747b4fddc142d80f352", "url": "https://github.com/geotools/geotools/commit/ac0f153faa99add803424747b4fddc142d80f352", "message": "confirm filter expressions work\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "5fc3ba1398bb2bd0847b1b4e1c68f277ff41fb1f", "url": "https://github.com/geotools/geotools/commit/5fc3ba1398bb2bd0847b1b4e1c68f277ff41fb1f", "message": "improve notification if expression not supported\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "062ff1103b0d4dbd73b32d73dcdcfb7e78136dca", "url": "https://github.com/geotools/geotools/commit/062ff1103b0d4dbd73b32d73dcdcfb7e78136dca", "message": "Test case now reporting the correct PropertyName reference\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "79eddf2949582978e69068c6f33f6c9efa810be8", "url": "https://github.com/geotools/geotools/commit/79eddf2949582978e69068c6f33f6c9efa810be8", "message": "refactor into private methods\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "8a607884335b7f6399329e0c15378cd2be12b0a2", "url": "https://github.com/geotools/geotools/commit/8a607884335b7f6399329e0c15378cd2be12b0a2", "message": "A better null pointer exception message when generating ECQL\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "0981769fa07e445f31599be43e6ddf4ee11dfb7e", "url": "https://github.com/geotools/geotools/commit/0981769fa07e445f31599be43e6ddf4ee11dfb7e", "message": "Test that delegating to MBExpression is working as expected\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "5c55d4834bf99900d7b35fb7bea1755aec1558d9", "url": "https://github.com/geotools/geotools/commit/5c55d4834bf99900d7b35fb7bea1755aec1558d9", "message": "Avoid deprecation warnings\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "2dd047cec1eb8c3b8d157f04751bc8c488287242", "url": "https://github.com/geotools/geotools/commit/2dd047cec1eb8c3b8d157f04751bc8c488287242", "message": "Address feedback\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "0e8e489ce9fe2e94161e9a4bfcc92f21d4d41134", "url": "https://github.com/geotools/geotools/commit/0e8e489ce9fe2e94161e9a4bfcc92f21d4d41134", "message": "Revise based on feedback\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "0e8e489ce9fe2e94161e9a4bfcc92f21d4d41134", "url": "https://github.com/geotools/geotools/commit/0e8e489ce9fe2e94161e9a4bfcc92f21d4d41134", "message": "Revise based on feedback\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "forcePushed"}, {"oid": "7ed7c7dfc752912f81897402378fd201d09e03c7", "url": "https://github.com/geotools/geotools/commit/7ed7c7dfc752912f81897402378fd201d09e03c7", "message": "update based on feedback\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-15T05:57:07Z", "type": "commit"}]}