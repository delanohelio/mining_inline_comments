{"pr_number": 1409, "pr_title": "require> enhancement", "pr_createdAt": "2020-05-26T08:57:54Z", "pr_url": "https://github.com/treasure-data/digdag/pull/1409", "timeline": [{"oid": "3e919f1a12403a966dd01c785df25019738ff212", "url": "https://github.com/treasure-data/digdag/commit/3e919f1a12403a966dd01c785df25019738ff212", "message": "Implement project_name param in require>.", "committedDate": "2020-05-15T03:51:55Z", "type": "commit"}, {"oid": "48b9ae47b4554f8b5b1fa0fadcc1a28842cd07b7", "url": "https://github.com/treasure-data/digdag/commit/48b9ae47b4554f8b5b1fa0fadcc1a28842cd07b7", "message": "Fix documents, template var in test based on the revew.", "committedDate": "2020-05-19T01:40:10Z", "type": "commit"}, {"oid": "db8b0259eddf44c9344ae13e208f2d5152e9515b", "url": "https://github.com/treasure-data/digdag/commit/db8b0259eddf44c9344ae13e208f2d5152e9515b", "message": "Update document.", "committedDate": "2020-05-27T09:19:23Z", "type": "forcePushed"}, {"oid": "fa92db5b52f841a54bff5cbe7fe822fea8daf97f", "url": "https://github.com/treasure-data/digdag/commit/fa92db5b52f841a54bff5cbe7fe822fea8daf97f", "message": "Remove ignore_no_existence and refactoring.", "committedDate": "2020-05-29T03:16:37Z", "type": "forcePushed"}, {"oid": "ef1f5fdeb1b8f248d281b5fb989f714b5b75649e", "url": "https://github.com/treasure-data/digdag/commit/ef1f5fdeb1b8f248d281b5fb989f714b5b75649e", "message": "Implement exponential backoff to reduce num of task retry.", "committedDate": "2020-06-01T05:54:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyOTUyMA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r433929520", "bodyText": "There is an unexpected space between workflowName and ).", "author": "komamitsu", "createdAt": "2020-06-02T14:40:46Z", "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -65,42 +68,157 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n-            int projectId = config.get(\"project_id\", int.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);\n+            if (lastStateParams.has(\"rerun_on_retry_attempt_name\")) { // set for rerun_on parameter.\n+                retryAttemptName = lastStateParams.getOptional(\"rerun_on_retry_attempt_name\", String.class);\n+            }\n+\n             Config overrideParams = config.getNestedOrGetEmpty(\"params\");\n+\n+            Optional<StoredSessionAttempt> attempt = Optional.absent();\n+            Optional<SessionAttemptConflictException> sessionAttemptConflictException = Optional.absent();\n+            Optional<ProjectIdentifier> projectIdentifier = Optional.absent();\n+            /**\n+             *  First of all, try to start attempt by startSession()\n+             *  If no attempt exists (no conflict), it return new StoredSessionAttempt.\n+             *    - set state param \"require_kicked\" to true.\n+             *    - task is retried to wait for done by nextPolling.\n+             *  If something errors happen, it will throw following exceptions.\n+             *    - ResourceNotFoundException ... workflow ,project name(or id) are wrong. -> processed as deterministic error\n+             *    - ResourceLimitExceededException ... this exception should be deterministic error\n+             *    - SessionAttemptConflictException ... this is not error.\n+             *      - If the conflict attempt is still running, wait for until done by nextPolling.\n+             *      - If done, check the state param \"require_kicked\" and whether the attempt is kicked by this require> or not.\n+             *        - If not kicked by this require>, check result and rerun_on option and determine rerun or not.\n+             *          - if need to rerun, generate unique retry_attempt_name and set to \"rerun_on_retry_attempt_name\"\n+             *          - throw nextPolling and in next call of runTask(), \"rerun_on_retry_attempt_name\" is used as retry_attempt_name and must succeed to create new attempt because it is unique.\n+             *        - For both kicked and not kicked, check the result and ignore_failure option\n+             *          - If ignore_failure is true or attempt finished successfully, require> op finished successfully\n+             *          - else finished with exception.\n+             */\n             try {\n-                StoredSessionAttempt attempt = callback.startSession(\n+                projectIdentifier = Optional.of(makeProjectIdentifier());\n+\n+                attempt = Optional.of(callback.startSession(\n                         context,\n                         request.getSiteId(),\n-                        projectId,\n+                        projectIdentifier.get(),\n                         workflowName,\n                         instant,\n                         retryAttemptName,\n-                        overrideParams);\n+                        overrideParams));\n+            }\n+            catch (SessionAttemptConflictException ex) {\n+                sessionAttemptConflictException = Optional.of(ex);\n+            }\n+            catch (ResourceNotFoundException ex) {\n+                throw new TaskExecutionException(String.format(ENGLISH, \"Dependent workflow does not exist. %s, workflowName:%s\",\n+                        projectIdentifier.transform((p)->p.toString()).or(\"\"), workflowName ));", "originalCommit": "ef1f5fdeb1b8f248d281b5fb989f714b5b75649e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMjExNA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434322114", "bodyText": "[minor] (p)->p.toString() can be replaced with ProjectIdentifier::toString", "author": "komamitsu", "createdAt": "2020-06-03T05:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyOTUyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM1NDIwNQ==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434354205", "bodyText": "Thanks! I will fix them.", "author": "yoyama", "createdAt": "2020-06-03T07:12:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyOTUyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQyODE4OQ==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434428189", "bodyText": "Fixed it. Thanks!", "author": "yoyama", "createdAt": "2020-06-03T09:20:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyOTUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMDU5NA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434320594", "bodyText": "What about the case the conflict attempt failed like If failed, xxx?", "author": "komamitsu", "createdAt": "2020-06-03T05:44:06Z", "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -64,46 +68,109 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);\n+            if (lastStateParams.has(\"rerun_on_retry_attempt_name\")) { // set for rerun_on parameter.\n+                retryAttemptName = lastStateParams.getOptional(\"rerun_on_retry_attempt_name\", String.class);\n+            }\n+\n             Config overrideParams = config.getNestedOrGetEmpty(\"params\");\n+\n+            Optional<StoredSessionAttempt> attempt = Optional.absent();\n+            Optional<SessionAttemptConflictException> sessionAttemptConflictException = Optional.absent();\n+            Optional<ProjectIdentifier> projectIdentifier = Optional.absent();\n+            /**\n+             *  First of all, try to start attempt by startSession()\n+             *  If no attempt exists (no conflict), it return new StoredSessionAttempt.\n+             *    - set state param \"require_kicked\" to true.\n+             *    - task is retried to wait for done by nextPolling.\n+             *  If something errors happen, it will throw following exceptions.\n+             *    - ResourceNotFoundException ... workflow ,project name(or id) are wrong. -> processed as deterministic error\n+             *    - ResourceLimitExceededException ... this exception should be deterministic error\n+             *    - SessionAttemptConflictException ... this is not error.\n+             *      - If the conflict attempt is still running, wait for until done by nextPolling.\n+             *      - If done, check the state param \"require_kicked\" and whether the attempt is kicked by this require> or not.", "originalCommit": "ef1f5fdeb1b8f248d281b5fb989f714b5b75649e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM1NDA5Ng==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434354096", "bodyText": "Do you mean, if the attempt which is kicked by require> failed,  what happen?\nIn this case the task will fail as usual.", "author": "yoyama", "createdAt": "2020-06-03T07:11:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMDU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMzIxMw==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434323213", "bodyText": "How about moving this block to the above catch (SessionAttemptConflictException ex) { ... } block? Maybe we can remove the Optional?", "author": "komamitsu", "createdAt": "2020-06-03T05:53:20Z", "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -64,46 +68,109 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);\n+            if (lastStateParams.has(\"rerun_on_retry_attempt_name\")) { // set for rerun_on parameter.\n+                retryAttemptName = lastStateParams.getOptional(\"rerun_on_retry_attempt_name\", String.class);\n+            }\n+\n             Config overrideParams = config.getNestedOrGetEmpty(\"params\");\n+\n+            Optional<StoredSessionAttempt> attempt = Optional.absent();\n+            Optional<SessionAttemptConflictException> sessionAttemptConflictException = Optional.absent();\n+            Optional<ProjectIdentifier> projectIdentifier = Optional.absent();\n+            /**\n+             *  First of all, try to start attempt by startSession()\n+             *  If no attempt exists (no conflict), it return new StoredSessionAttempt.\n+             *    - set state param \"require_kicked\" to true.\n+             *    - task is retried to wait for done by nextPolling.\n+             *  If something errors happen, it will throw following exceptions.\n+             *    - ResourceNotFoundException ... workflow ,project name(or id) are wrong. -> processed as deterministic error\n+             *    - ResourceLimitExceededException ... this exception should be deterministic error\n+             *    - SessionAttemptConflictException ... this is not error.\n+             *      - If the conflict attempt is still running, wait for until done by nextPolling.\n+             *      - If done, check the state param \"require_kicked\" and whether the attempt is kicked by this require> or not.\n+             *        - If not kicked by this require>, check result and rerun_on option and determine rerun or not.\n+             *          - if need to rerun, generate unique retry_attempt_name and set to \"rerun_on_retry_attempt_name\"\n+             *          - throw nextPolling and in next call of runTask(), \"rerun_on_retry_attempt_name\" is used as retry_attempt_name and must succeed to create new attempt because it is unique.\n+             *        - For both kicked and not kicked, check the result and ignore_failure option\n+             *          - If ignore_failure is true or attempt finished successfully, require> op finished successfully\n+             *          - else finished with exception.\n+             */\n             try {\n-                ProjectIdentifier projectIdentifier = makeProjectIdentifier();\n+                projectIdentifier = Optional.of(makeProjectIdentifier());\n \n-                StoredSessionAttempt attempt = callback.startSession(\n+                attempt = Optional.of(callback.startSession(\n                         context,\n                         request.getSiteId(),\n-                        projectIdentifier,\n+                        projectIdentifier.get(),\n                         workflowName,\n                         instant,\n                         retryAttemptName,\n-                        overrideParams);\n+                        overrideParams));\n+            }\n+            catch (SessionAttemptConflictException ex) {\n+                sessionAttemptConflictException = Optional.of(ex);\n+            }\n+            catch (ResourceNotFoundException ex) {\n+                throw new TaskExecutionException(String.format(ENGLISH, \"Dependent workflow does not exist. %s, workflowName:%s\",\n+                        projectIdentifier.transform((p)->p.toString()).or(\"\"), workflowName ));\n+            }\n+            catch (ResourceLimitExceededException ex) {\n+                throw new TaskExecutionException(ex);\n+            }\n \n-                boolean isDone = attempt.getStateFlags().isDone();\n-                if (isDone) {\n-                    if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n+            if (sessionAttemptConflictException.isPresent()) {\n+                StoredSessionAttempt conflictedAttempt = sessionAttemptConflictException.get().getConflictedSession();", "originalCommit": "ef1f5fdeb1b8f248d281b5fb989f714b5b75649e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM1MTA2NA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434351064", "bodyText": "Of course, we can do.  My intention of this way is that firstly get result of startSession() including exception (especially SessionAttemptConflictException is not error), then the logic goes ahead based on the result.\nif we move the logic in catch (SessionAttemptConflictException ex) { ... }, catch {} become large.\nIn this case it is better to define another method and call it.\nWhat is your thought?", "author": "yoyama", "createdAt": "2020-06-03T07:05:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMzIxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQyOTIxOA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434429218", "bodyText": "Based on discussion in person, I fixed it.\nAs result, the code became simple. Thank you for your advice! \ud83d\ude42", "author": "yoyama", "createdAt": "2020-06-03T09:21:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMzIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMzcwMg==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434323702", "bodyText": "How about moving this line to right after calling callback.startSession()  in the above try { ... } block? Maybe we can remove the Optional?", "author": "komamitsu", "createdAt": "2020-06-03T05:54:51Z", "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -64,46 +68,109 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);\n+            if (lastStateParams.has(\"rerun_on_retry_attempt_name\")) { // set for rerun_on parameter.\n+                retryAttemptName = lastStateParams.getOptional(\"rerun_on_retry_attempt_name\", String.class);\n+            }\n+\n             Config overrideParams = config.getNestedOrGetEmpty(\"params\");\n+\n+            Optional<StoredSessionAttempt> attempt = Optional.absent();\n+            Optional<SessionAttemptConflictException> sessionAttemptConflictException = Optional.absent();\n+            Optional<ProjectIdentifier> projectIdentifier = Optional.absent();\n+            /**\n+             *  First of all, try to start attempt by startSession()\n+             *  If no attempt exists (no conflict), it return new StoredSessionAttempt.\n+             *    - set state param \"require_kicked\" to true.\n+             *    - task is retried to wait for done by nextPolling.\n+             *  If something errors happen, it will throw following exceptions.\n+             *    - ResourceNotFoundException ... workflow ,project name(or id) are wrong. -> processed as deterministic error\n+             *    - ResourceLimitExceededException ... this exception should be deterministic error\n+             *    - SessionAttemptConflictException ... this is not error.\n+             *      - If the conflict attempt is still running, wait for until done by nextPolling.\n+             *      - If done, check the state param \"require_kicked\" and whether the attempt is kicked by this require> or not.\n+             *        - If not kicked by this require>, check result and rerun_on option and determine rerun or not.\n+             *          - if need to rerun, generate unique retry_attempt_name and set to \"rerun_on_retry_attempt_name\"\n+             *          - throw nextPolling and in next call of runTask(), \"rerun_on_retry_attempt_name\" is used as retry_attempt_name and must succeed to create new attempt because it is unique.\n+             *        - For both kicked and not kicked, check the result and ignore_failure option\n+             *          - If ignore_failure is true or attempt finished successfully, require> op finished successfully\n+             *          - else finished with exception.\n+             */\n             try {\n-                ProjectIdentifier projectIdentifier = makeProjectIdentifier();\n+                projectIdentifier = Optional.of(makeProjectIdentifier());\n \n-                StoredSessionAttempt attempt = callback.startSession(\n+                attempt = Optional.of(callback.startSession(\n                         context,\n                         request.getSiteId(),\n-                        projectIdentifier,\n+                        projectIdentifier.get(),\n                         workflowName,\n                         instant,\n                         retryAttemptName,\n-                        overrideParams);\n+                        overrideParams));\n+            }\n+            catch (SessionAttemptConflictException ex) {\n+                sessionAttemptConflictException = Optional.of(ex);\n+            }\n+            catch (ResourceNotFoundException ex) {\n+                throw new TaskExecutionException(String.format(ENGLISH, \"Dependent workflow does not exist. %s, workflowName:%s\",\n+                        projectIdentifier.transform((p)->p.toString()).or(\"\"), workflowName ));\n+            }\n+            catch (ResourceLimitExceededException ex) {\n+                throw new TaskExecutionException(ex);\n+            }\n \n-                boolean isDone = attempt.getStateFlags().isDone();\n-                if (isDone) {\n-                    if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n+            if (sessionAttemptConflictException.isPresent()) {\n+                StoredSessionAttempt conflictedAttempt = sessionAttemptConflictException.get().getConflictedSession();\n+                if (conflictedAttempt.getStateFlags().isDone()) {\n+                    // A flag to distinguish whether the attempt is kicked by require> or previous attempt.\n+                    boolean requireKicked = lastStateParams.get(\"require_kicked\", boolean.class, false);\n+                    if (!requireKicked &&  (\n+                            rerunOn == OptionRerunOn.ALL ||\n+                            rerunOn == OptionRerunOn.FAILED && !conflictedAttempt.getStateFlags().isSuccess())) {\n+\n+                        //To force run, set flag gen_retry_attempt_name and do polling\n+                        throw nextPolling(lastStateParams.deepCopy().set(\"rerun_on_retry_attempt_name\", UUID.randomUUID().toString()));\n+                    }\n+                    if (!ignoreFailure && !conflictedAttempt.getStateFlags().isSuccess()) {\n                         // ignore_failure is false and the attempt is in error state. Make this operator failed.\n                         throw new TaskExecutionException(String.format(ENGLISH,\n-                                    \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n-                                    attempt.getSessionId(), attempt.getId()));\n+                            \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n+                            conflictedAttempt.getSessionId(), conflictedAttempt.getId()));\n                     }\n                     return TaskResult.empty(cf);\n                 }\n                 else {\n-                    // TODO use exponential-backoff to calculate retry interval\n-                    throw TaskExecutionException.ofNextPolling(1, ConfigElement.copyOf(request.getLastStateParams()));\n+                    // Wait for finish running attempt\n+                    throw nextPolling(request.getLastStateParams().deepCopy());\n                 }\n             }\n-            catch (ResourceNotFoundException ex) {\n-                throw new ConfigException(ex);\n+            else if (attempt.isPresent()) { // startSession succeeded and created new attempt\n+                throw nextPolling(request.getLastStateParams().deepCopy().set(\"require_kicked\", true));", "originalCommit": "ef1f5fdeb1b8f248d281b5fb989f714b5b75649e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM1MTk1NA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434351954", "bodyText": "My intention is same as above. But this code is small.\nSo I agree with move to try{..}.", "author": "yoyama", "createdAt": "2020-06-03T07:07:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMzcwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQyOTM0Ng==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434429346", "bodyText": "Fixed it. Thanks!", "author": "yoyama", "createdAt": "2020-06-03T09:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMzcwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1OTc5OA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434959798", "bodyText": "I'm wondering if this scope reduction of retry_attempt_name can affect existing workflows...", "author": "komamitsu", "createdAt": "2020-06-04T02:39:11Z", "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -65,43 +68,149 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n-            int projectId = config.get(\"project_id\", int.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);", "originalCommit": "1bee39f38f9c07cee67357e846d3021616b171a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAzMDM4Mw==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435030383", "bodyText": "Yes. There is possibility as discussion in person.\nLet me discuss again in a meeting.", "author": "yoyama", "createdAt": "2020-06-04T06:54:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1OTc5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA0MzAxNQ==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435043015", "bodyText": "Just noticed you've already mentioned it in the document :)", "author": "komamitsu", "createdAt": "2020-06-04T07:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1OTc5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2NDc4Nw==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434964787", "bodyText": "This isn't used?", "author": "komamitsu", "createdAt": "2020-06-04T02:58:37Z", "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -65,43 +68,149 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n-            int projectId = config.get(\"project_id\", int.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);\n+            if (lastStateParams.has(\"rerun_on_retry_attempt_name\")) { // set for rerun_on parameter.\n+                retryAttemptName = lastStateParams.getOptional(\"rerun_on_retry_attempt_name\", String.class);\n+            }\n+\n             Config overrideParams = config.getNestedOrGetEmpty(\"params\");\n+\n+            Optional<ProjectIdentifier> projectIdentifier = Optional.absent();\n+            /**\n+             *  First of all, try to start attempt by startSession()\n+             *  If no attempt exists (no conflict), it return new StoredSessionAttempt.\n+             *    - set state param \"require_kicked\" to true.\n+             *    - task is retried to wait for done by nextPolling.\n+             *  If something errors happen, it will throw following exceptions.\n+             *    - ResourceNotFoundException ... workflow ,project name(or id) are wrong. -> processed as deterministic error\n+             *    - ResourceLimitExceededException ... this exception should be deterministic error\n+             *    - SessionAttemptConflictException ... this is not error.\n+             *      - If the conflict attempt is still running, wait for until done by nextPolling.\n+             *      - If done, check the state param \"require_kicked\" and whether the attempt is kicked by this require> or not.\n+             *        - If not kicked by this require>, check result and rerun_on option and determine rerun or not.\n+             *          - if need to rerun, generate unique retry_attempt_name and set to \"rerun_on_retry_attempt_name\"\n+             *          - throw nextPolling and in next call of runTask(), \"rerun_on_retry_attempt_name\" is used as retry_attempt_name and must succeed to create new attempt because it is unique.\n+             *        - For both kicked and not kicked, check the result and ignore_failure option\n+             *          - If ignore_failure is true or attempt finished successfully, require> op finished successfully\n+             *          - else finished with exception.\n+             */\n             try {\n-                StoredSessionAttempt attempt = callback.startSession(\n+                projectIdentifier = Optional.of(makeProjectIdentifier());\n+\n+                callback.startSession(\n                         context,\n                         request.getSiteId(),\n-                        projectId,\n+                        projectIdentifier.get(),\n                         workflowName,\n                         instant,\n                         retryAttemptName,\n                         overrideParams);\n-\n-                boolean isDone = attempt.getStateFlags().isDone();\n-                if (isDone) {\n-                    if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n-                        // ignore_failure is false and the attempt is in error state. Make this operator failed.\n-                        throw new TaskExecutionException(String.format(ENGLISH,\n-                                    \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n-                                    attempt.getSessionId(), attempt.getId()));\n-                    }\n-                    return TaskResult.empty(cf);\n-                }\n-                else {\n-                    // TODO use exponential-backoff to calculate retry interval\n-                    throw TaskExecutionException.ofNextPolling(1, ConfigElement.copyOf(request.getLastStateParams()));\n-                }\n+                throw nextPolling(request.getLastStateParams().deepCopy().set(\"require_kicked\", true));\n+            }\n+            catch (SessionAttemptConflictException ex) {\n+                return processAttempt(ex.getConflictedSession(), lastStateParams, rerunOn, ignoreFailure);\n             }\n             catch (ResourceNotFoundException ex) {\n-                throw new ConfigException(ex);\n+                throw new TaskExecutionException(String.format(ENGLISH, \"Dependent workflow does not exist. %s, workflowName:%s\",\n+                        projectIdentifier.transform(ProjectIdentifier::toString).or(\"\"), workflowName));\n             }\n             catch (ResourceLimitExceededException ex) {\n                 throw new TaskExecutionException(ex);\n             }\n         }\n+\n+        private TaskResult processAttempt(StoredSessionAttempt attempt, Config lastStateParams, OptionRerunOn rerunOn, boolean ignoreFailure)\n+        {\n+            if (attempt.getStateFlags().isDone()) {\n+                // A flag to distinguish whether the attempt is kicked by require> or previous attempt.\n+                boolean requireKicked = lastStateParams.get(\"require_kicked\", boolean.class, false);\n+                if (!requireKicked &&  (\n+                        rerunOn == OptionRerunOn.ALL ||\n+                                rerunOn == OptionRerunOn.FAILED && !attempt.getStateFlags().isSuccess())) {\n+\n+                    //To force run, set flag gen_retry_attempt_name and do polling\n+                    throw nextPolling(lastStateParams.deepCopy().set(\"rerun_on_retry_attempt_name\", UUID.randomUUID().toString()));\n+                }\n+                if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n+                    // ignore_failure is false and the attempt is in error state. Make this operator failed.\n+                    throw new TaskExecutionException(String.format(ENGLISH,\n+                            \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n+                            attempt.getSessionId(), attempt.getId()));\n+                }\n+                return TaskResult.empty(cf);\n+            }\n+            else {\n+                // Wait for finish running attempt\n+                throw nextPolling(request.getLastStateParams().deepCopy());\n+            }\n+        }\n+\n+        private TaskExecutionException nextPolling(Config stateParams)\n+        {\n+            int iteration = stateParams.get(\"retry\", int.class, 0);\n+            stateParams.set(\"retry\", iteration+1);\n+            int interval = (int) Math.min(1 * Math.pow(2, iteration), MAX_TASK_RETRY_INTERVAL);\n+\n+            return TaskExecutionException.ofNextPolling( interval, ConfigElement.copyOf(stateParams));\n+        }\n+\n+        /**\n+         * Make ProjectIdentifier from parameters.\n+         * @return\n+         */\n+        private ProjectIdentifier makeProjectIdentifier()\n+        {\n+            Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            int projectId = config.get(\"project_id\", int.class);\n+            Optional<Integer> projectIdParam = localConfig.getOptional(\"project_id\", Integer.class);\n+            Optional<String> projectNameParam = localConfig.getOptional(\"project_name\", String.class);\n+\n+            if (projectIdParam.isPresent() && projectNameParam.isPresent()) {\n+                throw new ConfigException(\"Both project_id and project_name can't be set\");\n+            }\n+            ProjectIdentifier projectIdentifier;\n+            if (projectNameParam.isPresent()) {\n+                projectIdentifier = ProjectIdentifier.ofName(projectNameParam.get());\n+            }\n+            else if (projectIdParam.isPresent()) {\n+                projectIdentifier = ProjectIdentifier.ofId(projectIdParam.get());\n+            }\n+            else {\n+                projectIdentifier = ProjectIdentifier.ofId(projectId);\n+            }\n+            return projectIdentifier;\n+        }\n+    }\n+\n+    enum OptionRerunOn\n+    {\n+        NONE(\"none\"),\n+        FAILED( \"failed\"),\n+        ALL (\"all\");\n+\n+        private final String name;", "originalCommit": "1bee39f38f9c07cee67357e846d3021616b171a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAyODQ5Mw==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435028493", "bodyText": "Ah, correct. Currently not used. Will remove it. Thanks!", "author": "yoyama", "createdAt": "2020-06-04T06:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2NDc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2ODIyNA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434968224", "bodyText": "When OptionRerunOn.ALL is set, the workflow should be executed regardless it was executed via require operator or not, right? If so, rerunOn == OptionRerunOn.ALL should not depend on requireKicked?", "author": "komamitsu", "createdAt": "2020-06-04T03:13:35Z", "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -65,43 +68,149 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n-            int projectId = config.get(\"project_id\", int.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);\n+            if (lastStateParams.has(\"rerun_on_retry_attempt_name\")) { // set for rerun_on parameter.\n+                retryAttemptName = lastStateParams.getOptional(\"rerun_on_retry_attempt_name\", String.class);\n+            }\n+\n             Config overrideParams = config.getNestedOrGetEmpty(\"params\");\n+\n+            Optional<ProjectIdentifier> projectIdentifier = Optional.absent();\n+            /**\n+             *  First of all, try to start attempt by startSession()\n+             *  If no attempt exists (no conflict), it return new StoredSessionAttempt.\n+             *    - set state param \"require_kicked\" to true.\n+             *    - task is retried to wait for done by nextPolling.\n+             *  If something errors happen, it will throw following exceptions.\n+             *    - ResourceNotFoundException ... workflow ,project name(or id) are wrong. -> processed as deterministic error\n+             *    - ResourceLimitExceededException ... this exception should be deterministic error\n+             *    - SessionAttemptConflictException ... this is not error.\n+             *      - If the conflict attempt is still running, wait for until done by nextPolling.\n+             *      - If done, check the state param \"require_kicked\" and whether the attempt is kicked by this require> or not.\n+             *        - If not kicked by this require>, check result and rerun_on option and determine rerun or not.\n+             *          - if need to rerun, generate unique retry_attempt_name and set to \"rerun_on_retry_attempt_name\"\n+             *          - throw nextPolling and in next call of runTask(), \"rerun_on_retry_attempt_name\" is used as retry_attempt_name and must succeed to create new attempt because it is unique.\n+             *        - For both kicked and not kicked, check the result and ignore_failure option\n+             *          - If ignore_failure is true or attempt finished successfully, require> op finished successfully\n+             *          - else finished with exception.\n+             */\n             try {\n-                StoredSessionAttempt attempt = callback.startSession(\n+                projectIdentifier = Optional.of(makeProjectIdentifier());\n+\n+                callback.startSession(\n                         context,\n                         request.getSiteId(),\n-                        projectId,\n+                        projectIdentifier.get(),\n                         workflowName,\n                         instant,\n                         retryAttemptName,\n                         overrideParams);\n-\n-                boolean isDone = attempt.getStateFlags().isDone();\n-                if (isDone) {\n-                    if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n-                        // ignore_failure is false and the attempt is in error state. Make this operator failed.\n-                        throw new TaskExecutionException(String.format(ENGLISH,\n-                                    \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n-                                    attempt.getSessionId(), attempt.getId()));\n-                    }\n-                    return TaskResult.empty(cf);\n-                }\n-                else {\n-                    // TODO use exponential-backoff to calculate retry interval\n-                    throw TaskExecutionException.ofNextPolling(1, ConfigElement.copyOf(request.getLastStateParams()));\n-                }\n+                throw nextPolling(request.getLastStateParams().deepCopy().set(\"require_kicked\", true));\n+            }\n+            catch (SessionAttemptConflictException ex) {\n+                return processAttempt(ex.getConflictedSession(), lastStateParams, rerunOn, ignoreFailure);\n             }\n             catch (ResourceNotFoundException ex) {\n-                throw new ConfigException(ex);\n+                throw new TaskExecutionException(String.format(ENGLISH, \"Dependent workflow does not exist. %s, workflowName:%s\",\n+                        projectIdentifier.transform(ProjectIdentifier::toString).or(\"\"), workflowName));\n             }\n             catch (ResourceLimitExceededException ex) {\n                 throw new TaskExecutionException(ex);\n             }\n         }\n+\n+        private TaskResult processAttempt(StoredSessionAttempt attempt, Config lastStateParams, OptionRerunOn rerunOn, boolean ignoreFailure)\n+        {\n+            if (attempt.getStateFlags().isDone()) {\n+                // A flag to distinguish whether the attempt is kicked by require> or previous attempt.\n+                boolean requireKicked = lastStateParams.get(\"require_kicked\", boolean.class, false);\n+                if (!requireKicked &&  (\n+                        rerunOn == OptionRerunOn.ALL ||", "originalCommit": "1bee39f38f9c07cee67357e846d3021616b171a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3MzExNQ==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434973115", "bodyText": "Ah, got it. I had a wrong idea. It's for Check attempt kicker on the diagram.", "author": "komamitsu", "createdAt": "2020-06-04T03:34:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2ODIyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxNjY3Nw==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435016677", "bodyText": "A space on the left of interval", "author": "komamitsu", "createdAt": "2020-06-04T06:20:41Z", "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -65,43 +68,149 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n-            int projectId = config.get(\"project_id\", int.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);\n+            if (lastStateParams.has(\"rerun_on_retry_attempt_name\")) { // set for rerun_on parameter.\n+                retryAttemptName = lastStateParams.getOptional(\"rerun_on_retry_attempt_name\", String.class);\n+            }\n+\n             Config overrideParams = config.getNestedOrGetEmpty(\"params\");\n+\n+            Optional<ProjectIdentifier> projectIdentifier = Optional.absent();\n+            /**\n+             *  First of all, try to start attempt by startSession()\n+             *  If no attempt exists (no conflict), it return new StoredSessionAttempt.\n+             *    - set state param \"require_kicked\" to true.\n+             *    - task is retried to wait for done by nextPolling.\n+             *  If something errors happen, it will throw following exceptions.\n+             *    - ResourceNotFoundException ... workflow ,project name(or id) are wrong. -> processed as deterministic error\n+             *    - ResourceLimitExceededException ... this exception should be deterministic error\n+             *    - SessionAttemptConflictException ... this is not error.\n+             *      - If the conflict attempt is still running, wait for until done by nextPolling.\n+             *      - If done, check the state param \"require_kicked\" and whether the attempt is kicked by this require> or not.\n+             *        - If not kicked by this require>, check result and rerun_on option and determine rerun or not.\n+             *          - if need to rerun, generate unique retry_attempt_name and set to \"rerun_on_retry_attempt_name\"\n+             *          - throw nextPolling and in next call of runTask(), \"rerun_on_retry_attempt_name\" is used as retry_attempt_name and must succeed to create new attempt because it is unique.\n+             *        - For both kicked and not kicked, check the result and ignore_failure option\n+             *          - If ignore_failure is true or attempt finished successfully, require> op finished successfully\n+             *          - else finished with exception.\n+             */\n             try {\n-                StoredSessionAttempt attempt = callback.startSession(\n+                projectIdentifier = Optional.of(makeProjectIdentifier());\n+\n+                callback.startSession(\n                         context,\n                         request.getSiteId(),\n-                        projectId,\n+                        projectIdentifier.get(),\n                         workflowName,\n                         instant,\n                         retryAttemptName,\n                         overrideParams);\n-\n-                boolean isDone = attempt.getStateFlags().isDone();\n-                if (isDone) {\n-                    if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n-                        // ignore_failure is false and the attempt is in error state. Make this operator failed.\n-                        throw new TaskExecutionException(String.format(ENGLISH,\n-                                    \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n-                                    attempt.getSessionId(), attempt.getId()));\n-                    }\n-                    return TaskResult.empty(cf);\n-                }\n-                else {\n-                    // TODO use exponential-backoff to calculate retry interval\n-                    throw TaskExecutionException.ofNextPolling(1, ConfigElement.copyOf(request.getLastStateParams()));\n-                }\n+                throw nextPolling(request.getLastStateParams().deepCopy().set(\"require_kicked\", true));\n+            }\n+            catch (SessionAttemptConflictException ex) {\n+                return processAttempt(ex.getConflictedSession(), lastStateParams, rerunOn, ignoreFailure);\n             }\n             catch (ResourceNotFoundException ex) {\n-                throw new ConfigException(ex);\n+                throw new TaskExecutionException(String.format(ENGLISH, \"Dependent workflow does not exist. %s, workflowName:%s\",\n+                        projectIdentifier.transform(ProjectIdentifier::toString).or(\"\"), workflowName));\n             }\n             catch (ResourceLimitExceededException ex) {\n                 throw new TaskExecutionException(ex);\n             }\n         }\n+\n+        private TaskResult processAttempt(StoredSessionAttempt attempt, Config lastStateParams, OptionRerunOn rerunOn, boolean ignoreFailure)\n+        {\n+            if (attempt.getStateFlags().isDone()) {\n+                // A flag to distinguish whether the attempt is kicked by require> or previous attempt.\n+                boolean requireKicked = lastStateParams.get(\"require_kicked\", boolean.class, false);\n+                if (!requireKicked &&  (\n+                        rerunOn == OptionRerunOn.ALL ||\n+                                rerunOn == OptionRerunOn.FAILED && !attempt.getStateFlags().isSuccess())) {\n+\n+                    //To force run, set flag gen_retry_attempt_name and do polling\n+                    throw nextPolling(lastStateParams.deepCopy().set(\"rerun_on_retry_attempt_name\", UUID.randomUUID().toString()));\n+                }\n+                if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n+                    // ignore_failure is false and the attempt is in error state. Make this operator failed.\n+                    throw new TaskExecutionException(String.format(ENGLISH,\n+                            \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n+                            attempt.getSessionId(), attempt.getId()));\n+                }\n+                return TaskResult.empty(cf);\n+            }\n+            else {\n+                // Wait for finish running attempt\n+                throw nextPolling(request.getLastStateParams().deepCopy());\n+            }\n+        }\n+\n+        private TaskExecutionException nextPolling(Config stateParams)\n+        {\n+            int iteration = stateParams.get(\"retry\", int.class, 0);\n+            stateParams.set(\"retry\", iteration+1);\n+            int interval = (int) Math.min(1 * Math.pow(2, iteration), MAX_TASK_RETRY_INTERVAL);\n+\n+            return TaskExecutionException.ofNextPolling( interval, ConfigElement.copyOf(stateParams));", "originalCommit": "1bee39f38f9c07cee67357e846d3021616b171a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwNTM3Ng==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435105376", "bodyText": "Thanks! Fixed it.", "author": "yoyama", "createdAt": "2020-06-04T09:07:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxNjY3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxNjkzNg==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435016936", "bodyText": "Spaces on the both sides of + would be better?", "author": "komamitsu", "createdAt": "2020-06-04T06:21:26Z", "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -65,43 +68,149 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n-            int projectId = config.get(\"project_id\", int.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);\n+            if (lastStateParams.has(\"rerun_on_retry_attempt_name\")) { // set for rerun_on parameter.\n+                retryAttemptName = lastStateParams.getOptional(\"rerun_on_retry_attempt_name\", String.class);\n+            }\n+\n             Config overrideParams = config.getNestedOrGetEmpty(\"params\");\n+\n+            Optional<ProjectIdentifier> projectIdentifier = Optional.absent();\n+            /**\n+             *  First of all, try to start attempt by startSession()\n+             *  If no attempt exists (no conflict), it return new StoredSessionAttempt.\n+             *    - set state param \"require_kicked\" to true.\n+             *    - task is retried to wait for done by nextPolling.\n+             *  If something errors happen, it will throw following exceptions.\n+             *    - ResourceNotFoundException ... workflow ,project name(or id) are wrong. -> processed as deterministic error\n+             *    - ResourceLimitExceededException ... this exception should be deterministic error\n+             *    - SessionAttemptConflictException ... this is not error.\n+             *      - If the conflict attempt is still running, wait for until done by nextPolling.\n+             *      - If done, check the state param \"require_kicked\" and whether the attempt is kicked by this require> or not.\n+             *        - If not kicked by this require>, check result and rerun_on option and determine rerun or not.\n+             *          - if need to rerun, generate unique retry_attempt_name and set to \"rerun_on_retry_attempt_name\"\n+             *          - throw nextPolling and in next call of runTask(), \"rerun_on_retry_attempt_name\" is used as retry_attempt_name and must succeed to create new attempt because it is unique.\n+             *        - For both kicked and not kicked, check the result and ignore_failure option\n+             *          - If ignore_failure is true or attempt finished successfully, require> op finished successfully\n+             *          - else finished with exception.\n+             */\n             try {\n-                StoredSessionAttempt attempt = callback.startSession(\n+                projectIdentifier = Optional.of(makeProjectIdentifier());\n+\n+                callback.startSession(\n                         context,\n                         request.getSiteId(),\n-                        projectId,\n+                        projectIdentifier.get(),\n                         workflowName,\n                         instant,\n                         retryAttemptName,\n                         overrideParams);\n-\n-                boolean isDone = attempt.getStateFlags().isDone();\n-                if (isDone) {\n-                    if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n-                        // ignore_failure is false and the attempt is in error state. Make this operator failed.\n-                        throw new TaskExecutionException(String.format(ENGLISH,\n-                                    \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n-                                    attempt.getSessionId(), attempt.getId()));\n-                    }\n-                    return TaskResult.empty(cf);\n-                }\n-                else {\n-                    // TODO use exponential-backoff to calculate retry interval\n-                    throw TaskExecutionException.ofNextPolling(1, ConfigElement.copyOf(request.getLastStateParams()));\n-                }\n+                throw nextPolling(request.getLastStateParams().deepCopy().set(\"require_kicked\", true));\n+            }\n+            catch (SessionAttemptConflictException ex) {\n+                return processAttempt(ex.getConflictedSession(), lastStateParams, rerunOn, ignoreFailure);\n             }\n             catch (ResourceNotFoundException ex) {\n-                throw new ConfigException(ex);\n+                throw new TaskExecutionException(String.format(ENGLISH, \"Dependent workflow does not exist. %s, workflowName:%s\",\n+                        projectIdentifier.transform(ProjectIdentifier::toString).or(\"\"), workflowName));\n             }\n             catch (ResourceLimitExceededException ex) {\n                 throw new TaskExecutionException(ex);\n             }\n         }\n+\n+        private TaskResult processAttempt(StoredSessionAttempt attempt, Config lastStateParams, OptionRerunOn rerunOn, boolean ignoreFailure)\n+        {\n+            if (attempt.getStateFlags().isDone()) {\n+                // A flag to distinguish whether the attempt is kicked by require> or previous attempt.\n+                boolean requireKicked = lastStateParams.get(\"require_kicked\", boolean.class, false);\n+                if (!requireKicked &&  (\n+                        rerunOn == OptionRerunOn.ALL ||\n+                                rerunOn == OptionRerunOn.FAILED && !attempt.getStateFlags().isSuccess())) {\n+\n+                    //To force run, set flag gen_retry_attempt_name and do polling\n+                    throw nextPolling(lastStateParams.deepCopy().set(\"rerun_on_retry_attempt_name\", UUID.randomUUID().toString()));\n+                }\n+                if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n+                    // ignore_failure is false and the attempt is in error state. Make this operator failed.\n+                    throw new TaskExecutionException(String.format(ENGLISH,\n+                            \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n+                            attempt.getSessionId(), attempt.getId()));\n+                }\n+                return TaskResult.empty(cf);\n+            }\n+            else {\n+                // Wait for finish running attempt\n+                throw nextPolling(request.getLastStateParams().deepCopy());\n+            }\n+        }\n+\n+        private TaskExecutionException nextPolling(Config stateParams)\n+        {\n+            int iteration = stateParams.get(\"retry\", int.class, 0);\n+            stateParams.set(\"retry\", iteration+1);", "originalCommit": "1bee39f38f9c07cee67357e846d3021616b171a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwNTYwNA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435105604", "bodyText": "Thanks! Fixed it.", "author": "yoyama", "createdAt": "2020-06-04T09:08:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxNjkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxNzc1MA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435017750", "bodyText": "Maybe duplicated deep copy?", "author": "komamitsu", "createdAt": "2020-06-04T06:23:40Z", "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -65,43 +68,149 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n-            int projectId = config.get(\"project_id\", int.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);\n+            if (lastStateParams.has(\"rerun_on_retry_attempt_name\")) { // set for rerun_on parameter.\n+                retryAttemptName = lastStateParams.getOptional(\"rerun_on_retry_attempt_name\", String.class);\n+            }\n+\n             Config overrideParams = config.getNestedOrGetEmpty(\"params\");\n+\n+            Optional<ProjectIdentifier> projectIdentifier = Optional.absent();\n+            /**\n+             *  First of all, try to start attempt by startSession()\n+             *  If no attempt exists (no conflict), it return new StoredSessionAttempt.\n+             *    - set state param \"require_kicked\" to true.\n+             *    - task is retried to wait for done by nextPolling.\n+             *  If something errors happen, it will throw following exceptions.\n+             *    - ResourceNotFoundException ... workflow ,project name(or id) are wrong. -> processed as deterministic error\n+             *    - ResourceLimitExceededException ... this exception should be deterministic error\n+             *    - SessionAttemptConflictException ... this is not error.\n+             *      - If the conflict attempt is still running, wait for until done by nextPolling.\n+             *      - If done, check the state param \"require_kicked\" and whether the attempt is kicked by this require> or not.\n+             *        - If not kicked by this require>, check result and rerun_on option and determine rerun or not.\n+             *          - if need to rerun, generate unique retry_attempt_name and set to \"rerun_on_retry_attempt_name\"\n+             *          - throw nextPolling and in next call of runTask(), \"rerun_on_retry_attempt_name\" is used as retry_attempt_name and must succeed to create new attempt because it is unique.\n+             *        - For both kicked and not kicked, check the result and ignore_failure option\n+             *          - If ignore_failure is true or attempt finished successfully, require> op finished successfully\n+             *          - else finished with exception.\n+             */\n             try {\n-                StoredSessionAttempt attempt = callback.startSession(\n+                projectIdentifier = Optional.of(makeProjectIdentifier());\n+\n+                callback.startSession(\n                         context,\n                         request.getSiteId(),\n-                        projectId,\n+                        projectIdentifier.get(),\n                         workflowName,\n                         instant,\n                         retryAttemptName,\n                         overrideParams);\n-\n-                boolean isDone = attempt.getStateFlags().isDone();\n-                if (isDone) {\n-                    if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n-                        // ignore_failure is false and the attempt is in error state. Make this operator failed.\n-                        throw new TaskExecutionException(String.format(ENGLISH,\n-                                    \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n-                                    attempt.getSessionId(), attempt.getId()));\n-                    }\n-                    return TaskResult.empty(cf);\n-                }\n-                else {\n-                    // TODO use exponential-backoff to calculate retry interval\n-                    throw TaskExecutionException.ofNextPolling(1, ConfigElement.copyOf(request.getLastStateParams()));\n-                }\n+                throw nextPolling(request.getLastStateParams().deepCopy().set(\"require_kicked\", true));\n+            }\n+            catch (SessionAttemptConflictException ex) {\n+                return processAttempt(ex.getConflictedSession(), lastStateParams, rerunOn, ignoreFailure);\n             }\n             catch (ResourceNotFoundException ex) {\n-                throw new ConfigException(ex);\n+                throw new TaskExecutionException(String.format(ENGLISH, \"Dependent workflow does not exist. %s, workflowName:%s\",\n+                        projectIdentifier.transform(ProjectIdentifier::toString).or(\"\"), workflowName));\n             }\n             catch (ResourceLimitExceededException ex) {\n                 throw new TaskExecutionException(ex);\n             }\n         }\n+\n+        private TaskResult processAttempt(StoredSessionAttempt attempt, Config lastStateParams, OptionRerunOn rerunOn, boolean ignoreFailure)\n+        {\n+            if (attempt.getStateFlags().isDone()) {\n+                // A flag to distinguish whether the attempt is kicked by require> or previous attempt.\n+                boolean requireKicked = lastStateParams.get(\"require_kicked\", boolean.class, false);\n+                if (!requireKicked &&  (\n+                        rerunOn == OptionRerunOn.ALL ||\n+                                rerunOn == OptionRerunOn.FAILED && !attempt.getStateFlags().isSuccess())) {\n+\n+                    //To force run, set flag gen_retry_attempt_name and do polling\n+                    throw nextPolling(lastStateParams.deepCopy().set(\"rerun_on_retry_attempt_name\", UUID.randomUUID().toString()));\n+                }\n+                if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n+                    // ignore_failure is false and the attempt is in error state. Make this operator failed.\n+                    throw new TaskExecutionException(String.format(ENGLISH,\n+                            \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n+                            attempt.getSessionId(), attempt.getId()));\n+                }\n+                return TaskResult.empty(cf);\n+            }\n+            else {\n+                // Wait for finish running attempt\n+                throw nextPolling(request.getLastStateParams().deepCopy());", "originalCommit": "1bee39f38f9c07cee67357e846d3021616b171a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAzNDQ2MA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435034460", "bodyText": "May be not duplicated, but I should use lastStateParam argument in my understand.", "author": "yoyama", "createdAt": "2020-06-04T07:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxNzc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwNTg4NA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435105884", "bodyText": "I updated it.", "author": "yoyama", "createdAt": "2020-06-04T09:08:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxNzc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMzY5Mg==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435113692", "bodyText": "Just posted a comment https://github.com/treasure-data/digdag/pull/1405/files#r435112975", "author": "komamitsu", "createdAt": "2020-06-04T09:21:54Z", "path": "digdag-tests/src/test/java/acceptance/RequireIT.java", "diffHunk": "@@ -185,6 +203,159 @@ public void testIgnoreProjectIdParam()\n         assertThat(success, is(true)); // --param project_id=-1 is ignored.\n     }\n \n+    /**\n+     * Test for project_id and project_name parameter\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRequireToAnotherProject()\n+            throws Exception\n+    {\n+        final String childProjectName = \"child_another\";\n+\n+        // Push child project\n+        Path childProjectDir = folder.getRoot().toPath().resolve(\"another_foobar\");\n+        Files.createDirectories(childProjectDir);\n+        copyResource(\"acceptance/require/child_another_project.dig\", childProjectDir);\n+        CommandStatus pushChildStatus = main(\"push\",\n+                \"--project\", childProjectDir.toString(),\n+                childProjectName,\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushChildStatus.errUtf8(), pushChildStatus.code(), is(0));\n+\n+        // extract child project id\n+        Matcher m = Pattern.compile(\".*\\\\s+id:\\\\s+(\\\\d+).*\").matcher(pushChildStatus.outUtf8());\n+        assertThat(m.find(), is(true));\n+        String childProjectId = m.group(1);\n+\n+        // Push parent project\n+        Files.write(projectDir.resolve(\"parent_another_project.dig\"), asList(Resources.toString(\n+                Resources.getResource(\"acceptance/require/parent_another_project.dig\"), UTF_8)\n+                .replace(\"__CHILD_PROJECT_ID__\", childProjectId)\n+                .replace(\"__CHILD_PROJECT_NAME__\", childProjectName)));\n+        CommandStatus pushParentStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"parent_another\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushParentStatus.errUtf8(), pushParentStatus.code(), is(0));\n+\n+        CommandStatus startStatus = main(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"parent_another\", \"parent_another_project\",\n+                \"--session\", \"now\"\n+        );\n+        assertThat(startStatus.errUtf8(), startStatus.code(), is(0));", "originalCommit": "5e899ca2ad3760e3b946633f172ed6e9990a018f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MTQ5Mg==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435741492", "bodyText": "I fixed it in #1405 and if it become OK, rebase to this PR.", "author": "yoyama", "createdAt": "2020-06-05T07:35:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMzY5Mg=="}], "type": "inlineReview"}, {"oid": "211dde3347f2dde718b149b3e0d440721f177b55", "url": "https://github.com/treasure-data/digdag/commit/211dde3347f2dde718b149b3e0d440721f177b55", "message": "Fix RequireIT", "committedDate": "2020-06-05T02:14:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NjUwMQ==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435686501", "bodyText": "[minor] Space", "author": "komamitsu", "createdAt": "2020-06-05T04:42:08Z", "path": "digdag-tests/src/test/java/acceptance/RequireIT.java", "diffHunk": "@@ -185,6 +203,159 @@ public void testIgnoreProjectIdParam()\n         assertThat(success, is(true)); // --param project_id=-1 is ignored.\n     }\n \n+    /**\n+     * Test for project_id and project_name parameter\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRequireToAnotherProject()\n+            throws Exception\n+    {\n+        final String childProjectName = \"child_another\";\n+\n+        // Push child project\n+        Path childProjectDir = folder.getRoot().toPath().resolve(\"another_foobar\");\n+        Files.createDirectories(childProjectDir);\n+        copyResource(\"acceptance/require/child_another_project.dig\", childProjectDir);\n+        CommandStatus pushChildStatus = main(\"push\",\n+                \"--project\", childProjectDir.toString(),\n+                childProjectName,\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushChildStatus.errUtf8(), pushChildStatus.code(), is(0));\n+\n+        // extract child project id\n+        Matcher m = Pattern.compile(\".*\\\\s+id:\\\\s+(\\\\d+).*\").matcher(pushChildStatus.outUtf8());\n+        assertThat(m.find(), is(true));\n+        String childProjectId = m.group(1);\n+\n+        // Push parent project\n+        Files.write(projectDir.resolve(\"parent_another_project.dig\"), asList(Resources.toString(\n+                Resources.getResource(\"acceptance/require/parent_another_project.dig\"), UTF_8)\n+                .replace(\"__CHILD_PROJECT_ID__\", childProjectId)\n+                .replace(\"__CHILD_PROJECT_NAME__\", childProjectName)));\n+        CommandStatus pushParentStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"parent_another\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushParentStatus.errUtf8(), pushParentStatus.code(), is(0));\n+\n+        CommandStatus startStatus = main(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"parent_another\", \"parent_another_project\",\n+                \"--session\", \"now\"\n+        );\n+        assertThat(startStatus.errUtf8(), startStatus.code(), is(0));\n+    }\n+\n+    @Test\n+    public void testRerunOnParam()\n+            throws Exception\n+    {\n+        // Create new project\n+        CommandStatus initStatus = main(\"init\",\n+                \"-c\", config.toString(),\n+                projectDir.toString());\n+        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n+\n+        Path childOutFile = projectDir.resolve(\"child.out\").toAbsolutePath().normalize();\n+        prepareForChildWF(childOutFile);\n+        copyResource(\"acceptance/require/parent_rerun_on.dig\", projectDir.resolve(\"parent.dig\"));\n+        copyResource(\"acceptance/require/child_rerun_on.dig\", projectDir.resolve(\"child.dig\"));\n+\n+        // Push the project\n+        CommandStatus pushStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"require\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"-r\", \"4711\");\n+        assertThat(pushStatus.errUtf8(), pushStatus.code(), is(0));\n+\n+        // test for rerun_on: none\n+        {\n+            String sessionTime = \"2020-05-28 12:34:01\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"none\", false);\n+            assertThat(\"Number of child's attempt must be one. (== require> skip the call)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+\n+        // test for rerun_on: all. require> kick child always.\n+        {\n+            String sessionTime = \"2020-05-28 12:34:11\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"all\", false);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt failed\n+        {\n+            String sessionTime = \"2020-05-28 12:34:21\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", true);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt succeeded\n+        {\n+            String sessionTime = \"2020-05-28 12:34:31\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", false);\n+            assertThat(\"Number of child's attempt must be one. (== require> kick)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+    }\n+\n+    private RestSessionAttemptCollection testRerunOnParam(String sessionTime, String rerunOn, boolean previousChildRunFail) throws InterruptedException\n+    {\n+        //Start a child\n+        String childFailParam = previousChildRunFail ? \"yes\" : \"no\";\n+        CommandStatus childStatus = startAndWait(true,\"require\", \"child\", \"--session\", sessionTime,", "originalCommit": "5e899ca2ad3760e3b946633f172ed6e9990a018f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0NDA0OA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435744048", "bodyText": "Fixed it. (Removed the param because of refactoring)", "author": "yoyama", "createdAt": "2020-06-05T07:40:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NjUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NjUzNA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435686534", "bodyText": "Same as above", "author": "komamitsu", "createdAt": "2020-06-05T04:42:20Z", "path": "digdag-tests/src/test/java/acceptance/RequireIT.java", "diffHunk": "@@ -185,6 +203,159 @@ public void testIgnoreProjectIdParam()\n         assertThat(success, is(true)); // --param project_id=-1 is ignored.\n     }\n \n+    /**\n+     * Test for project_id and project_name parameter\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRequireToAnotherProject()\n+            throws Exception\n+    {\n+        final String childProjectName = \"child_another\";\n+\n+        // Push child project\n+        Path childProjectDir = folder.getRoot().toPath().resolve(\"another_foobar\");\n+        Files.createDirectories(childProjectDir);\n+        copyResource(\"acceptance/require/child_another_project.dig\", childProjectDir);\n+        CommandStatus pushChildStatus = main(\"push\",\n+                \"--project\", childProjectDir.toString(),\n+                childProjectName,\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushChildStatus.errUtf8(), pushChildStatus.code(), is(0));\n+\n+        // extract child project id\n+        Matcher m = Pattern.compile(\".*\\\\s+id:\\\\s+(\\\\d+).*\").matcher(pushChildStatus.outUtf8());\n+        assertThat(m.find(), is(true));\n+        String childProjectId = m.group(1);\n+\n+        // Push parent project\n+        Files.write(projectDir.resolve(\"parent_another_project.dig\"), asList(Resources.toString(\n+                Resources.getResource(\"acceptance/require/parent_another_project.dig\"), UTF_8)\n+                .replace(\"__CHILD_PROJECT_ID__\", childProjectId)\n+                .replace(\"__CHILD_PROJECT_NAME__\", childProjectName)));\n+        CommandStatus pushParentStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"parent_another\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushParentStatus.errUtf8(), pushParentStatus.code(), is(0));\n+\n+        CommandStatus startStatus = main(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"parent_another\", \"parent_another_project\",\n+                \"--session\", \"now\"\n+        );\n+        assertThat(startStatus.errUtf8(), startStatus.code(), is(0));\n+    }\n+\n+    @Test\n+    public void testRerunOnParam()\n+            throws Exception\n+    {\n+        // Create new project\n+        CommandStatus initStatus = main(\"init\",\n+                \"-c\", config.toString(),\n+                projectDir.toString());\n+        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n+\n+        Path childOutFile = projectDir.resolve(\"child.out\").toAbsolutePath().normalize();\n+        prepareForChildWF(childOutFile);\n+        copyResource(\"acceptance/require/parent_rerun_on.dig\", projectDir.resolve(\"parent.dig\"));\n+        copyResource(\"acceptance/require/child_rerun_on.dig\", projectDir.resolve(\"child.dig\"));\n+\n+        // Push the project\n+        CommandStatus pushStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"require\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"-r\", \"4711\");\n+        assertThat(pushStatus.errUtf8(), pushStatus.code(), is(0));\n+\n+        // test for rerun_on: none\n+        {\n+            String sessionTime = \"2020-05-28 12:34:01\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"none\", false);\n+            assertThat(\"Number of child's attempt must be one. (== require> skip the call)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+\n+        // test for rerun_on: all. require> kick child always.\n+        {\n+            String sessionTime = \"2020-05-28 12:34:11\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"all\", false);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt failed\n+        {\n+            String sessionTime = \"2020-05-28 12:34:21\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", true);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt succeeded\n+        {\n+            String sessionTime = \"2020-05-28 12:34:31\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", false);\n+            assertThat(\"Number of child's attempt must be one. (== require> kick)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+    }\n+\n+    private RestSessionAttemptCollection testRerunOnParam(String sessionTime, String rerunOn, boolean previousChildRunFail) throws InterruptedException\n+    {\n+        //Start a child\n+        String childFailParam = previousChildRunFail ? \"yes\" : \"no\";\n+        CommandStatus childStatus = startAndWait(true,\"require\", \"child\", \"--session\", sessionTime,\n+                \"-p\", \"child_fail=\" + childFailParam);\n+        assertThat(isAttemptSuccess(childStatus), not(previousChildRunFail));\n+\n+        // Start a parent with same session time.\n+        CommandStatus rerunOnNoneStatus = startAndWait(false,\"require\", \"parent\", \"--session\", sessionTime,", "originalCommit": "5e899ca2ad3760e3b946633f172ed6e9990a018f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0Mzk2Ng==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435743966", "bodyText": "Fixed it. (Removed the param because of refactoring)", "author": "yoyama", "createdAt": "2020-06-05T07:40:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NjUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MTcwMA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435691700", "bodyText": "I'm wondering why this method call always passes ignoreAttemptFailure=true (sorry, a bit too difficult for me \ud83d\ude05.)\nCould I ask you the followings?\n\nAdd a comment for each case about why target attempt is expected to fail\n2. If possible, make this method call pass attemptShouldFail or something deterministic instead of  ignoreAttemptFailure (probably related to https://github.com/treasure-data/digdag/pull/1409/files#r435692688)", "author": "komamitsu", "createdAt": "2020-06-05T05:05:02Z", "path": "digdag-tests/src/test/java/acceptance/RequireIT.java", "diffHunk": "@@ -185,6 +203,159 @@ public void testIgnoreProjectIdParam()\n         assertThat(success, is(true)); // --param project_id=-1 is ignored.\n     }\n \n+    /**\n+     * Test for project_id and project_name parameter\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRequireToAnotherProject()\n+            throws Exception\n+    {\n+        final String childProjectName = \"child_another\";\n+\n+        // Push child project\n+        Path childProjectDir = folder.getRoot().toPath().resolve(\"another_foobar\");\n+        Files.createDirectories(childProjectDir);\n+        copyResource(\"acceptance/require/child_another_project.dig\", childProjectDir);\n+        CommandStatus pushChildStatus = main(\"push\",\n+                \"--project\", childProjectDir.toString(),\n+                childProjectName,\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushChildStatus.errUtf8(), pushChildStatus.code(), is(0));\n+\n+        // extract child project id\n+        Matcher m = Pattern.compile(\".*\\\\s+id:\\\\s+(\\\\d+).*\").matcher(pushChildStatus.outUtf8());\n+        assertThat(m.find(), is(true));\n+        String childProjectId = m.group(1);\n+\n+        // Push parent project\n+        Files.write(projectDir.resolve(\"parent_another_project.dig\"), asList(Resources.toString(\n+                Resources.getResource(\"acceptance/require/parent_another_project.dig\"), UTF_8)\n+                .replace(\"__CHILD_PROJECT_ID__\", childProjectId)\n+                .replace(\"__CHILD_PROJECT_NAME__\", childProjectName)));\n+        CommandStatus pushParentStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"parent_another\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushParentStatus.errUtf8(), pushParentStatus.code(), is(0));\n+\n+        CommandStatus startStatus = main(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"parent_another\", \"parent_another_project\",\n+                \"--session\", \"now\"\n+        );\n+        assertThat(startStatus.errUtf8(), startStatus.code(), is(0));\n+    }\n+\n+    @Test\n+    public void testRerunOnParam()\n+            throws Exception\n+    {\n+        // Create new project\n+        CommandStatus initStatus = main(\"init\",\n+                \"-c\", config.toString(),\n+                projectDir.toString());\n+        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n+\n+        Path childOutFile = projectDir.resolve(\"child.out\").toAbsolutePath().normalize();\n+        prepareForChildWF(childOutFile);\n+        copyResource(\"acceptance/require/parent_rerun_on.dig\", projectDir.resolve(\"parent.dig\"));\n+        copyResource(\"acceptance/require/child_rerun_on.dig\", projectDir.resolve(\"child.dig\"));\n+\n+        // Push the project\n+        CommandStatus pushStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"require\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"-r\", \"4711\");\n+        assertThat(pushStatus.errUtf8(), pushStatus.code(), is(0));\n+\n+        // test for rerun_on: none\n+        {\n+            String sessionTime = \"2020-05-28 12:34:01\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"none\", false);\n+            assertThat(\"Number of child's attempt must be one. (== require> skip the call)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+\n+        // test for rerun_on: all. require> kick child always.\n+        {\n+            String sessionTime = \"2020-05-28 12:34:11\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"all\", false);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt failed\n+        {\n+            String sessionTime = \"2020-05-28 12:34:21\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", true);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt succeeded\n+        {\n+            String sessionTime = \"2020-05-28 12:34:31\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", false);\n+            assertThat(\"Number of child's attempt must be one. (== require> kick)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+    }\n+\n+    private RestSessionAttemptCollection testRerunOnParam(String sessionTime, String rerunOn, boolean previousChildRunFail) throws InterruptedException\n+    {\n+        //Start a child\n+        String childFailParam = previousChildRunFail ? \"yes\" : \"no\";\n+        CommandStatus childStatus = startAndWait(true,\"require\", \"child\", \"--session\", sessionTime,", "originalCommit": "5e899ca2ad3760e3b946633f172ed6e9990a018f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NjcxMg==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435696712", "bodyText": "After having read all codes in testRerunOnParam() I understand all things. So probably you can ignore the above comment from me.", "author": "komamitsu", "createdAt": "2020-06-05T05:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MTcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyODk0OA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435728948", "bodyText": "I will add some additional comments.", "author": "yoyama", "createdAt": "2020-06-05T07:08:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MTcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MzY5MQ==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435743691", "bodyText": "Done. Thanks!", "author": "yoyama", "createdAt": "2020-06-05T07:40:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MTcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MjY4OA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435692688", "bodyText": "Oh, the same check is done above like assertThat(isAttemptSuccess(childStatus), not(previousChildRunFail))?\nSo we can remove this to make things simpler?", "author": "komamitsu", "createdAt": "2020-06-05T05:08:47Z", "path": "digdag-tests/src/test/java/acceptance/RequireIT.java", "diffHunk": "@@ -185,6 +203,159 @@ public void testIgnoreProjectIdParam()\n         assertThat(success, is(true)); // --param project_id=-1 is ignored.\n     }\n \n+    /**\n+     * Test for project_id and project_name parameter\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRequireToAnotherProject()\n+            throws Exception\n+    {\n+        final String childProjectName = \"child_another\";\n+\n+        // Push child project\n+        Path childProjectDir = folder.getRoot().toPath().resolve(\"another_foobar\");\n+        Files.createDirectories(childProjectDir);\n+        copyResource(\"acceptance/require/child_another_project.dig\", childProjectDir);\n+        CommandStatus pushChildStatus = main(\"push\",\n+                \"--project\", childProjectDir.toString(),\n+                childProjectName,\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushChildStatus.errUtf8(), pushChildStatus.code(), is(0));\n+\n+        // extract child project id\n+        Matcher m = Pattern.compile(\".*\\\\s+id:\\\\s+(\\\\d+).*\").matcher(pushChildStatus.outUtf8());\n+        assertThat(m.find(), is(true));\n+        String childProjectId = m.group(1);\n+\n+        // Push parent project\n+        Files.write(projectDir.resolve(\"parent_another_project.dig\"), asList(Resources.toString(\n+                Resources.getResource(\"acceptance/require/parent_another_project.dig\"), UTF_8)\n+                .replace(\"__CHILD_PROJECT_ID__\", childProjectId)\n+                .replace(\"__CHILD_PROJECT_NAME__\", childProjectName)));\n+        CommandStatus pushParentStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"parent_another\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushParentStatus.errUtf8(), pushParentStatus.code(), is(0));\n+\n+        CommandStatus startStatus = main(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"parent_another\", \"parent_another_project\",\n+                \"--session\", \"now\"\n+        );\n+        assertThat(startStatus.errUtf8(), startStatus.code(), is(0));\n+    }\n+\n+    @Test\n+    public void testRerunOnParam()\n+            throws Exception\n+    {\n+        // Create new project\n+        CommandStatus initStatus = main(\"init\",\n+                \"-c\", config.toString(),\n+                projectDir.toString());\n+        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n+\n+        Path childOutFile = projectDir.resolve(\"child.out\").toAbsolutePath().normalize();\n+        prepareForChildWF(childOutFile);\n+        copyResource(\"acceptance/require/parent_rerun_on.dig\", projectDir.resolve(\"parent.dig\"));\n+        copyResource(\"acceptance/require/child_rerun_on.dig\", projectDir.resolve(\"child.dig\"));\n+\n+        // Push the project\n+        CommandStatus pushStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"require\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"-r\", \"4711\");\n+        assertThat(pushStatus.errUtf8(), pushStatus.code(), is(0));\n+\n+        // test for rerun_on: none\n+        {\n+            String sessionTime = \"2020-05-28 12:34:01\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"none\", false);\n+            assertThat(\"Number of child's attempt must be one. (== require> skip the call)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+\n+        // test for rerun_on: all. require> kick child always.\n+        {\n+            String sessionTime = \"2020-05-28 12:34:11\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"all\", false);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt failed\n+        {\n+            String sessionTime = \"2020-05-28 12:34:21\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", true);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt succeeded\n+        {\n+            String sessionTime = \"2020-05-28 12:34:31\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", false);\n+            assertThat(\"Number of child's attempt must be one. (== require> kick)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+    }\n+\n+    private RestSessionAttemptCollection testRerunOnParam(String sessionTime, String rerunOn, boolean previousChildRunFail) throws InterruptedException\n+    {\n+        //Start a child\n+        String childFailParam = previousChildRunFail ? \"yes\" : \"no\";\n+        CommandStatus childStatus = startAndWait(true,\"require\", \"child\", \"--session\", sessionTime,\n+                \"-p\", \"child_fail=\" + childFailParam);\n+        assertThat(isAttemptSuccess(childStatus), not(previousChildRunFail));\n+\n+        // Start a parent with same session time.\n+        CommandStatus rerunOnNoneStatus = startAndWait(false,\"require\", \"parent\", \"--session\", sessionTime,\n+                \"-p\", \"param_rerun_on=\" + rerunOn,\n+                \"-p\", \"child_fail=no\");\n+\n+        assertThat(isAttemptSuccess(rerunOnNoneStatus), is(true));\n+        RestSessionAttemptCollection attempts = client.getSessionAttemptRetries(getAttemptId(childStatus));\n+        return attempts;\n+    }\n+\n+    private static boolean isAttemptSuccess(CommandStatus status) { return status.outUtf8().contains(\"status: success\"); }\n+\n+    private CommandStatus startAndWait(boolean ignoreAttemptFailure, String... args) throws InterruptedException\n+    {\n+        List<String> newArgs = new ArrayList<>(Arrays.asList(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint()\n+                ));\n+        newArgs.addAll(Arrays.asList(args));\n+        CommandStatus startStatus = main(newArgs);\n+        Id startAttemptId = getAttemptId(startStatus);\n+        CommandStatus attemptsStatus = null;\n+        // Wait for the attempt to complete\n+        boolean success = false;\n+        for (int i = 0; i < 30; i++) {\n+            attemptsStatus = main(\"attempt\",\n+                    \"-c\", config.toString(),\n+                    \"-e\", server.endpoint(),\n+                    String.valueOf(startAttemptId));\n+            if (attemptsStatus.outUtf8().contains(\"status: success\")) {\n+                success = true;\n+                break;\n+            }\n+            else if (attemptsStatus.outUtf8().contains(\"status: error\")) {\n+                break;\n+            }\n+            Thread.sleep(1000);\n+        }\n+        if (!ignoreAttemptFailure) {\n+            assertThat(success, is(true));", "originalCommit": "5e899ca2ad3760e3b946633f172ed6e9990a018f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyMDU1MA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435720550", "bodyText": "Thanks for your pointing out. I will remove them and argument ignoreAttemptFailure.", "author": "yoyama", "createdAt": "2020-06-05T06:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MjY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MzQzMA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435743430", "bodyText": "Fixed it and refactoring. Thanks for your pointing out.", "author": "yoyama", "createdAt": "2020-06-05T07:39:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MjY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5Mzc4OA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435693788", "bodyText": "Is this line needed?", "author": "komamitsu", "createdAt": "2020-06-05T05:13:22Z", "path": "digdag-tests/src/test/java/acceptance/RequireIT.java", "diffHunk": "@@ -185,6 +203,159 @@ public void testIgnoreProjectIdParam()\n         assertThat(success, is(true)); // --param project_id=-1 is ignored.\n     }\n \n+    /**\n+     * Test for project_id and project_name parameter\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRequireToAnotherProject()\n+            throws Exception\n+    {\n+        final String childProjectName = \"child_another\";\n+\n+        // Push child project\n+        Path childProjectDir = folder.getRoot().toPath().resolve(\"another_foobar\");\n+        Files.createDirectories(childProjectDir);\n+        copyResource(\"acceptance/require/child_another_project.dig\", childProjectDir);\n+        CommandStatus pushChildStatus = main(\"push\",\n+                \"--project\", childProjectDir.toString(),\n+                childProjectName,\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushChildStatus.errUtf8(), pushChildStatus.code(), is(0));\n+\n+        // extract child project id\n+        Matcher m = Pattern.compile(\".*\\\\s+id:\\\\s+(\\\\d+).*\").matcher(pushChildStatus.outUtf8());\n+        assertThat(m.find(), is(true));\n+        String childProjectId = m.group(1);\n+\n+        // Push parent project\n+        Files.write(projectDir.resolve(\"parent_another_project.dig\"), asList(Resources.toString(\n+                Resources.getResource(\"acceptance/require/parent_another_project.dig\"), UTF_8)\n+                .replace(\"__CHILD_PROJECT_ID__\", childProjectId)\n+                .replace(\"__CHILD_PROJECT_NAME__\", childProjectName)));\n+        CommandStatus pushParentStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"parent_another\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushParentStatus.errUtf8(), pushParentStatus.code(), is(0));\n+\n+        CommandStatus startStatus = main(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"parent_another\", \"parent_another_project\",\n+                \"--session\", \"now\"\n+        );\n+        assertThat(startStatus.errUtf8(), startStatus.code(), is(0));\n+    }\n+\n+    @Test\n+    public void testRerunOnParam()\n+            throws Exception\n+    {\n+        // Create new project\n+        CommandStatus initStatus = main(\"init\",\n+                \"-c\", config.toString(),\n+                projectDir.toString());\n+        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n+\n+        Path childOutFile = projectDir.resolve(\"child.out\").toAbsolutePath().normalize();\n+        prepareForChildWF(childOutFile);", "originalCommit": "5e899ca2ad3760e3b946633f172ed6e9990a018f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcxODczNQ==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435718735", "bodyText": "Thanks. I will remove 263 and 264.", "author": "yoyama", "createdAt": "2020-06-05T06:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5Mzc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MzA5Nw==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435743097", "bodyText": "Fixed it, thanks.", "author": "yoyama", "createdAt": "2020-06-05T07:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5Mzc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NTg2NQ==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435695865", "bodyText": "How about adding a test case of the combination of none and true?", "author": "komamitsu", "createdAt": "2020-06-05T05:22:21Z", "path": "digdag-tests/src/test/java/acceptance/RequireIT.java", "diffHunk": "@@ -185,6 +203,159 @@ public void testIgnoreProjectIdParam()\n         assertThat(success, is(true)); // --param project_id=-1 is ignored.\n     }\n \n+    /**\n+     * Test for project_id and project_name parameter\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRequireToAnotherProject()\n+            throws Exception\n+    {\n+        final String childProjectName = \"child_another\";\n+\n+        // Push child project\n+        Path childProjectDir = folder.getRoot().toPath().resolve(\"another_foobar\");\n+        Files.createDirectories(childProjectDir);\n+        copyResource(\"acceptance/require/child_another_project.dig\", childProjectDir);\n+        CommandStatus pushChildStatus = main(\"push\",\n+                \"--project\", childProjectDir.toString(),\n+                childProjectName,\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushChildStatus.errUtf8(), pushChildStatus.code(), is(0));\n+\n+        // extract child project id\n+        Matcher m = Pattern.compile(\".*\\\\s+id:\\\\s+(\\\\d+).*\").matcher(pushChildStatus.outUtf8());\n+        assertThat(m.find(), is(true));\n+        String childProjectId = m.group(1);\n+\n+        // Push parent project\n+        Files.write(projectDir.resolve(\"parent_another_project.dig\"), asList(Resources.toString(\n+                Resources.getResource(\"acceptance/require/parent_another_project.dig\"), UTF_8)\n+                .replace(\"__CHILD_PROJECT_ID__\", childProjectId)\n+                .replace(\"__CHILD_PROJECT_NAME__\", childProjectName)));\n+        CommandStatus pushParentStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"parent_another\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushParentStatus.errUtf8(), pushParentStatus.code(), is(0));\n+\n+        CommandStatus startStatus = main(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"parent_another\", \"parent_another_project\",\n+                \"--session\", \"now\"\n+        );\n+        assertThat(startStatus.errUtf8(), startStatus.code(), is(0));\n+    }\n+\n+    @Test\n+    public void testRerunOnParam()\n+            throws Exception\n+    {\n+        // Create new project\n+        CommandStatus initStatus = main(\"init\",\n+                \"-c\", config.toString(),\n+                projectDir.toString());\n+        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n+\n+        Path childOutFile = projectDir.resolve(\"child.out\").toAbsolutePath().normalize();\n+        prepareForChildWF(childOutFile);\n+        copyResource(\"acceptance/require/parent_rerun_on.dig\", projectDir.resolve(\"parent.dig\"));\n+        copyResource(\"acceptance/require/child_rerun_on.dig\", projectDir.resolve(\"child.dig\"));\n+\n+        // Push the project\n+        CommandStatus pushStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"require\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"-r\", \"4711\");\n+        assertThat(pushStatus.errUtf8(), pushStatus.code(), is(0));\n+\n+        // test for rerun_on: none\n+        {\n+            String sessionTime = \"2020-05-28 12:34:01\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"none\", false);", "originalCommit": "5e899ca2ad3760e3b946633f172ed6e9990a018f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MjgyNA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435742824", "bodyText": "Thanks, I added it. Now all conditions are covered.", "author": "yoyama", "createdAt": "2020-06-05T07:38:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NTg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NTkxNA==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435695914", "bodyText": "How about adding a test case of the combination of all and true?", "author": "komamitsu", "createdAt": "2020-06-05T05:22:33Z", "path": "digdag-tests/src/test/java/acceptance/RequireIT.java", "diffHunk": "@@ -185,6 +203,159 @@ public void testIgnoreProjectIdParam()\n         assertThat(success, is(true)); // --param project_id=-1 is ignored.\n     }\n \n+    /**\n+     * Test for project_id and project_name parameter\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRequireToAnotherProject()\n+            throws Exception\n+    {\n+        final String childProjectName = \"child_another\";\n+\n+        // Push child project\n+        Path childProjectDir = folder.getRoot().toPath().resolve(\"another_foobar\");\n+        Files.createDirectories(childProjectDir);\n+        copyResource(\"acceptance/require/child_another_project.dig\", childProjectDir);\n+        CommandStatus pushChildStatus = main(\"push\",\n+                \"--project\", childProjectDir.toString(),\n+                childProjectName,\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushChildStatus.errUtf8(), pushChildStatus.code(), is(0));\n+\n+        // extract child project id\n+        Matcher m = Pattern.compile(\".*\\\\s+id:\\\\s+(\\\\d+).*\").matcher(pushChildStatus.outUtf8());\n+        assertThat(m.find(), is(true));\n+        String childProjectId = m.group(1);\n+\n+        // Push parent project\n+        Files.write(projectDir.resolve(\"parent_another_project.dig\"), asList(Resources.toString(\n+                Resources.getResource(\"acceptance/require/parent_another_project.dig\"), UTF_8)\n+                .replace(\"__CHILD_PROJECT_ID__\", childProjectId)\n+                .replace(\"__CHILD_PROJECT_NAME__\", childProjectName)));\n+        CommandStatus pushParentStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"parent_another\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushParentStatus.errUtf8(), pushParentStatus.code(), is(0));\n+\n+        CommandStatus startStatus = main(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"parent_another\", \"parent_another_project\",\n+                \"--session\", \"now\"\n+        );\n+        assertThat(startStatus.errUtf8(), startStatus.code(), is(0));\n+    }\n+\n+    @Test\n+    public void testRerunOnParam()\n+            throws Exception\n+    {\n+        // Create new project\n+        CommandStatus initStatus = main(\"init\",\n+                \"-c\", config.toString(),\n+                projectDir.toString());\n+        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n+\n+        Path childOutFile = projectDir.resolve(\"child.out\").toAbsolutePath().normalize();\n+        prepareForChildWF(childOutFile);\n+        copyResource(\"acceptance/require/parent_rerun_on.dig\", projectDir.resolve(\"parent.dig\"));\n+        copyResource(\"acceptance/require/child_rerun_on.dig\", projectDir.resolve(\"child.dig\"));\n+\n+        // Push the project\n+        CommandStatus pushStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"require\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"-r\", \"4711\");\n+        assertThat(pushStatus.errUtf8(), pushStatus.code(), is(0));\n+\n+        // test for rerun_on: none\n+        {\n+            String sessionTime = \"2020-05-28 12:34:01\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"none\", false);\n+            assertThat(\"Number of child's attempt must be one. (== require> skip the call)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+\n+        // test for rerun_on: all. require> kick child always.\n+        {\n+            String sessionTime = \"2020-05-28 12:34:11\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"all\", false);", "originalCommit": "5e899ca2ad3760e3b946633f172ed6e9990a018f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MjQwMQ==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435742401", "bodyText": "I added it. Thanks!", "author": "yoyama", "createdAt": "2020-06-05T07:37:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NTkxNA=="}], "type": "inlineReview"}, {"oid": "f5ff6f1b6c3163374558949d8dd861d8ab9f2749", "url": "https://github.com/treasure-data/digdag/commit/f5ff6f1b6c3163374558949d8dd861d8ab9f2749", "message": "Improve project_name test in RequireIT.", "committedDate": "2020-06-05T06:37:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4OTUzNg==", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435789536", "bodyText": "\ud83d\udcaf", "author": "komamitsu", "createdAt": "2020-06-05T09:05:51Z", "path": "digdag-tests/src/test/java/acceptance/RequireIT.java", "diffHunk": "@@ -185,6 +203,176 @@ public void testIgnoreProjectIdParam()\n         assertThat(success, is(true)); // --param project_id=-1 is ignored.\n     }\n \n+    /**\n+     * Test for project_id and project_name parameter\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRequireToAnotherProject()\n+            throws Exception\n+    {\n+        final String childProjectName = \"child_another\";\n+\n+        // Push child project\n+        Path childProjectDir = folder.getRoot().toPath().resolve(\"another_foobar\");\n+        Files.createDirectories(childProjectDir);\n+        copyResource(\"acceptance/require/child_another_project.dig\", childProjectDir);\n+        CommandStatus pushChildStatus = main(\"push\",\n+                \"--project\", childProjectDir.toString(),\n+                childProjectName,\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushChildStatus.errUtf8(), pushChildStatus.code(), is(0));\n+\n+        // extract child project id\n+        Matcher m = Pattern.compile(\".*\\\\s+id:\\\\s+(\\\\d+).*\").matcher(pushChildStatus.outUtf8());\n+        assertThat(m.find(), is(true));\n+        String childProjectId = m.group(1);\n+\n+        // Push parent project\n+        Files.write(projectDir.resolve(\"parent_another_project.dig\"), asList(Resources.toString(\n+                Resources.getResource(\"acceptance/require/parent_another_project.dig\"), UTF_8)\n+                .replace(\"__CHILD_PROJECT_ID__\", childProjectId)\n+                .replace(\"__CHILD_PROJECT_NAME__\", childProjectName)));\n+        CommandStatus pushParentStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"parent_another\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushParentStatus.errUtf8(), pushParentStatus.code(), is(0));\n+\n+        CommandStatus startStatus = main(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"parent_another\", \"parent_another_project\",\n+                \"--session\", \"now\"\n+        );\n+        assertThat(startStatus.errUtf8(), startStatus.code(), is(0));\n+    }\n+\n+    @Test\n+    public void testRerunOnParam()\n+            throws Exception\n+    {\n+        // Create new project\n+        CommandStatus initStatus = main(\"init\",\n+                \"-c\", config.toString(),\n+                projectDir.toString());\n+        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n+\n+        copyResource(\"acceptance/require/parent_rerun_on.dig\", projectDir.resolve(\"parent.dig\"));\n+        copyResource(\"acceptance/require/child_rerun_on.dig\", projectDir.resolve(\"child.dig\"));\n+\n+        // Push the project\n+        CommandStatus pushStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"require\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"-r\", \"4711\");\n+        assertThat(pushStatus.errUtf8(), pushStatus.code(), is(0));\n+\n+        // test for rerun_on: none and previous child succeeded. parent will succeed.\n+        {\n+            String sessionTime = \"2020-05-28 12:34:01\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"none\", false, true);\n+            assertThat(\"Number of child's attempt must be one. (== require> skip the call)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+\n+        // test for rerun_on: none and previous child failed. parent will fail.\n+        {\n+            String sessionTime = \"2020-05-28 12:34:02\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"none\", true, false);\n+            assertThat(\"Number of child's attempt must be one. (== require> skip the call)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+\n+        // test for rerun_on: all and previous child succeeded. require> kick child always.\n+        {\n+            String sessionTime = \"2020-05-28 12:34:11\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"all\", false, true);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: all and previous child failed. require> kick child always.\n+        {\n+            String sessionTime = \"2020-05-28 12:34:12\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"all\", true, true);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt failed\n+        {\n+            String sessionTime = \"2020-05-28 12:34:21\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", true, true);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt succeeded\n+        {\n+            String sessionTime = \"2020-05-28 12:34:31\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", false, true);\n+            assertThat(\"Number of child's attempt must be one. (== require> kick)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+    }\n+\n+    /**\n+     * Test for rerun_on\n+     *\n+     * @param sessionTime\n+     * @param rerunOn              parameter for rerun_on:  \"none\" or \"fail\" or \"all\"\n+     * @param previousChildRunFail if true, first child workflow failed.\n+     * @return\n+     * @throws InterruptedException\n+     */\n+    private RestSessionAttemptCollection testRerunOnParam(String sessionTime, String rerunOn, boolean previousChildRunFail, boolean expectParentSucceed) throws InterruptedException", "originalCommit": "5c033679d7efbf4efb4f0ca8d3764a2453ae8ae2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bc449ed4351d8dfacde2312e7518f5431532a39f", "url": "https://github.com/treasure-data/digdag/commit/bc449ed4351d8dfacde2312e7518f5431532a39f", "message": "Fix minor comment issue", "committedDate": "2020-06-08T05:50:51Z", "type": "commit"}, {"oid": "8d5a559f06d7832fff917464bcb329b8e0b5dcea", "url": "https://github.com/treasure-data/digdag/commit/8d5a559f06d7832fff917464bcb329b8e0b5dcea", "message": "Enhance require> operator.\n\nIgnore retry_attempt_name from out of operator.\nIntroduce ignore_no_existence option.\nIntroduce return_on: (none,failed,all).", "committedDate": "2020-06-08T06:02:50Z", "type": "commit"}, {"oid": "361f0be3a6217c724fc60c0bf5373cd9869d95d4", "url": "https://github.com/treasure-data/digdag/commit/361f0be3a6217c724fc60c0bf5373cd9869d95d4", "message": "Update document.", "committedDate": "2020-06-08T06:02:50Z", "type": "commit"}, {"oid": "886213d28c5b0c06ea3d86ec3bcf22b3756012d6", "url": "https://github.com/treasure-data/digdag/commit/886213d28c5b0c06ea3d86ec3bcf22b3756012d6", "message": "Integration test for require>", "committedDate": "2020-06-08T06:04:08Z", "type": "commit"}, {"oid": "88ee5a12d662e804a857f41fb831c4d5906f0f2d", "url": "https://github.com/treasure-data/digdag/commit/88ee5a12d662e804a857f41fb831c4d5906f0f2d", "message": "Remove ignore_no_existence and refactoring.", "committedDate": "2020-06-08T06:05:03Z", "type": "commit"}, {"oid": "60d546cb0237b70b1dcc23ba6c7edf9f4f8fe62c", "url": "https://github.com/treasure-data/digdag/commit/60d546cb0237b70b1dcc23ba6c7edf9f4f8fe62c", "message": "Implement exponential backoff to reduce num of task retry.", "committedDate": "2020-06-08T06:05:03Z", "type": "commit"}, {"oid": "12e8fc167a2ff39ca09138e2d0ffc610bbad2ff1", "url": "https://github.com/treasure-data/digdag/commit/12e8fc167a2ff39ca09138e2d0ffc610bbad2ff1", "message": "Refactoring based on review.", "committedDate": "2020-06-08T06:05:03Z", "type": "commit"}, {"oid": "9f37b38c83fa4c4124f772187763d5b1a2c0070a", "url": "https://github.com/treasure-data/digdag/commit/9f37b38c83fa4c4124f772187763d5b1a2c0070a", "message": "Refactoring based on review.", "committedDate": "2020-06-08T06:05:03Z", "type": "commit"}, {"oid": "6aa1f20780e028bb5b444eb9616ccf4993ed3ceb", "url": "https://github.com/treasure-data/digdag/commit/6aa1f20780e028bb5b444eb9616ccf4993ed3ceb", "message": "Refactoring based on the review.", "committedDate": "2020-06-08T06:05:22Z", "type": "commit"}, {"oid": "dd583ebbdda4e440879adc83f73c036471179cad", "url": "https://github.com/treasure-data/digdag/commit/dd583ebbdda4e440879adc83f73c036471179cad", "message": "Cover all conditions in testRerunOnParam().", "committedDate": "2020-06-08T06:05:22Z", "type": "commit"}, {"oid": "dd583ebbdda4e440879adc83f73c036471179cad", "url": "https://github.com/treasure-data/digdag/commit/dd583ebbdda4e440879adc83f73c036471179cad", "message": "Cover all conditions in testRerunOnParam().", "committedDate": "2020-06-08T06:05:22Z", "type": "forcePushed"}]}