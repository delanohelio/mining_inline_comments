{"pr_number": 900, "pr_title": "RDM-8166 - Using Formatted Date(Time) Fields on Workbasket & Search Input Screens", "pr_createdAt": "2020-04-09T13:10:46Z", "pr_url": "https://github.com/hmcts/ccd-data-store-api/pull/900", "timeline": [{"oid": "389fe72956031606dce7ba158a7cb0972c654a9e", "url": "https://github.com/hmcts/ccd-data-store-api/commit/389fe72956031606dce7ba158a7cb0972c654a9e", "message": "RDM-8166 - Extend search input to complex types", "committedDate": "2020-04-09T13:08:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI2MjI2Nw==", "url": "https://github.com/hmcts/ccd-data-store-api/pull/900#discussion_r406262267", "bodyText": "this field type has children (nestedField). This test is not able to find any CaseField that is matching the test path \"Field.ID\"", "author": "kiran-yenigala-hmcts", "createdAt": "2020-04-09T14:51:22Z", "path": "src/test/java/uk/gov/hmcts/ccd/domain/model/definition/FieldTypeTest.java", "diffHunk": "@@ -75,4 +80,137 @@ public void getChildrenOfComplexType() {\n             assertTrue(children.stream().anyMatch(e -> e.getId().equals(caseField2.getId())));\n         }\n     }\n+\n+    @Nested\n+    @DisplayName(\"getNestedField test\")\n+    class FieldTypeGetNestedFieldTest {\n+\n+        private final String COMPLEX_FIELD_TYPE = \"Complex\";\n+        private final String COLLECTION_FIELD_TYPE = \"Collection\";\n+\n+        @Test\n+        void shouldFindBasicNestedField() {\n+            String testPath = \"NestedField\";\n+            CaseField nestedField = newCaseField()\n+                .withId(\"NestedField\")\n+                .withFieldType(aFieldType().withType(\"Text\").build())\n+                .build();\n+            FieldType fieldType = aFieldType().withType(COMPLEX_FIELD_TYPE).withComplexField(nestedField).build();\n+\n+            final Optional<CommonField> result = fieldType.getNestedField(testPath);\n+\n+            assertAll(\n+                () -> assertThat(result.isPresent(), is(true)),\n+                () -> assertThat(result.get(), is(nestedField))\n+            );\n+        }\n+\n+        @Test\n+        void shouldFindDeepNestedField() {\n+            String testPath = \"NestedField.DeepNestedField\";\n+            CaseField deepNestedField = newCaseField().withId(\"DeepNestedField\").build();\n+            CaseField nestedField = newCaseField()\n+                .withId(\"NestedField\")\n+                .withFieldType(aFieldType().withType(COMPLEX_FIELD_TYPE)\n+                    .withComplexField(newCaseField().withId(\"SomeOtherField\").build())\n+                    .withComplexField(deepNestedField)\n+                    .build()\n+                ).build();\n+            FieldType fieldType = aFieldType().withType(COMPLEX_FIELD_TYPE).withComplexField(nestedField).build();\n+\n+            final Optional<CommonField> result = fieldType.getNestedField(testPath);\n+\n+            assertAll(\n+                () -> assertThat(result.isPresent(), is(true)),\n+                () -> assertThat(result.get(), is(deepNestedField))\n+            );\n+        }\n+\n+        @Test\n+        void shouldFindNestedCollectionField() {\n+            String testPath = \"NestedCollectionField\";\n+            CaseField collectionField = newCaseField()\n+                .withId(\"NestedCollectionField\")\n+                .withFieldType(aFieldType().withType(COLLECTION_FIELD_TYPE)\n+                    .withCollectionField(newCaseField().withId(\"SomeOtherField\").build())\n+                    .build()\n+                ).build();\n+            FieldType fieldType = aFieldType().withType(COLLECTION_FIELD_TYPE).withCollectionField(collectionField).build();\n+\n+            final Optional<CommonField> result = fieldType.getNestedField(testPath);\n+\n+            assertAll(\n+                () -> assertThat(result.isPresent(), is(true)),\n+                () -> assertThat(result.get(), is(collectionField))\n+            );\n+        }\n+\n+        @Test\n+        void shouldNotReturnResultForNonExistentNestedField() {\n+            String testPath = \"NestedField.NonExistentDeepNestedField\";\n+            CaseField deepNestedField = newCaseField().withId(\"DeepNestedField\").build();\n+            CaseField nestedField = newCaseField()\n+                .withId(\"NestedField\")\n+                .withFieldType(aFieldType().withType(\"Complex\")\n+                    .withComplexField(newCaseField().withId(\"SomeOtherField\").build())\n+                    .withComplexField(deepNestedField)\n+                    .build()\n+                ).build();\n+            FieldType fieldType = aFieldType().withType(COMPLEX_FIELD_TYPE).withComplexField(nestedField).build();\n+\n+            final Optional<CommonField> result = fieldType.getNestedField(testPath);\n+\n+            assertAll(\n+                () -> assertThat(result.isPresent(), is(false))\n+            );\n+        }\n+\n+        @Test\n+        void shouldNotReturnResultForBlankPath() {\n+            String testPath = \"\";\n+            CaseField nestedField = newCaseField()\n+                .withId(\"NestedField\")\n+                .withFieldType(aFieldType().withType(\"Text\").build())\n+                .build();\n+            FieldType fieldType = aFieldType().withType(COMPLEX_FIELD_TYPE).withComplexField(nestedField).build();\n+\n+            final Optional<CommonField> result = fieldType.getNestedField(testPath);\n+\n+            assertAll(() -> {\n+                assertThat(result.isPresent(), is(false));\n+            });\n+        }\n+\n+        @Test\n+        void shouldNotReturnResultForPathWithNoNesting() {\n+            String testPath = \"NonNestedPath\";\n+            CaseField nestedField = newCaseField()\n+                .withId(\"NestedField\")\n+                .withFieldType(aFieldType().withType(\"Text\").build())\n+                .build();\n+            FieldType fieldType = aFieldType().withType(COMPLEX_FIELD_TYPE).withComplexField(nestedField).build();\n+\n+            final Optional<CommonField> result = fieldType.getNestedField(testPath);\n+\n+            assertAll(() -> {\n+                assertThat(result.isPresent(), is(false));\n+            });\n+        }\n+\n+        @Test\n+        void shouldNotReturnResultForFieldTypeWithNoChildren() {\n+            String testPath = \"Field.ID\";\n+            CaseField nestedField = newCaseField()\n+                .withId(\"NestedField\")\n+                .withFieldType(aFieldType().withType(\"Text\").build())\n+                .build();\n+            FieldType fieldType = aFieldType().withType(COMPLEX_FIELD_TYPE).withComplexField(nestedField).build();", "originalCommit": "389fe72956031606dce7ba158a7cb0972c654a9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4MTQ2MA==", "url": "https://github.com/hmcts/ccd-data-store-api/pull/900#discussion_r406281460", "bodyText": "if we can move this to FieldType that will be keep this class simple", "author": "kiran-yenigala-hmcts", "createdAt": "2020-04-09T15:18:35Z", "path": "src/main/java/uk/gov/hmcts/ccd/domain/model/search/Field.java", "diffHunk": "@@ -41,4 +47,13 @@ public boolean isMetadata() {\n     public void setMetadata(boolean metadata) {\n         this.metadata = metadata;\n     }\n+\n+    public Optional<CommonField> getNestedField(String path) {\n+        final List<String> pathElements = Arrays.asList(path.trim().split(\"\\\\.\"));", "originalCommit": "389fe72956031606dce7ba158a7cb0972c654a9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4NzkxNg==", "url": "https://github.com/hmcts/ccd-data-store-api/pull/900#discussion_r406287916", "bodyText": "Move this method to FieldType class", "author": "kiran-yenigala-hmcts", "createdAt": "2020-04-09T15:27:39Z", "path": "src/main/java/uk/gov/hmcts/ccd/domain/model/search/SearchResultViewColumn.java", "diffHunk": "@@ -73,32 +70,11 @@ public String getDisplayContextParameter() {\n     }\n \n     public Optional<CommonField> getNestedField(String path) {\n-        if (StringUtils.isBlank(path) || path.trim().split(\"\\\\.\").length == 1 || this.getCaseFieldType().getChildren().isEmpty()) {\n+        final List<String> pathElements = Arrays.asList(path.trim().split(\"\\\\.\"));", "originalCommit": "389fe72956031606dce7ba158a7cb0972c654a9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5MzM3Ng==", "url": "https://github.com/hmcts/ccd-data-store-api/pull/900#discussion_r406293376", "bodyText": "instead of subList() better to use index like below then it will give some performance benefit as well.\nreduce(List caseFields, List pathElements, int startIndex)\n........\nreturn reduce(newCaseFields, pathElements, startIndex + 1);", "author": "kiran-yenigala-hmcts", "createdAt": "2020-04-09T15:35:40Z", "path": "src/main/java/uk/gov/hmcts/ccd/domain/model/definition/FieldType.java", "diffHunk": "@@ -129,6 +134,34 @@ public void setCollectionFieldType(FieldType collectionFieldType) {\n         this.collectionFieldType = collectionFieldType;\n     }\n \n+    public Optional<CommonField> getNestedField(String path) {\n+        if (StringUtils.isBlank(path) || this.getChildren().isEmpty()) {\n+            return Optional.empty();\n+        }\n+        List<String> pathElements = Arrays.stream(path.trim().split(\"\\\\.\")).collect(toList());\n+\n+        return reduce(this.getChildren(), pathElements);\n+    }\n+\n+    private Optional<CommonField> reduce(List<CaseField> caseFields, List<String> pathElements) {\n+        String firstPathElement = pathElements.get(0);\n+        Optional<CaseField> optionalCaseField = caseFields.stream().filter(e -> e.getId().equals(firstPathElement)).findFirst();\n+        if (optionalCaseField.isPresent()) {\n+            CommonField caseField = optionalCaseField.get();\n+\n+            if (pathElements.size() == 1) {\n+                return Optional.of(caseField);\n+            } else {\n+                List<CaseField> newCaseFields = caseField.getFieldType().getChildren();\n+                List<String> tail = pathElements.subList(1, pathElements.size());\n+\n+                return reduce(newCaseFields, tail);\n+            }", "originalCommit": "389fe72956031606dce7ba158a7cb0972c654a9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwNjMxNQ==", "url": "https://github.com/hmcts/ccd-data-store-api/pull/900#discussion_r406406315", "bodyText": "Won't action this as part of this ticket as is part of an existing implementation that was copied over from CommonField. In latest commit I've updated CommonField to now use this one as well so it's not all duplicated.", "author": "danlysiak", "createdAt": "2020-04-09T18:46:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5MzM3Ng=="}], "type": "inlineReview"}, {"oid": "3e3c321e64a250adeaf7b7bc536515597239a247", "url": "https://github.com/hmcts/ccd-data-store-api/commit/3e3c321e64a250adeaf7b7bc536515597239a247", "message": "Review comments/refactoring", "committedDate": "2020-04-09T18:44:39Z", "type": "commit"}, {"oid": "25b7097f500a0342629ddb81727516d7e3e7ddd6", "url": "https://github.com/hmcts/ccd-data-store-api/commit/25b7097f500a0342629ddb81727516d7e3e7ddd6", "message": "Merge branch 'RDM-7694' into RDM-8166", "committedDate": "2020-04-15T10:49:12Z", "type": "commit"}, {"oid": "fce702611c91eb4d0feb4bb8feadce701621e0eb", "url": "https://github.com/hmcts/ccd-data-store-api/commit/fce702611c91eb4d0feb4bb8feadce701621e0eb", "message": "Typo", "committedDate": "2020-04-15T14:20:43Z", "type": "commit"}, {"oid": "e7deba0c3903b093e092b45e0521c7dde8962a66", "url": "https://github.com/hmcts/ccd-data-store-api/commit/e7deba0c3903b093e092b45e0521c7dde8962a66", "message": "Merge branch 'RDM-7575-DateTime-Formatting' into RDM-8166", "committedDate": "2020-04-15T17:28:32Z", "type": "commit"}]}