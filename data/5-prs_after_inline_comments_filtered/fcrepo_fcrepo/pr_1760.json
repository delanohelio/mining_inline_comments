{"pr_number": 1760, "pr_title": "FCREPO-3409 - DC membership index", "pr_createdAt": "2020-09-30T16:00:29Z", "pr_url": "https://github.com/fcrepo/fcrepo/pull/1760", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc1NTk1Nw==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r497755957", "bodyText": "Not sure but do you need the WHERE EXISTS clause as it seems identical to the above WHERE clause just with the addition of the \" AND mto.operation = :deleteOp\" + line. Could that be added to the original WHERE clause and the second one removed?", "author": "whikloj", "createdAt": "2020-09-30T19:40:54Z", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";", "originalCommit": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyNzg4MA==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498427880", "bodyText": "The first WHERE clause is in order to get the new value for end_time, and the WHERE EXISTS is to determine which membership entries are being ended. But I'll add the operation check to the first subquery, just in case there are multiple operations for membership entry in the current transaction. If I'm remembering correctly, this query ended up kind of dumb looking because h2 doesn't support joins in UPDATE queries, so I had to have the two nearly identical subqueries.", "author": "bbpennel", "createdAt": "2020-10-01T18:08:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc1NTk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc1OTA0MQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r497759041", "bodyText": "I saw this a couple places, just wondering if there is a benefit to passing a static string in versus just using 'delete' here? Same for the :addOp and 'add'?", "author": "whikloj", "createdAt": "2020-09-30T19:46:48Z", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +", "originalCommit": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzODAwNQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498238005", "bodyText": "mainly for programmer error. When I was working on it I originally had 'delete' hardcoded in the query, but ended up with mismatches between the values in different places ('delete' vs 'deleted') which failed silently since it was valid sql. By passing in a constant it means I'll get an error if I misspell :deleteOp since the variable would be missing.", "author": "bbpennel", "createdAt": "2020-10-01T13:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc1OTA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc2MjYzMQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r497762631", "bodyText": "I think this needs the @Transactional annotation.", "author": "whikloj", "createdAt": "2020-09-30T19:53:36Z", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/default-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", ADD_OPERATION);\n+\n+        final int affected = jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parameterSource);\n+\n+        // If no rows were deleted, then assume we need to delete permanent entry\n+        if (affected == 0) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"subjectId\", membership.getSubject().getURI(),\n+                    \"property\", membership.getPredicate().getURI(),\n+                    \"objectId\", membership.getObject().getURI(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_MEMBERSHIP, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * End membership entry within a transaction\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipInTx(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"endTime\", Timestamp.from(endTime),\n+                \"noEndTime\", NO_END_TIMESTAMP);\n+        jdbcTemplate.update(END_MEMBERSHIP_IN_TX, parameterSource);\n+    }\n+\n+    /**\n+     * End all membership properties resulting from the specified source container\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime) {\n+        deleteMembershipForSource(txId, sourceId, endTime, false);\n+    }\n+\n+    /**\n+     * Delete all membership properties from a source container, clearing properties from\n+     * the current transaction and setting an action to clear the properties outside the tx\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be cleaned up\n+     */\n+    public void deleteMembershipForSource(final String txId, final FedoraId sourceId) {\n+        deleteMembershipForSource(txId, sourceId, null, true);\n+    }\n+\n+    private void deleteMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime,\n+            final boolean deleteProperties) {\n+        // End all membership added in this transaction\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"addOp\", ADD_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX, parameterSource);\n+\n+        // End all membership that existed prior to this transaction\n+        if (deleteProperties) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"forceFlag\", FORCE_FLAG,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(DELETE_EXISTING_FOR_SOURCE, parameterSource2);\n+        } else {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_FOR_SOURCE, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * Clean up any references to the target id, in transactions and outside\n+     * @param txId transaction id\n+     * @param targetId identifier of the resource to cleanup membership references for\n+     */\n+    public void deleteMembershipReferences(final String txId, final FedoraId targetId) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"targetId\", targetId.getFullId(),\n+                \"txId\", txId);\n+\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_TRANSACTION, parameterSource);\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_MEMBERSHIP, parameterSource);\n+    }\n+\n+    /**\n+     * Add new membership property to the index, clearing any delete\n+     * operations for the property if necessary.\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container which produced the membership\n+     * @param membership membership triple\n+     * @param startTime time the membership triple was added\n+     */\n+    public void addMembership(final String txId, final FedoraId sourceId, final Triple membership,\n+            final Instant startTime) {\n+        // Clear any existing delete operation for this membership\n+        final Map<String, Object> parametersDelete = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", DELETE_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parametersDelete);\n+\n+        // Add the new membership operation\n+        addMembership(txId, sourceId, membership, startTime, null);\n+    }\n+\n+    /**\n+     * Add new membership property to the index\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container which produced the membership\n+     * @param membership membership triple\n+     * @param startTime time the membership triple was added\n+     * @param endTime time the membership triple ends, or never if not provided\n+     */\n+    public void addMembership(final String txId, final FedoraId sourceId, final Triple membership,\n+            final Instant startTime, final Instant endTime) {\n+        final var endTimestamp = endTime == null ? NO_END_TIMESTAMP : Timestamp.from(endTime);\n+        // Add the new membership operation\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"targetId\", membership.getObject().getURI(),\n+                \"sourceId\", sourceId.getFullId(),\n+                \"startTime\", Timestamp.from(startTime),\n+                \"endTime\", endTimestamp,\n+                \"txId\", txId,\n+                \"operation\", ADD_OPERATION);\n+\n+        jdbcTemplate.update(INSERT_MEMBERSHIP_IN_TX, parameterSource);\n+    }\n+\n+    /**\n+     * Get a stream of membership triples with\n+     * @param txId transaction from which membership will be retrieved, or null for no transaction\n+     * @param subjectId ID of the subject\n+     * @return Stream of membership triples\n+     */\n+    public Stream<Triple> getMembership(final String txId, final FedoraId subjectId) {\n+        final Node subjectNode = NodeFactory.createURI(subjectId.getBaseId());\n+\n+        final RowMapper<Triple> membershipMapper = (rs, rowNum) ->\n+                Triple.create(subjectNode,\n+                              NodeFactory.createURI(rs.getString(\"property\")),\n+                              NodeFactory.createURI(rs.getString(\"object_id\")));\n+\n+        List<Triple> membership = null;\n+        if (txId == null) {\n+            if (subjectId.isMemento()) {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getBaseId(),\n+                        \"mementoTime\", subjectId.getMementoInstant());\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP_MEMENTO, parameterSource, membershipMapper);\n+            } else {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getFullId(),\n+                        \"noEndTime\", NO_END_TIMESTAMP);\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP, parameterSource, membershipMapper);\n+            }\n+        } else {\n+            if (subjectId.isMemento()) {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getBaseId(),\n+                        \"mementoTime\", subjectId.getMementoInstant(),\n+                        \"txId\", txId,\n+                        \"addOp\", ADD_OPERATION,\n+                        \"deleteOp\", DELETE_OPERATION);\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP_MEMENTO_IN_TX, parameterSource, membershipMapper);\n+            } else {\n+                final Map<String, Object> parameterSource = Map.of(\n+                        \"subjectId\", subjectId.getFullId(),\n+                        \"noEndTime\", NO_END_TIMESTAMP,\n+                        \"txId\", txId,\n+                        \"addOp\", ADD_OPERATION,\n+                        \"deleteOp\", DELETE_OPERATION);\n+\n+                membership = jdbcTemplate.query(SELECT_MEMBERSHIP_IN_TX, parameterSource, membershipMapper);\n+            }\n+        }\n+\n+        return membership.stream();\n+    }\n+\n+    /**\n+     * Perform a commit of operations stored in the specified transaction\n+     * @param txId transaction id\n+     */\n+    public void commitTransaction(final String txId) {", "originalCommit": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzOTkyMA==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498239920", "bodyText": "I'll add that. Is it needed for all methods that modify the index?", "author": "bbpennel", "createdAt": "2020-10-01T13:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc2MjYzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI2NjIzOA==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498266238", "bodyText": "Just if you are performing multiple SQL statements that all either need to succeed or the whole thing fail. In the Containment index only commit and reset are transactional as they each have more than one updates that must occur.", "author": "whikloj", "createdAt": "2020-10-01T13:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc2MjYzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM1ODE2Nw==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498358167", "bodyText": "Okay, I'll add the annotation to a few more places", "author": "bbpennel", "createdAt": "2020-10-01T16:04:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc2MjYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc2OTg5Mw==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r497769893", "bodyText": "I must be reading this wrong. It appears that if you are not using auto versioning then any change to a direct container rebuilds its entire membership history?", "author": "whikloj", "createdAt": "2020-09-30T20:07:35Z", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);", "originalCommit": "5d8c5836d81e4b2b5b266ad1f9dc470888e77327", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyNDU5OQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498424599", "bodyText": "No, you're reading it correctly. I ended up doing that because modifying the mutable head of a DC can change the committed membership entries, including for deleted members, so it seemed like things were going to get very messy. But thinking about it some more today, I'm realizing I can probably do it as a modification, so I'll try to switch it over.", "author": "bbpennel", "createdAt": "2020-10-01T18:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc2OTg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI5NjkyMQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498296921", "bodyText": "Going forward, I think it would be better if we inject the config objects rather than directly from properties. It will make it easier if we don't have to search through the entire code base to find where a property is being accessed. You could either inject the config bean and programmatically access the value you want, or use a value annotation like @Value(\"#{configBeanName.autoVersioningEnabled}\").", "author": "pwinckles", "createdAt": "2020-10-01T14:39:30Z", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")", "originalCommit": "a64c47de676a72456a64bcef747fffb7b3890cc5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyOTQ4OQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498429489", "bodyText": "I initially tried to inject the config object, but it wasn't available within fcrepo-kernel-impl because fcrepo-configs isn't a dependency of that module. Maybe it should be? It might be nice if weren't coming from an OCFL named class as well.", "author": "bbpennel", "createdAt": "2020-10-01T18:12:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI5NjkyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzMDk1Mg==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498430952", "bodyText": "It shouldn't be a problem for any module to take a dependency on fcrepo-configs.", "author": "pwinckles", "createdAt": "2020-10-01T18:14:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI5NjkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM4NzU2MQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498387561", "bodyText": "Missing an argument", "author": "pwinckles", "createdAt": "2020-10-01T16:54:44Z", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\");", "originalCommit": "a64c47de676a72456a64bcef747fffb7b3890cc5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDMyNQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498394325", "bodyText": "m2 is not used.\nI think this could also be rewritten like: .sorted(Comparator.comparing(m -> m.getFedoraId().getFullId()))", "author": "pwinckles", "createdAt": "2020-10-01T17:07:10Z", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\");\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {\n+        final FedoraResource fedoraResc = getFedoraResource(txId, containerId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            final var propertyTimeline = makePropertyTimeline(fedoraResc);\n+\n+            // get all the members of the DC and index the history for each, accounting for changes to the DC\n+            fedoraResc.getChildren().forEach(member -> {\n+                final var memberDeleted = member instanceof Tombstone;\n+                final var memberNode = NodeFactory.createURI(member.getFedoraId().getFullId());\n+                log.debug(\"Populating membership history for DirectContainer {}member {}\",\n+                        memberDeleted ? \"deleted \" : \"\", member.getFedoraId());\n+                final Instant memberCreated;\n+                // Get the creation time from the deleted object if the member is a tombstone\n+                if (memberDeleted) {\n+                    memberCreated = ((Tombstone) member).getDeletedObject().getCreatedDate();\n+                } else {\n+                    memberCreated = member.getCreatedDate();\n+                }\n+                final var memberModified = member.getLastModifiedDate();\n+                final var memberEnd = memberDeleted ? memberModified : NO_END_INSTANT;\n+\n+                // Reduce timeline to just states in effect after the member was created\n+                var timelineStream = propertyTimeline.stream()\n+                        .filter(e -> e.endDatetime.compareTo(memberCreated) > 0);\n+                // If the member was deleted, then reduce timeline to states before the deletion\n+                if (memberDeleted) {\n+                    timelineStream = timelineStream.filter(e -> e.mementoDatetime.compareTo(memberModified) < 0);\n+                }\n+                // Index each addition or change to the membership generated by this member\n+                timelineStream.forEach(e -> {\n+                    // Start time of the membership is the later of member creation or membership resc memento time\n+                    indexManager.addMembership(txId, containerId,\n+                            generateMembershipTriple(e.membershipResource,\n+                                    memberNode, e.hasMemberRelation, e.isMemberOfRelation),\n+                            instantMax(memberCreated, e.mementoDatetime),\n+                            instantMin(memberEnd, e.endDatetime));\n+                });\n+            });\n+        }\n+    }\n+\n+    private Instant instantMax(final Instant first, final Instant second) {\n+        if (first.isAfter(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    private Instant instantMin(final Instant first, final Instant second) {\n+        if (first.isBefore(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    /**\n+     * Creates a timeline of states for a DirectContainer, tracking changes to its\n+     * properties that impact membership.\n+     * @param fedoraResc resource subject of the timeline\n+     * @return timeline\n+     */\n+    private List<DirectContainerProperties> makePropertyTimeline(final FedoraResource fedoraResc) {\n+        final var entryList = fedoraResc.getTimeMap().getChildren()\n+                .sorted((m1, m2) -> m1.getFedoraId().getFullId().compareTo(m1.getFedoraId().getFullId()))", "originalCommit": "a64c47de676a72456a64bcef747fffb7b3890cc5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDc2OQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498394769", "bodyText": "Are you just trying to sort the mementos by date? If so, I think they should already be sorted.", "author": "pwinckles", "createdAt": "2020-10-01T17:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzMTc0MA==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498431740", "bodyText": "Yes, I'm trying to sort them by date, I'm happy to remove the sort (and its typo) if we can rely on the versions to be sorted in ascending order. If that's a guarantee, perhaps we should update the documentation for org.fcrepo.persistence.api.PersistentStorageSession.listVersions(FedoraId) to state that? Any other theoretic persistence implementations would need to ensure order too.", "author": "bbpennel", "createdAt": "2020-10-01T18:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NTYyOQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498395629", "bodyText": "Why are you using a while loop rather than a for loop?", "author": "pwinckles", "createdAt": "2020-10-01T17:09:37Z", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\");\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {\n+        final FedoraResource fedoraResc = getFedoraResource(txId, containerId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            final var propertyTimeline = makePropertyTimeline(fedoraResc);\n+\n+            // get all the members of the DC and index the history for each, accounting for changes to the DC\n+            fedoraResc.getChildren().forEach(member -> {\n+                final var memberDeleted = member instanceof Tombstone;\n+                final var memberNode = NodeFactory.createURI(member.getFedoraId().getFullId());\n+                log.debug(\"Populating membership history for DirectContainer {}member {}\",\n+                        memberDeleted ? \"deleted \" : \"\", member.getFedoraId());\n+                final Instant memberCreated;\n+                // Get the creation time from the deleted object if the member is a tombstone\n+                if (memberDeleted) {\n+                    memberCreated = ((Tombstone) member).getDeletedObject().getCreatedDate();\n+                } else {\n+                    memberCreated = member.getCreatedDate();\n+                }\n+                final var memberModified = member.getLastModifiedDate();\n+                final var memberEnd = memberDeleted ? memberModified : NO_END_INSTANT;\n+\n+                // Reduce timeline to just states in effect after the member was created\n+                var timelineStream = propertyTimeline.stream()\n+                        .filter(e -> e.endDatetime.compareTo(memberCreated) > 0);\n+                // If the member was deleted, then reduce timeline to states before the deletion\n+                if (memberDeleted) {\n+                    timelineStream = timelineStream.filter(e -> e.mementoDatetime.compareTo(memberModified) < 0);\n+                }\n+                // Index each addition or change to the membership generated by this member\n+                timelineStream.forEach(e -> {\n+                    // Start time of the membership is the later of member creation or membership resc memento time\n+                    indexManager.addMembership(txId, containerId,\n+                            generateMembershipTriple(e.membershipResource,\n+                                    memberNode, e.hasMemberRelation, e.isMemberOfRelation),\n+                            instantMax(memberCreated, e.mementoDatetime),\n+                            instantMin(memberEnd, e.endDatetime));\n+                });\n+            });\n+        }\n+    }\n+\n+    private Instant instantMax(final Instant first, final Instant second) {\n+        if (first.isAfter(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    private Instant instantMin(final Instant first, final Instant second) {\n+        if (first.isBefore(second)) {\n+            return first;\n+        } else {\n+            return second;\n+        }\n+    }\n+\n+    /**\n+     * Creates a timeline of states for a DirectContainer, tracking changes to its\n+     * properties that impact membership.\n+     * @param fedoraResc resource subject of the timeline\n+     * @return timeline\n+     */\n+    private List<DirectContainerProperties> makePropertyTimeline(final FedoraResource fedoraResc) {\n+        final var entryList = fedoraResc.getTimeMap().getChildren()\n+                .sorted((m1, m2) -> m1.getFedoraId().getFullId().compareTo(m1.getFedoraId().getFullId()))\n+                .map(memento -> new DirectContainerProperties(memento))\n+                .collect(Collectors.toList());\n+\n+        // Reduce timeline to entries where significant properties change\n+        final var changeEntries = new ArrayList<DirectContainerProperties>();\n+        var curr = entryList.get(0);\n+        changeEntries.add(curr);\n+        int i = 1;\n+        while (i < entryList.size()) {", "originalCommit": "a64c47de676a72456a64bcef747fffb7b3890cc5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzMzAyMw==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498433023", "bodyText": "Hmm, I'd like to think I had a reason at some point, but doesn't seem like there is one, I'll switch it.", "author": "bbpennel", "createdAt": "2020-10-01T18:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NTYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5ODg0MQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498398841", "bodyText": "I think you'll actually want a @Transactional at this level", "author": "pwinckles", "createdAt": "2020-10-01T17:15:30Z", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {", "originalCommit": "a64c47de676a72456a64bcef747fffb7b3890cc5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5OTYxMQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498399611", "bodyText": "@Transactional", "author": "pwinckles", "createdAt": "2020-10-01T17:16:51Z", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\");\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {", "originalCommit": "a64c47de676a72456a64bcef747fffb7b3890cc5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzNDQyMA==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498434420", "bodyText": "Sure. In the case of a container with lots of members this could be a very long transaction, I'm guessing that won't be problematic?", "author": "bbpennel", "createdAt": "2020-10-01T18:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5OTYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzNzEwNQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498437105", "bodyText": "No, I wouldn't expect that would be a problem", "author": "pwinckles", "createdAt": "2020-10-01T18:26:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5OTYxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5OTc1MA==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498399750", "bodyText": "@Transactional", "author": "pwinckles", "createdAt": "2020-10-01T17:17:07Z", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Value(\"${fcrepo.autoversioning.enabled:true}\")\n+    private boolean autoVersioningEnabled;\n+\n+    @Override\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            // If using manual versioning all membership history could change for this source\n+            if (!autoVersioningEnabled) {\n+                indexManager.deleteMembershipForSource(txId, fedoraId);\n+                populateMembershipHistory(txId, fedoraId);\n+                return;\n+            }\n+\n+            // For autoversioning, perform incremental update of properties\n+            final var dcRdfResc = getRdfResource(fedoraResc);\n+\n+            final var dcLastModified = fedoraResc.getLastModifiedDate();\n+\n+            // Delete/end existing membership from this container\n+            indexManager.endMembershipForSource(txId, fedoraResc.getFedoraId(), dcLastModified);\n+\n+            // Add updated membership properties for all non-tombstone children\n+            fedoraResc.getChildren()\n+                    .filter(child -> !(child instanceof Tombstone))\n+                    .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                    .forEach(newMembership -> indexManager.addMembership(txId, fedoraId,\n+                            newMembership, dcLastModified));\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {", "originalCommit": "a64c47de676a72456a64bcef747fffb7b3890cc5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMTM5OA==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498401398", "bodyText": "Perhaps the column names should be constants?", "author": "pwinckles", "createdAt": "2020-10-01T17:20:12Z", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/default-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,", "originalCommit": "a64c47de676a72456a64bcef747fffb7b3890cc5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzNTIzMA==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498435230", "bodyText": "The parameter names or the column names? I'm okay with constants for the parameter names", "author": "bbpennel", "createdAt": "2020-10-01T18:23:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMTM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzNzI2NA==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498437264", "bodyText": "The keys in the map", "author": "pwinckles", "createdAt": "2020-10-01T18:26:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMTM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxNzM3NQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498417375", "bodyText": "I think there may be some oddness here when addMembership() is called after calling deleteMembershipForSource(), but it's possible that I just don't understand the intended behavior. The problem I see is that there are two different types of deletes, with or without the force flag. deleteMembershipForSource() creates deletes with the force flag, and I assume that you would always want to apply them. However, this method will delete all of these operations in the transaction, so they won't be applied. Won't this result in duplicate entries (assuming there aren't any db constraints being violated)? I think the case where this matters is MembershipServiceImpl#L104.", "author": "pwinckles", "createdAt": "2020-10-01T17:49:24Z", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/default-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", ADD_OPERATION);\n+\n+        final int affected = jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parameterSource);\n+\n+        // If no rows were deleted, then assume we need to delete permanent entry\n+        if (affected == 0) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"subjectId\", membership.getSubject().getURI(),\n+                    \"property\", membership.getPredicate().getURI(),\n+                    \"objectId\", membership.getObject().getURI(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_MEMBERSHIP, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * End membership entry within a transaction\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipInTx(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"endTime\", Timestamp.from(endTime),\n+                \"noEndTime\", NO_END_TIMESTAMP);\n+        jdbcTemplate.update(END_MEMBERSHIP_IN_TX, parameterSource);\n+    }\n+\n+    /**\n+     * End all membership properties resulting from the specified source container\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime) {\n+        deleteMembershipForSource(txId, sourceId, endTime, false);\n+    }\n+\n+    /**\n+     * Delete all membership properties from a source container, clearing properties from\n+     * the current transaction and setting an action to clear the properties outside the tx\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be cleaned up\n+     */\n+    public void deleteMembershipForSource(final String txId, final FedoraId sourceId) {\n+        deleteMembershipForSource(txId, sourceId, null, true);\n+    }\n+\n+    private void deleteMembershipForSource(final String txId, final FedoraId sourceId, final Instant endTime,\n+            final boolean deleteProperties) {\n+        // End all membership added in this transaction\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"addOp\", ADD_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX, parameterSource);\n+\n+        // End all membership that existed prior to this transaction\n+        if (deleteProperties) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"forceFlag\", FORCE_FLAG,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(DELETE_EXISTING_FOR_SOURCE, parameterSource2);\n+        } else {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    \"txId\", txId,\n+                    \"sourceId\", sourceId.getFullId(),\n+                    \"endTime\", Timestamp.from(endTime),\n+                    \"noEndTime\", NO_END_TIMESTAMP,\n+                    \"deleteOp\", DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_FOR_SOURCE, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * Clean up any references to the target id, in transactions and outside\n+     * @param txId transaction id\n+     * @param targetId identifier of the resource to cleanup membership references for\n+     */\n+    public void deleteMembershipReferences(final String txId, final FedoraId targetId) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                \"targetId\", targetId.getFullId(),\n+                \"txId\", txId);\n+\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_TRANSACTION, parameterSource);\n+        jdbcTemplate.update(PURGE_ALL_REFERENCES_MEMBERSHIP, parameterSource);\n+    }\n+\n+    /**\n+     * Add new membership property to the index, clearing any delete\n+     * operations for the property if necessary.\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container which produced the membership\n+     * @param membership membership triple\n+     * @param startTime time the membership triple was added\n+     */\n+    public void addMembership(final String txId, final FedoraId sourceId, final Triple membership,\n+            final Instant startTime) {\n+        // Clear any existing delete operation for this membership\n+        final Map<String, Object> parametersDelete = Map.of(\n+                \"txId\", txId,\n+                \"sourceId\", sourceId.getFullId(),\n+                \"subjectId\", membership.getSubject().getURI(),\n+                \"property\", membership.getPredicate().getURI(),\n+                \"objectId\", membership.getObject().getURI(),\n+                \"operation\", DELETE_OPERATION);\n+\n+        jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parametersDelete);", "originalCommit": "a64c47de676a72456a64bcef747fffb7b3890cc5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzNjU0MQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r498436541", "bodyText": "That's a good point, I believe I should exclude force_flag deletes from being cleaned up here.", "author": "bbpennel", "createdAt": "2020-10-01T18:25:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxNzM3NQ=="}], "type": "inlineReview"}, {"oid": "a831edb1b0d09db43e149ee3a001a87cc74a7667", "url": "https://github.com/fcrepo/fcrepo/commit/a831edb1b0d09db43e149ee3a001a87cc74a7667", "message": "Initial commit of membership service", "committedDate": "2020-10-01T18:58:35Z", "type": "commit"}, {"oid": "8dba75f7b807f66f66520ebbb29d098a2bb5d383", "url": "https://github.com/fcrepo/fcrepo/commit/8dba75f7b807f66f66520ebbb29d098a2bb5d383", "message": "Implement getMembers for non-mementos, allow committing of transactions", "committedDate": "2020-10-01T18:58:35Z", "type": "commit"}, {"oid": "4fea69370a66740a1edfd1e8346ad088f8cc1bf8", "url": "https://github.com/fcrepo/fcrepo/commit/4fea69370a66740a1edfd1e8346ad088f8cc1bf8", "message": "Implement and test modification of DirectContainers, adjustments to interface", "committedDate": "2020-10-01T18:58:36Z", "type": "commit"}, {"oid": "a1a91ac78edb71b6e116d8d77557a2e62b83c6f5", "url": "https://github.com/fcrepo/fcrepo/commit/a1a91ac78edb71b6e116d8d77557a2e62b83c6f5", "message": "Implement getting membership for mementos", "committedDate": "2020-10-01T18:58:36Z", "type": "commit"}, {"oid": "67a562f490566e747b02609040a28bf5307f932f", "url": "https://github.com/fcrepo/fcrepo/commit/67a562f490566e747b02609040a28bf5307f932f", "message": "Trigger membership indexing", "committedDate": "2020-10-01T18:59:19Z", "type": "commit"}, {"oid": "f2a6f8dd81dedb70029e09d1f5e2bcf16081ef45", "url": "https://github.com/fcrepo/fcrepo/commit/f2a6f8dd81dedb70029e09d1f5e2bcf16081ef45", "message": "Return empty list for getUserTypes() if the resource is deleted and the user rdf is not present", "committedDate": "2020-10-01T18:59:19Z", "type": "commit"}, {"oid": "db11116944ed6a090bac017f1e38292f9f581ff3", "url": "https://github.com/fcrepo/fcrepo/commit/db11116944ed6a090bac017f1e38292f9f581ff3", "message": "Handle resources being purged. Fix up tests", "committedDate": "2020-10-01T19:00:09Z", "type": "commit"}, {"oid": "f88e38f798a2450f3ddca5070101aeda5d04a9c1", "url": "https://github.com/fcrepo/fcrepo/commit/f88e38f798a2450f3ddca5070101aeda5d04a9c1", "message": "Mysql membership config", "committedDate": "2020-10-01T19:00:09Z", "type": "commit"}, {"oid": "4f10d32395643baba8e38eb614638bca2ec286bf", "url": "https://github.com/fcrepo/fcrepo/commit/4f10d32395643baba8e38eb614638bca2ec286bf", "message": "Rebuild membership index during a rebuild", "committedDate": "2020-10-01T19:00:09Z", "type": "commit"}, {"oid": "80756127756820e1ad464e87b6d2d7bc286434de", "url": "https://github.com/fcrepo/fcrepo/commit/80756127756820e1ad464e87b6d2d7bc286434de", "message": "Handle modifications of DCs with autoversioning disabled by regenerating the index for that DC. Differentiate between 'end' and 'delete' more consistently.", "committedDate": "2020-10-01T19:00:09Z", "type": "commit"}, {"oid": "34a67b4917396f2cbbd83e23b1421c5b04f1cb01", "url": "https://github.com/fcrepo/fcrepo/commit/34a67b4917396f2cbbd83e23b1421c5b04f1cb01", "message": "Cleanup", "committedDate": "2020-10-01T19:00:09Z", "type": "commit"}, {"oid": "e4abc61e19d78e7b9acc9282d0c6c00624649361", "url": "https://github.com/fcrepo/fcrepo/commit/e4abc61e19d78e7b9acc9282d0c6c00624649361", "message": "Add primary key to avoid max primary key length error in some dbs. Other adjustments to accomodate specific db requirements", "committedDate": "2020-10-01T19:00:09Z", "type": "commit"}, {"oid": "8c18bac31a4b0ef9ab37ad43b5859782cf591d5d", "url": "https://github.com/fcrepo/fcrepo/commit/8c18bac31a4b0ef9ab37ad43b5859782cf591d5d", "message": "Adjustments for dbs", "committedDate": "2020-10-01T19:00:09Z", "type": "commit"}, {"oid": "ed94142905c43c7eedac4f9233b8e0ef68289b1a", "url": "https://github.com/fcrepo/fcrepo/commit/ed94142905c43c7eedac4f9233b8e0ef68289b1a", "message": "Reduce fields in index", "committedDate": "2020-10-01T19:00:09Z", "type": "commit"}, {"oid": "50004a2d5f82fc75eb729a5f040e8a8edca6bb67", "url": "https://github.com/fcrepo/fcrepo/commit/50004a2d5f82fc75eb729a5f040e8a8edca6bb67", "message": "Update index for mysql", "committedDate": "2020-10-01T19:00:09Z", "type": "commit"}, {"oid": "51cf5f15f9f7a9e9e8493f656cee4627e7a8f3ff", "url": "https://github.com/fcrepo/fcrepo/commit/51cf5f15f9f7a9e9e8493f656cee4627e7a8f3ff", "message": "Address feedback and some mysql issues", "committedDate": "2020-10-01T19:00:09Z", "type": "commit"}, {"oid": "edbbd407825cea0b6df5188a761cd43e52783351", "url": "https://github.com/fcrepo/fcrepo/commit/edbbd407825cea0b6df5188a761cd43e52783351", "message": "Datetime for date fields in mariadb and mysql, timestamp for postgres and h2", "committedDate": "2020-10-01T19:00:09Z", "type": "commit"}, {"oid": "edbbd407825cea0b6df5188a761cd43e52783351", "url": "https://github.com/fcrepo/fcrepo/commit/edbbd407825cea0b6df5188a761cd43e52783351", "message": "Datetime for date fields in mariadb and mysql, timestamp for postgres and h2", "committedDate": "2020-10-01T19:00:09Z", "type": "forcePushed"}, {"oid": "da3b4a13493ea6d7129ed42633135514727fecc8", "url": "https://github.com/fcrepo/fcrepo/commit/da3b4a13493ea6d7129ed42633135514727fecc8", "message": "Use constants for parameter names, use OcflPropsConfig for getting autoversioning state", "committedDate": "2020-10-01T19:34:22Z", "type": "commit"}, {"oid": "22e9c047d602ebb0cc870d5f66372241095ff6e0", "url": "https://github.com/fcrepo/fcrepo/commit/22e9c047d602ebb0cc870d5f66372241095ff6e0", "message": "Fix word order", "committedDate": "2020-10-01T20:41:08Z", "type": "commit"}, {"oid": "04b837f99591584b495aec00da3b83b626ae3014", "url": "https://github.com/fcrepo/fcrepo/commit/04b837f99591584b495aec00da3b83b626ae3014", "message": "Return TimeMap from getTimeMap. Timemap now has method for getting a list of version times", "committedDate": "2020-10-02T18:01:11Z", "type": "commit"}, {"oid": "9422e6203b8521bff2df7b159327a34f5215b358", "url": "https://github.com/fcrepo/fcrepo/commit/9422e6203b8521bff2df7b159327a34f5215b358", "message": "Perform more selective reindexing when a DC is modified with on demand versioning", "committedDate": "2020-10-02T18:05:00Z", "type": "commit"}, {"oid": "be16c5850f662ae201dfce45866f6d65d2b8bf8b", "url": "https://github.com/fcrepo/fcrepo/commit/be16c5850f662ae201dfce45866f6d65d2b8bf8b", "message": "Add transactional to indexManager methods", "committedDate": "2020-10-05T14:00:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5NjUwMw==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499696503", "bodyText": "To be clear, this SQL deletes membership relations when the provided dateTime is either before (or at) the \"start_time\" of the relationship or the provided dateTime is before (or at) the \"end_time\" of the relationship?\nIt probably makes sense... I am just trying to understand the scenario.", "author": "awoods", "createdAt": "2020-10-05T15:44:43Z", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+import javax.transaction.Transactional;\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+    private static final Timestamp NO_START_TIMESTAMP = Timestamp.from(Instant.parse(\"1000-01-01T00:00:00.000Z\"));\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String TX_ID_PARAM = \"txId\";\n+    private static final String SUBJECT_ID_PARAM = \"subjectId\";\n+    private static final String NO_END_TIME_PARAM = \"noEndTime\";\n+    private static final String ADD_OP_PARAM = \"addOp\";\n+    private static final String DELETE_OP_PARAM = \"deleteOp\";\n+    private static final String MEMENTO_TIME_PARAM = \"mementoTime\";\n+    private static final String PROPERTY_PARAM = \"property\";\n+    private static final String TARGET_ID_PARAM = \"targetId\";\n+    private static final String SOURCE_ID_PARAM = \"sourceId\";\n+    private static final String START_TIME_PARAM = \"startTime\";\n+    private static final String END_TIME_PARAM = \"endTime\";\n+    private static final String OPERATION_PARAM = \"operation\";\n+    private static final String FORCE_PARAM = \"forceFlag\";\n+    private static final String OBJECT_ID_PARAM = \"objectId\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\" +\n+                \" AND force_flag IS NULL\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE_AFTER =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND (m.start_time >= :startTime\" +\n+                \" OR m.end_time >= :startTime)\";", "originalCommit": "be16c5850f662ae201dfce45866f6d65d2b8bf8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgxMzAyOQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499813029", "bodyText": "Yes, that's right. It is to deal with obnoxious history rewriting from modifying mutable head versions of DirectContainers. Sorry to do this to you, but consider the following timeline, in a repo with autoversioning turned off:\n\nCreate membership resc coll1 and direct container dc1 with membership relation ex:hasMember1, at time T0.\nAt time T1, resource dc1/mem1 is created. This adds an entry to the index:\n<coll1> ex:hasMember1 <dc1/mem1> which spans T1 to forever.\nAt time T2, dc1 is changed to have relation ex:hasMember2. The index is now:\n<coll1> ex:hasMember2 <dc1/mem1> which spans T1 to forever (the old entry is deleted since its end time was >= T2)\nAt T3, create V1 of dc1. No changes to the index.\nAt time T4, dc1 is changed to have relation ex:hasMember3. The index is now:\n<coll1> ex:hasMember2 <dc1/mem1> which spans T1 to T4 (T3/V1 locked ex:hasMember2 in, which changes at T4)\n<coll1> ex:hasMember3 <dc1/mem1> which spans T4 to forever.\nAt T5, dc1 is changed back to relation ex:hasMember1. History in the index is editted:\n<coll1> ex:hasMember2 <dc1/mem1> which spans T1 to T5 (note, end time changed)\n<coll1> ex:hasMember1 <dc1/mem1> which spans T5 to forever.\n\nThe query in question allows the last few states to be rewritten. Alternatively, I could regenerate the full history of membership produced by dc1 whenever its modified, which I had earlier in the PR. Its simpler, but obviously costly in scenarios where clients create versions of DCs and modify them.", "author": "bbpennel", "createdAt": "2020-10-05T19:10:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5NjUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1NDE3Nw==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499854177", "bodyText": "Thanks for the explanation and deep consideration of scenarios.", "author": "awoods", "createdAt": "2020-10-05T20:30:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5NjUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0MzI3OA==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499743278", "bodyText": "Can this method be removed? It does not appear to be called anywhere.", "author": "awoods", "createdAt": "2020-10-05T17:00:21Z", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipIndexManager.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.sql.DataSource;\n+import javax.transaction.Transactional;\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.fcrepo.common.db.DbPlatform;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.slf4j.Logger;\n+import org.springframework.core.io.DefaultResourceLoader;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n+import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\n+import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Manager for the membership index\n+ *\n+ * @author bbpennel\n+ */\n+@Component\n+public class MembershipIndexManager {\n+    private static final Logger log = getLogger(MembershipIndexManager.class);\n+\n+    private static final Timestamp NO_END_TIMESTAMP = Timestamp.from(MembershipServiceImpl.NO_END_INSTANT);\n+    private static final Timestamp NO_START_TIMESTAMP = Timestamp.from(Instant.parse(\"1000-01-01T00:00:00.000Z\"));\n+\n+    private static final String ADD_OPERATION = \"add\";\n+    private static final String DELETE_OPERATION = \"delete\";\n+    private static final String FORCE_FLAG = \"force\";\n+\n+    private static final String TX_ID_PARAM = \"txId\";\n+    private static final String SUBJECT_ID_PARAM = \"subjectId\";\n+    private static final String NO_END_TIME_PARAM = \"noEndTime\";\n+    private static final String ADD_OP_PARAM = \"addOp\";\n+    private static final String DELETE_OP_PARAM = \"deleteOp\";\n+    private static final String MEMENTO_TIME_PARAM = \"mementoTime\";\n+    private static final String PROPERTY_PARAM = \"property\";\n+    private static final String TARGET_ID_PARAM = \"targetId\";\n+    private static final String SOURCE_ID_PARAM = \"sourceId\";\n+    private static final String START_TIME_PARAM = \"startTime\";\n+    private static final String END_TIME_PARAM = \"endTime\";\n+    private static final String OPERATION_PARAM = \"operation\";\n+    private static final String FORCE_PARAM = \"forceFlag\";\n+    private static final String OBJECT_ID_PARAM = \"objectId\";\n+\n+    private static final String SELECT_ALL_MEMBERSHIP = \"SELECT * FROM membership\";\n+\n+    private static final String SELECT_ALL_OPERATIONS = \"SELECT * FROM membership_tx_operations\";\n+\n+    private static final String SELECT_MEMBERSHIP =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_IN_TX =\n+            \"SELECT m.property, m.object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\";\n+\n+    private static final String SELECT_MEMBERSHIP_MEMENTO_IN_TX =\n+            \"SELECT property, object_id\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.subject_id = :subjectId\" +\n+                \" AND m.start_time <= :mementoTime\" +\n+                \" AND m.end_time > :mementoTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT 1\" +\n+                    \" FROM membership_tx_operations mto\" +\n+                    \" WHERE mto.subject_id = :subjectId\" +\n+                        \" AND mto.source_id = m.source_id\" +\n+                        \" AND mto.property = m.property\" +\n+                        \" AND mto.object_id = m.object_id\" +\n+                        \" AND mto.end_time <= :mementoTime\" +\n+                        \" AND mto.tx_id = :txId\" +\n+                        \" AND mto.operation = :deleteOp)\" +\n+            \" UNION\" +\n+            \" SELECT property, object_id\" +\n+            \" FROM membership_tx_operations\" +\n+            \" WHERE subject_id = :subjectId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND start_time <= :mementoTime\" +\n+                \" AND end_time > :mementoTime\" +\n+                \" AND operation = :addOp\";\n+\n+    private static final String INSERT_MEMBERSHIP_IN_TX =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" VALUES (:subjectId, :property, :targetId, :sourceId, :startTime, :endTime, :txId, :operation)\";\n+\n+    private static final String END_EXISTING_MEMBERSHIP =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT m.subject_id, m.property, m.object_id, m.source_id, m.start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND m.end_time = :noEndTime\" +\n+                \" AND m.subject_id = :subjectId\" +\n+                \" AND m.property = :property\" +\n+                \" AND m.object_id = :objectId\";\n+\n+    private static final String END_MEMBERSHIP_IN_TX =\n+            \"UPDATE membership_tx_operations\" +\n+            \" SET end_time = :endTime\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\";\n+\n+    private static final String CLEAR_ENTRY_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND subject_id = :subjectId\" +\n+                \" AND property = :property\" +\n+                \" AND object_id = :objectId\" +\n+                \" AND operation = :operation\" +\n+                \" AND force_flag IS NULL\";\n+\n+    private static final String CLEAR_ALL_ADDED_FOR_SOURCE_IN_TX =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND tx_id = :txId\" +\n+                \" AND operation = :addOp\";\n+\n+    // Add \"delete\" entries for all existing membership from the given source, if not already deleted\n+    private static final String END_EXISTING_FOR_SOURCE =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, :endTime, :txId, :deleteOp\" +\n+            \" FROM membership m\" +\n+            \" WHERE source_id = :sourceId\" +\n+                \" AND end_time = :noEndTime\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership_tx_operations mtx\" +\n+                    \" WHERE mtx.subject_id = m.subject_id\" +\n+                        \" AND mtx.property = m.property\" +\n+                        \" AND mtx.object_id = m.object_id\" +\n+                        \" AND mtx.source_id = m.source_id\" +\n+                        \" AND mtx.operation = :deleteOp\" +\n+                    \")\";\n+\n+    private static final String DELETE_EXISTING_FOR_SOURCE_AFTER =\n+            \"INSERT INTO membership_tx_operations\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time, tx_id, operation, force_flag)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time, :txId, :deleteOp, :forceFlag\" +\n+            \" FROM membership m\" +\n+            \" WHERE m.source_id = :sourceId\" +\n+                \" AND (m.start_time >= :startTime\" +\n+                \" OR m.end_time >= :startTime)\";\n+\n+    private static final String PURGE_ALL_REFERENCES_MEMBERSHIP =\n+            \"DELETE from membership\" +\n+            \" where source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId\";\n+\n+    private static final String PURGE_ALL_REFERENCES_TRANSACTION =\n+            \"DELETE from membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\" +\n+                \" AND (source_id = :targetId\" +\n+                \" OR subject_id = :targetId\" +\n+                \" OR object_id = :targetId)\";\n+\n+    private static final String COMMIT_DELETES =\n+            \"DELETE from membership\" +\n+            \" WHERE EXISTS (\" +\n+                \" SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND mto.force_flag = :forceFlag\" +\n+                    \" AND membership.source_id = mto.source_id\" +\n+                    \" AND membership.subject_id = mto.subject_id\" +\n+                    \" AND membership.property = mto.property\" +\n+                    \" AND membership.object_id = mto.object_id\" +\n+                \" )\";\n+\n+\n+    private static final String COMMIT_ENDS =\n+            \"UPDATE membership m\" +\n+            \" SET end_time = (\" +\n+                \" SELECT mto.end_time\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                \" )\" +\n+            \" WHERE EXISTS (\" +\n+                \"SELECT TRUE\" +\n+                \" FROM membership_tx_operations mto\" +\n+                \" WHERE mto.tx_id = :txId\" +\n+                    \" AND mto.operation = :deleteOp\" +\n+                    \" AND m.source_id = mto.source_id\" +\n+                    \" AND m.subject_id = mto.subject_id\" +\n+                    \" AND m.property = mto.property\" +\n+                    \" AND m.object_id = mto.object_id\" +\n+                \" )\";\n+\n+    // Transfer all \"add\" operations from tx to committed membership, unless the entry already exists\n+    private static final String COMMIT_ADDS =\n+            \"INSERT INTO membership\" +\n+            \" (subject_id, property, object_id, source_id, start_time, end_time)\" +\n+            \" SELECT subject_id, property, object_id, source_id, start_time, end_time\" +\n+            \" FROM membership_tx_operations mto\" +\n+            \" WHERE mto.tx_id = :txId\" +\n+                \" AND mto.operation = :addOp\" +\n+                \" AND NOT EXISTS (\" +\n+                    \" SELECT TRUE\" +\n+                    \" FROM membership m\" +\n+                    \" WHERE m.source_id = mto.source_id\" +\n+                        \" AND m.subject_id = mto.subject_id\" +\n+                        \" AND m.property = mto.property\" +\n+                        \" AND m.object_id = mto.object_id\" +\n+                        \" AND m.start_time = mto.start_time\" +\n+                        \" AND m.end_time = mto.end_time\" +\n+                \" )\";\n+\n+    private static final String DELETE_TRANSACTION =\n+            \"DELETE FROM membership_tx_operations\" +\n+            \" WHERE tx_id = :txId\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP = \"TRUNCATE TABLE membership\";\n+\n+    private static final String TRUNCATE_MEMBERSHIP_TX = \"TRUNCATE TABLE membership_tx_operations\";\n+\n+    @Inject\n+    private DataSource dataSource;\n+\n+    private NamedParameterJdbcTemplate jdbcTemplate;\n+\n+    private static final Map<DbPlatform, String> DDL_MAP = Map.of(\n+            DbPlatform.MYSQL, \"sql/mysql-membership.sql\",\n+            DbPlatform.H2, \"sql/default-membership.sql\",\n+            DbPlatform.POSTGRESQL, \"sql/default-membership.sql\",\n+            DbPlatform.MARIADB, \"sql/mariadb-membership.sql\"\n+    );\n+\n+    @PostConstruct\n+    public void setUp() {\n+        jdbcTemplate = new NamedParameterJdbcTemplate(getDataSource());\n+\n+        final var dbPlatform = DbPlatform.fromDataSource(dataSource);\n+\n+        Preconditions.checkArgument(DDL_MAP.containsKey(dbPlatform),\n+                \"Missing DDL mapping for %s\", dbPlatform);\n+\n+        final var ddl = DDL_MAP.get(dbPlatform);\n+        log.debug(\"Applying ddl: {}\", ddl);\n+        DatabasePopulatorUtils.execute(\n+                new ResourceDatabasePopulator(new DefaultResourceLoader().getResource(\"classpath:\" + ddl)),\n+                dataSource);\n+    }\n+\n+    /**\n+     * End a membership entry, setting an end time if committed, or clearing from the current tx\n+     * if it was newly added.\n+     *\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    @Transactional\n+    public void endMembership(final String txId,  final FedoraId sourceId, final Triple membership,\n+            final Instant endTime) {\n+        final Map<String, Object> parameterSource = Map.of(\n+                TX_ID_PARAM, txId,\n+                SOURCE_ID_PARAM, sourceId.getFullId(),\n+                SUBJECT_ID_PARAM, membership.getSubject().getURI(),\n+                PROPERTY_PARAM, membership.getPredicate().getURI(),\n+                OBJECT_ID_PARAM, membership.getObject().getURI(),\n+                OPERATION_PARAM, ADD_OPERATION);\n+\n+        final int affected = jdbcTemplate.update(CLEAR_ENTRY_IN_TX, parameterSource);\n+\n+        // If no rows were deleted, then assume we need to delete permanent entry\n+        if (affected == 0) {\n+            final Map<String, Object> parameterSource2 = Map.of(\n+                    TX_ID_PARAM, txId,\n+                    SOURCE_ID_PARAM, sourceId.getFullId(),\n+                    SUBJECT_ID_PARAM, membership.getSubject().getURI(),\n+                    PROPERTY_PARAM, membership.getPredicate().getURI(),\n+                    OBJECT_ID_PARAM, membership.getObject().getURI(),\n+                    END_TIME_PARAM, Timestamp.from(endTime),\n+                    NO_END_TIME_PARAM, NO_END_TIMESTAMP,\n+                    DELETE_OP_PARAM, DELETE_OPERATION);\n+            jdbcTemplate.update(END_EXISTING_MEMBERSHIP, parameterSource2);\n+        }\n+    }\n+\n+    /**\n+     * End membership entry within a transaction\n+     * @param txId transaction id\n+     * @param sourceId ID of the direct/indirect container whose membership should be ended\n+     * @param membership membership triple to end\n+     * @param endTime the time the resource was deleted, generally its last modified\n+     */\n+    public void endMembershipInTx(final String txId,  final FedoraId sourceId, final Triple membership,", "originalCommit": "be16c5850f662ae201dfce45866f6d65d2b8bf8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwMzA2Ng==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499803066", "bodyText": "Good catch, I think this got leftover during a few refactors of populateMembershipHistory", "author": "bbpennel", "createdAt": "2020-10-05T18:51:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0MzI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1NTk4Mw==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499755983", "bodyText": "txId never used.", "author": "awoods", "createdAt": "2020-10-05T17:23:23Z", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import javax.transaction.Transactional;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.config.OcflPropsConfig;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Inject\n+    private OcflPropsConfig propsConfig;\n+\n+    @Override\n+    @Transactional\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            if (propsConfig.isAutoVersioningEnabled()) {\n+                modifyDCAutoversioned(txId, fedoraResc);\n+            } else {\n+                modifyDCOnDemandVersioning(txId, fedoraResc);\n+            }\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private void modifyDCAutoversioned(final String txId, final FedoraResource dcResc) {\n+        final var dcId = dcResc.getFedoraId();\n+        final var dcRdfResc = getRdfResource(dcResc);\n+\n+        final var dcLastModified = dcResc.getLastModifiedDate();\n+\n+        // Delete/end existing membership from this container\n+        indexManager.endMembershipForSource(txId, dcResc.getFedoraId(), dcLastModified);\n+\n+        // Add updated membership properties for all non-tombstone children\n+        dcResc.getChildren()\n+                .filter(child -> !(child instanceof Tombstone))\n+                .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                .forEach(newMembership -> indexManager.addMembership(txId, dcId,\n+                        newMembership, dcLastModified));\n+    }\n+\n+    private void modifyDCOnDemandVersioning(final String txId, final FedoraResource dcResc) {\n+        final var dcId = dcResc.getFedoraId();\n+        final var mementoDatetimes = dcResc.getTimeMap().listMementoDatetimes();\n+        final Instant lastVersionDatetime;\n+        if (mementoDatetimes.size() == 0) {\n+            // If no previous versions of DC, then cleanup and repopulate everything\n+            lastVersionDatetime = null;\n+        } else {\n+            // If at least one past version, then reindex membership involving the last version and after\n+            lastVersionDatetime = mementoDatetimes.get(mementoDatetimes.size() - 1);\n+        }\n+        indexManager.deleteMembershipForSourceAfter(txId, dcId, lastVersionDatetime);\n+        populateMembershipHistory(txId, dcResc, lastVersionDatetime);\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,", "originalCommit": "be16c5850f662ae201dfce45866f6d65d2b8bf8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MTEwMQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499761101", "bodyText": "Maybe add a , between \"{}\" and \"member\"?", "author": "awoods", "createdAt": "2020-10-05T17:32:50Z", "path": "fcrepo-kernel-impl/src/main/java/org/fcrepo/kernel/impl/services/MembershipServiceImpl.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.kernel.impl.services;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.fcrepo.kernel.api.RdfCollectors.toModel;\n+\n+import org.slf4j.Logger;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import javax.transaction.Transactional;\n+\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.NodeFactory;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.rdf.model.Resource;\n+import org.fcrepo.config.OcflPropsConfig;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.PathNotFoundException;\n+import org.fcrepo.kernel.api.exception.PathNotFoundRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.Binary;\n+import org.fcrepo.kernel.api.models.Container;\n+import org.fcrepo.kernel.api.models.FedoraResource;\n+import org.fcrepo.kernel.api.models.ResourceFactory;\n+import org.fcrepo.kernel.api.models.Tombstone;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+\n+/**\n+ * Implementation of a service which updates and persists membership properties for resources\n+ *\n+ * @author bbpennel\n+ * @since 6.0.0\n+ */\n+@Component\n+public class MembershipServiceImpl implements MembershipService {\n+    private static final Logger log = getLogger(MembershipServiceImpl.class);\n+\n+    public static final Instant NO_END_INSTANT = Instant.parse(\"9999-12-31T00:00:00.000Z\");\n+\n+    @Inject\n+    private MembershipIndexManager indexManager;\n+\n+    @Inject\n+    private ResourceFactory resourceFactory;\n+\n+    @Inject\n+    private OcflPropsConfig propsConfig;\n+\n+    @Override\n+    @Transactional\n+    public void resourceCreated(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        // Only need to compute membership for created containers and binaries\n+        if (!(fedoraResc instanceof Container || fedoraResc instanceof Binary)) {\n+            return;\n+        }\n+\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var newMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.addMembership(txId, parentResc.getFedoraId(), newMembership, fedoraResc.getCreatedDate());\n+        }\n+\n+        // TODO check if fedoraResc is a member of any IndirectContainers\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void resourceModified(final String txId, final FedoraId fedoraId) {\n+        final var fedoraResc = getFedoraResource(txId, fedoraId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            log.debug(\"Modified DirectContainer {}, recomputing generated membership relations\", fedoraId);\n+\n+            if (propsConfig.isAutoVersioningEnabled()) {\n+                modifyDCAutoversioned(txId, fedoraResc);\n+            } else {\n+                modifyDCOnDemandVersioning(txId, fedoraResc);\n+            }\n+            return;\n+        }\n+        // TODO handle modification of IndirectContainers and proxies\n+    }\n+\n+    private void modifyDCAutoversioned(final String txId, final FedoraResource dcResc) {\n+        final var dcId = dcResc.getFedoraId();\n+        final var dcRdfResc = getRdfResource(dcResc);\n+\n+        final var dcLastModified = dcResc.getLastModifiedDate();\n+\n+        // Delete/end existing membership from this container\n+        indexManager.endMembershipForSource(txId, dcResc.getFedoraId(), dcLastModified);\n+\n+        // Add updated membership properties for all non-tombstone children\n+        dcResc.getChildren()\n+                .filter(child -> !(child instanceof Tombstone))\n+                .map(child -> generateDirectMembership(txId, dcRdfResc, child))\n+                .forEach(newMembership -> indexManager.addMembership(txId, dcId,\n+                        newMembership, dcLastModified));\n+    }\n+\n+    private void modifyDCOnDemandVersioning(final String txId, final FedoraResource dcResc) {\n+        final var dcId = dcResc.getFedoraId();\n+        final var mementoDatetimes = dcResc.getTimeMap().listMementoDatetimes();\n+        final Instant lastVersionDatetime;\n+        if (mementoDatetimes.size() == 0) {\n+            // If no previous versions of DC, then cleanup and repopulate everything\n+            lastVersionDatetime = null;\n+        } else {\n+            // If at least one past version, then reindex membership involving the last version and after\n+            lastVersionDatetime = mementoDatetimes.get(mementoDatetimes.size() - 1);\n+        }\n+        indexManager.deleteMembershipForSourceAfter(txId, dcId, lastVersionDatetime);\n+        populateMembershipHistory(txId, dcResc, lastVersionDatetime);\n+    }\n+\n+    private Triple generateDirectMembership(final String txId, final Resource dcRdfResc,\n+            final FedoraResource memberResc) {\n+        final var memberRdfResc = getRdfResource(memberResc.getFedoraId());\n+\n+        final var membershipResc = getMembershipResource(dcRdfResc);\n+        final var memberOfRel = getMemberOfRelation(dcRdfResc);\n+        final var hasMemberRel = getHasMemberRelation(dcRdfResc);\n+\n+        return generateMembershipTriple(membershipResc.asNode(), memberRdfResc.asNode(),\n+                hasMemberRel.asNode(), memberOfRel == null ? null : memberOfRel.asNode());\n+    }\n+\n+    private Triple generateMembershipTriple(final Node membership, final Node member,\n+            final Node hasMemberRel, final Node memberOfRel) {\n+        if (memberOfRel != null) {\n+            return new Triple(member, memberOfRel, membership);\n+        } else {\n+            return new Triple(membership, hasMemberRel, member);\n+        }\n+    }\n+\n+    private boolean isDirectContainer(final FedoraResource fedoraResc) {\n+        return fedoraResc instanceof Container && fedoraResc.hasType(RdfLexicon.DIRECT_CONTAINER.getURI());\n+    }\n+\n+    private Resource getRdfResource(final FedoraResource fedoraResc) {\n+        final var model = fedoraResc.getTriples().collect(toModel());\n+        return model.getResource(fedoraResc.getFedoraId().getFullId());\n+    }\n+\n+    private Resource getRdfResource(final FedoraId fedoraId) {\n+        return org.apache.jena.rdf.model.ResourceFactory.createResource(fedoraId.getFullId());\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:isMemberOfRelation property for the given resource, or null if none is specified\n+     */\n+    private Resource getMemberOfRelation(final Resource resc) {\n+        final var memberOfRelStmt = resc.getProperty(RdfLexicon.IS_MEMBER_OF_RELATION);\n+        if (memberOfRelStmt != null) {\n+            return memberOfRelStmt.getResource();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @param resc\n+     * @return the ldp:hasMemberRelation property for the given resource, or ldp:member if none is specified\n+     */\n+    private Resource getHasMemberRelation(final Resource resc) {\n+        final var hasMemberStmt = resc.getProperty(RdfLexicon.HAS_MEMBER_RELATION);\n+        if (hasMemberStmt != null) {\n+            return hasMemberStmt.getResource();\n+        } else {\n+            return RdfLexicon.LDP_MEMBER;\n+        }\n+    }\n+\n+    private Resource getMembershipResource(final Resource containerResc) {\n+        return containerResc.getPropertyResourceValue(RdfLexicon.MEMBERSHIP_RESOURCE);\n+    }\n+\n+    private FedoraResource getFedoraResource(final String txId, final FedoraId fedoraId) {\n+        try {\n+            return resourceFactory.getResource(txId, fedoraId);\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    private FedoraResource getParentResource(final FedoraResource resc) {\n+        try {\n+            return resc.getParent();\n+        } catch (final PathNotFoundException e) {\n+            throw new PathNotFoundRuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void resourceDeleted(final String txId, final FedoraId fedoraId) {\n+        // delete DirectContainer, end all membership for that source\n+        FedoraResource fedoraResc;\n+        try {\n+            fedoraResc = getFedoraResource(txId, fedoraId);\n+        } catch (final PathNotFoundRuntimeException e) {\n+            log.debug(\"Deleted resource {} does not have a tombstone, cleanup any references\", fedoraId);\n+            indexManager.deleteMembershipReferences(txId, fedoraId);\n+            return;\n+        }\n+        if (fedoraResc instanceof Tombstone) {\n+            fedoraResc = ((Tombstone) fedoraResc).getDeletedObject();\n+        }\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            indexManager.endMembershipForSource(txId, fedoraId, fedoraResc.getLastModifiedDate());\n+        }\n+\n+        // delete child of DirectContainer, clear from tx and end existing\n+        final var parentResc = getParentResource(fedoraResc);\n+\n+        if (isDirectContainer(parentResc)) {\n+            final var parentRdfResc = getRdfResource(parentResc);\n+            final var deletedMembership = generateDirectMembership(txId, parentRdfResc, fedoraResc);\n+            indexManager.endMembership(txId, parentResc.getFedoraId(), deletedMembership,\n+                    fedoraResc.getLastModifiedDate());\n+\n+        }\n+    }\n+\n+    @Override\n+    public RdfStream getMembership(final String txId, final FedoraId fedoraId) {\n+        final FedoraId subjectId;\n+        if (fedoraId.isDescription()) {\n+            subjectId = fedoraId.asBaseId();\n+        } else {\n+            subjectId = fedoraId;\n+        }\n+        final var subject = NodeFactory.createURI(subjectId.getBaseId());\n+        final var membershipStream = indexManager.getMembership(txId, subjectId);\n+        return new DefaultRdfStream(subject, membershipStream);\n+    }\n+\n+    @Override\n+    public void commitTransaction(final String txId) {\n+        indexManager.commitTransaction(txId);\n+    }\n+\n+    @Override\n+    public void rollbackTransaction(final String txId) {\n+        indexManager.deleteTransaction(txId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        indexManager.clearIndex();\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void populateMembershipHistory(final String txId, final FedoraId containerId) {\n+        final FedoraResource fedoraResc = getFedoraResource(txId, containerId);\n+\n+        if (isDirectContainer(fedoraResc)) {\n+            populateMembershipHistory(txId, fedoraResc, null);\n+        }\n+    }\n+\n+    private void populateMembershipHistory(final String txId, final FedoraResource fedoraResc,\n+            final Instant afterTime) {\n+        final var containerId = fedoraResc.getFedoraId();\n+        final var propertyTimeline = makePropertyTimeline(fedoraResc);\n+        final List<DirectContainerProperties> timeline;\n+        // If provided, filter the timeline to just entries active on or after the specified time\n+        if (afterTime != null) {\n+            timeline = propertyTimeline.stream().filter(e -> e.startDatetime.compareTo(afterTime) >= 0\n+                    || e.endDatetime.compareTo(afterTime) >= 0)\n+                .collect(Collectors.toList());\n+        } else {\n+            timeline = propertyTimeline;\n+        }\n+\n+        // get all the members of the DC and index the history for each, accounting for changes to the DC\n+        fedoraResc.getChildren().forEach(member -> {\n+            final var memberDeleted = member instanceof Tombstone;\n+            final var memberNode = NodeFactory.createURI(member.getFedoraId().getFullId());\n+            log.debug(\"Populating membership history for DirectContainer {}member {}\",", "originalCommit": "be16c5850f662ae201dfce45866f6d65d2b8bf8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwMTEwOQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1760#discussion_r499801109", "bodyText": "I know it looks goofy, but that would result in two spaces between DirectContainer and member if the member isn't deleted. I could remove the deletion state from the debug statement though", "author": "bbpennel", "createdAt": "2020-10-05T18:48:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MTEwMQ=="}], "type": "inlineReview"}, {"oid": "a421b4d36ea5e0fc3f94dae05234ac000c51b25f", "url": "https://github.com/fcrepo/fcrepo/commit/a421b4d36ea5e0fc3f94dae05234ac000c51b25f", "message": "Remove unused parameter and method", "committedDate": "2020-10-05T19:11:00Z", "type": "commit"}]}