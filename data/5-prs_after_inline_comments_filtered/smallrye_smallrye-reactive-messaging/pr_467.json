{"pr_number": 467, "pr_title": "Fixes #79 - Add support for @Blocking", "pr_createdAt": "2020-03-26T21:00:51Z", "pr_url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg5NTM2Ng==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398895366", "bodyText": "Maybe isExecutionOrdered or isBlockingExecutionOrdered?", "author": "cescoffier", "createdAt": "2020-03-26T21:11:20Z", "path": "api/src/main/java/io/smallrye/reactive/messaging/MediatorConfiguration.java", "diffHunk": "@@ -41,6 +41,12 @@\n \n     int getNumberOfSubscriberBeforeConnecting();\n \n+    boolean isBlocking();\n+\n+    String getWorkerPoolName();\n+\n+    boolean isOrderedExecution();", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk2OTQ3NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398969474", "bodyText": "Latter?", "author": "kenfinnigan", "createdAt": "2020-03-27T00:26:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg5NTM2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwNTAxMw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399105013", "bodyText": "+1", "author": "cescoffier", "createdAt": "2020-03-27T08:33:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg5NTM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkwMzQzNw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398903437", "bodyText": "don't we have a closeAnAwait() method?", "author": "cescoffier", "createdAt": "2020-03-26T21:27:50Z", "path": "smallrye-reactive-messaging-amqp/src/test/java/io/smallrye/reactive/messaging/amqp/AmqpTestBase.java", "diffHunk": "@@ -45,7 +46,8 @@ public void tearDown() throws InterruptedException {\n \n         CountDownLatch latch = new CountDownLatch(1);\n         usage.close();\n-        vertx.close().subscribe().with(x -> latch.countDown(), f -> latch.countDown());\n+        executionHolder.vertx().close().subscribe().with(x -> latch.countDown(), f -> latch.countDown());", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTIzOTgxNg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399239816", "bodyText": "I just retained the code that was there previously as well.\nBut if the vertx().closeAndAwait() inside executionHolder.terminate() is fine, I can remove the line", "author": "kenfinnigan", "createdAt": "2020-03-27T12:49:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkwMzQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkwODE4NQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398908185", "bodyText": "For my own curiosity. How does that work?", "author": "cescoffier", "createdAt": "2020-03-26T21:37:31Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConnector.java", "diffHunk": "@@ -39,26 +41,17 @@\n     private List<KafkaSource> sources = new CopyOnWriteArrayList<>();\n     private List<KafkaSink> sinks = new CopyOnWriteArrayList<>();\n \n-    private boolean internalVertxInstance = false;\n     private Vertx vertx;\n \n-    public void terminate(@Observes @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(50) @BeforeDestroyed(ApplicationScoped.class) Object event) {", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk3MDcxMQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398970711", "bodyText": "@Observes(notifyObserver = Reception.IF_EXISTS) means that an instance of this bean isn't created to call the terminate() method if one doesn't exist.\n@Priority then defines the ordering, with lower numbers being triggered first", "author": "kenfinnigan", "createdAt": "2020-03-27T00:31:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkwODE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwMzY0Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399103642", "bodyText": "So it makes the hypothesis that the processing is synchronous/blocking? Or priority cannot be enforced right?", "author": "cescoffier", "createdAt": "2020-03-27T08:30:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkwODE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI0MDIyOA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399240228", "bodyText": "All observers are synchronous by default unless you specify an async observer.", "author": "kenfinnigan", "createdAt": "2020-03-27T12:49:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkwODE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkxMDA5Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398910092", "bodyText": "wondering if we could check that only once.", "author": "cescoffier", "createdAt": "2020-03-26T21:41:38Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/AbstractMediator.java", "diffHunk": "@@ -73,6 +80,21 @@ public void initialize(Object bean) {\n         }\n     }\n \n+    protected <T> Uni<T> invokeBlocking(Object... args) {\n+        try {\n+            Objects.requireNonNull(this.invoker, \"Invoker not initialized\");", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk2OTYxMA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398969610", "bodyText": "I will see if somewhere fits", "author": "kenfinnigan", "createdAt": "2020-03-27T00:27:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkxMDA5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3Mjk5OA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401872998", "bodyText": "Any chance with this?", "author": "cescoffier", "createdAt": "2020-04-01T19:57:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkxMDA5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2MTQ2Ng==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r402261466", "bodyText": "So, I think we can move it to initialize() of each mediator after they've called super.initialize(), but it does mean duplicating that check across the mediators.\nWhat do you think?", "author": "kenfinnigan", "createdAt": "2020-04-02T12:06:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkxMDA5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMzE2NQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r402403165", "bodyText": "let's keep it there for now. We can revisit later.", "author": "cescoffier", "createdAt": "2020-04-02T15:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkxMDA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyMDc3MQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398920771", "bodyText": "Maybe we should log a message.", "author": "cescoffier", "createdAt": "2020-03-26T22:04:58Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/ExecutionHolder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.inject.Inject;\n+\n+import io.vertx.mutiny.core.Vertx;\n+\n+@ApplicationScoped\n+public class ExecutionHolder {\n+\n+    @Inject\n+    private Instance<Vertx> instanceOfVertx;\n+\n+    private boolean internalVertxInstance = false;\n+    private Vertx vertx;\n+\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(200) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        if (internalVertxInstance) {\n+            vertx.close().await().indefinitely();\n+        }\n+    }\n+\n+    @PostConstruct\n+    public void init() {\n+        if (instanceOfVertx == null || instanceOfVertx.isUnsatisfied()) {\n+            internalVertxInstance = true;\n+            this.vertx = Vertx.vertx();", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk3MDg0NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398970844", "bodyText": "That we're creating an instance? sure", "author": "kenfinnigan", "createdAt": "2020-03-27T00:32:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyMDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NDUwMw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399084503", "bodyText": "Yes.", "author": "cescoffier", "createdAt": "2020-03-27T07:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyMDc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyMTI4NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398921284", "bodyText": "Action instead of code?", "author": "cescoffier", "createdAt": "2020-03-26T22:06:12Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/WorkerPoolRegistry.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.enterprise.inject.spi.AnnotatedMethod;\n+import javax.enterprise.inject.spi.AnnotatedType;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+import io.smallrye.reactive.messaging.annotations.Incomings;\n+import io.smallrye.reactive.messaging.helpers.Validation;\n+import io.vertx.core.Handler;\n+import io.vertx.mutiny.core.Promise;\n+import io.vertx.mutiny.core.WorkerExecutor;\n+\n+@ApplicationScoped\n+public class WorkerPoolRegistry {\n+    private static final String WORKER_CONFIG_PREFIX = \"smallrye.messaging.worker\";\n+    private static final String WORKER_CONCURRENCY = \"max-concurrency\";\n+\n+    @Inject\n+    private ExecutionHolder executionHolder;\n+\n+    @Inject\n+    private Instance<Config> configInstance;\n+\n+    private Map<String, Integer> workerDefinitions = new HashMap<>();\n+    private Map<String, WorkerExecutor> workerExecutors = new ConcurrentHashMap<>();\n+\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(100) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        if (!workerExecutors.isEmpty()) {\n+            for (WorkerExecutor executor : workerExecutors.values()) {\n+                executor.close();\n+            }\n+        }\n+    }\n+\n+    public <T> Uni<T> executeWork(Handler<Promise<T>> blockingCodeHandler, String workerName, boolean ordered) {\n+        Objects.requireNonNull(blockingCodeHandler, \"Code to execute not provided\");", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyMjEyMA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398922120", "bodyText": "Need to be synchronized I guess.", "author": "cescoffier", "createdAt": "2020-03-26T22:08:14Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/WorkerPoolRegistry.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.enterprise.inject.spi.AnnotatedMethod;\n+import javax.enterprise.inject.spi.AnnotatedType;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+import io.smallrye.reactive.messaging.annotations.Incomings;\n+import io.smallrye.reactive.messaging.helpers.Validation;\n+import io.vertx.core.Handler;\n+import io.vertx.mutiny.core.Promise;\n+import io.vertx.mutiny.core.WorkerExecutor;\n+\n+@ApplicationScoped\n+public class WorkerPoolRegistry {\n+    private static final String WORKER_CONFIG_PREFIX = \"smallrye.messaging.worker\";\n+    private static final String WORKER_CONCURRENCY = \"max-concurrency\";\n+\n+    @Inject\n+    private ExecutionHolder executionHolder;\n+\n+    @Inject\n+    private Instance<Config> configInstance;\n+\n+    private Map<String, Integer> workerDefinitions = new HashMap<>();\n+    private Map<String, WorkerExecutor> workerExecutors = new ConcurrentHashMap<>();\n+\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(100) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        if (!workerExecutors.isEmpty()) {\n+            for (WorkerExecutor executor : workerExecutors.values()) {\n+                executor.close();\n+            }\n+        }\n+    }\n+\n+    public <T> Uni<T> executeWork(Handler<Promise<T>> blockingCodeHandler, String workerName, boolean ordered) {\n+        Objects.requireNonNull(blockingCodeHandler, \"Code to execute not provided\");\n+\n+        if (workerName == null) {\n+            return executionHolder.vertx().executeBlocking(blockingCodeHandler, ordered);\n+        } else {\n+            return getWorker(workerName).executeBlocking(blockingCodeHandler, ordered);\n+        }\n+    }\n+\n+    private WorkerExecutor getWorker(String workerName) {", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyNjIwMw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398926203", "bodyText": "I'm not sure we need to be that precise.", "author": "cescoffier", "createdAt": "2020-03-26T22:17:32Z", "path": "smallrye-reactive-messaging-provider/src/test/java/io/smallrye/reactive/messaging/blocking/BlockingProcessorTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package io.smallrye.reactive.messaging.blocking;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.junit.Test;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.reactive.messaging.MyCollector;\n+import io.smallrye.reactive.messaging.WeldTestBase;\n+import io.smallrye.reactive.messaging.blocking.beans.BeanConsumingItemsAndProducingItems;\n+import io.smallrye.reactive.messaging.blocking.beans.BeanConsumingItemsAndProducingMessages;\n+import io.smallrye.reactive.messaging.blocking.beans.BeanConsumingMessagesAndProducingItems;\n+import io.smallrye.reactive.messaging.blocking.beans.BeanConsumingMessagesAndProducingMessages;\n+\n+public class BlockingProcessorTest extends WeldTestBase {\n+\n+    private static final List<String> LIST = Multi.createFrom().range(1, 11).map(i -> Integer.toString(i))\n+            .collectItems().asList()\n+            .await().indefinitely();\n+\n+    @Test\n+    public void testBeanConsumingMessagesAndProducingMessages() {\n+        addBeanClass(BeanConsumingMessagesAndProducingMessages.class);\n+        initialize();\n+        MyCollector collector = container.select(MyCollector.class).get();\n+        await().until(collector::hasCompleted);\n+        assertThat(collector.payloads()).isEqualTo(LIST);\n+\n+        BeanConsumingMessagesAndProducingMessages bean = container.select(BeanConsumingMessagesAndProducingMessages.class)\n+                .get();\n+\n+        List<String> threadNames = bean.threads().stream().distinct().collect(Collectors.toList());\n+        assertThat(threadNames.contains(Thread.currentThread().getName())).isFalse();\n+        for (String name : threadNames) {\n+            assertThat(name.startsWith(\"vert.x-worker-thread-\")).isTrue();\n+        }\n+    }\n+\n+    @Test\n+    public void testBeanConsumingMessagesAndProducingItems() {\n+        addBeanClass(BeanConsumingMessagesAndProducingItems.class);\n+        initialize();\n+        MyCollector collector = container.select(MyCollector.class).get();\n+        await().until(collector::hasCompleted);\n+        assertThat(collector.payloads()).isEqualTo(LIST);\n+\n+        BeanConsumingMessagesAndProducingItems bean = container.select(BeanConsumingMessagesAndProducingItems.class).get();\n+\n+        List<String> threadNames = bean.threads().stream().distinct().collect(Collectors.toList());\n+        assertThat(threadNames.contains(Thread.currentThread().getName())).isFalse();\n+        for (String name : threadNames) {\n+            assertThat(name.startsWith(\"vert.x-worker-thread-\")).isTrue();", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk2OTc3Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r398969772", "bodyText": "Well, it makes sure it's on the worker thread ;-)", "author": "kenfinnigan", "createdAt": "2020-03-27T00:27:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyNjIwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwNTIxNw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399105217", "bodyText": "Ok, fair enough :-)", "author": "cescoffier", "createdAt": "2020-03-27T08:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyNjIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4MDc5Ng==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399080796", "bodyText": "I would add a note telling that when possible the initial thread (execution context) is \"restored\" once the blocking operation has been completed. This should also be explained in the doc.\nI would also add a few lines about the configuration.", "author": "cescoffier", "createdAt": "2020-03-27T07:37:00Z", "path": "api/src/main/java/io/smallrye/reactive/messaging/annotations/Blocking.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package io.smallrye.reactive.messaging.annotations;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Identifies that a particular method performs blocking operations,\n+ * and as such should be executed on a worker thread.\n+ */", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4MDk5Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399080992", "bodyText": "Instead of NO_VALUE maybe it should be DEFAULT_WORKER_POOL.", "author": "cescoffier", "createdAt": "2020-03-27T07:37:35Z", "path": "api/src/main/java/io/smallrye/reactive/messaging/annotations/Blocking.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package io.smallrye.reactive.messaging.annotations;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Identifies that a particular method performs blocking operations,\n+ * and as such should be executed on a worker thread.\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(METHOD)\n+public @interface Blocking {\n+    String NO_VALUE = \"<no-value>\";", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4MjIyMQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399082221", "bodyText": "This requires a bit more explanation.\nSomething like:\nThe blocking processing of the incoming messages is executed on worker threads. However, some combustion may be faster than others. When ordered is set to true, the results are emitted in the same order as the input so the order is preserved. When ordered is set to false, results are emitted as soon as the blocking computation terminated, regardless if the combustion from previous messages has completed.\nthe result of the blocking operation will be emitted in the same order as the input.", "author": "cescoffier", "createdAt": "2020-03-27T07:41:08Z", "path": "api/src/main/java/io/smallrye/reactive/messaging/annotations/Blocking.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package io.smallrye.reactive.messaging.annotations;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Identifies that a particular method performs blocking operations,\n+ * and as such should be executed on a worker thread.\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(METHOD)\n+public @interface Blocking {\n+    String NO_VALUE = \"<no-value>\";\n+\n+    /**\n+     * Indicates the name of the worker pool to use for execution.\n+     * By default all executions will be performed on the default worker pool.\n+     *\n+     * @return custom worker pool name for blocking execution.\n+     */\n+    String value() default NO_VALUE;\n+\n+    /**\n+     * Indicates whether the execution on the worker pool should be ordered.\n+     * By default all executions are ordered.", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTIzNTMyNA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399235324", "bodyText": "did you really mean \"combustion\" above?", "author": "kenfinnigan", "createdAt": "2020-03-27T12:40:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4MjIyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI0Njg5NQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399246895", "bodyText": ":-) ... computation.", "author": "cescoffier", "createdAt": "2020-03-27T13:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4MjIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NDcwOA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399084708", "bodyText": "Not sure about CDI concurrency model. Should it be synchronized? (as well as the accessor)", "author": "cescoffier", "createdAt": "2020-03-27T07:47:38Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/ExecutionHolder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.inject.Inject;\n+\n+import io.vertx.mutiny.core.Vertx;\n+\n+@ApplicationScoped\n+public class ExecutionHolder {\n+\n+    @Inject\n+    private Instance<Vertx> instanceOfVertx;\n+\n+    private boolean internalVertxInstance = false;\n+    private Vertx vertx;\n+\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(200) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        if (internalVertxInstance) {\n+            vertx.close().await().indefinitely();\n+        }\n+    }\n+\n+    @PostConstruct\n+    public void init() {", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTExMDY0Mw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399110643", "bodyText": "It does not have to be synchronized but the vertx field should be volatile. A better approach would be to make the  vertx field final and use constructor injection:\nprivate final Vertx vertx;\n\n// Dummy no-args constructor needed for client proxies, not needed on quarkus ;-)\nExecutionHolder() {\n}\n\n@Inject\nExecutionHolder(Instance<Vertx> instanceOfVertx) {\n  this.vertx = ...\n}", "author": "mkouba", "createdAt": "2020-03-27T08:44:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NDcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEyMjUxMg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399122512", "bodyText": "Yes, that would be much better!", "author": "cescoffier", "createdAt": "2020-03-27T09:07:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NDcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI1ODkwOQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399258909", "bodyText": "Set Vertx to null in the default constructor?", "author": "kenfinnigan", "createdAt": "2020-03-27T13:21:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NDcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwNTY2MA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399305660", "bodyText": "It also impacts tests that don't use CDI container, as I need to set the Vertx instance", "author": "kenfinnigan", "createdAt": "2020-03-27T14:30:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NDcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwODAxMA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399308010", "bodyText": "Set Vertx to null in the default constructor?\n\nI think so. And make sure it's package-private. It should be only used when instantiating a client proxy.\n\nIt also impacts tests that don't use CDI container, as I need to set the Vertx instance.\n\nIn that case you can add one more constructor that accepts a Vertx instance directly.", "author": "mkouba", "createdAt": "2020-03-27T14:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NDcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NTIwMA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399085200", "bodyText": "I would add some javadoc explaining the role of this component:\n\nProvides common runtime services to the connector such as Vertx so it avoids duplicating creation and cleanup in the various connectors.", "author": "cescoffier", "createdAt": "2020-03-27T07:48:49Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/ExecutionHolder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.inject.Inject;\n+\n+import io.vertx.mutiny.core.Vertx;\n+\n+@ApplicationScoped\n+public class ExecutionHolder {", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NTM2Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399085362", "bodyText": "@mkouba Just to verify. Does this work in ArC?", "author": "cescoffier", "createdAt": "2020-03-27T07:49:09Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/ExecutionHolder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.inject.Inject;\n+\n+import io.vertx.mutiny.core.Vertx;\n+\n+@ApplicationScoped\n+public class ExecutionHolder {\n+\n+    @Inject\n+    private Instance<Vertx> instanceOfVertx;\n+\n+    private boolean internalVertxInstance = false;\n+    private Vertx vertx;\n+\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(200) @BeforeDestroyed(ApplicationScoped.class) Object event) {", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4NzA4Nw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399087087", "bodyText": "Not really related to this PR, but I guess we should provide logging facilities in AbstractMediator because that sounds duplicated a few times.", "author": "cescoffier", "createdAt": "2020-03-27T07:53:24Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/AbstractMediator.java", "diffHunk": "@@ -73,6 +80,21 @@ public void initialize(Object bean) {\n         }\n     }\n \n+    protected <T> Uni<T> invokeBlocking(Object... args) {\n+        try {\n+            Objects.requireNonNull(this.invoker, \"Invoker not initialized\");\n+            Objects.requireNonNull(this.workerPoolRegistry, \"Worker pool not initialized\");\n+            return workerPoolRegistry.executeWork(\n+                    future -> future.complete((T) this.invoker.invoke(args)),\n+                    configuration.getWorkerPoolName(),\n+                    configuration.isOrderedExecution());\n+        } catch (RuntimeException e) {\n+            LoggerFactory.getLogger(configuration().methodAsString())", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4ODkzNg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399088936", "bodyText": "For safety and logging reason I would do something like:\ntry {\n    T res = (T) this.invoker.invoke(args);\n    if (res == null) {\n         throw new NullPointerException(\"The operation .... has returned null\"\n    }\n   future.complete(res);\n} catch(Throwable e) {\n    future.fail(e);\n}", "author": "cescoffier", "createdAt": "2020-03-27T07:57:44Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/AbstractMediator.java", "diffHunk": "@@ -73,6 +80,21 @@ public void initialize(Object bean) {\n         }\n     }\n \n+    protected <T> Uni<T> invokeBlocking(Object... args) {\n+        try {\n+            Objects.requireNonNull(this.invoker, \"Invoker not initialized\");\n+            Objects.requireNonNull(this.workerPoolRegistry, \"Worker pool not initialized\");\n+            return workerPoolRegistry.executeWork(\n+                    future -> future.complete((T) this.invoker.invoke(args)),", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4OTg5MA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399089890", "bodyText": "The message is not totally correct, as you check for method returning Void (NONE).", "author": "cescoffier", "createdAt": "2020-03-27T07:59:46Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/MediatorConfigurationSupport.java", "diffHunk": "@@ -490,6 +490,29 @@ public Integer processBroadcast(Object outgoing, Supplier<Integer> supplier) {\n         return null;\n     }\n \n+    public void validateBlocking(ValidationOutput validationOutput) {\n+        if (!(validationOutput.production.equals(MediatorConfiguration.Production.INDIVIDUAL_MESSAGE)\n+                || validationOutput.production.equals(MediatorConfiguration.Production.INDIVIDUAL_PAYLOAD)\n+                || validationOutput.production.equals(MediatorConfiguration.Production.NONE))) {\n+            throw getBlockingError(\"The @Blocking annotation is only supported for methods returning Message or a payload\");", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4OTk2NQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399089965", "bodyText": "I would add an individual Message or payload.", "author": "cescoffier", "createdAt": "2020-03-27T07:59:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4OTg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5MDI1MA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399090250", "bodyText": "Same comment.", "author": "cescoffier", "createdAt": "2020-03-27T08:00:42Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/MediatorConfigurationSupport.java", "diffHunk": "@@ -490,6 +490,29 @@ public Integer processBroadcast(Object outgoing, Supplier<Integer> supplier) {\n         return null;\n     }\n \n+    public void validateBlocking(ValidationOutput validationOutput) {\n+        if (!(validationOutput.production.equals(MediatorConfiguration.Production.INDIVIDUAL_MESSAGE)\n+                || validationOutput.production.equals(MediatorConfiguration.Production.INDIVIDUAL_PAYLOAD)\n+                || validationOutput.production.equals(MediatorConfiguration.Production.NONE))) {\n+            throw getBlockingError(\"The @Blocking annotation is only supported for methods returning Message or a payload\");\n+        }\n+\n+        if (!(validationOutput.consumption.equals(MediatorConfiguration.Consumption.MESSAGE)\n+                || validationOutput.consumption.equals(MediatorConfiguration.Consumption.PAYLOAD)\n+                || validationOutput.consumption.equals(MediatorConfiguration.Consumption.NONE))) {\n+            throw getBlockingError(\n+                    \"The @Blocking annotation is only supported for methods with parameters of Message or a payload\");", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5MDM4NQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399090385", "bodyText": "You need to also check for Uni.", "author": "cescoffier", "createdAt": "2020-03-27T08:01:05Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/MediatorConfigurationSupport.java", "diffHunk": "@@ -490,6 +490,29 @@ public Integer processBroadcast(Object outgoing, Supplier<Integer> supplier) {\n         return null;\n     }\n \n+    public void validateBlocking(ValidationOutput validationOutput) {\n+        if (!(validationOutput.production.equals(MediatorConfiguration.Production.INDIVIDUAL_MESSAGE)\n+                || validationOutput.production.equals(MediatorConfiguration.Production.INDIVIDUAL_PAYLOAD)\n+                || validationOutput.production.equals(MediatorConfiguration.Production.NONE))) {\n+            throw getBlockingError(\"The @Blocking annotation is only supported for methods returning Message or a payload\");\n+        }\n+\n+        if (!(validationOutput.consumption.equals(MediatorConfiguration.Consumption.MESSAGE)\n+                || validationOutput.consumption.equals(MediatorConfiguration.Consumption.PAYLOAD)\n+                || validationOutput.consumption.equals(MediatorConfiguration.Consumption.NONE))) {\n+            throw getBlockingError(\n+                    \"The @Blocking annotation is only supported for methods with parameters of Message or a payload\");\n+        }\n+\n+        if (ClassUtils.isAssignable(returnType, CompletionStage.class)) {", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3NDI1Mw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401874253", "bodyText": "Could you add the check?", "author": "cescoffier", "createdAt": "2020-04-01T19:59:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5MDM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NzgxMw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401977813", "bodyText": "I added it below", "author": "kenfinnigan", "createdAt": "2020-04-01T23:59:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5MDM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5MTg0Nw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399091847", "bodyText": "We may want to refactor and extract this code as it's now duplicated a few times. It can be done in another PR.", "author": "cescoffier", "createdAt": "2020-03-27T08:04:39Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/SubscriberMediator.java", "diffHunk": "@@ -127,20 +127,36 @@ public void onComplete() {\n     }\n \n     private void processMethodReturningVoid() {\n-        this.subscriber = ReactiveStreams.<Message<?>> builder()\n-                .flatMapCompletionStage(managePreProcessingAck())\n-                .map(message -> {\n-                    invoke(message.getPayload());\n-                    return message;\n-                })\n-                .flatMapCompletionStage(x -> {\n-                    if (configuration.getAcknowledgment() == Acknowledgment.Strategy.POST_PROCESSING) {\n-                        return getAckOrCompletion(x);\n-                    } else {\n-                        return CompletableFuture.completedFuture(x);\n-                    }\n-                })\n-                .ignore();\n+        if (configuration.isBlocking()) {\n+            this.subscriber = ReactiveStreams.<Message<?>> builder()\n+                    .flatMapCompletionStage(managePreProcessingAck())\n+                    .flatMapCompletionStage(message -> ((Uni<?>) invokeBlocking(message.getPayload()))\n+                            .subscribeAsCompletionStage()\n+                            .thenApply(x -> message))\n+                    .flatMapCompletionStage(x -> {\n+                        if (configuration.getAcknowledgment() == Acknowledgment.Strategy.POST_PROCESSING) {", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5Mjc1Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399092752", "bodyText": "This should have been tested before (I've added a comment about this case).", "author": "cescoffier", "createdAt": "2020-03-27T08:06:59Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/PublisherMediator.java", "diffHunk": "@@ -110,17 +110,33 @@ private void produceAPublisherOfMessages() {\n     }\n \n     private void produceIndividualMessages() {\n-        setPublisher(ReactiveStreams.generate(() -> {\n-            Message message = invoke();\n-            Objects.requireNonNull(message,\n-                    \"The method \" + configuration.methodAsString() + \" returned an invalid value: null\");\n-            return message;\n-        }));\n+        if (configuration.isBlocking()) {\n+            setPublisher(ReactiveStreams.<Uni<?>> generate(this::invokeBlocking)\n+                    .flatMapCompletionStage(Uni::subscribeAsCompletionStage)\n+                    .map(message -> {\n+                        Objects.requireNonNull(message,", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI1MTUzOQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399251539", "bodyText": "So remove the null check?", "author": "kenfinnigan", "createdAt": "2020-03-27T13:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5Mjc1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI1NjM0Mw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399256343", "bodyText": "If you follow the other approach in invokeBlocking yes.", "author": "cescoffier", "createdAt": "2020-03-27T13:17:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5Mjc1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NDUxOA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399094518", "bodyText": "There is a bug here. It may have been there before.\nPOST_PROCESSING acknowledgment is not handled correctly (well not handled at all).", "author": "cescoffier", "createdAt": "2020-03-27T08:11:13Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/ProcessorMediator.java", "diffHunk": "@@ -234,44 +234,92 @@ private void processMethodReturningAPublisherOfPayloadsAndConsumingPayloads() {\n     private void processMethodReturningIndividualMessageAndConsumingIndividualItem() {\n         // Item can be message or payload\n         if (configuration.consumption() == MediatorConfiguration.Consumption.PAYLOAD) {\n-            this.processor = ReactiveStreams.<Message> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message) invoke(input.getPayload()))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input.getPayload()))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message) result))\n+                        .buildRs();", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI0NDI3Mw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399244273", "bodyText": "I was wondering that yesterday, as it seemed it was the only one without it. Should've asked then!", "author": "kenfinnigan", "createdAt": "2020-03-27T12:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NDUxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3NDcxMw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401874713", "bodyText": "Can you open an issue?", "author": "cescoffier", "createdAt": "2020-04-01T20:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NDUxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2NTA0Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r402265042", "bodyText": "#480", "author": "kenfinnigan", "createdAt": "2020-04-02T12:13:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NDUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NDk5MA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399094990", "bodyText": "Same here.\nPOST_PROCESSING acknowledgment is not handled.", "author": "cescoffier", "createdAt": "2020-03-27T08:12:14Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/ProcessorMediator.java", "diffHunk": "@@ -234,44 +234,92 @@ private void processMethodReturningAPublisherOfPayloadsAndConsumingPayloads() {\n     private void processMethodReturningIndividualMessageAndConsumingIndividualItem() {\n         // Item can be message or payload\n         if (configuration.consumption() == MediatorConfiguration.Consumption.PAYLOAD) {\n-            this.processor = ReactiveStreams.<Message> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message) invoke(input.getPayload()))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input.getPayload()))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message) result))\n+                        .buildRs();\n+            } else {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .map(input -> (Message) invoke(input.getPayload()))", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NTE2MQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399095161", "bodyText": "POST_PROCESSING acknowledgment is not handled correctly", "author": "cescoffier", "createdAt": "2020-03-27T08:12:35Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/ProcessorMediator.java", "diffHunk": "@@ -234,44 +234,92 @@ private void processMethodReturningAPublisherOfPayloadsAndConsumingPayloads() {\n     private void processMethodReturningIndividualMessageAndConsumingIndividualItem() {\n         // Item can be message or payload\n         if (configuration.consumption() == MediatorConfiguration.Consumption.PAYLOAD) {\n-            this.processor = ReactiveStreams.<Message> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message) invoke(input.getPayload()))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input.getPayload()))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message) result))\n+                        .buildRs();\n+            } else {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .map(input -> (Message) invoke(input.getPayload()))\n+                        .buildRs();\n+            }\n         } else {\n-            this.processor = ReactiveStreams.<Message> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message) invoke(input))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message) result))", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NTE4Ng==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399095186", "bodyText": "POST_PROCESSING acknowledgment is not handled correctly", "author": "cescoffier", "createdAt": "2020-03-27T08:12:40Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/ProcessorMediator.java", "diffHunk": "@@ -234,44 +234,92 @@ private void processMethodReturningAPublisherOfPayloadsAndConsumingPayloads() {\n     private void processMethodReturningIndividualMessageAndConsumingIndividualItem() {\n         // Item can be message or payload\n         if (configuration.consumption() == MediatorConfiguration.Consumption.PAYLOAD) {\n-            this.processor = ReactiveStreams.<Message> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message) invoke(input.getPayload()))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input.getPayload()))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message) result))\n+                        .buildRs();\n+            } else {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .map(input -> (Message) invoke(input.getPayload()))\n+                        .buildRs();\n+            }\n         } else {\n-            this.processor = ReactiveStreams.<Message> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message) invoke(input))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message) result))\n+                        .buildRs();\n+            } else {\n+                this.processor = ReactiveStreams.<Message> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .map(input -> (Message) invoke(input))", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NjcwOA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399096708", "bodyText": "I would remove the @Incomings", "author": "cescoffier", "createdAt": "2020-03-27T08:16:08Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/WorkerPoolRegistry.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.enterprise.inject.spi.AnnotatedMethod;\n+import javax.enterprise.inject.spi.AnnotatedType;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+import io.smallrye.reactive.messaging.annotations.Incomings;\n+import io.smallrye.reactive.messaging.helpers.Validation;\n+import io.vertx.core.Handler;\n+import io.vertx.mutiny.core.Promise;\n+import io.vertx.mutiny.core.WorkerExecutor;\n+\n+@ApplicationScoped\n+public class WorkerPoolRegistry {\n+    private static final String WORKER_CONFIG_PREFIX = \"smallrye.messaging.worker\";\n+    private static final String WORKER_CONCURRENCY = \"max-concurrency\";\n+\n+    @Inject\n+    private ExecutionHolder executionHolder;\n+\n+    @Inject\n+    private Instance<Config> configInstance;\n+\n+    private Map<String, Integer> workerDefinitions = new HashMap<>();\n+    private Map<String, WorkerExecutor> workerExecutors = new ConcurrentHashMap<>();\n+\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(100) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        if (!workerExecutors.isEmpty()) {\n+            for (WorkerExecutor executor : workerExecutors.values()) {\n+                executor.close();\n+            }\n+        }\n+    }\n+\n+    public <T> Uni<T> executeWork(Handler<Promise<T>> blockingCodeHandler, String workerName, boolean ordered) {\n+        Objects.requireNonNull(blockingCodeHandler, \"Code to execute not provided\");\n+\n+        if (workerName == null) {\n+            return executionHolder.vertx().executeBlocking(blockingCodeHandler, ordered);\n+        } else {\n+            return getWorker(workerName).executeBlocking(blockingCodeHandler, ordered);\n+        }\n+    }\n+\n+    private WorkerExecutor getWorker(String workerName) {\n+        Objects.requireNonNull(workerName, \"Worker Name not specified\");\n+\n+        if (workerExecutors.containsKey(workerName)) {\n+            return workerExecutors.get(workerName);\n+        }\n+        if (workerDefinitions.containsKey(workerName)) {\n+            WorkerExecutor executor = executionHolder.vertx().createSharedWorkerExecutor(workerName,\n+                    workerDefinitions.get(workerName));\n+            if (executor != null) {\n+                workerExecutors.put(workerName, executor);\n+                return executor;\n+            } else {\n+                throw new RuntimeException(\"Failed to create Worker for \" + workerName);\n+            }\n+        }\n+\n+        // Shouldn't get here\n+        throw new IllegalArgumentException(\"@Blocking referred to invalid worker name.\");\n+    }\n+\n+    public <T> void analyzeWorker(AnnotatedType<T> annotatedType) {\n+        Objects.requireNonNull(annotatedType, \"AnnotatedType was empty\");\n+\n+        Set<AnnotatedMethod<? super T>> methods = annotatedType.getMethods();\n+\n+        methods.stream()\n+                .filter(m -> m.isAnnotationPresent(Blocking.class))\n+                .forEach(m -> addWorker(m.getJavaMember()));\n+    }\n+\n+    private void addWorker(Method method) {\n+        Objects.requireNonNull(method, \"Method was empty\");\n+\n+        Blocking blocking = method.getAnnotation(Blocking.class);\n+\n+        // Validate @Blocking is used in conjunction with @Incomings, @Incoming, or @Outgoing\n+        if (!(method.isAnnotationPresent(Incomings.class) || method.isAnnotationPresent(Incoming.class)\n+                || method.isAnnotationPresent(Outgoing.class))) {\n+            throw getBlockingError(method, \"no @Incomings, @Incoming, or @Outgoing present\");", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NzEwNw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399097107", "bodyText": "Maybe a log message (info) indicating the that the worker pool has been created with concurrency x", "author": "cescoffier", "createdAt": "2020-03-27T08:16:59Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/WorkerPoolRegistry.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.enterprise.inject.spi.AnnotatedMethod;\n+import javax.enterprise.inject.spi.AnnotatedType;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+import io.smallrye.reactive.messaging.annotations.Incomings;\n+import io.smallrye.reactive.messaging.helpers.Validation;\n+import io.vertx.core.Handler;\n+import io.vertx.mutiny.core.Promise;\n+import io.vertx.mutiny.core.WorkerExecutor;\n+\n+@ApplicationScoped\n+public class WorkerPoolRegistry {\n+    private static final String WORKER_CONFIG_PREFIX = \"smallrye.messaging.worker\";\n+    private static final String WORKER_CONCURRENCY = \"max-concurrency\";\n+\n+    @Inject\n+    private ExecutionHolder executionHolder;\n+\n+    @Inject\n+    private Instance<Config> configInstance;\n+\n+    private Map<String, Integer> workerDefinitions = new HashMap<>();\n+    private Map<String, WorkerExecutor> workerExecutors = new ConcurrentHashMap<>();\n+\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(100) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        if (!workerExecutors.isEmpty()) {\n+            for (WorkerExecutor executor : workerExecutors.values()) {\n+                executor.close();\n+            }\n+        }\n+    }\n+\n+    public <T> Uni<T> executeWork(Handler<Promise<T>> blockingCodeHandler, String workerName, boolean ordered) {\n+        Objects.requireNonNull(blockingCodeHandler, \"Code to execute not provided\");\n+\n+        if (workerName == null) {\n+            return executionHolder.vertx().executeBlocking(blockingCodeHandler, ordered);\n+        } else {\n+            return getWorker(workerName).executeBlocking(blockingCodeHandler, ordered);\n+        }\n+    }\n+\n+    private WorkerExecutor getWorker(String workerName) {\n+        Objects.requireNonNull(workerName, \"Worker Name not specified\");\n+\n+        if (workerExecutors.containsKey(workerName)) {\n+            return workerExecutors.get(workerName);\n+        }\n+        if (workerDefinitions.containsKey(workerName)) {\n+            WorkerExecutor executor = executionHolder.vertx().createSharedWorkerExecutor(workerName,\n+                    workerDefinitions.get(workerName));\n+            if (executor != null) {\n+                workerExecutors.put(workerName, executor);\n+                return executor;\n+            } else {\n+                throw new RuntimeException(\"Failed to create Worker for \" + workerName);\n+            }\n+        }\n+\n+        // Shouldn't get here\n+        throw new IllegalArgumentException(\"@Blocking referred to invalid worker name.\");\n+    }\n+\n+    public <T> void analyzeWorker(AnnotatedType<T> annotatedType) {\n+        Objects.requireNonNull(annotatedType, \"AnnotatedType was empty\");\n+\n+        Set<AnnotatedMethod<? super T>> methods = annotatedType.getMethods();\n+\n+        methods.stream()\n+                .filter(m -> m.isAnnotationPresent(Blocking.class))\n+                .forEach(m -> addWorker(m.getJavaMember()));\n+    }\n+\n+    private void addWorker(Method method) {\n+        Objects.requireNonNull(method, \"Method was empty\");\n+\n+        Blocking blocking = method.getAnnotation(Blocking.class);\n+\n+        // Validate @Blocking is used in conjunction with @Incomings, @Incoming, or @Outgoing\n+        if (!(method.isAnnotationPresent(Incomings.class) || method.isAnnotationPresent(Incoming.class)\n+                || method.isAnnotationPresent(Outgoing.class))) {\n+            throw getBlockingError(method, \"no @Incomings, @Incoming, or @Outgoing present\");\n+        }\n+\n+        if (!blocking.value().equals(Blocking.NO_VALUE)) {\n+            // Validate @Blocking value is not empty, if set\n+            if (Validation.isBlank(blocking.value())) {\n+                throw getBlockingError(method, \"value is blank or null\");\n+            }\n+\n+            // Validate @Blocking worker pool has configuration to define concurrency\n+            String workerConfigKey = WORKER_CONFIG_PREFIX + \".\" + blocking.value() + \".\" + WORKER_CONCURRENCY;\n+            Optional<Integer> concurrency = configInstance.get().getOptionalValue(workerConfigKey, Integer.class);\n+            if (!concurrency.isPresent()) {\n+                throw getBlockingError(method, workerConfigKey + \" was not defined\");\n+            }\n+\n+            workerDefinitions.put(blocking.value(), concurrency.get());", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NzM2MA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399097360", "bodyText": "Don't we have this method somewhere else?", "author": "cescoffier", "createdAt": "2020-03-27T08:17:30Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/WorkerPoolRegistry.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package io.smallrye.reactive.messaging.connectors;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.event.Reception;\n+import javax.enterprise.inject.Instance;\n+import javax.enterprise.inject.spi.AnnotatedMethod;\n+import javax.enterprise.inject.spi.AnnotatedType;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+import io.smallrye.reactive.messaging.annotations.Incomings;\n+import io.smallrye.reactive.messaging.helpers.Validation;\n+import io.vertx.core.Handler;\n+import io.vertx.mutiny.core.Promise;\n+import io.vertx.mutiny.core.WorkerExecutor;\n+\n+@ApplicationScoped\n+public class WorkerPoolRegistry {\n+    private static final String WORKER_CONFIG_PREFIX = \"smallrye.messaging.worker\";\n+    private static final String WORKER_CONCURRENCY = \"max-concurrency\";\n+\n+    @Inject\n+    private ExecutionHolder executionHolder;\n+\n+    @Inject\n+    private Instance<Config> configInstance;\n+\n+    private Map<String, Integer> workerDefinitions = new HashMap<>();\n+    private Map<String, WorkerExecutor> workerExecutors = new ConcurrentHashMap<>();\n+\n+    public void terminate(\n+            @Observes(notifyObserver = Reception.IF_EXISTS) @Priority(100) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        if (!workerExecutors.isEmpty()) {\n+            for (WorkerExecutor executor : workerExecutors.values()) {\n+                executor.close();\n+            }\n+        }\n+    }\n+\n+    public <T> Uni<T> executeWork(Handler<Promise<T>> blockingCodeHandler, String workerName, boolean ordered) {\n+        Objects.requireNonNull(blockingCodeHandler, \"Code to execute not provided\");\n+\n+        if (workerName == null) {\n+            return executionHolder.vertx().executeBlocking(blockingCodeHandler, ordered);\n+        } else {\n+            return getWorker(workerName).executeBlocking(blockingCodeHandler, ordered);\n+        }\n+    }\n+\n+    private WorkerExecutor getWorker(String workerName) {\n+        Objects.requireNonNull(workerName, \"Worker Name not specified\");\n+\n+        if (workerExecutors.containsKey(workerName)) {\n+            return workerExecutors.get(workerName);\n+        }\n+        if (workerDefinitions.containsKey(workerName)) {\n+            WorkerExecutor executor = executionHolder.vertx().createSharedWorkerExecutor(workerName,\n+                    workerDefinitions.get(workerName));\n+            if (executor != null) {\n+                workerExecutors.put(workerName, executor);\n+                return executor;\n+            } else {\n+                throw new RuntimeException(\"Failed to create Worker for \" + workerName);\n+            }\n+        }\n+\n+        // Shouldn't get here\n+        throw new IllegalArgumentException(\"@Blocking referred to invalid worker name.\");\n+    }\n+\n+    public <T> void analyzeWorker(AnnotatedType<T> annotatedType) {\n+        Objects.requireNonNull(annotatedType, \"AnnotatedType was empty\");\n+\n+        Set<AnnotatedMethod<? super T>> methods = annotatedType.getMethods();\n+\n+        methods.stream()\n+                .filter(m -> m.isAnnotationPresent(Blocking.class))\n+                .forEach(m -> addWorker(m.getJavaMember()));\n+    }\n+\n+    private void addWorker(Method method) {\n+        Objects.requireNonNull(method, \"Method was empty\");\n+\n+        Blocking blocking = method.getAnnotation(Blocking.class);\n+\n+        // Validate @Blocking is used in conjunction with @Incomings, @Incoming, or @Outgoing\n+        if (!(method.isAnnotationPresent(Incomings.class) || method.isAnnotationPresent(Incoming.class)\n+                || method.isAnnotationPresent(Outgoing.class))) {\n+            throw getBlockingError(method, \"no @Incomings, @Incoming, or @Outgoing present\");\n+        }\n+\n+        if (!blocking.value().equals(Blocking.NO_VALUE)) {\n+            // Validate @Blocking value is not empty, if set\n+            if (Validation.isBlank(blocking.value())) {\n+                throw getBlockingError(method, \"value is blank or null\");\n+            }\n+\n+            // Validate @Blocking worker pool has configuration to define concurrency\n+            String workerConfigKey = WORKER_CONFIG_PREFIX + \".\" + blocking.value() + \".\" + WORKER_CONCURRENCY;\n+            Optional<Integer> concurrency = configInstance.get().getOptionalValue(workerConfigKey, Integer.class);\n+            if (!concurrency.isPresent()) {\n+                throw getBlockingError(method, workerConfigKey + \" was not defined\");\n+            }\n+\n+            workerDefinitions.put(blocking.value(), concurrency.get());\n+        }\n+    }\n+\n+    private IllegalArgumentException getBlockingError(Method method, String message) {\n+        return new IllegalArgumentException(", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMxNjAxNQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399316015", "bodyText": "Both these methods are also in MediatorConfigurationSupport.\nSimilar methods for Incoming and Outgoing are also duplicated between that class and DefaultMediatorConfiguration", "author": "kenfinnigan", "createdAt": "2020-03-27T14:44:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5NzM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwMDkzNw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399100937", "bodyText": "Need to also test when the method returns an Uni", "author": "cescoffier", "createdAt": "2020-03-27T08:25:09Z", "path": "smallrye-reactive-messaging-provider/src/test/java/io/smallrye/reactive/messaging/blocking/InvalidBlockingProcessorShapeTest.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package io.smallrye.reactive.messaging.blocking;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.spi.DeploymentException;\n+\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.eclipse.microprofile.reactive.streams.operators.ProcessorBuilder;\n+import org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder;\n+import org.eclipse.microprofile.reactive.streams.operators.ReactiveStreams;\n+import org.junit.Test;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.Flowable;\n+import io.smallrye.reactive.messaging.WeldTestBaseWithoutTails;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+\n+public class InvalidBlockingProcessorShapeTest extends WeldTestBaseWithoutTails {\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingACompletionStageOfMessage() {\n+        addBeanClass(BeanProducingACompletionStageOfMessage.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingACompletionStageOfMessage {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public CompletionStage<Message<String>> process(Message<Integer> value) {\n+            return CompletableFuture.supplyAsync(() -> Integer.toString(value.getPayload() + 1))\n+                    .thenApply(Message::of);\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwMTIzNA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399101234", "bodyText": "I would add specific tests for Multi.", "author": "cescoffier", "createdAt": "2020-03-27T08:25:45Z", "path": "smallrye-reactive-messaging-provider/src/test/java/io/smallrye/reactive/messaging/blocking/InvalidBlockingProcessorShapeTest.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package io.smallrye.reactive.messaging.blocking;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.spi.DeploymentException;\n+\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.eclipse.microprofile.reactive.streams.operators.ProcessorBuilder;\n+import org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder;\n+import org.eclipse.microprofile.reactive.streams.operators.ReactiveStreams;\n+import org.junit.Test;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.Flowable;\n+import io.smallrye.reactive.messaging.WeldTestBaseWithoutTails;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+\n+public class InvalidBlockingProcessorShapeTest extends WeldTestBaseWithoutTails {\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingACompletionStageOfMessage() {\n+        addBeanClass(BeanProducingACompletionStageOfMessage.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingACompletionStageOfMessage {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public CompletionStage<Message<String>> process(Message<Integer> value) {\n+            return CompletableFuture.supplyAsync(() -> Integer.toString(value.getPayload() + 1))\n+                    .thenApply(Message::of);\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingACompletionStageOfPayloads() {\n+        addBeanClass(BeanProducingACompletionStage.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingACompletionStage {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public CompletionStage<String> process(int value) {\n+            return CompletableFuture.supplyAsync(() -> Integer.toString(value + 1));\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingACompletableFutureOfMessage() {\n+        addBeanClass(BeanProducingACompletableFutureOfMessage.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingACompletableFutureOfMessage {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public CompletionStage<Message<String>> process(Message<Integer> value) {\n+            return CompletableFuture.supplyAsync(() -> Integer.toString(value.getPayload() + 1))\n+                    .thenApply(Message::of);\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingACompletableFutureOfPayloads() {\n+        addBeanClass(BeanProducingACompletableFuture.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingACompletableFuture {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public CompletableFuture<String> process(int value) {\n+            return CompletableFuture.supplyAsync(() -> Integer.toString(value + 1));\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingAProcessorOfMessages() {\n+        addBeanClass(BeanProducingAProcessorOfMessages.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingAProcessorOfMessages {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public Processor<Message<Integer>, Message<String>> process() {\n+            return ReactiveStreams.<Message<Integer>> builder()\n+                    .map(Message::getPayload)\n+                    .map(i -> i + 1)\n+                    .flatMapRsPublisher(i -> Flowable.just(i, i))\n+                    .map(i -> Integer.toString(i))\n+                    .map(Message::of)\n+                    .buildRs();\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingAProcessorBuilderOfMessages() {\n+        addBeanClass(BeanProducingAProcessorBuilderOfMessages.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingAProcessorBuilderOfMessages {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public ProcessorBuilder<Message<Integer>, Message<String>> process() {\n+            return ReactiveStreams.<Message<Integer>> builder()\n+                    .map(Message::getPayload)\n+                    .map(i -> i + 1)\n+                    .flatMapRsPublisher(i -> Flowable.just(i, i))\n+                    .map(i -> Integer.toString(i))\n+                    .map(Message::of);\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingAProcessorOfPayloads() {\n+        addBeanClass(BeanProducingAProcessorOfPayloads.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingAProcessorOfPayloads {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public Processor<Integer, String> process() {\n+            return ReactiveStreams.<Integer> builder()\n+                    .map(i -> i + 1)\n+                    .flatMapRsPublisher(i -> Flowable.just(i, i))\n+                    .map(i -> Integer.toString(i))\n+                    .buildRs();\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingAProcessorBuilderOfPayloads() {\n+        addBeanClass(BeanProducingAProcessorBuilderOfPayloads.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingAProcessorBuilderOfPayloads {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public ProcessorBuilder<Integer, String> process() {\n+            return ReactiveStreams.<Integer> builder()\n+                    .map(i -> i + 1)\n+                    .flatMapRsPublisher(i -> Flowable.just(i, i))\n+                    .map(i -> Integer.toString(i));\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingAPublisherOfMessagesAndConsumingIndividualMessage() {\n+        addBeanClass(BeanProducingAPublisherOfMessagesAndConsumingIndividualMessage.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingAPublisherOfMessagesAndConsumingIndividualMessage {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public Publisher<Message<String>> process(Message<Integer> message) {\n+            return ReactiveStreams.of(message)\n+                    .map(Message::getPayload)\n+                    .map(i -> i + 1)\n+                    .flatMapRsPublisher(i -> Flowable.just(i, i))\n+                    .map(i -> Integer.toString(i))\n+                    .map(Message::of)\n+                    .buildRs();\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingAPublisherOfPayloadsAndConsumingIndividualPayload() {\n+        addBeanClass(BeanProducingAPublisherOfPayloadsAndConsumingIndividualPayload.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingAPublisherOfPayloadsAndConsumingIndividualPayload {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public Publisher<String> process(Integer payload) {\n+            return ReactiveStreams.of(payload)\n+                    .map(i -> i + 1)\n+                    .flatMapRsPublisher(i -> Flowable.just(i, i))\n+                    .map(i -> Integer.toString(i))\n+                    .buildRs();\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingAPublisherBuilderOfPayloadsAndConsumingIndividualPayload() {\n+        addBeanClass(BeanProducingAPublisherBuilderOfPayloadsAndConsumingIndividualPayload.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingAPublisherBuilderOfPayloadsAndConsumingIndividualPayload {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public PublisherBuilder<String> process(Integer payload) {\n+            return ReactiveStreams.of(payload)\n+                    .map(i -> i + 1)\n+                    .flatMapRsPublisher(i -> Flowable.just(i, i))\n+                    .map(i -> Integer.toString(i));\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingAPublisherBuilderOfMessagesAndConsumingIndividualMessage() {\n+        addBeanClass(BeanProducingAPublisherBuilderOfMessagesAndConsumingIndividualMessage.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingAPublisherBuilderOfMessagesAndConsumingIndividualMessage {\n+        @Blocking\n+        @Incoming(\"count\")\n+        @Outgoing(\"sink\")\n+        public PublisherBuilder<Message<String>> process(Message<Integer> message) {", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwMTYyNg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399101626", "bodyText": "Would need tests with Unis", "author": "cescoffier", "createdAt": "2020-03-27T08:26:31Z", "path": "smallrye-reactive-messaging-provider/src/test/java/io/smallrye/reactive/messaging/blocking/InvalidBlockingPublisherShapeTest.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package io.smallrye.reactive.messaging.blocking;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.spi.DeploymentException;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder;\n+import org.eclipse.microprofile.reactive.streams.operators.ReactiveStreams;\n+import org.junit.Test;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.Flowable;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.reactive.messaging.WeldTestBaseWithoutTails;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+\n+public class InvalidBlockingPublisherShapeTest extends WeldTestBaseWithoutTails {\n+    @Test(expected = DeploymentException.class)\n+    public void testPublisherOfMessages() {\n+        addBeanClass(BeanReturningAPublisherOfMessages.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanReturningAPublisherOfMessages {\n+        @Blocking\n+        @Outgoing(\"sink\")\n+        public Publisher<Message<String>> create() {\n+            return ReactiveStreams.of(\"a\", \"b\", \"c\").map(Message::of).buildRs();\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testPublisherOfMessagesWithMulti() {\n+        addBeanClass(BeanProducingMessagesAsMulti.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingMessagesAsMulti {\n+        @Blocking\n+        @Outgoing(\"sink\")\n+        public Multi<Message<String>> publisher() {\n+            return Multi.createFrom().range(1, 11).flatMap(i -> Flowable.just(i, i)).map(i -> Integer.toString(i))\n+                    .map(Message::of);\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testProducingPayloadsAsMulti() {\n+        addBeanClass(BeanProducingPayloadAsMulti.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingPayloadAsMulti {\n+        @Blocking\n+        @Outgoing(\"sink\")\n+        public Multi<String> publisher() {\n+            return Multi.createFrom().range(1, 11).flatMap(i -> Flowable.just(i, i)).map(i -> Integer.toString(i));\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testProducingPayloadsAsPublisher() {\n+        addBeanClass(BeanProducingPayloadAsPublisher.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingPayloadAsPublisher {\n+        @Blocking\n+        @Outgoing(\"sink\")\n+        public Publisher<String> publisher() {\n+            return Flowable.range(1, 10).flatMap(i -> Flowable.just(i, i)).map(i -> Integer.toString(i));\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testProducingMessagesAsPublisherBuilder() {\n+        addBeanClass(BeanProducingMessagesAsPublisherBuilder.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingMessagesAsPublisherBuilder {\n+        @Blocking\n+        @Outgoing(\"sink\")\n+        public PublisherBuilder<Message<String>> publisher() {\n+            return ReactiveStreams.fromPublisher(Flowable.range(1, 10))\n+                    .flatMapRsPublisher(i -> Flowable.just(i, i))\n+                    .map(i -> Integer.toString(i))\n+                    .map(Message::of);\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testProducingPayloadAsPublisherBuilder() {\n+        addBeanClass(BeanProducingPayloadAsPublisherBuilder.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanProducingPayloadAsPublisherBuilder {\n+        @Blocking\n+        @Outgoing(\"sink\")\n+        public PublisherBuilder<String> publisher() {\n+            return ReactiveStreams.fromPublisher(Flowable.range(1, 10))\n+                    .flatMapRsPublisher(i -> Flowable.just(i, i))\n+                    .map(i -> Integer.toString(i));\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testProduceCompletionStageOfMessage() {\n+        addBeanClass(BeanReturningCompletionStageOfMessage.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanReturningCompletionStageOfMessage {\n+        private AtomicInteger count = new AtomicInteger();\n+        private ExecutorService executor = Executors.newSingleThreadExecutor();\n+\n+        @Blocking\n+        @Outgoing(\"infinite-producer\")\n+        public CompletionStage<Message<Integer>> create() {\n+            return CompletableFuture.supplyAsync(() -> Message.of(count.incrementAndGet()), executor);\n+        }\n+\n+        @PreDestroy\n+        public void cleanup() {\n+            executor.shutdown();\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testProduceCompletionStageOfPayload() {\n+        addBeanClass(BeanReturningCompletionStageOfPayload.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanReturningCompletionStageOfPayload {", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwMTk1NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399101954", "bodyText": "Need the same with Uni.", "author": "cescoffier", "createdAt": "2020-03-27T08:27:13Z", "path": "smallrye-reactive-messaging-provider/src/test/java/io/smallrye/reactive/messaging/blocking/InvalidBlockingSubscriberShapeTest.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package io.smallrye.reactive.messaging.blocking;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.spi.DeploymentException;\n+\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.streams.operators.ReactiveStreams;\n+import org.junit.Test;\n+import org.reactivestreams.Subscriber;\n+\n+import io.smallrye.reactive.messaging.WeldTestBaseWithoutTails;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+\n+public class InvalidBlockingSubscriberShapeTest extends WeldTestBaseWithoutTails {\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingASubscriberOfMessages() {\n+        addBeanClass(BeanReturningASubscriberOfMessages.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanReturningASubscriberOfMessages {\n+        private List<String> list = new ArrayList<>();\n+\n+        @Blocking\n+        @Incoming(\"count\")\n+        public Subscriber<Message<String>> create() {\n+            return ReactiveStreams.<Message<String>> builder().forEach(m -> list.add(m.getPayload()))\n+                    .build();\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testBeanProducingASubscriberOfPayloads() {\n+        addBeanClass(BeanReturningASubscriberOfPayloads.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanReturningASubscriberOfPayloads {\n+        private List<String> list = new ArrayList<>();\n+\n+        @Blocking\n+        @Incoming(\"count\")\n+        public Subscriber<String> create() {\n+            return ReactiveStreams.<String> builder().forEach(m -> list.add(m)).build();\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testThatWeCanProduceSubscriberOfMessage() {\n+        addBeanClass(BeanReturningASubscriberOfMessagesButDiscarding.class);\n+        initialize();\n+    }\n+\n+    @ApplicationScoped\n+    public static class BeanReturningASubscriberOfMessagesButDiscarding {\n+        @Blocking\n+        @Incoming(\"subscriber\")\n+        public Subscriber<Message<String>> create() {\n+            return ReactiveStreams.<Message<String>> builder()\n+                    .ignore().build();\n+        }\n+    }\n+\n+    @Test(expected = DeploymentException.class)\n+    public void testThatWeCanConsumeMessagesFromAMethodReturningACompletionStage() {", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwMjM2Nw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399102367", "bodyText": "I would actually do something really blocking to check the concurrency.", "author": "cescoffier", "createdAt": "2020-03-27T08:28:00Z", "path": "smallrye-reactive-messaging-provider/src/test/java/io/smallrye/reactive/messaging/blocking/beans/BeanReturningPayloads.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package io.smallrye.reactive.messaging.blocking.beans;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+\n+@ApplicationScoped\n+public class BeanReturningPayloads {\n+    private AtomicInteger count = new AtomicInteger();\n+    private List<String> threads = new CopyOnWriteArrayList<>();\n+\n+    @Blocking\n+    @Outgoing(\"infinite-producer\")\n+    public int create() {\n+        threads.add(Thread.currentThread().getName());\n+        return count.incrementAndGet();", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwMzgyNA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399103824", "bodyText": "With the priority thingy this should not be required anymore.", "author": "cescoffier", "createdAt": "2020-03-27T08:31:02Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -98,7 +98,7 @@ public KafkaSource(Vertx vertx, Config config, String servers) {\n \n     public void closeQuietly() {\n         try {\n-            this.consumer.closeAndAwait();\n+            this.consumer.closeAndForget();", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI0MDU1Ng==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399240556", "bodyText": "Do you mean revert to the original code or remove?", "author": "kenfinnigan", "createdAt": "2020-03-27T12:50:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwMzgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNjQzNg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r402406436", "bodyText": "yes. closeAndAwait();", "author": "cescoffier", "createdAt": "2020-04-02T15:30:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwMzgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwODM0OQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r402408349", "bodyText": "Should be the right code now", "author": "kenfinnigan", "createdAt": "2020-04-02T15:33:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwMzgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwNDEzOA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399104138", "bodyText": "With the @priority, this should not be required anymore.", "author": "cescoffier", "createdAt": "2020-03-27T08:31:41Z", "path": "smallrye-reactive-messaging-mqtt-server/src/main/java/io/smallrye/reactive/messaging/mqtt/server/MqttServerSource.java", "diffHunk": "@@ -144,11 +144,7 @@ private static MqttServerOptions mqttServerOptions(Config config) {\n     }\n \n     synchronized void close() {\n-        mqttServer.close()\n-                .onFailure().invoke(t -> logger.warn(\"An exception has been caught while closing the MQTT server\", t))\n-                .onItem().invoke(x -> logger.debug(\"MQTT server closed\"))\n-                .onFailure().recoverWithItem((Void) null)\n-                .await().indefinitely();\n+        mqttServer.closeAndForget();", "originalCommit": "3097a3edb97e4974281cbfb363d3824f4359ee59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI0MDgxNA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r399240814", "bodyText": "Same question here, remove the close or go back to original code?", "author": "kenfinnigan", "createdAt": "2020-03-27T12:50:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwNDEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNjcwNA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r402406704", "bodyText": "closeAndAwait", "author": "cescoffier", "createdAt": "2020-04-02T15:31:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwNDEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwODI2MA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r402408260", "bodyText": "Should be the right code now", "author": "kenfinnigan", "createdAt": "2020-04-02T15:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwNDEzOA=="}], "type": "inlineReview"}, {"oid": "f9d16f3f3ec06b2aac128f20cf29c3f0d21f94ad", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/f9d16f3f3ec06b2aac128f20cf29c3f0d21f94ad", "message": "Fixes #79 - Implement @Blocking support", "committedDate": "2020-03-30T17:37:27Z", "type": "commit"}, {"oid": "491b1eb5fccf0756ae1b75b9985eff88f5066d26", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/491b1eb5fccf0756ae1b75b9985eff88f5066d26", "message": "Fix shutdown sequence order and tests", "committedDate": "2020-03-30T17:54:02Z", "type": "commit"}, {"oid": "5cd1087cdab18d4368d5ababe870bb19e2b1c68c", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/5cd1087cdab18d4368d5ababe870bb19e2b1c68c", "message": "Add tests for Processors and Publishers, and fix issues", "committedDate": "2020-03-30T17:55:34Z", "type": "commit"}, {"oid": "557533db96955d1cd81251f283e49aec73605a88", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/557533db96955d1cd81251f283e49aec73605a88", "message": "Updates based on PR feedback/comments", "committedDate": "2020-03-30T17:57:13Z", "type": "commit"}, {"oid": "1eac422c4d903c33cb24c8c95a8194139102f936", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/1eac422c4d903c33cb24c8c95a8194139102f936", "message": "Minor updates based on the recently merged cleanup PR", "committedDate": "2020-03-30T18:17:07Z", "type": "commit"}, {"oid": "1eac422c4d903c33cb24c8c95a8194139102f936", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/1eac422c4d903c33cb24c8c95a8194139102f936", "message": "Minor updates based on the recently merged cleanup PR", "committedDate": "2020-03-30T18:17:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2NTg4Ng==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401865886", "bodyText": "Why the  close has been removing?", "author": "cescoffier", "createdAt": "2020-04-01T19:44:54Z", "path": "smallrye-reactive-messaging-amqp/src/test/java/io/smallrye/reactive/messaging/amqp/AmqpSinkTest.java", "diffHunk": "@@ -33,7 +33,6 @@\n     @After\n     public void cleanup() {\n         if (provider != null) {", "originalCommit": "1eac422c4d903c33cb24c8c95a8194139102f936", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI1NzUyOA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r402257528", "bodyText": "The method became terminate -> https://github.com/smallrye/smallrye-reactive-messaging/pull/467/files#diff-3a4f486c21639cc4d8651925bb53e79dL338", "author": "kenfinnigan", "createdAt": "2020-04-02T11:59:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2NTg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2NjE1OA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401866158", "bodyText": "Why has this been removed?", "author": "cescoffier", "createdAt": "2020-04-01T19:45:26Z", "path": "smallrye-reactive-messaging-amqp/src/test/java/io/smallrye/reactive/messaging/amqp/AmqpSourceTest.java", "diffHunk": "@@ -47,7 +48,6 @@\n     @After\n     public void cleanup() {\n         if (provider != null) {\n-            provider.close();", "originalCommit": "1eac422c4d903c33cb24c8c95a8194139102f936", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3NTYxNQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401875615", "bodyText": "We must check that the returned Uni is not null.", "author": "cescoffier", "createdAt": "2020-04-01T20:02:24Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/ProcessorMediator.java", "diffHunk": "@@ -236,44 +245,92 @@ private void processMethodReturningAPublisherOfPayloadsAndConsumingPayloads() {\n     private void processMethodReturningIndividualMessageAndConsumingIndividualItem() {\n         // Item can be message or payload\n         if (configuration.consumption() == MediatorConfiguration.Consumption.PAYLOAD) {\n-            this.processor = ReactiveStreams.<Message<?>> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message<?>) invoke(input.getPayload()))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message<?>> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message<?>> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input.getPayload()))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message<?>) result))\n+                        .buildRs();\n+            } else {\n+                this.processor = ReactiveStreams.<Message<?>> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .map(input -> (Message<?>) invoke(input.getPayload()))\n+                        .buildRs();\n+            }\n         } else {\n-            this.processor = ReactiveStreams.<Message<?>> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message<?>) invoke(input))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message<?>> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message<?>> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input))", "originalCommit": "1eac422c4d903c33cb24c8c95a8194139102f936", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3NTkwNQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401875905", "bodyText": "we need to verify that result is not null", "author": "cescoffier", "createdAt": "2020-04-01T20:02:57Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/ProcessorMediator.java", "diffHunk": "@@ -236,44 +245,92 @@ private void processMethodReturningAPublisherOfPayloadsAndConsumingPayloads() {\n     private void processMethodReturningIndividualMessageAndConsumingIndividualItem() {\n         // Item can be message or payload\n         if (configuration.consumption() == MediatorConfiguration.Consumption.PAYLOAD) {\n-            this.processor = ReactiveStreams.<Message<?>> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message<?>) invoke(input.getPayload()))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message<?>> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message<?>> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input.getPayload()))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message<?>) result))\n+                        .buildRs();\n+            } else {\n+                this.processor = ReactiveStreams.<Message<?>> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .map(input -> (Message<?>) invoke(input.getPayload()))\n+                        .buildRs();\n+            }\n         } else {\n-            this.processor = ReactiveStreams.<Message<?>> builder()\n-                    .flatMapCompletionStage(managePreProcessingAck())\n-                    .map(input -> (Message<?>) invoke(input))\n-                    .buildRs();\n+            if (configuration.isBlocking()) {\n+                this.processor = ReactiveStreams.<Message<?>> builder()\n+                        .flatMapCompletionStage(managePreProcessingAck())\n+                        .<Message<?>> flatMapCompletionStage(input -> ((Uni<?>) invokeBlocking(input))\n+                                .subscribeAsCompletionStage()\n+                                .thenApply(result -> (Message<?>) result))", "originalCommit": "1eac422c4d903c33cb24c8c95a8194139102f936", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1ODkwNg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401958906", "bodyText": "For the value, is . allowed as part of the name?", "author": "Emily-Jiang", "createdAt": "2020-04-01T22:59:58Z", "path": "api/src/main/java/io/smallrye/reactive/messaging/annotations/Blocking.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package io.smallrye.reactive.messaging.annotations;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Identifies that a particular method performs blocking operations,\n+ * and as such should be executed on separate worker.\n+ *\n+ * When possible, the initial threads execution context is _restored_\n+ * once the blocking operation has completed.\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(METHOD)\n+public @interface Blocking {\n+    String DEFAULT_WORKER_POOL = \"<no-value>\";\n+\n+    /**\n+     * Indicates the name of the worker pool to use for execution.\n+     * By default all executions will be performed on the default worker pool.\n+     *\n+     * The maximum concurrency of a custom worker pool can be set with the following configuration key:\n+     * <code>smallrye.messaging.worker.{pool-name}.max-concurrency</code>\n+     *\n+     * @return custom worker pool name for blocking execution.\n+     */\n+    String value() default DEFAULT_WORKER_POOL;", "originalCommit": "1eac422c4d903c33cb24c8c95a8194139102f936", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NTI2Ng==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401975266", "bodyText": "Probably not, just like other configs like topic name", "author": "kenfinnigan", "createdAt": "2020-04-01T23:51:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1ODkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3ODQ0OQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r401978449", "bodyText": "I was wrong, the way it's currently coded it can be any value", "author": "kenfinnigan", "createdAt": "2020-04-02T00:01:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1ODkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2NDUzNA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r402264534", "bodyText": "I took a look at vertx.createSharedWorkerExecutor(). It seems there is no restriction on the name as far as javadoc is concerned.", "author": "Emily-Jiang", "createdAt": "2020-04-02T12:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1ODkwNg=="}], "type": "inlineReview"}, {"oid": "55b4c84d73d1ba592cfed652393d30bf84d470f3", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/55b4c84d73d1ba592cfed652393d30bf84d470f3", "message": "Updates based on feedback", "committedDate": "2020-04-02T12:52:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2NzAxNg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r402867016", "bodyText": "I think the term \"initial threads\" could be a bit confusing for some non-English speakers as the apostrophe is missing and the words are close to \"the initiating thread's context is propogated\". I think it would be better as:\n\"When possible, the context on the worker thread used to execute the method is restored to the context present on the worker thread prior to the method being executed\"    (if you want that meaning).\nOr \"When possible, the context present on the worker thread when the blocking method is run is set to match the context used to run non-blocking methods.\" (if you want that meaning)....and apologies for \"bike shedding\" - as this is such a small point, it is not necessary to change prior to merge.", "author": "hutchig", "createdAt": "2020-04-03T09:10:26Z", "path": "api/src/main/java/io/smallrye/reactive/messaging/annotations/Blocking.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package io.smallrye.reactive.messaging.annotations;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Identifies that a particular method performs blocking operations,\n+ * and as such should be executed on separate worker.\n+ *\n+ * When possible, the initial threads execution context is _restored_", "originalCommit": "55b4c84d73d1ba592cfed652393d30bf84d470f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk2NjA4OA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r402966088", "bodyText": "What about changing \"initial\" to \"triggering\"?", "author": "kenfinnigan", "createdAt": "2020-04-03T12:22:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2NzAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzAwMTg0Nw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/467#discussion_r403001847", "bodyText": "\"When supported, the caller execution context is captured and restored after the execution of the blocking method. This means that the rest of the pipeline would run in the same context (same thread). Typically, this is the case if the caller is using a Vert.x Context (event loop or worker).\"", "author": "cescoffier", "createdAt": "2020-04-03T13:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2NzAxNg=="}], "type": "inlineReview"}, {"oid": "2b1e52c164f748ec6f9f8ef5eba26b42d1484671", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/2b1e52c164f748ec6f9f8ef5eba26b42d1484671", "message": "Update based on feedback", "committedDate": "2020-04-03T13:26:54Z", "type": "commit"}]}