{"pr_number": 659, "pr_title": "Initial OpenTelemetry tracing for Kafka", "pr_createdAt": "2020-07-16T18:52:10Z", "pr_url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwNTQ2NQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456005465", "bodyText": "gRPC ? That's an unexpected dependency.", "author": "cescoffier", "createdAt": "2020-07-16T18:59:11Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "diffHunk": "@@ -7,21 +7,36 @@\n import org.apache.kafka.common.header.Headers;\n import org.eclipse.microprofile.reactive.messaging.Metadata;\n \n+import io.grpc.Context;", "originalCommit": "55e3a0d309094ab4df8b7d0debf8a55a18dee152", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwOTIzNQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456009235", "bodyText": "Yeah, OpenTelemetry using gRPC Context to pass things around.", "author": "kenfinnigan", "createdAt": "2020-07-16T19:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwNTQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI1MDY2Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456250662", "bodyText": "We need to investigate how we can mitigate this in Quarkus. Depending on quarkus-grpc might be a bit too much.", "author": "cescoffier", "createdAt": "2020-07-17T06:46:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwNTQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMDg1OA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476200858", "bodyText": "Any info about this?", "author": "cescoffier", "createdAt": "2020-08-25T06:14:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwNTQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMDI3OA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476410278", "bodyText": "It's only the grpc Context that's needed, not the entirety of grpc", "author": "kenfinnigan", "createdAt": "2020-08-25T12:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwNTQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI2NTU5NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456265594", "bodyText": "Is this synchronously executed on the same thread from where the message is produced?", "author": "pavolloffay", "createdAt": "2020-07-17T07:23:52Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {", "originalCommit": "55e3a0d309094ab4df8b7d0debf8a55a18dee152", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyNzk3Nw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456327977", "bodyText": "Yes, is it blocking?", "author": "cescoffier", "createdAt": "2020-07-17T09:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI2NTU5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1MTI0Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456451242", "bodyText": "It's done right before creating the Kafka ProducerRecord, and I don't believe it's blocking", "author": "kenfinnigan", "createdAt": "2020-07-17T13:44:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI2NTU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MDg2Nw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456270867", "bodyText": "is the partition important? Could it help to debug the problem?  Shall we add it as an attribute?", "author": "pavolloffay", "createdAt": "2020-07-17T07:35:08Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);", "originalCommit": "55e3a0d309094ab4df8b7d0debf8a55a18dee152", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyODI4Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456328282", "bodyText": "Partitions are important. They should be part of the trace (but optional)", "author": "cescoffier", "createdAt": "2020-07-17T09:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MDg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1MTg0NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456451844", "bodyText": "On the outgoing trace I couldn't see a way to get the partitiion", "author": "kenfinnigan", "createdAt": "2020-07-17T13:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MDg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwNzc1NQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r458207755", "bodyText": "I'm a numpty, the partition is set further down as an attribute", "author": "kenfinnigan", "createdAt": "2020-07-21T15:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MDg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MTg2NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456271864", "bodyText": "Set these attributes via SemanticAttributes class", "author": "pavolloffay", "createdAt": "2020-07-17T07:37:14Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -243,6 +248,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {\n+            TracingMetadata tracingMetadata = TracingMetadata.fromMessage(kafkaRecord).orElse(TracingMetadata.empty());\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(kafkaRecord.getTopic())\n+                    .setSpanKind(Span.Kind.CONSUMER);\n+\n+            // Handle possible parent span\n+            final SpanContext parentSpan = tracingMetadata.getPreviousSpanContext();\n+            if (parentSpan != null && parentSpan.isValid()) {\n+                spanBuilder.setParent(parentSpan);\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", kafkaRecord.getPartition());", "originalCommit": "55e3a0d309094ab4df8b7d0debf8a55a18dee152", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwODc2OA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r458208768", "bodyText": "Not released yet", "author": "kenfinnigan", "createdAt": "2020-07-21T15:57:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MTg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MjU0NQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456272545", "bodyText": "We should prefix the span name with the operation send/receive or produce/consume", "author": "pavolloffay", "createdAt": "2020-07-17T07:38:36Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -243,6 +248,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {\n+            TracingMetadata tracingMetadata = TracingMetadata.fromMessage(kafkaRecord).orElse(TracingMetadata.empty());\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(kafkaRecord.getTopic())", "originalCommit": "55e3a0d309094ab4df8b7d0debf8a55a18dee152", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MjYzOQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456272639", "bodyText": "We should prefix the span name with the operation send/receive or produce/consume", "author": "pavolloffay", "createdAt": "2020-07-17T07:38:49Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)", "originalCommit": "55e3a0d309094ab4df8b7d0debf8a55a18dee152", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1MTU3OQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456451579", "bodyText": "Why?\nThat's not what is recommended by current OpenTelemetry docs", "author": "kenfinnigan", "createdAt": "2020-07-17T13:44:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MjYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1NTQwNg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456455406", "bodyText": "Where did you find the guidelines?\nThe operation name should be low cardinality which topic name certainly is, but it should represent the operation wich in our case is either consume or produce.", "author": "pavolloffay", "createdAt": "2020-07-17T13:51:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MjYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1NjI1Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456456252", "bodyText": "We should also add the topic name to tags. This will help with the data semantics and in aggregation jobs since we cannot rely on the operation name.", "author": "pavolloffay", "createdAt": "2020-07-17T13:52:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MjYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1OTA1OQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456459059", "bodyText": "https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/messaging.md looks like it has been updated since last I saw, previously it only mentioned topic name.\nTopic name is added to messaging.destination", "author": "kenfinnigan", "createdAt": "2020-07-17T13:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MjYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ2MDcwNQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456460705", "bodyText": "It might be the important fact here is to keep it low cardinality and then describe what it does. produce would be also good but including the topic name is even better.", "author": "pavolloffay", "createdAt": "2020-07-17T14:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MjYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzE3Ng==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456273176", "bodyText": "This span will not provide any valuable timing information e.g. how long the send operation took. Is there a way to end the span once the message is sent on the wire?", "author": "pavolloffay", "createdAt": "2020-07-17T07:39:56Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -243,6 +248,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {\n+            TracingMetadata tracingMetadata = TracingMetadata.fromMessage(kafkaRecord).orElse(TracingMetadata.empty());\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(kafkaRecord.getTopic())\n+                    .setSpanKind(Span.Kind.CONSUMER);\n+\n+            // Handle possible parent span\n+            final SpanContext parentSpan = tracingMetadata.getPreviousSpanContext();\n+            if (parentSpan != null && parentSpan.isValid()) {\n+                spanBuilder.setParent(parentSpan);\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", kafkaRecord.getPartition());\n+            span.setAttribute(\"offset\", kafkaRecord.getOffset());\n+            span.setAttribute(\"messaging.system\", \"kafka\");\n+            span.setAttribute(\"messaging.destination\", kafkaRecord.getTopic());\n+            span.setAttribute(\"messaging.destination_kind\", \"topic\");\n+\n+            kafkaRecord.injectTracingMetadata(tracingMetadata.withSpan(span));\n+\n+            span.end();", "originalCommit": "55e3a0d309094ab4df8b7d0debf8a55a18dee152", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1MzI5NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456453294", "bodyText": "The goal of the spans is not to track method execution, but simply to indicate a connector for @Incoming or @Outgoing.", "author": "kenfinnigan", "createdAt": "2020-07-17T13:47:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNDUwOQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476204509", "bodyText": "We could still register the reception timestamp.\nNote that it's not the record timestamp.", "author": "cescoffier", "createdAt": "2020-08-25T06:23:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4NzM0NQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476487345", "bodyText": "There doesn't appear to be anything defined to represent that in OTeL at present.\nDo you have a suggested name?", "author": "kenfinnigan", "createdAt": "2020-08-25T14:20:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE2NjgwNQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r478166805", "bodyText": "@pavolloffay any hint?", "author": "cescoffier", "createdAt": "2020-08-27T06:12:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODkyNjM4NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r478926384", "bodyText": "I am not sure I follow you here.\nDo you want to record the reception timestamp as the span timestamp? The span start time should be overridable, if the timing you want to record is after the span start I suggest to add a timed event to the span.", "author": "pavolloffay", "createdAt": "2020-08-28T08:15:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzQ2MA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456273460", "bodyText": "Isn't the add overriding the value?", "author": "pavolloffay", "createdAt": "2020-07-17T07:40:32Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/tracing/HeaderInjectAdapter.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.kafka.common.header.Headers;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+\n+public class HeaderInjectAdapter implements HttpTextFormat.Setter<Headers> {\n+    public static final HeaderInjectAdapter SETTER = new HeaderInjectAdapter();\n+\n+    @Override\n+    public void set(Headers headers, String key, String value) {\n+        if (headers != null) {\n+            headers.remove(key).add(key, value.getBytes(StandardCharsets.UTF_8));", "originalCommit": "55e3a0d309094ab4df8b7d0debf8a55a18dee152", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1MzU4OQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456453589", "bodyText": "Can't recall right now, but this is the pattern used in the Kafka instrumentation class", "author": "kenfinnigan", "createdAt": "2020-07-17T13:48:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzQ2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMTg5MQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r458211891", "bodyText": "The equals check on RecordHeader uses key and value, so I think it's necessary to remove the previous one using the key otherwise you could end up with different values as the underlying collection is a List.\nMaybe I'm wrong, but probably better to be safe", "author": "kenfinnigan", "createdAt": "2020-07-21T16:01:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzQ2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNTI2NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476205264", "bodyText": "I was thinking add was appending, but let's check.", "author": "cescoffier", "createdAt": "2020-08-25T06:25:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzQ2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxNDY0MA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476414640", "bodyText": "Yes add is appending, so we need to remove the previous value to ensure we don't end up with multiples present", "author": "kenfinnigan", "createdAt": "2020-08-25T12:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3NDA0NQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456274045", "bodyText": "missing final?", "author": "pavolloffay", "createdAt": "2020-07-17T07:41:45Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConnector.java", "diffHunk": "@@ -77,6 +80,8 @@\n \n     public static final String CONNECTOR_NAME = \"smallrye-kafka\";\n \n+    public static Tracer TRACER = OpenTelemetry.getTracerProvider().get(\"io.smallrye.reactive.messaging.kafka\");", "originalCommit": "55e3a0d309094ab4df8b7d0debf8a55a18dee152", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwMzAyMQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456303021", "bodyText": "It would be good to check if the spans belong to the same trace", "author": "pavolloffay", "createdAt": "2020-07-17T08:37:42Z", "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import static io.opentelemetry.trace.Span.Kind.CONSUMER;\n+import static io.opentelemetry.trace.Span.Kind.PRODUCER;\n+import static io.opentelemetry.trace.TracingContextUtils.withSpan;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.jboss.weld.environment.se.Weld;\n+import org.jboss.weld.environment.se.WeldContainer;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.exporters.inmemory.InMemorySpanExporter;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.reactivex.Flowable;\n+import io.smallrye.config.SmallRyeConfigProviderResolver;\n+import io.smallrye.reactive.messaging.TracingMetadata;\n+import io.smallrye.reactive.messaging.kafka.KafkaConnector;\n+import io.smallrye.reactive.messaging.kafka.KafkaTestBase;\n+import io.smallrye.reactive.messaging.kafka.KafkaUsage;\n+import io.smallrye.reactive.messaging.kafka.MapBasedConfig;\n+\n+public class TracingPropagationTest extends KafkaTestBase {\n+\n+    private WeldContainer container;\n+    private InMemorySpanExporter testExporter;\n+    private SpanProcessor spanProcessor;\n+\n+    @Before\n+    public void setup() {\n+        testExporter = InMemorySpanExporter.create();\n+        spanProcessor = SimpleSpanProcessor.newBuilder(testExporter).build();\n+        OpenTelemetrySdk.getTracerProvider().addSpanProcessor(spanProcessor);\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        if (testExporter != null) {\n+            testExporter.shutdown();\n+        }\n+        if (spanProcessor != null) {\n+            spanProcessor.shutdown();\n+        }\n+\n+        if (container != null) {\n+            container.close();\n+        }\n+\n+        // Release the config objects\n+        SmallRyeConfigProviderResolver.instance().releaseConfig(ConfigProvider.getConfig());\n+    }\n+\n+    @Test\n+    public void testFromAppToKafka() {\n+        KafkaUsage usage = new KafkaUsage();\n+        List<Map.Entry<String, Integer>> messages = new CopyOnWriteArrayList<>();\n+        List<Context> contexts = new CopyOnWriteArrayList<>();\n+        usage.consumeIntegersWithTracing(\"output\", 10, 1, TimeUnit.MINUTES, null,\n+                (key, value) -> messages.add(entry(key, value)),\n+                contexts::add);\n+        deploy(getKafkaSinkConfigForMyAppGeneratingData(), MyAppGeneratingData.class);\n+\n+        await().until(() -> messages.size() >= 10);\n+        List<Integer> values = new ArrayList<>();\n+        assertThat(messages).allSatisfy(entry -> {\n+            assertThat(entry.getValue()).isNotNull();\n+            values.add(entry.getValue());\n+        });\n+        assertThat(values).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        assertThat(contexts).hasSize(10);\n+        assertThat(contexts).doesNotContainNull().doesNotHaveDuplicates();\n+        List<SpanId> spanIds = contexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getSpanId())\n+                .collect(Collectors.toList());\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);", "originalCommit": "55e3a0d309094ab4df8b7d0debf8a55a18dee152", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwNDM2MQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456304361", "bodyText": "Let's discuss what span context should be used as a parent.\nWhat represents the getPreviousSpanContext? Is it the context derived from the previous Kafka message?\nIf this code is executed synchronously when the user code is sending a message then it might be better to set the current active context as the parent.", "author": "pavolloffay", "createdAt": "2020-07-17T08:40:19Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);\n+\n+            if (tracingMetadata.isPresent()) {\n+                // Handle possible parent span\n+                final SpanContext parentSpan = tracingMetadata.get().getPreviousSpanContext();", "originalCommit": "55e3a0d309094ab4df8b7d0debf8a55a18dee152", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MjQ1OQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r458282459", "bodyText": "That's one of the reasons we didn't like the current Kafka instrumentation for OpenTelemetry: https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/master/instrumentation/kafka-clients-0.11/src/main/java/io/opentelemetry/auto/instrumentation/kafkaclients/TracingIterator.java#L46\nThere's no guarantee that we process a method with @Incoming and then it's @Outgoing with such timing that there couldn't have been a different @Incoming being received before the other @Outgoing is processed, so relying on the context that's on the TRACER would lead to issues.\nAt least that's my understanding of things", "author": "kenfinnigan", "createdAt": "2020-07-21T17:52:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwNDM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MzE3MA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r458283170", "bodyText": "getPreviousSpanContext() will return the SpanContext, if there is one, from any @Incoming that was processed", "author": "kenfinnigan", "createdAt": "2020-07-21T17:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwNDM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODI1OA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456308258", "bodyText": "Potential leak on the not closed scope.", "author": "pavolloffay", "createdAt": "2020-07-17T08:47:32Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);\n+\n+            if (tracingMetadata.isPresent()) {\n+                // Handle possible parent span\n+                final SpanContext parentSpan = tracingMetadata.get().getPreviousSpanContext();\n+                if (parentSpan != null && parentSpan.isValid()) {\n+                    spanBuilder.setParent(parentSpan);\n+                } else {\n+                    spanBuilder.setNoParent();\n+                }\n+\n+                // Handle possible adjacent spans\n+                final SpanContext incomingSpan = tracingMetadata.get().getCurrentSpanContext();\n+                if (incomingSpan != null && incomingSpan.isValid()) {\n+                    spanBuilder.addLink(incomingSpan);\n+                }\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+            TracingContextUtils.currentContextWith(span);", "originalCommit": "55e3a0d309094ab4df8b7d0debf8a55a18dee152", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODQ3MA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456308470", "bodyText": "SemanticAttributes should be used", "author": "pavolloffay", "createdAt": "2020-07-17T08:47:54Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -158,6 +168,47 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic)\n+                    .setSpanKind(Span.Kind.PRODUCER);\n+\n+            if (tracingMetadata.isPresent()) {\n+                // Handle possible parent span\n+                final SpanContext parentSpan = tracingMetadata.get().getPreviousSpanContext();\n+                if (parentSpan != null && parentSpan.isValid()) {\n+                    spanBuilder.setParent(parentSpan);\n+                } else {\n+                    spanBuilder.setNoParent();\n+                }\n+\n+                // Handle possible adjacent spans\n+                final SpanContext incomingSpan = tracingMetadata.get().getCurrentSpanContext();\n+                if (incomingSpan != null && incomingSpan.isValid()) {\n+                    spanBuilder.addLink(incomingSpan);\n+                }\n+            } else {\n+                spanBuilder.setNoParent();\n+            }\n+\n+            final Span span = spanBuilder.startSpan();\n+            TracingContextUtils.currentContextWith(span);\n+\n+            // Set Span attributes\n+            span.setAttribute(\"partition\", partition);", "originalCommit": "55e3a0d309094ab4df8b7d0debf8a55a18dee152", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1MjkwOA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456452908", "bodyText": "In 0.5.0 they weren't there, I can use them now they're there", "author": "kenfinnigan", "createdAt": "2020-07-17T13:46:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODQ3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwODU0OA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r458208548", "bodyText": "Actually, they're only in master and not 0.6.0", "author": "kenfinnigan", "createdAt": "2020-07-21T15:57:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwOTk1NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456309954", "bodyText": "Why readCounter is being used?\nnit: getAndIncrement()", "author": "pavolloffay", "createdAt": "2020-07-17T08:50:40Z", "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/KafkaUsage.java", "diffHunk": "@@ -215,6 +220,26 @@ public void consumeStrings(String topicName, int count, long timeout, TimeUnit u\n                 });\n     }\n \n+    public void consumeStringsWithTracing(String topicName, int count, long timeout, TimeUnit unit, Runnable completion,\n+            BiConsumer<String, String> consumer, Consumer<Context> tracingConsumer) {\n+        AtomicLong readCounter = new AtomicLong();\n+        this.consumeStrings(this.continueIfNotExpired(() -> readCounter.get() < (long) count, timeout, unit), completion,", "originalCommit": "55e3a0d309094ab4df8b7d0debf8a55a18dee152", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1NDMwOA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456454308", "bodyText": "It counts up to the number of messages we expect to receive.\nAs for the nit, all the other methods use the same method", "author": "kenfinnigan", "createdAt": "2020-07-17T13:49:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwOTk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNTc0OQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456315749", "bodyText": "There are missing tests when an active span is created in the test an messages are produced and consumed. In this case the spans created by the instrumentation should by linked to the span in the test.", "author": "pavolloffay", "createdAt": "2020-07-17T09:01:46Z", "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import static io.opentelemetry.trace.Span.Kind.CONSUMER;\n+import static io.opentelemetry.trace.Span.Kind.PRODUCER;\n+import static io.opentelemetry.trace.TracingContextUtils.withSpan;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.jboss.weld.environment.se.Weld;\n+import org.jboss.weld.environment.se.WeldContainer;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.exporters.inmemory.InMemorySpanExporter;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.reactivex.Flowable;\n+import io.smallrye.config.SmallRyeConfigProviderResolver;\n+import io.smallrye.reactive.messaging.TracingMetadata;\n+import io.smallrye.reactive.messaging.kafka.KafkaConnector;\n+import io.smallrye.reactive.messaging.kafka.KafkaTestBase;\n+import io.smallrye.reactive.messaging.kafka.KafkaUsage;\n+import io.smallrye.reactive.messaging.kafka.MapBasedConfig;\n+\n+public class TracingPropagationTest extends KafkaTestBase {", "originalCommit": "55e3a0d309094ab4df8b7d0debf8a55a18dee152", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1NTIzOQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r456455239", "bodyText": "That's what testFromKafkaToAppToKafka() tests. Spans present on the message from Kafka that we receive into the app.", "author": "kenfinnigan", "createdAt": "2020-07-17T13:50:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNTc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4NTExNw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r458285117", "bodyText": "Ah, do you mean inside the method annotated with @Incoming or @Outgoing it creates a span?", "author": "kenfinnigan", "createdAt": "2020-07-21T17:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNTc0OQ=="}], "type": "inlineReview"}, {"oid": "f053535373223ba7ab9fcdb2f824db5b173323e0", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/f053535373223ba7ab9fcdb2f824db5b173323e0", "message": "Updates based on PR feedback", "committedDate": "2020-07-21T18:16:28Z", "type": "forcePushed"}, {"oid": "96a605497685d51e6288f59664673a9d1ae724b6", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/96a605497685d51e6288f59664673a9d1ae724b6", "message": "Add an await to in memory span reporting", "committedDate": "2020-07-23T15:12:06Z", "type": "forcePushed"}, {"oid": "bcdc0834069592c83fc38c7c069edde4f2d33a1b", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/bcdc0834069592c83fc38c7c069edde4f2d33a1b", "message": "Disable tracing in non tracing tests", "committedDate": "2020-07-29T15:39:36Z", "type": "forcePushed"}, {"oid": "cedeee96473f8aafbcc7a56684ec4931e27e22a7", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/cedeee96473f8aafbcc7a56684ec4931e27e22a7", "message": "Disable tracing in non tracing tests\n\n# Conflicts:\n#\tsmallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "committedDate": "2020-08-19T15:25:53Z", "type": "forcePushed"}, {"oid": "d15af1af3133dddd929ec6fd6c98a1e0dabe4269", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/d15af1af3133dddd929ec6fd6c98a1e0dabe4269", "message": "Update to OTeL 0.7.1 and use new SemanticAttributes", "committedDate": "2020-08-20T17:51:02Z", "type": "forcePushed"}, {"oid": "b8e755370fa58767e50ac58eeac6b3ab80d0087a", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/b8e755370fa58767e50ac58eeac6b3ab80d0087a", "message": "Update to OTeL 0.7.1 and use new SemanticAttributes", "committedDate": "2020-08-24T13:04:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMTEwMA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476201100", "bodyText": "Should it be added only if tracing is enabled?", "author": "cescoffier", "createdAt": "2020-08-25T06:14:47Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "diffHunk": "@@ -23,8 +28,18 @@ public IncomingKafkaRecord(\n             KafkaCommitHandler commitHandler,\n             KafkaFailureHandler onNack) {\n         this.kafkaMetadata = new IncomingKafkaRecordMetadata<>(record);\n-        this.metadata = Metadata.of(this.kafkaMetadata);\n         this.commitHandler = commitHandler;\n+\n+        TracingMetadata tracingMetadata = TracingMetadata.empty();", "originalCommit": "b8e755370fa58767e50ac58eeac6b3ab80d0087a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMDQ4Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476410482", "bodyText": "Probably, will adjust", "author": "kenfinnigan", "createdAt": "2020-08-25T12:30:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMTEwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMTY3Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476201672", "bodyText": "with metadata not final anymore, we must synchronize access.", "author": "cescoffier", "createdAt": "2020-08-25T06:16:15Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/IncomingKafkaRecord.java", "diffHunk": "@@ -81,4 +96,8 @@ public Metadata getMetadata() {\n     public CompletionStage<Void> nack(Throwable reason) {\n         return onNack.handle(this, reason);\n     }\n+\n+    public void injectTracingMetadata(TracingMetadata tracingMetadata) {", "originalCommit": "b8e755370fa58767e50ac58eeac6b3ab80d0087a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMDcyMA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476410720", "bodyText": "do you mean just making the method synchronized, or something different?", "author": "kenfinnigan", "createdAt": "2020-08-25T12:30:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMTY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ0NjA5OA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476446098", "bodyText": "yes, synchronized", "author": "cescoffier", "createdAt": "2020-08-25T13:25:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMTY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMjE0Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476202142", "bodyText": "so even if tracing is disabled we instantiate the tracer? Does it make sense?", "author": "cescoffier", "createdAt": "2020-08-25T06:17:29Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConnector.java", "diffHunk": "@@ -79,6 +82,8 @@\n \n     public static final String CONNECTOR_NAME = \"smallrye-kafka\";\n \n+    public static final Tracer TRACER = OpenTelemetry.getTracerProvider().get(\"io.smallrye.reactive.messaging.kafka\");", "originalCommit": "b8e755370fa58767e50ac58eeac6b3ab80d0087a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMTM0Ng==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476411346", "bodyText": "There's a small cost yes, even to have the No Op tracer.\nHowever, not setting it like this then means more work to ensure we don't create multiple versions later.\nI don't mind doing that, but that would potentially slow things down a bit on the first use", "author": "kenfinnigan", "createdAt": "2020-08-25T12:32:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMjE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ0NjM1OA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476446358", "bodyText": "ok, make sense.", "author": "cescoffier", "createdAt": "2020-08-25T13:26:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMjE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMjcyOA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476202728", "bodyText": "is the \"send\" word defined somewhere? In Kafka, we use \"write\" most of the time.", "author": "cescoffier", "createdAt": "2020-08-25T06:19:11Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -168,6 +180,48 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {\n+            Optional<TracingMetadata> tracingMetadata = TracingMetadata.fromMessage(message);\n+\n+            final Span.Builder spanBuilder = TRACER.spanBuilder(topic + \" send\")", "originalCommit": "b8e755370fa58767e50ac58eeac6b3ab80d0087a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMjY5OA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476412698", "bodyText": "It's defined by OpenTelemetry specification. See https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/messaging.md#conventions", "author": "kenfinnigan", "createdAt": "2020-08-25T12:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMjcyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ0NjY4MQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476446681", "bodyText": "great, don't forget to add this to the documentation.", "author": "cescoffier", "createdAt": "2020-08-25T13:26:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMjcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMzAzNg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476203036", "bodyText": "This whole block should be externalized in a carefully tested method.", "author": "cescoffier", "createdAt": "2020-08-25T06:20:01Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSink.java", "diffHunk": "@@ -168,6 +180,48 @@ private void handleWriteResult(AsyncResult<?> ar, Message<?> message, ProducerRe\n                 kafkaHeaders);\n     }\n \n+    private void createOutgoingTrace(Message<?> message, String topic, int partition, Headers headers) {\n+        if (configuration.getTracingEnabled()) {", "originalCommit": "b8e755370fa58767e50ac58eeac6b3ab80d0087a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMTg4OA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476411888", "bodyText": "Not sure what you mean. It's all in createOutgoingTrace method, are you suggesting something else?\nOr do you mean there should be unit tests verifying the behavior of just this method?", "author": "kenfinnigan", "createdAt": "2020-08-25T12:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMzAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ0NzMyNg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476447326", "bodyText": "Damned missed it.", "author": "cescoffier", "createdAt": "2020-08-25T13:27:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMzAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMzk1NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476203954", "bodyText": "let's build a conditional pipeline instead of testing if tracing is enabled every time.\nmulti = ...\nif (getTracingEnabled()) {\n    multi = .... \n}", "author": "cescoffier", "createdAt": "2020-08-25T06:22:29Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -225,6 +230,7 @@ public KafkaSource(Vertx vertx,\n                     }\n                 })\n                 .map(rec -> commitHandler.received(new IncomingKafkaRecord<>(rec, commitHandler, failureHandler)))\n+                .onItem().invoke(this::incomingTrace)", "originalCommit": "b8e755370fa58767e50ac58eeac6b3ab80d0087a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMjkxMw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476412913", "bodyText": "Ok", "author": "kenfinnigan", "createdAt": "2020-08-25T12:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMzk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyNzY0Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476427642", "bodyText": "How do I do the onItem() so that it's invoked at the correct place in the stream?\nDo you mean creating two pipelines, one with and one without the onItem()? Or do you mean multi into multi?", "author": "kenfinnigan", "createdAt": "2020-08-25T12:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMzk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ0OTIxNg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476449216", "bodyText": "Pipelines are \"append-only\".\nYou create one, and append the onItem() if tracing is enabled:\nmulti = ...\nif (getTracingEnabled()) {\n    multi = multi.onItem().invoke(this::incomingTrace); \n}\nmulti = multi....", "author": "cescoffier", "createdAt": "2020-08-25T13:30:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwMzk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNDg4NQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476204885", "bodyText": "should it fail on multiple values? Is it even possible?", "author": "cescoffier", "createdAt": "2020-08-25T06:24:54Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/tracing/HeaderExtractAdapter.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.Headers;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+\n+public class HeaderExtractAdapter implements HttpTextFormat.Getter<Headers> {\n+    public static final HeaderExtractAdapter GETTER = new HeaderExtractAdapter();\n+\n+    @Override\n+    public String get(Headers headers, String key) {\n+        final Header header = headers.lastHeader(key);", "originalCommit": "b8e755370fa58767e50ac58eeac6b3ab80d0087a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMzE5NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476413194", "bodyText": "I think it's specified to only retrieve the last one", "author": "kenfinnigan", "createdAt": "2020-08-25T12:35:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNDg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNTczMQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476205731", "bodyText": "That is a bit cumbersome and error-prone.\nIs there something we can do in the base class?", "author": "cescoffier", "createdAt": "2020-08-25T06:27:02Z", "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/DefaultConfigTest.java", "diffHunk": "@@ -89,12 +89,14 @@ private MapBasedConfig getKafkaSinkConfigForMyAppProcessingData(String topicOut,\n         Map<String, Object> config = new HashMap<>();\n         config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n         config.put(prefix + \"topic\", topicOut);\n+        config.put(prefix + \"tracing-enabled\", false);", "originalCommit": "b8e755370fa58767e50ac58eeac6b3ab80d0087a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxNDg2Mw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476414863", "bodyText": "Will see if something can be done", "author": "kenfinnigan", "createdAt": "2020-08-25T12:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNTczMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5MDk4Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476490982", "bodyText": "I was thinking I could detect whether it was set in MapBasedConfig and then add it set to false in write() if it wasn't.\nBut I'm not sure that's going to be easy given the different key prefixes and an unknown number of them.", "author": "kenfinnigan", "createdAt": "2020-08-25T14:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNTczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIwNTkzNg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476205936", "bodyText": "we should wait until the vert.x instance is closed if we want to be totally correct.", "author": "cescoffier", "createdAt": "2020-08-25T06:27:31Z", "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/KafkaTestBase.java", "diffHunk": "@@ -66,7 +66,9 @@ public void setup() {\n \n     @After\n     public void tearDown() {\n-        vertx.close();\n+        if (vertx != null) {\n+            vertx.close();", "originalCommit": "b8e755370fa58767e50ac58eeac6b3ab80d0087a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIyOTYwMQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476229601", "bodyText": "minor - can be final", "author": "cescoffier", "createdAt": "2020-08-25T07:18:51Z", "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "diffHunk": "@@ -0,0 +1,392 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import static io.opentelemetry.trace.Span.Kind.CONSUMER;\n+import static io.opentelemetry.trace.Span.Kind.PRODUCER;\n+import static io.opentelemetry.trace.TracingContextUtils.withSpan;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.jboss.weld.environment.se.Weld;\n+import org.jboss.weld.environment.se.WeldContainer;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.exporters.inmemory.InMemorySpanExporter;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.reactivex.Flowable;\n+import io.smallrye.config.SmallRyeConfigProviderResolver;\n+import io.smallrye.reactive.messaging.TracingMetadata;\n+import io.smallrye.reactive.messaging.kafka.KafkaConnector;\n+import io.smallrye.reactive.messaging.kafka.KafkaTestBase;\n+import io.smallrye.reactive.messaging.kafka.KafkaUsage;\n+import io.smallrye.reactive.messaging.kafka.MapBasedConfig;\n+\n+public class TracingPropagationTest extends KafkaTestBase {\n+\n+    private WeldContainer container;\n+    private InMemorySpanExporter testExporter;\n+    private SpanProcessor spanProcessor;\n+\n+    @Before\n+    public void setup() {\n+        testExporter = InMemorySpanExporter.create();\n+        spanProcessor = SimpleSpanProcessor.newBuilder(testExporter).build();\n+        OpenTelemetrySdk.getTracerProvider().addSpanProcessor(spanProcessor);\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        if (testExporter != null) {\n+            testExporter.shutdown();\n+        }\n+        if (spanProcessor != null) {\n+            spanProcessor.shutdown();\n+        }\n+\n+        if (container != null) {\n+            container.close();\n+        }\n+\n+        // Release the config objects\n+        SmallRyeConfigProviderResolver.instance().releaseConfig(ConfigProvider.getConfig());\n+    }\n+\n+    @Test\n+    public void testFromAppToKafka() {\n+        KafkaUsage usage = new KafkaUsage();\n+        List<Map.Entry<String, Integer>> messages = new CopyOnWriteArrayList<>();\n+        List<Context> contexts = new CopyOnWriteArrayList<>();\n+        usage.consumeIntegersWithTracing(\"output\", 10, 1, TimeUnit.MINUTES, null,\n+                (key, value) -> messages.add(entry(key, value)),\n+                contexts::add);\n+        deploy(getKafkaSinkConfigForMyAppGeneratingData(), MyAppGeneratingData.class);\n+\n+        await().until(() -> messages.size() >= 10);\n+        List<Integer> values = new ArrayList<>();\n+        assertThat(messages).allSatisfy(entry -> {\n+            assertThat(entry.getValue()).isNotNull();\n+            values.add(entry.getValue());\n+        });\n+        assertThat(values).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        assertThat(contexts).hasSize(10);\n+        assertThat(contexts).doesNotContainNull().doesNotHaveDuplicates();\n+\n+        List<SpanId> spanIds = contexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getSpanId())\n+                .collect(Collectors.toList());\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+\n+        List<TraceId> traceIds = contexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getTraceId())\n+                .collect(Collectors.toList());\n+        assertThat(traceIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            assertThat(data.getSpanId()).isIn(spanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getTraceId()).isIn(traceIds);\n+            assertThat(data.getKind()).isEqualByComparingTo(PRODUCER);\n+            assertThat(data.getParentSpanId().isValid()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testFromKafkaToAppToKafka() {\n+        KafkaUsage usage = new KafkaUsage();\n+        List<Map.Entry<String, Integer>> messages = new CopyOnWriteArrayList<>();\n+        List<Context> receivedContexts = new CopyOnWriteArrayList<>();\n+        usage.consumeIntegersWithTracing(\"result-topic\", 10, 1, TimeUnit.MINUTES, null,\n+                (key, value) -> messages.add(entry(key, value)),\n+                receivedContexts::add);\n+        deploy(getKafkaSinkConfigForMyAppProcessingData(), MyAppProcessingData.class);\n+\n+        AtomicInteger count = new AtomicInteger();\n+        List<SpanContext> producedSpanContexts = new CopyOnWriteArrayList<>();\n+        usage.produceIntegers(10, null,\n+                () -> new ProducerRecord<>(\"some-topic\", null, null, \"a-key\", count.getAndIncrement(),\n+                        createTracingSpan(producedSpanContexts, \"some-topic\")));\n+\n+        await().atMost(Duration.ofMinutes(5)).until(() -> messages.size() >= 10);\n+        List<Integer> values = new ArrayList<>();\n+        assertThat(messages).allSatisfy(entry -> {\n+            assertThat(entry.getValue()).isNotNull();\n+            values.add(entry.getValue());\n+        });\n+        assertThat(values).containsExactly(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+\n+        List<TraceId> producedTraceIds = producedSpanContexts.stream()\n+                .map(SpanContext::getTraceId)\n+                .collect(Collectors.toList());\n+        assertThat(producedTraceIds).hasSize(10);\n+\n+        assertThat(receivedContexts).hasSize(10);\n+        assertThat(receivedContexts).doesNotContainNull().doesNotHaveDuplicates();\n+\n+        List<SpanId> receivedSpanIds = receivedContexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getSpanId())\n+                .collect(Collectors.toList());\n+        assertThat(receivedSpanIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+\n+        List<TraceId> receivedTraceIds = receivedContexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getTraceId())\n+                .collect(Collectors.toList());\n+        assertThat(receivedTraceIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+        assertThat(receivedTraceIds).containsExactlyInAnyOrderElementsOf(producedTraceIds);\n+\n+        List<SpanId> receivedParentSpanIds = new ArrayList<>();\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            if (data.getKind().equals(CONSUMER)) {\n+                // Need to skip the spans created during @Incoming processing\n+                continue;\n+            }\n+            assertThat(data.getSpanId()).isIn(receivedSpanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getTraceId()).isIn(producedTraceIds);\n+            assertThat(data.getKind()).isEqualByComparingTo(PRODUCER);\n+            assertThat(data.getParentSpanId().isValid()).isTrue();\n+            receivedParentSpanIds.add(data.getParentSpanId());\n+        }\n+\n+        assertThat(producedSpanContexts.stream()\n+                .map(SpanContext::getSpanId)).containsExactlyElementsOf(receivedParentSpanIds);\n+    }\n+\n+    @Test\n+    public void testFromKafkaToAppWithParentSpan() {\n+        KafkaUsage usage = new KafkaUsage();\n+        deploy(getKafkaSinkConfigForMyAppReceivingData(\"parent-stuff\"), MyAppReceivingData.class);\n+\n+        AtomicInteger count = new AtomicInteger();\n+        MyAppReceivingData bean = container.getBeanManager().createInstance().select(MyAppReceivingData.class).get();\n+        List<SpanContext> producedSpanContexts = new CopyOnWriteArrayList<>();\n+\n+        usage.produceIntegers(10, null,\n+                () -> new ProducerRecord<>(\"parent-stuff\", null, null, \"a-key\", count.getAndIncrement(),\n+                        createTracingSpan(producedSpanContexts, \"stuff-topic\")));\n+\n+        await().until(() -> bean.list().size() >= 10);\n+        assertThat(bean.list()).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        List<TraceId> producedTraceIds = producedSpanContexts.stream()\n+                .map(SpanContext::getTraceId)\n+                .collect(Collectors.toList());\n+        assertThat(producedTraceIds).hasSize(10);\n+\n+        assertThat(bean.tracing()).hasSizeGreaterThanOrEqualTo(10);\n+        assertThat(bean.tracing()).doesNotContainNull().doesNotHaveDuplicates();\n+\n+        List<TraceId> receivedTraceIds = bean.tracing().stream()\n+                .map(tracingMetadata -> tracingMetadata.getCurrentSpanContext().getTraceId())\n+                .collect(Collectors.toList());\n+        assertThat(receivedTraceIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+        assertThat(receivedTraceIds).containsExactlyInAnyOrderElementsOf(producedTraceIds);\n+\n+        List<SpanId> spanIds = new ArrayList<>();\n+\n+        for (TracingMetadata tracing : bean.tracing()) {\n+            spanIds.add(tracing.getCurrentSpanContext().getSpanId());\n+\n+            assertThat(tracing.getPreviousSpanContext()).isNotNull();\n+            assertThat(tracing.getPreviousSpanContext().getTraceId())\n+                    .isEqualByComparingTo(tracing.getCurrentSpanContext().getTraceId());\n+            assertThat(tracing.getPreviousSpanContext().getSpanId())\n+                    .isNotEqualByComparingTo(tracing.getCurrentSpanContext().getSpanId());\n+        }\n+\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSizeGreaterThanOrEqualTo(10);\n+\n+        List<SpanId> parentIds = bean.tracing().stream()\n+                .map(tracingMetadata -> tracingMetadata.getPreviousSpanContext().getSpanId())\n+                .collect(Collectors.toList());\n+\n+        assertThat(producedSpanContexts.stream()\n+                .map(SpanContext::getSpanId)).containsExactlyElementsOf(parentIds);\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            assertThat(data.getSpanId()).isIn(spanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getKind()).isEqualByComparingTo(CONSUMER);\n+            assertThat(data.getParentSpanId()).isNotNull();\n+            assertThat(data.getParentSpanId()).isIn(parentIds);\n+        }\n+    }\n+\n+    @Test\n+    public void testFromKafkaToAppWithNoParent() {\n+        KafkaUsage usage = new KafkaUsage();\n+        deploy(getKafkaSinkConfigForMyAppReceivingData(\"no-parent-stuff\"), MyAppReceivingData.class);\n+\n+        AtomicInteger count = new AtomicInteger();\n+        MyAppReceivingData bean = container.getBeanManager().createInstance().select(MyAppReceivingData.class).get();\n+\n+        usage.produceIntegers(10, null,\n+                () -> new ProducerRecord<>(\"no-parent-stuff\", null, null, \"a-key\", count.getAndIncrement()));\n+\n+        await().until(() -> bean.list().size() >= 10);\n+        assertThat(bean.list()).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        assertThat(bean.tracing()).hasSizeGreaterThanOrEqualTo(10);\n+        assertThat(bean.tracing()).doesNotContainNull().doesNotHaveDuplicates();\n+        List<SpanId> spanIds = new ArrayList<>();\n+\n+        for (TracingMetadata tracing : bean.tracing()) {\n+            spanIds.add(tracing.getCurrentSpanContext().getSpanId());\n+            assertThat(tracing.getPreviousSpanContext()).isNull();\n+        }\n+\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSizeGreaterThanOrEqualTo(10);\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            assertThat(data.getSpanId()).isIn(spanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getKind()).isEqualByComparingTo(CONSUMER);\n+            assertThat(data.getParentSpanId().isValid()).isFalse();\n+        }\n+    }\n+\n+    private Iterable<Header> createTracingSpan(List<SpanContext> spanContexts, String topic) {\n+        RecordHeaders proposedHeaders = new RecordHeaders();\n+        final Span span = KafkaConnector.TRACER.spanBuilder(topic).setSpanKind(PRODUCER).startSpan();\n+        final Context context = withSpan(span, Context.current());\n+        OpenTelemetry.getPropagators()\n+                .getHttpTextFormat()\n+                .inject(context, proposedHeaders, (headers, key, value) -> {\n+                    if (headers != null) {\n+                        headers.remove(key).add(key, value.getBytes(StandardCharsets.UTF_8));\n+                    }\n+                });\n+        spanContexts.add(span.getContext());\n+        return proposedHeaders;\n+    }\n+\n+    private <T> void deploy(MapBasedConfig config, Class<T> clazz) {\n+        if (config != null) {\n+            config.write();\n+        } else {\n+            MapBasedConfig.clear();\n+        }\n+\n+        Weld weld = baseWeld();\n+        weld.addBeanClass(clazz);\n+\n+        container = weld.initialize();\n+    }\n+\n+    private MapBasedConfig getKafkaSinkConfigForMyAppGeneratingData() {\n+        String prefix = \"mp.messaging.outgoing.kafka.\";\n+        Map<String, Object> config = new HashMap<>();\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.serializer\", IntegerSerializer.class.getName());\n+        config.put(prefix + \"topic\", \"output\");\n+        return new MapBasedConfig(config);\n+    }\n+\n+    private MapBasedConfig getKafkaSinkConfigForMyAppProcessingData() {\n+        String prefix = \"mp.messaging.outgoing.kafka.\";\n+        Map<String, Object> config = new HashMap<>();\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.serializer\", IntegerSerializer.class.getName());\n+        config.put(prefix + \"topic\", \"result-topic\");\n+\n+        prefix = \"mp.messaging.incoming.source.\";\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.deserializer\", IntegerDeserializer.class.getName());\n+        config.put(prefix + \"key.deserializer\", StringDeserializer.class.getName());\n+        config.put(prefix + \"topic\", \"some-topic\");\n+        config.put(prefix + \"auto.offset.reset\", \"earliest\");\n+\n+        return new MapBasedConfig(config);\n+    }\n+\n+    private MapBasedConfig getKafkaSinkConfigForMyAppReceivingData(String topic) {\n+        Map<String, Object> config = new HashMap<>();\n+\n+        String prefix = \"mp.messaging.incoming.stuff.\";\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.deserializer\", IntegerDeserializer.class.getName());\n+        config.put(prefix + \"key.deserializer\", StringDeserializer.class.getName());\n+        config.put(prefix + \"topic\", topic);\n+        config.put(prefix + \"auto.offset.reset\", \"earliest\");\n+\n+        return new MapBasedConfig(config);\n+    }\n+\n+    @ApplicationScoped\n+    public static class MyAppGeneratingData {\n+\n+        @Outgoing(\"kafka\")\n+        public Flowable<Integer> source() {\n+            return Flowable.range(0, 10);\n+        }\n+    }\n+\n+    @ApplicationScoped\n+    public static class MyAppProcessingData {\n+\n+        @Incoming(\"source\")\n+        @Outgoing(\"kafka\")\n+        public Message<Integer> processMessage(Message<Integer> input) {\n+            return input.withPayload(input.getPayload() + 1);\n+        }\n+    }\n+\n+    @ApplicationScoped\n+    public static class MyAppReceivingData {\n+        private List<TracingMetadata> tracingMetadata = new ArrayList<>();", "originalCommit": "b8e755370fa58767e50ac58eeac6b3ab80d0087a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIyOTYzMQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r476229631", "bodyText": "minor - can be final", "author": "cescoffier", "createdAt": "2020-08-25T07:18:56Z", "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/tracing/TracingPropagationTest.java", "diffHunk": "@@ -0,0 +1,392 @@\n+package io.smallrye.reactive.messaging.kafka.tracing;\n+\n+import static io.opentelemetry.trace.Span.Kind.CONSUMER;\n+import static io.opentelemetry.trace.Span.Kind.PRODUCER;\n+import static io.opentelemetry.trace.TracingContextUtils.withSpan;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+import org.jboss.weld.environment.se.Weld;\n+import org.jboss.weld.environment.se.WeldContainer;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.exporters.inmemory.InMemorySpanExporter;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.reactivex.Flowable;\n+import io.smallrye.config.SmallRyeConfigProviderResolver;\n+import io.smallrye.reactive.messaging.TracingMetadata;\n+import io.smallrye.reactive.messaging.kafka.KafkaConnector;\n+import io.smallrye.reactive.messaging.kafka.KafkaTestBase;\n+import io.smallrye.reactive.messaging.kafka.KafkaUsage;\n+import io.smallrye.reactive.messaging.kafka.MapBasedConfig;\n+\n+public class TracingPropagationTest extends KafkaTestBase {\n+\n+    private WeldContainer container;\n+    private InMemorySpanExporter testExporter;\n+    private SpanProcessor spanProcessor;\n+\n+    @Before\n+    public void setup() {\n+        testExporter = InMemorySpanExporter.create();\n+        spanProcessor = SimpleSpanProcessor.newBuilder(testExporter).build();\n+        OpenTelemetrySdk.getTracerProvider().addSpanProcessor(spanProcessor);\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        if (testExporter != null) {\n+            testExporter.shutdown();\n+        }\n+        if (spanProcessor != null) {\n+            spanProcessor.shutdown();\n+        }\n+\n+        if (container != null) {\n+            container.close();\n+        }\n+\n+        // Release the config objects\n+        SmallRyeConfigProviderResolver.instance().releaseConfig(ConfigProvider.getConfig());\n+    }\n+\n+    @Test\n+    public void testFromAppToKafka() {\n+        KafkaUsage usage = new KafkaUsage();\n+        List<Map.Entry<String, Integer>> messages = new CopyOnWriteArrayList<>();\n+        List<Context> contexts = new CopyOnWriteArrayList<>();\n+        usage.consumeIntegersWithTracing(\"output\", 10, 1, TimeUnit.MINUTES, null,\n+                (key, value) -> messages.add(entry(key, value)),\n+                contexts::add);\n+        deploy(getKafkaSinkConfigForMyAppGeneratingData(), MyAppGeneratingData.class);\n+\n+        await().until(() -> messages.size() >= 10);\n+        List<Integer> values = new ArrayList<>();\n+        assertThat(messages).allSatisfy(entry -> {\n+            assertThat(entry.getValue()).isNotNull();\n+            values.add(entry.getValue());\n+        });\n+        assertThat(values).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        assertThat(contexts).hasSize(10);\n+        assertThat(contexts).doesNotContainNull().doesNotHaveDuplicates();\n+\n+        List<SpanId> spanIds = contexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getSpanId())\n+                .collect(Collectors.toList());\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+\n+        List<TraceId> traceIds = contexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getTraceId())\n+                .collect(Collectors.toList());\n+        assertThat(traceIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            assertThat(data.getSpanId()).isIn(spanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getTraceId()).isIn(traceIds);\n+            assertThat(data.getKind()).isEqualByComparingTo(PRODUCER);\n+            assertThat(data.getParentSpanId().isValid()).isFalse();\n+        }\n+    }\n+\n+    @Test\n+    public void testFromKafkaToAppToKafka() {\n+        KafkaUsage usage = new KafkaUsage();\n+        List<Map.Entry<String, Integer>> messages = new CopyOnWriteArrayList<>();\n+        List<Context> receivedContexts = new CopyOnWriteArrayList<>();\n+        usage.consumeIntegersWithTracing(\"result-topic\", 10, 1, TimeUnit.MINUTES, null,\n+                (key, value) -> messages.add(entry(key, value)),\n+                receivedContexts::add);\n+        deploy(getKafkaSinkConfigForMyAppProcessingData(), MyAppProcessingData.class);\n+\n+        AtomicInteger count = new AtomicInteger();\n+        List<SpanContext> producedSpanContexts = new CopyOnWriteArrayList<>();\n+        usage.produceIntegers(10, null,\n+                () -> new ProducerRecord<>(\"some-topic\", null, null, \"a-key\", count.getAndIncrement(),\n+                        createTracingSpan(producedSpanContexts, \"some-topic\")));\n+\n+        await().atMost(Duration.ofMinutes(5)).until(() -> messages.size() >= 10);\n+        List<Integer> values = new ArrayList<>();\n+        assertThat(messages).allSatisfy(entry -> {\n+            assertThat(entry.getValue()).isNotNull();\n+            values.add(entry.getValue());\n+        });\n+        assertThat(values).containsExactly(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+\n+        List<TraceId> producedTraceIds = producedSpanContexts.stream()\n+                .map(SpanContext::getTraceId)\n+                .collect(Collectors.toList());\n+        assertThat(producedTraceIds).hasSize(10);\n+\n+        assertThat(receivedContexts).hasSize(10);\n+        assertThat(receivedContexts).doesNotContainNull().doesNotHaveDuplicates();\n+\n+        List<SpanId> receivedSpanIds = receivedContexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getSpanId())\n+                .collect(Collectors.toList());\n+        assertThat(receivedSpanIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+\n+        List<TraceId> receivedTraceIds = receivedContexts.stream()\n+                .map(context -> TracingContextUtils.getSpanWithoutDefault(context).getContext().getTraceId())\n+                .collect(Collectors.toList());\n+        assertThat(receivedTraceIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+        assertThat(receivedTraceIds).containsExactlyInAnyOrderElementsOf(producedTraceIds);\n+\n+        List<SpanId> receivedParentSpanIds = new ArrayList<>();\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            if (data.getKind().equals(CONSUMER)) {\n+                // Need to skip the spans created during @Incoming processing\n+                continue;\n+            }\n+            assertThat(data.getSpanId()).isIn(receivedSpanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getTraceId()).isIn(producedTraceIds);\n+            assertThat(data.getKind()).isEqualByComparingTo(PRODUCER);\n+            assertThat(data.getParentSpanId().isValid()).isTrue();\n+            receivedParentSpanIds.add(data.getParentSpanId());\n+        }\n+\n+        assertThat(producedSpanContexts.stream()\n+                .map(SpanContext::getSpanId)).containsExactlyElementsOf(receivedParentSpanIds);\n+    }\n+\n+    @Test\n+    public void testFromKafkaToAppWithParentSpan() {\n+        KafkaUsage usage = new KafkaUsage();\n+        deploy(getKafkaSinkConfigForMyAppReceivingData(\"parent-stuff\"), MyAppReceivingData.class);\n+\n+        AtomicInteger count = new AtomicInteger();\n+        MyAppReceivingData bean = container.getBeanManager().createInstance().select(MyAppReceivingData.class).get();\n+        List<SpanContext> producedSpanContexts = new CopyOnWriteArrayList<>();\n+\n+        usage.produceIntegers(10, null,\n+                () -> new ProducerRecord<>(\"parent-stuff\", null, null, \"a-key\", count.getAndIncrement(),\n+                        createTracingSpan(producedSpanContexts, \"stuff-topic\")));\n+\n+        await().until(() -> bean.list().size() >= 10);\n+        assertThat(bean.list()).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        List<TraceId> producedTraceIds = producedSpanContexts.stream()\n+                .map(SpanContext::getTraceId)\n+                .collect(Collectors.toList());\n+        assertThat(producedTraceIds).hasSize(10);\n+\n+        assertThat(bean.tracing()).hasSizeGreaterThanOrEqualTo(10);\n+        assertThat(bean.tracing()).doesNotContainNull().doesNotHaveDuplicates();\n+\n+        List<TraceId> receivedTraceIds = bean.tracing().stream()\n+                .map(tracingMetadata -> tracingMetadata.getCurrentSpanContext().getTraceId())\n+                .collect(Collectors.toList());\n+        assertThat(receivedTraceIds).doesNotContainNull().doesNotHaveDuplicates().hasSize(10);\n+        assertThat(receivedTraceIds).containsExactlyInAnyOrderElementsOf(producedTraceIds);\n+\n+        List<SpanId> spanIds = new ArrayList<>();\n+\n+        for (TracingMetadata tracing : bean.tracing()) {\n+            spanIds.add(tracing.getCurrentSpanContext().getSpanId());\n+\n+            assertThat(tracing.getPreviousSpanContext()).isNotNull();\n+            assertThat(tracing.getPreviousSpanContext().getTraceId())\n+                    .isEqualByComparingTo(tracing.getCurrentSpanContext().getTraceId());\n+            assertThat(tracing.getPreviousSpanContext().getSpanId())\n+                    .isNotEqualByComparingTo(tracing.getCurrentSpanContext().getSpanId());\n+        }\n+\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSizeGreaterThanOrEqualTo(10);\n+\n+        List<SpanId> parentIds = bean.tracing().stream()\n+                .map(tracingMetadata -> tracingMetadata.getPreviousSpanContext().getSpanId())\n+                .collect(Collectors.toList());\n+\n+        assertThat(producedSpanContexts.stream()\n+                .map(SpanContext::getSpanId)).containsExactlyElementsOf(parentIds);\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            assertThat(data.getSpanId()).isIn(spanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getKind()).isEqualByComparingTo(CONSUMER);\n+            assertThat(data.getParentSpanId()).isNotNull();\n+            assertThat(data.getParentSpanId()).isIn(parentIds);\n+        }\n+    }\n+\n+    @Test\n+    public void testFromKafkaToAppWithNoParent() {\n+        KafkaUsage usage = new KafkaUsage();\n+        deploy(getKafkaSinkConfigForMyAppReceivingData(\"no-parent-stuff\"), MyAppReceivingData.class);\n+\n+        AtomicInteger count = new AtomicInteger();\n+        MyAppReceivingData bean = container.getBeanManager().createInstance().select(MyAppReceivingData.class).get();\n+\n+        usage.produceIntegers(10, null,\n+                () -> new ProducerRecord<>(\"no-parent-stuff\", null, null, \"a-key\", count.getAndIncrement()));\n+\n+        await().until(() -> bean.list().size() >= 10);\n+        assertThat(bean.list()).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+\n+        assertThat(bean.tracing()).hasSizeGreaterThanOrEqualTo(10);\n+        assertThat(bean.tracing()).doesNotContainNull().doesNotHaveDuplicates();\n+        List<SpanId> spanIds = new ArrayList<>();\n+\n+        for (TracingMetadata tracing : bean.tracing()) {\n+            spanIds.add(tracing.getCurrentSpanContext().getSpanId());\n+            assertThat(tracing.getPreviousSpanContext()).isNull();\n+        }\n+\n+        assertThat(spanIds).doesNotContainNull().doesNotHaveDuplicates().hasSizeGreaterThanOrEqualTo(10);\n+\n+        for (SpanData data : testExporter.getFinishedSpanItems()) {\n+            assertThat(data.getSpanId()).isIn(spanIds);\n+            assertThat(data.getSpanId()).isNotEqualByComparingTo(data.getParentSpanId());\n+            assertThat(data.getKind()).isEqualByComparingTo(CONSUMER);\n+            assertThat(data.getParentSpanId().isValid()).isFalse();\n+        }\n+    }\n+\n+    private Iterable<Header> createTracingSpan(List<SpanContext> spanContexts, String topic) {\n+        RecordHeaders proposedHeaders = new RecordHeaders();\n+        final Span span = KafkaConnector.TRACER.spanBuilder(topic).setSpanKind(PRODUCER).startSpan();\n+        final Context context = withSpan(span, Context.current());\n+        OpenTelemetry.getPropagators()\n+                .getHttpTextFormat()\n+                .inject(context, proposedHeaders, (headers, key, value) -> {\n+                    if (headers != null) {\n+                        headers.remove(key).add(key, value.getBytes(StandardCharsets.UTF_8));\n+                    }\n+                });\n+        spanContexts.add(span.getContext());\n+        return proposedHeaders;\n+    }\n+\n+    private <T> void deploy(MapBasedConfig config, Class<T> clazz) {\n+        if (config != null) {\n+            config.write();\n+        } else {\n+            MapBasedConfig.clear();\n+        }\n+\n+        Weld weld = baseWeld();\n+        weld.addBeanClass(clazz);\n+\n+        container = weld.initialize();\n+    }\n+\n+    private MapBasedConfig getKafkaSinkConfigForMyAppGeneratingData() {\n+        String prefix = \"mp.messaging.outgoing.kafka.\";\n+        Map<String, Object> config = new HashMap<>();\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.serializer\", IntegerSerializer.class.getName());\n+        config.put(prefix + \"topic\", \"output\");\n+        return new MapBasedConfig(config);\n+    }\n+\n+    private MapBasedConfig getKafkaSinkConfigForMyAppProcessingData() {\n+        String prefix = \"mp.messaging.outgoing.kafka.\";\n+        Map<String, Object> config = new HashMap<>();\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.serializer\", IntegerSerializer.class.getName());\n+        config.put(prefix + \"topic\", \"result-topic\");\n+\n+        prefix = \"mp.messaging.incoming.source.\";\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.deserializer\", IntegerDeserializer.class.getName());\n+        config.put(prefix + \"key.deserializer\", StringDeserializer.class.getName());\n+        config.put(prefix + \"topic\", \"some-topic\");\n+        config.put(prefix + \"auto.offset.reset\", \"earliest\");\n+\n+        return new MapBasedConfig(config);\n+    }\n+\n+    private MapBasedConfig getKafkaSinkConfigForMyAppReceivingData(String topic) {\n+        Map<String, Object> config = new HashMap<>();\n+\n+        String prefix = \"mp.messaging.incoming.stuff.\";\n+        config.put(prefix + \"connector\", KafkaConnector.CONNECTOR_NAME);\n+        config.put(prefix + \"value.deserializer\", IntegerDeserializer.class.getName());\n+        config.put(prefix + \"key.deserializer\", StringDeserializer.class.getName());\n+        config.put(prefix + \"topic\", topic);\n+        config.put(prefix + \"auto.offset.reset\", \"earliest\");\n+\n+        return new MapBasedConfig(config);\n+    }\n+\n+    @ApplicationScoped\n+    public static class MyAppGeneratingData {\n+\n+        @Outgoing(\"kafka\")\n+        public Flowable<Integer> source() {\n+            return Flowable.range(0, 10);\n+        }\n+    }\n+\n+    @ApplicationScoped\n+    public static class MyAppProcessingData {\n+\n+        @Incoming(\"source\")\n+        @Outgoing(\"kafka\")\n+        public Message<Integer> processMessage(Message<Integer> input) {\n+            return input.withPayload(input.getPayload() + 1);\n+        }\n+    }\n+\n+    @ApplicationScoped\n+    public static class MyAppReceivingData {\n+        private List<TracingMetadata> tracingMetadata = new ArrayList<>();\n+        private List<Integer> results = new CopyOnWriteArrayList<>();", "originalCommit": "b8e755370fa58767e50ac58eeac6b3ab80d0087a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "87fe25b0548205127cef80d6f4f8d1a1df3cc92b", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/87fe25b0548205127cef80d6f4f8d1a1df3cc92b", "message": "Initial OpenTelemetry work", "committedDate": "2020-08-25T14:02:18Z", "type": "commit"}, {"oid": "c655294dc64890e90088f73265b69235e7aa606c", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/c655294dc64890e90088f73265b69235e7aa606c", "message": "Updates based on PR feedback", "committedDate": "2020-08-25T14:02:21Z", "type": "commit"}, {"oid": "9f438b75396a17289913d4ac41a423c5fbd491b4", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/9f438b75396a17289913d4ac41a423c5fbd491b4", "message": "Disable tracing in non tracing tests", "committedDate": "2020-08-25T14:02:21Z", "type": "commit"}, {"oid": "d0bc7cbf2d6dbb238ed9a90c58b194b3050e4ba4", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/d0bc7cbf2d6dbb238ed9a90c58b194b3050e4ba4", "message": "Disable tracing in non tracing tests", "committedDate": "2020-08-25T14:03:00Z", "type": "commit"}, {"oid": "23848eed7d98766607a08b6636f5472e97625723", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/23848eed7d98766607a08b6636f5472e97625723", "message": "Update to OTeL 0.7.1 and use new SemanticAttributes", "committedDate": "2020-08-25T14:03:03Z", "type": "commit"}, {"oid": "b9c298550d2387d3efcfc8a25f6ae9eeebdba3a7", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/b9c298550d2387d3efcfc8a25f6ae9eeebdba3a7", "message": "Updates for rebasing on Cloud Events and based on PR feedback", "committedDate": "2020-08-25T18:09:46Z", "type": "commit"}, {"oid": "b9c298550d2387d3efcfc8a25f6ae9eeebdba3a7", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/b9c298550d2387d3efcfc8a25f6ae9eeebdba3a7", "message": "Updates for rebasing on Cloud Events and based on PR feedback", "committedDate": "2020-08-25T18:09:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI3MTE3NQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r479271175", "bodyText": "The signature looks weird getTracingEnabled() it could be .isTracingEnabled()?", "author": "pavolloffay", "createdAt": "2020-08-28T13:08:47Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -264,6 +275,36 @@ public synchronized void reportFailure(Throwable failure) {\n         failures.add(failure);\n     }\n \n+    public void incomingTrace(IncomingKafkaRecord<K, V> kafkaRecord) {\n+        if (configuration.getTracingEnabled()) {", "originalCommit": "b9c298550d2387d3efcfc8a25f6ae9eeebdba3a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTMxMDAzNg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/659#discussion_r479310036", "bodyText": "I think that's just how the methods are generated, as it's not manually coded", "author": "kenfinnigan", "createdAt": "2020-08-28T13:50:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI3MTE3NQ=="}], "type": "inlineReview"}]}