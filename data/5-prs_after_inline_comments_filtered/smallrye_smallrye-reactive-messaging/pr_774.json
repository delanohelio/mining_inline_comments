{"pr_number": 774, "pr_title": "Improve the latest commit strategy", "pr_createdAt": "2020-09-23T19:22:15Z", "pr_url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM3NTA0NQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494375045", "bodyText": "offsets isn't threadsafe. The user might call the Message#ack method inside  a worker thread. It's the reason why on the Throttled strategy we run the handle code inside the context's event thread.", "author": "pcasaes", "createdAt": "2020-09-24T14:40:32Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaLatestCommit.java", "diffHunk": "@@ -18,13 +23,33 @@\n public class KafkaLatestCommit implements KafkaCommitHandler {\n \n     private final KafkaConsumer<?, ?> consumer;\n+    private final Map<TopicPartition, Long> offsets = new HashMap<>();\n \n-    public KafkaLatestCommit(KafkaConsumer<?, ?> consumer) {\n-        this.consumer = consumer;\n+    public KafkaLatestCommit(io.vertx.mutiny.kafka.client.consumer.KafkaConsumer<?, ?> consumer) {\n+        this.consumer = (KafkaConsumer<?, ?>) consumer.getDelegate();\n     }\n \n     @Override\n     public <K, V> CompletionStage<Void> handle(IncomingKafkaRecord<K, V> record) {\n-        return consumer.commit().subscribeAsCompletionStage();\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+        Map<TopicPartition, OffsetAndMetadata> map = new HashMap<>();\n+        TopicPartition key = new TopicPartition(record.getTopic(), record.getPartition());\n+        Long last = offsets.get(key);\n+        // Verify that the latest committed offset before this one.\n+        if (last == null || last < record.getOffset() + 1) {\n+            offsets.put(key, record.getOffset() + 1);", "originalCommit": "37ce2975c49568828b6c3cbadb9ae2ccfc834bd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ4ODY4NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494488684", "bodyText": "Fixed.", "author": "cescoffier", "createdAt": "2020-09-24T17:26:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM3NTA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM3OTYxNw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494379617", "bodyText": "This has always bothered me about this strategy. Committing on every message causes High load on the cluster. Maybe we should add a warning to the documentation.\nAlso, what's the implication of completing exceptionally here?", "author": "pcasaes", "createdAt": "2020-09-24T14:46:25Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaLatestCommit.java", "diffHunk": "@@ -18,13 +23,33 @@\n public class KafkaLatestCommit implements KafkaCommitHandler {\n \n     private final KafkaConsumer<?, ?> consumer;\n+    private final Map<TopicPartition, Long> offsets = new HashMap<>();\n \n-    public KafkaLatestCommit(KafkaConsumer<?, ?> consumer) {\n-        this.consumer = consumer;\n+    public KafkaLatestCommit(io.vertx.mutiny.kafka.client.consumer.KafkaConsumer<?, ?> consumer) {\n+        this.consumer = (KafkaConsumer<?, ?>) consumer.getDelegate();\n     }\n \n     @Override\n     public <K, V> CompletionStage<Void> handle(IncomingKafkaRecord<K, V> record) {\n-        return consumer.commit().subscribeAsCompletionStage();\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+        Map<TopicPartition, OffsetAndMetadata> map = new HashMap<>();\n+        TopicPartition key = new TopicPartition(record.getTopic(), record.getPartition());\n+        Long last = offsets.get(key);\n+        // Verify that the latest committed offset before this one.\n+        if (last == null || last < record.getOffset() + 1) {\n+            offsets.put(key, record.getOffset() + 1);\n+            map.put(key, new OffsetAndMetadata(record.getOffset() + 1, null));\n+\n+            consumer.commit(map, ar -> {\n+                if (ar.failed()) {\n+                    future.completeExceptionally(ar.cause());\n+                } else {\n+                    future.complete(null);\n+                }\n+            });", "originalCommit": "37ce2975c49568828b6c3cbadb9ae2ccfc834bd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ3Mjc4Nw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494472787", "bodyText": "it's actually better than the previous one that was committing on every message, every subscribed topic/partition. At least this one tracks the message more carefully. I've updated the doc.\nBefore switching to the throttled by default (which is the objective), we must do a lot more tests. Typically, it does not commit on application shutdown.\nAbout the completeExceptionally, if the commit fails, the failure is propagated downstream and mark the application as failed.", "author": "cescoffier", "createdAt": "2020-09-24T16:59:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM3OTYxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ4ODc1NQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494488755", "bodyText": "Fixed.", "author": "cescoffier", "createdAt": "2020-09-24T17:26:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM3OTYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM4MDcxMg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494380712", "bodyText": "Very nice!", "author": "pcasaes", "createdAt": "2020-09-24T14:47:45Z", "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/commit/CommitStrategiesTest.java", "diffHunk": "@@ -0,0 +1,310 @@\n+package io.smallrye.reactive.messaging.kafka.commit;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.lang.reflect.Field;\n+import java.util.*;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Instance;\n+import javax.enterprise.inject.UnsatisfiedResolutionException;\n+import javax.enterprise.inject.spi.DeploymentException;\n+import javax.inject.Named;\n+\n+import io.smallrye.reactive.messaging.kafka.IncomingKafkaRecordMetadata;\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.MockConsumer;\n+import org.apache.kafka.clients.consumer.OffsetAndMetadata;\n+import org.apache.kafka.clients.consumer.OffsetResetStrategy;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.reactive.messaging.kafka.KafkaConnectorIncomingConfiguration;\n+import io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener;\n+import io.smallrye.reactive.messaging.kafka.base.MapBasedConfig;\n+import io.smallrye.reactive.messaging.kafka.base.WeldTestBase;\n+import io.smallrye.reactive.messaging.kafka.impl.KafkaSource;\n+import io.vertx.kafka.client.consumer.KafkaReadStream;\n+import io.vertx.mutiny.core.Vertx;\n+import io.vertx.mutiny.kafka.client.consumer.KafkaConsumer;\n+\n+public class CommitStrategiesTest extends WeldTestBase {", "originalCommit": "37ce2975c49568828b6c3cbadb9ae2ccfc834bd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM4NTA2Mw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494385063", "bodyText": "Very happy with this. Will allow much fine-grain testing, but Man... that's definitely undocumented.\nAlso, rebalance do not calls the callbacks... It's a TODO in their code :-)", "author": "cescoffier", "createdAt": "2020-09-24T14:53:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM4MDcxMg=="}], "type": "inlineReview"}, {"oid": "37f6ba5c88f4976c590965584fdf01ed3cb4959b", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/37f6ba5c88f4976c590965584fdf01ed3cb4959b", "message": "Fix the latest commit strategy - commit the offset from the received message and keep track to not commit previous offset.", "committedDate": "2020-09-24T17:25:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU3NDczMg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494574732", "bodyText": "Why would it run on another context? Doesn't vert.x assure that the timer runs on the same context it was created on?", "author": "pcasaes", "createdAt": "2020-09-24T19:55:47Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -158,27 +160,37 @@ private void startFlushAndCheckHealthTimer() {\n \n     }\n \n-    private void flushAndCheckHealth(long timerId) {\n-        Map<TopicPartition, Long> offsetsMapping = clearLesserSequentiallyProcessedOffsetsAndReturnLargestOffsetMapping();\n-\n-        if (!offsetsMapping.isEmpty()) {\n-            Map<TopicPartition, OffsetAndMetadata> offsets = offsetsMapping\n-                    .entrySet()\n-                    .stream()\n-                    .collect(Collectors.toMap(Map.Entry::getKey,\n-                            e -> new OffsetAndMetadata().setOffset(e.getValue() + 1L)));\n-            consumer.getDelegate().commit(offsets, a -> this.startFlushAndCheckHealthTimer());\n-        } else {\n-            this.startFlushAndCheckHealthTimer();\n+    private synchronized Context getContext() {\n+        if (context == null) {\n+            context = vertx.getOrCreateContext();\n         }\n+        return context;\n+    }\n+\n+    private void flushAndCheckHealth(long timerId) {\n+        // The timer may be on another context, so make sure we are on the right one to access the store.", "originalCommit": "37f6ba5c88f4976c590965584fdf01ed3cb4959b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2NTkwMw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494765903", "bodyText": "It only ensures it's the same event loop if the timer is created from an event loop, which here is not necessarily the case (if the timer is created from another event loop or from a regular thread). So, it's safer to just store a context and enforce we always run on it.", "author": "cescoffier", "createdAt": "2020-09-25T06:05:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU3NDczMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2NjI4NQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494766285", "bodyText": "A possible optimization would be a trampoline: check if we are on the context already and if so run immediately, if not, run on context. Let me add that.", "author": "cescoffier", "createdAt": "2020-09-25T06:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU3NDczMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3MjIzNQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494772235", "bodyText": "Actually, you are right, got confused with my multiple branches. In this one, no need to check as the partitionAssigned method is still called from the event loop (which is something we MUST change - and I've another branch where I started this).", "author": "cescoffier", "createdAt": "2020-09-25T06:24:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU3NDczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcxOTU2MA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494719560", "bodyText": "I ran a test locally on a project and it works perfectly!\nI do have one final suggestion. context here is loaded only once, so using a lock every time we acquire seems heavy handed. What do you think about using a double checked lock? We would have to change context to be volatile on line 51\nprivate volatile Context context;\n\nAnd then rewrite this method\n    private Context getContext() {\n        Context ctx = this.context;\n        if (ctx == null) {\n            synchronized (this) {\n                ctx = this.context;\n                if (ctx == null) {\n                    this.context = ctx = vertx.getOrCreateContext();\n                }\n            }\n        }\n        return ctx;\n    }\n\nWe could do the same with the latest strategy - maybe even abstract it to reduce duplicate code.\nTheoretically we would see a 100x performance gain.", "author": "pcasaes", "createdAt": "2020-09-25T02:59:04Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/KafkaThrottledLatestProcessedCommit.java", "diffHunk": "@@ -158,27 +160,37 @@ private void startFlushAndCheckHealthTimer() {\n \n     }\n \n-    private void flushAndCheckHealth(long timerId) {\n-        Map<TopicPartition, Long> offsetsMapping = clearLesserSequentiallyProcessedOffsetsAndReturnLargestOffsetMapping();\n-\n-        if (!offsetsMapping.isEmpty()) {\n-            Map<TopicPartition, OffsetAndMetadata> offsets = offsetsMapping\n-                    .entrySet()\n-                    .stream()\n-                    .collect(Collectors.toMap(Map.Entry::getKey,\n-                            e -> new OffsetAndMetadata().setOffset(e.getValue() + 1L)));\n-            consumer.getDelegate().commit(offsets, a -> this.startFlushAndCheckHealthTimer());\n-        } else {\n-            this.startFlushAndCheckHealthTimer();\n+    private synchronized Context getContext() {\n+        if (context == null) {\n+            context = vertx.getOrCreateContext();\n         }\n+        return context;\n+    }", "originalCommit": "37f6ba5c88f4976c590965584fdf01ed3cb4959b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk4NTgzNA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494985834", "bodyText": "Fixed.", "author": "cescoffier", "createdAt": "2020-09-25T13:26:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcxOTU2MA=="}], "type": "inlineReview"}, {"oid": "734be1be05620cda1fae39b070656e1169d414e9", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/734be1be05620cda1fae39b070656e1169d414e9", "message": "Improve context management in commit strategies", "committedDate": "2020-09-25T07:22:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk5MDA3OQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494990079", "bodyText": "Very nice!!!!", "author": "pcasaes", "createdAt": "2020-09-25T13:32:53Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/ContextHolder.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package io.smallrye.reactive.messaging.kafka.commit;\n+\n+import io.vertx.mutiny.core.Context;\n+import io.vertx.mutiny.core.Vertx;\n+\n+/**\n+ * A class holding a vert.x context to make sure methods are always run from the same one.\n+ */\n+public class ContextHolder {", "originalCommit": "734be1be05620cda1fae39b070656e1169d414e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk5ODI0NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r494998244", "bodyText": "This pattern comes from\nhttps://www.oracle.com/technical-resources/articles/javase/bloch-effective-08-qa.html\nUnder: Best Practices for Lazy Initialization\nIt's also referenced in Java Concurrency in Practice by Goetz et al in section 16.2.4\n\nSubsequent changes in the JMM... have enabled DLC to work if resource is made volatile.", "author": "pcasaes", "createdAt": "2020-09-25T13:45:34Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/commit/ContextHolder.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package io.smallrye.reactive.messaging.kafka.commit;\n+\n+import io.vertx.mutiny.core.Context;\n+import io.vertx.mutiny.core.Vertx;\n+\n+/**\n+ * A class holding a vert.x context to make sure methods are always run from the same one.\n+ */\n+public class ContextHolder {\n+\n+    protected final Vertx vertx;\n+    protected volatile Context context;\n+\n+    public ContextHolder(Vertx vertx) {\n+        this.vertx = vertx;\n+    }\n+\n+    public Context getContext() {\n+        Context ctx = this.context;\n+        if (ctx == null) {\n+            synchronized (this) {\n+                ctx = this.context;\n+                if (ctx == null) {\n+                    this.context = ctx = vertx.getOrCreateContext();\n+                }\n+            }\n+        }\n+        return ctx;\n+    }", "originalCommit": "734be1be05620cda1fae39b070656e1169d414e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAwMDk4Ng==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r495000986", "bodyText": "Oh, I know the pattern, it was just late at night :-D\nI isolated it into its own class, so we can reuse the pattern.\nGoing to be fun with the rebalance listener not called on the event loop anymore...", "author": "cescoffier", "createdAt": "2020-09-25T13:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk5ODI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAwNDcwNg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r495004706", "bodyText": "I have no doubt you knew :D\nBut I assume others might read this.", "author": "pcasaes", "createdAt": "2020-09-25T13:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk5ODI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAwNTU1Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r495005552", "bodyText": "Going to be fun with the rebalance listener not called on the event loop anymore...\n\nYes! Haven't looked at your draft PR yet.", "author": "pcasaes", "createdAt": "2020-09-25T13:56:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk5ODI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAwNjg2Ng==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/774#discussion_r495006866", "bodyText": "I also admit to having used the DLC before Java 5. I was younger and naive \ud83e\udd23", "author": "pcasaes", "createdAt": "2020-09-25T13:58:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk5ODI0NA=="}], "type": "inlineReview"}, {"oid": "58cf91ec37836642d53fdf8abb11d2a8047ceba7", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/58cf91ec37836642d53fdf8abb11d2a8047ceba7", "message": "If not started, start the vert.x timer on message reception.", "committedDate": "2020-09-25T13:54:20Z", "type": "commit"}, {"oid": "fc8b6427c62b6fd075a580d8e8d4cbc786556494", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/fc8b6427c62b6fd075a580d8e8d4cbc786556494", "message": "Filter out unknown properties", "committedDate": "2020-09-25T13:56:11Z", "type": "commit"}, {"oid": "7733c1303d6532ea0b8ce2970310547821ffacb4", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/7733c1303d6532ea0b8ce2970310547821ffacb4", "message": "Fix the latest commit strategy - commit the offset from the received message and keep track to not commit previous offset.", "committedDate": "2020-09-25T13:57:36Z", "type": "commit"}, {"oid": "615e4648405e038462d53d144204f0f2d86bf794", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/615e4648405e038462d53d144204f0f2d86bf794", "message": "Improve context management in commit strategies", "committedDate": "2020-09-25T13:57:38Z", "type": "commit"}, {"oid": "615e4648405e038462d53d144204f0f2d86bf794", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/615e4648405e038462d53d144204f0f2d86bf794", "message": "Improve context management in commit strategies", "committedDate": "2020-09-25T13:57:38Z", "type": "forcePushed"}]}