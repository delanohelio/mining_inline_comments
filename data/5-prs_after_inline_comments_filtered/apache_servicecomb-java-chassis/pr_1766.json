{"pr_number": 1766, "pr_title": "[SCB-1922] implemented core logic of zero-config registry", "pr_createdAt": "2020-05-20T00:21:01Z", "pr_url": "https://github.com/apache/servicecomb-java-chassis/pull/1766", "timeline": [{"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931", "url": "https://github.com/apache/servicecomb-java-chassis/commit/bfeca6e794add76bc7216c490d93af6b20fe5931", "message": "[SCB-1922] implemented core logic of zero-config registry", "committedDate": "2020-05-19T23:55:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5MzQxMg==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427693412", "bodyText": "This line is too long. use etc/*xml code template to format files.", "author": "liubao68", "createdAt": "2020-05-20T01:38:02Z", "path": "service-registry/registry-zero-config/src/test/java/org/apache/servicecomb/serviceregistry/client/TestZeroConfigRegistryClientImpl.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry.client;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n+import org.apache.servicecomb.serviceregistry.api.response.HeartbeatResponse;\n+import org.apache.servicecomb.serviceregistry.client.http.MicroserviceInstances;\n+import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n+import org.mockito.Mock;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.INSTANCE_ID;\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.SCHEMA_CONTENT_ENDPOINT_BASE_PATH;\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD;\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.SCHEMA_CONTENT_ENDPOINT_SUBPATH;\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.INSTANCE_HEARTBEAT_RESPONSE_MESSAGE_OK;\n+import static org.mockito.Matchers.anyObject;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n+import org.apache.servicecomb.serviceregistry.server.ZeroConfigRegistryService;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.MockitoAnnotations;\n+import org.springframework.web.client.RestTemplate;\n+\n+import java.io.IOException;\n+import java.net.MulticastSocket;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public class TestZeroConfigRegistryClientImpl {\n+\n+    ZeroConfigRegistryClientImpl target;\n+\n+    @Mock\n+    ZeroConfigRegistryService zeroConfigRegistryService;\n+\n+    @Mock\n+    MulticastSocket multicastSocket;\n+\n+    @Mock\n+    RestTemplate restTemplate;\n+\n+    // testing data\n+    String selfServiceId = \"123\";\n+    String selfInstanceId = \"instanceId\";\n+    String otherServiceId = \"456\";\n+    String appId = \"appId\";\n+    String serviceName = \"serviceName\";\n+    String version = \"0.0.0.1\";\n+    String status = \"UP\";\n+    String host = \"host\";\n+    String schemaId1 = \"schemaId1\";\n+    String schemaContent1 = \"schemaContent1\";\n+    String newSchemaId = \"newSchemaId\";\n+    String newSchemaContent = \"newSchemaContent\";\n+    String nonExistSchemaId = \"nonExistSchemaId\";\n+    String endpoint1 = \"endpoint1\";\n+    String strVersionRule = \"0.0.0.0+\";\n+\n+    @Before\n+    public void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+        target = new ZeroConfigRegistryClientImpl(zeroConfigRegistryService, multicastSocket, restTemplate);\n+    }\n+\n+    private Microservice prepareService(String serviceId, boolean withId){\n+        Microservice microservice = new Microservice();\n+        if (withId){\n+            microservice.setServiceId(serviceId);\n+        }\n+        microservice.setServiceName(serviceName);\n+        microservice.setAppId(appId);\n+        microservice.setVersion(version);\n+        microservice.setStatus(status);\n+        List<String> schemas = new ArrayList<>();\n+        schemas.add(schemaId1);\n+        microservice.setSchemas(schemas);\n+        microservice.addSchema(schemaId1, schemaContent1);\n+        return microservice;\n+    }\n+\n+    private MicroserviceInstance prepareInstance(String instanceId, boolean withId){\n+        MicroserviceInstance instance = new MicroserviceInstance();\n+        if (withId){\n+            instance.setInstanceId(instanceId);\n+        }\n+        instance.setServiceId(selfServiceId);\n+        List<String> endpointList = new ArrayList<>();\n+        endpointList.add(endpoint1);\n+        instance.setEndpoints(endpointList);\n+        instance.setStatus(MicroserviceInstanceStatus.UP);\n+        instance.setHostName(host);\n+        return instance;\n+    }\n+\n+    private ServerMicroserviceInstance prepareServerServiceInstance(boolean withEndpoint){\n+        ServerMicroserviceInstance serverServiceInstance = new ServerMicroserviceInstance();\n+        serverServiceInstance.setServiceId(otherServiceId);\n+        serverServiceInstance.setInstanceId(selfInstanceId);\n+        serverServiceInstance.setServiceName(serviceName);\n+        serverServiceInstance.setAppId(appId);\n+        serverServiceInstance.setVersion(version);\n+        serverServiceInstance.setStatus(status);\n+        List<String> schemas = new ArrayList<>();\n+        schemas.add(schemaId1);\n+        serverServiceInstance.setSchemas(schemas);\n+        if (withEndpoint) {\n+            List<String> endpointList = new ArrayList<>();\n+            endpointList.add(endpoint1);\n+            serverServiceInstance.setEndpoints(endpointList);\n+        }\n+        serverServiceInstance.setHostName(host);\n+        return serverServiceInstance;\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+\n+    }\n+\n+    @Test\n+    public void test_registerMicroservice_withID_shouldReturnSameID(){\n+        Microservice selfService = prepareService(selfServiceId, true);\n+        ClientUtil.microserviceSelf = selfService;\n+\n+        String returnedServiceId = target.registerMicroservice(selfService);\n+\n+        Assert.assertEquals(selfServiceId, returnedServiceId);\n+    }\n+\n+    @Test\n+    public void test_registerMicroservice_withoutID_shouldReturnGeneratedID(){\n+        Microservice serviceWithoutID = prepareService(selfServiceId, false);\n+        ClientUtil.microserviceSelf = serviceWithoutID;\n+\n+        String returnedServiceId = target.registerMicroservice(serviceWithoutID);\n+\n+        Assert.assertEquals(ClientUtil.generateServiceId(serviceWithoutID), returnedServiceId);\n+    }\n+\n+    @Test\n+    public void test_getMicroservice_forItself_shouldReturnItself_And_NotCallZeroConfigRegistryService (){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);;\n+\n+        Microservice microservice = target.getMicroservice(selfServiceId);\n+\n+        Assert.assertEquals(microservice.getServiceId(), ClientUtil.microserviceSelf.getServiceId());\n+        verifyZeroInteractions(zeroConfigRegistryService);\n+    }\n+\n+    @Test\n+    public void test_getMicroservice_forItself_shouldReturnOtherService_And_CallZeroConfigRegistryService (){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+\n+        when(zeroConfigRegistryService.getMicroservice(otherServiceId)).thenReturn(prepareServerServiceInstance(true));\n+\n+        Microservice returnedMicroservice = target.getMicroservice(otherServiceId);\n+\n+        Assert.assertEquals(otherServiceId, returnedMicroservice.getServiceId());\n+        verify(zeroConfigRegistryService, times(1)).getMicroservice(otherServiceId);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void test_isSchemaExist_whenServiceIdIsNull_shouldThrowIllegalArgumentException(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, false);\n+\n+        target.isSchemaExist(selfServiceId, schemaId1);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void test_isSchemaExist_whenServiceIdIsNotItselfId_shouldThrowIllegalArgumentException(){\n+        ClientUtil.microserviceSelf = prepareService(otherServiceId, true);\n+\n+        target.isSchemaExist(selfServiceId, schemaId1);\n+    }\n+\n+    @Test\n+    public void test_isSchemaExist_whenServiceIdIsItselfId_shouldReturnTrue(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+\n+        boolean returnedResult = target.isSchemaExist(selfServiceId, schemaId1);\n+        Assert.assertTrue(returnedResult);\n+    }\n+\n+    @Test\n+    public void test_isSchemaExist_whenSchemaNotExist_shouldReturnFalse(){\n+        ClientUtil.microserviceSelf =  prepareService(selfServiceId, true);\n+\n+        boolean returnedResult = target.isSchemaExist(selfServiceId, nonExistSchemaId);\n+        Assert.assertFalse(returnedResult);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void test_registerSchema_whenServiceIdIsNull_shouldThrowIllegalArgumentException(){\n+        ClientUtil.microserviceSelf =  prepareService(selfServiceId, false);\n+\n+        target.registerSchema(selfServiceId, schemaId1, schemaContent1);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void test_registerSchema_whenServiceIdIsNotItSelfId_shouldThrowIllegalArgumentException(){\n+        ClientUtil.microserviceSelf =  prepareService(selfServiceId, true);\n+\n+        target.registerSchema(otherServiceId, schemaId1, schemaContent1);\n+    }\n+\n+    @Test\n+    public void test_registerSchema_whenReigsterForItself_shouldSuceed(){\n+        ClientUtil.microserviceSelf =  prepareService(selfServiceId, true);\n+\n+        boolean returnedResult = target.registerSchema(selfServiceId, newSchemaId, newSchemaContent);\n+        Assert.assertTrue(returnedResult);\n+        Assert.assertEquals(newSchemaContent, ClientUtil.microserviceSelf.getSchemaMap().computeIfPresent(newSchemaId, (k, v) -> {\n+            return v;\n+        }));\n+    }\n+\n+    @Test\n+    public void test_getSchema_whenForSelfMicroservice_shouldSuceed(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+\n+        String returnedSchemaContent = target.getSchema(selfServiceId, schemaId1);\n+        Assert.assertEquals(schemaContent1, returnedSchemaContent);\n+    }\n+\n+    @Test\n+    public void test_getSchema_whenForSelfMicroservice_shouldNotCallZeroConfigRegistryServiceAndSucceed(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+\n+        String returnedSchemaContent = target.getSchema(selfServiceId, schemaId1);\n+\n+        Assert.assertEquals(schemaContent1, returnedSchemaContent);\n+        verifyZeroInteractions(zeroConfigRegistryService);\n+    }\n+\n+    @Test\n+    public void test_getSchema_whenForOtherMicroservice_shouldCallZeroConfigRegistryService(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+        when(zeroConfigRegistryService.getMicroservice(otherServiceId)).thenReturn(prepareServerServiceInstance(true));\n+        String schemaContentEndpoint = endpoint1 + SCHEMA_CONTENT_ENDPOINT_BASE_PATH + SCHEMA_CONTENT_ENDPOINT_SUBPATH + \"?\" + SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD + \"=\" + schemaId1;", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwODA0Mg==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427708042", "bodyText": "after removing those \"long\" constant\uff0c now. it's much shorter:)", "author": "jungan21", "createdAt": "2020-05-20T02:33:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5MzQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NDM4OQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427694389", "bodyText": "Suggestions: path and name only used in endpoints, I think use literal is more readable than using a constant, we can easly get what's the url and param from method signature without a code jump.", "author": "liubao68", "createdAt": "2020-05-20T01:41:54Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwNzkxNA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427707914", "bodyText": "sure. cleared those constant", "author": "jungan21", "createdAt": "2020-05-20T02:33:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NDM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NDU5OQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427694599", "bodyText": "Suggestions: package name can rename to org.apache.serviecomb.zeroconfig", "author": "liubao68", "createdAt": "2020-05-20T01:42:38Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwNzgyOA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427707828", "bodyText": "agree. will renmae package naeme", "author": "jungan21", "createdAt": "2020-05-20T02:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NDU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODkxNQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427698915", "bodyText": "better to use JAX-RS annotation, because not all project depend on swagger-generator-springmvc", "author": "wujimin", "createdAt": "2020-05-20T01:58:40Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwODcxNA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427708714", "bodyText": "I see. thx for the reminder, Since I tested for Spingmvc version already.  I will make this change to JAX-RS version in next PR. thx", "author": "jungan21", "createdAt": "2020-05-20T02:36:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxNjE5MQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r428916191", "bodyText": "I tried with pure JAX-RS annotation today It seems our swagger generator has issue for processing JAX-RS @QueryParam and @PathParam.  When there is no path parameter annotation, it's OK. Below please find the details.\n**1. Error when parsing JAX-RS @QueryParam annotation to take in query parameter. I\n\n@RestSchema(schemaId = \"schemaContentEndpoint\")\n@Path(\"/schemaEndpoint\")\n@Produces(MediaType.TEXT_PLAIN)\npublic class SchemaContentEndpoint {\n\n    @Path(\"/schemas\")\n    @GET\n    public String getSchemaEndpoint(**@QueryParam**(\"schemaId\") String schemaId) {\n        Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();\n        return schemaMap.get(schemaId);\n    }\n}\n\nError message:\nCaused by: java.lang.IllegalStateException: parameter name is not present, method=org.apache.servicecomb.zeroconfigsc.SchemaContentEndpoint:getSchemaEndpoint\nsolution:\n  change pom.xml, add compiler argument: -parameters, for example:\n    <plugin>\n      <groupId>org.apache.maven.plugins</groupId>\n      <artifactId>maven-compiler-plugin</artifactId>\n      <configuration>\n        <compilerArgument>-parameters</compilerArgument>\n      </configuration>\n    </plugin>\n\tat org.apache.servicecomb.swagger.generator.SwaggerGeneratorUtils.collectParameterName(SwaggerGeneratorUtils.java:192)\n\tat org.apache.servicecomb.swagger.generator.ParameterGenerator.<init>(ParameterGenerator.java:55)\n\tat org.apache.servicecomb.swagger.generator.ParameterGenerator.<init>(ParameterGenerator.java:66)\n\tat org.apache.servicecomb.swagger.generator.core.AbstractOperationGenerator.initMethodParameterGenerators(AbstractOperationGenerator.java:230)\n\nBTW, if I replace @QueryParam with SpringMVC @RequestParameter, it works fine. Also If I remove @QueryParam, it works fine too.\nBased on the error message, it seems name attribute is required for swagger generator to be able to process/parse the Annotation.\n`", "author": "jungan21", "createdAt": "2020-05-21T21:09:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwMjk4NA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427702984", "bodyText": "seems http method should be GET", "author": "wujimin", "createdAt": "2020-05-20T02:14:11Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwNzczNA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427707734", "bodyText": "yup . agree", "author": "jungan21", "createdAt": "2020-05-20T02:32:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwMjk4NA=="}], "type": "inlineReview"}, {"oid": "76a8c3b1476c2298ae039e32884b37247348eccd", "url": "https://github.com/apache/servicecomb-java-chassis/commit/76a8c3b1476c2298ae039e32884b37247348eccd", "message": "[SCB-1922] Address review comments", "committedDate": "2020-05-20T02:36:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwOTI3OQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427709279", "bodyText": "utils with data is not so good\neven a utils with data, should provide a getter method, not access it directly", "author": "wujimin", "createdAt": "2020-05-20T02:38:27Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )\n+    public String getSchemaEndpoint(@RequestParam(name = SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD) String schemaId) {\n+        Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMDQ4MA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427710480", "bodyText": ":), it's eaiser for unit test", "author": "jungan21", "createdAt": "2020-05-20T02:43:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwOTI3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMDM5MA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427710390", "bodyText": "please import codestyle:  etc/intellij-java-google-style.xml\nand then reformat new code.", "author": "wujimin", "createdAt": "2020-05-20T02:43:02Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry.client;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n+import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+public class ClientUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClientUtil.class);", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMDk5NA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427710994", "bodyText": "will do . thx", "author": "jungan21", "createdAt": "2020-05-20T02:45:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMDM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMDYzNw==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427710637", "bodyText": "must new for each times?", "author": "wujimin", "createdAt": "2020-05-20T02:44:09Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry.client;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n+import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+public class ClientUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClientUtil.class);\n+\n+    private static ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+\n+    public static Microservice microserviceSelf = new Microservice();\n+\n+    public static Map<String, String> serviceInstanceMapForHeartbeat = null;\n+\n+    public static synchronized void init(){\n+        Runnable heartbeatRunnable = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (serviceInstanceMapForHeartbeat != null && !serviceInstanceMapForHeartbeat.isEmpty()){\n+                    // after first registration succeeds\n+                    try {\n+                        byte[] heartbeatEventDataBytes = serviceInstanceMapForHeartbeat.toString().getBytes();\n+                        MulticastSocket multicastSocket = new MulticastSocket();", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMjAzOQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427712039", "bodyText": "no necessary.. will make change", "author": "jungan21", "createdAt": "2020-05-20T02:49:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMDYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMTc4OA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427711788", "bodyText": "String.join(\",\", list)", "author": "wujimin", "createdAt": "2020-05-20T02:48:47Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry.client;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n+import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+public class ClientUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClientUtil.class);\n+\n+    private static ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+\n+    public static Microservice microserviceSelf = new Microservice();\n+\n+    public static Map<String, String> serviceInstanceMapForHeartbeat = null;\n+\n+    public static synchronized void init(){\n+        Runnable heartbeatRunnable = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (serviceInstanceMapForHeartbeat != null && !serviceInstanceMapForHeartbeat.isEmpty()){\n+                    // after first registration succeeds\n+                    try {\n+                        byte[] heartbeatEventDataBytes = serviceInstanceMapForHeartbeat.toString().getBytes();\n+                        MulticastSocket multicastSocket = new MulticastSocket();\n+                        multicastSocket.setLoopbackMode(false);\n+                        multicastSocket.setTimeToLive(TIME_TO_LIVE);\n+\n+                        DatagramPacket instanceDataPacket = new DatagramPacket(heartbeatEventDataBytes, heartbeatEventDataBytes.length,\n+                                InetAddress.getByName(GROUP), PORT);\n+\n+                        multicastSocket.send(instanceDataPacket);\n+                    } catch (Exception e) {\n+                        LOGGER.error(\"Failed to send heartbeat event for object: {}\", serviceInstanceMapForHeartbeat, e);\n+                    }\n+                }\n+            }\n+        };\n+        executor.scheduleAtFixedRate(heartbeatRunnable, CLIENT_DELAY, HEALTH_CHECK_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    public static Optional<Map<String, String>> convertToRegisterDataModel(String serviceId, String microserviceInstanceId,\n+                                                                           MicroserviceInstance microserviceInstance, Microservice microservice) {\n+        Map<String, String> serviceInstanceTextAttributesMap = new HashMap<>();\n+\n+        serviceInstanceTextAttributesMap.put(EVENT, REGISTER_EVENT);\n+        serviceInstanceTextAttributesMap.put(VERSION, microservice.getVersion());\n+        serviceInstanceTextAttributesMap.put(SERVICE_ID, serviceId);\n+        serviceInstanceTextAttributesMap.put(INSTANCE_ID, microserviceInstanceId);\n+        serviceInstanceTextAttributesMap.put(STATUS, microserviceInstance.getStatus().toString());\n+        serviceInstanceTextAttributesMap.put(APP_ID, microservice.getAppId());\n+        serviceInstanceTextAttributesMap.put(SERVICE_NAME, microservice.getServiceName());\n+\n+        String hostName = microserviceInstance.getHostName();\n+        serviceInstanceTextAttributesMap.put(HOST_NAME, hostName);\n+\n+        // schema1$schema2\n+        serviceInstanceTextAttributesMap.put(ENDPOINTS, convertListToString(microserviceInstance.getEndpoints()));\n+        serviceInstanceTextAttributesMap.put(SCHEMA_IDS, convertListToString(microservice.getSchemas()));\n+\n+        return Optional.of(serviceInstanceTextAttributesMap);\n+    }\n+\n+    private static String convertListToString (List<String> list){", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMzU2OA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427713568", "bodyText": "Thanks! clean code :)", "author": "jungan21", "createdAt": "2020-05-20T02:55:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMTc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMzU5NA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427713594", "bodyText": "why schemaMap can be null?", "author": "wujimin", "createdAt": "2020-05-20T02:55:56Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )\n+    public String getSchemaEndpoint(@RequestParam(name = SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD) String schemaId) {\n+        Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMzgxMA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427713810", "bodyText": "I relaized this too... can only be empy \ud83d\udc4d", "author": "jungan21", "createdAt": "2020-05-20T02:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMzU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMzgyNA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427713824", "bodyText": "schemaMap.computeIfPresent(schemaId,  (key, schemaContent) -> { return schemaContent;}) \nwhat's the difference to schemaMap.get(schemaId)", "author": "wujimin", "createdAt": "2020-05-20T02:56:58Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )\n+    public String getSchemaEndpoint(@RequestParam(name = SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD) String schemaId) {\n+        Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();\n+        return schemaMap != null ? schemaMap.computeIfPresent(schemaId,  (key, schemaContent) -> { return schemaContent;}) : null;", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxNDMwMg==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427714302", "bodyText": "will change this piece of code to the following:\n    Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();\n    return schemaMap.get(schemaId);", "author": "jungan21", "createdAt": "2020-05-20T02:59:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMzgyNA=="}], "type": "inlineReview"}, {"oid": "d708cd13939d8fcae02511228266a41868cbf013", "url": "https://github.com/apache/servicecomb-java-chassis/commit/d708cd13939d8fcae02511228266a41868cbf013", "message": "[SCB-1922] implemented core logic of zero-config registry", "committedDate": "2020-05-20T03:56:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyNDMyNw==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427824327", "bodyText": "It's better to use the same configuratioin mechansim, see: https://docs.servicecomb.io/java-chassis/zh_CN/config/general-config/\nand use a boolean value, e.g 'DynamicPropertyFacotry.getInstance().getBooleanProperty(\"servicecomb.zeroconfig.enabled\", true).get()`", "author": "liubao68", "createdAt": "2020-05-20T08:17:12Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigRegistryApplicationListener.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig;\n+\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+import org.apache.servicecomb.serviceregistry.client.ServiceRegistryClient;\n+import org.apache.servicecomb.serviceregistry.config.ServiceRegistryConfig;\n+\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ZeroConfigRegistryClientImpl;\n+import org.apache.servicecomb.zeroconfig.server.ServerUtil;\n+import org.apache.servicecomb.zeroconfig.server.ZeroConfigRegistryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.BeansException;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.context.ApplicationContextAware;\n+import org.springframework.context.ApplicationEvent;\n+import org.springframework.context.ApplicationListener;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.web.client.RestTemplate;\n+\n+import java.io.IOException;\n+import java.net.MulticastSocket;\n+import java.util.function.Function;\n+\n+/**\n+ * ZeroConfigServiceRegistryClientImpl is injected before cse application listener (order is -1000)\n+ */\n+\n+@Configuration\n+@Order(-1001)\n+public class ZeroConfigRegistryApplicationListener implements ApplicationListener<ApplicationEvent>,\n+    ApplicationContextAware {\n+\n+  private static final Logger LOGGER = LoggerFactory\n+      .getLogger(ZeroConfigRegistryApplicationListener.class);\n+\n+  private ApplicationContext applicationContext;\n+  private MulticastSocket multicastSocket;\n+\n+  @Override\n+  public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n+\n+    // same mechanism as Local registry to enable the Zero Config registry\n+    String flag = System.getProperty(ZeroConfigRegistryConstants.ZERO_CONFIG_REGISTRY_FLAG);", "originalCommit": "d708cd13939d8fcae02511228266a41868cbf013", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcwNTYzNg==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r428705636", "bodyText": "Thanks for sharing . will take a look at this mechanism", "author": "jungan21", "createdAt": "2020-05-21T14:56:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyNDMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcxODI3NQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r428718275", "bodyText": "just to be safe,I will set default value to false.... for now", "author": "jungan21", "createdAt": "2020-05-21T15:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyNDMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyOTI5NQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427829295", "bodyText": "This attrubite is set but never read", "author": "liubao68", "createdAt": "2020-05-20T08:25:12Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigRegistryApplicationListener.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig;\n+\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+import org.apache.servicecomb.serviceregistry.client.ServiceRegistryClient;\n+import org.apache.servicecomb.serviceregistry.config.ServiceRegistryConfig;\n+\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ZeroConfigRegistryClientImpl;\n+import org.apache.servicecomb.zeroconfig.server.ServerUtil;\n+import org.apache.servicecomb.zeroconfig.server.ZeroConfigRegistryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.BeansException;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.context.ApplicationContextAware;\n+import org.springframework.context.ApplicationEvent;\n+import org.springframework.context.ApplicationListener;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.web.client.RestTemplate;\n+\n+import java.io.IOException;\n+import java.net.MulticastSocket;\n+import java.util.function.Function;\n+\n+/**\n+ * ZeroConfigServiceRegistryClientImpl is injected before cse application listener (order is -1000)\n+ */\n+\n+@Configuration\n+@Order(-1001)\n+public class ZeroConfigRegistryApplicationListener implements ApplicationListener<ApplicationEvent>,\n+    ApplicationContextAware {\n+\n+  private static final Logger LOGGER = LoggerFactory\n+      .getLogger(ZeroConfigRegistryApplicationListener.class);\n+\n+  private ApplicationContext applicationContext;", "originalCommit": "d708cd13939d8fcae02511228266a41868cbf013", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc2ODI2NQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r428768265", "bodyText": "will deleted private ApplicationContext applicationContext; variable", "author": "jungan21", "createdAt": "2020-05-21T16:29:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyOTI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyOTgzMw==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427829833", "bodyText": "Why need this line of code?", "author": "liubao68", "createdAt": "2020-05-20T08:26:04Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigRegistryApplicationListener.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig;\n+\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+import org.apache.servicecomb.serviceregistry.client.ServiceRegistryClient;\n+import org.apache.servicecomb.serviceregistry.config.ServiceRegistryConfig;\n+\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ZeroConfigRegistryClientImpl;\n+import org.apache.servicecomb.zeroconfig.server.ServerUtil;\n+import org.apache.servicecomb.zeroconfig.server.ZeroConfigRegistryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.BeansException;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.context.ApplicationContextAware;\n+import org.springframework.context.ApplicationEvent;\n+import org.springframework.context.ApplicationListener;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.web.client.RestTemplate;\n+\n+import java.io.IOException;\n+import java.net.MulticastSocket;\n+import java.util.function.Function;\n+\n+/**\n+ * ZeroConfigServiceRegistryClientImpl is injected before cse application listener (order is -1000)\n+ */\n+\n+@Configuration\n+@Order(-1001)\n+public class ZeroConfigRegistryApplicationListener implements ApplicationListener<ApplicationEvent>,\n+    ApplicationContextAware {\n+\n+  private static final Logger LOGGER = LoggerFactory\n+      .getLogger(ZeroConfigRegistryApplicationListener.class);\n+\n+  private ApplicationContext applicationContext;\n+  private MulticastSocket multicastSocket;\n+\n+  @Override\n+  public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n+\n+    // same mechanism as Local registry to enable the Zero Config registry\n+    String flag = System.getProperty(ZeroConfigRegistryConstants.ZERO_CONFIG_REGISTRY_FLAG);\n+    if (flag != null && flag.equals(ZeroConfigRegistryConstants.ZERO_CONFIG_REGISTRY_ENABLE_FLAG)) {\n+      this.applicationContext = applicationContext;\n+      BeanUtils.setContext(applicationContext);", "originalCommit": "d708cd13939d8fcae02511228266a41868cbf013", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcwNzUzMQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r428707531", "bodyText": "it seems not necessary.. as we will st applicationContext in the  CseApplicationListener.  just to confirm, I will remove the following two lines:\n    this.applicationContext = applicationContext;\n     BeanUtils.setContext(applicationContext);", "author": "jungan21", "createdAt": "2020-05-21T14:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyOTgzMw=="}], "type": "inlineReview"}]}