{"pr_number": 2000, "pr_title": "[SCB-2089] \u652f\u6301\u670d\u52a1\u4e2d\u5fc3rbac\u8ba4\u8bc1", "pr_createdAt": "2020-10-13T01:29:00Z", "pr_url": "https://github.com/apache/servicecomb-java-chassis/pull/2000", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyMDc2NQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/2000#discussion_r503820765", "bodyText": "registryName need support configuration", "author": "liubao68", "createdAt": "2020-10-13T09:53:49Z", "path": "service-registry/registry-service-center/src/main/java/org/apache/servicecomb/serviceregistry/auth/TokenAuthHeaderProvider.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.servicecomb.serviceregistry.auth;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.servicecomb.foundation.auth.AuthHeaderProvider;\n+import org.apache.servicecomb.foundation.auth.Cipher;\n+import org.apache.servicecomb.foundation.auth.DefaultCipher;\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+\n+import com.netflix.config.DynamicPropertyFactory;\n+\n+public class TokenAuthHeaderProvider implements AuthHeaderProvider {\n+  public static final String ACCOUNT_NAME_KEY = \"servicecomb.credentials.account.name\";\n+\n+  public static final String PASSWORD_KEY = \"servicecomb.credentials.account.password\";\n+\n+  public static final String CIPHER_KEY = \"servicecomb.credentials.cipher\";\n+\n+  private String registryName;", "originalCommit": "1a83440f7cf9303935be433ceb31e9e4588a7f10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4MjU2OA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/2000#discussion_r504382568", "bodyText": "the default constructor use the default name, if somebody want to use multi servicecenter, the can use TokenAuthHeaderProvider(String registryName, String accountName, String password, String cipherName)", "author": "jeho0815", "createdAt": "2020-10-14T03:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyMDc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyMTM2NA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/2000#discussion_r503821364", "bodyText": "This constructor never used, can be deleted", "author": "liubao68", "createdAt": "2020-10-13T09:54:46Z", "path": "service-registry/registry-service-center/src/main/java/org/apache/servicecomb/serviceregistry/auth/TokenAuthHeaderProvider.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.servicecomb.serviceregistry.auth;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.servicecomb.foundation.auth.AuthHeaderProvider;\n+import org.apache.servicecomb.foundation.auth.Cipher;\n+import org.apache.servicecomb.foundation.auth.DefaultCipher;\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+\n+import com.netflix.config.DynamicPropertyFactory;\n+\n+public class TokenAuthHeaderProvider implements AuthHeaderProvider {\n+  public static final String ACCOUNT_NAME_KEY = \"servicecomb.credentials.account.name\";\n+\n+  public static final String PASSWORD_KEY = \"servicecomb.credentials.account.password\";\n+\n+  public static final String CIPHER_KEY = \"servicecomb.credentials.cipher\";\n+\n+  private String registryName;\n+\n+  private String accountName;\n+\n+  private String password;\n+\n+  private String cipherName;\n+\n+  public TokenAuthHeaderProvider() {\n+    this.registryName = ServiceRegistry.DEFAULT_REGISTRY_NAME;\n+    this.accountName = DynamicPropertyFactory.getInstance()\n+        .getStringProperty(ACCOUNT_NAME_KEY, null).get();\n+    this.password = DynamicPropertyFactory.getInstance()\n+        .getStringProperty(PASSWORD_KEY, null).get();\n+    this.cipherName = DynamicPropertyFactory.getInstance()\n+        .getStringProperty(CIPHER_KEY, DefaultCipher.DEFAULT_CYPHER).get();\n+    if (StringUtils.isNotEmpty(accountName)) {\n+      TokenCacheManager.getInstance().addTokenCache(registryName, accountName, password, getCipher());\n+    }\n+  }\n+\n+  public TokenAuthHeaderProvider(String registryName, String accountName, String password, String cipherName) {", "originalCommit": "1a83440f7cf9303935be433ceb31e9e4588a7f10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4Mjc0Mg==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/2000#discussion_r504382742", "bodyText": "this is used to multi service center scence", "author": "jeho0815", "createdAt": "2020-10-14T03:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyMTM2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyMzg1NA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/2000#discussion_r503823854", "bodyText": "should not retry when using old version of service center and stop scheduler service", "author": "liubao68", "createdAt": "2020-10-13T09:58:46Z", "path": "service-registry/registry-service-center/src/main/java/org/apache/servicecomb/serviceregistry/auth/TokenCacheManager.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.servicecomb.serviceregistry.auth;\n+\n+import java.time.Clock;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.annotation.Nonnull;\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.servicecomb.foundation.auth.Cipher;\n+import org.apache.servicecomb.foundation.common.concurrency.SuppressedRunnableWrapper;\n+import org.apache.servicecomb.foundation.common.concurrent.ConcurrentHashMapEx;\n+import org.apache.servicecomb.foundation.common.utils.TimeUtils;\n+import org.apache.servicecomb.foundation.vertx.client.http.HttpClients;\n+import org.apache.servicecomb.serviceregistry.RegistryUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+import org.apache.servicecomb.serviceregistry.api.request.RbacTokenRequest;\n+import org.apache.servicecomb.serviceregistry.api.response.RbacTokenResponse;\n+import org.apache.servicecomb.serviceregistry.client.ServiceRegistryClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class TokenCacheManager {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(TokenCacheManager.class);\n+\n+  private static final TokenCacheManager INSTANCE = new TokenCacheManager();\n+\n+  private Clock clock = TimeUtils.getSystemDefaultZoneClock();\n+\n+  private ScheduledExecutorService tokenCacheWorker;\n+\n+  private Map<String, TokenCache> tokenCacheMap;\n+\n+  public static TokenCacheManager getInstance() {\n+    return INSTANCE;\n+  }\n+\n+  private TokenCacheManager() {\n+    tokenCacheWorker = Executors.newScheduledThreadPool(2, new ThreadFactory() {\n+      private final AtomicInteger threadIndexer = new AtomicInteger();\n+\n+      @Override\n+      public Thread newThread(@Nonnull Runnable r) {\n+        Thread thread = new Thread(r, \"auth-token-cache-\" + threadIndexer.getAndIncrement());\n+        thread.setDaemon(true);\n+        return thread;\n+      }\n+    });\n+    tokenCacheMap = new ConcurrentHashMapEx<>();\n+  }\n+\n+  public void addTokenCache(String registryName, String accountName, String password, Cipher cipher) {\n+    Objects.requireNonNull(registryName, \"registryName should not be null!\");\n+    if (tokenCacheMap.containsKey(registryName)) {\n+      LOGGER.warn(\"duplicate token cache registration for serviceRegistry[{}]\", registryName);\n+      return;\n+    }\n+\n+    TokenCache tokenCache = new TokenCache(registryName, accountName, password, cipher, this.clock);\n+    tokenCache.setTokenCacheWorker(this.tokenCacheWorker);\n+    tokenCacheMap.put(registryName, tokenCache);\n+    HttpClients.load();\n+    RegistryUtils.init();\n+    tokenCache.refreshToken();\n+  }\n+\n+  public String getToken(String registryName) {\n+    return Optional.ofNullable(tokenCacheMap.get(registryName))\n+        .map(TokenCache::getToken)\n+        .orElse(\"\");\n+  }\n+\n+  public static class TokenCache {\n+    private final String registryName;\n+\n+    private final String accountName;\n+\n+    private final String password;\n+\n+    private final Clock clock;\n+\n+    private String token;\n+\n+    private long nextRefreshTime;\n+\n+    private boolean wrongPassword;\n+\n+    /**\n+     * The life cycle period of a token, in millisecond.\n+     * After the {@code tokenLife} time since the token created, it should be refreshed.\n+     * <p>\n+     * Default life time in sc is 30min, give 2min buffer\n+     * </p>\n+     */\n+    private long tokenLife = TimeUnit.MINUTES.toMillis(30 - 2);\n+\n+    private ScheduledExecutorService tokenCacheWorker;\n+\n+    private Cipher cipher;\n+\n+    public TokenCache(String registryName, String accountName, String password,\n+        Cipher cipher, Clock clock) {\n+      this.registryName = registryName;\n+      this.accountName = accountName;\n+      this.password = password;\n+      this.cipher = cipher;\n+      this.clock = clock;\n+    }\n+\n+    public String getToken() {\n+      return token == null ? \"\" : token;\n+    }\n+\n+    public void setTokenCacheWorker(ScheduledExecutorService tokenCacheWorker) {\n+      Objects.requireNonNull(tokenCacheWorker, \"input tokenCacheWorker is null\");\n+      if (this.tokenCacheWorker != null) {\n+        throw new IllegalStateException(\"tokenCacheWorker already set!\");\n+      }\n+\n+      this.tokenCacheWorker = tokenCacheWorker;\n+      startTokenRefreshTask();\n+    }\n+\n+    private void startTokenRefreshTask() {\n+      this.tokenCacheWorker.scheduleAtFixedRate(\n+          new SuppressedRunnableWrapper(() -> {\n+            if (isTokenOutdated()) {\n+              refreshToken();\n+            }\n+          }),\n+          1,\n+          5,\n+          TimeUnit.SECONDS);\n+    }\n+\n+    private boolean isTokenOutdated() {\n+      return clock.millis() > nextRefreshTime;\n+    }\n+\n+    private void refreshToken() {\n+      if (wrongPassword) {\n+        return;\n+      }\n+      ServiceRegistry serviceRegistry = RegistryUtils.getServiceRegistry(registryName);\n+      ServiceRegistryClient serviceRegistryClient =\n+          serviceRegistry == null ? null : serviceRegistry.getServiceRegistryClient();\n+      if ((serviceRegistry == null || serviceRegistryClient == null)\n+          && ServiceRegistry.DEFAULT_REGISTRY_NAME.equals(registryName)) {\n+        LOGGER.error(\"failed to get default serviceRegistry\");\n+        tokenCacheWorker.schedule( // retry after 1 second\n+            this::refreshToken, 1, TimeUnit.SECONDS);\n+        return;\n+      }\n+      RbacTokenRequest request = new RbacTokenRequest();\n+      request.setAccountName(new String(cipher.decrypt(accountName.toCharArray())));\n+      request.setPassword(new String(cipher.decrypt(password.toCharArray())));\n+      RbacTokenResponse rbacTokenResponse = serviceRegistryClient.getRbacToken(request);\n+      LOGGER.info(\"refresh token successfully {}\", rbacTokenResponse.getStatusCode());\n+      if (StringUtils.isEmpty(this.token) && Status.UNAUTHORIZED.getStatusCode() == rbacTokenResponse.getStatusCode()) {", "originalCommit": "1a83440f7cf9303935be433ceb31e9e4588a7f10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4MjgwMg==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/2000#discussion_r504382802", "bodyText": "done", "author": "jeho0815", "createdAt": "2020-10-14T03:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyMzg1NA=="}], "type": "inlineReview"}, {"oid": "0f3f91d5afb3d338b15b5af1c682aefa30a36648", "url": "https://github.com/apache/servicecomb-java-chassis/commit/0f3f91d5afb3d338b15b5af1c682aefa30a36648", "message": "[SCB-2089] \u652f\u6301\u670d\u52a1\u4e2d\u5fc3rbac\u8ba4\u8bc1", "committedDate": "2020-10-14T02:01:08Z", "type": "commit"}, {"oid": "0f3f91d5afb3d338b15b5af1c682aefa30a36648", "url": "https://github.com/apache/servicecomb-java-chassis/commit/0f3f91d5afb3d338b15b5af1c682aefa30a36648", "message": "[SCB-2089] \u652f\u6301\u670d\u52a1\u4e2d\u5fc3rbac\u8ba4\u8bc1", "committedDate": "2020-10-14T02:01:08Z", "type": "forcePushed"}]}