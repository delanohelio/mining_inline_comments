{"pr_number": 893, "pr_title": "Shared cache RT pickup, dual client stack support", "pr_createdAt": "2020-04-22T01:19:20Z", "pr_url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/893", "timeline": [{"oid": "52ccd794f299a9e14544114a0992e4deabeaacab", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/commit/52ccd794f299a9e14544114a0992e4deabeaacab", "message": "WIP - TSL pickup, dual client stack support", "committedDate": "2020-04-22T01:04:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4OTc5Mw==", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/893#discussion_r413189793", "bodyText": "Remove this comment, may add more confusion than clarity", "author": "iambmelt", "createdAt": "2020-04-22T17:47:13Z", "path": "common/src/main/java/com/microsoft/identity/common/internal/cache/MsalOAuth2TokenCache.java", "diffHunk": "@@ -552,6 +553,76 @@ public ICacheRecord load(@NonNull final String clientId,\n                 null // not applicable\n         );\n \n+        {\n+            // If we didn't find an RT in the cache, this could be a \"TSL-seed\" or \"dual-client stack\"\n+            // scenario\n+            //\n+            // Defining these terms:\n+            // TSL-seed: another 1P TSL integrated app has put a token into our cache so we can\n+            //     pick it up\n+            //\n+            // Dual-Client stack: two FoCI-enabled app registrations are sharing a single binary\n+            //     and accordingly, can share RTs.\n+            //     Examples for this might be TFL/TFW - which uses multiple client ids to enable\n+            //     different scenarios depending on enterprise vs. consumer usage\n+\n+            // Unlike the broker, where we check if an app is FoCI prior to making a network call\n+            // with an arbitrary FoCI RT we find in the cache, if we're in standalone mode and find\n+            // a FoCI RT in the cache, the current app must also be FoCI (!!!)\n+            //\n+            // Making the assumption that the current client id can use any FoCI RT we find in the", "originalCommit": "52ccd794f299a9e14544114a0992e4deabeaacab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIwMzkxOA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/893#discussion_r413203918", "bodyText": "I would prefer to keep the comment, I think it is quite helpful.", "author": "shahzaibj", "createdAt": "2020-04-22T18:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4OTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI1MTE3Ng==", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/893#discussion_r413251176", "bodyText": "Ok, will re-add with some slightly modified language based on feedback I received offline", "author": "iambmelt", "createdAt": "2020-04-22T19:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4OTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI1MzgwMg==", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/893#discussion_r413253802", "bodyText": "Readded in 63183e3", "author": "iambmelt", "createdAt": "2020-04-22T19:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4OTc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIwMzAwMQ==", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/893#discussion_r413203001", "bodyText": "Are there any (or could there be any) first party apps that are not part of FoCI for some reason?", "author": "shahzaibj", "createdAt": "2020-04-22T18:05:42Z", "path": "common/src/main/java/com/microsoft/identity/common/internal/cache/MsalOAuth2TokenCache.java", "diffHunk": "@@ -552,6 +553,76 @@ public ICacheRecord load(@NonNull final String clientId,\n                 null // not applicable\n         );\n \n+        {\n+            // If we didn't find an RT in the cache, this could be a \"TSL-seed\" or \"dual-client stack\"\n+            // scenario\n+            //\n+            // Defining these terms:\n+            // TSL-seed: another 1P TSL integrated app has put a token into our cache so we can\n+            //     pick it up\n+            //\n+            // Dual-Client stack: two FoCI-enabled app registrations are sharing a single binary\n+            //     and accordingly, can share RTs.\n+            //     Examples for this might be TFL/TFW - which uses multiple client ids to enable\n+            //     different scenarios depending on enterprise vs. consumer usage\n+\n+            // Unlike the broker, where we check if an app is FoCI prior to making a network call\n+            // with an arbitrary FoCI RT we find in the cache, if we're in standalone mode and find\n+            // a FoCI RT in the cache, the current app must also be FoCI (!!!)\n+            //\n+            // Making the assumption that the current client id can use any FoCI RT we find in the\n+            // cache is strictly contingent that app developers NOT mix 1P & 3P registrations into\n+            // the same binary. If you do this, Bad Things will happen and you'll get confusing\n+            // errors that the RT used doesn't match the client app registration. Also, this\n+            // assumption means we don't need to implement \"FoCI probing\" and/or track FoCI app meta\n+\n+            if (refreshTokens.isEmpty()) {\n+                // Look for an arbitrary RT matching the current user.\n+                // If we find one, check that it is FoCI, if it is, assume it works.\n+                final List<Credential> fallbackRts = mAccountCredentialCache.getCredentialsFilteredBy(\n+                        account.getHomeAccountId(),\n+                        account.getEnvironment(),\n+                        CredentialType.RefreshToken,\n+                        null, // wildcard (*)\n+                        isMultiResourceCapable\n+                                ? null // wildcard (*)\n+                                : account.getRealm(),\n+                        isMultiResourceCapable\n+                                ? null // wildcard (*)\n+                                : target,\n+                        null // not applicable\n+                );\n+\n+                if (!fallbackRts.isEmpty()) {\n+                    Logger.verbose(\n+                            TAG + methodName,\n+                            \"Inspecting fallback RTs for a FoCI match.\"\n+                    );\n+\n+                    // Any arbitrary RT should be OK -- if multiple clients are stacked, they're either", "originalCommit": "52ccd794f299a9e14544114a0992e4deabeaacab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyMTg4Mw==", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/893#discussion_r413221883", "bodyText": "Yes, we do have 1P apps that are not FoCI. They won't benefit from these changes\nHad an offline sync w/ @shoatman -- the output of our discussion was that any 1P app that plans to dual-client stack must have both be FoCI, or neither. We won't support a 'blended' model where one is and the other is not", "author": "iambmelt", "createdAt": "2020-04-22T18:32:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIwMzAwMQ=="}], "type": "inlineReview"}, {"oid": "8209896f99f6548b3bdbef4f8dee156c59865fc7", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/commit/8209896f99f6548b3bdbef4f8dee156c59865fc7", "message": "Removing potentially confusing comment", "committedDate": "2020-04-22T18:10:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIwNzIxMA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/893#discussion_r413207210", "bodyText": "Left similar comment below, basically I want to know if some app can have multiple client id stacked, let's say three, and all of them are 1P registrations. Could there be case that even though all three are 1P, but for some reason one of them is not part of FoCI, whereas the other two are. Is this case possible? And should we implement probing for it?", "author": "shahzaibj", "createdAt": "2020-04-22T18:10:58Z", "path": "common/src/main/java/com/microsoft/identity/common/internal/cache/MsalOAuth2TokenCache.java", "diffHunk": "@@ -552,6 +553,76 @@ public ICacheRecord load(@NonNull final String clientId,\n                 null // not applicable\n         );\n \n+        {\n+            // If we didn't find an RT in the cache, this could be a \"TSL-seed\" or \"dual-client stack\"\n+            // scenario\n+            //\n+            // Defining these terms:\n+            // TSL-seed: another 1P TSL integrated app has put a token into our cache so we can\n+            //     pick it up\n+            //\n+            // Dual-Client stack: two FoCI-enabled app registrations are sharing a single binary\n+            //     and accordingly, can share RTs.\n+            //     Examples for this might be TFL/TFW - which uses multiple client ids to enable\n+            //     different scenarios depending on enterprise vs. consumer usage\n+\n+            // Unlike the broker, where we check if an app is FoCI prior to making a network call\n+            // with an arbitrary FoCI RT we find in the cache, if we're in standalone mode and find\n+            // a FoCI RT in the cache, the current app must also be FoCI (!!!)\n+            //\n+            // Making the assumption that the current client id can use any FoCI RT we find in the\n+            // cache is strictly contingent that app developers NOT mix 1P & 3P registrations into\n+            // the same binary. If you do this, Bad Things will happen and you'll get confusing\n+            // errors that the RT used doesn't match the client app registration. Also, this\n+            // assumption means we don't need to implement \"FoCI probing\" and/or track FoCI app meta", "originalCommit": "52ccd794f299a9e14544114a0992e4deabeaacab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI0OTkyNQ==", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/893#discussion_r413249925", "bodyText": "See comment here -- we won't support this by-design. Not supporting it let's us dodge having to bring probe logic out of broker", "author": "iambmelt", "createdAt": "2020-04-22T19:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIwNzIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyMjYwNA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/893#discussion_r413222604", "bodyText": "nit: Since finding refresh tokens is now complicated, should it be in its own (potentially set of) private method(s)?", "author": "AdamBJohnsonx", "createdAt": "2020-04-22T18:33:29Z", "path": "common/src/main/java/com/microsoft/identity/common/internal/cache/MsalOAuth2TokenCache.java", "diffHunk": "@@ -552,6 +553,70 @@ public ICacheRecord load(@NonNull final String clientId,\n                 null // not applicable\n         );\n \n+        {", "originalCommit": "8209896f99f6548b3bdbef4f8dee156c59865fc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyNTc0NQ==", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/893#discussion_r413225745", "bodyText": "Yeah, I'll take that feedback. This method becoming long", "author": "iambmelt", "createdAt": "2020-04-22T18:38:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyMjYwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI0ODQ2MA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/893#discussion_r413248460", "bodyText": "Resolved via\n\na22f456\n\nTweaked javadoc in:\n\n3ab2e13", "author": "iambmelt", "createdAt": "2020-04-22T19:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyMjYwNA=="}], "type": "inlineReview"}, {"oid": "a22f456f20136fe51c96c5c2cf5d786c39b841ba", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/commit/a22f456f20136fe51c96c5c2cf5d786c39b841ba", "message": "Breaking method out, readability, CR feedback", "committedDate": "2020-04-22T19:08:25Z", "type": "commit"}, {"oid": "3ab2e13c109012a373bc56cee8ad0f81382d2644", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/commit/3ab2e13c109012a373bc56cee8ad0f81382d2644", "message": "Fixing javadoc", "committedDate": "2020-04-22T19:09:38Z", "type": "commit"}, {"oid": "63183e37f5a41ef6f676c57f23377a26d3f584bb", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/commit/63183e37f5a41ef6f676c57f23377a26d3f584bb", "message": "Cleaning up comments", "committedDate": "2020-04-22T19:18:38Z", "type": "commit"}, {"oid": "2ecfac346edd4b2a6077f8b127faa28915cd2df0", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/commit/2ecfac346edd4b2a6077f8b127faa28915cd2df0", "message": "Fix PMD. Remove unused variable", "committedDate": "2020-04-22T19:20:33Z", "type": "commit"}, {"oid": "956694d3bfc198b7fe8c47bda7c4c86f4ef8ad65", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/commit/956694d3bfc198b7fe8c47bda7c4c86f4ef8ad65", "message": "Adding unit test", "committedDate": "2020-04-22T20:12:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMwOTQwOA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/893#discussion_r413309408", "bodyText": "Is this a safe copy that we're adding to, with guaranteed mutability, for all implementations of the cache interface?  One would think, but the interface documentation is vague on what we're getting back here other than that it implements List.  Should we take a copy before we mutate it or relax the final modifier on the refreshTokens reference so we can just reassign it since we only want the first element anyway?", "author": "AdamBJohnsonx", "createdAt": "2020-04-22T20:33:12Z", "path": "common/src/main/java/com/microsoft/identity/common/internal/cache/MsalOAuth2TokenCache.java", "diffHunk": "@@ -552,6 +552,35 @@ public ICacheRecord load(@NonNull final String clientId,\n                 null // not applicable\n         );\n \n+        if (refreshTokens.isEmpty()) {\n+            // If we didn't find an RT in the cache, this could be a \"TSL-seed\" or \"dual-client stack\"\n+            // scenario\n+            //\n+            // Defining these terms:\n+            // TSL-seed: another 1P TSL integrated app has put a token into our cache so we can\n+            //     pick it up\n+            //\n+            // Dual-Client stack: two FoCI-enabled app registrations are sharing a single binary\n+            //     and accordingly, can share RTs.\n+            //     Examples for this might be TFL/TFW - which uses multiple client ids to enable\n+            //     different scenarios depending on enterprise vs. consumer usage\n+\n+            // Unlike the broker, where we check if an app is FoCI prior to making a network call\n+            // with an arbitrary FoCI RT we find in the cache, if we're in standalone mode and find\n+            // a FoCI RT in the cache, the current app must also be FoCI (!!!)\n+            //\n+            // Making the assumption that the current client id can use any FoCI RT we find in the\n+            // cache is strictly contingent that app developers NOT mix FoCI/non-FoCI registrations\n+            // into same binary. If you do this, you'll get confusing errors that the RT used doesn't\n+            // match the client app registration. This assumption means we don't need to implement\n+            // \"FoCI probing\" and/or track FoCI app meta\n+            final Credential fallbackFrt = getFamilyRefreshTokenForAccount(account);\n+\n+            if (null != fallbackFrt) {\n+                refreshTokens.add(fallbackFrt);", "originalCommit": "2ecfac346edd4b2a6077f8b127faa28915cd2df0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzMTAxMA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/893#discussion_r413331010", "bodyText": "The List is mutable, but as you mention, the interface is vague on this point.\nI'll take the suggestion to remove the final modifier and will reassign the List -- API vagueries should ideally be ironed out as well so I'll spot check classes and make updates to the javadoc where appropriate as part of this PR\nThere's probably >1 interface floating around here that is ambiguous on the mutability/immutability of the resulting Collection. As you see them, feel free to file an issue (or plural issues) if you see more places like that this that need clarity and those can be addressed either piecemeal or as part of a larger effort", "author": "iambmelt", "createdAt": "2020-04-22T21:03:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMwOTQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzOTY5Mg==", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/893#discussion_r413339692", "bodyText": "Javadoc/mutability clarifed in:\n\n7df4abf\n\nList reinit + add (even tho we know List is mutable) in:\n\na1b4f1b\n\nStrictly speaking we could take the attitude that the changes in 7df4abf make a1b4f1b unnecessary, but I'm fine to incorporate that original suggestion and leave as-is", "author": "iambmelt", "createdAt": "2020-04-22T21:17:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMwOTQwOA=="}], "type": "inlineReview"}, {"oid": "7df4abf2dc56e75d737ab1c7f6c94c99fe8e4c81", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/commit/7df4abf2dc56e75d737ab1c7f6c94c99fe8e4c81", "message": "Clarifying javadoc on interface result mutability", "committedDate": "2020-04-22T21:15:00Z", "type": "commit"}, {"oid": "a1b4f1b113bf53c57c349ab7bb114dcd7e83a965", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/commit/a1b4f1b113bf53c57c349ab7bb114dcd7e83a965", "message": "Make no assumptions about mutability, set a new List and add the result", "committedDate": "2020-04-22T21:15:28Z", "type": "commit"}]}