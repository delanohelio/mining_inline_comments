{"pr_number": 9695, "pr_title": "KAFKA-10500: Remove thread", "pr_createdAt": "2020-12-04T20:08:09Z", "pr_url": "https://github.com/apache/kafka/pull/9695", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NDQxOA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r536354418", "bodyText": "I moved the changeThreadCount lock to be more specific so we will not hold a lock while acquiring a new one.", "author": "wcarlson5", "createdAt": "2020-12-04T20:14:27Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,28 +924,69 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {", "originalCommit": "d6a8cbd4435e1b0b55d7cc3922226fcff60676d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk1NDcyOQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r537954729", "bodyText": "Nice. One minor suggestion, log a warning if the client isn't running (or rebalancing) and print the current state", "author": "ableegoldman", "createdAt": "2020-12-08T01:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NDQxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU3MzMxNw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r538573317", "bodyText": "good idea", "author": "wcarlson5", "createdAt": "2020-12-08T16:33:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NDQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NzI2OA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r536367268", "bodyText": "removeStreamThread is supposed to be a blocking call until the shutdown is complete", "author": "wcarlson5", "createdAt": "2020-12-04T20:41:02Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,28 +924,69 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     *\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     *\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@code cache.max.bytes.buffering}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {\n+                if (streamThread.isAlive()) {\n+                    streamThread.shutdown();\n+                    while (streamThread.state() != StreamThread.State.DEAD && !streamThread.getName().equals(Thread.currentThread().getName())) {", "originalCommit": "a2eb7beca2f0589ca9d6aa39a0bc2d72c6a9b954", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2OTM3OQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r537969379", "bodyText": "I take it the !streamThread.getName().equals(Thread.currentThread().getName()) is in preparation for adding the REPLACE_THREAD enum -- if so, can you just leave a //TODO here for now and add this in the followup PR so we have relevant changes reviewed together?", "author": "ableegoldman", "createdAt": "2020-12-08T01:48:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NzI2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUzOTI2Nw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r538539267", "bodyText": "Actually it is for if the thread chosen is the thread that called remove thread. REPLACE_THREAD will not actually call removeThread()", "author": "wcarlson5", "createdAt": "2020-12-08T16:03:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NzI2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxMTc2OA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r538911768", "bodyText": "Ah right you mean if removeThread() is called from the exception handler. Thanks for clarifying", "author": "ableegoldman", "createdAt": "2020-12-09T00:28:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NzI2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyMTY3Ng==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r538921676", "bodyText": "Ok in that case I think my concerns from here apply as well: is it safe to immediately redistribute the memory from the cache if the removed thread hasn't necessarily closed yet? Definitely risks an OOM, but maybe that risk is low (or at least acceptable). But we definitely can't remove the thread from threads until it's shut down since that puts its thread id back on the menu, and the ids have to be unique. How should we handle this?", "author": "ableegoldman", "createdAt": "2020-12-09T00:54:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NzI2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkzODU1MA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r538938550", "bodyText": "I think we have to put the thread id back on the menu. Otherwise when we replace the thread we will not be able to use the same id. In the tests for REPLACE_THREAD there has been no problems with having the thread that is shutting down have the same name as the thread that is starting. But for a call to removeThread it is probably best to not resize until shutdown is complete\ni think the OOM risk is acceptable. The thread shutdown is much simpler than a client one and should not be using more space and the new thread should not have any tasks assigned until the old thread leaves the group.", "author": "wcarlson5", "createdAt": "2020-12-09T01:37:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NzI2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkzOTg1Nw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r538939857", "bodyText": "Ah right you mean if removeThread() is called from the exception handler. Thanks for clarifying\n\nIt doesn't have to be from the handler. A thread that calls removeThread() could easily be removing itself.\nIn which case your concern about the OOM might apply as well. I don't see a good way around it though .", "author": "wcarlson5", "createdAt": "2020-12-09T01:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NzI2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MDk0OA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r538940948", "bodyText": "As for swallowing the InterruptedException, it still makes me uncomfortable but maybe there was/is a good reason that we do it already. Or, maybe you're just the first person to notice that we're doing that.\n\nI hope there is a good reason, but we don't seem to have a problem with it yet so....", "author": "wcarlson5", "createdAt": "2020-12-09T01:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NzI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NzcxOQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r536367719", "bodyText": "This makes sure that the names are reused correctly and that adding add removing continuously do not cause problems", "author": "wcarlson5", "createdAt": "2020-12-04T20:41:58Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,55 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {", "originalCommit": "7028ab1bbff7066da158be31ec268c3c1b1ea050", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk1NTM5Mg==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r537955392", "bodyText": "Same here, let's log a warning", "author": "ableegoldman", "createdAt": "2020-12-08T01:11:24Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,22 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {", "originalCommit": "b329214d7db48ce993ac253a64133f60d65f848d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU3Mzc0NA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r538573744", "bodyText": "I will log it on both empty returns", "author": "wcarlson5", "createdAt": "2020-12-08T16:34:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk1NTM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk1NzgzMw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r537957833", "bodyText": "We need to protect this with a lock or use a thread-safe data structure for threads, otherwise we can get a ConcurrentModificationException if the user calls addThread and/or removeThread at the same time (on that note let's add test coverage for this)", "author": "ableegoldman", "createdAt": "2020-12-08T01:17:48Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,22 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {", "originalCommit": "b329214d7db48ce993ac253a64133f60d65f848d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUzNjM3Ng==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r538536376", "bodyText": "The thread list is synchronized so that take care of it, no?", "author": "wcarlson5", "createdAt": "2020-12-08T16:01:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk1NzgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxMTE0Ng==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r538911146", "bodyText": "Where is it synchronized? I'm thinking that eg while iterating through this list in one thread, another thread may be inside the synchronized (changeThreadCount) block of where it removes from this list. Only the second access is synchronized so the iteration itself is still vulnerable right?", "author": "ableegoldman", "createdAt": "2020-12-09T00:27:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk1NzgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkzNDEzNw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r538934137", "bodyText": "kafka/streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java\n    \n    \n         Line 825\n      in\n      338045c\n    \n    \n    \n    \n\n        \n          \n           threads = Collections.synchronizedList(new LinkedList<>()); \n        \n    \n  \n\n\nThe list access is synchronized. I think that when using an iterator such as a for each loop that should be safe. But since we are not actually making changes out side of the synchronized (changeThreadCount) those shouldn't cause a problem.", "author": "wcarlson5", "createdAt": "2020-12-09T01:26:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk1NzgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY0MzU3Nw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r544643577", "bodyText": "Ah I missed the previous PR where you changed the list type. Ok I'm  not that familiar with Collections.synchronizedList but I'm still worried we may not be safe with this. From the javadocs:\nIt is imperative that the user manually synchronize on the returned list when iterating over it:", "author": "ableegoldman", "createdAt": "2020-12-16T21:42:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk1NzgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY0NTA2MA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r544645060", "bodyText": "It wouldn't be guaranteed to catch this, but either way I think we should have a test that starts up two threads which both try to removeThread() at the same time (and maybe similarly for addStreamThread)", "author": "ableegoldman", "createdAt": "2020-12-16T21:45:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk1NzgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5NzQ3MQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r551597471", "bodyText": "Okay we won't get a concurrent modification but the result won't be deterministic, I think we can just synchronize the iterator in remove thread as that is the only time were we are iterating and making changes. The other places concurrent access should not be a problem.\nI've added tests for the remove and add, there does not seem to be a problem but it is hard to guarantee that the race condition hit each time.", "author": "wcarlson5", "createdAt": "2021-01-04T22:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk1NzgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2NDMxNg==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r537964316", "bodyText": "Be careful about swallowing the InterruptedException completely. Getting this exception means the user wants the thread to stop, not just this specific method. And we don't know what the caller of removeThread looks like, it might just be an infinite loop that checks on some metric and adjusts the thread count if necessary. We should make sure to propagate the interrupt once we finish cleaning up after the thread", "author": "ableegoldman", "createdAt": "2020-12-08T01:35:03Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,22 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {\n+                if (streamThread.isAlive()) {\n+                    streamThread.shutdown();\n+                    while (streamThread.state() != StreamThread.State.DEAD && !streamThread.getName().equals(Thread.currentThread().getName())) {\n+                        try {\n+                            synchronized (streamThread.state()) {\n+                                streamThread.state().wait(100);\n+                            }\n+                        } catch (final InterruptedException e) {\n+                            e.printStackTrace();", "originalCommit": "b329214d7db48ce993ac253a64133f60d65f848d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3NjM5MQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r537976391", "bodyText": "Actually now I'm wondering, should we even do the clean up if the thread is interrupted before completed? It definitely seems like we shouldn't remove it from threads since that would free up the id for a new thread, and they have to be unique. And resizing the cache might be risky if the removed thread hasn't cleared its own cache yet.\nI guess we could have the thread handle this cleanup itself once it reaches the end of the shutdown...but maybe the priority should be to keep the code simple. Burning a thread id probably isn't so bad, but permanently losing its share of the cache memory is. WDYT?", "author": "ableegoldman", "createdAt": "2020-12-08T02:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2NDMxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU3ODI2NA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r538578264", "bodyText": "I think if we make a StreamThread#waitOnThreadState we can handle it the same what as in the KafkaStreams#waitOnState", "author": "wcarlson5", "createdAt": "2020-12-08T16:38:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2NDMxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYwMDgwMg==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r538600802", "bodyText": "This will be moving to the other method but if you look at KafkaStreams#waitOnState you will see it also swallows the exception. If we follow the same pattern we would as well. If we want to deviate from that we can just have remove thread throw the interrupted exception.", "author": "wcarlson5", "createdAt": "2020-12-08T16:57:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2NDMxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyMzYxMA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r538923610", "bodyText": "Let's continue the discussion about what to do if the thread hasn't finished shutting down here, since the same question applies to this case.\nAs for swallowing the InterruptedException, it still makes me uncomfortable but maybe there was/is a good reason that we do it already. Or, maybe you're just the first person to notice that we're doing that.", "author": "ableegoldman", "createdAt": "2020-12-09T00:59:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2NDMxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkzNTIxMw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r538935213", "bodyText": "Alright I am resolving for clarity", "author": "wcarlson5", "createdAt": "2020-12-09T01:29:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2NDMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3NDU3OA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r537974578", "bodyText": "Maybe we could follow a similar pattern as to KafkaStreams#waitOnState and use notify instead of waking up every 100ms", "author": "ableegoldman", "createdAt": "2020-12-08T01:59:52Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,22 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {\n+                if (streamThread.isAlive()) {\n+                    streamThread.shutdown();\n+                    while (streamThread.state() != StreamThread.State.DEAD && !streamThread.getName().equals(Thread.currentThread().getName())) {\n+                        try {\n+                            synchronized (streamThread.state()) {\n+                                streamThread.state().wait(100);", "originalCommit": "b329214d7db48ce993ac253a64133f60d65f848d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYwMDgyNA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r538600824", "bodyText": "good idea", "author": "wcarlson5", "createdAt": "2020-12-08T16:57:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3NDU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE0ODkxMQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540148911", "bodyText": "Looking at these lines, I have two questions:\n\nWhy do we not also resize the cache of the global stream thread?\nWhy do we not do all computations regarding the cache size in getCacheSizePerThread()?\n\nRegarding 1, I think we need to resize also the cache of the global stream thread, because otherwise the global stream thread may get over proportionally much cache when new stream threads are added beyond the initial number of steam threads and -- which I think is worse -- if all stream threads are removed, we would not use all cache for the global stream thread.", "author": "cadonna", "createdAt": "2020-12-10T12:59:38Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,25 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        log.warn(\"Cannot add a stream thread in state \" + state());\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {\n+                if (streamThread.isAlive()) {\n+                    streamThread.shutdown();\n+                    if (!streamThread.getName().equals(Thread.currentThread().getName())) {\n+                        streamThread.waitOnThreadState(StreamThread.State.DEAD);\n+                    }\n+                    synchronized (changeThreadCount) {\n+                        final long cacheSizePerThread = threads.size() == 1 ? 0 : getCacheSizePerThread(threads.size() - 1);\n+                        resizeThreadCache(cacheSizePerThread);", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA2MzQ1OQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r541063459", "bodyText": "I agree I completely forgot to add a resize method to the global thread. Added", "author": "wcarlson5", "createdAt": "2020-12-11T16:19:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE0ODkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE2NzY3Mg==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540167672", "bodyText": "Is there a reason why we want to support that a stream thread can remove itself? If not I would simply not allow it and check on line 970 if the stream thread is alive and not the calling thread. Not allowing a stream thread removing itself would also ensure that we do not exceed the total cache size when we resize the cache.", "author": "cadonna", "createdAt": "2020-12-10T13:28:07Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,25 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        log.warn(\"Cannot add a stream thread in state \" + state());\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {\n+                if (streamThread.isAlive()) {\n+                    streamThread.shutdown();\n+                    if (!streamThread.getName().equals(Thread.currentThread().getName())) {", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1MTU5Ng==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540351596", "bodyText": "Maybe there is a global thread and a stream thread and the user only wants a global thread now?", "author": "wcarlson5", "createdAt": "2020-12-10T17:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE2NzY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1NDEwNg==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540854106", "bodyText": "That would still work, but not if the non-global stream threads are removed by a non-global stream thread. I can think of a use case where a stream thread is removed by another stream thread when a special record is processed. Do we want to support such a use case?", "author": "cadonna", "createdAt": "2020-12-11T10:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE2NzY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA1NjY0MQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r541056641", "bodyText": "I think  it would be odd for use to allow an outside thread to remove that last thread but not allow a thread to remove its self", "author": "wcarlson5", "createdAt": "2020-12-11T16:09:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE2NzY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3NTkwMA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540175900", "bodyText": "Independently on how we decide about cleanup here, we should not print the stack trace. Please remove.", "author": "cadonna", "createdAt": "2020-12-10T13:40:02Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -597,6 +598,18 @@ public void setStreamsUncaughtExceptionHandler(final java.util.function.Consumer\n         this.streamsUncaughtExceptionHandler = streamsUncaughtExceptionHandler;\n     }\n \n+    public void waitOnThreadState(final StreamThread.State targetState) {\n+        synchronized (stateLock) {\n+            while (state != targetState) {\n+                try {\n+                    stateLock.wait();\n+                } catch (final InterruptedException e) {\n+                    e.printStackTrace();", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM2NDEyNg==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540364126", "bodyText": "I will do what the wait on state method in KafkaStreams does", "author": "wcarlson5", "createdAt": "2020-12-10T17:36:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3NTkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3OTQzNg==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540179436", "bodyText": "This might be a nit, but if we wait on the stream thread state below, why do we not check the stream thread state being not DEAD here? Would be easier to understand when reading the code, IMO.", "author": "cadonna", "createdAt": "2020-12-10T13:45:02Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,25 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        log.warn(\"Cannot add a stream thread in state \" + state());\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {\n+                if (streamThread.isAlive()) {", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyNTAzNA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540225034", "bodyText": "Additionally, we should remove dead stream threads from the list if we encounter any here.", "author": "cadonna", "createdAt": "2020-12-10T14:44:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3OTQzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1ODUwMw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540358503", "bodyText": "we also want to avoid removing threads in PENDING_SHUTDOWN. There should not be any dead threads, this check is to make sure another call the removeThread is not removing the same thread.", "author": "wcarlson5", "createdAt": "2020-12-10T17:28:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3OTQzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1Nzk5Ng==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540857996", "bodyText": "Good point about not removing stream threads in PENDING_SHUTDOWN.\n\nThere should not be any dead threads, this check is to make sure another call the removeThread is not removing the same thread.\n\nRight! Thanks to the new uncaught exception handler! \ud83d\ude00", "author": "cadonna", "createdAt": "2020-12-11T10:48:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3OTQzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE4MjY2Nw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540182667", "bodyText": "Some more information about why we cannot remove a stream thread would be useful.", "author": "cadonna", "createdAt": "2020-12-10T13:49:30Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,25 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        log.warn(\"Cannot add a stream thread in state \" + state());\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {\n+                if (streamThread.isAlive()) {\n+                    streamThread.shutdown();\n+                    if (!streamThread.getName().equals(Thread.currentThread().getName())) {\n+                        streamThread.waitOnThreadState(StreamThread.State.DEAD);\n+                    }\n+                    synchronized (changeThreadCount) {\n+                        final long cacheSizePerThread = threads.size() == 1 ? 0 : getCacheSizePerThread(threads.size() - 1);\n+                        resizeThreadCache(cacheSizePerThread);\n                         threads.remove(streamThread);\n-                        resizeThreadCache(getCacheSizePerThread(threads.size()));\n-                        return Optional.empty();\n                     }\n+                    return Optional.of(streamThread.getName());\n                 }\n             }\n         }\n+        log.warn(\"Cannot remove a stream thread in state \" + state());", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM2MzQzNg==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540363436", "bodyText": "There are two cases. Either there is no threads that can be removed of the client is in the wrong state", "author": "wcarlson5", "createdAt": "2020-12-10T17:35:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE4MjY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE4NzU4MA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540187580", "bodyText": "I think it would be better to use something like Kafka Streams client did not reach state RUNNING as condition details instead of wait until running. BTW, the line is too long. \ud83d\ude01", "author": "cadonna", "createdAt": "2020-12-10T13:56:05Z", "path": "streams/src/test/java/org/apache/kafka/streams/KafkaStreamsTest.java", "diffHunk": "@@ -631,6 +634,23 @@ public void shouldNotAddThreadWhenError() {\n         assertThat(streams.threads.size(), equalTo(oldSize));\n     }\n \n+    @Test\n+    public void shouldRemoveThread() throws InterruptedException {\n+        props.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, 2);\n+        final KafkaStreams streams = new KafkaStreams(getBuilderWithSource().build(), props, supplier, time);\n+        streams.start();\n+        final int oldSize = streams.threads.size();\n+        TestUtils.waitForCondition(() -> streams.state() == KafkaStreams.State.RUNNING, 15L, \"wait until running\");", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE5MDM1OQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540190359", "bodyText": "Why do you not verify the number of the stream threads also here?", "author": "cadonna", "createdAt": "2020-12-10T13:59:45Z", "path": "streams/src/test/java/org/apache/kafka/streams/KafkaStreamsTest.java", "diffHunk": "@@ -631,6 +634,23 @@ public void shouldNotAddThreadWhenError() {\n         assertThat(streams.threads.size(), equalTo(oldSize));\n     }\n \n+    @Test\n+    public void shouldRemoveThread() throws InterruptedException {\n+        props.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, 2);\n+        final KafkaStreams streams = new KafkaStreams(getBuilderWithSource().build(), props, supplier, time);\n+        streams.start();\n+        final int oldSize = streams.threads.size();\n+        TestUtils.waitForCondition(() -> streams.state() == KafkaStreams.State.RUNNING, 15L, \"wait until running\");\n+        assertThat(streams.removeStreamThread(), equalTo(Optional.of(\"newThread\")));\n+        assertThat(streams.threads.size(), equalTo(oldSize - 1));\n+    }\n+\n+    @Test\n+    public void shouldNotRemoveThreadWhenNotRunning() {\n+        props.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1);\n+        final KafkaStreams streams = new KafkaStreams(getBuilderWithSource().build(), props, supplier, time);\n+        assertThat(streams.removeStreamThread(), equalTo(Optional.empty()));\n+    }", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE5MTI4Ng==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540191286", "bodyText": "You should also verify the return value of removeStreamThread() here.", "author": "cadonna", "createdAt": "2020-12-10T14:00:58Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE5Mzg1Mg==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540193852", "bodyText": "A test is missing that verifies the behavior when a stream thread in state DEAD is in the list of stream threads.", "author": "cadonna", "createdAt": "2020-12-10T14:04:30Z", "path": "streams/src/test/java/org/apache/kafka/streams/KafkaStreamsTest.java", "diffHunk": "@@ -631,6 +634,23 @@ public void shouldNotAddThreadWhenError() {\n         assertThat(streams.threads.size(), equalTo(oldSize));\n     }\n \n+    @Test\n+    public void shouldRemoveThread() throws InterruptedException {\n+        props.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, 2);\n+        final KafkaStreams streams = new KafkaStreams(getBuilderWithSource().build(), props, supplier, time);\n+        streams.start();\n+        final int oldSize = streams.threads.size();\n+        TestUtils.waitForCondition(() -> streams.state() == KafkaStreams.State.RUNNING, 15L, \"wait until running\");\n+        assertThat(streams.removeStreamThread(), equalTo(Optional.of(\"newThread\")));\n+        assertThat(streams.threads.size(), equalTo(oldSize - 1));\n+    }\n+\n+    @Test\n+    public void shouldNotRemoveThreadWhenNotRunning() {\n+        props.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1);\n+        final KafkaStreams streams = new KafkaStreams(getBuilderWithSource().build(), props, supplier, time);\n+        assertThat(streams.removeStreamThread(), equalTo(Optional.empty()));\n+    }\n ", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM2NjM1Mg==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540366352", "bodyText": "There is no case where a streamThread should be dead in the thread list", "author": "wcarlson5", "createdAt": "2020-12-10T17:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE5Mzg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2MDc1OQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540860759", "bodyText": "Fair enough! Still we need to test also when a thread in not alive, i.e., thread.isAlive() == false", "author": "cadonna", "createdAt": "2020-12-11T10:52:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE5Mzg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA0NzgwMg==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r541047802", "bodyText": "Sure added", "author": "wcarlson5", "createdAt": "2020-12-11T15:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE5Mzg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIwNDU4MQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540204581", "bodyText": "Could you please add some line breaks? This and some of the other verifications are too long.", "author": "cadonna", "createdAt": "2020-12-10T14:19:03Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIwNTc0MA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540205740", "bodyText": "nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.", "author": "cadonna", "createdAt": "2020-12-10T14:20:34Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIwOTI3Ng==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540209276", "bodyText": "nit: wrong indentation", "author": "cadonna", "createdAt": "2020-12-10T14:24:52Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxMTMzMQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540211331", "bodyText": "IMO, this string should give details when the condition is not met, like stream thread has not been added. Same applies to the other wait conditions.", "author": "cadonna", "createdAt": "2020-12-10T14:27:26Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxMzAwMA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540213000", "bodyText": "This is not a guarantee that we give in the KIP. Assuming that always the first stream thread is removed is too strict for this test.", "author": "cadonna", "createdAt": "2020-12-10T14:29:36Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n+            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+\n+\n+            oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"2\", \"3\"}));", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4MTQwNA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540381404", "bodyText": "That is true, Will remove", "author": "wcarlson5", "createdAt": "2020-12-10T17:59:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxMzAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxNDU2OA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540214568", "bodyText": "Here you should test if the stream thread has the name of the stream thread that was removed before.", "author": "cadonna", "createdAt": "2020-12-10T14:31:37Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n+            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+\n+\n+            oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"2\", \"3\"}));\n+\n+            final Optional<String> name2 = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name2.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4MzE3OA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540383178", "bodyText": "will do", "author": "wcarlson5", "createdAt": "2020-12-10T18:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxNDU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxNjE0OQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540216149", "bodyText": "You verify the wrong name here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        assertThat(name, CoreMatchers.not(Optional.empty()));\n          \n          \n            \n                        assertThat(name2, CoreMatchers.not(Optional.empty()));", "author": "cadonna", "createdAt": "2020-12-10T14:33:37Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n+            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+\n+\n+            oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"2\", \"3\"}));\n+\n+            final Optional<String> name2 = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4MTYyMw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540381623", "bodyText": "good catch", "author": "wcarlson5", "createdAt": "2020-12-10T18:00:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxNjE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxODYyMg==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540218622", "bodyText": "Why not name.get() instead of name.orElse(\"\")?", "author": "cadonna", "createdAt": "2020-12-10T14:36:46Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM3ODM1NA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540378354", "bodyText": "it can be either", "author": "wcarlson5", "createdAt": "2020-12-10T17:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxODYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyMDE0Nw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540220147", "bodyText": "Could surround this call with new lines as you did for the others? Makes the calls under test more visible.", "author": "cadonna", "createdAt": "2020-12-10T14:38:45Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n+            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+\n+\n+            oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM3OTUyMA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540379520", "bodyText": "yes", "author": "wcarlson5", "createdAt": "2020-12-10T17:57:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyMDE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyMDI1Mg==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540220252", "bodyText": "Please remove empty line.", "author": "cadonna", "createdAt": "2020-12-10T14:38:55Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n+            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyMTM3MQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540221371", "bodyText": "Why do you not verify the actual name since it is well defined in the KIP which name should be returned given that we know that the other two stream thread are named 1 and 2?", "author": "cadonna", "createdAt": "2020-12-10T14:40:17Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM3NzgwNA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540377804", "bodyText": "we can verify here, we verify the names in a few lines as well", "author": "wcarlson5", "createdAt": "2020-12-10T17:54:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyMTM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyMjM1OA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540222358", "bodyText": "Could you add a verification that the returned name is not empty?", "author": "cadonna", "createdAt": "2020-12-10T14:41:33Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n+            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+\n+\n+            oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();", "originalCommit": "338045c9b62c3b6154789d9cfa9a1cf104188e16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM3OTU3Ng==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540379576", "bodyText": "yes", "author": "wcarlson5", "createdAt": "2020-12-10T17:57:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyMjM1OA=="}], "type": "inlineReview"}, {"oid": "2eb05bc3ff6aedc326cc61f57e138b6cee869509", "url": "https://github.com/apache/kafka/commit/2eb05bc3ff6aedc326cc61f57e138b6cee869509", "message": "init commit", "committedDate": "2020-12-11T21:33:50Z", "type": "commit"}, {"oid": "c5c74960741998bd4867eaaecce4fff77716a31a", "url": "https://github.com/apache/kafka/commit/c5c74960741998bd4867eaaecce4fff77716a31a", "message": "fix wait", "committedDate": "2020-12-11T21:33:50Z", "type": "commit"}, {"oid": "b22a31b4ff70b9e5e9ccb2b0673106499c648ffd", "url": "https://github.com/apache/kafka/commit/b22a31b4ff70b9e5e9ccb2b0673106499c648ffd", "message": "fix wait + add name tests", "committedDate": "2020-12-11T21:33:50Z", "type": "commit"}, {"oid": "9f9d9e94fbba6ac2b022e9d7e1670cfd3d3db708", "url": "https://github.com/apache/kafka/commit/9f9d9e94fbba6ac2b022e9d7e1670cfd3d3db708", "message": "remove extra lines", "committedDate": "2020-12-11T21:33:50Z", "type": "commit"}, {"oid": "27a9361d35a7bbe0a532607e4ef5f7a7d1eb9f06", "url": "https://github.com/apache/kafka/commit/27a9361d35a7bbe0a532607e4ef5f7a7d1eb9f06", "message": "javadoc fixes", "committedDate": "2020-12-11T21:33:50Z", "type": "commit"}, {"oid": "d0c589c5b7bc3431d0611dd1a05840003d01c2ca", "url": "https://github.com/apache/kafka/commit/d0c589c5b7bc3431d0611dd1a05840003d01c2ca", "message": "respond to Sophie's comments", "committedDate": "2020-12-11T21:33:50Z", "type": "commit"}, {"oid": "68b9da5f45dc46d93d5646417961229f5a5d976d", "url": "https://github.com/apache/kafka/commit/68b9da5f45dc46d93d5646417961229f5a5d976d", "message": "Bruno's comments", "committedDate": "2020-12-11T21:33:50Z", "type": "commit"}, {"oid": "9eaf17d325e4428ba70e39ebe96be75b0724b46d", "url": "https://github.com/apache/kafka/commit/9eaf17d325e4428ba70e39ebe96be75b0724b46d", "message": "cleanup", "committedDate": "2020-12-11T21:33:50Z", "type": "commit"}, {"oid": "1a7e48b66770a8a506a3a2e7c45a3e58aa5357ac", "url": "https://github.com/apache/kafka/commit/1a7e48b66770a8a506a3a2e7c45a3e58aa5357ac", "message": "cleanup", "committedDate": "2020-12-11T21:33:50Z", "type": "commit"}, {"oid": "181f25835076b897aa13a7626c0d1590b7fd6043", "url": "https://github.com/apache/kafka/commit/181f25835076b897aa13a7626c0d1590b7fd6043", "message": "address comments", "committedDate": "2021-01-04T22:04:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMjA0Mw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553002043", "bodyText": "I know Bruno brought this up already and maybe I just missed the resolution in the previous comments, but: should we allow a StreamThread to remove itself? Originally I was thinking \"no\" but I was just thinking about what be the expected behavior from this method when called from a StreamThread, and I actually think we should consider ONLY removing the calling thread.\nI get the sense that users will interpret removeStreamThread() when called from a Thread as essentially saying \"shutdown this thread\", not \"remove some random thread\". WDYT?", "author": "ableegoldman", "createdAt": "2021-01-06T22:44:36Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -947,24 +948,65 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        log.warn(\"Cannot add a stream thread in state \" + state());\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            synchronized (changeThreadCount) {\n+                for (final StreamThread streamThread : threads) {\n+                    if (streamThread.isAlive()) {\n                         streamThread.shutdown();\n+                        if (!streamThread.getName().equals(Thread.currentThread().getName())) {", "originalCommit": "181f25835076b897aa13a7626c0d1590b7fd6043", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMzA1Mw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553003053", "bodyText": "I think we should assert one or the other at least, ie we only ever remove the current thread or we only ever remove a different thread. And document this clearly of course \ud83d\ude42", "author": "ableegoldman", "createdAt": "2021-01-06T22:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMjA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNDc5MQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553004791", "bodyText": "We want to avoid removing the calling thread because the idea is that the call will block until thread is gone. This is best for the cache resizing too. However I do not like the idea of not letting a thread remove itself because, if we have one stream thread left not letting that thread remove it self (maybe leaving a global thread) this seems incomplete. If we need to make this more structured maybe we only remove itself if is the only thread running? that should make the cache and blocking issue less of a problem. How does that sound?", "author": "wcarlson5", "createdAt": "2021-01-06T22:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMjA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNTY4NQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553005685", "bodyText": "@ableegoldman I don't know about only letting it remove its self. Not only stream threads can call this.", "author": "wcarlson5", "createdAt": "2021-01-06T22:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMjA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNzkwNw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553007907", "bodyText": "Sorry, my suggestion was vaguely worded. I meant that we should only let a StreamThread remove itself, if we detect that removeThread has been called by a StreamThread (which should be possible). If it's called by something else, then yes we should just pick a random thread to remove. I think that addresses your concern in the first sentence of your reply, but let me know if I'm misinterpreting it.\n\nI do not like the idea of not letting a thread remove itself because, if we have one stream thread left not letting that thread remove it self (maybe leaving a global thread) this seems incomplete.\n\nThat's a good point. In that case I would advocate for only letting a StreamThread remove itself. Do you see any problems with that?", "author": "ableegoldman", "createdAt": "2021-01-06T23:02:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMjA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAxMTg3Mg==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553011872", "bodyText": "well there is the issue of the cache resize. Which we wait until thread is dead before changing the cache size. We can not do that when a thread removes itself which makes it possible for OOM. (#9695 (comment)) so it think it would be best to avoid removing itself if possible. unless it is the last thread", "author": "wcarlson5", "createdAt": "2021-01-06T23:14:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMjA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAxNjIxMQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553016211", "bodyText": "So we should try removing any other thread, if one exists, and only allow to remove the current thread if it's the last one? That sounds reasonable, let's go with that", "author": "ableegoldman", "createdAt": "2021-01-06T23:27:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMjA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAxNjgzOQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553016839", "bodyText": "cool I'll make those changes. Basically a thread can only remove itself if it is the only thread left", "author": "wcarlson5", "createdAt": "2021-01-06T23:30:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMjA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNTE4Ng==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553005186", "bodyText": "Awesome, thanks for adding this test. One small suggestion would be to wait for the client to get back to RUNNING at the end, so we can verify that everything did go smoothly with the add/remove. I think this would be good to do in all of these tests, actually", "author": "ableegoldman", "createdAt": "2021-01-06T22:53:55Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -97,15 +99,132 @@ public void shouldAddStreamThread() throws Exception {\n \n             final Optional<String> name = kafkaStreams.addStreamThread();\n \n-            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            assertThat(name, not(Optional.empty()));\n             TestUtils.waitForCondition(\n                 () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n                         .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n                 \"Wait for the thread to be added\"\n             );\n             assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n-            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n-            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+            assertThat(\n+                kafkaStreams\n+                    .localThreadsMetadata()\n+                    .stream()\n+                    .map(t -> t.threadName().split(\"-StreamThread-\")[1])\n+                    .sorted().toArray(),\n+                equalTo(new String[] {\"1\", \"2\", \"3\"})\n+            );\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.state() == KafkaStreams.State.RUNNING,\n+                \"Kafka Streams client did not reach state RUNNING\"\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.removeStreamThread().get().split(\"-\")[0], equalTo(appId));\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveThreads() throws InterruptedException {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            final CountDownLatch latch = new CountDownLatch(2);\n+            final Thread one = adjustCountHelperThread(kafkaStreams, 4, latch);\n+            final Thread two = adjustCountHelperThread(kafkaStreams, 6, latch);\n+            two.start();\n+            one.start();\n+            latch.await(30, TimeUnit.SECONDS);\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount));\n+        }", "originalCommit": "181f25835076b897aa13a7626c0d1590b7fd6043", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNTcxNw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553005717", "bodyText": "good idea", "author": "wcarlson5", "createdAt": "2021-01-06T22:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNTE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNjE5MQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553006191", "bodyText": "One more corner case we should add test coverage for is what happens when we get down to 0 threads. Two things to verify  that I can think of are: (1) that the client stays in RUNNING, and (2) that we can add more threads again after we've been idling with zero threads for a short while (and as always, that it goes into REBALANCING --> RUNNING after adding the threads)", "author": "ableegoldman", "createdAt": "2021-01-06T22:56:55Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -97,15 +99,132 @@ public void shouldAddStreamThread() throws Exception {\n \n             final Optional<String> name = kafkaStreams.addStreamThread();\n \n-            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            assertThat(name, not(Optional.empty()));\n             TestUtils.waitForCondition(\n                 () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n                         .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n                 \"Wait for the thread to be added\"\n             );\n             assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n-            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n-            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+            assertThat(\n+                kafkaStreams\n+                    .localThreadsMetadata()\n+                    .stream()\n+                    .map(t -> t.threadName().split(\"-StreamThread-\")[1])\n+                    .sorted().toArray(),\n+                equalTo(new String[] {\"1\", \"2\", \"3\"})\n+            );\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.state() == KafkaStreams.State.RUNNING,\n+                \"Kafka Streams client did not reach state RUNNING\"\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {", "originalCommit": "181f25835076b897aa13a7626c0d1590b7fd6043", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNzc3NA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553007774", "bodyText": "Well right now it would not stay in running until https://github.com/apache/kafka/pull/9720/files gets merged. So we can in a follow up PR get that corner case tested.", "author": "wcarlson5", "createdAt": "2021-01-06T23:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNjE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwODkzMw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553008933", "bodyText": "Ah, right. Would it make sense to add this test in the above PR instead? Or something in the middle, you could add the test in this PR and just leave out (1) for now, then add that check in the other PR.", "author": "ableegoldman", "createdAt": "2021-01-06T23:05:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNjE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAxNDE0NQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553014145", "bodyText": "the above PR doesn't have the remove as its in this PR. bit of a circular dependency :)\nWe do test that the client stays in running after shutting down some threads. We can add a test to add threads after we shut them down. However I would like to test it with remove thread anyways so if this get merged first I will update the above PR", "author": "wcarlson5", "createdAt": "2021-01-06T23:20:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNjE5MQ=="}], "type": "inlineReview"}, {"oid": "8e85b199a73557d3e6dcf4f2c8d26cc0b3bb04ae", "url": "https://github.com/apache/kafka/commit/8e85b199a73557d3e6dcf4f2c8d26cc0b3bb04ae", "message": "added wait for running in tests", "committedDate": "2021-01-06T23:42:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyMzY3NQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553023675", "bodyText": "I guess technically this might not work if we have only one live thread left, but other dead threads still in the list -- in that case we might skip over the live thread when we really should have removed it. I'm not sure how much of a problem this would really be, just wanted to point it out.", "author": "ableegoldman", "createdAt": "2021-01-06T23:54:06Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -992,7 +992,7 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n         if (isRunningOrRebalancing()) {\n             synchronized (changeThreadCount) {\n                 for (final StreamThread streamThread : threads) {\n-                    if (streamThread.isAlive()) {\n+                    if (streamThread.isAlive() && (!streamThread.getName().equals(Thread.currentThread().getName()) || threads.size() == 1)) {", "originalCommit": "8e85b199a73557d3e6dcf4f2c8d26cc0b3bb04ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA0MjgwNQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553042805", "bodyText": "We don't keep the dead threads in this list. When a thread dies we remove it form the list and updated the number of dead threads metric.", "author": "wcarlson5", "createdAt": "2021-01-07T00:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyMzY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA3ODU4MQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553078581", "bodyText": "Then why check isAlive() here at all? (I'm not necessarily requesting changes here, just trying to understand)", "author": "ableegoldman", "createdAt": "2021-01-07T02:44:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyMzY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEzODA3Nw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r555138077", "bodyText": "there is a very small window between when thread dies with the old handler and when it is removed from the the list. So we have to check to make sure for now", "author": "wcarlson5", "createdAt": "2021-01-11T15:44:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyMzY3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyNDQ0Mw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553024443", "bodyText": "Ah, sorry I didn't think of this/mention it before, but I think we actually need to wait for a transition to RUNNING, and not just for it to be in the state itself. It probably takes a little while after removing a thread for the rebalance to occur, so it's probably already in RUNNING. Pretty sure there's some other integration test util that watches for the REBALANCING -> RUNNING transition, though", "author": "ableegoldman", "createdAt": "2021-01-06T23:56:52Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -128,6 +133,7 @@ public void shouldRemoveStreamThread() throws Exception {\n             final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n             assertThat(kafkaStreams.removeStreamThread().get().split(\"-\")[0], equalTo(appId));\n             assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+            waitForApplicationState(Collections.singletonList(kafkaStreams), KafkaStreams.State.RUNNING, DEFAULT_DURATION);", "originalCommit": "8e85b199a73557d3e6dcf4f2c8d26cc0b3bb04ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA0MzczMQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553043731", "bodyText": "ah okay that makes sense", "author": "wcarlson5", "createdAt": "2021-01-07T00:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyNDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA0NzMwOA==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553047308", "bodyText": "I didn't see that util but this should work", "author": "wcarlson5", "createdAt": "2021-01-07T00:48:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyNDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA3OTc5MQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553079791", "bodyText": "Cool, what you did below (waitForApplicationState on REBALANCING before RUNNING) looks good. But I think you missed doing that here -- in fact we should probably do a similar thing in all the tests in this class. Can you just give the file a final pass and make sure we verify the REBALANCING -> RUNNING transition in all of the tests?", "author": "ableegoldman", "createdAt": "2021-01-07T02:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyNDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU2MTM1Mw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553561353", "bodyText": "added", "author": "wcarlson5", "createdAt": "2021-01-07T20:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyNDQ0Mw=="}], "type": "inlineReview"}, {"oid": "306a139fd0670f6f5fff7c225fc87a9c1063a29b", "url": "https://github.com/apache/kafka/commit/306a139fd0670f6f5fff7c225fc87a9c1063a29b", "message": "ensure at least one rebalance occures", "committedDate": "2021-01-07T00:48:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM4MDUxMg==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553380512", "bodyText": "nit: Could you please rename the createStreamThread() to createAndAddStreamThread(). It is a bit weird that we have threads.remove() in this method but no threads.add(). The renaming would make it clearer.", "author": "cadonna", "createdAt": "2021-01-07T14:59:28Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -947,24 +948,65 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);", "originalCommit": "306a139fd0670f6f5fff7c225fc87a9c1063a29b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM4NDA0OQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553384049", "bodyText": "nit: To deduplicate code, you could also remove these two lines, because they are the same as the last two lines of the method.\nnit: Could you change Cannot add a stream thread in state \" + state() to Cannot add a stream thread when Kafka Streams client is in state \" + state(), or similar. Currently, it is not completely clear if the state belongs to the stream thread or to the client.", "author": "cadonna", "createdAt": "2021-01-07T15:05:03Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -947,24 +948,65 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();", "originalCommit": "306a139fd0670f6f5fff7c225fc87a9c1063a29b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM4NjI5Mw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553386293", "bodyText": "See my nit comment above.", "author": "cadonna", "createdAt": "2021-01-07T15:08:39Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -947,24 +948,65 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        log.warn(\"Cannot add a stream thread in state \" + state());\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            synchronized (changeThreadCount) {\n+                for (final StreamThread streamThread : threads) {\n+                    if (streamThread.isAlive() && (!streamThread.getName().equals(Thread.currentThread().getName()) || threads.size() == 1)) {\n                         streamThread.shutdown();\n+                        if (!streamThread.getName().equals(Thread.currentThread().getName())) {\n+                            streamThread.waitOnThreadState(StreamThread.State.DEAD);\n+                        }\n                         threads.remove(streamThread);\n-                        resizeThreadCache(getCacheSizePerThread(threads.size()));\n-                        return Optional.empty();\n+                        final long cacheSizePerThread = getCacheSizePerThread(threads.size());\n+                        resizeThreadCache(cacheSizePerThread);\n+                        return Optional.of(streamThread.getName());\n                     }\n                 }\n             }\n+            log.warn(\"There are no threads eligible for removal\");\n+        } else {\n+            log.warn(\"Cannot remove a stream thread in state \" + state());", "originalCommit": "306a139fd0670f6f5fff7c225fc87a9c1063a29b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM5ODIwOQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553398209", "bodyText": "Do we not need to synchronize this block on the changeThreadCount to at least guarantee that the state is correct when the method returns? Otherwise between the if and threadMetadata.add(thread.threadMetadata()) the stream thread might transit to DEAD.", "author": "cadonna", "createdAt": "2021-01-07T15:27:33Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -1432,7 +1480,9 @@ public void cleanUp() {\n         validateIsRunningOrRebalancing();\n         final Set<ThreadMetadata> threadMetadata = new HashSet<>();\n         for (final StreamThread thread : threads) {\n-            threadMetadata.add(thread.threadMetadata());\n+            if (thread.state() != StreamThread.State.DEAD) {\n+                threadMetadata.add(thread.threadMetadata());\n+            }\n         }\n         return threadMetadata;", "originalCommit": "306a139fd0670f6f5fff7c225fc87a9c1063a29b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ5MDEyNw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553490127", "bodyText": "changeThreadCount  would not take care of that we need to sync on the thread state", "author": "wcarlson5", "createdAt": "2021-01-07T17:57:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM5ODIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk4ODE3MQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553988171", "bodyText": "Ah yes, you are right! The stream thread might be replaced or just normally shut down which would not be synchronized on the changeThreadCount lock. However, we still do not guarantee that the state is correct when the method returns, because the state could change after the lock is released but before the method returns. At this point with or without lock it doesn't matter. Either we find something that synchronizes the whole method or we can also remove the synchronisation on the stream thread state. And also if we find something that synchronizes the whole method, I am not sure if this guarantee is worth the hassle. WDYT?", "author": "cadonna", "createdAt": "2021-01-08T14:51:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM5ODIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE0MTU2Mw==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r555141563", "bodyText": "since changing the thread metadata uses a copy once its is added to the list as not dead it insures that we won't return a dead thread. And after we and it to the list we don't need to care until method is called again", "author": "wcarlson5", "createdAt": "2021-01-11T15:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM5ODIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQxMjY4MQ==", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553412681", "bodyText": "nit: My IDE says that the cast is not needed.", "author": "cadonna", "createdAt": "2021-01-07T15:49:01Z", "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -424,6 +424,7 @@ public void setUncaughtExceptionHandler(final StreamsUncaughtExceptionHandler st\n \n     private void defaultStreamsUncaughtExceptionHandler(final Throwable throwable) {\n         if (oldHandler) {\n+            threads.remove((StreamThread) Thread.currentThread());", "originalCommit": "306a139fd0670f6f5fff7c225fc87a9c1063a29b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dab30d6e6d79c49ee9274730788cb8ba0a668fbc", "url": "https://github.com/apache/kafka/commit/dab30d6e6d79c49ee9274730788cb8ba0a668fbc", "message": "comments", "committedDate": "2021-01-07T18:25:02Z", "type": "commit"}, {"oid": "d0ebbdbc44ffe154d5bff5ef93ec3d16748b380c", "url": "https://github.com/apache/kafka/commit/d0ebbdbc44ffe154d5bff5ef93ec3d16748b380c", "message": "comments", "committedDate": "2021-01-07T20:08:26Z", "type": "commit"}]}