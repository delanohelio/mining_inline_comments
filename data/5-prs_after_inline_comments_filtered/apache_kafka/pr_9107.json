{"pr_number": 9107, "pr_title": "KAFKA-5488: Add type-safe split() operator", "pr_createdAt": "2020-07-30T22:30:31Z", "pr_url": "https://github.com/apache/kafka/pull/9107", "timeline": [{"oid": "8a77301eb628e6684768a5405144a0d02ed17ac2", "url": "https://github.com/apache/kafka/commit/8a77301eb628e6684768a5405144a0d02ed17ac2", "message": "Documentation update", "committedDate": "2020-12-20T15:53:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU4NzUyMQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547587521", "bodyText": "nit: should be one line (easier to read)", "author": "mjsax", "createdAt": "2020-12-23T01:16:10Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+/**\r\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\r\n+ * {@link BranchedKStream}.\r\n+ *\r\n+ * @param <K> type of record key\r\n+ * @param <V> type of record value\r\n+ */\r\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\r\n+\r\n+    protected final String name;\r\n+    protected final Function<? super KStream<K, V>,\r\n+            ? extends KStream<K, V>> chainFunction;\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU4NzkzOA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547587938", "bodyText": "nit: {@link ' -> {@code(we should use@linkto link to other classes but use@code` to refer to ourself -- there is no point in letting a JavaDoc page link to itself.\nSimilar below.", "author": "mjsax", "createdAt": "2020-12-23T01:17:55Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+/**\r\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\r\n+ * {@link BranchedKStream}.\r\n+ *\r\n+ * @param <K> type of record key\r\n+ * @param <V> type of record value\r\n+ */\r\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\r\n+\r\n+    protected final String name;\r\n+    protected final Function<? super KStream<K, V>,\r\n+            ? extends KStream<K, V>> chainFunction;\r\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\r\n+\r\n+    protected Branched(final String name,\r\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\r\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\r\n+        this.name = name;\r\n+        this.chainFunction = chainFunction;\r\n+        this.chainConsumer = chainConsumer;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} from an existing instance.\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU4ODUwNQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547588505", "bodyText": "nit: can you first have all the static builder methods and the instance methods at the end of the class?", "author": "mjsax", "createdAt": "2020-12-23T01:20:10Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+/**\r\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\r\n+ * {@link BranchedKStream}.\r\n+ *\r\n+ * @param <K> type of record key\r\n+ * @param <V> type of record value\r\n+ */\r\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\r\n+\r\n+    protected final String name;\r\n+    protected final Function<? super KStream<K, V>,\r\n+            ? extends KStream<K, V>> chainFunction;\r\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\r\n+\r\n+    protected Branched(final String name,\r\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\r\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\r\n+        this.name = name;\r\n+        this.chainFunction = chainFunction;\r\n+        this.chainConsumer = chainConsumer;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} from an existing instance.\r\n+     *\r\n+     * @param branched the instance of {@link Branched} to copy\r\n+     */\r\n+    protected Branched(final Branched<K, V> branched) {\r\n+        this(branched.name, branched.chainFunction, branched.chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configure the instance of {@link Branched} with a branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\r\n+     *             {@link BranchedKStream} description for details)\r\n+     * @return {@code this}\r\n+     */\r\n+    @Override\r\n+    public Branched<K, V> withName(final String name) {\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU4ODgwMw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547588803", "bodyText": "nit supposed -> used ?\nthis function -> the provided function", "author": "mjsax", "createdAt": "2020-12-23T01:21:33Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+/**\r\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\r\n+ * {@link BranchedKStream}.\r\n+ *\r\n+ * @param <K> type of record key\r\n+ * @param <V> type of record value\r\n+ */\r\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\r\n+\r\n+    protected final String name;\r\n+    protected final Function<? super KStream<K, V>,\r\n+            ? extends KStream<K, V>> chainFunction;\r\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\r\n+\r\n+    protected Branched(final String name,\r\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\r\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\r\n+        this.name = name;\r\n+        this.chainFunction = chainFunction;\r\n+        this.chainConsumer = chainConsumer;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} from an existing instance.\r\n+     *\r\n+     * @param branched the instance of {@link Branched} to copy\r\n+     */\r\n+    protected Branched(final Branched<K, V> branched) {\r\n+        this(branched.name, branched.chainFunction, branched.chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configure the instance of {@link Branched} with a branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\r\n+     *             {@link BranchedKStream} description for details)\r\n+     * @return {@code this}\r\n+     */\r\n+    @Override\r\n+    public Branched<K, V> withName(final String name) {\r\n+        return new Branched<>(name, chainFunction, chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\r\n+     *             (see {@link BranchedKStream} description for details)\r\n+     * @param <K>  key type\r\n+     * @param <V>  value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> as(final String name) {\r\n+        return new Branched<>(name, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function.\r\n+     *\r\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\r\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5NzEzNQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547597135", "bodyText": "Actually, I am wondering if we should allow to pass in null? Thoughts?", "author": "mjsax", "createdAt": "2020-12-23T01:56:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU4ODgwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwMzgyNA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548503824", "bodyText": "See my reply below, where we discuss null consumers: #9107 (comment)\n(in short: I agree, I think we shouldn't)", "author": "inponomarev", "createdAt": "2020-12-24T11:38:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU4ODgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU4OTU3MA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547589570", "bodyText": "If a non-null branch is provided here? (branch -> consumer?)\nBut I would propose to simplify it, and just use By default (as passing in a non-null consumer should be the \"default\" usage).", "author": "mjsax", "createdAt": "2020-12-23T01:24:46Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+/**\r\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\r\n+ * {@link BranchedKStream}.\r\n+ *\r\n+ * @param <K> type of record key\r\n+ * @param <V> type of record value\r\n+ */\r\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\r\n+\r\n+    protected final String name;\r\n+    protected final Function<? super KStream<K, V>,\r\n+            ? extends KStream<K, V>> chainFunction;\r\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\r\n+\r\n+    protected Branched(final String name,\r\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\r\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\r\n+        this.name = name;\r\n+        this.chainFunction = chainFunction;\r\n+        this.chainConsumer = chainConsumer;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} from an existing instance.\r\n+     *\r\n+     * @param branched the instance of {@link Branched} to copy\r\n+     */\r\n+    protected Branched(final Branched<K, V> branched) {\r\n+        this(branched.name, branched.chainFunction, branched.chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configure the instance of {@link Branched} with a branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\r\n+     *             {@link BranchedKStream} description for details)\r\n+     * @return {@code this}\r\n+     */\r\n+    @Override\r\n+    public Branched<K, V> withName(final String name) {\r\n+        return new Branched<>(name, chainFunction, chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\r\n+     *             (see {@link BranchedKStream} description for details)\r\n+     * @param <K>  key type\r\n+     * @param <V>  value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> as(final String name) {\r\n+        return new Branched<>(name, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function.\r\n+     *\r\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\r\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\r\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details).\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withFunction(\r\n+            final Function<? super KStream<K, V>,\r\n+                    ? extends KStream<K, V>> chain) {\r\n+        return new Branched<>(null, chain, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain consumer.\r\n+     *\r\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5NzI5Mw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547597293", "bodyText": "As above, should we even allow a not-null consumer?", "author": "mjsax", "createdAt": "2020-12-23T01:56:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU4OTU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUxNTUyNg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548515526", "bodyText": "see #9107 (comment)", "author": "inponomarev", "createdAt": "2020-12-24T12:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU4OTU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MDAyNw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547590027", "bodyText": "If {@code null} is passed instead of an actual consumer, the branch will be added unmodified to the resulting {@code Map}.", "author": "mjsax", "createdAt": "2020-12-23T01:26:28Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+/**\r\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\r\n+ * {@link BranchedKStream}.\r\n+ *\r\n+ * @param <K> type of record key\r\n+ * @param <V> type of record value\r\n+ */\r\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\r\n+\r\n+    protected final String name;\r\n+    protected final Function<? super KStream<K, V>,\r\n+            ? extends KStream<K, V>> chainFunction;\r\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\r\n+\r\n+    protected Branched(final String name,\r\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\r\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\r\n+        this.name = name;\r\n+        this.chainFunction = chainFunction;\r\n+        this.chainConsumer = chainConsumer;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} from an existing instance.\r\n+     *\r\n+     * @param branched the instance of {@link Branched} to copy\r\n+     */\r\n+    protected Branched(final Branched<K, V> branched) {\r\n+        this(branched.name, branched.chainFunction, branched.chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configure the instance of {@link Branched} with a branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\r\n+     *             {@link BranchedKStream} description for details)\r\n+     * @return {@code this}\r\n+     */\r\n+    @Override\r\n+    public Branched<K, V> withName(final String name) {\r\n+        return new Branched<>(name, chainFunction, chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\r\n+     *             (see {@link BranchedKStream} description for details)\r\n+     * @param <K>  key type\r\n+     * @param <V>  value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> as(final String name) {\r\n+        return new Branched<>(name, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function.\r\n+     *\r\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\r\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\r\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details).\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withFunction(\r\n+            final Function<? super KStream<K, V>,\r\n+                    ? extends KStream<K, V>> chain) {\r\n+        return new Branched<>(null, chain, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain consumer.\r\n+     *\r\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\r\n+     *              the respective branch will not be added to the resulting {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5NzY4Mw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547597683", "bodyText": "I tried to read up on the KIP discussion thread, and I am wondering if we did agree to this behavior? My understanding was that if a consumer is use, there won't be any entry in the Map for this branch?", "author": "mjsax", "createdAt": "2020-12-23T01:58:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MDAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUxNTE4MQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548515181", "bodyText": "OK let me explain how I understood this:\nLet's try to forget about Java type system and look at the problem conceptually, from set / category theory point of view\nWe're using either function or consumer or nothing for branch processing. From mathematical point of view, we can consider consumer to be a function that maps its domain to the empty set. This explains our decision why consumer 'swallows' branch unlike function that 'forwards' its result to the resulting map. Then we agreed that the case when nothing is provided, like in this example\nBranchedKStream<Integer, String> branch = source.split()\n          .branch(isEven)\n          .branch(isMultipleOfSeven);\nis to be interpreted like\nBranchedKStream<Integer, String> branch = source.split()\n         .branch(isEven, Branched.withFunction(Function.identity()))\n         .branch(isMultipleOfSeven, Branched.withFunction(Function.identity()));\nNow back to Java: in Java, for nothing we have null. My original intention was to try to emulate Function|Consumer union type using overloading, but Java didn't allow me to do this dirty trick -- and separate withFunction and withConsumer builder methods appeared \ud83d\ude04\nIf I had succeded, it would have made sence to treat null uniformely for both functions and consumers.\nHope this explains why I allowed nulls and always treated it as an identity function.\nBut now I think you're right. It's best to just prohibit passing in nulls and throw explicit NPEs for both functions and consumers. This, at least, can spare us from further debates :-)", "author": "inponomarev", "createdAt": "2020-12-24T12:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MDAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0Mzk0Mw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r549543943", "bodyText": "SGTM. In general, even if possible, I don't like to give null semantics :)", "author": "mjsax", "createdAt": "2020-12-29T02:16:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MDAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MDI2OQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547590269", "bodyText": "nit: formatting\nfinal Function<? super KStream<K, V>, ? extends KStream<K, V>> chain,\nfinal String name) {", "author": "mjsax", "createdAt": "2020-12-23T01:27:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+/**\r\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\r\n+ * {@link BranchedKStream}.\r\n+ *\r\n+ * @param <K> type of record key\r\n+ * @param <V> type of record value\r\n+ */\r\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\r\n+\r\n+    protected final String name;\r\n+    protected final Function<? super KStream<K, V>,\r\n+            ? extends KStream<K, V>> chainFunction;\r\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\r\n+\r\n+    protected Branched(final String name,\r\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\r\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\r\n+        this.name = name;\r\n+        this.chainFunction = chainFunction;\r\n+        this.chainConsumer = chainConsumer;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} from an existing instance.\r\n+     *\r\n+     * @param branched the instance of {@link Branched} to copy\r\n+     */\r\n+    protected Branched(final Branched<K, V> branched) {\r\n+        this(branched.name, branched.chainFunction, branched.chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configure the instance of {@link Branched} with a branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\r\n+     *             {@link BranchedKStream} description for details)\r\n+     * @return {@code this}\r\n+     */\r\n+    @Override\r\n+    public Branched<K, V> withName(final String name) {\r\n+        return new Branched<>(name, chainFunction, chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\r\n+     *             (see {@link BranchedKStream} description for details)\r\n+     * @param <K>  key type\r\n+     * @param <V>  value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> as(final String name) {\r\n+        return new Branched<>(name, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function.\r\n+     *\r\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\r\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\r\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details).\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withFunction(\r\n+            final Function<? super KStream<K, V>,\r\n+                    ? extends KStream<K, V>> chain) {\r\n+        return new Branched<>(null, chain, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain consumer.\r\n+     *\r\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\r\n+     *              the respective branch will not be added to the resulting {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\r\n+     *              and the branch will be added to the resulting {@code Map}.\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\r\n+        return new Branched<K, V>(null, null, chain);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\r\n+     *\r\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\r\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\r\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details).\r\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\r\n+     *              (see {@link BranchedKStream} description for details)\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withFunction(\r\n+            final Function<? super KStream<K, V>,\r\n+                    ? extends KStream<K, V>> chain, final String name) {\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MDM3Nw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547590377", "bodyText": "used\nIf the provided function", "author": "mjsax", "createdAt": "2020-12-23T01:27:52Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+/**\r\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\r\n+ * {@link BranchedKStream}.\r\n+ *\r\n+ * @param <K> type of record key\r\n+ * @param <V> type of record value\r\n+ */\r\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\r\n+\r\n+    protected final String name;\r\n+    protected final Function<? super KStream<K, V>,\r\n+            ? extends KStream<K, V>> chainFunction;\r\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\r\n+\r\n+    protected Branched(final String name,\r\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\r\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\r\n+        this.name = name;\r\n+        this.chainFunction = chainFunction;\r\n+        this.chainConsumer = chainConsumer;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} from an existing instance.\r\n+     *\r\n+     * @param branched the instance of {@link Branched} to copy\r\n+     */\r\n+    protected Branched(final Branched<K, V> branched) {\r\n+        this(branched.name, branched.chainFunction, branched.chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configure the instance of {@link Branched} with a branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\r\n+     *             {@link BranchedKStream} description for details)\r\n+     * @return {@code this}\r\n+     */\r\n+    @Override\r\n+    public Branched<K, V> withName(final String name) {\r\n+        return new Branched<>(name, chainFunction, chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\r\n+     *             (see {@link BranchedKStream} description for details)\r\n+     * @param <K>  key type\r\n+     * @param <V>  value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> as(final String name) {\r\n+        return new Branched<>(name, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function.\r\n+     *\r\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\r\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\r\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details).\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withFunction(\r\n+            final Function<? super KStream<K, V>,\r\n+                    ? extends KStream<K, V>> chain) {\r\n+        return new Branched<>(null, chain, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain consumer.\r\n+     *\r\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\r\n+     *              the respective branch will not be added to the resulting {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\r\n+     *              and the branch will be added to the resulting {@code Map}.\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\r\n+        return new Branched<K, V>(null, null, chain);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\r\n+     *\r\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\r\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MDU2Nw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547590567", "bodyText": "as above", "author": "mjsax", "createdAt": "2020-12-23T01:28:39Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+/**\r\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\r\n+ * {@link BranchedKStream}.\r\n+ *\r\n+ * @param <K> type of record key\r\n+ * @param <V> type of record value\r\n+ */\r\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\r\n+\r\n+    protected final String name;\r\n+    protected final Function<? super KStream<K, V>,\r\n+            ? extends KStream<K, V>> chainFunction;\r\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\r\n+\r\n+    protected Branched(final String name,\r\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\r\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\r\n+        this.name = name;\r\n+        this.chainFunction = chainFunction;\r\n+        this.chainConsumer = chainConsumer;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} from an existing instance.\r\n+     *\r\n+     * @param branched the instance of {@link Branched} to copy\r\n+     */\r\n+    protected Branched(final Branched<K, V> branched) {\r\n+        this(branched.name, branched.chainFunction, branched.chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configure the instance of {@link Branched} with a branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null} a default branch name postfix will be generated (see\r\n+     *             {@link BranchedKStream} description for details)\r\n+     * @return {@code this}\r\n+     */\r\n+    @Override\r\n+    public Branched<K, V> withName(final String name) {\r\n+        return new Branched<>(name, chainFunction, chainConsumer);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided branch name postfix.\r\n+     *\r\n+     * @param name the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\r\n+     *             (see {@link BranchedKStream} description for details)\r\n+     * @param <K>  key type\r\n+     * @param <V>  value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> as(final String name) {\r\n+        return new Branched<>(name, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function.\r\n+     *\r\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\r\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\r\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details).\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withFunction(\r\n+            final Function<? super KStream<K, V>,\r\n+                    ? extends KStream<K, V>> chain) {\r\n+        return new Branched<>(null, chain, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain consumer.\r\n+     *\r\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\r\n+     *              the respective branch will not be added to the resulting {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details). If {@code null}, a no-op consumer will be supposed\r\n+     *              and the branch will be added to the resulting {@code Map}.\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\r\n+        return new Branched<K, V>(null, null, chain);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\r\n+     *\r\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\r\n+     *              {@code kStream -> kStream} function will be supposed. If this function returns\r\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\r\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\r\n+     *              {@link BranchedKStream} description for details).\r\n+     * @param name  the branch name postfix to be used. If {@code null}, a default branch name postfix will be generated\r\n+     *              (see {@link BranchedKStream} description for details)\r\n+     * @param <K>   key type\r\n+     * @param <V>   value type\r\n+     * @return a new instance of {@link Branched}\r\n+     */\r\n+    public static <K, V> Branched<K, V> withFunction(\r\n+            final Function<? super KStream<K, V>,\r\n+                    ? extends KStream<K, V>> chain, final String name) {\r\n+        return new Branched<>(name, chain, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance of {@link Branched} with provided chain function and branch name postfix.\r\n+     *\r\n+     * @param chain A consumer to which the branch will be sent. If a non-null branch is provided here,\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MTIxMA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547591210", "bodyText": "Maybe add a note that not all branches are added to the Map?", "author": "mjsax", "createdAt": "2020-12-23T01:31:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUxOTI2OQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548519269", "bodyText": "Rephrased: if certain conditions are met, it also can be accessed from the {@link Map}... -- and all these coditions are described below", "author": "inponomarev", "createdAt": "2020-12-24T12:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MTIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MTUxMQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547591511", "bodyText": "you can apply [multiple] {#filter} [operators], one for each predicate, instead", "author": "mjsax", "createdAt": "2020-12-23T01:32:44Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MTY4Mw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547591683", "bodyText": "nit: Do we need a new paragraph? We get a list below anyway.", "author": "mjsax", "createdAt": "2020-12-23T01:33:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MTkwMQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547591901", "bodyText": "If a [branch?] name is provided [in] {@link BranchedKStream#branch(Predicate, Branched)} via the {@link Branched} parameter", "author": "mjsax", "createdAt": "2020-12-23T01:34:21Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MjMyNw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547592327", "bodyText": "nit: missing . at the end", "author": "mjsax", "createdAt": "2020-12-23T01:36:00Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MjM2OA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547592368", "bodyText": "nit: missing . at the end", "author": "mjsax", "createdAt": "2020-12-23T01:36:09Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUyMTM3OQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548521379", "bodyText": "Do we use dots at the end of list items? (Sorry -- English is my second language so I really don't know. I noticed that sometimes you do but in most cases you don't. In Russian language we must always use dots or commas at the end of list items, but Russian and English punctuations are completely different.)", "author": "inponomarev", "createdAt": "2020-12-24T12:49:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MjM2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzODU5OA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r549538598", "bodyText": "Also my second language... I think, it is mostly a matter of style. Personally, I prefer to use . at the end, because a bullet point is still a sentence from my POV, and actually, a bullet point could be multiple sentences. You also capitalized the first word of each bullet point, so it seems to be a sentence. -- I guess some people don't capitalize the first word and also don't use a . at the en, ie, us a \"no-sentence\" bullet point style. But this only work for \"single sentence\" bullet points.\nIt's really a nit. I just raised my personal (an obviously very subjective) preference.", "author": "mjsax", "createdAt": "2020-12-29T01:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MjM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MjM5Mw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547592393", "bodyText": "nit: missing . at the end", "author": "mjsax", "createdAt": "2020-12-23T01:36:12Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MjYyMQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547592621", "bodyText": "nit: Do we need a new paragraph after a list?", "author": "mjsax", "createdAt": "2020-12-23T01:36:52Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MjY3NQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547592675", "bodyText": "as above", "author": "mjsax", "createdAt": "2020-12-23T01:37:03Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MjY5Nw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547592697", "bodyText": "as above", "author": "mjsax", "createdAt": "2020-12-23T01:37:10Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r\n+ *     identity chain function)\r\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\r\n+ *     the result returned by this function\r\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\r\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\r\n+ * </ul>\r\n+ * <p>\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MzA3Mg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547593072", "bodyText": "is provided [in]\nvia [the] {@link Branched} parameter.", "author": "mjsax", "createdAt": "2020-12-23T01:38:50Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MzMxMA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547593310", "bodyText": "Do we need the content in the parentheses?", "author": "mjsax", "createdAt": "2020-12-23T01:39:54Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r\n+ *     identity chain function)\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUyMzk3Ng==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548523976", "bodyText": "No we don't, removed )", "author": "inponomarev", "createdAt": "2020-12-24T13:00:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MzMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MzM5NQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547593395", "bodyText": "and returns -> that returns (or and it returns)\nvalue -> {@link KStream} ? (and than the returned {@link KStream} is added to the {@code Map}.`", "author": "mjsax", "createdAt": "2020-12-23T01:40:26Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r\n+ *     identity chain function)\r\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MzQ4OQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547593489", "bodyText": "nit: missing \".\" (some for other bullet points)", "author": "mjsax", "createdAt": "2020-12-23T01:40:59Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r\n+ *     identity chain function)\r\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\r\n+ *     the result returned by this function\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5MzkyNA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547593924", "bodyText": "then the value is the branch itself ->  then the branch itself is added to the {@code Map} ?", "author": "mjsax", "createdAt": "2020-12-23T01:43:03Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5NDIzMw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547594233", "bodyText": "the respective entry is not put to the map. -> , then no entry is added to the map.", "author": "mjsax", "createdAt": "2020-12-23T01:44:24Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r\n+ *     identity chain function)\r\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\r\n+ *     the result returned by this function\r\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5NDM2NQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547594365", "bodyText": "If a [non-null] consumer\nthen the the respective entry is not put to the map -> , then no entry is added to the map.", "author": "mjsax", "createdAt": "2020-12-23T01:44:55Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r\n+ *     identity chain function)\r\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\r\n+ *     the result returned by this function\r\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\r\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5NDQ0Nw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547594447", "bodyText": "Seems the null consumer case is missing (is case we want to allow if, but as mentioned above, I have some doubts)?", "author": "mjsax", "createdAt": "2020-12-23T01:45:14Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r\n+ *     identity chain function)\r\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\r\n+ *     the result returned by this function\r\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\r\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\r\n+ * </ul>\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5ODQxOA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547598418", "bodyText": "To simplify the example, should we use predicate1, predicate2 as in the first example?", "author": "mjsax", "createdAt": "2020-12-23T02:01:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r\n+ *     identity chain function)\r\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\r\n+ *     the result returned by this function\r\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\r\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\r\n+ * </ul>\r\n+ * <p>\r\n+ * For example:\r\n+ * <pre> {@code\r\n+ * Map<String, KStream<..., ...>> result =\r\n+ *   source.split(Named.as(\"foo-\"))\r\n+ *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\r\n+ *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\r\n+ *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\r\n+ *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\r\n+ *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\r\n+ * }</pre>\r\n+ *\r\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\r\n+ *\r\n+ * <h3>Direct Branch Consuming</h3>\r\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\r\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\r\n+ *\r\n+ * <pre> {@code\r\n+ * source.split()\r\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.withConsumer(ks -> ks.to(\"A\")))\r\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.withConsumer(ks -> ks.to(\"B\")))\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5OTEwNw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547599107", "bodyText": "{@code BranchedKStream}", "author": "mjsax", "createdAt": "2020-12-23T02:04:21Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r\n+ * <p>\r\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\r\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\r\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\r\n+ *     a prefix for each key. By default, no prefix is used\r\n+ *     <li>If a name is provided for the {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\r\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\r\n+ *     as a decimal number, starting from {@code \"1\"}\r\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\r\n+ *     to {@code prefix + \"0\"}\r\n+ * </ul>\r\n+ * <p>\r\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\r\n+ * <p>\r\n+ * <ul>\r\n+ *     <li>If no chain function or consumer is provided {@link BranchedKStream#branch(Predicate, Branched)} via\r\n+ *     {@link Branched} parameter, then the value is the branch itself (which is equivalent to {@code ks -> ks}\r\n+ *     identity chain function)\r\n+ *     <li>If a chain function is provided and returns a non-null value for a given branch, then the value is\r\n+ *     the result returned by this function\r\n+ *     <li>If a chain function returns {@code null} for a given branch, then the respective entry is not put to the map.\r\n+ *     <li>If a consumer is provided for a given branch, then the the respective entry is not put to the map\r\n+ * </ul>\r\n+ * <p>\r\n+ * For example:\r\n+ * <pre> {@code\r\n+ * Map<String, KStream<..., ...>> result =\r\n+ *   source.split(Named.as(\"foo-\"))\r\n+ *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\r\n+ *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\r\n+ *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\r\n+ *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\r\n+ *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\r\n+ * }</pre>\r\n+ *\r\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\r\n+ *\r\n+ * <h3>Direct Branch Consuming</h3>\r\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\r\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\r\n+ *\r\n+ * <pre> {@code\r\n+ * source.split()\r\n+ *     .branch((key, value) -> value.contains(\"A\"), Branched.withConsumer(ks -> ks.to(\"A\")))\r\n+ *     .branch((key, value) -> value.contains(\"B\"), Branched.withConsumer(ks -> ks.to(\"B\")))\r\n+ *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\r\n+ * }</pre>\r\n+ *\r\n+ * <h3>Collecting branches in a single scope</h3>\r\n+ * In other cases we want to combine branches again after splitting. The map returned by\r\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\r\n+ * access to all the branches in the same scope:\r\n+ *\r\n+ * <pre> {@code\r\n+ * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\r\n+ *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\r\n+ *     .defaultBranch(Branched.as(\"non-null\"));\r\n+ *\r\n+ * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\r\n+ * }</pre>\r\n+ *\r\n+ * <h3>Dynamic branching</h3>\r\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\r\n+ *\r\n+ * <pre> {@code\r\n+ * BranchedKStream branched = stream.split();\r\n+ * for (RecordType recordType : RecordType.values())\r\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\r\n+ *         Branched.withConsumer(recordType::processRecords));\r\n+ * }</pre>\r\n+ *\r\n+ * @param <K> Type of keys\r\n+ * @param <V> Type of values\r\n+ * @see KStream\r\n+ */\r\n+public interface BranchedKStream<K, V> {\r\n+    /**\r\n+     * Defines a branch for records that match the predicate.\r\n+     *\r\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\r\n+     *                  If this predicate returns {@code true} for a given record, the record will be\r\n+     *                  routed to the current branch and will not be evaluated against the predicates\r\n+     *                  for the remaining branches.\r\n+     * @return {@code this} to facilitate method chaining\r\n+     */\r\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\r\n+\r\n+    /**\r\n+     * Defines a branch for records that match the predicate.\r\n+     *\r\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\r\n+     *                  If this predicate returns {@code true} for a given record, the record will be\r\n+     *                  routed to the current branch and will not be evaluated against the predicates\r\n+     *                  for the remaining branches.\r\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\r\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\r\n+     *                  for {@link BranchedKStream})\r\n+     * @return {@code this} to facilitate method chaining\r\n+     */\r\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\r\n+\r\n+    /**\r\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\r\n+     * by other branches.\r\n+     *\r\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU5OTg4OQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547599889", "bodyText": "Add: If a record does not match any predicates, it will be routed to the default branch, or dropped if no default branch is created.", "author": "mjsax", "createdAt": "2020-12-23T02:07:27Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+/**\r\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\r\n+ * <p>\r\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\r\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\r\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\r\n+ * evaluates to {@code true}.\r\n+ * <p>\r\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\r\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\r\n+ * parameter. It also can be accessed from the {@link Map} returned by {@link BranchedKStream#defaultBranch(Branched)} or\r\n+ * {@link BranchedKStream#noDefaultBranch()} (see <a href=\"#examples\">usage examples</a>).\r\n+ * <p>\r\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\r\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\r\n+ * to route a record to multiple streams, you can use {@link KStream#filter(Predicate)} for each predicate instead\r\n+ * of branching.\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwMDQzNg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547600436", "bodyText": "Nit Split (no s) -- we use imperative to write JavaDocs.\nthis stream -> this {@code KStream}.\n(Same for the overload method)", "author": "mjsax", "createdAt": "2020-12-23T02:09:36Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -773,10 +775,32 @@\n      * @param named  a {@link Named} config used to name the processor in the topology\n      * @param predicates the ordered list of {@link Predicate} instances\n      * @return multiple distinct substreams of this {@code KStream}\n+     * @deprecated since 2.7. Use {@link #split(Named)} instead.\n      */\n+    @Deprecated\n     @SuppressWarnings(\"unchecked\")\n     KStream<K, V>[] branch(final Named named, final Predicate<? super K, ? super V>... predicates);\n \n+    /**\n+     * Splits this stream. {@link BranchedKStream} can be used for routing the records to different branches depending", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwMTI0NA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547601244", "bodyText": "newStream -> branch ?", "author": "mjsax", "createdAt": "2020-12-23T02:13:13Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedInternal.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream.internals;\r\n+\r\n+import org.apache.kafka.streams.kstream.Branched;\r\n+import org.apache.kafka.streams.kstream.KStream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+class BranchedInternal<K, V> extends Branched<K, V> {\r\n+    BranchedInternal(final Branched<K, V> branched) {\r\n+        super(branched);\r\n+    }\r\n+\r\n+    BranchedInternal() {\r\n+        super(null, null, null);\r\n+    }\r\n+\r\n+    static <K, V> BranchedInternal<K, V> empty() {\r\n+        return new BranchedInternal<>();\r\n+    }\r\n+\r\n+    String branchProcessorName(final String prefix, final int index) {\r\n+        if (name == null) {\r\n+            return prefix + index;\r\n+        } else {\r\n+            return prefix + name;\r\n+        }\r\n+    }\r\n+\r\n+    public void process(final KStreamImpl<K, V> newStream, final String branchChildName, final Map<String, KStream<K, V>> result) {\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwMjMxNA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547602314", "bodyText": "I think this method is hard to read. Proposal:\nif (chainFunction != null) {\n  final KStream<K, V> transformedStream = chainFunction.apply(newStream);\n  if (transformedStream != null) {\n    result.put(branchChildName, transformedStream);\n  }\n} else if (chainConsumer != null) {\n  chainConsumer.accept(transformedStream);\n} else {\n  result.put(branchChildName, newStream);\n}", "author": "mjsax", "createdAt": "2020-12-23T02:17:09Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedInternal.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream.internals;\r\n+\r\n+import org.apache.kafka.streams.kstream.Branched;\r\n+import org.apache.kafka.streams.kstream.KStream;\r\n+\r\n+import java.util.Map;\r\n+\r\n+class BranchedInternal<K, V> extends Branched<K, V> {\r\n+    BranchedInternal(final Branched<K, V> branched) {\r\n+        super(branched);\r\n+    }\r\n+\r\n+    BranchedInternal() {\r\n+        super(null, null, null);\r\n+    }\r\n+\r\n+    static <K, V> BranchedInternal<K, V> empty() {\r\n+        return new BranchedInternal<>();\r\n+    }\r\n+\r\n+    String branchProcessorName(final String prefix, final int index) {\r\n+        if (name == null) {\r\n+            return prefix + index;\r\n+        } else {\r\n+            return prefix + name;\r\n+        }\r\n+    }\r\n+\r\n+    public void process(final KStreamImpl<K, V> newStream, final String branchChildName, final Map<String, KStream<K, V>> result) {\r\n+        final KStream<K, V> transformedStream;\r\n+        if (chainFunction == null) {\r\n+            transformedStream = newStream;\r\n+        } else {\r\n+            transformedStream = chainFunction.apply(newStream);\r\n+        }\r\n+        if (transformedStream == null) {\r\n+            return;\r\n+        }\r\n+        if (chainConsumer != null) {\r\n+            chainConsumer.accept(transformedStream);\r\n+            return;\r\n+        } else {\r\n+            result.put(branchChildName, transformedStream);\r\n+        }\r\n+    }\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODYwNjI1MA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548606250", "bodyText": "Agreed, replaced the code as you suggested", "author": "inponomarev", "createdAt": "2020-12-24T16:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwMjMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwMjkyNQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547602925", "bodyText": "Seems we should add a corresponding test for split() ? (Same for other test classes.)", "author": "mjsax", "createdAt": "2020-12-23T02:19:45Z", "path": "streams/src/test/java/org/apache/kafka/streams/StreamsBuilderTest.java", "diffHunk": "@@ -615,7 +615,7 @@ public void shouldUseSpecifiedNameForTransformValuesWithKey() {\n     }\n \n     @Test\n-    @SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings({\"unchecked\", \"deprecation\"})", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODYyMTE5MA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548621190", "bodyText": "done, added a new corresponding test!", "author": "inponomarev", "createdAt": "2020-12-24T16:59:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwMjkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwMzYzOQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547603639", "bodyText": "missing null check for named", "author": "mjsax", "createdAt": "2020-12-23T02:22:53Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -492,6 +496,16 @@ public void foreach(final ForeachAction<? super K, ? super V> action,\n         return branchChildren;\n     }\n \n+    @Override\n+    public BranchedKStream<K, V> split() {\n+        return new BranchedKStreamImpl<>(this, repartitionRequired, NamedInternal.empty());\n+    }\n+\n+    @Override\n+    public BranchedKStream<K, V> split(final Named named) {\n+        return new BranchedKStreamImpl<>(this, repartitionRequired, new NamedInternal(named));", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODYyMTMxMw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548621313", "bodyText": "done", "author": "inponomarev", "createdAt": "2020-12-24T16:59:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwMzYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNDg2Ng==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547604866", "bodyText": "Should we really do it this way, or add a predicate to the list that always returns true if a default branch is added?", "author": "mjsax", "createdAt": "2020-12-23T02:27:45Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamBranch.java", "diffHunk": "@@ -41,14 +43,18 @@\n     private class KStreamBranchProcessor extends AbstractProcessor<K, V> {\n         @Override\n         public void process(final K key, final V value) {\n-            for (int i = 0; i < predicates.length; i++) {\n-                if (predicates[i].test(key, value)) {\n+            for (int i = 0; i < predicates.size(); i++) {\n+                if (predicates.get(i).test(key, value)) {\n                     // use forward with child here and then break the loop\n                     // so that no record is going to be piped to multiple streams\n-                    context().forward(key, value, To.child(childNodes[i]));\n-                    break;\n+                    context().forward(key, value, To.child(childNodes.get(i)));\n+                    return;\n                 }\n             }\n+            // using default child node if supplied", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNTQzOQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547605439", "bodyText": "Missing null check for predicate (similar below for other methods and parameters).", "author": "mjsax", "createdAt": "2020-12-23T02:30:05Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream.internals;\r\n+\r\n+import org.apache.kafka.streams.kstream.Branched;\r\n+import org.apache.kafka.streams.kstream.BranchedKStream;\r\n+import org.apache.kafka.streams.kstream.KStream;\r\n+import org.apache.kafka.streams.kstream.Predicate;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorGraphNode;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorParameters;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+public class BranchedKStreamImpl<K, V> implements BranchedKStream<K, V> {\r\n+\r\n+    private static final String BRANCH_NAME = \"KSTREAM-BRANCH-\";\r\n+\r\n+    private final KStreamImpl<K, V> source;\r\n+    private final boolean repartitionRequired;\r\n+    private final String splitterName;\r\n+    private final Map<String, KStream<K, V>> result = new HashMap<>();\r\n+\r\n+    private final List<Predicate<? super K, ? super V>> predicates = new ArrayList<>();\r\n+    private final List<String> childNames = new ArrayList<>();\r\n+    private final ProcessorGraphNode<K, V> splitterNode;\r\n+\r\n+    BranchedKStreamImpl(final KStreamImpl<K, V> source, final boolean repartitionRequired, final NamedInternal named) {\r\n+        this.source = source;\r\n+        this.repartitionRequired = repartitionRequired;\r\n+        this.splitterName = named.orElseGenerateWithPrefix(source.builder, BRANCH_NAME);\r\n+\r\n+        // predicates and childNames are passed by reference so when the user adds a branch they get added to\r\n+        final ProcessorParameters<K, V> processorParameters =\r\n+                new ProcessorParameters<>(new KStreamBranch<>(predicates, childNames), splitterName);\r\n+        splitterNode = new ProcessorGraphNode<>(splitterName, processorParameters);\r\n+        source.builder.addGraphNode(source.streamsGraphNode, splitterNode);\r\n+    }\r\n+\r\n+    @Override\r\n+    public BranchedKStream<K, V> branch(final Predicate<? super K, ? super V> predicate) {\r\n+        return branch(predicate, BranchedInternal.empty());\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNjA2NA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547606064", "bodyText": "Should we call branch((k,v) -> true, branched) instead to just add a predicate and branch? This way, the default branch is nothing special at runtime any longer.", "author": "mjsax", "createdAt": "2020-12-23T02:32:48Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream.internals;\r\n+\r\n+import org.apache.kafka.streams.kstream.Branched;\r\n+import org.apache.kafka.streams.kstream.BranchedKStream;\r\n+import org.apache.kafka.streams.kstream.KStream;\r\n+import org.apache.kafka.streams.kstream.Predicate;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorGraphNode;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorParameters;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+public class BranchedKStreamImpl<K, V> implements BranchedKStream<K, V> {\r\n+\r\n+    private static final String BRANCH_NAME = \"KSTREAM-BRANCH-\";\r\n+\r\n+    private final KStreamImpl<K, V> source;\r\n+    private final boolean repartitionRequired;\r\n+    private final String splitterName;\r\n+    private final Map<String, KStream<K, V>> result = new HashMap<>();\r\n+\r\n+    private final List<Predicate<? super K, ? super V>> predicates = new ArrayList<>();\r\n+    private final List<String> childNames = new ArrayList<>();\r\n+    private final ProcessorGraphNode<K, V> splitterNode;\r\n+\r\n+    BranchedKStreamImpl(final KStreamImpl<K, V> source, final boolean repartitionRequired, final NamedInternal named) {\r\n+        this.source = source;\r\n+        this.repartitionRequired = repartitionRequired;\r\n+        this.splitterName = named.orElseGenerateWithPrefix(source.builder, BRANCH_NAME);\r\n+\r\n+        // predicates and childNames are passed by reference so when the user adds a branch they get added to\r\n+        final ProcessorParameters<K, V> processorParameters =\r\n+                new ProcessorParameters<>(new KStreamBranch<>(predicates, childNames), splitterName);\r\n+        splitterNode = new ProcessorGraphNode<>(splitterName, processorParameters);\r\n+        source.builder.addGraphNode(source.streamsGraphNode, splitterNode);\r\n+    }\r\n+\r\n+    @Override\r\n+    public BranchedKStream<K, V> branch(final Predicate<? super K, ? super V> predicate) {\r\n+        return branch(predicate, BranchedInternal.empty());\r\n+    }\r\n+\r\n+    @Override\r\n+    public BranchedKStream<K, V> branch(final Predicate<? super K, ? super V> predicate, final Branched<K, V> branched) {\r\n+        predicates.add(predicate);\r\n+        createBranch(branched, predicates.size());\r\n+        return this;\r\n+    }\r\n+\r\n+    @Override\r\n+    public Map<String, KStream<K, V>> defaultBranch() {\r\n+        return defaultBranch(BranchedInternal.empty());\r\n+    }\r\n+\r\n+    @Override\r\n+    public Map<String, KStream<K, V>> defaultBranch(final Branched<K, V> branched) {\r\n+        createBranch(branched, 0);\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODYyOTIwNQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548629205", "bodyText": "The default branch should have index 0 (so it will be stable when branches are added or removed), but it should always be checked after all other branches. And when we come to the default branch during message processing, there is actually no need in dereferncing a predicate and calling test... that's why I treat the default branch differently.", "author": "inponomarev", "createdAt": "2020-12-24T17:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNjA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0Mjg1NQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r549542855", "bodyText": "I guess it's fine both ways. -- The point about the index is a good one that I missed. But would still be doable I guess.\nI don't think that there would be any measurable runtime difference if you use a \"default predicate\" (what we also do in the current implementation) -- the code is just a little \"cleaner\" as we don't need an extra \"if\" at the end -- but it's also not the end of the world as the process method is fairly simply anyway.", "author": "mjsax", "createdAt": "2020-12-29T02:09:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNjA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNjYxNw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547606617", "bodyText": "As we call branchProcessorName only once, I am wondering if we should embed the code here and remove branchProcessorName -- our usual pattern is to only have getters on the XxxInternal implemenation.", "author": "mjsax", "createdAt": "2020-12-23T02:35:11Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream.internals;\r\n+\r\n+import org.apache.kafka.streams.kstream.Branched;\r\n+import org.apache.kafka.streams.kstream.BranchedKStream;\r\n+import org.apache.kafka.streams.kstream.KStream;\r\n+import org.apache.kafka.streams.kstream.Predicate;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorGraphNode;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorParameters;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+public class BranchedKStreamImpl<K, V> implements BranchedKStream<K, V> {\r\n+\r\n+    private static final String BRANCH_NAME = \"KSTREAM-BRANCH-\";\r\n+\r\n+    private final KStreamImpl<K, V> source;\r\n+    private final boolean repartitionRequired;\r\n+    private final String splitterName;\r\n+    private final Map<String, KStream<K, V>> result = new HashMap<>();\r\n+\r\n+    private final List<Predicate<? super K, ? super V>> predicates = new ArrayList<>();\r\n+    private final List<String> childNames = new ArrayList<>();\r\n+    private final ProcessorGraphNode<K, V> splitterNode;\r\n+\r\n+    BranchedKStreamImpl(final KStreamImpl<K, V> source, final boolean repartitionRequired, final NamedInternal named) {\r\n+        this.source = source;\r\n+        this.repartitionRequired = repartitionRequired;\r\n+        this.splitterName = named.orElseGenerateWithPrefix(source.builder, BRANCH_NAME);\r\n+\r\n+        // predicates and childNames are passed by reference so when the user adds a branch they get added to\r\n+        final ProcessorParameters<K, V> processorParameters =\r\n+                new ProcessorParameters<>(new KStreamBranch<>(predicates, childNames), splitterName);\r\n+        splitterNode = new ProcessorGraphNode<>(splitterName, processorParameters);\r\n+        source.builder.addGraphNode(source.streamsGraphNode, splitterNode);\r\n+    }\r\n+\r\n+    @Override\r\n+    public BranchedKStream<K, V> branch(final Predicate<? super K, ? super V> predicate) {\r\n+        return branch(predicate, BranchedInternal.empty());\r\n+    }\r\n+\r\n+    @Override\r\n+    public BranchedKStream<K, V> branch(final Predicate<? super K, ? super V> predicate, final Branched<K, V> branched) {\r\n+        predicates.add(predicate);\r\n+        createBranch(branched, predicates.size());\r\n+        return this;\r\n+    }\r\n+\r\n+    @Override\r\n+    public Map<String, KStream<K, V>> defaultBranch() {\r\n+        return defaultBranch(BranchedInternal.empty());\r\n+    }\r\n+\r\n+    @Override\r\n+    public Map<String, KStream<K, V>> defaultBranch(final Branched<K, V> branched) {\r\n+        createBranch(branched, 0);\r\n+        return result;\r\n+    }\r\n+\r\n+    private void createBranch(final Branched<K, V> branched, final int index) {\r\n+        final BranchedInternal<K, V> branchedInternal = new BranchedInternal<>(branched);\r\n+        final String branchChildName = branchedInternal.branchProcessorName(splitterName, index);\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNjg2Ng==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547606866", "bodyText": "result -> outputBranches ?", "author": "mjsax", "createdAt": "2020-12-23T02:36:08Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream.internals;\r\n+\r\n+import org.apache.kafka.streams.kstream.Branched;\r\n+import org.apache.kafka.streams.kstream.BranchedKStream;\r\n+import org.apache.kafka.streams.kstream.KStream;\r\n+import org.apache.kafka.streams.kstream.Predicate;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorGraphNode;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorParameters;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+public class BranchedKStreamImpl<K, V> implements BranchedKStream<K, V> {\r\n+\r\n+    private static final String BRANCH_NAME = \"KSTREAM-BRANCH-\";\r\n+\r\n+    private final KStreamImpl<K, V> source;\r\n+    private final boolean repartitionRequired;\r\n+    private final String splitterName;\r\n+    private final Map<String, KStream<K, V>> result = new HashMap<>();\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNzczOQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547607739", "bodyText": "I am wondering if it might be better to move this code into a build method that would be called within defaultBranch() / noDefaultBranch() ?\nThe pattern to pass in empty list that we modify later seems undesirable, and we should first build the list, and than pass them in -- otherwise, we make assumptions how ProcessorParameters and ProcessorGraphNode might be implemented what we should avoid.", "author": "mjsax", "createdAt": "2020-12-23T02:39:51Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream.internals;\r\n+\r\n+import org.apache.kafka.streams.kstream.Branched;\r\n+import org.apache.kafka.streams.kstream.BranchedKStream;\r\n+import org.apache.kafka.streams.kstream.KStream;\r\n+import org.apache.kafka.streams.kstream.Predicate;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorGraphNode;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorParameters;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+public class BranchedKStreamImpl<K, V> implements BranchedKStream<K, V> {\r\n+\r\n+    private static final String BRANCH_NAME = \"KSTREAM-BRANCH-\";\r\n+\r\n+    private final KStreamImpl<K, V> source;\r\n+    private final boolean repartitionRequired;\r\n+    private final String splitterName;\r\n+    private final Map<String, KStream<K, V>> result = new HashMap<>();\r\n+\r\n+    private final List<Predicate<? super K, ? super V>> predicates = new ArrayList<>();\r\n+    private final List<String> childNames = new ArrayList<>();\r\n+    private final ProcessorGraphNode<K, V> splitterNode;\r\n+\r\n+    BranchedKStreamImpl(final KStreamImpl<K, V> source, final boolean repartitionRequired, final NamedInternal named) {\r\n+        this.source = source;\r\n+        this.repartitionRequired = repartitionRequired;\r\n+        this.splitterName = named.orElseGenerateWithPrefix(source.builder, BRANCH_NAME);\r\n+\r\n+        // predicates and childNames are passed by reference so when the user adds a branch they get added to\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODY0NTIwMw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548645203", "bodyText": "I clearly remember that something made me to write it this way, but I have to recall...", "author": "inponomarev", "createdAt": "2020-12-24T17:34:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNzczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0Mjk5NQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r549542995", "bodyText": "Would love to learn about it. -- In general, it's easier to follow the same pattern throughout the code base. It easier to reason about the code that way, and also easier for people to learn the code base.", "author": "mjsax", "createdAt": "2020-12-29T02:11:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNzczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0MzI0Nw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r549543247", "bodyText": "Just saw your other comment: #9107 (comment)", "author": "mjsax", "createdAt": "2020-12-29T02:12:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwNzczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwODA0MQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r547608041", "bodyText": "Same comment as for branchProcessorName -- it seems better to keep BranchedInternal a simple container and pull in the code into this method.", "author": "mjsax", "createdAt": "2020-12-23T02:41:17Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedKStreamImpl.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream.internals;\r\n+\r\n+import org.apache.kafka.streams.kstream.Branched;\r\n+import org.apache.kafka.streams.kstream.BranchedKStream;\r\n+import org.apache.kafka.streams.kstream.KStream;\r\n+import org.apache.kafka.streams.kstream.Predicate;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorGraphNode;\r\n+import org.apache.kafka.streams.kstream.internals.graph.ProcessorParameters;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+public class BranchedKStreamImpl<K, V> implements BranchedKStream<K, V> {\r\n+\r\n+    private static final String BRANCH_NAME = \"KSTREAM-BRANCH-\";\r\n+\r\n+    private final KStreamImpl<K, V> source;\r\n+    private final boolean repartitionRequired;\r\n+    private final String splitterName;\r\n+    private final Map<String, KStream<K, V>> result = new HashMap<>();\r\n+\r\n+    private final List<Predicate<? super K, ? super V>> predicates = new ArrayList<>();\r\n+    private final List<String> childNames = new ArrayList<>();\r\n+    private final ProcessorGraphNode<K, V> splitterNode;\r\n+\r\n+    BranchedKStreamImpl(final KStreamImpl<K, V> source, final boolean repartitionRequired, final NamedInternal named) {\r\n+        this.source = source;\r\n+        this.repartitionRequired = repartitionRequired;\r\n+        this.splitterName = named.orElseGenerateWithPrefix(source.builder, BRANCH_NAME);\r\n+\r\n+        // predicates and childNames are passed by reference so when the user adds a branch they get added to\r\n+        final ProcessorParameters<K, V> processorParameters =\r\n+                new ProcessorParameters<>(new KStreamBranch<>(predicates, childNames), splitterName);\r\n+        splitterNode = new ProcessorGraphNode<>(splitterName, processorParameters);\r\n+        source.builder.addGraphNode(source.streamsGraphNode, splitterNode);\r\n+    }\r\n+\r\n+    @Override\r\n+    public BranchedKStream<K, V> branch(final Predicate<? super K, ? super V> predicate) {\r\n+        return branch(predicate, BranchedInternal.empty());\r\n+    }\r\n+\r\n+    @Override\r\n+    public BranchedKStream<K, V> branch(final Predicate<? super K, ? super V> predicate, final Branched<K, V> branched) {\r\n+        predicates.add(predicate);\r\n+        createBranch(branched, predicates.size());\r\n+        return this;\r\n+    }\r\n+\r\n+    @Override\r\n+    public Map<String, KStream<K, V>> defaultBranch() {\r\n+        return defaultBranch(BranchedInternal.empty());\r\n+    }\r\n+\r\n+    @Override\r\n+    public Map<String, KStream<K, V>> defaultBranch(final Branched<K, V> branched) {\r\n+        createBranch(branched, 0);\r\n+        return result;\r\n+    }\r\n+\r\n+    private void createBranch(final Branched<K, V> branched, final int index) {\r\n+        final BranchedInternal<K, V> branchedInternal = new BranchedInternal<>(branched);\r\n+        final String branchChildName = branchedInternal.branchProcessorName(splitterName, index);\r\n+        childNames.add(branchChildName);\r\n+        source.builder.newProcessorName(branchChildName);\r\n+        final ProcessorParameters<K, V> parameters = new ProcessorParameters<>(new PassThrough<>(), branchChildName);\r\n+        final ProcessorGraphNode<K, V> branchChildNode = new ProcessorGraphNode<>(branchChildName, parameters);\r\n+        source.builder.addGraphNode(splitterNode, branchChildNode);\r\n+        final KStreamImpl<K, V> newStream = new KStreamImpl<>(branchChildName, source.keySerde,\r\n+                source.valueSerde, source.subTopologySourceNodes,\r\n+                repartitionRequired, branchChildNode, source.builder);\r\n+        branchedInternal.process(newStream, branchChildName, result);\r", "originalCommit": "8a77301eb628e6684768a5405144a0d02ed17ac2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODY0MjEzOA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r548642138", "bodyText": "done", "author": "inponomarev", "createdAt": "2020-12-24T17:30:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYwODA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1NTkxNA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r549555914", "bodyText": "It's a naming convention in the whole Kafka code base, to omit the get prefix for all getter methods, ie, this should be name(). (Similar below for the other getters.)", "author": "mjsax", "createdAt": "2020-12-29T03:34:43Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/BranchedInternal.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements. See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License. You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.kafka.streams.kstream.internals;\r\n+\r\n+import org.apache.kafka.streams.kstream.Branched;\r\n+import org.apache.kafka.streams.kstream.KStream;\r\n+\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Function;\r\n+\r\n+class BranchedInternal<K, V> extends Branched<K, V> {\r\n+    BranchedInternal(final Branched<K, V> branched) {\r\n+        super(branched);\r\n+    }\r\n+\r\n+    BranchedInternal() {\r\n+        super(null, null, null);\r\n+    }\r\n+\r\n+    static <K, V> BranchedInternal<K, V> empty() {\r\n+        return new BranchedInternal<>();\r\n+    }\r\n+\r\n+    String getName() {\r", "originalCommit": "c7bb27eedb09beea3412bea778aee6b73059095b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcyMjU0Mw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r549722543", "bodyText": "done", "author": "inponomarev", "createdAt": "2020-12-29T14:22:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1NTkxNA=="}], "type": "inlineReview"}, {"oid": "0759478faf0c2d26da8f989840ba21f824b9b5ea", "url": "https://github.com/apache/kafka/commit/0759478faf0c2d26da8f989840ba21f824b9b5ea", "message": "Scala API wrapper", "committedDate": "2021-01-13T19:49:31Z", "type": "forcePushed"}, {"oid": "2ef3837ea963cc6f4d1940a1fc3cb3346d653644", "url": "https://github.com/apache/kafka/commit/2ef3837ea963cc6f4d1940a1fc3cb3346d653644", "message": "Rewrite StreamsGraphTest using split()", "committedDate": "2021-01-20T02:07:40Z", "type": "forcePushed"}, {"oid": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "url": "https://github.com/apache/kafka/commit/9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "message": "Rewrite StreamsGraphTest using split()", "committedDate": "2021-01-20T02:30:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc2NjM4OQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564766389", "bodyText": "nit: should not -> cannot  (or can't if you prefer)", "author": "mjsax", "createdAt": "2021-01-26T19:15:23Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    protected final String name;\n+    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\n+\n+    protected Branched(final String name,\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided branch name suffix.\n+     *\n+     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(final String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc2NzA2OA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564767068", "bodyText": "nit: should not -> cannot", "author": "mjsax", "createdAt": "2021-01-26T19:16:06Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    protected final String name;\n+    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\n+\n+    protected Branched(final String name,\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided branch name suffix.\n+     *\n+     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(final String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain consumer should not be null\");", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc2NzIzOQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564767239", "bodyText": "nit: remove here", "author": "mjsax", "createdAt": "2021-01-26T19:16:22Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    protected final String name;\n+    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\n+\n+    protected Branched(final String name,\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided branch name suffix.\n+     *\n+     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(final String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc2Nzg4MQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564767881", "bodyText": "remove  If {@code null}, the identity {@code kStream -> kStream} function will be used. -- we don't allow null", "author": "mjsax", "createdAt": "2021-01-26T19:17:22Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    protected final String name;\n+    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\n+\n+    protected Branched(final String name,\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided branch name suffix.\n+     *\n+     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(final String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n+        return new Branched<>(null, null, chain);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function and branch name suffix.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc2ODE0Ng==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564768146", "bodyText": "nit: should not -> cannot", "author": "mjsax", "createdAt": "2021-01-26T19:17:45Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    protected final String name;\n+    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\n+\n+    protected Branched(final String name,\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided branch name suffix.\n+     *\n+     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(final String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n+        return new Branched<>(null, null, chain);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function and branch name suffix.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be used. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain, final String name) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc2ODM1Mw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564768353", "bodyText": "nit: remove here", "author": "mjsax", "createdAt": "2021-01-26T19:18:01Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    protected final String name;\n+    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\n+\n+    protected Branched(final String name,\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided branch name suffix.\n+     *\n+     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(final String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n+        return new Branched<>(null, null, chain);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function and branch name suffix.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be used. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain, final String name) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");\n+        return new Branched<>(name, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain consumer and branch name suffix.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null consumer is provided here,", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc2ODU0Mg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564768542", "bodyText": "nit: should not -> cannot", "author": "mjsax", "createdAt": "2021-01-26T19:18:18Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    protected final String name;\n+    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\n+\n+    protected Branched(final String name,\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided branch name suffix.\n+     *\n+     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(final String name) {\n+        return new Branched<>(name, null, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function.\n+     *\n+     * @param chain A function that will be applied to the branch. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");\n+        return new Branched<>(null, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain consumer.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a consumer is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withConsumer(final Consumer<KStream<K, V>> chain) {\n+        Objects.requireNonNull(chain, \"chain consumer should not be null\");\n+        return new Branched<>(null, null, chain);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain function and branch name suffix.\n+     *\n+     * @param chain A function that will be applied to the branch. If {@code null}, the identity\n+     *              {@code kStream -> kStream} function will be used. If the provided function returns\n+     *              {@code null}, its result is ignored, otherwise it is added to the {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withFunction(\n+            final Function<? super KStream<K, V>, ? extends KStream<K, V>> chain, final String name) {\n+        Objects.requireNonNull(chain, \"chain function should not be null\");\n+        return new Branched<>(name, chain, null);\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided chain consumer and branch name suffix.\n+     *\n+     * @param chain A consumer to which the branch will be sent. If a non-null consumer is provided here,\n+     *              the respective branch will not be added to the resulting {@code Map} returned\n+     *              by {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} (see\n+     *              {@link BranchedKStream} description for details).\n+     * @param name  the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *              (see {@link BranchedKStream} description for details)\n+     * @param <K>   key type\n+     * @param <V>   value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> withConsumer(final Consumer<? super KStream<K, V>> chain,\n+                                                     final String name) {\n+        Objects.requireNonNull(chain, \"chain consumer should not be null\");", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk2ODAyMw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564968023", "bodyText": "nit: {@code true}", "author": "mjsax", "createdAt": "2021-01-27T01:52:00Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk2ODE4Nw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564968187", "bodyText": "nit: first match (without dash) ?", "author": "mjsax", "createdAt": "2021-01-27T01:52:27Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk4ODgwMA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564988800", "bodyText": "\\cc @vvcephei", "author": "mjsax", "createdAt": "2021-01-27T02:52:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk2ODE4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUxOTkxMg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r565519912", "bodyText": "Yes, I agree, unless you want to add a noun:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n          \n          \n            \n             * The branching happens on a first-match basis: A record in the original stream is assigned to the corresponding result", "author": "vvcephei", "createdAt": "2021-01-27T18:01:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk2ODE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk2ODU0NQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564968545", "bodyText": "proposal (add) operators[ to the same {@link KStream} instance],", "author": "mjsax", "createdAt": "2021-01-27T01:53:32Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk2ODgzMQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564968831", "bodyText": "nit: add empty line above headline for better readability in the code (won't change the produced html).", "author": "mjsax", "createdAt": "2021-01-27T01:54:24Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3MDA1Nw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564970057", "bodyText": "If a non-null chain function -> If a chain function\n(We don't allow null as chain function.)", "author": "mjsax", "createdAt": "2021-01-27T01:57:38Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3MDcwNg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564970706", "bodyText": "Remove non-null (null is not allowed anyway)", "author": "mjsax", "createdAt": "2021-01-27T01:59:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3MTA2Ng==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564971066", "bodyText": "Should we merge this sentence to the previous bullet point, instead of making a new bullet point?", "author": "mjsax", "createdAt": "2021-01-27T02:00:15Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3MjczOQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564972739", "bodyText": "I think it's worth to highlight that defaultBranch / noDefaultBranch are optional (to avoid the confusion about \"builder pattern\"):\nby an optional {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}  method call (see ...).", "author": "mjsax", "createdAt": "2021-01-27T02:05:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3MzAyNg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564973026", "bodyText": "Define (no s -- we use imperative in JavaDocs)", "author": "mjsax", "createdAt": "2021-01-27T02:06:01Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n+ * </ul>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *   source.split(Named.as(\"foo-\"))\n+ *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n+ *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n+ *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n+ *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n+ *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n+ *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.withConsumer(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3MzE5MQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564973191", "bodyText": "as above", "author": "mjsax", "createdAt": "2021-01-27T02:06:28Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n+ * </ul>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *   source.split(Named.as(\"foo-\"))\n+ *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n+ *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n+ *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n+ *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n+ *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n+ *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.withConsumer(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3Mzg1MQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564973851", "bodyText": "Finalize (no `s')", "author": "mjsax", "createdAt": "2021-01-27T02:08:15Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n+ * </ul>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *   source.split(Named.as(\"foo-\"))\n+ *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n+ *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n+ *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n+ *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n+ *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n+ *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.withConsumer(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3NDIxMw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564974213", "bodyText": "Add:\nCalling {@code defaultBranch()} or {@link #noDefaultBranch()} is optional.", "author": "mjsax", "createdAt": "2021-01-27T02:09:22Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n+ * </ul>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *   source.split(Named.as(\"foo-\"))\n+ *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n+ *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n+ *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n+ *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n+ *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n+ *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.withConsumer(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3NDI0Nw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564974247", "bodyText": "as above", "author": "mjsax", "createdAt": "2021-01-27T02:09:28Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n+ * </ul>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *   source.split(Named.as(\"foo-\"))\n+ *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n+ *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n+ *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n+ *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n+ *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n+ *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.withConsumer(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3NDI3Mw==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564974273", "bodyText": "Add:\nCalling {@code defaultBranch()} or {@link #noDefaultBranch()} is optional.", "author": "mjsax", "createdAt": "2021-01-27T02:09:33Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n+ * </ul>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *   source.split(Named.as(\"foo-\"))\n+ *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n+ *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n+ *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n+ *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n+ *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n+ *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.withConsumer(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3NDM2OA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564974368", "bodyText": "as above", "author": "mjsax", "createdAt": "2021-01-27T02:09:49Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/BranchedKStream.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Map;\n+\n+/**\n+ * Branches the records in the original stream based on the predicates supplied for the branch definitions.\n+ * <p>\n+ * Branches are defined with {@link BranchedKStream#branch(Predicate, Branched)} or\n+ * {@link BranchedKStream#defaultBranch(Branched)} methods. Each record is evaluated against the predicates\n+ * supplied via {@link Branched} parameters, and is routed to the first branch for which its respective predicate\n+ * evaluates to {@code true}. If a record does not match any predicates, it will be routed to the default branch,\n+ * or dropped if no default branch is created.\n+ * <p>\n+ * Each branch (which is a {@link KStream} instance) then can be processed either by\n+ * a {@link java.util.function.Function} or a {@link java.util.function.Consumer} provided via a {@link Branched}\n+ * parameter. If certain conditions are met, it also can be accessed from the {@link Map} returned by\n+ * {@link BranchedKStream#defaultBranch(Branched)} or {@link BranchedKStream#noDefaultBranch()}\n+ * (see <a href=\"#examples\">usage examples</a>).\n+ * <p>\n+ * The branching happens on first-match: A record in the original stream is assigned to the corresponding result\n+ * stream for the first predicate that evaluates to true, and is assigned to this stream only. If you need\n+ * to route a record to multiple streams, you can apply multiple {@link KStream#filter(Predicate)} operators,\n+ * one for each predicate, instead of branching.\n+ * <p>\n+ * The process of routing the records to different branches is a stateless record-by-record operation.\n+ * <h2><a name=\"maprules\">Rules of forming the resulting map</a></h2>\n+ * The keys of the {@code Map<String, KStream<K, V>>} entries returned by {@link BranchedKStream#defaultBranch(Branched)} or\n+ * {@link BranchedKStream#noDefaultBranch()} are defined by the following rules:\n+ * <ul>\n+ *     <li>If {@link Named} parameter was provided for {@link KStream#split(Named)}, its value is used as\n+ *     a prefix for each key. By default, no prefix is used\n+ *     <li>If a branch name is provided in {@link BranchedKStream#branch(Predicate, Branched)} via the\n+ *     {@link Branched} parameter, its value is appended to the prefix to form the {@code Map} key\n+ *     <li>If a name is not provided for the branch, then the key defaults to {@code prefix + position} of the branch\n+ *     as a decimal number, starting from {@code \"1\"}\n+ *     <li>If a name is not provided for the {@link BranchedKStream#defaultBranch()} call, then the key defaults\n+ *     to {@code prefix + \"0\"}\n+ * </ul>\n+ * The values of the respective {@code Map<Stream, KStream<K, V>>} entries are formed as following:\n+ * <ul>\n+ *     <li>If no chain function or consumer is provided in {@link BranchedKStream#branch(Predicate, Branched)} via\n+ *     the {@link Branched} parameter, then the the branch itself is added to the {@code Map}\n+ *     <li>If a non-null chain function is provided and it returns a non-null value for a given branch, then the value\n+ *     is the result returned by this function\n+ *     <li>If a chain function returns {@code null} for a given branch, then no entry is added to the map\n+ *     <li>If a non-null consumer is provided for a given branch, then no entry is added to the map\n+ * </ul>\n+ * For example:\n+ * <pre> {@code\n+ * Map<String, KStream<..., ...>> result =\n+ *   source.split(Named.as(\"foo-\"))\n+ *     .branch(predicate1, Branched.as(\"bar\"))                    // \"foo-bar\"\n+ *     .branch(predicate2, Branched.withConsumer(ks->ks.to(\"A\"))  // no entry: a Consumer is provided\n+ *     .branch(predicate3, Branched.withFunction(ks->null))       // no entry: chain function returns null\n+ *     .branch(predicate4)                                        // \"foo-4\": name defaults to the branch position\n+ *     .defaultBranch()                                           // \"foo-0\": \"0\" is the default name for the default branch\n+ * }</pre>\n+ *\n+ * <h2><a name=\"examples\">Usage examples</a></h2>\n+ *\n+ * <h3>Direct Branch Consuming</h3>\n+ * In many cases we do not need to have a single scope for all the branches, each branch being processed completely\n+ * independently from others. Then we can use 'consuming' lambdas or method references in {@link Branched} parameter:\n+ *\n+ * <pre> {@code\n+ * source.split()\n+ *     .branch(predicate1, Branched.withConsumer(ks -> ks.to(\"A\")))\n+ *     .branch(predicate2, Branched.withConsumer(ks -> ks.to(\"B\")))\n+ *     .defaultBranch(Branched.withConsumer(ks->ks.to(\"C\")));\n+ * }</pre>\n+ *\n+ * <h3>Collecting branches in a single scope</h3>\n+ * In other cases we want to combine branches again after splitting. The map returned by\n+ * {@link BranchedKStream#defaultBranch()} or {@link BranchedKStream#noDefaultBranch()} methods provides\n+ * access to all the branches in the same scope:\n+ *\n+ * <pre> {@code\n+ * Map<String, KStream<String, String>> branches = source.split(Named.as(\"split-\"))\n+ *     .branch((key, value) -> value == null, Branched.withFunction(s -> s.mapValues(v->\"NULL\"), \"null\")\n+ *     .defaultBranch(Branched.as(\"non-null\"));\n+ *\n+ * KStream<String, String> merged = branches.get(\"split-non-null\").merge(branches.get(\"split-null\"));\n+ * }</pre>\n+ *\n+ * <h3>Dynamic branching</h3>\n+ * There is also a case when we might need to create branches dynamically, e. g. one per enum value:\n+ *\n+ * <pre> {@code\n+ * BranchedKStream branched = stream.split();\n+ * for (RecordType recordType : RecordType.values())\n+ *     branched.branch((k, v) -> v.getRecType() == recordType,\n+ *         Branched.withConsumer(recordType::processRecords));\n+ * }</pre>\n+ *\n+ * @param <K> Type of keys\n+ * @param <V> Type of values\n+ * @see KStream\n+ */\n+public interface BranchedKStream<K, V> {\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate);\n+\n+    /**\n+     * Defines a branch for records that match the predicate.\n+     *\n+     * @param predicate A {@link Predicate} instance, against which each record will be evaluated.\n+     *                  If this predicate returns {@code true} for a given record, the record will be\n+     *                  routed to the current branch and will not be evaluated against the predicates\n+     *                  for the remaining branches.\n+     * @param branched  A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                  branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                  for {@link BranchedKStream})\n+     * @return {@code this} to facilitate method chaining\n+     */\n+    BranchedKStream<K, V> branch(Predicate<? super K, ? super V> predicate, Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@code BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch();\n+\n+    /**\n+     * Finalizes the construction of branches and defines the default branch for the messages not intercepted\n+     * by other branches.\n+     *\n+     * @param branched A {@link Branched} parameter, that allows to define a branch name, an in-place\n+     *                 branch consumer or branch mapper (see <a href=\"#examples\">code examples</a>\n+     *                 for {@link BranchedKStream})\n+     * @return {@link Map} of named branches. For rules of forming the resulting map, see {@link BranchedKStream}\n+     * <a href=\"#maprules\">description</a>.\n+     */\n+    Map<String, KStream<K, V>> defaultBranch(Branched<K, V> branched);\n+\n+    /**\n+     * Finalizes the construction of branches without forming a default branch.", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3NDQ3NA==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564974474", "bodyText": "Add:\nCalling {@code noDefaultBranch()} or {@link #defaultBranch()} is optional.", "author": "mjsax", "createdAt": "2021-01-27T02:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3NDM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk3NDkwMg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564974902", "bodyText": "2.7 -> 2.8", "author": "mjsax", "createdAt": "2021-01-27T02:11:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -773,10 +775,32 @@\n      * @param named  a {@link Named} config used to name the processor in the topology\n      * @param predicates the ordered list of {@link Predicate} instances\n      * @return multiple distinct substreams of this {@code KStream}\n+     * @deprecated since 2.7. Use {@link #split(Named)} instead.", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk4MjY1Mg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564982652", "bodyText": "Missing null check for name", "author": "mjsax", "createdAt": "2021-01-27T02:34:22Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    protected final String name;\n+    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\n+\n+    protected Branched(final String name,\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided branch name suffix.\n+     *\n+     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated\n+     *             (see {@link BranchedKStream} description for details)\n+     * @param <K>  key type\n+     * @param <V>  value type\n+     * @return a new instance of {@code Branched}\n+     */\n+    public static <K, V> Branched<K, V> as(final String name) {\n+        return new Branched<>(name, null, null);", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk4Nzc2OQ==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564987769", "bodyText": "\\cc @vvcephei", "author": "mjsax", "createdAt": "2021-01-27T02:49:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk4MjY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUxOTA2Ng==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r565519066", "bodyText": "I agree, it seems like a good idea to check for null here.", "author": "vvcephei", "createdAt": "2021-01-27T17:59:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk4MjY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDk4MzA0Mg==", "url": "https://github.com/apache/kafka/pull/9107#discussion_r564983042", "bodyText": "remove: If {@code null}, a default branch name suffix will be generated (we should not allow null to align to other methods, eg, Named.as())", "author": "mjsax", "createdAt": "2021-01-27T02:35:33Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/Branched.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * The {@code Branched} class is used to define the optional parameters when building branches with\n+ * {@link BranchedKStream}.\n+ *\n+ * @param <K> type of record key\n+ * @param <V> type of record value\n+ */\n+public class Branched<K, V> implements NamedOperation<Branched<K, V>> {\n+\n+    protected final String name;\n+    protected final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction;\n+    protected final Consumer<? super KStream<K, V>> chainConsumer;\n+\n+    protected Branched(final String name,\n+                       final Function<? super KStream<K, V>, ? extends KStream<K, V>> chainFunction,\n+                       final Consumer<? super KStream<K, V>> chainConsumer) {\n+        this.name = name;\n+        this.chainFunction = chainFunction;\n+        this.chainConsumer = chainConsumer;\n+    }\n+\n+    /**\n+     * Create an instance of {@code Branched} with provided branch name suffix.\n+     *\n+     * @param name the branch name suffix to be used. If {@code null}, a default branch name suffix will be generated", "originalCommit": "9b021a3cbbdf1216a7286aa5dadaefcfda8a934b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "199fd074baaa05ca691192355b68e1618c0de778", "url": "https://github.com/apache/kafka/commit/199fd074baaa05ca691192355b68e1618c0de778", "message": "Rewrite StreamsGraphTest using split()", "committedDate": "2021-01-28T03:14:40Z", "type": "forcePushed"}, {"oid": "1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "url": "https://github.com/apache/kafka/commit/1f9fcd9487dcf6fa8dbad87b2eee6a28b4213225", "message": "public interfaces and JavaDoc", "committedDate": "2021-02-02T11:32:35Z", "type": "commit"}, {"oid": "2ccaeac4b5af57cf48d36e454eb1a241ccc6c2da", "url": "https://github.com/apache/kafka/commit/2ccaeac4b5af57cf48d36e454eb1a241ccc6c2da", "message": "added implementation class", "committedDate": "2021-02-02T11:32:36Z", "type": "commit"}, {"oid": "876421a0c2fae8c3c9dd850050a32d0b8f05c97f", "url": "https://github.com/apache/kafka/commit/876421a0c2fae8c3c9dd850050a32d0b8f05c97f", "message": "update reference in JavaDoc", "committedDate": "2021-02-02T11:32:37Z", "type": "commit"}, {"oid": "73c0349163db6346bd6c8c5687eb23f447724c9d", "url": "https://github.com/apache/kafka/commit/73c0349163db6346bd6c8c5687eb23f447724c9d", "message": "remove compiler warnings", "committedDate": "2021-02-02T11:32:38Z", "type": "commit"}, {"oid": "74b21f97cba2a9b39dbbaa0dc10dd9332ef7b40f", "url": "https://github.com/apache/kafka/commit/74b21f97cba2a9b39dbbaa0dc10dd9332ef7b40f", "message": "implementation and test", "committedDate": "2021-02-02T11:32:40Z", "type": "commit"}, {"oid": "c60a1a0a207faef40dd30033486e83432aeae7aa", "url": "https://github.com/apache/kafka/commit/c60a1a0a207faef40dd30033486e83432aeae7aa", "message": "more tests", "committedDate": "2021-02-02T11:32:41Z", "type": "commit"}, {"oid": "15dd15233180dbfc45c15a50b46aa3c830c3e7da", "url": "https://github.com/apache/kafka/commit/15dd15233180dbfc45c15a50b46aa3c830c3e7da", "message": "Documentation update", "committedDate": "2021-02-02T11:32:42Z", "type": "commit"}, {"oid": "106ca5dd7f8abac27f39054b3e9a0a773c5041b9", "url": "https://github.com/apache/kafka/commit/106ca5dd7f8abac27f39054b3e9a0a773c5041b9", "message": "code review fixes", "committedDate": "2021-02-02T11:32:43Z", "type": "commit"}, {"oid": "184728d2b4c82e5d8b954dcf21bc0ba07b037958", "url": "https://github.com/apache/kafka/commit/184728d2b4c82e5d8b954dcf21bc0ba07b037958", "message": "requireNonNull for chain function and consumer", "committedDate": "2021-02-02T11:32:43Z", "type": "commit"}, {"oid": "89a79e3ff4a86e99377f0c63c027c8b08f590a07", "url": "https://github.com/apache/kafka/commit/89a79e3ff4a86e99377f0c63c027c8b08f590a07", "message": "test for branching with no defaultBranch()/noDefaultBranch()", "committedDate": "2021-02-02T11:32:44Z", "type": "commit"}, {"oid": "cb5f1a6412146a309e43102b843ef0375d18f69e", "url": "https://github.com/apache/kafka/commit/cb5f1a6412146a309e43102b843ef0375d18f69e", "message": "changelog, naming convention for BranchedInternal", "committedDate": "2021-02-02T11:32:45Z", "type": "commit"}, {"oid": "9179a33177f5f67ff332845e5f3ee372142025e2", "url": "https://github.com/apache/kafka/commit/9179a33177f5f67ff332845e5f3ee372142025e2", "message": "Scala API wrapper", "committedDate": "2021-02-02T14:43:24Z", "type": "commit"}, {"oid": "ad6d6cca6f5bf82ed06849878ebeb326f20d01c7", "url": "https://github.com/apache/kafka/commit/ad6d6cca6f5bf82ed06849878ebeb326f20d01c7", "message": "spotlessApply", "committedDate": "2021-02-02T14:43:26Z", "type": "commit"}, {"oid": "bb684e06f533a2b8b449ea079cf1c7c56e3888c0", "url": "https://github.com/apache/kafka/commit/bb684e06f533a2b8b449ea079cf1c7c56e3888c0", "message": "Correct the test to use the Scala Branched, not the Java one.", "committedDate": "2021-02-02T14:43:27Z", "type": "commit"}, {"oid": "4780f5279ccda10880f806db57689dc1379f633b", "url": "https://github.com/apache/kafka/commit/4780f5279ccda10880f806db57689dc1379f633b", "message": "Use default arguments instead of method overloads", "committedDate": "2021-02-02T14:43:29Z", "type": "commit"}, {"oid": "f4fbe74421f102124d7ebfe8df79ea933b97e460", "url": "https://github.com/apache/kafka/commit/f4fbe74421f102124d7ebfe8df79ea933b97e460", "message": "Use \"suffix\" instead of \"postfix\"", "committedDate": "2021-02-02T14:43:31Z", "type": "commit"}, {"oid": "aa3309e99448212034075961ed0c1e3d2fcff9c1", "url": "https://github.com/apache/kafka/commit/aa3309e99448212034075961ed0c1e3d2fcff9c1", "message": "convert CRLF -> LF", "committedDate": "2021-02-02T14:43:32Z", "type": "commit"}, {"oid": "c0540b16e45885e537eee3e90e9a9b3c7eb9afb3", "url": "https://github.com/apache/kafka/commit/c0540b16e45885e537eee3e90e9a9b3c7eb9afb3", "message": "fixed JavaDoc/Scaladoc\n\n* consumers cannot be null\n* typo: \"function\"->\"consumer\"", "committedDate": "2021-02-02T14:43:33Z", "type": "commit"}, {"oid": "68a830aaff0c4e8ce83f34a846316be9f2a1df31", "url": "https://github.com/apache/kafka/commit/68a830aaff0c4e8ce83f34a846316be9f2a1df31", "message": "Rewrite StreamsGraphTest using split()", "committedDate": "2021-02-02T14:43:34Z", "type": "commit"}, {"oid": "a82e991edd7701282b266cd3fadec14ff91ebbbc", "url": "https://github.com/apache/kafka/commit/a82e991edd7701282b266cd3fadec14ff91ebbbc", "message": "Javadoc/Scaladoc and Developer Guide updates", "committedDate": "2021-02-02T14:43:37Z", "type": "commit"}, {"oid": "a99018f2aafda722dbb56d4b4201b744408d45f7", "url": "https://github.com/apache/kafka/commit/a99018f2aafda722dbb56d4b4201b744408d45f7", "message": "unused Named import", "committedDate": "2021-02-02T15:04:25Z", "type": "commit"}, {"oid": "a99018f2aafda722dbb56d4b4201b744408d45f7", "url": "https://github.com/apache/kafka/commit/a99018f2aafda722dbb56d4b4201b744408d45f7", "message": "unused Named import", "committedDate": "2021-02-02T15:04:25Z", "type": "forcePushed"}, {"oid": "db573f522fa959d82d85b6964715cf3501205d38", "url": "https://github.com/apache/kafka/commit/db573f522fa959d82d85b6964715cf3501205d38", "message": "remove FunctionConverters", "committedDate": "2021-02-02T15:11:06Z", "type": "commit"}]}