{"pr_number": 8262, "pr_title": "KAFKA-6145: Add constrained balanced assignment algorithm", "pr_createdAt": "2020-03-10T09:15:09Z", "pr_url": "https://github.com/apache/kafka/pull/8262", "timeline": [{"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "url": "https://github.com/apache/kafka/commit/8aaad083f32ca67946a6c3df7f95650dd348c24c", "message": "[WIP] KAFKA-6145: Add constrained balanced assignment algorithm", "committedDate": "2020-03-10T09:14:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI3NDc2NA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391274764", "bodyText": "req: The clientId type should be UUID, or a generic for easier testing (c.f StickyTaskAssignor)", "author": "ableegoldman", "createdAt": "2020-03-11T21:20:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/StateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public interface StateConstrainedBalancedAssignor {\n+\n+    class ClientIdAndLag {\n+        private final String clientId;", "originalCommit": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUzNTQ4MQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391535481", "bodyText": "Good that you mentioned the easier testing. I was wondering why it was a generic.", "author": "cadonna", "createdAt": "2020-03-12T10:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI3NDc2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI3NTExMg==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391275112", "bodyText": "req: Lag should be a long", "author": "ableegoldman", "createdAt": "2020-03-11T21:21:10Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/StateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public interface StateConstrainedBalancedAssignor {\n+\n+    class ClientIdAndLag {\n+        private final String clientId;\n+        private final int lag;", "originalCommit": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI3NzM1NA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391277354", "bodyText": "req: The client String should be a UUID (or generic, see comment below) here and elsewhere", "author": "ableegoldman", "createdAt": "2020-03-11T21:25:59Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;", "originalCommit": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI4MzU5OA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391283598", "bodyText": "prop: make the value a SortedSet so we can just insert clients as we build the map and use a custom comparator to automatically sort the clients based on lag", "author": "ableegoldman", "createdAt": "2020-03-11T21:39:09Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,", "originalCommit": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1ODIxNw==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391358217", "bodyText": "see #buildClientRankingsByTask", "author": "ableegoldman", "createdAt": "2020-03-12T01:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI4MzU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI4OTA4NQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391289085", "bodyText": "req: I think we want to introduce some acceptableLag config within which a task is considered caught-up, otherwise this is way too strict. ie the condition should be lag <= acceptableLag", "author": "ableegoldman", "createdAt": "2020-03-11T21:52:17Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {", "originalCommit": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMjg0MA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391312840", "bodyText": "See #8282", "author": "ableegoldman", "createdAt": "2020-03-11T22:46:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI4OTA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUxNDg3NA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391514874", "bodyText": "I guess my comment above answers this comment.", "author": "cadonna", "createdAt": "2020-03-12T10:05:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI4OTA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMyOTkwNA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391329904", "bodyText": "req: rename to tasksToPreviousClients or something similar that works  \"previous\" into it", "author": "ableegoldman", "createdAt": "2020-03-11T23:39:52Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {", "originalCommit": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzMjc2MQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391332761", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n          \n          \n            \n                    // If a task was previously assigned to a client that that is caught-up and still exists, give it back", "author": "ableegoldman", "createdAt": "2020-03-11T23:49:17Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client", "originalCommit": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzMzA0OA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391333048", "bodyText": "req: rename clientHostingTask -> previousHostingClient (or similar)", "author": "ableegoldman", "createdAt": "2020-03-11T23:50:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);", "originalCommit": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzNTU3Ng==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391335576", "bodyText": "req: drop the !caughtUpClients.isEmpty() check here, if it's in the map it should have at least 1 caught-up client", "author": "ableegoldman", "createdAt": "2020-03-11T23:59:09Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {", "originalCommit": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUxODk5OA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391518998", "bodyText": "True! I also wondering, why I check for null. They must be some refactoring artefacts.", "author": "cadonna", "createdAt": "2020-03-12T10:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzNTU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzNjQ3MA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391336470", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return map from task IDs to lists of caught-up clients\n          \n          \n            \n                 * @return map from tasks with caught-up clients to the list of client candidates\n          \n      \n    \n    \n  \n\nor something similar to make it clear the map only contains tasks with caught-up clients", "author": "ableegoldman", "createdAt": "2020-03-12T00:02:27Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients", "originalCommit": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzODI3Mw==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391338273", "bodyText": "Hmm...I'm wondering if Map<String, List<TaskId>> previousAssignment is sufficient to pass in, won't we lose all the tasks that were assigned to a client that no longer exists for whatever reason? Maybe we should just pass in Map<TaskId, String> tasksToPreviousClients (aka tasksToHostClients) directly. We can build that map up during other steps in assign", "author": "ableegoldman", "createdAt": "2020-03-12T00:09:17Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {", "originalCommit": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NDkxNQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391344915", "bodyText": "Actually, do we even need this at all? It seems like we get everything we need from statefulTasksToRankedClients -- it should have all tasks (and clients), and either\na) the previous client was caught-up, in which case it should be the first rank and we can determine it was the previous host from a lag of Task.LATEST_OFFSET, or\nb) the previous client was not caught-up, in which case we don't really care what the previous host was for that task", "author": "ableegoldman", "createdAt": "2020-03-12T00:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzODI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUxMjcyNw==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391512727", "bodyText": "I assumed, the algorithm gets statefulTasksToRankedClients already \"normalized\" as described in KIP-441 with 0 for all caught-up clients. With caught-up clients, I mean clients with an acceptable lag. I was not aware of Task.LATEST_OFFSET before I reviewed your PR about the offset sums.\nI guess the question to answer is what is passed to this algorithm.\nAFAIU, statefulTasksToRankedClients should also be passed to the proposeBalancedAssignment() algorithm. That means, we should pass the \"normalized\" version of statefulTasksToRankedClients to this algorithm. I guess StreamsPartitionAssignor#buildClientRankingsByTask() is the right place to construct this map. Still we could use Task.LATEST_OFFSET to encode the client that previously hosted the task and remove previousAssignment.", "author": "cadonna", "createdAt": "2020-03-12T10:01:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzODI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxMzY5MA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392513690", "bodyText": "We synced on this, and agreed this map should be \"normalized\" as described above (ie all caught-up clients are encoded with 0, or Task.LATEST_OFFSET if they had the active task)", "author": "ableegoldman", "createdAt": "2020-03-13T22:29:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzODI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzOTU3Nw==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391339577", "bodyText": "req: we'll never hit this, as taskToCaughtUpClients only contains tasks with caught-up clients IIUC. Can we just construct unassignedTasksWithoutCaughtUpClients as the set totalTasks - taskToCaughtUpClients.keySet? We can do that in assignTasksWithoutCaughtUpClients and remove unassignedTasksWithoutCaughtUpClients from assignTasksWithCaughtUpClients entirely", "author": "ableegoldman", "createdAt": "2020-03-12T00:14:30Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);\n+                if (clientHostingTask != null && caughtUpClients.contains(clientHostingTask)) {\n+                    assignment.get(clientHostingTask).add(taskId);\n+                } else {\n+                    unassignedTasksWithCaughtUpClients.add(taskId);\n+                }\n+            } else {\n+                unassignedTasksWithoutCaughtUpClients.add(taskId);", "originalCommit": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MDA4Mw==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391340083", "bodyText": "Not sure if this will actually be cleaner or end up more complicated, but you may be able to reuse some of the StickyTaskAssignor code here which does similar things", "author": "ableegoldman", "createdAt": "2020-03-12T00:16:32Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);\n+                if (clientHostingTask != null && caughtUpClients.contains(clientHostingTask)) {\n+                    assignment.get(clientHostingTask).add(taskId);\n+                } else {\n+                    unassignedTasksWithCaughtUpClients.add(taskId);\n+                }\n+            } else {\n+                unassignedTasksWithoutCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task has not been assigned to a caught-up client, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {", "originalCommit": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MzM5MQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391343391", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // If a task has not been assigned to a caught-up client, assign it to the caught-up client with the least tasks\n          \n          \n            \n                    // If a task's previous host client was not caught-up or no longer exists, assign it to the caught-up client with the least tasks", "author": "ableegoldman", "createdAt": "2020-03-12T00:29:50Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);\n+                if (clientHostingTask != null && caughtUpClients.contains(clientHostingTask)) {\n+                    assignment.get(clientHostingTask).add(taskId);\n+                } else {\n+                    unassignedTasksWithCaughtUpClients.add(taskId);\n+                }\n+            } else {\n+                unassignedTasksWithoutCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task has not been assigned to a caught-up client, assign it to the caught-up client with the least tasks", "originalCommit": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NjAxNA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391346014", "bodyText": "prop: rename taskCount -> minTaskCount", "author": "ableegoldman", "createdAt": "2020-03-12T00:40:24Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);\n+                if (clientHostingTask != null && caughtUpClients.contains(clientHostingTask)) {\n+                    assignment.get(clientHostingTask).add(taskId);\n+                } else {\n+                    unassignedTasksWithCaughtUpClients.add(taskId);\n+                }\n+            } else {\n+                unassignedTasksWithoutCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task has not been assigned to a caught-up client, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<String> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            for (final String client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    taskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                   final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                   final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.get(taskId);\n+            int previousLag = clientIdAndLags.get(0).lag();\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;", "originalCommit": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1MjU4Nw==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391352587", "bodyText": "prop: move this condition to a descriptively named and/or commented helper function, eg hasMoveableTask\n-- also would be nice to include brief explanation as to why we check the last task only (because all tasks that are caught-up come before the moveable/un-caught-up tasks?)", "author": "ableegoldman", "createdAt": "2020-03-12T01:07:49Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);\n+                if (clientHostingTask != null && caughtUpClients.contains(clientHostingTask)) {\n+                    assignment.get(clientHostingTask).add(taskId);\n+                } else {\n+                    unassignedTasksWithCaughtUpClients.add(taskId);\n+                }\n+            } else {\n+                unassignedTasksWithoutCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task has not been assigned to a caught-up client, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<String> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            for (final String client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    taskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                   final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                   final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.get(taskId);\n+            int previousLag = clientIdAndLags.get(0).lag();\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            int i = 0;\n+            while (clientIdAndLags.get(i).lag() == previousLag) {\n+                final String clientId = clientIdAndLags.get(i).clientId();\n+                final int assignedTasksCount = assignment.get(clientId).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = clientId;\n+                    taskCount = assignedTasksCount;\n+                }\n+                ++i;\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Balance the assignment.\n+     *\n+     * @param assignment assignment\n+     * @param balanceFactor balance factor\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void balance(final Map<String, List<TaskId>> assignment,\n+                         final int balanceFactor,\n+                         final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                         final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        final List<String> clients = new ArrayList<>(assignment.keySet());\n+        if (clients.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        Collections.sort(clients);\n+        for (final String client1 : clients) {\n+            for (final String client2 : clients) {\n+                final List<TaskId> taskIds1 = assignment.get(client1);\n+                final List<TaskId> taskIds2 =  assignment.get(client2);\n+                final List<TaskId> source = taskIds1.size() > taskIds2.size() ? taskIds1 : taskIds2;\n+                final List<TaskId> destination = source == taskIds1 ? taskIds2 : taskIds1;\n+                while (\n+                    source.size() - destination.size() > balanceFactor &&\n+                    !tasksToCaughtUpClients.containsKey(source.get(source.size() - 1))", "originalCommit": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1MzE0Nw==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391353147", "bodyText": "maybe also add a lastAssignedTask(List<TaskId>) helper to clean up source.get(source.size() - 1) used here and below", "author": "ableegoldman", "createdAt": "2020-03-12T01:10:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1MjU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYwOTczMw==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391609733", "bodyText": "Ack", "author": "cadonna", "createdAt": "2020-03-12T13:11:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1MjU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NTk2NQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391355965", "bodyText": "I'm a little confused with the use of destination here -- seems like we only use the destination client to see if we need to try and improve on the balance factor, but when actually moving tasks we loop through all the clients again looking for candidates with fewer assigned tasks.\nDo we need the second for (final String client2 : clients)  loop, or can we just loop through clients once and then for each one loop through rankedClients  to find candidates?", "author": "ableegoldman", "createdAt": "2020-03-12T01:22:50Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);\n+                if (clientHostingTask != null && caughtUpClients.contains(clientHostingTask)) {\n+                    assignment.get(clientHostingTask).add(taskId);\n+                } else {\n+                    unassignedTasksWithCaughtUpClients.add(taskId);\n+                }\n+            } else {\n+                unassignedTasksWithoutCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task has not been assigned to a caught-up client, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<String> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            for (final String client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    taskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                   final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                   final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.get(taskId);\n+            int previousLag = clientIdAndLags.get(0).lag();\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            int i = 0;\n+            while (clientIdAndLags.get(i).lag() == previousLag) {\n+                final String clientId = clientIdAndLags.get(i).clientId();\n+                final int assignedTasksCount = assignment.get(clientId).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = clientId;\n+                    taskCount = assignedTasksCount;\n+                }\n+                ++i;\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Balance the assignment.\n+     *\n+     * @param assignment assignment\n+     * @param balanceFactor balance factor\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void balance(final Map<String, List<TaskId>> assignment,\n+                         final int balanceFactor,\n+                         final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                         final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        final List<String> clients = new ArrayList<>(assignment.keySet());\n+        if (clients.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        Collections.sort(clients);\n+        for (final String client1 : clients) {\n+            for (final String client2 : clients) {\n+                final List<TaskId> taskIds1 = assignment.get(client1);\n+                final List<TaskId> taskIds2 =  assignment.get(client2);\n+                final List<TaskId> source = taskIds1.size() > taskIds2.size() ? taskIds1 : taskIds2;\n+                final List<TaskId> destination = source == taskIds1 ? taskIds2 : taskIds1;", "originalCommit": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU5NzI1OA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391597258", "bodyText": "I like the idea. Will try to realize it.", "author": "cadonna", "createdAt": "2020-03-12T12:48:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NTk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NjI0OA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391356248", "bodyText": "req: If clients is empty I think we can/should catch it earlier, like back in initAssignment?", "author": "ableegoldman", "createdAt": "2020-03-12T01:24:05Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);\n+                if (clientHostingTask != null && caughtUpClients.contains(clientHostingTask)) {\n+                    assignment.get(clientHostingTask).add(taskId);\n+                } else {\n+                    unassignedTasksWithCaughtUpClients.add(taskId);\n+                }\n+            } else {\n+                unassignedTasksWithoutCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task has not been assigned to a caught-up client, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<String> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            for (final String client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    taskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                   final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                   final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.get(taskId);\n+            int previousLag = clientIdAndLags.get(0).lag();\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            int i = 0;\n+            while (clientIdAndLags.get(i).lag() == previousLag) {\n+                final String clientId = clientIdAndLags.get(i).clientId();\n+                final int assignedTasksCount = assignment.get(clientId).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = clientId;\n+                    taskCount = assignedTasksCount;\n+                }\n+                ++i;\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Balance the assignment.\n+     *\n+     * @param assignment assignment\n+     * @param balanceFactor balance factor\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void balance(final Map<String, List<TaskId>> assignment,\n+                         final int balanceFactor,\n+                         final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                         final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        final List<String> clients = new ArrayList<>(assignment.keySet());\n+        if (clients.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");", "originalCommit": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "36e5cdcb619f90b85e264d94a95b7175b96699fc", "url": "https://github.com/apache/kafka/commit/36e5cdcb619f90b85e264d94a95b7175b96699fc", "message": "Update streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java\n\nCo-Authored-By: A. Sophie Blee-Goldman <ableegoldman@gmail.com>", "committedDate": "2020-03-12T10:03:50Z", "type": "commit"}, {"oid": "bf9453fa0a71f3b4d758fde3bb002951219a031d", "url": "https://github.com/apache/kafka/commit/bf9453fa0a71f3b4d758fde3bb002951219a031d", "message": "Update streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java\n\nCo-Authored-By: A. Sophie Blee-Goldman <ableegoldman@gmail.com>", "committedDate": "2020-03-12T10:18:26Z", "type": "commit"}, {"oid": "8372c270297778efa59299f50be310ffcb1a6560", "url": "https://github.com/apache/kafka/commit/8372c270297778efa59299f50be310ffcb1a6560", "message": "Include feedback", "committedDate": "2020-03-12T14:52:38Z", "type": "commit"}, {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "url": "https://github.com/apache/kafka/commit/5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "message": "Add unit tests for state constrained balanced assignment", "committedDate": "2020-03-13T13:40:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxMTY3OQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392511679", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n          \n          \n            \n                 * Assigns tasks for which one or more caught-up clients exist to one of the caught-up clients.", "author": "ableegoldman", "createdAt": "2020-03-13T22:21:56Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, ID> tasksToPreviousClients(final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, ID> tasksToPreviousClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final ClientIdAndLag<ID> topRankedClient = taskToRankedClients.getValue().first();\n+            if (topRankedClient.lag() == Task.LATEST_OFFSET) {\n+                tasksToPreviousClients.put(taskToRankedClients.getKey(), topRankedClient.clientId());\n+            }\n+        }\n+        return tasksToPreviousClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.", "originalCommit": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxMjI3Mg==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392512272", "bodyText": "I think you mentioned this in another comment, but we can drop the null check here right? There should never be an entry with a null value here", "author": "ableegoldman", "createdAt": "2020-03-13T22:24:12Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, ID> tasksToPreviousClients(final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, ID> tasksToPreviousClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final ClientIdAndLag<ID> topRankedClient = taskToRankedClients.getValue().first();\n+            if (topRankedClient.lag() == Task.LATEST_OFFSET) {\n+                tasksToPreviousClients.put(taskToRankedClients.getKey(), topRankedClient.clientId());\n+            }\n+        }\n+        return tasksToPreviousClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        // If a task was previously assigned to a client that is caught-up and still exists, give it back to the client\n+        final Map<TaskId, ID> tasksToPreviousClients = tasksToPreviousClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<ID>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<ID> caughtUpClients = taskToCaughtUpClients.getValue();\n+            final ID previousHostingClients = tasksToPreviousClients.get(taskId);\n+            if (previousHostingClients != null && caughtUpClients.contains(previousHostingClients)) {", "originalCommit": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU5Njc4OA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393596788", "bodyText": "Probably the null check is not needed because contains() can handle it. However, also this is obsolete because of the above comment.", "author": "cadonna", "createdAt": "2020-03-17T11:00:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxMjI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxMjUzMA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392512530", "bodyText": "prop: rename taskToCaughtUpClient to taskEntry or something, looks confusingly similar to tasksToCaughtUpClients", "author": "ableegoldman", "createdAt": "2020-03-13T22:25:12Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, ID> tasksToPreviousClients(final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, ID> tasksToPreviousClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final ClientIdAndLag<ID> topRankedClient = taskToRankedClients.getValue().first();\n+            if (topRankedClient.lag() == Task.LATEST_OFFSET) {\n+                tasksToPreviousClients.put(taskToRankedClients.getKey(), topRankedClient.clientId());\n+            }\n+        }\n+        return tasksToPreviousClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        // If a task was previously assigned to a client that is caught-up and still exists, give it back to the client\n+        final Map<TaskId, ID> tasksToPreviousClients = tasksToPreviousClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<ID>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {", "originalCommit": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU5NjE0Mw==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393596143", "bodyText": "Obsolete, because of comment above.", "author": "cadonna", "createdAt": "2020-03-17T10:59:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxMjUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxODg1MA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392518850", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n          \n          \n            \n                    for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n          \n          \n            \n                        final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n          \n          \n            \n                        for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n          \n          \n            \n                            if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n          \n          \n            \n                                final TaskId taskId = taskToRankedClient.getKey();\n          \n          \n            \n                                taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n          \n          \n            \n                            } else {\n          \n          \n            \n                                break;\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    return taskToCaughtUpClients;\n          \n          \n            \n                    final Map<TaskId, List<ID>> taskToCaughtUpClients =\n          \n          \n            \n                        statefulTasksToRankedClients.entrySet().stream().collect(Collectors.toMap(\n          \n          \n            \n                            Entry::getKey, \n          \n          \n            \n                            t -> t.getValue().stream()\n          \n          \n            \n                                     .filter(c -> c.lag() == 0 || c.lag() == Task.LATEST_OFFSET)\n          \n          \n            \n                                     .map(ClientIdAndLag::clientId)\n          \n          \n            \n                                     .collect(Collectors.toList())));", "author": "ableegoldman", "createdAt": "2020-03-13T22:50:56Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;", "originalCommit": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMzQ4MA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392523480", "bodyText": "(just a suggestion based on what I personally find easier to read)", "author": "ableegoldman", "createdAt": "2020-03-13T23:11:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxODg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU1Nzk0Mg==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392557942", "bodyText": "TBH, I'm a little skeptical of using this style too much. Nothing against functional programming; it's just that, having done quite a bit of FP-heavy programming and maintenance for quite a few years, I've settled into an opinion that it's most efficient when employed in simple contexts. When you get into nested transformations like this, it becomes harder to come back to the code in three years with a completely blank slate and read it. Plus, it has a tendency to steer you away from efficient code and you can wind up doing multiple iterations over the same collection when one would have done. So, I tend to use the FP APIs to do stuff like turn a list of Tasks into a list of TaskId, and I'm happier to see regular loops and conditionals for stuff like this.\nThis is very much a matter of preference, though, and I'm only expressing mine.", "author": "vvcephei", "createdAt": "2020-03-14T05:11:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxODg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzEyMDU0Mw==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393120543", "bodyText": "Thank you for the proposal! That is an interesting alternative, but it is not equivalent to the original. In the original a task is only added to taskToCaughtUpClients if there are caught-up clients whereas in your alternative all tasks are added irrespectively whether they have a caught-up client or not. This breaks other parts of the code and the unit tests are not green. I tried to get at least the filter() to work, because I like it better than the break, but then I thought in the for-loop I have the guarantee that the loop stops after the caught-up clients, with the functional programming approach I haven't. So I decided to leave it as it is.", "author": "cadonna", "createdAt": "2020-03-16T15:43:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxODg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQwNzQ5MQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393407491", "bodyText": "Fine with me -- it's just a \"prop\" after all.\nFWIW I generally find these functional-style methods harder to read, but for whatever reason in this case I was finding the original a bit hard to understand and thought this suggestion helped to \"get to the point\" faster.\nBut of course it's always easier to read your own code than someone else's \ud83d\ude1c", "author": "ableegoldman", "createdAt": "2020-03-17T02:14:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxODg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk2MTI4OQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393961289", "bodyText": "Sounds good \ud83d\ude42", "author": "ableegoldman", "createdAt": "2020-03-17T20:49:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxODg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMTg5OA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392521898", "bodyText": "Since this only returns tasks whose previous client was caught up, I think we can simplify the first half of assignTasksWithCaughtUpClients  as just\ntasksToPreviousClients.forEach((t, c) -> assignment.computeIfPresent(c, (k, v) -> { v.add(t);  return v;}));\nunassignedTasksWithCaughtUpClients = new ArrayList<>(tasksToCaughtUpClients.keySet());\nunassignedTasksWithCaughtUpClients.removeAll(tasksToPreviousClients.keySet());", "author": "ableegoldman", "createdAt": "2020-03-13T23:04:22Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, ID> tasksToPreviousClients(final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, ID> tasksToPreviousClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final ClientIdAndLag<ID> topRankedClient = taskToRankedClients.getValue().first();\n+            if (topRankedClient.lag() == Task.LATEST_OFFSET) {\n+                tasksToPreviousClients.put(taskToRankedClients.getKey(), topRankedClient.clientId());\n+            }\n+        }\n+        return tasksToPreviousClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        // If a task was previously assigned to a client that is caught-up and still exists, give it back to the client\n+        final Map<TaskId, ID> tasksToPreviousClients = tasksToPreviousClients(statefulTasksToRankedClients);", "originalCommit": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU5NjA3Ng==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393596076", "bodyText": "Thank you for the proposal! I was able to simplify it even further and make it better readable, IMO.", "author": "cadonna", "createdAt": "2020-03-17T10:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMTg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMjIwOA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392522208", "bodyText": "req: clarify (either in name or in javadocs) that this only returns tasks whose previous client was caught-up (ie the task got to RUNNING)", "author": "ableegoldman", "createdAt": "2020-03-13T23:05:44Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, ID> tasksToPreviousClients(final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {", "originalCommit": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMzA5Nw==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392523097", "bodyText": "req: I think we need to iterate forwards in this case?", "author": "ableegoldman", "createdAt": "2020-03-13T23:09:07Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, ID> tasksToPreviousClients(final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, ID> tasksToPreviousClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final ClientIdAndLag<ID> topRankedClient = taskToRankedClients.getValue().first();\n+            if (topRankedClient.lag() == Task.LATEST_OFFSET) {\n+                tasksToPreviousClients.put(taskToRankedClients.getKey(), topRankedClient.clientId());\n+            }\n+        }\n+        return tasksToPreviousClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        // If a task was previously assigned to a client that is caught-up and still exists, give it back to the client\n+        final Map<TaskId, ID> tasksToPreviousClients = tasksToPreviousClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<ID>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<ID> caughtUpClients = taskToCaughtUpClients.getValue();\n+            final ID previousHostingClients = tasksToPreviousClients.get(taskId);\n+            if (previousHostingClients != null && caughtUpClients.contains(previousHostingClients)) {\n+                assignment.get(previousHostingClients).add(taskId);\n+            } else {\n+                unassignedTasksWithCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task's previous host client was not caught-up or no longer exists, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<ID> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            ID clientWithLeastTasks = null;\n+            int minTaskCount = Integer.MAX_VALUE;\n+            for (final ID client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (minTaskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    minTaskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                   final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                   final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final SortedSet<TaskId> unassignedTasksWithoutCaughtUpClients = new TreeSet<>(statefulTasksToRankedClients.keySet());\n+        unassignedTasksWithoutCaughtUpClients.removeAll(tasksToCaughtUpClients.keySet());\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = statefulTasksToRankedClients.get(taskId);\n+            final long minLag = rankedClients.first().lag();\n+            int minTasksCount = Integer.MAX_VALUE;\n+            ID clientWithLeastTasks = rankedClients.first().clientId();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == minLag) {\n+                    final ID clientId = clientIdAndLag.clientId();\n+                    final int assignedTasksCount = assignment.get(clientId).size();\n+                    if (minTasksCount > assignedTasksCount) {\n+                        clientWithLeastTasks = clientId;\n+                        minTasksCount = assignedTasksCount;\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Balance the assignment.\n+     *\n+     * @param assignment assignment\n+     * @param balanceFactor balance factor\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void balance(final Map<ID, List<TaskId>> assignment,\n+                         final int balanceFactor,\n+                         final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                         final Map<TaskId, List<ID>> tasksToCaughtUpClients) {\n+        final List<ID> clients = new ArrayList<>(assignment.keySet());\n+        Collections.sort(clients);\n+        for (final ID client : clients) {\n+            final List<TaskId> source = assignment.get(client);\n+            for (final TaskId task : assignedTasksWithoutCaughtUpClients(source, tasksToCaughtUpClients)) {\n+                for (final ClientIdAndLag<ID> clientAndLag : statefulTasksToRankedClients.get(task)) {\n+                    final List<TaskId> destination = assignment.get(clientAndLag.clientId());\n+                    if (source.size() - destination.size() > balanceFactor) {\n+                        source.remove(task);\n+                        destination.add(task);\n+                    }\n+                }\n+            }\n+            for (final TaskId task : assignedTasksWithCaughtUpClients(source, tasksToCaughtUpClients)) {\n+                for (final ID caughtUpClient : tasksToCaughtUpClients.get(task)) {\n+                    final List<TaskId> destination = assignment.get(caughtUpClient);\n+                    if (source.size() - destination.size() > balanceFactor) {\n+                        source.remove(task);\n+                        destination.add(task);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns a sublist of tasks in the given list that does not have a caught-up client.\n+     *\n+     * @param tasks list of task IDs\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     * @return a list of task IDs that does not have a caught-up client\n+     */\n+    private List<TaskId> assignedTasksWithoutCaughtUpClients(final List<TaskId> tasks,\n+                                                             final Map<TaskId, List<ID>> tasksToCaughtUpClients) {\n+        final List<TaskId> tasksWithoutCaughtUpClients = new ArrayList<>();\n+        for (int i = tasks.size() - 1; i >= 0; --i) {\n+            final TaskId task = tasks.get(i);\n+            if (!tasksToCaughtUpClients.containsKey(task)) {\n+                tasksWithoutCaughtUpClients.add(task);\n+            } else {\n+                break;\n+            }\n+        }\n+        return Collections.unmodifiableList(tasksWithoutCaughtUpClients);\n+    }\n+    private List<TaskId> assignedTasksWithCaughtUpClients(final List<TaskId> tasks,\n+                                                          final Map<TaskId, List<ID>> tasksToCaughtUpClients) {\n+        final List<TaskId> tasksWithCaughtUpClients = new ArrayList<>();\n+        for (int i = tasks.size() - 1; i >= 0; --i) {", "originalCommit": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI2NzU5Mg==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393267592", "bodyText": "I had to remove the break, because I found a case that breaks the assumption that tasks with caught-up clients are always in the beginning of the list.\nI still think it is better to iterate from the end because the order in most cases is as follows:\n\ntasks that were previously running on this client\ntasks for which this client is caught-up\ntasks for which this client is not caught-up\n\nI would rather move tasks in 2 before tasks in 1 and since the break is removed we do not abort pre-maturely.", "author": "cadonna", "createdAt": "2020-03-16T19:38:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMzA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk2NjY2MQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393966661", "bodyText": "Sounds good. The assumption is broken due to swapping tasks around during balance without preserving order, is that it?", "author": "ableegoldman", "createdAt": "2020-03-17T20:58:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMzA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxMjMwMg==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r394212302", "bodyText": "Exactly!", "author": "cadonna", "createdAt": "2020-03-18T09:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMzA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMzIxMw==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392523213", "bodyText": "Nice helper, this makes the balance code a lot easier to read", "author": "ableegoldman", "createdAt": "2020-03-13T23:09:41Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, ID> tasksToPreviousClients(final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, ID> tasksToPreviousClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final ClientIdAndLag<ID> topRankedClient = taskToRankedClients.getValue().first();\n+            if (topRankedClient.lag() == Task.LATEST_OFFSET) {\n+                tasksToPreviousClients.put(taskToRankedClients.getKey(), topRankedClient.clientId());\n+            }\n+        }\n+        return tasksToPreviousClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        // If a task was previously assigned to a client that is caught-up and still exists, give it back to the client\n+        final Map<TaskId, ID> tasksToPreviousClients = tasksToPreviousClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<ID>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<ID> caughtUpClients = taskToCaughtUpClients.getValue();\n+            final ID previousHostingClients = tasksToPreviousClients.get(taskId);\n+            if (previousHostingClients != null && caughtUpClients.contains(previousHostingClients)) {\n+                assignment.get(previousHostingClients).add(taskId);\n+            } else {\n+                unassignedTasksWithCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task's previous host client was not caught-up or no longer exists, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<ID> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            ID clientWithLeastTasks = null;\n+            int minTaskCount = Integer.MAX_VALUE;\n+            for (final ID client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (minTaskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    minTaskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                   final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                   final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final SortedSet<TaskId> unassignedTasksWithoutCaughtUpClients = new TreeSet<>(statefulTasksToRankedClients.keySet());\n+        unassignedTasksWithoutCaughtUpClients.removeAll(tasksToCaughtUpClients.keySet());\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = statefulTasksToRankedClients.get(taskId);\n+            final long minLag = rankedClients.first().lag();\n+            int minTasksCount = Integer.MAX_VALUE;\n+            ID clientWithLeastTasks = rankedClients.first().clientId();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == minLag) {\n+                    final ID clientId = clientIdAndLag.clientId();\n+                    final int assignedTasksCount = assignment.get(clientId).size();\n+                    if (minTasksCount > assignedTasksCount) {\n+                        clientWithLeastTasks = clientId;\n+                        minTasksCount = assignedTasksCount;\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Balance the assignment.\n+     *\n+     * @param assignment assignment\n+     * @param balanceFactor balance factor\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void balance(final Map<ID, List<TaskId>> assignment,\n+                         final int balanceFactor,\n+                         final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                         final Map<TaskId, List<ID>> tasksToCaughtUpClients) {\n+        final List<ID> clients = new ArrayList<>(assignment.keySet());\n+        Collections.sort(clients);\n+        for (final ID client : clients) {\n+            final List<TaskId> source = assignment.get(client);\n+            for (final TaskId task : assignedTasksWithoutCaughtUpClients(source, tasksToCaughtUpClients)) {\n+                for (final ClientIdAndLag<ID> clientAndLag : statefulTasksToRankedClients.get(task)) {\n+                    final List<TaskId> destination = assignment.get(clientAndLag.clientId());\n+                    if (source.size() - destination.size() > balanceFactor) {\n+                        source.remove(task);\n+                        destination.add(task);\n+                    }\n+                }\n+            }\n+            for (final TaskId task : assignedTasksWithCaughtUpClients(source, tasksToCaughtUpClients)) {\n+                for (final ID caughtUpClient : tasksToCaughtUpClients.get(task)) {\n+                    final List<TaskId> destination = assignment.get(caughtUpClient);\n+                    if (source.size() - destination.size() > balanceFactor) {\n+                        source.remove(task);\n+                        destination.add(task);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns a sublist of tasks in the given list that does not have a caught-up client.\n+     *\n+     * @param tasks list of task IDs\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     * @return a list of task IDs that does not have a caught-up client\n+     */\n+    private List<TaskId> assignedTasksWithoutCaughtUpClients(final List<TaskId> tasks,", "originalCommit": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNTU1NQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392525555", "bodyText": "req: should we break out of the statefulTasksToRankedClients loop here?", "author": "ableegoldman", "createdAt": "2020-03-13T23:21:23Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, ID> tasksToPreviousClients(final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, ID> tasksToPreviousClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final ClientIdAndLag<ID> topRankedClient = taskToRankedClients.getValue().first();\n+            if (topRankedClient.lag() == Task.LATEST_OFFSET) {\n+                tasksToPreviousClients.put(taskToRankedClients.getKey(), topRankedClient.clientId());\n+            }\n+        }\n+        return tasksToPreviousClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        // If a task was previously assigned to a client that is caught-up and still exists, give it back to the client\n+        final Map<TaskId, ID> tasksToPreviousClients = tasksToPreviousClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<ID>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<ID> caughtUpClients = taskToCaughtUpClients.getValue();\n+            final ID previousHostingClients = tasksToPreviousClients.get(taskId);\n+            if (previousHostingClients != null && caughtUpClients.contains(previousHostingClients)) {\n+                assignment.get(previousHostingClients).add(taskId);\n+            } else {\n+                unassignedTasksWithCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task's previous host client was not caught-up or no longer exists, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<ID> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            ID clientWithLeastTasks = null;\n+            int minTaskCount = Integer.MAX_VALUE;\n+            for (final ID client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (minTaskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    minTaskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                   final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                   final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final SortedSet<TaskId> unassignedTasksWithoutCaughtUpClients = new TreeSet<>(statefulTasksToRankedClients.keySet());\n+        unassignedTasksWithoutCaughtUpClients.removeAll(tasksToCaughtUpClients.keySet());\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = statefulTasksToRankedClients.get(taskId);\n+            final long minLag = rankedClients.first().lag();\n+            int minTasksCount = Integer.MAX_VALUE;\n+            ID clientWithLeastTasks = rankedClients.first().clientId();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == minLag) {\n+                    final ID clientId = clientIdAndLag.clientId();\n+                    final int assignedTasksCount = assignment.get(clientId).size();\n+                    if (minTasksCount > assignedTasksCount) {\n+                        clientWithLeastTasks = clientId;\n+                        minTasksCount = assignedTasksCount;\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Balance the assignment.\n+     *\n+     * @param assignment assignment\n+     * @param balanceFactor balance factor\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void balance(final Map<ID, List<TaskId>> assignment,\n+                         final int balanceFactor,\n+                         final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                         final Map<TaskId, List<ID>> tasksToCaughtUpClients) {\n+        final List<ID> clients = new ArrayList<>(assignment.keySet());\n+        Collections.sort(clients);\n+        for (final ID client : clients) {\n+            final List<TaskId> source = assignment.get(client);\n+            for (final TaskId task : assignedTasksWithoutCaughtUpClients(source, tasksToCaughtUpClients)) {\n+                for (final ClientIdAndLag<ID> clientAndLag : statefulTasksToRankedClients.get(task)) {\n+                    final List<TaskId> destination = assignment.get(clientAndLag.clientId());\n+                    if (source.size() - destination.size() > balanceFactor) {\n+                        source.remove(task);\n+                        destination.add(task);", "originalCommit": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5ODc2NQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393298765", "bodyText": "Good catch! Adapted unit tests to catch also this issue.", "author": "cadonna", "createdAt": "2020-03-16T20:44:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNTU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNTgzMA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392525830", "bodyText": "same here", "author": "ableegoldman", "createdAt": "2020-03-13T23:22:46Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, ID> tasksToPreviousClients(final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, ID> tasksToPreviousClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final ClientIdAndLag<ID> topRankedClient = taskToRankedClients.getValue().first();\n+            if (topRankedClient.lag() == Task.LATEST_OFFSET) {\n+                tasksToPreviousClients.put(taskToRankedClients.getKey(), topRankedClient.clientId());\n+            }\n+        }\n+        return tasksToPreviousClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        // If a task was previously assigned to a client that is caught-up and still exists, give it back to the client\n+        final Map<TaskId, ID> tasksToPreviousClients = tasksToPreviousClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<ID>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<ID> caughtUpClients = taskToCaughtUpClients.getValue();\n+            final ID previousHostingClients = tasksToPreviousClients.get(taskId);\n+            if (previousHostingClients != null && caughtUpClients.contains(previousHostingClients)) {\n+                assignment.get(previousHostingClients).add(taskId);\n+            } else {\n+                unassignedTasksWithCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task's previous host client was not caught-up or no longer exists, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<ID> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            ID clientWithLeastTasks = null;\n+            int minTaskCount = Integer.MAX_VALUE;\n+            for (final ID client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (minTaskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    minTaskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                   final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                   final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final SortedSet<TaskId> unassignedTasksWithoutCaughtUpClients = new TreeSet<>(statefulTasksToRankedClients.keySet());\n+        unassignedTasksWithoutCaughtUpClients.removeAll(tasksToCaughtUpClients.keySet());\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = statefulTasksToRankedClients.get(taskId);\n+            final long minLag = rankedClients.first().lag();\n+            int minTasksCount = Integer.MAX_VALUE;\n+            ID clientWithLeastTasks = rankedClients.first().clientId();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == minLag) {\n+                    final ID clientId = clientIdAndLag.clientId();\n+                    final int assignedTasksCount = assignment.get(clientId).size();\n+                    if (minTasksCount > assignedTasksCount) {\n+                        clientWithLeastTasks = clientId;\n+                        minTasksCount = assignedTasksCount;\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Balance the assignment.\n+     *\n+     * @param assignment assignment\n+     * @param balanceFactor balance factor\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void balance(final Map<ID, List<TaskId>> assignment,\n+                         final int balanceFactor,\n+                         final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                         final Map<TaskId, List<ID>> tasksToCaughtUpClients) {\n+        final List<ID> clients = new ArrayList<>(assignment.keySet());\n+        Collections.sort(clients);\n+        for (final ID client : clients) {\n+            final List<TaskId> source = assignment.get(client);\n+            for (final TaskId task : assignedTasksWithoutCaughtUpClients(source, tasksToCaughtUpClients)) {\n+                for (final ClientIdAndLag<ID> clientAndLag : statefulTasksToRankedClients.get(task)) {\n+                    final List<TaskId> destination = assignment.get(clientAndLag.clientId());\n+                    if (source.size() - destination.size() > balanceFactor) {\n+                        source.remove(task);\n+                        destination.add(task);\n+                    }\n+                }\n+            }\n+            for (final TaskId task : assignedTasksWithCaughtUpClients(source, tasksToCaughtUpClients)) {\n+                for (final ID caughtUpClient : tasksToCaughtUpClients.get(task)) {\n+                    final List<TaskId> destination = assignment.get(caughtUpClient);\n+                    if (source.size() - destination.size() > balanceFactor) {\n+                        source.remove(task);\n+                        destination.add(task);", "originalCommit": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjIyOQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392526229", "bodyText": "WDYT about renaming lag to rank, or effectiveLag, or something else that reminds us this isn't the actual literal lag? cc/ @vvcephei", "author": "ableegoldman", "createdAt": "2020-03-13T23:25:08Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/StateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+\n+public interface StateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> {\n+\n+    class ClientIdAndLag<ID extends Comparable<? super ID>> implements Comparable<ClientIdAndLag<ID>> {\n+        private final ID clientId;\n+        private final long lag;", "originalCommit": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU1NjU3Mw==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392556573", "bodyText": "Good thought. Lag was originally proposed in the KIP, but it's not what we're using anymore.", "author": "vvcephei", "createdAt": "2020-03-14T04:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU4MDU5NQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393580595", "bodyText": "Agreed!", "author": "cadonna", "createdAt": "2020-03-17T10:30:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjUyNA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392526524", "bodyText": "req: move this to StreamsPartitionAssignor, where we'll be building and passing the Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients map around", "author": "ableegoldman", "createdAt": "2020-03-13T23:26:28Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/StateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+\n+public interface StateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> {\n+\n+    class ClientIdAndLag<ID extends Comparable<? super ID>> implements Comparable<ClientIdAndLag<ID>> {", "originalCommit": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM0ODIxNQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393348215", "bodyText": "I would like to leave it as it is now and move it around when we have also other pieces in place.", "author": "cadonna", "createdAt": "2020-03-16T22:36:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjUyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQxMDIzMA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393410230", "bodyText": "Actually, WDYT about adding this class in the \"add configs\" PR and then rebasing this PR on top of that? Then I could do the same (since I need this class in my next PR as well)", "author": "ableegoldman", "createdAt": "2020-03-17T02:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjUyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYwMTAxMg==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393601012", "bodyText": "OK, makes sense haven't thought of that. Feel free to copy it over.", "author": "cadonna", "createdAt": "2020-03-17T11:08:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNzA4OQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392527089", "bodyText": "I know we do the same for the StickyTaskAssignor, but I don't really see what we gain by adding an interface for this class. Do we need it?", "author": "ableegoldman", "createdAt": "2020-03-13T23:29:23Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/StateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+\n+public interface StateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> {", "originalCommit": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM0ODkwMA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393348900", "bodyText": "The idea was to enable the strategy design pattern. It makes the whole assignment algorithm more modular. The algorithm implementation can be plugged in easily and if we want we can even choose the algorithm at runtime which can be handy if we want to benchmark different versions of the algorithm.", "author": "cadonna", "createdAt": "2020-03-16T22:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNzA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU1NTU3NQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392555575", "bodyText": "It looks like the primary purpose of this logic is to compute the list of clients, given the statefulTasksToRankedClients. Let's instead just make the set of clients an input to the assignment method instead. I realize it's not in the method signature I specified in the KIP, but then again, that was just algorithm pseudocode. This method isn't used anywhere (yet), so let's take advantage and just assume we'll be passed everything we need in the most convenient format for us.", "author": "vvcephei", "createdAt": "2020-03-14T04:25:31Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {", "originalCommit": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA0ODIwNA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393048204", "bodyText": "The primary purpose is to have an initialized map with empty lists as values, so that I do not need to care about get() returning null in other parts of this class. Additionally, this method makes sure that each client gets its assignment even though it might be an empty list. I agree about making the set of clients a parameter to the assign() method, though.", "author": "cadonna", "createdAt": "2020-03-16T14:08:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU1NTU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU1NTc3NA==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392555774", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n          \n          \n            \n                    for (final Map.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n          \n      \n    \n    \n  \n\nJust to resolve a warning about referencing the subclass instead of the interface.", "author": "vvcephei", "createdAt": "2020-03-14T04:28:56Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {", "originalCommit": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3OTU0MQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393079541", "bodyText": "How did you get that warning? How can this produce a warning?", "author": "cadonna", "createdAt": "2020-03-16T14:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU1NTc3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAzNDIzNg==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r394034236", "bodyText": "It's a warning you can enable in IntelliJ IDEA. Not a huge deal.", "author": "vvcephei", "createdAt": "2020-03-17T23:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU1NTc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU1NjYyNQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392556625", "bodyText": "These utility methods can be static.", "author": "vvcephei", "createdAt": "2020-03-14T04:46:06Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignorTest.java", "diffHunk": "@@ -0,0 +1,463 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+import org.apache.kafka.streams.processor.internals.assignment.StateConstrainedBalancedAssignor.ClientIdAndLag;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import static org.apache.kafka.common.utils.Utils.mkEntry;\n+import static org.apache.kafka.common.utils.Utils.mkMap;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class DefaultStateConstrainedBalancedAssignorTest {\n+\n+    private static final TaskId TASK_01 = new TaskId(0, 1);\n+    private static final TaskId TASK_12 = new TaskId(1, 2);\n+    private static final TaskId TASK_23 = new TaskId(2, 3);\n+\n+    private static final String CLIENT_1 = \"client1\";\n+    private static final String CLIENT_2 = \"client2\";\n+    private static final String CLIENT_3 = \"client3\";\n+\n+    @Test\n+    public void shouldAssignTaskToCaughtUpClient() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = Long.MAX_VALUE;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToPreviouslyHostingClient() {\n+        final long lagOfClient1 = Long.MAX_VALUE;\n+        final long lagOfClient2 = Task.LATEST_OFFSET;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToPreviouslyHostingClientWhenOtherCaughtUpClientExists() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = Task.LATEST_OFFSET;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToCaughtUpClientThatIsFirstInSortOrder() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToMostCaughtUpClient() {\n+        final long lagOfClient1 = 3;\n+        final long lagOfClient2 = 5;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHosts() {\n+        final long lagForTask01OnClient1 = 0;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 0;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1, \n+                lagForTask01OnClient2, \n+                lagForTask12OnClient1, \n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHostsEvenIfNotRequiredByBalanceFactor() {\n+        final long lagForTask01OnClient1 = 0;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 0;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfBoth() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfBoth1() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 100;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfBoth2() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 100;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignBothTasksToPreviousHostSinceBalanceFactorSatisfied() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Arrays.asList(TASK_01, TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignOneTaskToPreviousHostAndOtherTaskToMostCaughtUpClient() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 20;\n+        final long lagForTask12OnClient2 = 10;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignOneTaskToPreviousHostAndOtherTaskToNotMostCaughtUpClientDueToBalanceFactor() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 10;\n+        final long lagForTask12OnClient2 = 20;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignBothTasksToSameClientSincePreviousHostAndMostCaughtUpAndBalanceFactorSatisfied() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 10;\n+        final long lagForTask12OnClient2 = 20;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Arrays.asList(TASK_01, TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTasksToMostCaughtUpClient() {\n+        final long lagForTask01OnClient1 = 40;\n+        final long lagForTask01OnClient2 = 30;\n+        final long lagForTask12OnClient1 = 10;\n+        final long lagForTask12OnClient2 = 20;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignOneTaskToNotMostCaughtUpClientsDueToBalanceFactor() {\n+        final long lagForTask01OnClient1 = 40;\n+        final long lagForTask01OnClient2 = 30;\n+        final long lagForTask12OnClient1 = 20;\n+        final long lagForTask12OnClient2 = 10;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignBothTasksToSameMostCaughtUpClientSinceBalanceFactorSatisfied() {\n+        final long lagForTask01OnClient1 = 40;\n+        final long lagForTask01OnClient2 = 30;\n+        final long lagForTask12OnClient1 = 20;\n+        final long lagForTask12OnClient2 = 10;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Arrays.asList(TASK_01, TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksOverClientsWithEqualRank() {\n+        final long lagForTask01OnClient1 = 40;\n+        final long lagForTask01OnClient2 = 40;\n+        final long lagForTask12OnClient1 = 40;\n+        final long lagForTask12OnClient2 = 40;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    private SortedMap<TaskId, SortedSet<ClientIdAndLag<String>>> oneStatefulTasksToTwoRankedClients(final long lagOfClient1,\n+                                                                                                    final long lagOfClient2) {\n+        final SortedSet<ClientIdAndLag<String>> rankedClients01 = new TreeSet<>();\n+        rankedClients01.add(ClientIdAndLag.make(CLIENT_1, lagOfClient1));\n+        rankedClients01.add(ClientIdAndLag.make(CLIENT_2, lagOfClient2));\n+        return new TreeMap<>(\n+            mkMap(mkEntry(TASK_01, rankedClients01))\n+        );\n+    }\n+\n+    private SortedMap<TaskId, SortedSet<ClientIdAndLag<String>>> twoStatefulTasksToTwoRankedClients(final long lagForTask01OnClient1,\n+                                                                                                    final long lagForTask01OnClient2,\n+                                                                                                    final long lagForTask12OnClient1,\n+                                                                                                    final long lagForTask12OnClient2) {\n+        final SortedSet<ClientIdAndLag<String>> rankedClients01 = new TreeSet<>();\n+        rankedClients01.add(ClientIdAndLag.make(CLIENT_1, lagForTask01OnClient1));\n+        rankedClients01.add(ClientIdAndLag.make(CLIENT_2, lagForTask01OnClient2));\n+        final SortedSet<ClientIdAndLag<String>> rankedClients12 = new TreeSet<>();\n+        rankedClients12.add(ClientIdAndLag.make(CLIENT_1, lagForTask12OnClient1));\n+        rankedClients12.add(ClientIdAndLag.make(CLIENT_2, lagForTask12OnClient2));\n+        return new TreeMap<>(\n+            mkMap(\n+                mkEntry(TASK_01, rankedClients01),\n+                mkEntry(TASK_12, rankedClients12)\n+            )\n+        );\n+    }\n+\n+    private Map<String, List<TaskId>> expectedAssignmentForTwoClients(final List<TaskId> assignedTasksForClient1,", "originalCommit": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "63a179dcd01750933c15b8d53e1a6ab3bfd2dc2b", "url": "https://github.com/apache/kafka/commit/63a179dcd01750933c15b8d53e1a6ab3bfd2dc2b", "message": "Include feedback", "committedDate": "2020-03-17T11:01:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk2ODM2MQ==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393968361", "bodyText": "Why do we need this?", "author": "ableegoldman", "createdAt": "2020-03-17T21:01:57Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/StateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+\n+public interface StateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> {\n+\n+    class ClientIdAndRank<ID extends Comparable<? super ID>> implements Comparable<ClientIdAndRank<ID>> {\n+        private final ID clientId;\n+        private final long rank;\n+\n+        public ClientIdAndRank(final ID clientId, final long rank) {\n+            this.clientId = clientId;\n+            this.rank = rank;\n+        }\n+\n+        public static <ID extends Comparable<? super ID>> ClientIdAndRank<ID> make(final ID clientId, final long rank) {", "originalCommit": "63a179dcd01750933c15b8d53e1a6ab3bfd2dc2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxNjkyMg==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r394216922", "bodyText": "Actually, we do not need it. I just add it because I thought it would make the code more readable, but the improvement was not that big. You can remove it when you copy over this code to the other PR.", "author": "cadonna", "createdAt": "2020-03-18T09:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk2ODM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk3NDAwMw==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393974003", "bodyText": "Do we really need this test and the one above? If they are testing something different, can you think of a way to include that in the name instead of the 1 or 2 suffix?", "author": "ableegoldman", "createdAt": "2020-03-17T21:13:10Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignorTest.java", "diffHunk": "@@ -0,0 +1,643 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+import org.apache.kafka.streams.processor.internals.assignment.StateConstrainedBalancedAssignor.ClientIdAndRank;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import static org.apache.kafka.common.utils.Utils.mkEntry;\n+import static org.apache.kafka.common.utils.Utils.mkMap;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class DefaultStateConstrainedBalancedAssignorTest {\n+\n+    private static final TaskId TASK_01 = new TaskId(0, 1);\n+    private static final TaskId TASK_12 = new TaskId(1, 2);\n+    private static final TaskId TASK_23 = new TaskId(2, 3);\n+    private static final TaskId TASK_34 = new TaskId(3, 4);\n+\n+    private static final String CLIENT_1 = \"client1\";\n+    private static final String CLIENT_2 = \"client2\";\n+    private static final String CLIENT_3 = \"client3\";\n+\n+    private static final Set<String> TWO_CLIENTS = new HashSet<>(Arrays.asList(CLIENT_1, CLIENT_2));\n+    private static final Set<String> THREE_CLIENTS = new HashSet<>(Arrays.asList(CLIENT_1, CLIENT_2, CLIENT_3));\n+\n+    @Test\n+    public void shouldAssignTaskToCaughtUpClient() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = Long.MAX_VALUE;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToPreviouslyHostingClient() {\n+        final long lagOfClient1 = Long.MAX_VALUE;\n+        final long lagOfClient2 = Task.LATEST_OFFSET;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToPreviouslyHostingClientWhenOtherCaughtUpClientExists() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = Task.LATEST_OFFSET;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToCaughtUpClientThatIsFirstInSortOrder() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToMostCaughtUpClient() {\n+        final long lagOfClient1 = 3;\n+        final long lagOfClient2 = 5;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHosts() {\n+        final long lagForTask01OnClient1 = 0;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 0;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1, \n+                lagForTask01OnClient2, \n+                lagForTask12OnClient1, \n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHostsEvenIfNotRequiredByBalanceFactor() {\n+        final long lagForTask01OnClient1 = 0;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 0;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfAll() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask01OnClient3 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final long lagForTask12OnClient3 = 0;\n+        final long lagForTask23OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask23OnClient2 = 0;\n+        final long lagForTask23OnClient3 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            threeStatefulTasksToThreeRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask01OnClient3,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2,\n+                lagForTask12OnClient3,\n+                lagForTask23OnClient1,\n+                lagForTask23OnClient2,\n+                lagForTask23OnClient3\n+            ),\n+            balanceFactor,\n+            THREE_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_23);\n+        final List<TaskId> assignedTasksForClient3 = Collections.singletonList(TASK_12);\n+        assertThat(\n+            assignment,\n+            is(expectedAssignmentForThreeClients(assignedTasksForClient1, assignedTasksForClient2, assignedTasksForClient3))\n+        );\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfBoth1() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 100;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfBoth2() {", "originalCommit": "63a179dcd01750933c15b8d53e1a6ab3bfd2dc2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIyOTYwMw==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r394229603", "bodyText": "The two tests make sure that the move of the task from the previous host is independent from the task. I agree that the 1 and 2 suffix are not the best choice. I renamed them and changed also the previous host client in the second test to also verify the independence from the client. Additionally, I varied a bit the rank of the clients in other tests.", "author": "cadonna", "createdAt": "2020-03-18T10:03:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk3NDAwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk3NTAzNw==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393975037", "bodyText": "prop: shouldAssignOneTaskToPreviousHostAndOtherTaskToLessCaughtUpClientDueToBalanceFactor", "author": "ableegoldman", "createdAt": "2020-03-17T21:15:17Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignorTest.java", "diffHunk": "@@ -0,0 +1,643 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+import org.apache.kafka.streams.processor.internals.assignment.StateConstrainedBalancedAssignor.ClientIdAndRank;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import static org.apache.kafka.common.utils.Utils.mkEntry;\n+import static org.apache.kafka.common.utils.Utils.mkMap;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class DefaultStateConstrainedBalancedAssignorTest {\n+\n+    private static final TaskId TASK_01 = new TaskId(0, 1);\n+    private static final TaskId TASK_12 = new TaskId(1, 2);\n+    private static final TaskId TASK_23 = new TaskId(2, 3);\n+    private static final TaskId TASK_34 = new TaskId(3, 4);\n+\n+    private static final String CLIENT_1 = \"client1\";\n+    private static final String CLIENT_2 = \"client2\";\n+    private static final String CLIENT_3 = \"client3\";\n+\n+    private static final Set<String> TWO_CLIENTS = new HashSet<>(Arrays.asList(CLIENT_1, CLIENT_2));\n+    private static final Set<String> THREE_CLIENTS = new HashSet<>(Arrays.asList(CLIENT_1, CLIENT_2, CLIENT_3));\n+\n+    @Test\n+    public void shouldAssignTaskToCaughtUpClient() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = Long.MAX_VALUE;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToPreviouslyHostingClient() {\n+        final long lagOfClient1 = Long.MAX_VALUE;\n+        final long lagOfClient2 = Task.LATEST_OFFSET;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToPreviouslyHostingClientWhenOtherCaughtUpClientExists() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = Task.LATEST_OFFSET;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToCaughtUpClientThatIsFirstInSortOrder() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToMostCaughtUpClient() {\n+        final long lagOfClient1 = 3;\n+        final long lagOfClient2 = 5;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHosts() {\n+        final long lagForTask01OnClient1 = 0;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 0;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1, \n+                lagForTask01OnClient2, \n+                lagForTask12OnClient1, \n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHostsEvenIfNotRequiredByBalanceFactor() {\n+        final long lagForTask01OnClient1 = 0;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 0;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfAll() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask01OnClient3 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final long lagForTask12OnClient3 = 0;\n+        final long lagForTask23OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask23OnClient2 = 0;\n+        final long lagForTask23OnClient3 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            threeStatefulTasksToThreeRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask01OnClient3,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2,\n+                lagForTask12OnClient3,\n+                lagForTask23OnClient1,\n+                lagForTask23OnClient2,\n+                lagForTask23OnClient3\n+            ),\n+            balanceFactor,\n+            THREE_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_23);\n+        final List<TaskId> assignedTasksForClient3 = Collections.singletonList(TASK_12);\n+        assertThat(\n+            assignment,\n+            is(expectedAssignmentForThreeClients(assignedTasksForClient1, assignedTasksForClient2, assignedTasksForClient3))\n+        );\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfBoth1() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 100;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfBoth2() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 100;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignBothTasksToPreviousHostSinceBalanceFactorSatisfied() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Arrays.asList(TASK_01, TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignOneTaskToPreviousHostAndOtherTaskToMostCaughtUpClient() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 20;\n+        final long lagForTask12OnClient2 = 10;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignOneTaskToPreviousHostAndOtherTaskToNotMostCaughtUpClientDueToBalanceFactor() {", "originalCommit": "63a179dcd01750933c15b8d53e1a6ab3bfd2dc2b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAyOTcxNg==", "url": "https://github.com/apache/kafka/pull/8262#discussion_r394029716", "bodyText": "Nice find!", "author": "ableegoldman", "createdAt": "2020-03-17T23:34:38Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignorTest.java", "diffHunk": "@@ -0,0 +1,643 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+import org.apache.kafka.streams.processor.internals.assignment.StateConstrainedBalancedAssignor.ClientIdAndRank;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import static org.apache.kafka.common.utils.Utils.mkEntry;\n+import static org.apache.kafka.common.utils.Utils.mkMap;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class DefaultStateConstrainedBalancedAssignorTest {\n+\n+    private static final TaskId TASK_01 = new TaskId(0, 1);\n+    private static final TaskId TASK_12 = new TaskId(1, 2);\n+    private static final TaskId TASK_23 = new TaskId(2, 3);\n+    private static final TaskId TASK_34 = new TaskId(3, 4);\n+\n+    private static final String CLIENT_1 = \"client1\";\n+    private static final String CLIENT_2 = \"client2\";\n+    private static final String CLIENT_3 = \"client3\";\n+\n+    private static final Set<String> TWO_CLIENTS = new HashSet<>(Arrays.asList(CLIENT_1, CLIENT_2));\n+    private static final Set<String> THREE_CLIENTS = new HashSet<>(Arrays.asList(CLIENT_1, CLIENT_2, CLIENT_3));\n+\n+    @Test\n+    public void shouldAssignTaskToCaughtUpClient() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = Long.MAX_VALUE;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToPreviouslyHostingClient() {\n+        final long lagOfClient1 = Long.MAX_VALUE;\n+        final long lagOfClient2 = Task.LATEST_OFFSET;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToPreviouslyHostingClientWhenOtherCaughtUpClientExists() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = Task.LATEST_OFFSET;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToCaughtUpClientThatIsFirstInSortOrder() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToMostCaughtUpClient() {\n+        final long lagOfClient1 = 3;\n+        final long lagOfClient2 = 5;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHosts() {\n+        final long lagForTask01OnClient1 = 0;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 0;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1, \n+                lagForTask01OnClient2, \n+                lagForTask12OnClient1, \n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHostsEvenIfNotRequiredByBalanceFactor() {\n+        final long lagForTask01OnClient1 = 0;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 0;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfAll() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask01OnClient3 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final long lagForTask12OnClient3 = 0;\n+        final long lagForTask23OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask23OnClient2 = 0;\n+        final long lagForTask23OnClient3 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            threeStatefulTasksToThreeRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask01OnClient3,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2,\n+                lagForTask12OnClient3,\n+                lagForTask23OnClient1,\n+                lagForTask23OnClient2,\n+                lagForTask23OnClient3\n+            ),\n+            balanceFactor,\n+            THREE_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_23);\n+        final List<TaskId> assignedTasksForClient3 = Collections.singletonList(TASK_12);\n+        assertThat(\n+            assignment,\n+            is(expectedAssignmentForThreeClients(assignedTasksForClient1, assignedTasksForClient2, assignedTasksForClient3))\n+        );\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfBoth1() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 100;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfBoth2() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 100;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignBothTasksToPreviousHostSinceBalanceFactorSatisfied() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Arrays.asList(TASK_01, TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignOneTaskToPreviousHostAndOtherTaskToMostCaughtUpClient() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 20;\n+        final long lagForTask12OnClient2 = 10;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignOneTaskToPreviousHostAndOtherTaskToNotMostCaughtUpClientDueToBalanceFactor() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 10;\n+        final long lagForTask12OnClient2 = 20;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignBothTasksToSameClientSincePreviousHostAndMostCaughtUpAndBalanceFactorSatisfied() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 10;\n+        final long lagForTask12OnClient2 = 20;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Arrays.asList(TASK_01, TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTasksToMostCaughtUpClient() {\n+        final long lagForTask01OnClient1 = 50;\n+        final long lagForTask01OnClient2 = 20;\n+        final long lagForTask12OnClient1 = 20;\n+        final long lagForTask12OnClient2 = 50;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksEvenIfClientsAreNotMostCaughtUpDueToBalanceFactor() {\n+        final long lagForTask01OnClient1 = 20;\n+        final long lagForTask01OnClient2 = 50;\n+        final long lagForTask01OnClient3 = 100;\n+        final long lagForTask12OnClient1 = 20;\n+        final long lagForTask12OnClient2 = 50;\n+        final long lagForTask12OnClient3 = 100;\n+        final long lagForTask23OnClient1 = 20;\n+        final long lagForTask23OnClient2 = 50;\n+        final long lagForTask23OnClient3 = 100;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            threeStatefulTasksToThreeRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask01OnClient3,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2,\n+                lagForTask12OnClient3,\n+                lagForTask23OnClient1,\n+                lagForTask23OnClient2,\n+                lagForTask23OnClient3\n+            ),\n+            balanceFactor,\n+            THREE_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_23);\n+        final List<TaskId> assignedTasksForClient3 = Collections.singletonList(TASK_12);\n+        assertThat(\n+            assignment,\n+            is(expectedAssignmentForThreeClients(assignedTasksForClient1, assignedTasksForClient2, assignedTasksForClient3))\n+        );\n+    }\n+\n+    @Test\n+    public void shouldAssignBothTasksToSameMostCaughtUpClientSinceBalanceFactorSatisfied() {\n+        final long lagForTask01OnClient1 = 40;\n+        final long lagForTask01OnClient2 = 30;\n+        final long lagForTask12OnClient1 = 20;\n+        final long lagForTask12OnClient2 = 10;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Arrays.asList(TASK_01, TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksOverClientsWithEqualRank() {\n+        final long lagForTask01OnClient1 = 40;\n+        final long lagForTask01OnClient2 = 40;\n+        final long lagForTask12OnClient1 = 40;\n+        final long lagForTask12OnClient2 = 40;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    /**\n+     * This test shows that in an assigment of one client the assumption that the set of tasks which are caught-up on\n+     * the given client is followed by the set of tasks that are not caught-up on the given client does NOT hold.\n+     * In fact, in this test, at some point during the execution of the algorithm the assignment for CLIENT_2\n+     * contains TASK_34 followed by TASK_23. TASK_23 is caught-up on CLIENT_2 whereas TASK_34 is not.", "originalCommit": "63a179dcd01750933c15b8d53e1a6ab3bfd2dc2b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0ddf61034b88b75011f27ac35ef00a56d927384b", "url": "https://github.com/apache/kafka/commit/0ddf61034b88b75011f27ac35ef00a56d927384b", "message": "Improve tests", "committedDate": "2020-03-18T10:48:50Z", "type": "commit"}, {"oid": "b35b0ab0e58743b8629fbfaf3db7b07a812bfa23", "url": "https://github.com/apache/kafka/commit/b35b0ab0e58743b8629fbfaf3db7b07a812bfa23", "message": "Make algorithm stream thread aware", "committedDate": "2020-03-19T22:24:27Z", "type": "commit"}]}