{"pr_number": 9396, "pr_title": "KAFKA-10437: Implement new PAPI support for test-utils", "pr_createdAt": "2020-10-08T17:29:10Z", "pr_url": "https://github.com/apache/kafka/pull/9396", "timeline": [{"oid": "ca564b22c2d751c2bdfcd31910d2621fc50a25cc", "url": "https://github.com/apache/kafka/commit/ca564b22c2d751c2bdfcd31910d2621fc50a25cc", "message": "KAFKA-10437: Implement new PAPI support for test-utils", "committedDate": "2020-10-08T17:11:48Z", "type": "commit"}, {"oid": "428c6f32f056fd791f8d676a5febc7f5f8de654f", "url": "https://github.com/apache/kafka/commit/428c6f32f056fd791f8d676a5febc7f5f8de654f", "message": "drop unused import", "committedDate": "2020-10-08T17:55:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkwNDA1NA==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r501904054", "bodyText": "added for quality-of-life debugging", "author": "vvcephei", "createdAt": "2020-10-08T17:50:02Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/api/Record.java", "diffHunk": "@@ -162,4 +164,30 @@ public Headers headers() {\n     public Record<K, V> withHeaders(final Headers headers) {\n         return new Record<>(key, value, timestamp, headers);\n     }\n+\n+    @Override\n+    public String toString() {", "originalCommit": "ca564b22c2d751c2bdfcd31910d2621fc50a25cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkwNDIxNQ==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r501904215", "bodyText": "added for easier assertions in unit tests", "author": "vvcephei", "createdAt": "2020-10-08T17:50:16Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/api/Record.java", "diffHunk": "@@ -162,4 +164,30 @@ public Headers headers() {\n     public Record<K, V> withHeaders(final Headers headers) {\n         return new Record<>(key, value, timestamp, headers);\n     }\n+\n+    @Override\n+    public String toString() {\n+        return \"Record{\" +\n+            \"key=\" + key +\n+            \", value=\" + value +\n+            \", timestamp=\" + timestamp +\n+            \", headers=\" + headers +\n+            '}';\n+    }\n+\n+    @Override\n+    public boolean equals(final Object o) {", "originalCommit": "ca564b22c2d751c2bdfcd31910d2621fc50a25cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkwNTM2Ng==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r501905366", "bodyText": "As a testament to MockProcessorContextStateStoreTest, it actually found this bug. I had overlooked this usage while making the other root stores context-implementation agnostic in the last PR.", "author": "vvcephei", "createdAt": "2020-10-08T17:51:57Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/InMemorySessionStore.java", "diffHunk": "@@ -75,18 +75,25 @@ public String name() {\n     @Deprecated\n     @Override\n     public void init(final ProcessorContext context, final StateStore root) {\n-        this.context = (InternalProcessorContext) context;\n-\n-        final StreamsMetricsImpl metrics = this.context.metrics();\n         final String threadId = Thread.currentThread().getName();\n         final String taskName = context.taskId().toString();\n-        expiredRecordSensor = TaskMetrics.droppedRecordsSensorOrExpiredWindowRecordDropSensor(\n-            threadId,\n-            taskName,\n-            metricScope,\n-            name,\n-            metrics\n-        );\n+\n+        // The provided context is not required to implement InternalProcessorContext,\n+        // If it doesn't, we can't record this metric.\n+        if (context instanceof InternalProcessorContext) {", "originalCommit": "ca564b22c2d751c2bdfcd31910d2621fc50a25cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkwOTI0Nw==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r501909247", "bodyText": "This is a clone of the processor.MockProcessorContext, but implementing the new api.ProcessorContext interface.\nThe two context interfaces don't technically collide, but creating a standalone implementation allows us to provide type safety in the CapturedForward inner class without any backward compatibility concerns.\nIt also (IMO) makes it easier for users to make a clean switch to the new API by removing any ambiguity about whether a test is making use of the old API or the new API, or some mixture of both.", "author": "vvcephei", "createdAt": "2020-10-08T17:57:54Z", "path": "streams/test-utils/src/main/java/org/apache/kafka/streams/processor/api/MockProcessorContext.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.api;\n+\n+import org.apache.kafka.common.metrics.MetricConfig;\n+import org.apache.kafka.common.metrics.Metrics;\n+import org.apache.kafka.common.metrics.Sensor;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.utils.Time;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.StreamsMetrics;\n+import org.apache.kafka.streams.Topology;\n+import org.apache.kafka.streams.TopologyTestDriver;\n+import org.apache.kafka.streams.kstream.Transformer;\n+import org.apache.kafka.streams.kstream.ValueTransformer;\n+import org.apache.kafka.streams.processor.Cancellable;\n+import org.apache.kafka.streams.processor.PunctuationType;\n+import org.apache.kafka.streams.processor.Punctuator;\n+import org.apache.kafka.streams.processor.StateRestoreCallback;\n+import org.apache.kafka.streams.processor.StateStore;\n+import org.apache.kafka.streams.processor.StateStoreContext;\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.ClientUtils;\n+import org.apache.kafka.streams.processor.internals.RecordCollector;\n+import org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl;\n+import org.apache.kafka.streams.processor.internals.metrics.TaskMetrics;\n+import org.apache.kafka.streams.state.internals.InMemoryKeyValueStore;\n+\n+import java.io.File;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Properties;\n+\n+import static org.apache.kafka.common.utils.Utils.mkEntry;\n+import static org.apache.kafka.common.utils.Utils.mkMap;\n+import static org.apache.kafka.common.utils.Utils.mkProperties;\n+\n+/**\n+ * {@link MockProcessorContext} is a mock of {@link ProcessorContext} for users to test their {@link Processor},\n+ * {@link Transformer}, and {@link ValueTransformer} implementations.\n+ * <p>\n+ * The tests for this class (org.apache.kafka.streams.MockProcessorContextTest) include several behavioral\n+ * tests that serve as example usage.\n+ * <p>\n+ * Note that this class does not take any automated actions (such as firing scheduled punctuators).\n+ * It simply captures any data it witnesses.\n+ * If you require more automated tests, we recommend wrapping your {@link Processor} in a minimal source-processor-sink\n+ * {@link Topology} and using the {@link TopologyTestDriver}.\n+ */\n+public class MockProcessorContext<KForward, VForward> implements ProcessorContext<KForward, VForward>, RecordCollector.Supplier {", "originalCommit": "428c6f32f056fd791f8d676a5febc7f5f8de654f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA2NzEyNA==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r502067124", "bodyText": "Since we are adding a new class, could we have it extend InternalProcessorContext then, so that when we remove the old ones we can also cleanup the non-testing functions that branch on checking instanceof InternalProcessorContext: I'm assuming that InternalProcessorContext would stay in the end state, it would just extend api.ProcessorContext<Object, Object> and not StateStoreContext in the future.", "author": "guozhangwang", "createdAt": "2020-10-08T23:11:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkwOTI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjczNzA2Nw==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r502737067", "bodyText": "Unfortunately, that would actually expose InternalProcessorContext itself as a public interface (any supertype of a public type is a public type).", "author": "vvcephei", "createdAt": "2020-10-10T02:54:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkwOTI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3NDczNg==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r503574736", "bodyText": "InternalProcessorContext is already public interface but it's in internals package, so I figured it is okay?\nAnyways, this is not much blocking this PR, so feel free to merge it anyways and we can keep discussing here while you merge.", "author": "guozhangwang", "createdAt": "2020-10-12T22:56:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkwOTI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3MzExMA==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r504073110", "bodyText": "Thanks. I'll go ahead with the merge, then.\nIt seems like InternalProcessorContext is only \"public\" in the sense that Java 8 is insufficiently expressive to make it private. I guess I should say \"internal\" and \"external\". But it is certainly an internal type, therefore, we should not ever return it to the users when they call external APIs (such as the constructor of this class).\nOnce we upgrade to java 9, we should add module definitions so that we stop exporting internal types in the public API completely. As I understand things, it would actually become a compiler error at that point for us to provide an external class that inherits from an internal interface.\nI guess I don't see this as a big concern anyway. The way I implemented the state stores in the last PR makes them capable of accepting any implementation of ProcessorContext or StateStoreContext, although they'll disable some features if the context isn't an instance of InternalProcessorContext. To me, this seems like a fine situation. We could also note that there is https://cwiki.apache.org/confluence/display/KAFKA/KIP-622%3A+Add+currentSystemTimeMs+and+currentStreamTimeMs+to+ProcessorContext, which would remove the need for casting to InternalProcessorContext to begin with.", "author": "vvcephei", "createdAt": "2020-10-13T16:01:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkwOTI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxMTE1Nw==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r501911157", "bodyText": "stateDir isn't a required argument, but having a null value for it and then trying to use a rocksdb store leads to a very cryptic error like, \"you have to open all column families\". Placing a null-check right here allows us to fail fast and prints an explanatory message any time you use the context with a component that actually needs the stateDir.\nThis was also a problem with the prior implementation, but I didn't notice it until I implemented MockProcessorContextStateStoreTest.", "author": "vvcephei", "createdAt": "2020-10-08T18:00:52Z", "path": "streams/test-utils/src/main/java/org/apache/kafka/streams/processor/api/MockProcessorContext.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.api;\n+\n+import org.apache.kafka.common.metrics.MetricConfig;\n+import org.apache.kafka.common.metrics.Metrics;\n+import org.apache.kafka.common.metrics.Sensor;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.utils.Time;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.StreamsMetrics;\n+import org.apache.kafka.streams.Topology;\n+import org.apache.kafka.streams.TopologyTestDriver;\n+import org.apache.kafka.streams.kstream.Transformer;\n+import org.apache.kafka.streams.kstream.ValueTransformer;\n+import org.apache.kafka.streams.processor.Cancellable;\n+import org.apache.kafka.streams.processor.PunctuationType;\n+import org.apache.kafka.streams.processor.Punctuator;\n+import org.apache.kafka.streams.processor.StateRestoreCallback;\n+import org.apache.kafka.streams.processor.StateStore;\n+import org.apache.kafka.streams.processor.StateStoreContext;\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.ClientUtils;\n+import org.apache.kafka.streams.processor.internals.RecordCollector;\n+import org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl;\n+import org.apache.kafka.streams.processor.internals.metrics.TaskMetrics;\n+import org.apache.kafka.streams.state.internals.InMemoryKeyValueStore;\n+\n+import java.io.File;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Properties;\n+\n+import static org.apache.kafka.common.utils.Utils.mkEntry;\n+import static org.apache.kafka.common.utils.Utils.mkMap;\n+import static org.apache.kafka.common.utils.Utils.mkProperties;\n+\n+/**\n+ * {@link MockProcessorContext} is a mock of {@link ProcessorContext} for users to test their {@link Processor},\n+ * {@link Transformer}, and {@link ValueTransformer} implementations.\n+ * <p>\n+ * The tests for this class (org.apache.kafka.streams.MockProcessorContextTest) include several behavioral\n+ * tests that serve as example usage.\n+ * <p>\n+ * Note that this class does not take any automated actions (such as firing scheduled punctuators).\n+ * It simply captures any data it witnesses.\n+ * If you require more automated tests, we recommend wrapping your {@link Processor} in a minimal source-processor-sink\n+ * {@link Topology} and using the {@link TopologyTestDriver}.\n+ */\n+public class MockProcessorContext<KForward, VForward> implements ProcessorContext<KForward, VForward>, RecordCollector.Supplier {\n+    // Immutable fields ================================================\n+    private final StreamsMetricsImpl metrics;\n+    private final TaskId taskId;\n+    private final StreamsConfig config;\n+    private final File stateDir;\n+\n+    // settable record metadata ================================================\n+    private MockRecordMetadata recordMetadata;\n+\n+    // mocks ================================================\n+    private final Map<String, StateStore> stateStores = new HashMap<>();\n+    private final List<CapturedPunctuator> punctuators = new LinkedList<>();\n+    private final List<CapturedForward<? extends KForward, ? extends VForward>> capturedForwards = new LinkedList<>();\n+    private boolean committed = false;\n+\n+    private static final class MockRecordMetadata implements RecordMetadata {\n+        private final String topic;\n+        private final int partition;\n+        private final long offset;\n+\n+        private MockRecordMetadata(final String topic, final int partition, final long offset) {\n+            this.topic = topic;\n+            this.partition = partition;\n+            this.offset = offset;\n+        }\n+\n+        @Override\n+        public String topic() {\n+            return topic;\n+        }\n+\n+        @Override\n+        public int partition() {\n+            return partition;\n+        }\n+\n+        @Override\n+        public long offset() {\n+            return offset;\n+        }\n+    }\n+\n+    /**\n+     * {@link CapturedPunctuator} holds captured punctuators, along with their scheduling information.\n+     */\n+    public static final class CapturedPunctuator {\n+        private final Duration interval;\n+        private final PunctuationType type;\n+        private final Punctuator punctuator;\n+        private boolean cancelled = false;\n+\n+        private CapturedPunctuator(final Duration interval, final PunctuationType type, final Punctuator punctuator) {\n+            this.interval = interval;\n+            this.type = type;\n+            this.punctuator = punctuator;\n+        }\n+\n+        public Duration getInterval() {\n+            return interval;\n+        }\n+\n+        public PunctuationType getType() {\n+            return type;\n+        }\n+\n+        public Punctuator getPunctuator() {\n+            return punctuator;\n+        }\n+\n+        public void cancel() {\n+            cancelled = true;\n+        }\n+\n+        public boolean cancelled() {\n+            return cancelled;\n+        }\n+    }\n+\n+    public static final class CapturedForward<K, V> {\n+\n+        private final Record<K, V> record;\n+        private final Optional<String> childName;\n+\n+        public CapturedForward(final Record<K, V> record) {\n+            this(record, Optional.empty());\n+        }\n+\n+        public CapturedForward(final Record<K, V> record, final Optional<String> childName) {\n+            this.record = Objects.requireNonNull(record);\n+            this.childName = Objects.requireNonNull(childName);\n+        }\n+\n+        /**\n+         * The child this data was forwarded to.\n+         *\n+         * @return If present, the child name the record was forwarded to.\n+         *         If empty, the forward was a broadcast.\n+         */\n+        public Optional<String> childName() {\n+            return childName;\n+        }\n+\n+        /**\n+         * The record that was forwarded.\n+         *\n+         * @return The forwarded record. Not null.\n+         */\n+        public Record<K, V> record() {\n+            return record;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"CapturedForward{\" +\n+                \"record=\" + record +\n+                \", childName=\" + childName +\n+                '}';\n+        }\n+\n+        @Override\n+        public boolean equals(final Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            final CapturedForward<?, ?> that = (CapturedForward<?, ?>) o;\n+            return Objects.equals(record, that.record) &&\n+                Objects.equals(childName, that.childName);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(record, childName);\n+        }\n+    }\n+\n+    // constructors ================================================\n+\n+    /**\n+     * Create a {@link MockProcessorContext} with dummy {@code config} and {@code taskId} and {@code null} {@code stateDir}.\n+     * Most unit tests using this mock won't need to know the taskId,\n+     * and most unit tests should be able to get by with the\n+     * {@link InMemoryKeyValueStore}, so the stateDir won't matter.\n+     */\n+    public MockProcessorContext() {\n+        this(\n+            mkProperties(mkMap(\n+                mkEntry(StreamsConfig.APPLICATION_ID_CONFIG, \"\"),\n+                mkEntry(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"\")\n+            )),\n+            new TaskId(0, 0),\n+            null\n+        );\n+    }\n+\n+    /**\n+     * Create a {@link MockProcessorContext} with dummy {@code taskId} and {@code null} {@code stateDir}.\n+     * Most unit tests using this mock won't need to know the taskId,\n+     * and most unit tests should be able to get by with the\n+     * {@link InMemoryKeyValueStore}, so the stateDir won't matter.\n+     *\n+     * @param config a Properties object, used to configure the context and the processor.\n+     */\n+    public MockProcessorContext(final Properties config) {\n+        this(config, new TaskId(0, 0), null);\n+    }\n+\n+    /**\n+     * Create a {@link MockProcessorContext} with a specified taskId and null stateDir.\n+     *\n+     * @param config   a {@link Properties} object, used to configure the context and the processor.\n+     * @param taskId   a {@link TaskId}, which the context makes available via {@link MockProcessorContext#taskId()}.\n+     * @param stateDir a {@link File}, which the context makes available viw {@link MockProcessorContext#stateDir()}.\n+     */\n+    public MockProcessorContext(final Properties config, final TaskId taskId, final File stateDir) {\n+        final StreamsConfig streamsConfig = new ClientUtils.QuietStreamsConfig(config);\n+        this.taskId = taskId;\n+        this.config = streamsConfig;\n+        this.stateDir = stateDir;\n+        final MetricConfig metricConfig = new MetricConfig();\n+        metricConfig.recordLevel(Sensor.RecordingLevel.DEBUG);\n+        final String threadId = Thread.currentThread().getName();\n+        metrics = new StreamsMetricsImpl(\n+            new Metrics(metricConfig),\n+            threadId,\n+            streamsConfig.getString(StreamsConfig.BUILT_IN_METRICS_VERSION_CONFIG),\n+            Time.SYSTEM\n+        );\n+        TaskMetrics.droppedRecordsSensorOrSkippedRecordsSensor(threadId, taskId.toString(), metrics);\n+    }\n+\n+    @Override\n+    public String applicationId() {\n+        return config.getString(StreamsConfig.APPLICATION_ID_CONFIG);\n+    }\n+\n+    @Override\n+    public TaskId taskId() {\n+        return taskId;\n+    }\n+\n+    @Override\n+    public Map<String, Object> appConfigs() {\n+        final Map<String, Object> combined = new HashMap<>();\n+        combined.putAll(config.originals());\n+        combined.putAll(config.values());\n+        return combined;\n+    }\n+\n+    @Override\n+    public Map<String, Object> appConfigsWithPrefix(final String prefix) {\n+        return config.originalsWithPrefix(prefix);\n+    }\n+\n+    @Override\n+    public Serde<?> keySerde() {\n+        return config.defaultKeySerde();\n+    }\n+\n+    @Override\n+    public Serde<?> valueSerde() {\n+        return config.defaultValueSerde();\n+    }\n+\n+    @Override\n+    public File stateDir() {\n+        return Objects.requireNonNull(\n+            stateDir,\n+            \"The stateDir constructor argument was needed (probably for a state store) but not supplied. \" +\n+                \"You can either reconfigure your test so that it doesn't need access to the disk \" +\n+                \"(such as using an in-memory store), or use the full MockProcessorContext constructor to supply \" +\n+                \"a non-null stateDir argument.\"\n+        );", "originalCommit": "428c6f32f056fd791f8d676a5febc7f5f8de654f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxMzE1MA==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r501913150", "bodyText": "Rather than have the MockProcessorContext implement StateStoreContext as well, I think it's a good idea to explicitly get a StateStoreContext view of the same object. This will help users to have a clearer understanding of which context is which.", "author": "vvcephei", "createdAt": "2020-10-08T18:04:01Z", "path": "streams/test-utils/src/main/java/org/apache/kafka/streams/processor/api/MockProcessorContext.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.api;\n+\n+import org.apache.kafka.common.metrics.MetricConfig;\n+import org.apache.kafka.common.metrics.Metrics;\n+import org.apache.kafka.common.metrics.Sensor;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.utils.Time;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.StreamsMetrics;\n+import org.apache.kafka.streams.Topology;\n+import org.apache.kafka.streams.TopologyTestDriver;\n+import org.apache.kafka.streams.kstream.Transformer;\n+import org.apache.kafka.streams.kstream.ValueTransformer;\n+import org.apache.kafka.streams.processor.Cancellable;\n+import org.apache.kafka.streams.processor.PunctuationType;\n+import org.apache.kafka.streams.processor.Punctuator;\n+import org.apache.kafka.streams.processor.StateRestoreCallback;\n+import org.apache.kafka.streams.processor.StateStore;\n+import org.apache.kafka.streams.processor.StateStoreContext;\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.ClientUtils;\n+import org.apache.kafka.streams.processor.internals.RecordCollector;\n+import org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl;\n+import org.apache.kafka.streams.processor.internals.metrics.TaskMetrics;\n+import org.apache.kafka.streams.state.internals.InMemoryKeyValueStore;\n+\n+import java.io.File;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Properties;\n+\n+import static org.apache.kafka.common.utils.Utils.mkEntry;\n+import static org.apache.kafka.common.utils.Utils.mkMap;\n+import static org.apache.kafka.common.utils.Utils.mkProperties;\n+\n+/**\n+ * {@link MockProcessorContext} is a mock of {@link ProcessorContext} for users to test their {@link Processor},\n+ * {@link Transformer}, and {@link ValueTransformer} implementations.\n+ * <p>\n+ * The tests for this class (org.apache.kafka.streams.MockProcessorContextTest) include several behavioral\n+ * tests that serve as example usage.\n+ * <p>\n+ * Note that this class does not take any automated actions (such as firing scheduled punctuators).\n+ * It simply captures any data it witnesses.\n+ * If you require more automated tests, we recommend wrapping your {@link Processor} in a minimal source-processor-sink\n+ * {@link Topology} and using the {@link TopologyTestDriver}.\n+ */\n+public class MockProcessorContext<KForward, VForward> implements ProcessorContext<KForward, VForward>, RecordCollector.Supplier {\n+    // Immutable fields ================================================\n+    private final StreamsMetricsImpl metrics;\n+    private final TaskId taskId;\n+    private final StreamsConfig config;\n+    private final File stateDir;\n+\n+    // settable record metadata ================================================\n+    private MockRecordMetadata recordMetadata;\n+\n+    // mocks ================================================\n+    private final Map<String, StateStore> stateStores = new HashMap<>();\n+    private final List<CapturedPunctuator> punctuators = new LinkedList<>();\n+    private final List<CapturedForward<? extends KForward, ? extends VForward>> capturedForwards = new LinkedList<>();\n+    private boolean committed = false;\n+\n+    private static final class MockRecordMetadata implements RecordMetadata {\n+        private final String topic;\n+        private final int partition;\n+        private final long offset;\n+\n+        private MockRecordMetadata(final String topic, final int partition, final long offset) {\n+            this.topic = topic;\n+            this.partition = partition;\n+            this.offset = offset;\n+        }\n+\n+        @Override\n+        public String topic() {\n+            return topic;\n+        }\n+\n+        @Override\n+        public int partition() {\n+            return partition;\n+        }\n+\n+        @Override\n+        public long offset() {\n+            return offset;\n+        }\n+    }\n+\n+    /**\n+     * {@link CapturedPunctuator} holds captured punctuators, along with their scheduling information.\n+     */\n+    public static final class CapturedPunctuator {\n+        private final Duration interval;\n+        private final PunctuationType type;\n+        private final Punctuator punctuator;\n+        private boolean cancelled = false;\n+\n+        private CapturedPunctuator(final Duration interval, final PunctuationType type, final Punctuator punctuator) {\n+            this.interval = interval;\n+            this.type = type;\n+            this.punctuator = punctuator;\n+        }\n+\n+        public Duration getInterval() {\n+            return interval;\n+        }\n+\n+        public PunctuationType getType() {\n+            return type;\n+        }\n+\n+        public Punctuator getPunctuator() {\n+            return punctuator;\n+        }\n+\n+        public void cancel() {\n+            cancelled = true;\n+        }\n+\n+        public boolean cancelled() {\n+            return cancelled;\n+        }\n+    }\n+\n+    public static final class CapturedForward<K, V> {\n+\n+        private final Record<K, V> record;\n+        private final Optional<String> childName;\n+\n+        public CapturedForward(final Record<K, V> record) {\n+            this(record, Optional.empty());\n+        }\n+\n+        public CapturedForward(final Record<K, V> record, final Optional<String> childName) {\n+            this.record = Objects.requireNonNull(record);\n+            this.childName = Objects.requireNonNull(childName);\n+        }\n+\n+        /**\n+         * The child this data was forwarded to.\n+         *\n+         * @return If present, the child name the record was forwarded to.\n+         *         If empty, the forward was a broadcast.\n+         */\n+        public Optional<String> childName() {\n+            return childName;\n+        }\n+\n+        /**\n+         * The record that was forwarded.\n+         *\n+         * @return The forwarded record. Not null.\n+         */\n+        public Record<K, V> record() {\n+            return record;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"CapturedForward{\" +\n+                \"record=\" + record +\n+                \", childName=\" + childName +\n+                '}';\n+        }\n+\n+        @Override\n+        public boolean equals(final Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            final CapturedForward<?, ?> that = (CapturedForward<?, ?>) o;\n+            return Objects.equals(record, that.record) &&\n+                Objects.equals(childName, that.childName);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(record, childName);\n+        }\n+    }\n+\n+    // constructors ================================================\n+\n+    /**\n+     * Create a {@link MockProcessorContext} with dummy {@code config} and {@code taskId} and {@code null} {@code stateDir}.\n+     * Most unit tests using this mock won't need to know the taskId,\n+     * and most unit tests should be able to get by with the\n+     * {@link InMemoryKeyValueStore}, so the stateDir won't matter.\n+     */\n+    public MockProcessorContext() {\n+        this(\n+            mkProperties(mkMap(\n+                mkEntry(StreamsConfig.APPLICATION_ID_CONFIG, \"\"),\n+                mkEntry(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"\")\n+            )),\n+            new TaskId(0, 0),\n+            null\n+        );\n+    }\n+\n+    /**\n+     * Create a {@link MockProcessorContext} with dummy {@code taskId} and {@code null} {@code stateDir}.\n+     * Most unit tests using this mock won't need to know the taskId,\n+     * and most unit tests should be able to get by with the\n+     * {@link InMemoryKeyValueStore}, so the stateDir won't matter.\n+     *\n+     * @param config a Properties object, used to configure the context and the processor.\n+     */\n+    public MockProcessorContext(final Properties config) {\n+        this(config, new TaskId(0, 0), null);\n+    }\n+\n+    /**\n+     * Create a {@link MockProcessorContext} with a specified taskId and null stateDir.\n+     *\n+     * @param config   a {@link Properties} object, used to configure the context and the processor.\n+     * @param taskId   a {@link TaskId}, which the context makes available via {@link MockProcessorContext#taskId()}.\n+     * @param stateDir a {@link File}, which the context makes available viw {@link MockProcessorContext#stateDir()}.\n+     */\n+    public MockProcessorContext(final Properties config, final TaskId taskId, final File stateDir) {\n+        final StreamsConfig streamsConfig = new ClientUtils.QuietStreamsConfig(config);\n+        this.taskId = taskId;\n+        this.config = streamsConfig;\n+        this.stateDir = stateDir;\n+        final MetricConfig metricConfig = new MetricConfig();\n+        metricConfig.recordLevel(Sensor.RecordingLevel.DEBUG);\n+        final String threadId = Thread.currentThread().getName();\n+        metrics = new StreamsMetricsImpl(\n+            new Metrics(metricConfig),\n+            threadId,\n+            streamsConfig.getString(StreamsConfig.BUILT_IN_METRICS_VERSION_CONFIG),\n+            Time.SYSTEM\n+        );\n+        TaskMetrics.droppedRecordsSensorOrSkippedRecordsSensor(threadId, taskId.toString(), metrics);\n+    }\n+\n+    @Override\n+    public String applicationId() {\n+        return config.getString(StreamsConfig.APPLICATION_ID_CONFIG);\n+    }\n+\n+    @Override\n+    public TaskId taskId() {\n+        return taskId;\n+    }\n+\n+    @Override\n+    public Map<String, Object> appConfigs() {\n+        final Map<String, Object> combined = new HashMap<>();\n+        combined.putAll(config.originals());\n+        combined.putAll(config.values());\n+        return combined;\n+    }\n+\n+    @Override\n+    public Map<String, Object> appConfigsWithPrefix(final String prefix) {\n+        return config.originalsWithPrefix(prefix);\n+    }\n+\n+    @Override\n+    public Serde<?> keySerde() {\n+        return config.defaultKeySerde();\n+    }\n+\n+    @Override\n+    public Serde<?> valueSerde() {\n+        return config.defaultValueSerde();\n+    }\n+\n+    @Override\n+    public File stateDir() {\n+        return Objects.requireNonNull(\n+            stateDir,\n+            \"The stateDir constructor argument was needed (probably for a state store) but not supplied. \" +\n+                \"You can either reconfigure your test so that it doesn't need access to the disk \" +\n+                \"(such as using an in-memory store), or use the full MockProcessorContext constructor to supply \" +\n+                \"a non-null stateDir argument.\"\n+        );\n+    }\n+\n+    @Override\n+    public StreamsMetrics metrics() {\n+        return metrics;\n+    }\n+\n+    // settable record metadata ================================================\n+\n+    /**\n+     * The context exposes these metadata for use in the processor. Normally, they are set by the Kafka Streams framework,\n+     * but for the purpose of driving unit tests, you can set them directly.\n+     *\n+     * @param topic     A topic name\n+     * @param partition A partition number\n+     * @param offset    A record offset\n+     */\n+    public void setRecordMetadata(final String topic,\n+                                  final int partition,\n+                                  final long offset) {\n+        recordMetadata = new MockRecordMetadata(topic, partition, offset);\n+    }\n+\n+    @Override\n+    public Optional<RecordMetadata> recordMetadata() {\n+        return Optional.ofNullable(recordMetadata);\n+    }\n+\n+    // mocks ================================================\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <S extends StateStore> S getStateStore(final String name) {\n+        return (S) stateStores.get(name);\n+    }\n+\n+    public <S extends StateStore> void addStateStore(final S stateStore) {\n+        stateStores.put(stateStore.name(), stateStore);\n+    }\n+\n+    @Override\n+    public Cancellable schedule(final Duration interval,\n+                                final PunctuationType type,\n+                                final Punctuator callback) {\n+        final CapturedPunctuator capturedPunctuator = new CapturedPunctuator(interval, type, callback);\n+\n+        punctuators.add(capturedPunctuator);\n+\n+        return capturedPunctuator::cancel;\n+    }\n+\n+    /**\n+     * Get the punctuators scheduled so far. The returned list is not affected by subsequent calls to {@code schedule(...)}.\n+     *\n+     * @return A list of captured punctuators.\n+     */\n+    public List<CapturedPunctuator> scheduledPunctuators() {\n+        return new LinkedList<>(punctuators);\n+    }\n+\n+    @Override\n+    public <K extends KForward, V extends VForward> void forward(final Record<K, V> record) {\n+        forward(record, null);\n+    }\n+\n+    @Override\n+    public <K extends KForward, V extends VForward> void forward(final Record<K, V> record, final String childName) {\n+        capturedForwards.add(new CapturedForward<>(record, Optional.ofNullable(childName)));\n+    }\n+\n+    /**\n+     * Get all the forwarded data this context has observed. The returned list will not be\n+     * affected by subsequent interactions with the context. The data in the list is in the same order as the calls to\n+     * {@code forward(...)}.\n+     *\n+     * @return A list of records that were previously passed to the context.\n+     */\n+    public List<CapturedForward<? extends KForward, ? extends VForward>> forwarded() {\n+        return new LinkedList<>(capturedForwards);\n+    }\n+\n+    /**\n+     * Get all the forwarded data this context has observed for a specific child by name.\n+     * The returned list will not be affected by subsequent interactions with the context.\n+     * The data in the list is in the same order as the calls to {@code forward(...)}.\n+     *\n+     * @param childName The child name to retrieve forwards for\n+     * @return A list of records that were previously passed to the context.\n+     */\n+    public List<CapturedForward<? extends KForward, ? extends VForward>> forwarded(final String childName) {\n+        final LinkedList<CapturedForward<? extends KForward, ? extends VForward>> result = new LinkedList<>();\n+        for (final CapturedForward<? extends KForward, ? extends VForward> capture : capturedForwards) {\n+            if (!capture.childName().isPresent() || capture.childName().equals(Optional.of(childName))) {\n+                result.add(capture);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Clear the captured forwarded data.\n+     */\n+    public void resetForwards() {\n+        capturedForwards.clear();\n+    }\n+\n+    @Override\n+    public void commit() {\n+        committed = true;\n+    }\n+\n+    /**\n+     * Whether {@link ProcessorContext#commit()} has been called in this context.\n+     *\n+     * @return {@code true} iff {@link ProcessorContext#commit()} has been called in this context since construction or reset.\n+     */\n+    public boolean committed() {\n+        return committed;\n+    }\n+\n+    /**\n+     * Reset the commit capture to {@code false} (whether or not it was previously {@code true}).\n+     */\n+    public void resetCommit() {\n+        committed = false;\n+    }\n+\n+    @Override\n+    public RecordCollector recordCollector() {\n+        // This interface is assumed by state stores that add change-logging.\n+        // Rather than risk a mysterious ClassCastException during unit tests, throw an explanatory exception.\n+\n+        throw new UnsupportedOperationException(\n+            \"MockProcessorContext does not provide record collection. \" +\n+                \"For processor unit tests, use an in-memory state store with change-logging disabled. \" +\n+                \"Alternatively, use the TopologyTestDriver for testing processor/store/topology integration.\"\n+        );\n+    }\n+\n+    /**\n+     * Used to get a {@link StateStoreContext} for use with\n+     * {@link StateStore#init(StateStoreContext, StateStore)}\n+     * if you need to initialize a store for your tests.\n+     * @return a {@link StateStoreContext} that delegates to this ProcessorContext.\n+     */\n+    public StateStoreContext getStateStoreContext() {", "originalCommit": "428c6f32f056fd791f8d676a5febc7f5f8de654f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA3NTA2NA==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r502075064", "bodyText": "I agree. I think in the long run MockProcessorContext could extend InternalProcessorContext, which only extends api.ProcessorContext. When that's the case we should be able to remove the non-testing code's safeguards.", "author": "guozhangwang", "createdAt": "2020-10-08T23:25:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxMzE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxMzQ1MA==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r501913450", "bodyText": "This is the pre-existing test of the old-API ProcessorContext.", "author": "vvcephei", "createdAt": "2020-10-08T18:04:29Z", "path": "streams/test-utils/src/test/java/org/apache/kafka/streams/MockProcessorContextTest.java", "diffHunk": "@@ -43,6 +43,7 @@\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n+@SuppressWarnings(\"deprecation\") // this is a test of a deprecated API", "originalCommit": "428c6f32f056fd791f8d676a5febc7f5f8de654f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxNDAyOQ==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r501914029", "bodyText": "Don't need to suppress deprecation anymore, since it's moved to the class level, and don't need unchecked anymore thanks to the return-type change of getStateStore.", "author": "vvcephei", "createdAt": "2020-10-08T18:05:24Z", "path": "streams/test-utils/src/test/java/org/apache/kafka/streams/MockProcessorContextTest.java", "diffHunk": "@@ -231,14 +230,13 @@ public void process(final String key, final Long value) {\n \n         assertFalse(context.committed());\n     }\n-    @SuppressWarnings({\"deprecation\", \"unchecked\"}) // TODO deprecation will be fixed in KAFKA-10437", "originalCommit": "428c6f32f056fd791f8d676a5febc7f5f8de654f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxNDM0NA==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r501914344", "bodyText": "My prior comment was wrong. We do want to test the deprecated init method as well as the non-deprecated one.", "author": "vvcephei", "createdAt": "2020-10-08T18:05:52Z", "path": "streams/test-utils/src/test/java/org/apache/kafka/streams/internals/KeyValueStoreFacadeTest.java", "diffHunk": "@@ -53,9 +54,9 @@ public void setup() {\n         keyValueStoreFacade = new KeyValueStoreFacade<>(mockedKeyValueTimestampStore);\n     }\n \n-    @SuppressWarnings(\"deprecation\") // TODO will be fixed in KAFKA-10437\n+    @SuppressWarnings(\"deprecation\") // test of deprecated method", "originalCommit": "428c6f32f056fd791f8d676a5febc7f5f8de654f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxNDgxMQ==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r501914811", "bodyText": "This is a copy of the unit test for the old MockProcessorContext.", "author": "vvcephei", "createdAt": "2020-10-08T18:06:37Z", "path": "streams/test-utils/src/test/java/org/apache/kafka/streams/test/MockProcessorContextAPITest.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.test;\n+\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.processor.PunctuationType;\n+import org.apache.kafka.streams.processor.Punctuator;\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.api.MockProcessorContext;\n+import org.apache.kafka.streams.processor.api.MockProcessorContext.CapturedForward;\n+import org.apache.kafka.streams.processor.api.Processor;\n+import org.apache.kafka.streams.processor.api.ProcessorContext;\n+import org.apache.kafka.streams.processor.api.Record;\n+import org.apache.kafka.streams.processor.api.RecordMetadata;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+import org.apache.kafka.streams.state.StoreBuilder;\n+import org.apache.kafka.streams.state.Stores;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Properties;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static org.apache.kafka.common.utils.Utils.mkEntry;\n+import static org.apache.kafka.common.utils.Utils.mkMap;\n+import static org.apache.kafka.common.utils.Utils.mkProperties;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.is;\n+\n+public class MockProcessorContextAPITest {", "originalCommit": "428c6f32f056fd791f8d676a5febc7f5f8de654f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxNjYyMQ==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r501916621", "bodyText": "This is a new test. I wanted to make sure that no matter what kind of stores users select, they'll get well-defined results with the new MockProcessorContext.\nSome store features are well-defined not to be supported (they throw an IllegalArgumentException when you try to enable caching or logging), but all store types should otherwise work.\nHere, we're defining \"work\" as \"init doesn't throw an exception\", since this is the main involvement that the context itself has with the store.", "author": "vvcephei", "createdAt": "2020-10-08T18:09:30Z", "path": "streams/test-utils/src/test/java/org/apache/kafka/streams/test/MockProcessorContextStateStoreTest.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.test;\n+\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.common.utils.Utils;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.processor.StateStore;\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.api.MockProcessorContext;\n+import org.apache.kafka.streams.state.KeyValueBytesStoreSupplier;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+import org.apache.kafka.streams.state.SessionBytesStoreSupplier;\n+import org.apache.kafka.streams.state.SessionStore;\n+import org.apache.kafka.streams.state.StoreBuilder;\n+import org.apache.kafka.streams.state.Stores;\n+import org.apache.kafka.streams.state.WindowBytesStoreSupplier;\n+import org.apache.kafka.streams.state.WindowStore;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static java.util.Arrays.asList;\n+import static org.apache.kafka.common.utils.Utils.mkEntry;\n+import static org.apache.kafka.common.utils.Utils.mkMap;\n+import static org.apache.kafka.common.utils.Utils.mkProperties;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(value = Parameterized.class)\n+public class MockProcessorContextStateStoreTest {", "originalCommit": "428c6f32f056fd791f8d676a5febc7f5f8de654f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxNzE3NQ==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r501917175", "bodyText": "Converting this processor to the new API.", "author": "vvcephei", "createdAt": "2020-10-08T18:10:23Z", "path": "streams/test-utils/src/test/java/org/apache/kafka/streams/test/wordcount/WindowedWordCountProcessorSupplier.java", "diffHunk": "@@ -18,43 +18,41 @@\n \n import org.apache.kafka.streams.KeyValue;\n import org.apache.kafka.streams.kstream.Windowed;\n-import org.apache.kafka.streams.processor.Processor;\n-import org.apache.kafka.streams.processor.ProcessorContext;\n-import org.apache.kafka.streams.processor.ProcessorSupplier;\n import org.apache.kafka.streams.processor.PunctuationType;\n+import org.apache.kafka.streams.processor.api.Processor;\n+import org.apache.kafka.streams.processor.api.ProcessorContext;\n+import org.apache.kafka.streams.processor.api.ProcessorSupplier;\n+import org.apache.kafka.streams.processor.api.Record;\n import org.apache.kafka.streams.state.KeyValueIterator;\n import org.apache.kafka.streams.state.WindowStore;\n \n import java.time.Duration;\n import java.util.Locale;\n \n-public final class WindowedWordCountProcessorSupplier implements ProcessorSupplier<String, String> {\n+public final class WindowedWordCountProcessorSupplier implements ProcessorSupplier<String, String, String, String> {", "originalCommit": "428c6f32f056fd791f8d676a5febc7f5f8de654f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxNzQwNw==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r501917407", "bodyText": "Converting the test for the processor to the new API as well.", "author": "vvcephei", "createdAt": "2020-10-08T18:10:47Z", "path": "streams/test-utils/src/test/java/org/apache/kafka/streams/test/wordcount/WindowedWordCountProcessorTest.java", "diffHunk": "@@ -31,19 +32,17 @@\n import java.io.File;\n import java.io.IOException;\n import java.time.Duration;\n-import java.util.HashMap;\n-import java.util.Iterator;\n+import java.util.List;\n import java.util.Properties;\n \n+import static java.util.Arrays.asList;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.is;\n-import static org.junit.Assert.assertThrows;\n \n public class WindowedWordCountProcessorTest {\n-    @SuppressWarnings(\"deprecation\") // TODO will be fixed in KAFKA-10437\n     @Test\n     public void shouldWorkWithInMemoryStore() {\n-        final MockProcessorContext context = new MockProcessorContext();\n+        final MockProcessorContext<String, String> context = new MockProcessorContext<>();", "originalCommit": "428c6f32f056fd791f8d676a5febc7f5f8de654f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA3Njg1Nw==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r502076857", "bodyText": "Can we remove those two tests?", "author": "guozhangwang", "createdAt": "2020-10-08T23:28:14Z", "path": "streams/test-utils/src/test/java/org/apache/kafka/streams/test/wordcount/WindowedWordCountProcessorTest.java", "diffHunk": "@@ -136,54 +133,18 @@ public void shouldWorkWithPersistentStore() throws IOException {\n             context.scheduledPunctuators().get(0).getPunctuator().punctuate(1_000L);\n \n             // finally, we can verify the output.\n-            final Iterator<MockProcessorContext.CapturedForward> capturedForwards = context.forwarded().iterator();\n-            assertThat(capturedForwards.next().keyValue(), is(new KeyValue<>(\"[alpha@100/200]\", \"2\")));\n-            assertThat(capturedForwards.next().keyValue(), is(new KeyValue<>(\"[beta@100/200]\", \"1\")));\n-            assertThat(capturedForwards.next().keyValue(), is(new KeyValue<>(\"[delta@200/300]\", \"1\")));\n-            assertThat(capturedForwards.next().keyValue(), is(new KeyValue<>(\"[gamma@100/200]\", \"1\")));\n-            assertThat(capturedForwards.next().keyValue(), is(new KeyValue<>(\"[gamma@200/300]\", \"1\")));\n-            assertThat(capturedForwards.hasNext(), is(false));\n+            final List<CapturedForward<? extends String, ? extends String>> capturedForwards = context.forwarded();\n+            final List<CapturedForward<? extends String, ? extends String>> expected = asList(\n+                new CapturedForward<>(new Record<>(\"[alpha@100/200]\", \"2\", 1_000L)),\n+                new CapturedForward<>(new Record<>(\"[beta@100/200]\", \"1\", 1_000L)),\n+                new CapturedForward<>(new Record<>(\"[delta@200/300]\", \"1\", 1_000L)),\n+                new CapturedForward<>(new Record<>(\"[gamma@100/200]\", \"1\", 1_000L)),\n+                new CapturedForward<>(new Record<>(\"[gamma@200/300]\", \"1\", 1_000L))\n+            );\n+\n+            assertThat(capturedForwards, is(expected));\n         } finally {\n             Utils.delete(stateDir);\n         }\n     }\n-\n-    @SuppressWarnings(\"deprecation\") // TODO will be fixed in KAFKA-10437\n-    @Test\n-    public void shouldFailWithLogging() {", "originalCommit": "428c6f32f056fd791f8d676a5febc7f5f8de654f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjczNzIzMQ==", "url": "https://github.com/apache/kafka/pull/9396#discussion_r502737231", "bodyText": "Yes, they are superceded by the new MockProcessorContextStateStoreTest, which verifies that any state store configured with logging or caching is rejected.", "author": "vvcephei", "createdAt": "2020-10-10T02:56:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA3Njg1Nw=="}], "type": "inlineReview"}]}