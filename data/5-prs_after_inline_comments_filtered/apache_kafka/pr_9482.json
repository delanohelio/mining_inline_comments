{"pr_number": 9482, "pr_title": "KAFKA-10632; Raft client should push all committed data to state machines", "pr_createdAt": "2020-10-22T18:32:33Z", "pr_url": "https://github.com/apache/kafka/pull/9482", "timeline": [{"oid": "348a14bb40f9d3db022e68f01b607c49270e48cf", "url": "https://github.com/apache/kafka/commit/348a14bb40f9d3db022e68f01b607c49270e48cf", "message": "KAFKA-10632; Raft client should push all committed data to state machine", "committedDate": "2020-10-27T23:20:25Z", "type": "commit"}, {"oid": "348a14bb40f9d3db022e68f01b607c49270e48cf", "url": "https://github.com/apache/kafka/commit/348a14bb40f9d3db022e68f01b607c49270e48cf", "message": "KAFKA-10632; Raft client should push all committed data to state machine", "committedDate": "2020-10-27T23:20:25Z", "type": "forcePushed"}, {"oid": "84cfc2fed4c6fe488ce68ad8ebd3c5cf0b447b39", "url": "https://github.com/apache/kafka/commit/84cfc2fed4c6fe488ce68ad8ebd3c5cf0b447b39", "message": "Remove unused `DataInputReadable`", "committedDate": "2020-10-27T23:25:52Z", "type": "commit"}, {"oid": "9a7dced63aac4b8db2165ff186c577d714a2c936", "url": "https://github.com/apache/kafka/commit/9a7dced63aac4b8db2165ff186c577d714a2c936", "message": "Ensure supplied buffers are released by `RecordsBatchReader`", "committedDate": "2020-10-28T00:51:08Z", "type": "commit"}, {"oid": "62eac1a0b20805cd1fad3be9901e68db0590bfea", "url": "https://github.com/apache/kafka/commit/62eac1a0b20805cd1fad3be9901e68db0590bfea", "message": "Add missing license header", "committedDate": "2020-10-28T00:58:42Z", "type": "commit"}, {"oid": "ba8994d20aea177086c089a01f20fcef290ff44b", "url": "https://github.com/apache/kafka/commit/ba8994d20aea177086c089a01f20fcef290ff44b", "message": "tweak shutdown error message", "committedDate": "2020-10-28T01:22:50Z", "type": "commit"}, {"oid": "6d8134ea7de896ed804dca8fa8b25216f1c4323f", "url": "https://github.com/apache/kafka/commit/6d8134ea7de896ed804dca8fa8b25216f1c4323f", "message": "Fix metric names in `TestRaftServer`", "committedDate": "2020-10-28T01:30:55Z", "type": "commit"}, {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c", "url": "https://github.com/apache/kafka/commit/1345f566ff9265c4072f2129bf6c477946c4407c", "message": "Use kafka metrics in workload generator", "committedDate": "2020-10-28T03:23:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE4ODQzMw==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513188433", "bodyText": "Why do we change these values to debug?", "author": "abbccdda", "createdAt": "2020-10-28T05:26:00Z", "path": "clients/src/main/java/org/apache/kafka/common/metrics/stats/Percentiles.java", "diffHunk": "@@ -113,11 +113,11 @@ protected HistogramSample newSample(long timeMs) {\n     protected void update(Sample sample, MetricConfig config, double value, long timeMs) {\n         final double boundedValue;\n         if (value > max) {\n-            log.warn(\"Received value {} which is greater than max recordable value {}, will be pinned to the max value\",\n+            log.debug(\"Received value {} which is greater than max recordable value {}, will be pinned to the max value\",", "originalCommit": "1345f566ff9265c4072f2129bf6c477946c4407c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUxMjIxMw==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514512213", "bodyText": "The warn seemed excessive for a metric update, which could be done very frequently. I looked over the code and it looks like we don't really use this outside of tests (and now the code added in this patch). I think the user should just understand the contract, which is that anything outside of the specified range gets rounded down.", "author": "hachikuji", "createdAt": "2020-10-29T19:28:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE4ODQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIwMDAxMA==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513200010", "bodyText": "nit: we could refactor out the try-catch logic.", "author": "abbccdda", "createdAt": "2020-10-28T06:06:18Z", "path": "clients/src/main/java/org/apache/kafka/common/protocol/DataInputStreamReadable.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.protocol;\n+\n+import org.apache.kafka.common.utils.ByteUtils;\n+\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+public class DataInputStreamReadable implements Readable, Closeable {\n+    protected final DataInputStream input;\n+\n+    public DataInputStreamReadable(DataInputStream input) {\n+        this.input = input;\n+    }\n+\n+    @Override\n+    public byte readByte() {\n+        try {\n+            return input.readByte();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public short readShort() {\n+        try {", "originalCommit": "1345f566ff9265c4072f2129bf6c477946c4407c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUxNDA1MQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514514051", "bodyText": "Yeah, I could introduce a helper with a lambda, but that would add some unnecessary garbage to the deserialization path. Although it is ugly, I think the duplication is not a big deal. We probably won't touch this class after it is created.", "author": "hachikuji", "createdAt": "2020-10-29T19:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIwMDAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIwMDE0OA==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513200148", "bodyText": "Why do we wrap the IO exception here?", "author": "abbccdda", "createdAt": "2020-10-28T06:06:49Z", "path": "clients/src/main/java/org/apache/kafka/common/protocol/DataInputStreamReadable.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.protocol;\n+\n+import org.apache.kafka.common.utils.ByteUtils;\n+\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+public class DataInputStreamReadable implements Readable, Closeable {\n+    protected final DataInputStream input;\n+\n+    public DataInputStreamReadable(DataInputStream input) {\n+        this.input = input;\n+    }\n+\n+    @Override\n+    public byte readByte() {\n+        try {\n+            return input.readByte();\n+        } catch (IOException e) {", "originalCommit": "1345f566ff9265c4072f2129bf6c477946c4407c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUxNTc2Mw==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514515763", "bodyText": "IOException is checked, so we cannot raise it from the current Readable interface, so the options are to either add the exception to the Readable interface or to rethrow it as an unchecked exception. I went with the latter to reduce the impact and because I think we tend to prefer unchecked exceptions in general since checked exceptions sort of end up leaking their way through a bunch of call stacks.", "author": "hachikuji", "createdAt": "2020-10-29T19:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIwMDE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIwNjEyOA==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513206128", "bodyText": "We couldn't be sure whether the records could be read as string?", "author": "abbccdda", "createdAt": "2020-10-28T06:26:51Z", "path": "raft/src/main/java/org/apache/kafka/raft/BatchReader.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.raft;\n+\n+import java.io.Closeable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.OptionalLong;\n+\n+/**\n+ * This interface is used to send committed data from the {@link RaftClient}\n+ * down to registered {@link RaftClient.Listener} instances.\n+ *\n+ * The advantage of hiding the consumption of committed batches behind an interface\n+ * is that it allows us to push blocking operations such as reads from disk outside\n+ * of the Raft IO thread. This helps to ensure that a slow state machine will not\n+ * affect replication.\n+ *\n+ * @param <T> record type (see {@link org.apache.kafka.raft.RecordSerde})\n+ */\n+public interface BatchReader<T> extends Iterator<BatchReader.Batch<T>>, Closeable {\n+\n+    /**\n+     * Get the base offset of the readable batches. Note that this value is a constant\n+     * which is defined when the {@link BatchReader} instance is constructed. It does\n+     * not change based on reader progress.\n+     *\n+     * @return the base offset\n+     */\n+    long baseOffset();\n+\n+    /**\n+     * Get the last offset of the batch if it is known. When reading from disk, we may\n+     * not know the last offset of a set of records until it has been read from disk.\n+     * In this case, the state machine cannot advance to the next committed data until\n+     * all batches from the {@link BatchReader} instance have been consumed.\n+     *\n+     * @return optional last offset\n+     */\n+    OptionalLong lastOffset();\n+\n+    /**\n+     * Close this reader. It is the responsibility of the {@link RaftClient.Listener}\n+     * to close each reader passed to {@link RaftClient.Listener#handleCommit(BatchReader)}.\n+     */\n+    @Override\n+    void close();\n+\n+    class Batch<T> {\n+        private final long baseOffset;\n+        private final int epoch;\n+        private final List<T> records;\n+\n+        public Batch(long baseOffset, int epoch, List<T> records) {\n+            this.baseOffset = baseOffset;\n+            this.epoch = epoch;\n+            this.records = records;\n+        }\n+\n+        public long lastOffset() {\n+            return baseOffset + records.size() - 1;\n+        }\n+\n+        public long baseOffset() {\n+            return baseOffset;\n+        }\n+\n+        public List<T> records() {\n+            return records;\n+        }\n+\n+        public int epoch() {\n+            return epoch;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Batch(\" +\n+                \"baseOffset=\" + baseOffset +\n+                \", epoch=\" + epoch +\n+                \", records=\" + records +", "originalCommit": "1345f566ff9265c4072f2129bf6c477946c4407c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUxNjU3MA==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514516570", "bodyText": "Yeah, I'm relying on the toString. I think this is only useful for debugging.", "author": "hachikuji", "createdAt": "2020-10-29T19:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIwNjEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIwNjk4Mw==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513206983", "bodyText": "Do we compare the value or the address of records?", "author": "abbccdda", "createdAt": "2020-10-28T06:29:33Z", "path": "raft/src/main/java/org/apache/kafka/raft/BatchReader.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.raft;\n+\n+import java.io.Closeable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.OptionalLong;\n+\n+/**\n+ * This interface is used to send committed data from the {@link RaftClient}\n+ * down to registered {@link RaftClient.Listener} instances.\n+ *\n+ * The advantage of hiding the consumption of committed batches behind an interface\n+ * is that it allows us to push blocking operations such as reads from disk outside\n+ * of the Raft IO thread. This helps to ensure that a slow state machine will not\n+ * affect replication.\n+ *\n+ * @param <T> record type (see {@link org.apache.kafka.raft.RecordSerde})\n+ */\n+public interface BatchReader<T> extends Iterator<BatchReader.Batch<T>>, Closeable {\n+\n+    /**\n+     * Get the base offset of the readable batches. Note that this value is a constant\n+     * which is defined when the {@link BatchReader} instance is constructed. It does\n+     * not change based on reader progress.\n+     *\n+     * @return the base offset\n+     */\n+    long baseOffset();\n+\n+    /**\n+     * Get the last offset of the batch if it is known. When reading from disk, we may\n+     * not know the last offset of a set of records until it has been read from disk.\n+     * In this case, the state machine cannot advance to the next committed data until\n+     * all batches from the {@link BatchReader} instance have been consumed.\n+     *\n+     * @return optional last offset\n+     */\n+    OptionalLong lastOffset();\n+\n+    /**\n+     * Close this reader. It is the responsibility of the {@link RaftClient.Listener}\n+     * to close each reader passed to {@link RaftClient.Listener#handleCommit(BatchReader)}.\n+     */\n+    @Override\n+    void close();\n+\n+    class Batch<T> {\n+        private final long baseOffset;\n+        private final int epoch;\n+        private final List<T> records;\n+\n+        public Batch(long baseOffset, int epoch, List<T> records) {\n+            this.baseOffset = baseOffset;\n+            this.epoch = epoch;\n+            this.records = records;\n+        }\n+\n+        public long lastOffset() {\n+            return baseOffset + records.size() - 1;\n+        }\n+\n+        public long baseOffset() {\n+            return baseOffset;\n+        }\n+\n+        public List<T> records() {\n+            return records;\n+        }\n+\n+        public int epoch() {\n+            return epoch;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Batch(\" +\n+                \"baseOffset=\" + baseOffset +\n+                \", epoch=\" + epoch +\n+                \", records=\" + records +\n+                ')';\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Batch<?> batch = (Batch<?>) o;\n+            return baseOffset == batch.baseOffset &&\n+                epoch == batch.epoch &&\n+                Objects.equals(records, batch.records);", "originalCommit": "1345f566ff9265c4072f2129bf6c477946c4407c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUxODM2MA==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514518360", "bodyText": "We are relying on the standard equals method. I think it's up to the user of the api to ensure a reasonable implementation if they expect to rely on batch equality. The raft implementation does not set any expectations on record equality, but it is useful in testing where we can control the record type.", "author": "hachikuji", "createdAt": "2020-10-29T19:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIwNjk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIwNzg4MA==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513207880", "bodyText": "after the provided timeout passes if it is not completed/ if not completed within the provided time limit", "author": "abbccdda", "createdAt": "2020-10-28T06:32:32Z", "path": "raft/src/main/java/org/apache/kafka/raft/ExpirationService.java", "diffHunk": "@@ -16,11 +16,17 @@\n  */\n package org.apache.kafka.raft;\n \n-import org.apache.kafka.common.KafkaException;\n+import java.util.concurrent.CompletableFuture;\n \n-public class LogTruncationException extends KafkaException {\n-\n-    public LogTruncationException(String message) {\n-        super(message);\n-    }\n+public interface ExpirationService {\n+    /**\n+     * Get a new completable future which will automatically expire with a\n+     * {@link org.apache.kafka.common.errors.TimeoutException} after the provided\n+     * timeout passes if it is not completed before then through some other means.", "originalCommit": "1345f566ff9265c4072f2129bf6c477946c4407c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIxMDQ0OQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513210449", "bodyText": "it does not could be removed.", "author": "abbccdda", "createdAt": "2020-10-28T06:40:23Z", "path": "raft/src/main/java/org/apache/kafka/raft/QuorumState.java", "diffHunk": "@@ -369,6 +379,17 @@ public void transitionToLeader(long epochStartOffset) throws IOException {\n         if (!candidateState.isVoteGranted())\n             throw new IllegalStateException(\"Cannot become leader without majority votes granted\");\n \n+        // Note that the leader does not retain the high watermark that was known\n+        // in the previous state. The reason it does not is to protect the monotonicity", "originalCommit": "1345f566ff9265c4072f2129bf6c477946c4407c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMDg5NA==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513630894", "bodyText": "Should we add description to the exception?", "author": "abbccdda", "createdAt": "2020-10-28T17:27:17Z", "path": "raft/src/main/java/org/apache/kafka/raft/internals/MemoryBatchReader.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.raft.internals;\n+\n+import org.apache.kafka.raft.BatchReader;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.OptionalLong;\n+\n+public class MemoryBatchReader<T> implements BatchReader<T> {\n+    private final CloseListener<BatchReader<T>> closeListener;\n+    private final Iterator<Batch<T>> iterator;\n+    private final long baseOffset;\n+    private final long lastOffset;\n+\n+    public MemoryBatchReader(\n+        List<Batch<T>> batches,\n+        CloseListener<BatchReader<T>> closeListener\n+    ) {\n+        if (batches.isEmpty()) {\n+            throw new IllegalArgumentException();", "originalCommit": "1345f566ff9265c4072f2129bf6c477946c4407c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMjM5Mg==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513632392", "bodyText": "How do we decide to use either record batch reader or memory batch reader?", "author": "abbccdda", "createdAt": "2020-10-28T17:29:24Z", "path": "raft/src/main/java/org/apache/kafka/raft/internals/RecordsBatchReader.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.raft.internals;\n+\n+import org.apache.kafka.common.protocol.DataInputStreamReadable;\n+import org.apache.kafka.common.protocol.Readable;\n+import org.apache.kafka.common.record.BufferSupplier;\n+import org.apache.kafka.common.record.DefaultRecordBatch;\n+import org.apache.kafka.common.record.FileRecords;\n+import org.apache.kafka.common.record.MemoryRecords;\n+import org.apache.kafka.common.record.MutableRecordBatch;\n+import org.apache.kafka.common.record.Records;\n+import org.apache.kafka.raft.BatchReader;\n+import org.apache.kafka.raft.RecordSerde;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.OptionalLong;\n+\n+public class RecordsBatchReader<T> implements BatchReader<T> {", "originalCommit": "1345f566ff9265c4072f2129bf6c477946c4407c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUzMzcxMg==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514533712", "bodyText": "MemoryBatchReader is only used for writes from the leader. We retain the original records from the call to scheduleAppend and send them to the listener in handleCommit. This is useful because it ensures the active controller will not need to read from disk.", "author": "hachikuji", "createdAt": "2020-10-29T20:05:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMjM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkyMjc1MA==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513922750", "bodyText": "Do we have other types of threshold than Long?", "author": "abbccdda", "createdAt": "2020-10-29T03:36:01Z", "path": "raft/src/main/java/org/apache/kafka/raft/internals/ThresholdPurgatory.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.raft.internals;\n+\n+import org.apache.kafka.raft.ExpirationService;\n+\n+import java.util.NavigableMap;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentNavigableMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class ThresholdPurgatory<T extends Comparable<T>> implements FuturePurgatory<T> {\n+    private final AtomicLong idGenerator = new AtomicLong(0);\n+    private final ExpirationService expirationService;\n+    private final ConcurrentNavigableMap<ThresholdKey<T>, CompletableFuture<Long>> thresholdMap =\n+        new ConcurrentSkipListMap<>();\n+\n+    public ThresholdPurgatory(ExpirationService expirationService) {\n+        this.expirationService = expirationService;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Long> await(T threshold, long maxWaitTimeMs) {\n+        ThresholdKey<T> key = new ThresholdKey<>(idGenerator.incrementAndGet(), threshold);\n+        CompletableFuture<Long> future = expirationService.await(maxWaitTimeMs);\n+        thresholdMap.put(key, future);\n+        future.whenComplete((timeMs, exception) -> thresholdMap.remove(key));\n+        return future;\n+    }\n+\n+    @Override\n+    public void maybeComplete(T value, long currentTimeMs) {\n+        ThresholdKey<T> maxKey = new ThresholdKey<>(Long.MAX_VALUE, value);\n+        NavigableMap<ThresholdKey<T>, CompletableFuture<Long>> submap = thresholdMap.headMap(maxKey);\n+        for (CompletableFuture<Long> completion : submap.values()) {\n+            completion.complete(currentTimeMs);\n+        }\n+    }\n+\n+    @Override\n+    public void completeAll(long currentTimeMs) {\n+        for (CompletableFuture<Long> completion : thresholdMap.values()) {\n+            completion.complete(currentTimeMs);\n+        }\n+    }\n+\n+    @Override\n+    public void completeAllExceptionally(Throwable exception) {\n+        for (CompletableFuture<Long> completion : thresholdMap.values()) {\n+            completion.completeExceptionally(exception);\n+        }\n+    }\n+\n+    @Override\n+    public int numWaiting() {\n+        return thresholdMap.size();\n+    }\n+\n+    private static class ThresholdKey<T extends Comparable<T>> implements Comparable<ThresholdKey<T>> {", "originalCommit": "1345f566ff9265c4072f2129bf6c477946c4407c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUzNTc2MQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514535761", "bodyText": "Not at the moment. I guess your point is that we might be able to drop the generics, which is fair. I think we can also drop the FuturePurgatory interface. Is it ok if we save this for a follow-up?", "author": "hachikuji", "createdAt": "2020-10-29T20:08:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkyMjc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAyNzAxNQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514027015", "bodyText": "Why do we need to repeatedly get leader epoch?", "author": "abbccdda", "createdAt": "2020-10-29T06:43:19Z", "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -228,35 +234,81 @@ private void updateLeaderEndOffsetAndTimestamp(\n         final LogOffsetMetadata endOffsetMetadata = log.endOffset();\n \n         if (state.updateLocalState(currentTimeMs, endOffsetMetadata)) {\n-            updateHighWatermark(state, currentTimeMs);\n+            onUpdateLeaderHighWatermark(state, currentTimeMs);\n         }\n \n-        LogOffset endOffset = new LogOffset(endOffsetMetadata.offset, Isolation.UNCOMMITTED);\n-        fetchPurgatory.maybeComplete(endOffset, currentTimeMs);\n+        fetchPurgatory.maybeComplete(endOffsetMetadata.offset, currentTimeMs);\n     }\n \n-    private void updateHighWatermark(\n-        EpochState state,\n+    private void onUpdateLeaderHighWatermark(\n+        LeaderState state,\n         long currentTimeMs\n     ) {\n         state.highWatermark().ifPresent(highWatermark -> {\n-            logger.debug(\"High watermark updated to {}\", highWatermark);\n+            logger.debug(\"Leader high watermark updated to {}\", highWatermark);\n             log.updateHighWatermark(highWatermark);\n-\n-            LogOffset offset = new LogOffset(highWatermark.offset, Isolation.COMMITTED);\n-            appendPurgatory.maybeComplete(offset, currentTimeMs);\n-            fetchPurgatory.maybeComplete(offset, currentTimeMs);\n+            appendPurgatory.maybeComplete(highWatermark.offset, currentTimeMs);\n+            maybeFireHandleCommit(highWatermark.offset);\n         });\n     }\n \n-    @Override\n-    public LeaderAndEpoch currentLeaderAndEpoch() {\n-        return quorum.leaderAndEpoch();\n+    private void maybeFireHandleCommit(long highWatermark) {\n+        maybeFireHandleCommit(listenerContexts, highWatermark);\n+    }\n+\n+    private void maybeFireHandleCommit(List<ListenerContext> listenerContexts, long highWatermark) {\n+        // TODO: When there are multiple listeners, we can cache reads to save some work\n+        for (ListenerContext listenerContext : listenerContexts) {\n+            OptionalLong nextExpectedOffsetOpt = listenerContext.nextExpectedOffset();\n+            if (!nextExpectedOffsetOpt.isPresent()) {\n+                continue;\n+            }\n+\n+            long nextExpectedOffset = nextExpectedOffsetOpt.getAsLong();\n+            if (nextExpectedOffset < highWatermark) {\n+                LogFetchInfo readInfo = log.read(nextExpectedOffset, Isolation.COMMITTED);\n+                listenerContext.fireHandleCommit(nextExpectedOffset, readInfo.records);\n+            }\n+        }\n+    }\n+\n+    private void maybeFireHandleCommit(long baseOffset, int epoch, List<T> records) {\n+        for (ListenerContext listenerContext : listenerContexts) {\n+            OptionalLong nextExpectedOffsetOpt = listenerContext.nextExpectedOffset();\n+            if (!nextExpectedOffsetOpt.isPresent()) {\n+                continue;\n+            }\n+\n+            long nextExpectedOffset = nextExpectedOffsetOpt.getAsLong();\n+            if (nextExpectedOffset == baseOffset) {\n+                listenerContext.fireHandleCommit(baseOffset, epoch, records);\n+            }\n+        }\n+    }\n+\n+    private void maybeFireHandleClaim(LeaderState state) {\n+        for (ListenerContext listenerContext : listenerContexts) {\n+            int leaderEpoch = state.epoch();", "originalCommit": "1345f566ff9265c4072f2129bf6c477946c4407c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUzNjgyOA==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514536828", "bodyText": "I will move this outside the loop.", "author": "hachikuji", "createdAt": "2020-10-29T20:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAyNzAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1MjE0MA==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514452140", "bodyText": "It looks a bit weird to have two versions of fire handle commit, could we name them differently or comment about their distinctive logics for determining when to fire commit callback?", "author": "abbccdda", "createdAt": "2020-10-29T17:48:13Z", "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -228,35 +234,81 @@ private void updateLeaderEndOffsetAndTimestamp(\n         final LogOffsetMetadata endOffsetMetadata = log.endOffset();\n \n         if (state.updateLocalState(currentTimeMs, endOffsetMetadata)) {\n-            updateHighWatermark(state, currentTimeMs);\n+            onUpdateLeaderHighWatermark(state, currentTimeMs);\n         }\n \n-        LogOffset endOffset = new LogOffset(endOffsetMetadata.offset, Isolation.UNCOMMITTED);\n-        fetchPurgatory.maybeComplete(endOffset, currentTimeMs);\n+        fetchPurgatory.maybeComplete(endOffsetMetadata.offset, currentTimeMs);\n     }\n \n-    private void updateHighWatermark(\n-        EpochState state,\n+    private void onUpdateLeaderHighWatermark(\n+        LeaderState state,\n         long currentTimeMs\n     ) {\n         state.highWatermark().ifPresent(highWatermark -> {\n-            logger.debug(\"High watermark updated to {}\", highWatermark);\n+            logger.debug(\"Leader high watermark updated to {}\", highWatermark);\n             log.updateHighWatermark(highWatermark);\n-\n-            LogOffset offset = new LogOffset(highWatermark.offset, Isolation.COMMITTED);\n-            appendPurgatory.maybeComplete(offset, currentTimeMs);\n-            fetchPurgatory.maybeComplete(offset, currentTimeMs);\n+            appendPurgatory.maybeComplete(highWatermark.offset, currentTimeMs);\n+            maybeFireHandleCommit(highWatermark.offset);\n         });\n     }\n \n-    @Override\n-    public LeaderAndEpoch currentLeaderAndEpoch() {\n-        return quorum.leaderAndEpoch();\n+    private void maybeFireHandleCommit(long highWatermark) {\n+        maybeFireHandleCommit(listenerContexts, highWatermark);\n+    }\n+\n+    private void maybeFireHandleCommit(List<ListenerContext> listenerContexts, long highWatermark) {\n+        // TODO: When there are multiple listeners, we can cache reads to save some work\n+        for (ListenerContext listenerContext : listenerContexts) {\n+            OptionalLong nextExpectedOffsetOpt = listenerContext.nextExpectedOffset();\n+            if (!nextExpectedOffsetOpt.isPresent()) {\n+                continue;\n+            }\n+\n+            long nextExpectedOffset = nextExpectedOffsetOpt.getAsLong();\n+            if (nextExpectedOffset < highWatermark) {\n+                LogFetchInfo readInfo = log.read(nextExpectedOffset, Isolation.COMMITTED);\n+                listenerContext.fireHandleCommit(nextExpectedOffset, readInfo.records);\n+            }\n+        }\n+    }\n+\n+    private void maybeFireHandleCommit(long baseOffset, int epoch, List<T> records) {", "originalCommit": "1345f566ff9265c4072f2129bf6c477946c4407c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUzNzY5NA==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514537694", "bodyText": "The only difference is the input. I will add some comments to try and clarify the usage.", "author": "hachikuji", "createdAt": "2020-10-29T20:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1MjE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1NjMzMQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514456331", "bodyText": "Why would this work? If the flush wasn't successful, could the fetched records be invalidated later?", "author": "abbccdda", "createdAt": "2020-10-29T17:54:30Z", "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -329,8 +387,9 @@ private void appendLeaderChangeMessage(LeaderState state, long currentTimeMs) {\n     }\n \n     private void flushLeaderLog(LeaderState state, long currentTimeMs) {\n-        log.flush();\n+        // We update the end offset before flushing so that parked fetches can return sooner", "originalCommit": "1345f566ff9265c4072f2129bf6c477946c4407c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUzOTczNw==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514539737", "bodyText": "Yeah, it's ok for followers to see uncommitted or even unflushed data. The main thing is that we avoid advancing the high watermark until the fsync completes. Note that this is the main reason that we had to do KAFKA-10527. Without this fix, it was possible for the leader to continue in the same epoch after a start, which means that it could lose and overwrite unflushed data.", "author": "hachikuji", "createdAt": "2020-10-29T20:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1NjMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQyMzI0MQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515423241", "bodyText": "Yeah. You want to force an epoch change in the case that the old leader stays leader and partially replicated data was lost. This would force followers to truncate to the new leader's log state.", "author": "jsancio", "createdAt": "2020-10-30T23:31:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1NjMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1OTUzNA==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514459534", "bodyText": "Do we anticipate use cases to add listeners on the fly? Right now I could only see one case in static context from test raft server.", "author": "abbccdda", "createdAt": "2020-10-29T17:59:30Z", "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1688,14 +1694,39 @@ private long pollCurrentState(long currentTimeMs) throws IOException {\n         }\n     }\n \n+    private void pollListeners() {\n+        // Register any listeners added since the last poll\n+        while (!pendingListeners.isEmpty()) {", "originalCommit": "1345f566ff9265c4072f2129bf6c477946c4407c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUwNDU5Mw==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514504593", "bodyText": "I doubt we would use it in practice, though I guess it would open the door to changing roles dynamically, which might be interesting in the future. That said, it was simple to add and useful in testing since it gave me an easy way to initialize a state where a listener had not caught up.", "author": "hachikuji", "createdAt": "2020-10-29T19:14:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1OTUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ2MzIzMQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514463231", "bodyText": "Should we call pollListeners after pollCurrentState to get more recent updates quicker?", "author": "abbccdda", "createdAt": "2020-10-29T18:05:17Z", "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1688,14 +1694,39 @@ private long pollCurrentState(long currentTimeMs) throws IOException {\n         }\n     }\n \n+    private void pollListeners() {\n+        // Register any listeners added since the last poll\n+        while (!pendingListeners.isEmpty()) {\n+            Listener<T> listener = pendingListeners.poll();\n+            listenerContexts.add(new ListenerContext(listener));\n+        }\n+\n+        // Check listener progress to see if reads are expected\n+        quorum.highWatermark().ifPresent(highWatermarkMetadata -> {\n+            long highWatermark = highWatermarkMetadata.offset;\n+\n+            List<ListenerContext> listenersToUpdate = listenerContexts.stream()\n+                .filter(listenerContext -> {\n+                    OptionalLong nextExpectedOffset = listenerContext.nextExpectedOffset();\n+                    return nextExpectedOffset.isPresent() && nextExpectedOffset.getAsLong() < highWatermark;\n+                })\n+                .collect(Collectors.toList());\n+\n+            maybeFireHandleCommit(listenersToUpdate, highWatermarkMetadata.offset);\n+        });\n+    }\n+\n     public void poll() throws IOException {\n         GracefulShutdown gracefulShutdown = shutdown.get();\n         if (gracefulShutdown != null) {\n             pollShutdown(gracefulShutdown);\n         } else {\n+            pollListeners();", "originalCommit": "1345f566ff9265c4072f2129bf6c477946c4407c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU4NDQ2OQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514584469", "bodyText": "Hmm, that's a fair question. I think the listeners will tend to get new data in two cases: 1) high watermark advanced, or 2) a previous read completes. In the first case, the high watermark only advances in response to a request, so there should be no delay. In the second case, we call wakeup() to take us out of the network poll, so I think there also should be no delay. Can you think of a case where there would be a delay?", "author": "hachikuji", "createdAt": "2020-10-29T21:41:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ2MzIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzMzY4Ng==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515433686", "bodyText": "That looks correct to me with the clarification that \"in response to a request\" has two cases:\n\nThe leader handles a fetch request. This implementation calls \"update high watermark\nThe follower handle a fetch response. This implementation calls \"update high watermark\"\n\nI think that pollListeners should only fire a Listener::handleCommit for new listeners in pendingListeners.", "author": "jsancio", "createdAt": "2020-10-31T00:36:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ2MzIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU2OTE4MA==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515569180", "bodyText": "Sounds fair.", "author": "abbccdda", "createdAt": "2020-11-01T03:16:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ2MzIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ2Mzg4NQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514463885", "bodyText": "What about just name as handleBecomeLeader?", "author": "abbccdda", "createdAt": "2020-10-29T18:06:18Z", "path": "raft/src/main/java/org/apache/kafka/raft/RaftClient.java", "diffHunk": "@@ -26,30 +24,53 @@\n \n     interface Listener<T> {\n         /**\n-         * Callback which is invoked when records written through {@link #scheduleAppend(int, List)}\n-         * become committed.\n+         * Callback which is invoked for all records committed to the log.\n+         * It is the responsibility of the caller to invoke {@link BatchReader#close()}\n+         * after consuming the reader.\n          *\n          * Note that there is not a one-to-one correspondence between writes through\n          * {@link #scheduleAppend(int, List)} and this callback. The Raft implementation\n          * is free to batch together the records from multiple append calls provided\n          * that batch boundaries are respected. This means that each batch specified\n          * through {@link #scheduleAppend(int, List)} is guaranteed to be a subset of\n-         * a batch passed to {@link #handleCommit(int, long, List)}.\n+         * a batch provided by the {@link BatchReader}.\n+         *\n+         * @param reader reader instance which must be iterated and closed\n+         */\n+        void handleCommit(BatchReader<T> reader);\n+\n+        /**\n+         * Invoked after this node has become a leader. This is only called after\n+         * all commits up to the start of the leader's epoch have been sent to\n+         * {@link #handleCommit(BatchReader)}.\n+         *\n+         * After becoming a leader, the client is eligible to write to the log\n+         * using {@link #scheduleAppend(int, List)}.\n          *\n-         * @param epoch the epoch in which the write was accepted\n-         * @param lastOffset the offset of the last record in the record list\n-         * @param records the set of records that were committed\n+         * @param epoch the claimed leader epoch\n          */\n-        void handleCommit(int epoch, long lastOffset, List<T> records);\n+        default void handleClaim(int epoch) {}", "originalCommit": "1345f566ff9265c4072f2129bf6c477946c4407c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU4NTM1Mw==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514585353", "bodyText": "Yeah, I considered using handleBecomeLeader and handleResignLeader. In the end, I decided to use the more concise handleClaim and handleResign names which are used in the kip-500 branch.", "author": "hachikuji", "createdAt": "2020-10-29T21:43:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ2Mzg4NQ=="}], "type": "inlineReview"}, {"oid": "7c4b31ad898e083a354ebf648f334ac7db7e59a6", "url": "https://github.com/apache/kafka/commit/7c4b31ad898e083a354ebf648f334ac7db7e59a6", "message": "Address Boyang's comments", "committedDate": "2020-10-29T21:45:59Z", "type": "commit"}, {"oid": "867650fa2344497ac3f3505bd5058f2eae0cc0c4", "url": "https://github.com/apache/kafka/commit/867650fa2344497ac3f3505bd5058f2eae0cc0c4", "message": "Fix unused import in `TimingWheelExpirationService`", "committedDate": "2020-10-29T22:11:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQxNzA3Mg==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515417072", "bodyText": "How about extending java.lang.Iterable<...> instead of Iterator? This will allow the user to use BatchReader::forEach.", "author": "jsancio", "createdAt": "2020-10-30T23:01:45Z", "path": "raft/src/main/java/org/apache/kafka/raft/BatchReader.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.raft;\n+\n+import java.io.Closeable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.OptionalLong;\n+\n+/**\n+ * This interface is used to send committed data from the {@link RaftClient}\n+ * down to registered {@link RaftClient.Listener} instances.\n+ *\n+ * The advantage of hiding the consumption of committed batches behind an interface\n+ * is that it allows us to push blocking operations such as reads from disk outside\n+ * of the Raft IO thread. This helps to ensure that a slow state machine will not\n+ * affect replication.\n+ *\n+ * @param <T> record type (see {@link org.apache.kafka.raft.RecordSerde})\n+ */\n+public interface BatchReader<T> extends Iterator<BatchReader.Batch<T>>, Closeable {", "originalCommit": "867650fa2344497ac3f3505bd5058f2eae0cc0c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE4NzAxOQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r516187019", "bodyText": "I was thinking about this and having some trouble putting my hesitation into words. I guess there are two main reasons why I preferred the Iterator:\n\nWe need some way to communicate iteration progress back to the IO thread. It is probably still possible to do this with a layer of indirection through Iterable, but it seemed more natural if the IO thread had access to the Iterator object that was used by the listener.\nIteration is not necessarily cheap since it might involve reading from disk. I thought we may as well enforce a single-read pattern.", "author": "hachikuji", "createdAt": "2020-11-02T18:52:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQxNzA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE5NjI0Ng==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r516196246", "bodyText": "We need some way to communicate iteration progress back to the IO thread. It is probably still possible to do this with a layer of indirection through Iterable, but it seemed more natural if the IO thread had access to the Iterator object that was used by the listener.\n\nOkay. Specifically, you are saying that this would be difficult to implement with an Iterable:\nlastReturnedOffset = res.lastOffset();\nhttps://github.com/apache/kafka/pull/9482/files/867650fa2344497ac3f3505bd5058f2eae0cc0c4#diff-37728c07e52382d38a9db6f655c3921d274c4277a8909d7613fc433d6bf69636R140", "author": "jsancio", "createdAt": "2020-11-02T19:10:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQxNzA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIyMjQ5NQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r516222495", "bodyText": "Yeah. Not so much difficult, but awkward because of the one-to-many association between the Iterable and Iterator.", "author": "hachikuji", "createdAt": "2020-11-02T20:01:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQxNzA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQxNzU3MA==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515417570", "bodyText": "If we are overriding close to not throw an IOException, then maybe extending java.lang.AutoCloseable instead of java.io.Closeable is better.", "author": "jsancio", "createdAt": "2020-10-30T23:04:07Z", "path": "raft/src/main/java/org/apache/kafka/raft/BatchReader.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.raft;\n+\n+import java.io.Closeable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.OptionalLong;\n+\n+/**\n+ * This interface is used to send committed data from the {@link RaftClient}\n+ * down to registered {@link RaftClient.Listener} instances.\n+ *\n+ * The advantage of hiding the consumption of committed batches behind an interface\n+ * is that it allows us to push blocking operations such as reads from disk outside\n+ * of the Raft IO thread. This helps to ensure that a slow state machine will not\n+ * affect replication.\n+ *\n+ * @param <T> record type (see {@link org.apache.kafka.raft.RecordSerde})\n+ */\n+public interface BatchReader<T> extends Iterator<BatchReader.Batch<T>>, Closeable {\n+\n+    /**\n+     * Get the base offset of the readable batches. Note that this value is a constant\n+     * which is defined when the {@link BatchReader} instance is constructed. It does\n+     * not change based on reader progress.\n+     *\n+     * @return the base offset\n+     */\n+    long baseOffset();\n+\n+    /**\n+     * Get the last offset of the batch if it is known. When reading from disk, we may\n+     * not know the last offset of a set of records until it has been read from disk.\n+     * In this case, the state machine cannot advance to the next committed data until\n+     * all batches from the {@link BatchReader} instance have been consumed.\n+     *\n+     * @return optional last offset\n+     */\n+    OptionalLong lastOffset();\n+\n+    /**\n+     * Close this reader. It is the responsibility of the {@link RaftClient.Listener}\n+     * to close each reader passed to {@link RaftClient.Listener#handleCommit(BatchReader)}.\n+     */\n+    @Override\n+    void close();", "originalCommit": "867650fa2344497ac3f3505bd5058f2eae0cc0c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQyNzAxOQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515427019", "bodyText": "With the new Listener when is this not a noop? Looking at the code, we only add entries to fetchPurgatorywhen the replica is a leader and it receives a Fetch request.\nIn previous read based implementation we needed this because I think the fetchPurgatory contained both reads and Fetch.\nI think the part that is missing is that the old leader should fetchPurgatory.completeAll when it loses leadership.\nWhat do you think?", "author": "jsancio", "createdAt": "2020-10-30T23:52:15Z", "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1017,12 +1028,9 @@ private boolean handleFetchResponse(\n                 log.truncateToEndOffset(divergingOffsetAndEpoch).ifPresent(truncationOffset -> {\n                     logger.info(\"Truncated to offset {} from Fetch response from leader {}\",\n                         truncationOffset, quorum.leaderIdOrNil());\n-\n-                    // Since the end offset has been updated, we should complete any delayed\n-                    // reads at the end offset.\n-                    fetchPurgatory.maybeComplete(\n-                        new LogOffset(Long.MAX_VALUE, Isolation.UNCOMMITTED),\n-                        currentTimeMs);\n+                    // After truncation, we complete all pending reads in order to\n+                    // ensure that fetches account for the updated log end offset\n+                    fetchPurgatory.completeAll(currentTimeMs);", "originalCommit": "867650fa2344497ac3f3505bd5058f2eae0cc0c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1MTY0NQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r516151645", "bodyText": "With the new Listener when is this not a noop? Looking at the code, we only add entries to fetchPurgatorywhen the replica is a leader and it receives a Fetch request.\n\nYeah, that's fair. I don't think we can truncate unless we are a follower and that implies we already cleared the purgatory in onBecomeFollower. So I think you are right that we are safe to remove this, though we'll probably need to add it back once we have follower fetching.\n\nI think the part that is missing is that the old leader should fetchPurgatory.completeAll when it loses leadership.\n\nI had considered this previously and decided to leave the fetches in purgatory while the election was in progress to prevent unnecessary retries since that is all the client can do while waiting for the outcome. On the other hand, some of the fetches in purgatory might be from other voters. It might be better to respond more quickly so that there are not any unnecessary election delays. I'd suggest we open a separate issue to consider this.", "author": "hachikuji", "createdAt": "2020-11-02T17:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQyNzAxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3MjU3MQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r516172571", "bodyText": "I had considered this previously and decided to leave the fetches in purgatory while the election was in progress to prevent unnecessary retries since that is all the client can do while waiting for the outcome. On the other hand, some of the fetches in purgatory might be from other voters. It might be better to respond more quickly so that there are not any unnecessary election delays. I'd suggest we open a separate issue to consider this.\n\nSounds good to create a Jira for this.", "author": "jsancio", "createdAt": "2020-11-02T18:25:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQyNzAxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMzODQwMQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r516338401", "bodyText": "Filed https://issues.apache.org/jira/browse/KAFKA-10677.", "author": "hachikuji", "createdAt": "2020-11-02T23:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQyNzAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzMDAyOQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515430029", "bodyText": "Is this needed because users of KafkaRaftClient can call ::register before ::initizalize? When else would this result on a call to Listener::handleCommit?", "author": "jsancio", "createdAt": "2020-10-31T00:10:50Z", "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -228,35 +234,80 @@ private void updateLeaderEndOffsetAndTimestamp(\n         final LogOffsetMetadata endOffsetMetadata = log.endOffset();\n \n         if (state.updateLocalState(currentTimeMs, endOffsetMetadata)) {\n-            updateHighWatermark(state, currentTimeMs);\n+            onUpdateLeaderHighWatermark(state, currentTimeMs);\n         }\n \n-        LogOffset endOffset = new LogOffset(endOffsetMetadata.offset, Isolation.UNCOMMITTED);\n-        fetchPurgatory.maybeComplete(endOffset, currentTimeMs);\n+        fetchPurgatory.maybeComplete(endOffsetMetadata.offset, currentTimeMs);\n     }\n \n-    private void updateHighWatermark(\n-        EpochState state,\n+    private void onUpdateLeaderHighWatermark(\n+        LeaderState state,\n         long currentTimeMs\n     ) {\n         state.highWatermark().ifPresent(highWatermark -> {\n-            logger.debug(\"High watermark updated to {}\", highWatermark);\n+            logger.debug(\"Leader high watermark updated to {}\", highWatermark);\n             log.updateHighWatermark(highWatermark);\n-\n-            LogOffset offset = new LogOffset(highWatermark.offset, Isolation.COMMITTED);\n-            appendPurgatory.maybeComplete(offset, currentTimeMs);\n-            fetchPurgatory.maybeComplete(offset, currentTimeMs);\n+            appendPurgatory.maybeComplete(highWatermark.offset, currentTimeMs);\n+            maybeFireHandleCommit(highWatermark.offset);", "originalCommit": "867650fa2344497ac3f3505bd5058f2eae0cc0c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzMTMyOQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515431329", "bodyText": "Never mind. I think this can happens when the replica changes state from follower to leader.\nI was having an issue if doing this would cause both appendPurgatory.maybeComplete and maybeFireHandleCommit to fire Listener.handleCommit for the same listener.\nI don't think this can happened based on how ListenerContext is managing the nextExpectedOffset. If appendPurgator.maybeComplete fires then that means that nextExpectedOffset is greater that the high watermark. Since the nextExpectedOffset is greater than the high watermark then maybeFireHandleCommit will not fire.\nI actually think that this order is important. Should we write a comment on the code explaining this if you agree with my analysis?", "author": "jsancio", "createdAt": "2020-10-31T00:19:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzMDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1Mzc0OQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r516153749", "bodyText": "I will add a comment. I agree it is a subtle point.", "author": "hachikuji", "createdAt": "2020-11-02T17:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzMDAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzNDY3NA==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515434674", "bodyText": "I would document that synchronized is protecting lastSent and lastAckedOffset.\nclaimedEpoch is okay because it is only used by the thread calling RaftClient::poll.", "author": "jsancio", "createdAt": "2020-10-31T00:44:13Z", "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1778,4 +1808,98 @@ public void complete() {\n         }\n     }\n \n+    private final class ListenerContext implements CloseListener<BatchReader<T>> {\n+        private final RaftClient.Listener<T> listener;\n+        private BatchReader<T> lastSent = null;\n+        private long lastAckedOffset = 0;", "originalCommit": "867650fa2344497ac3f3505bd5058f2eae0cc0c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzNTE5Mg==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515435192", "bodyText": "Interesting that Java let's the outer class (KafkaRaftClient) access this private method. This makes reasoning about the concurrency non-trivial.", "author": "jsancio", "createdAt": "2020-10-31T00:48:16Z", "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1778,4 +1808,98 @@ public void complete() {\n         }\n     }\n \n+    private final class ListenerContext implements CloseListener<BatchReader<T>> {\n+        private final RaftClient.Listener<T> listener;\n+        private BatchReader<T> lastSent = null;\n+        private long lastAckedOffset = 0;\n+        private int claimedEpoch = 0;", "originalCommit": "867650fa2344497ac3f3505bd5058f2eae0cc0c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1OTgzNw==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r516159837", "bodyText": "Let me add a helper to ListenerContext so that we can keep the field encapsulated.", "author": "hachikuji", "createdAt": "2020-11-02T18:02:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzNTE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzNjk3Mg==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515436972", "bodyText": "How about failAfter?", "author": "jsancio", "createdAt": "2020-10-31T01:03:40Z", "path": "raft/src/main/java/org/apache/kafka/raft/ExpirationService.java", "diffHunk": "@@ -16,11 +16,17 @@\n  */\n package org.apache.kafka.raft;\n \n-import org.apache.kafka.common.KafkaException;\n+import java.util.concurrent.CompletableFuture;\n \n-public class LogTruncationException extends KafkaException {\n-\n-    public LogTruncationException(String message) {\n-        super(message);\n-    }\n+public interface ExpirationService {\n+    /**\n+     * Get a new completable future which will automatically fail exceptionally with a\n+     * {@link org.apache.kafka.common.errors.TimeoutException} if not completed before\n+     * the provided time limit expires.\n+     *\n+     * @param timeoutMs the duration in milliseconds before the future is completed exceptionally\n+     * @param <T> arbitrary future type (the service must set no expectation on the this type)\n+     * @return the completable future\n+     */\n+    <T> CompletableFuture<T> await(long timeoutMs);", "originalCommit": "867650fa2344497ac3f3505bd5058f2eae0cc0c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzODg4NA==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515438884", "bodyText": "This applies to all of the listener.handle... on this file.\nWhat are your thoughts on the Listener throwing an exception? I think with this implementation it will unwind all the way until KafakRaftClient::poll. Should we catch all non-fatal exceptions here and log an error instead?", "author": "jsancio", "createdAt": "2020-10-31T01:21:38Z", "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1778,4 +1808,98 @@ public void complete() {\n         }\n     }\n \n+    private final class ListenerContext implements CloseListener<BatchReader<T>> {\n+        private final RaftClient.Listener<T> listener;\n+        private BatchReader<T> lastSent = null;\n+        private long lastAckedOffset = 0;\n+        private int claimedEpoch = 0;\n+\n+        private ListenerContext(Listener<T> listener) {\n+            this.listener = listener;\n+        }\n+\n+        /**\n+         * Get the last acked offset, which is one greater than the offset of the\n+         * last record which was acked by the state machine.\n+         */\n+        public synchronized long lastAckedOffset() {\n+            return lastAckedOffset;\n+        }\n+\n+        /**\n+         * Get the next expected offset, which might be larger than the last acked\n+         * offset if there are inflight batches which have not been acked yet.\n+         * Note that when fetching from disk, we may not know the last offset of\n+         * inflight data until it has been processed by the state machine. In this case,\n+         * we delay sending additional data until the state machine has read to the\n+         * end and the last offset is determined.\n+         */\n+        public synchronized OptionalLong nextExpectedOffset() {\n+            if (lastSent != null) {\n+                OptionalLong lastSentOffset = lastSent.lastOffset();\n+                if (lastSentOffset.isPresent()) {\n+                    return OptionalLong.of(lastSentOffset.getAsLong() + 1);\n+                } else {\n+                    return OptionalLong.empty();\n+                }\n+            } else {\n+                return OptionalLong.of(lastAckedOffset);\n+            }\n+        }\n+\n+        /**\n+         * This API is used for committed records that have been received through\n+         * replication. In general, followers will write new data to disk before they\n+         * know whether it has been committed. Rather than retaining the uncommitted\n+         * data in memory, we let the state machine read the records from disk.\n+         */\n+        public void fireHandleCommit(long baseOffset, Records records) {\n+            BufferSupplier bufferSupplier = BufferSupplier.create();\n+            RecordsBatchReader<T> reader = new RecordsBatchReader<>(baseOffset, records,\n+                serde, bufferSupplier, this);\n+            fireHandleCommit(reader);\n+        }\n+\n+        /**\n+         * This API is used for committed records originating from {@link #scheduleAppend(int, List)}\n+         * on this instance. In this case, we are able to save the original record objects,\n+         * which saves the need to read them back from disk. This is a nice optimization\n+         * for the leader which is typically doing more work than all of the followers.\n+         */\n+        public void fireHandleCommit(long baseOffset, int epoch, List<T> records) {\n+            BatchReader.Batch<T> batch = new BatchReader.Batch<>(baseOffset, epoch, records);\n+            MemoryBatchReader<T> reader = new MemoryBatchReader<>(Collections.singletonList(batch), this);\n+            fireHandleCommit(reader);\n+        }\n+\n+        private void fireHandleCommit(BatchReader<T> reader) {\n+            synchronized (this) {\n+                this.lastSent = reader;\n+            }\n+            listener.handleCommit(reader);", "originalCommit": "867650fa2344497ac3f3505bd5058f2eae0cc0c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2NzgwNw==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r516167807", "bodyText": "Hmm... That's a good question. I guess the issue is that the listener will then be in an unknown state. Should the IO thread keep sending it updates or should it mark it as failed? This comes back to something I have been wondering in the KIP-500 world. Do we want the process to stay active if either the controller or broker listeners have failed or would it be better to shutdown? At the moment, I am leaning toward the latter. In any case, I suggest we let the errors propagate for now and file a jira to reconsider once we are closer to integration. Does that sound fair?", "author": "hachikuji", "createdAt": "2020-11-02T18:16:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzODg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3NjIwNQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r516176205", "bodyText": "At the moment, I am leaning toward the latter. In any case, I suggest we let the errors propagate for now and file a jira to reconsider once we are closer to integration. Does that sound fair?\n\nSounds fair to create a Jira and revisit this later.", "author": "jsancio", "createdAt": "2020-11-02T18:31:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzODg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMzODYyNQ==", "url": "https://github.com/apache/kafka/pull/9482#discussion_r516338625", "bodyText": "Filed https://issues.apache.org/jira/browse/KAFKA-10676.", "author": "hachikuji", "createdAt": "2020-11-02T23:45:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzODg4NA=="}], "type": "inlineReview"}, {"oid": "7e3600e16a72c139cd89ef194b4e503983b47cdb", "url": "https://github.com/apache/kafka/commit/7e3600e16a72c139cd89ef194b4e503983b47cdb", "message": "Address review comments", "committedDate": "2020-11-02T18:26:05Z", "type": "commit"}, {"oid": "dc30f4f97055c8b3f543560205f1fe597107116a", "url": "https://github.com/apache/kafka/commit/dc30f4f97055c8b3f543560205f1fe597107116a", "message": "Add basic test case for mock expiration service", "committedDate": "2020-11-02T18:39:46Z", "type": "commit"}, {"oid": "dc30f4f97055c8b3f543560205f1fe597107116a", "url": "https://github.com/apache/kafka/commit/dc30f4f97055c8b3f543560205f1fe597107116a", "message": "Add basic test case for mock expiration service", "committedDate": "2020-11-02T18:39:46Z", "type": "forcePushed"}, {"oid": "65494771be58190214d67d2d27bdd3f853fdaa6c", "url": "https://github.com/apache/kafka/commit/65494771be58190214d67d2d27bdd3f853fdaa6c", "message": "Fix typo in comment", "committedDate": "2020-11-02T18:53:46Z", "type": "commit"}]}