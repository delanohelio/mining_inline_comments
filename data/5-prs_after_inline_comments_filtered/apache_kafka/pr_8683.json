{"pr_number": 8683, "pr_title": "KAFKA-9893: Configurable TCP connection timeout and improve the initial metadata fetch", "pr_createdAt": "2020-05-18T01:41:48Z", "pr_url": "https://github.com/apache/kafka/pull/8683", "timeline": [{"oid": "f2025d7291d419eb0da01bbabe2ba36f7fb8b7bb", "url": "https://github.com/apache/kafka/commit/f2025d7291d419eb0da01bbabe2ba36f7fb8b7bb", "message": "Adding client configs and change the signature of NetworkClient", "committedDate": "2020-05-15T05:06:41Z", "type": "commit"}, {"oid": "b795a823a57cdcd664dc50932724769c49aa9b7a", "url": "https://github.com/apache/kafka/commit/b795a823a57cdcd664dc50932724769c49aa9b7a", "message": "Clean the config names and types", "committedDate": "2020-05-18T01:11:56Z", "type": "commit"}, {"oid": "57661e544f4b137fdcc53e4ec2cff5ff2ecef74c", "url": "https://github.com/apache/kafka/commit/57661e544f4b137fdcc53e4ec2cff5ff2ecef74c", "message": "Added testLeastLoadedNodeProvideDisconnectedNodesPrioritizedByFailedAttempts(), fixed the failedAttempts counting bug", "committedDate": "2020-05-18T09:25:48Z", "type": "commit"}, {"oid": "57661e544f4b137fdcc53e4ec2cff5ff2ecef74c", "url": "https://github.com/apache/kafka/commit/57661e544f4b137fdcc53e4ec2cff5ff2ecef74c", "message": "Added testLeastLoadedNodeProvideDisconnectedNodesPrioritizedByFailedAttempts(), fixed the failedAttempts counting bug", "committedDate": "2020-05-18T09:25:48Z", "type": "forcePushed"}, {"oid": "d19e5d7c8715d6d0234b166c577691f48712507c", "url": "https://github.com/apache/kafka/commit/d19e5d7c8715d6d0234b166c577691f48712507c", "message": "fix state transition", "committedDate": "2020-06-03T05:59:44Z", "type": "commit"}, {"oid": "b9118c944c5668ca00109e7d88b74c02824f2787", "url": "https://github.com/apache/kafka/commit/b9118c944c5668ca00109e7d88b74c02824f2787", "message": "Migrate static timeout to exponential timeout", "committedDate": "2020-06-05T08:39:10Z", "type": "commit"}, {"oid": "06bdd5d394086a40d75742b6904607906ec971a1", "url": "https://github.com/apache/kafka/commit/06bdd5d394086a40d75742b6904607906ec971a1", "message": "Finished the Javadoc, adding more tests", "committedDate": "2020-06-06T02:08:54Z", "type": "commit"}, {"oid": "06bdd5d394086a40d75742b6904607906ec971a1", "url": "https://github.com/apache/kafka/commit/06bdd5d394086a40d75742b6904607906ec971a1", "message": "Finished the Javadoc, adding more tests", "committedDate": "2020-06-06T02:08:54Z", "type": "forcePushed"}, {"oid": "6daba4155e6052e42985ba7f8d9572ef8cef2a01", "url": "https://github.com/apache/kafka/commit/6daba4155e6052e42985ba7f8d9572ef8cef2a01", "message": "NIT, and apply config to more clients", "committedDate": "2020-06-06T07:29:04Z", "type": "commit"}, {"oid": "6daba4155e6052e42985ba7f8d9572ef8cef2a01", "url": "https://github.com/apache/kafka/commit/6daba4155e6052e42985ba7f8d9572ef8cef2a01", "message": "NIT, and apply config to more clients", "committedDate": "2020-06-06T07:29:04Z", "type": "forcePushed"}, {"oid": "22b1b4c1a7a80df827ea6a50d82afaed004f369f", "url": "https://github.com/apache/kafka/commit/22b1b4c1a7a80df827ea6a50d82afaed004f369f", "message": "resolve merge conflict", "committedDate": "2020-06-06T15:54:03Z", "type": "commit"}, {"oid": "de0c5af8a6ad306766ca2c809161f5032f4de387", "url": "https://github.com/apache/kafka/commit/de0c5af8a6ad306766ca2c809161f5032f4de387", "message": "Fix BrokerApiVersionsCommand", "committedDate": "2020-06-06T16:22:29Z", "type": "commit"}, {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "url": "https://github.com/apache/kafka/commit/b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "message": "Support connection timeout in KafkaConfig", "committedDate": "2020-06-06T20:53:25Z", "type": "commit"}, {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "url": "https://github.com/apache/kafka/commit/b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "message": "Support connection timeout in KafkaConfig", "committedDate": "2020-06-06T20:53:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3OTYxMg==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439579612", "bodyText": "Just to be sure, we are reusing the code, but not changing the behaviour for backoff right?", "author": "rajinisivaram", "createdAt": "2020-06-12T18:28:43Z", "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -34,19 +36,22 @@\n  *\n  */\n final class ClusterConnectionStates {\n-    private final long reconnectBackoffInitMs;\n-    private final long reconnectBackoffMaxMs;\n-    private final static int RECONNECT_BACKOFF_EXP_BASE = 2;\n-    private final double reconnectBackoffMaxExp;\n     private final Map<String, NodeConnectionState> nodeState;\n     private final Logger log;\n+    private Set<String> connectingNodes;\n+    private GeometricProgression reconnectBackoff;\n+    private GeometricProgression connectionSetupTimeout;\n \n-    public ClusterConnectionStates(long reconnectBackoffMs, long reconnectBackoffMaxMs, LogContext logContext) {\n+    public ClusterConnectionStates(long reconnectBackoffMs, long reconnectBackoffMaxMs,\n+                                   long connectionSetupTimeoutMs, long connectionSetupTimeoutMaxMs,\n+                                   LogContext logContext) {\n         this.log = logContext.logger(ClusterConnectionStates.class);\n-        this.reconnectBackoffInitMs = reconnectBackoffMs;\n-        this.reconnectBackoffMaxMs = reconnectBackoffMaxMs;\n-        this.reconnectBackoffMaxExp = Math.log(this.reconnectBackoffMaxMs / (double) Math.max(reconnectBackoffMs, 1)) / Math.log(RECONNECT_BACKOFF_EXP_BASE);\n+        this.reconnectBackoff = new GeometricProgression(\n+                reconnectBackoffMs, 2, reconnectBackoffMaxMs, 0.2);", "originalCommit": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYxMTU0NA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439611544", "bodyText": "Yes, we are reusing the code.", "author": "ctan888", "createdAt": "2020-06-12T19:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3OTYxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MDUxOA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439580518", "bodyText": "why did we remove the constance and hard-code the number inline?", "author": "rajinisivaram", "createdAt": "2020-06-12T18:30:40Z", "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -34,19 +36,22 @@\n  *\n  */\n final class ClusterConnectionStates {\n-    private final long reconnectBackoffInitMs;\n-    private final long reconnectBackoffMaxMs;\n-    private final static int RECONNECT_BACKOFF_EXP_BASE = 2;", "originalCommit": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYyMTE3MA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439621170", "bodyText": "I was thinking that the existing code hardcoded the jitter. I added back the constance and also added a constance for jitter.", "author": "ctan888", "createdAt": "2020-06-12T20:10:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MDUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MjgxMQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439582811", "bodyText": "failedAttempts isn't really the number of failed connections, so not sure what we are setting timeout to.", "author": "rajinisivaram", "createdAt": "2020-06-12T18:35:47Z", "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -158,9 +165,16 @@ public InetAddress currentAddress(String id) throws UnknownHostException {\n      */\n     public void disconnected(String id, long now) {\n         NodeConnectionState nodeState = nodeState(id);\n-        nodeState.state = ConnectionState.DISCONNECTED;\n         nodeState.lastConnectAttemptMs = now;\n-        updateReconnectBackoff(nodeState);\n+        nodeState.failedAttempts++;\n+        nodeState.reconnectBackoffMs = reconnectBackoff.term(nodeState.failedAttempts - 1);\n+        if (nodeState.state == ConnectionState.CONNECTING) {\n+            nodeState.connectionSetupTimeoutMs = connectionSetupTimeout.term(nodeState.failedAttempts);", "originalCommit": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwOTk1Mg==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439609952", "bodyText": "Correct. I'll add a new class property to record connection failures separately.", "author": "ctan888", "createdAt": "2020-06-12T19:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MjgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MzY5MA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439583690", "bodyText": "Can't we keep this method to perform reset (perhaps rename the method) and include all types of reset?", "author": "rajinisivaram", "createdAt": "2020-06-12T18:37:53Z", "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -296,36 +314,6 @@ public AuthenticationException authenticationException(String id) {\n         return state != null ? state.authenticationException : null;\n     }\n \n-    /**\n-     * Resets the failure count for a node and sets the reconnect backoff to the base\n-     * value configured via reconnect.backoff.ms\n-     *\n-     * @param nodeState The node state object to update\n-     */\n-    private void resetReconnectBackoff(NodeConnectionState nodeState) {", "originalCommit": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc1MjU0MQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439752541", "bodyText": "Including all types of reset together is probably not a good choice because the reset of failed attempts and the reset of the connection timeout may happen in different places.\nHowever, I agree we should have some abstraction on the update and reset logic. I'll put the logic in new class methods.", "author": "ctan888", "createdAt": "2020-06-13T16:52:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MzY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NDY3MQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439584671", "bodyText": "Didn't we decide to call this socket.connection.setup.timeout.ms during KIP discussion? (connection instead of connections)", "author": "rajinisivaram", "createdAt": "2020-06-12T18:40:17Z", "path": "clients/src/main/java/org/apache/kafka/clients/CommonClientConfigs.java", "diffHunk": "@@ -103,6 +103,12 @@\n         Utils.join(SecurityProtocol.names(), \", \") + \".\";\n     public static final String DEFAULT_SECURITY_PROTOCOL = \"PLAINTEXT\";\n \n+    public static final String SOCKET_CONNECTIONS_SETUP_TIMEOUT_MS_CONFIG = \"socket.connections.setup.timeout.ms\";", "originalCommit": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYzMjQ3NQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439632475", "bodyText": "I think in the kip I used socket.connections.setup.timeout.ms\nSince @cmccabe also suggests socket.connection.setup.timeout.ms, I'll change the KIP proposal to stick to socket.connection.setup.timeout.ms", "author": "ctan888", "createdAt": "2020-06-12T20:39:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NDY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NTMwNw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439585307", "bodyText": "TimeOut => TimedOut", "author": "rajinisivaram", "createdAt": "2020-06-12T18:41:40Z", "path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java", "diffHunk": "@@ -554,6 +571,7 @@ private void doSend(ClientRequest clientRequest, boolean isInternalRequest, long\n         handleDisconnections(responses, updatedNow);\n         handleConnections();\n         handleInitiateApiVersionRequests(updatedNow);\n+        handleTimeOutConnections(responses, updatedNow);", "originalCommit": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc1NjMyNw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439756327", "bodyText": "Do you mean TimeOut => Timeout? Refactored.", "author": "ctan888", "createdAt": "2020-06-13T17:49:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NTMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NjQyNA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439586424", "bodyText": "Shouldn't we also check that the node is in connecting state?", "author": "rajinisivaram", "createdAt": "2020-06-12T18:44:10Z", "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -357,6 +345,37 @@ private NodeConnectionState nodeState(String id) {\n         return state;\n     }\n \n+    /**\n+     * Get the id set of nodes which are in CONNECTING state\n+     */\n+    public Set<String> connectingNodes() {\n+        return this.connectingNodes;\n+    }\n+\n+    /**\n+     * Get the timestamp of the latest connection attempt of a given node\n+     * @param id the connection to fetch the state for\n+     */\n+    public long lastConnectAttemptMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState == null ? 0 : nodeState.lastConnectAttemptMs;\n+    }\n+\n+    // Visible for testing\n+    long connectionSetupTimeoutMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState.connectionSetupTimeoutMs;\n+    }\n+\n+    /**\n+     * Test if the connection to the given node has reached its timeout\n+     * @param id the connection to fetch the state for\n+     * @param now the current time in ms\n+     */\n+    public boolean isConnectionSetupTimeout(String id, long now) {\n+        return now - lastConnectAttemptMs(id) > connectionSetupTimeoutMs(id);", "originalCommit": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY0NjY5Ng==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439646696", "bodyText": "I think we don't need to check if the node is in connecting state because the caller is only applying this test to all the nodes in the connecting state.", "author": "ctan888", "createdAt": "2020-06-12T21:19:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NjQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNjMzNw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442726337", "bodyText": "That is indeed true today as the caller only calls with nodes in connectingNodes but that may not be true forever. I would add the check as suggested by Rajini here to make the implementation safe.", "author": "dajac", "createdAt": "2020-06-19T09:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NjQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc5MzI5MA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r443793290", "bodyText": "Make sense. Checker added.", "author": "ctan888", "createdAt": "2020-06-22T20:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NjQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NjgwOQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439586809", "bodyText": "comment unnecessary since it is obvious from the line below", "author": "rajinisivaram", "createdAt": "2020-06-12T18:45:03Z", "path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java", "diffHunk": "@@ -786,6 +808,26 @@ private void handleAbortedSends(List<ClientResponse> responses) {\n         abortedSends.clear();\n     }\n \n+    /**\n+     * Handle socket channel connection timeout. The timeout will hit iff a connection\n+     * stays at the ConnectionState.CONNECTING state longer than the timeout value,\n+     * as indicated by ClusterConnectionStates.NodeConnectionState.\n+     *\n+     * @param responses The list of responses to update\n+     * @param now The current time\n+     */\n+    private void handleTimeOutConnections(List<ClientResponse> responses, long now) {\n+        Set<String> connectingNodes = connectionStates.connectingNodes();\n+        for (String nodeId: connectingNodes) {\n+            if (connectionStates.isConnectionSetupTimeout(nodeId, now)) {\n+                // close connection to the node", "originalCommit": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY0NzEwNA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439647104", "bodyText": "Line deleted.", "author": "ctan888", "createdAt": "2020-06-12T21:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NjgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4Njk5NA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439586994", "bodyText": "Can we include the timeout in the log line?", "author": "rajinisivaram", "createdAt": "2020-06-12T18:45:25Z", "path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java", "diffHunk": "@@ -786,6 +808,26 @@ private void handleAbortedSends(List<ClientResponse> responses) {\n         abortedSends.clear();\n     }\n \n+    /**\n+     * Handle socket channel connection timeout. The timeout will hit iff a connection\n+     * stays at the ConnectionState.CONNECTING state longer than the timeout value,\n+     * as indicated by ClusterConnectionStates.NodeConnectionState.\n+     *\n+     * @param responses The list of responses to update\n+     * @param now The current time\n+     */\n+    private void handleTimeOutConnections(List<ClientResponse> responses, long now) {\n+        Set<String> connectingNodes = connectionStates.connectingNodes();\n+        for (String nodeId: connectingNodes) {\n+            if (connectionStates.isConnectionSetupTimeout(nodeId, now)) {\n+                // close connection to the node\n+                this.selector.close(nodeId);\n+                log.debug(\"Disconnecting from node {} due to socket connection setup timeout.\", nodeId);", "originalCommit": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2MzA1OQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439663059", "bodyText": "Added timeout value to the log.", "author": "ctan888", "createdAt": "2020-06-12T22:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4Njk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NzY1MA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439587650", "bodyText": "Can we define the defaults in CommonClientConfigs?", "author": "rajinisivaram", "createdAt": "2020-06-12T18:46:51Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/AdminClientConfig.java", "diffHunk": "@@ -149,6 +155,16 @@\n                                         atLeast(0),\n                                         Importance.MEDIUM,\n                                         REQUEST_TIMEOUT_MS_DOC)\n+                                .define(SOCKET_CONNECTIONS_SETUP_TIMEOUT_MS_CONFIG,\n+                                        Type.LONG,\n+                                        10 * 1000,\n+                                        Importance.MEDIUM,\n+                                        CommonClientConfigs.SOCKET_CONNECTIONS_SETUP_TIMEOUT_MS_DOC)\n+                                .define(SOCKET_CONNECTIONS_SETUP_TIMEOUT_MAX_MS_CONFIG,\n+                                        Type.LONG,\n+                                        127 * 1000,", "originalCommit": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc1MTc1MQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439751751", "bodyText": "I think the current practice is to hard code the defaults in each client's config definition. Do we still want to define the defaults in CommonClientConfigs?", "author": "ctan888", "createdAt": "2020-06-13T16:38:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NzY1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NDkwNQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440674905", "bodyText": "While I also recognize that we are not consistent with this, I would do it as suggested by Rajini. The defaults are the same everywhere so it makes sense to have it defined centrally for now.", "author": "dajac", "createdAt": "2020-06-16T08:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NzY1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM4MjQ3MQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442382471", "bodyText": "Sounds good. WIll refactor.", "author": "ctan888", "createdAt": "2020-06-18T17:17:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NzY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4Nzk3NA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439587974", "bodyText": "This is not exactly a geometric progression?", "author": "rajinisivaram", "createdAt": "2020-06-12T18:47:32Z", "path": "clients/src/main/java/org/apache/kafka/common/utils/GeometricProgression.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * An util class for exponential backoff, backoff, etc...\n+ * The formula is Term(n) = random(1 - jitter, 1 + jitter) * scaleFactor * (ratio) ^ n\n+ * If scaleFactor is greater or equal than termMax, a constant term of will be provided\n+ * This class is thread-safe\n+ */\n+public class GeometricProgression {", "originalCommit": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc1MTc5Mg==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439751792", "bodyText": "The naming is kind of hard because exponential reconnect backoff, exponential retry backoff, and exponential timeout are sharing this util class at the same time. Any suggestion?", "author": "ctan888", "createdAt": "2020-06-13T16:39:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4Nzk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NjI0Ng==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440676246", "bodyText": "I would go with ExponentialBackoff even if we use it for computing an exponential timeout as well. I think that people will understand this.", "author": "dajac", "createdAt": "2020-06-16T08:27:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4Nzk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM4OTcxMQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442389711", "bodyText": "Good idea. Will go for ExponentialBackoff", "author": "ctan888", "createdAt": "2020-06-18T17:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4Nzk3NA=="}], "type": "inlineReview"}, {"oid": "982957988046b5964624d29ad916de0d5d0dfab2", "url": "https://github.com/apache/kafka/commit/982957988046b5964624d29ad916de0d5d0dfab2", "message": "Rename config, extract reset and update logic, some small NIT refactor", "committedDate": "2020-06-13T17:49:24Z", "type": "commit"}, {"oid": "982957988046b5964624d29ad916de0d5d0dfab2", "url": "https://github.com/apache/kafka/commit/982957988046b5964624d29ad916de0d5d0dfab2", "message": "Rename config, extract reset and update logic, some small NIT refactor", "committedDate": "2020-06-13T17:49:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MDkzMg==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440650932", "bodyText": "Shouldn't we increment before computing the new reconnect backoff?", "author": "dajac", "createdAt": "2020-06-16T07:45:29Z", "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -300,30 +323,48 @@ public AuthenticationException authenticationException(String id) {\n      * Resets the failure count for a node and sets the reconnect backoff to the base\n      * value configured via reconnect.backoff.ms\n      *\n-     * @param nodeState The node state object to update\n+     * @param nodeState nodeState The node state object to update\n      */\n     private void resetReconnectBackoff(NodeConnectionState nodeState) {\n         nodeState.failedAttempts = 0;\n-        nodeState.reconnectBackoffMs = this.reconnectBackoffInitMs;\n+        nodeState.reconnectBackoffMs = reconnectBackoff.term(0);\n+    }\n+\n+    /**\n+     * Resets the failure count for a node and sets the connection setup timeout to the base\n+     * value configured via socket.connection.setup.timeout.ms\n+     *\n+     * @param nodeState nodeState The node state object to update\n+     */\n+    private void resetConnectionSetupTimeout(NodeConnectionState nodeState) {\n+        nodeState.failedConnectAttempts = 0;\n+        nodeState.connectionSetupTimeoutMs = connectionSetupTimeout.term(0);\n     }\n \n     /**\n-     * Update the node reconnect backoff exponentially.\n+     * Increment the failure counter, update the node reconnect backoff exponentially,\n+     * and record the current timestamp.\n      * The delay is reconnect.backoff.ms * 2**(failures - 1) * (+/- 20% random jitter)\n      * Up to a (pre-jitter) maximum of reconnect.backoff.max.ms\n      *\n      * @param nodeState The node state object to update\n      */\n-    private void updateReconnectBackoff(NodeConnectionState nodeState) {\n-        if (this.reconnectBackoffMaxMs > this.reconnectBackoffInitMs) {\n-            nodeState.failedAttempts += 1;\n-            double backoffExp = Math.min(nodeState.failedAttempts - 1, this.reconnectBackoffMaxExp);\n-            double backoffFactor = Math.pow(RECONNECT_BACKOFF_EXP_BASE, backoffExp);\n-            long reconnectBackoffMs = (long) (this.reconnectBackoffInitMs * backoffFactor);\n-            // Actual backoff is randomized to avoid connection storms.\n-            double randomFactor = ThreadLocalRandom.current().nextDouble(0.8, 1.2);\n-            nodeState.reconnectBackoffMs = (long) (randomFactor * reconnectBackoffMs);\n-        }\n+    private void incrementReconnectBackoff(NodeConnectionState nodeState, long now) {\n+        nodeState.reconnectBackoffMs = reconnectBackoff.term(nodeState.failedAttempts);\n+        nodeState.failedAttempts++;", "originalCommit": "982957988046b5964624d29ad916de0d5d0dfab2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxNTM5OA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r441915398", "bodyText": "reconnectBackoff.term(0) will return the ${reconnect.backoff.ms} * 2 ^ 0 * jitter\nreconnectBackoff.term(1) will return the ${reconnect.backoff.ms} * 2 ^ 1 * jitter\nThe difference btw reconnect backoff and connection timeout here is that, after the first failed attempts, the connection timeout will be the 1st term of the randomized geometric sequence but the reconnect backoff will be the 0st term of the randomized geometric sequence. So We should use (failedAttempts - 1) for fetching reconnect backoff and (failedAttemps) for fetching the connection timeout.", "author": "ctan888", "createdAt": "2020-06-18T01:17:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MDkzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwMDkxNA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442700914", "bodyText": "That makes sense. Thanks for the clarification.", "author": "dajac", "createdAt": "2020-06-19T08:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MDkzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1NTk2OA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440655968", "bodyText": "Are you sure that using lastConnectAttemptMs is correct here? lastConnectAttemptMs is recorded when a connection is disconnected and as we respect the reconnectBackoffMs before reconnecting, the connection timeout computed here will also include the current reconnectBackoffMs. Is this what we want? It may be better to record the time in connecting.", "author": "dajac", "createdAt": "2020-06-16T07:53:51Z", "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -357,6 +398,36 @@ private NodeConnectionState nodeState(String id) {\n         return state;\n     }\n \n+    /**\n+     * Get the id set of nodes which are in CONNECTING state\n+     */\n+    public Set<String> connectingNodes() {\n+        return this.connectingNodes;\n+    }\n+\n+    /**\n+     * Get the timestamp of the latest connection attempt of a given node\n+     * @param id the connection to fetch the state for\n+     */\n+    public long lastConnectAttemptMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState == null ? 0 : nodeState.lastConnectAttemptMs;\n+    }\n+\n+    public long connectionSetupTimeoutMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState.connectionSetupTimeoutMs;\n+    }\n+\n+    /**\n+     * Test if the connection to the given node has reached its timeout\n+     * @param id the connection to fetch the state for\n+     * @param now the current time in ms\n+     */\n+    public boolean isConnectionSetupTimeout(String id, long now) {\n+        return now - lastConnectAttemptMs(id) > connectionSetupTimeoutMs(id);", "originalCommit": "982957988046b5964624d29ad916de0d5d0dfab2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1NTEyMw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442355123", "bodyText": "I think so. The lastConnectAttemptMs is updated in both connecting (Line 145 & Line 157) and disconnected.", "author": "ctan888", "createdAt": "2020-06-18T16:31:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1NTk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNjYwMA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442726600", "bodyText": "Oh right. I missed the ones in connecting. Thanks for the clarification.", "author": "dajac", "createdAt": "2020-06-19T09:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1NTk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1NjU4Ng==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440656586", "bodyText": "Should we ensure that nodeState is not null here?", "author": "dajac", "createdAt": "2020-06-16T07:54:53Z", "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -357,6 +398,36 @@ private NodeConnectionState nodeState(String id) {\n         return state;\n     }\n \n+    /**\n+     * Get the id set of nodes which are in CONNECTING state\n+     */\n+    public Set<String> connectingNodes() {\n+        return this.connectingNodes;\n+    }\n+\n+    /**\n+     * Get the timestamp of the latest connection attempt of a given node\n+     * @param id the connection to fetch the state for\n+     */\n+    public long lastConnectAttemptMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState == null ? 0 : nodeState.lastConnectAttemptMs;\n+    }\n+\n+    public long connectionSetupTimeoutMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState.connectionSetupTimeoutMs;", "originalCommit": "982957988046b5964624d29ad916de0d5d0dfab2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1NDMwNw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442354307", "bodyText": "No. The caller will ensure that the node is in the connecting state. I'll add an IllegalStateException here.", "author": "ctan888", "createdAt": "2020-06-18T16:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1NjU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTM5NA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442725394", "bodyText": "I would rather prefer to handle this like we did in lastConnectAttemptMs in order to remain consistent. If nodeState is null, we can return 0.", "author": "dajac", "createdAt": "2020-06-19T09:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1NjU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc4NTEzNA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r443785134", "bodyText": "When NetworkClient initializes a connection to a given node (NetworkClient::initiateConnect), it's guaranteed that the nodeState will get initialized and won't be null. I think it's probably not reasonable if the caller wants to get the connection timeout of a given node before the connection initialization, which is the reason I prevent this kind of calling by throwing the exception.\nHowever, it might be reasonable for a caller to get the lastConnectAttemptMs before initializing the connection. For example, the node provider wants to provide a node with the least recent connection attempt. For those nodes haven't been connected yet, their NodeConnectionState does not exist. However, this implies that the node has the highest priority and we may assume their lastConnectAttemptMs is 0.", "author": "ctan888", "createdAt": "2020-06-22T19:43:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1NjU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk1MTIyNg==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r444951226", "bodyText": "Thanks for the clarification. In this case, let's reuse the nodeState method which check null and throws an IllegalStateException as you do here. We may be able to use it in isConnectionSetupTimeout as well.", "author": "dajac", "createdAt": "2020-06-24T14:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1NjU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA0Mjk3NA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445042974", "bodyText": "Sure. Now isConnectionSetupTimeout is also using this checker.", "author": "ctan888", "createdAt": "2020-06-24T17:05:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1NjU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1ODc5Ng==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440658796", "bodyText": "It would be great if you could update the javadoc of the method to reflect this.", "author": "dajac", "createdAt": "2020-06-16T07:58:35Z", "path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java", "diffHunk": "@@ -678,7 +696,11 @@ public Node leastLoadedNode(long now) {\n             } else if (connectionStates.isPreparingConnection(node.idString())) {\n                 foundConnecting = node;\n             } else if (canConnect(node, now)) {\n-                foundCanConnect = node;\n+                if (foundCanConnect == null ||\n+                        this.connectionStates.lastConnectAttemptMs(foundCanConnect.idString()) >\n+                                this.connectionStates.lastConnectAttemptMs(node.idString())) {\n+                    foundCanConnect = node;\n+                }", "originalCommit": "982957988046b5964624d29ad916de0d5d0dfab2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM2MzYzMg==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442363632", "bodyText": "Yes", "author": "ctan888", "createdAt": "2020-06-18T16:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1ODc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1OTQyNg==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440659426", "bodyText": "nit: We usually put a space before and after the :.", "author": "dajac", "createdAt": "2020-06-16T07:59:41Z", "path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java", "diffHunk": "@@ -786,6 +808,29 @@ private void handleAbortedSends(List<ClientResponse> responses) {\n         abortedSends.clear();\n     }\n \n+    /**\n+     * Handle socket channel connection timeout. The timeout will hit iff a connection\n+     * stays at the ConnectionState.CONNECTING state longer than the timeout value,\n+     * as indicated by ClusterConnectionStates.NodeConnectionState.\n+     *\n+     * @param responses The list of responses to update\n+     * @param now The current time\n+     */\n+    private void handleTimeoutConnections(List<ClientResponse> responses, long now) {\n+        Set<String> connectingNodes = connectionStates.connectingNodes();\n+        for (String nodeId: connectingNodes) {", "originalCommit": "982957988046b5964624d29ad916de0d5d0dfab2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM3NTQyNA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442375424", "bodyText": "Refactored", "author": "ctan888", "createdAt": "2020-06-18T17:05:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1OTQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY2MTg5Mw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440661893", "bodyText": "This one can be removed I suppose.", "author": "dajac", "createdAt": "2020-06-16T08:03:58Z", "path": "clients/src/test/java/org/apache/kafka/common/utils/GeometricProgressionTest.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class GeometricProgressionTest {\n+    @Test\n+    public void testGeometricProgression() {\n+        long scaleFactor = 100;\n+        int ratio = 2;\n+        long termMax = 2000;\n+        double jitter = 0.2;\n+        GeometricProgression geometricProgression = new GeometricProgression(\n+                scaleFactor, ratio, termMax, jitter\n+        );\n+\n+        for (int i = 0; i <= 100; i++) {\n+            for (int n = 0; n <= 4; n++) {\n+                assertEquals(scaleFactor * Math.pow(ratio, n), geometricProgression.term(n),\n+                        scaleFactor * Math.pow(ratio, n) * jitter);\n+            }\n+            System.out.println(geometricProgression.term(5));", "originalCommit": "982957988046b5964624d29ad916de0d5d0dfab2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM4NzY2MA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442387660", "bodyText": "Oh, right. I forgot removing it.", "author": "ctan888", "createdAt": "2020-06-18T17:26:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY2MTg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3MTQ4MA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440671480", "bodyText": "nit: I would use to be established instead of to be built and I think that we should avoid putting default values in the documentation here because first the default can be changed on a per client basis and second the default will be documented based on the default value provided in config definition.", "author": "dajac", "createdAt": "2020-06-16T08:20:02Z", "path": "clients/src/main/java/org/apache/kafka/clients/CommonClientConfigs.java", "diffHunk": "@@ -103,6 +103,12 @@\n         Utils.join(SecurityProtocol.names(), \", \") + \".\";\n     public static final String DEFAULT_SECURITY_PROTOCOL = \"PLAINTEXT\";\n \n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_CONFIG = \"socket.connection.setup.timeout.ms\";\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_DOC = \"The amount of time the client will wait for the initial socket connection to be built. If the connection is not built before the timeout elapses the network client will close the socket channel. The default value will be 10 seconds.\";", "originalCommit": "982957988046b5964624d29ad916de0d5d0dfab2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM2MjY3Mw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442362673", "bodyText": "Make sense. I'll change the description and remove the defaults in the doc.", "author": "ctan888", "createdAt": "2020-06-18T16:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3MTQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3MTY0Nw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440671647", "bodyText": "Same comment as above.", "author": "dajac", "createdAt": "2020-06-16T08:20:17Z", "path": "clients/src/main/java/org/apache/kafka/clients/CommonClientConfigs.java", "diffHunk": "@@ -103,6 +103,12 @@\n         Utils.join(SecurityProtocol.names(), \", \") + \".\";\n     public static final String DEFAULT_SECURITY_PROTOCOL = \"PLAINTEXT\";\n \n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_CONFIG = \"socket.connection.setup.timeout.ms\";\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_DOC = \"The amount of time the client will wait for the initial socket connection to be built. If the connection is not built before the timeout elapses the network client will close the socket channel. The default value will be 10 seconds.\";\n+\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_CONFIG = \"socket.connection.setup.timeout.max.ms\";\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_DOC = \"The maximum amount of time the client will wait for the initial socket connection to be built. The connection setup timeout will increase exponentially for each consecutive connection failure up to this maximum. To avoid connection storms, a randomization factor of 0.2 will be applied to the backoff resulting in a random range between 20% below and 20% above the computed value. The default value will be 127 seconds.\";", "originalCommit": "982957988046b5964624d29ad916de0d5d0dfab2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM3Mjg3Mw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442372873", "bodyText": "Refactored", "author": "ctan888", "createdAt": "2020-06-18T17:00:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3MTY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3Njg2Mg==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440676862", "bodyText": "nit: What about using retries instead of n? It may help to understand that the exponential value is computed based on the number of tries or retries.", "author": "dajac", "createdAt": "2020-06-16T08:28:43Z", "path": "clients/src/main/java/org/apache/kafka/common/utils/GeometricProgression.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * An util class for exponential backoff, backoff, etc...\n+ * The formula is Term(n) = random(1 - jitter, 1 + jitter) * scaleFactor * (ratio) ^ n\n+ * If scaleFactor is greater or equal than termMax, a constant term of will be provided\n+ * This class is thread-safe\n+ */\n+public class GeometricProgression {\n+    private final int ratio;\n+    private final double expMax;\n+    private final long scaleFactor;\n+    private final double jitter;\n+\n+    public GeometricProgression(long scaleFactor, int ratio, long termMax, double jitter) {\n+        this.scaleFactor = scaleFactor;\n+        this.ratio = ratio;\n+        this.jitter = jitter;\n+        this.expMax = termMax > scaleFactor ?\n+                Math.log(termMax / (double) Math.max(scaleFactor, 1)) / Math.log(ratio) : 0;\n+    }\n+\n+    public long term(long n) {", "originalCommit": "982957988046b5964624d29ad916de0d5d0dfab2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM5NDA1OA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442394058", "bodyText": "As we noticed in your earlier comments, the same value of attempts may correspond to different terms.\nconnection_timeout = constant * 2 ^ (attempts)\nreconnect_backoff = constant * 2 ^ (attempts - 1)\n(in KIP-580) retry_backoff = constant * 2 ^ (attempts - 1)\nSo I think using retries or attempts instead of n might also confuse people. Shall we think of another naming?", "author": "ctan888", "createdAt": "2020-06-18T17:37:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3Njg2Mg=="}], "type": "inlineReview"}, {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c", "url": "https://github.com/apache/kafka/commit/27fa1cf7a07d14ad8a2677c73b4393531fabb43c", "message": "Second round refactoring", "committedDate": "2020-06-18T17:49:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTU0Nw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442725547", "bodyText": "Can we add a javadoc for this method?", "author": "dajac", "createdAt": "2020-06-19T09:13:47Z", "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -357,6 +399,38 @@ private NodeConnectionState nodeState(String id) {\n         return state;\n     }\n \n+    /**\n+     * Get the id set of nodes which are in CONNECTING state\n+     */\n+    public Set<String> connectingNodes() {\n+        return this.connectingNodes;\n+    }\n+\n+    /**\n+     * Get the timestamp of the latest connection attempt of a given node\n+     * @param id the connection to fetch the state for\n+     */\n+    public long lastConnectAttemptMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState == null ? 0 : nodeState.lastConnectAttemptMs;\n+    }\n+\n+    public long connectionSetupTimeoutMs(String id) {", "originalCommit": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc3NDU4OA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r443774588", "bodyText": "Yes. Added.", "author": "ctan888", "createdAt": "2020-06-22T19:20:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyOTI3NA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442729274", "bodyText": "We usually defined constants with capital letters and underscores to separate words. Moreover, we usually put defaults next to the config and the doc. We could use the following:\n\nSOCKET_CONNECTION_SETUP_TIMEOUT_MS_DEFAULT; and\nSOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_DEFAULT.", "author": "dajac", "createdAt": "2020-06-19T09:21:43Z", "path": "clients/src/main/java/org/apache/kafka/clients/CommonClientConfigs.java", "diffHunk": "@@ -185,4 +191,9 @@ public static void warnIfDeprecatedDnsLookupValue(AbstractConfig config) {\n                 CLIENT_DNS_LOOKUP_CONFIG, ClientDnsLookup.DEFAULT,\n                 ClientDnsLookup.USE_ALL_DNS_IPS);\n     }\n+\n+    public class Defaults {\n+        public static final long SocketConnectionSetupTimeoutMs = 10 * 1000;\n+        public static final long SocketConnectionSetupTimeoutMaxMs = 127 * 1000;", "originalCommit": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxNDI3OQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442814279", "bodyText": "In KafkaConfigs alone, we separated the defaults. For this one, we should do as @dajac suggested above (similar one is DEFAULT_SECURITY_PROTOCOL).", "author": "rajinisivaram", "createdAt": "2020-06-19T12:35:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyOTI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgwNjM0MQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r443806341", "bodyText": "I see. Refactored.", "author": "ctan888", "createdAt": "2020-06-22T20:27:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyOTI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMDA4Nw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442730087", "bodyText": "nit: I personally prefer the previous name. I would also rename handleTimeoutConnections to handleTimedOutConnections.", "author": "dajac", "createdAt": "2020-06-19T09:23:21Z", "path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java", "diffHunk": "@@ -771,7 +794,7 @@ private void processDisconnection(List<ClientResponse> responses,\n      * @param responses The list of responses to update\n      * @param now The current time\n      */\n-    private void handleTimedOutRequests(List<ClientResponse> responses, long now) {\n+    private void handleTimeoutRequests(List<ClientResponse> responses, long now) {", "originalCommit": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxMjM3MA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442812370", "bodyText": "I agree, the previous name was better", "author": "rajinisivaram", "createdAt": "2020-06-19T12:31:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMDA4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgwNzU1Mw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r443807553", "bodyText": "Sure. Refactored.", "author": "ctan888", "createdAt": "2020-06-22T20:29:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMDA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0Nzg3Ng==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442747876", "bodyText": "I find the terminology used here not intuitive. What about using something like: initialInterval, multiplier and maxInterval? I think these are more common when it comes to configuring backoff.", "author": "dajac", "createdAt": "2020-06-19T09:58:50Z", "path": "clients/src/main/java/org/apache/kafka/common/utils/ExponentialBackoff.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * An utility class for exponential backoff, timeout, etc...\n+ * The formula is Term(n) = random(1 - jitter, 1 + jitter) * scaleFactor * (ratio) ^ n\n+ * If scaleFactor is greater or equal than termMax, a constant term of will be provided\n+ * This class is thread-safe\n+ */\n+public class ExponentialBackoff {\n+    private final int ratio;\n+    private final double expMax;\n+    private final long scaleFactor;\n+    private final double jitter;\n+\n+    public ExponentialBackoff(long scaleFactor, int ratio, long termMax, double jitter) {", "originalCommit": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg4ODY0OA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r443888648", "bodyText": "I was using the naming for geometric sequences on Wikipedia. I think your suggestion also make sense. @rajinisivaram Do you think we can use initialInterval, multiplier, and maxInterval?", "author": "ctan888", "createdAt": "2020-06-23T00:03:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0Nzg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk1NDY1MA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r444954650", "bodyText": "@rajinisivaram What do you think about the proposal?", "author": "dajac", "createdAt": "2020-06-24T14:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0Nzg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAwNTU4NQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445005585", "bodyText": "Sorry, missed this earlier. Yes, I prefer initialInterval, multiplier, and maxInterval too since they fit better with  ExponentialBackoff.", "author": "rajinisivaram", "createdAt": "2020-06-24T16:04:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0Nzg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA0ODY5MA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445048690", "bodyText": "Sure. Let's use this proposal.", "author": "ctan888", "createdAt": "2020-06-24T17:15:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0Nzg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0ODU2NA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442748564", "bodyText": "nit: Let me try with another suggestion ;) What about backoff(long attempts)?", "author": "dajac", "createdAt": "2020-06-19T10:00:11Z", "path": "clients/src/main/java/org/apache/kafka/common/utils/ExponentialBackoff.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * An utility class for exponential backoff, timeout, etc...\n+ * The formula is Term(n) = random(1 - jitter, 1 + jitter) * scaleFactor * (ratio) ^ n\n+ * If scaleFactor is greater or equal than termMax, a constant term of will be provided\n+ * This class is thread-safe\n+ */\n+public class ExponentialBackoff {\n+    private final int ratio;\n+    private final double expMax;\n+    private final long scaleFactor;\n+    private final double jitter;\n+\n+    public ExponentialBackoff(long scaleFactor, int ratio, long termMax, double jitter) {\n+        this.scaleFactor = scaleFactor;\n+        this.ratio = ratio;\n+        this.jitter = jitter;\n+        this.expMax = termMax > scaleFactor ?\n+                Math.log(termMax / (double) Math.max(scaleFactor, 1)) / Math.log(ratio) : 0;\n+    }\n+\n+    public long term(long n) {", "originalCommit": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxNTc1Nw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442815757", "bodyText": "term is non-intuitive. backoff doesn't quite fit for connection timeout, but I guess it fits with ExponentialBackoff. So unless there is a better suggestion, backoff seems reasonable.", "author": "rajinisivaram", "createdAt": "2020-06-19T12:38:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0ODU2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg5MDExNQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r443890115", "bodyText": "Thanks for the suggestion. Let's use the signature backoff(long attempts) for now", "author": "ctan888", "createdAt": "2020-06-23T00:08:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0ODU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0OTg1MQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442749851", "bodyText": "nit: I would rephrase this a bit and also explain briefly how we use it in AK (e.g. connect timeout, reconnection backoff, etc.). Also, I would suggest to terminate phrases with ..", "author": "dajac", "createdAt": "2020-06-19T10:02:49Z", "path": "clients/src/main/java/org/apache/kafka/common/utils/ExponentialBackoff.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * An utility class for exponential backoff, timeout, etc...", "originalCommit": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk3MDg5OA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r443970898", "bodyText": "Sure. How does it look like now?", "author": "ctan888", "createdAt": "2020-06-23T05:29:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0OTg1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1NjE1NA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442756154", "bodyText": "nit: Could we define a local constant for the base 2 and reuse it everywhere?", "author": "dajac", "createdAt": "2020-06-19T10:16:04Z", "path": "clients/src/test/java/org/apache/kafka/clients/ClusterConnectionStatesTest.java", "diffHunk": "@@ -321,4 +325,37 @@ public void testIsPreparingConnection() {\n         connectionStates.disconnected(nodeId1, time.milliseconds());\n         assertFalse(connectionStates.isPreparingConnection(nodeId1));\n     }\n+\n+    @Test\n+    public void testExponentialConnectionSetupTimeout() {\n+        assertTrue(connectionStates.canConnect(nodeId1, time.milliseconds()));\n+\n+        // Check the exponential timeout growth\n+        for (int n = 0; n <= Math.log((double) connectionSetupTimeoutMaxMs / connectionSetupTimeoutMs) / Math.log(2); n++) {", "originalCommit": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg5MTQ0NQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r443891445", "bodyText": "Yes. I added static class properties to make the test robust.", "author": "ctan888", "createdAt": "2020-06-23T00:13:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1NjE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1NjYyNg==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442756626", "bodyText": "nit: For the jitter, what about defining a constant like reconnectBackoffJitter?", "author": "dajac", "createdAt": "2020-06-19T10:17:10Z", "path": "clients/src/test/java/org/apache/kafka/clients/ClusterConnectionStatesTest.java", "diffHunk": "@@ -321,4 +325,37 @@ public void testIsPreparingConnection() {\n         connectionStates.disconnected(nodeId1, time.milliseconds());\n         assertFalse(connectionStates.isPreparingConnection(nodeId1));\n     }\n+\n+    @Test\n+    public void testExponentialConnectionSetupTimeout() {\n+        assertTrue(connectionStates.canConnect(nodeId1, time.milliseconds()));\n+\n+        // Check the exponential timeout growth\n+        for (int n = 0; n <= Math.log((double) connectionSetupTimeoutMaxMs / connectionSetupTimeoutMs) / Math.log(2); n++) {\n+            connectionStates.connecting(nodeId1, time.milliseconds(), \"localhost\", ClientDnsLookup.DEFAULT);\n+            assertTrue(connectionStates.connectingNodes().contains(nodeId1));\n+            assertEquals(connectionSetupTimeoutMs * Math.pow(2, n),\n+                    connectionStates.connectionSetupTimeoutMs(nodeId1),\n+                    connectionSetupTimeoutMs * Math.pow(2, n) * 0.2);", "originalCommit": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkwMzEzMw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r443903133", "bodyText": "Yes. I added static class properties for specifying these parameters.", "author": "ctan888", "createdAt": "2020-06-23T00:58:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1NjYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1NzE3Mw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442757173", "bodyText": "nit: I would put connectionSetupTimeoutMaxMs first as it is the expected value. The same applies below.", "author": "dajac", "createdAt": "2020-06-19T10:18:14Z", "path": "clients/src/test/java/org/apache/kafka/clients/ClusterConnectionStatesTest.java", "diffHunk": "@@ -321,4 +325,37 @@ public void testIsPreparingConnection() {\n         connectionStates.disconnected(nodeId1, time.milliseconds());\n         assertFalse(connectionStates.isPreparingConnection(nodeId1));\n     }\n+\n+    @Test\n+    public void testExponentialConnectionSetupTimeout() {\n+        assertTrue(connectionStates.canConnect(nodeId1, time.milliseconds()));\n+\n+        // Check the exponential timeout growth\n+        for (int n = 0; n <= Math.log((double) connectionSetupTimeoutMaxMs / connectionSetupTimeoutMs) / Math.log(2); n++) {\n+            connectionStates.connecting(nodeId1, time.milliseconds(), \"localhost\", ClientDnsLookup.DEFAULT);\n+            assertTrue(connectionStates.connectingNodes().contains(nodeId1));\n+            assertEquals(connectionSetupTimeoutMs * Math.pow(2, n),\n+                    connectionStates.connectionSetupTimeoutMs(nodeId1),\n+                    connectionSetupTimeoutMs * Math.pow(2, n) * 0.2);\n+            connectionStates.disconnected(nodeId1, time.milliseconds());\n+            assertFalse(connectionStates.connectingNodes().contains(nodeId1));\n+        }\n+\n+        // Check the timeout value upper bound\n+        connectionStates.connecting(nodeId1, time.milliseconds(), \"localhost\", ClientDnsLookup.DEFAULT);\n+        assertEquals(connectionStates.connectionSetupTimeoutMs(nodeId1), connectionSetupTimeoutMaxMs, connectionSetupTimeoutMaxMs * 0.2);", "originalCommit": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkwMzM2MQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r443903361", "bodyText": "Good catch. The expected should be what you suggested. Refactored.", "author": "ctan888", "createdAt": "2020-06-23T00:59:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1NzE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc2Mzg0MQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442763841", "bodyText": "I think that it would be good to test with n=5 as well to ensure that termMax is already applied from it. Perhaps, we could do the following:\nfor (int n = 0; n <= 100; n++) {\n  if (n <= 4)\n    assertEquals(scaleFactor * Math.pow(ratio, n), exponentialBackoff.term(n),\n       scaleFactor * Math.pow(ratio, n) * jitter);\n  else\n    assertTrue(exponentialBackoff.term(1000) <= termMax * (1 + jitter));\n}", "author": "dajac", "createdAt": "2020-06-19T10:33:04Z", "path": "clients/src/test/java/org/apache/kafka/common/utils/ExponentialBackoffTest.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class ExponentialBackoffTest {\n+    @Test\n+    public void testExponentialBackoff() {\n+        long scaleFactor = 100;\n+        int ratio = 2;\n+        long termMax = 2000;\n+        double jitter = 0.2;\n+        ExponentialBackoff exponentialBackoff = new ExponentialBackoff(\n+                scaleFactor, ratio, termMax, jitter\n+        );\n+\n+        for (int i = 0; i <= 100; i++) {\n+            for (int n = 0; n <= 4; n++) {\n+                assertEquals(scaleFactor * Math.pow(ratio, n), exponentialBackoff.term(n),\n+                        scaleFactor * Math.pow(ratio, n) * jitter);\n+            }\n+            assertTrue(exponentialBackoff.term(1000) <= termMax * (1 + jitter));", "originalCommit": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzMzk1Nw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r443933957", "bodyText": "Thanks for the suggestion. I've adopted this in my test.", "author": "ctan888", "createdAt": "2020-06-23T02:59:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc2Mzg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgwODE1NA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442808154", "bodyText": "the attempt number is incremented, but backoff value is not exactly incremented. I think we should leave it as updateReconnectBackoff.", "author": "rajinisivaram", "createdAt": "2020-06-19T12:22:01Z", "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -158,9 +175,15 @@ public InetAddress currentAddress(String id) throws UnknownHostException {\n      */\n     public void disconnected(String id, long now) {\n         NodeConnectionState nodeState = nodeState(id);\n-        nodeState.state = ConnectionState.DISCONNECTED;\n         nodeState.lastConnectAttemptMs = now;\n-        updateReconnectBackoff(nodeState);\n+        incrementReconnectBackoff(nodeState);", "originalCommit": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc2OTc4Mg==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r443769782", "bodyText": "Make sense. Refactored.", "author": "ctan888", "createdAt": "2020-06-22T19:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgwODE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgwODQwNg==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442808406", "bodyText": "update instead of increment here too?", "author": "rajinisivaram", "createdAt": "2020-06-19T12:22:36Z", "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -158,9 +175,15 @@ public InetAddress currentAddress(String id) throws UnknownHostException {\n      */\n     public void disconnected(String id, long now) {\n         NodeConnectionState nodeState = nodeState(id);\n-        nodeState.state = ConnectionState.DISCONNECTED;\n         nodeState.lastConnectAttemptMs = now;\n-        updateReconnectBackoff(nodeState);\n+        incrementReconnectBackoff(nodeState);\n+        if (nodeState.state == ConnectionState.CONNECTING) {\n+            incrementConnectionSetupTimeout(nodeState);", "originalCommit": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc2OTg0NA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r443769844", "bodyText": "Refactored", "author": "ctan888", "createdAt": "2020-06-22T19:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgwODQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgwODYxMQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442808611", "bodyText": "nodeState added twice?", "author": "rajinisivaram", "createdAt": "2020-06-19T12:23:06Z", "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -300,30 +325,47 @@ public AuthenticationException authenticationException(String id) {\n      * Resets the failure count for a node and sets the reconnect backoff to the base\n      * value configured via reconnect.backoff.ms\n      *\n-     * @param nodeState The node state object to update\n+     * @param nodeState nodeState The node state object to update", "originalCommit": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc3MDIwNA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r443770204", "bodyText": "Removed.", "author": "ctan888", "createdAt": "2020-06-22T19:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgwODYxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxMTEyNA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442811124", "bodyText": "initial socket connection  - not initial?", "author": "rajinisivaram", "createdAt": "2020-06-19T12:28:24Z", "path": "clients/src/main/java/org/apache/kafka/clients/CommonClientConfigs.java", "diffHunk": "@@ -103,6 +103,12 @@\n         Utils.join(SecurityProtocol.names(), \", \") + \".\";\n     public static final String DEFAULT_SECURITY_PROTOCOL = \"PLAINTEXT\";\n \n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_CONFIG = \"socket.connection.setup.timeout.ms\";\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_DOC = \"The amount of time the client will wait for the initial socket connection to be established. If the connection is not built before the timeout elapses the network client will close the socket channel.\";\n+\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_CONFIG = \"socket.connection.setup.timeout.max.ms\";\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_DOC = \"The maximum amount of time the client will wait for the initial socket connection to be established. The connection setup timeout will increase exponentially for each consecutive connection failure up to this maximum. To avoid connection storms, a randomization factor of 0.2 will be applied to the backoff resulting in a random range between 20% below and 20% above the computed value.\";", "originalCommit": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc5NDU5OA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r443794598", "bodyText": "Yes. Refactored.", "author": "ctan888", "createdAt": "2020-06-22T20:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxMTEyNA=="}], "type": "inlineReview"}, {"oid": "3e92a0f42be128011ecda49438d67c95fbc54bbc", "url": "https://github.com/apache/kafka/commit/3e92a0f42be128011ecda49438d67c95fbc54bbc", "message": "comment adoption", "committedDate": "2020-06-23T05:30:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk0NzU5NA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r444947594", "bodyText": "We should be consistent with the naming above for DEFAULT_SECURITY_PROTOCOL and name this DEFAULT_SOCKET_CONNECTION_SETUP_TIMEOUT_MS. We seem to use xxx_DEFAULT in some places, but common configs here and in SslConfigs and SaslConfigs use DEFAULT_xxx, so let's stick to that.", "author": "rajinisivaram", "createdAt": "2020-06-24T14:43:56Z", "path": "clients/src/main/java/org/apache/kafka/clients/CommonClientConfigs.java", "diffHunk": "@@ -103,6 +103,14 @@\n         Utils.join(SecurityProtocol.names(), \", \") + \".\";\n     public static final String DEFAULT_SECURITY_PROTOCOL = \"PLAINTEXT\";\n \n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_CONFIG = \"socket.connection.setup.timeout.ms\";\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_DOC = \"The amount of time the client will wait for the socket connection to be established. If the connection is not built before the timeout elapses, clients will close the socket channel.\";\n+    public static final Long SOCKET_CONNECTION_SETUP_TIMEOUT_MS_DEFAULT = 10 * 1000L;", "originalCommit": "3e92a0f42be128011ecda49438d67c95fbc54bbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA0ODM4NA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445048384", "bodyText": "Sure. Refactored.", "author": "ctan888", "createdAt": "2020-06-24T17:14:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk0NzU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk0NzgwNA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r444947804", "bodyText": "As above, DEFAULT_SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS", "author": "rajinisivaram", "createdAt": "2020-06-24T14:44:16Z", "path": "clients/src/main/java/org/apache/kafka/clients/CommonClientConfigs.java", "diffHunk": "@@ -103,6 +103,14 @@\n         Utils.join(SecurityProtocol.names(), \", \") + \".\";\n     public static final String DEFAULT_SECURITY_PROTOCOL = \"PLAINTEXT\";\n \n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_CONFIG = \"socket.connection.setup.timeout.ms\";\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_DOC = \"The amount of time the client will wait for the socket connection to be established. If the connection is not built before the timeout elapses, clients will close the socket channel.\";\n+    public static final Long SOCKET_CONNECTION_SETUP_TIMEOUT_MS_DEFAULT = 10 * 1000L;\n+\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_CONFIG = \"socket.connection.setup.timeout.max.ms\";\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_DOC = \"The maximum amount of time the client will wait for the socket connection to be established. The connection setup timeout will increase exponentially for each consecutive connection failure up to this maximum. To avoid connection storms, a randomization factor of 0.2 will be applied to the timeout resulting in a random range between 20% below and 20% above the computed value.\";\n+    public static final Long SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_DEFAULT = 127 * 1000L;", "originalCommit": "3e92a0f42be128011ecda49438d67c95fbc54bbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2Mjc3Mw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445062773", "bodyText": "Yes.", "author": "ctan888", "createdAt": "2020-06-24T17:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk0NzgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk1NjA5MA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r444956090", "bodyText": "nit: It may be better to keep them as lower case to stay inline with the other constants. Or shall we convert all the others to upper case and to static constant?", "author": "dajac", "createdAt": "2020-06-24T14:54:38Z", "path": "clients/src/test/java/org/apache/kafka/clients/ClusterConnectionStatesTest.java", "diffHunk": "@@ -40,7 +40,12 @@\n     private final MockTime time = new MockTime();\n     private final long reconnectBackoffMs = 10 * 1000;\n     private final long reconnectBackoffMax = 60 * 1000;\n-    private final double reconnectBackoffJitter = 0.2;\n+    private final long connectionSetupTimeoutMs = 10 * 1000;\n+    private final long connectionSetupTimeoutMaxMs = 127 * 1000;\n+    private final static int RECONNECT_BACKOFF_EXP_BASE = 2;\n+    private final static double RECONNECT_BACKOFF_JITTER = 0.2;\n+    private final static int CONNECTION_SETUP_TIMEOUT_EXP_BASE = 2;\n+    private final static double CONNECTION_SETUP_TIMEOUT_JITTER = 0.2;", "originalCommit": "3e92a0f42be128011ecda49438d67c95fbc54bbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAwODcxNQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445008715", "bodyText": "We can just make the constants in ClusterConnectionStates package-private and reuse them here?", "author": "rajinisivaram", "createdAt": "2020-06-24T16:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk1NjA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1NDM4Mw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445054383", "bodyText": "Make sense. I've made them package-private and lower-cased the constants.", "author": "ctan888", "createdAt": "2020-06-24T17:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk1NjA5MA=="}], "type": "inlineReview"}, {"oid": "3a945cfa4eeb367394b32cc6f99a1bf107333e4b", "url": "https://github.com/apache/kafka/commit/3a945cfa4eeb367394b32cc6f99a1bf107333e4b", "message": "3rd round of comment adoption", "committedDate": "2020-06-24T22:45:06Z", "type": "commit"}, {"oid": "3a945cfa4eeb367394b32cc6f99a1bf107333e4b", "url": "https://github.com/apache/kafka/commit/3a945cfa4eeb367394b32cc6f99a1bf107333e4b", "message": "3rd round of comment adoption", "committedDate": "2020-06-24T22:45:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NDU3Ng==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445654576", "bodyText": "nit: This can be replaced by this.nodeState(id).", "author": "dajac", "createdAt": "2020-06-25T15:41:55Z", "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -357,6 +402,46 @@ private NodeConnectionState nodeState(String id) {\n         return state;\n     }\n \n+    /**\n+     * Get the id set of nodes which are in CONNECTING state\n+     */\n+    public Set<String> connectingNodes() {\n+        return this.connectingNodes;\n+    }\n+\n+    /**\n+     * Get the timestamp of the latest connection attempt of a given node\n+     * @param id the connection to fetch the state for\n+     */\n+    public long lastConnectAttemptMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState == null ? 0 : nodeState.lastConnectAttemptMs;\n+    }\n+\n+    /**\n+     * Get the current socket connection setup timeout of the given node.\n+     * The base value is defined via socket.connection.setup.timeout.\n+     * @param id the connection to fetch the state for\n+     */\n+    public long connectionSetupTimeoutMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        if (nodeState == null)\n+            throw new IllegalStateException(\"Connection to node \" + id + \" hasn't been initialized\");", "originalCommit": "3a945cfa4eeb367394b32cc6f99a1bf107333e4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxMTM0OQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445911349", "bodyText": "Good catch. Refactored.", "author": "ctan888", "createdAt": "2020-06-26T00:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NDU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NDc4MQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445654781", "bodyText": "nit: You can also use this.nodeState(id) here.", "author": "dajac", "createdAt": "2020-06-25T15:42:13Z", "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -357,6 +402,46 @@ private NodeConnectionState nodeState(String id) {\n         return state;\n     }\n \n+    /**\n+     * Get the id set of nodes which are in CONNECTING state\n+     */\n+    public Set<String> connectingNodes() {\n+        return this.connectingNodes;\n+    }\n+\n+    /**\n+     * Get the timestamp of the latest connection attempt of a given node\n+     * @param id the connection to fetch the state for\n+     */\n+    public long lastConnectAttemptMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState == null ? 0 : nodeState.lastConnectAttemptMs;\n+    }\n+\n+    /**\n+     * Get the current socket connection setup timeout of the given node.\n+     * The base value is defined via socket.connection.setup.timeout.\n+     * @param id the connection to fetch the state for\n+     */\n+    public long connectionSetupTimeoutMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        if (nodeState == null)\n+            throw new IllegalStateException(\"Connection to node \" + id + \" hasn't been initialized\");\n+        return nodeState.connectionSetupTimeoutMs;\n+    }\n+\n+    /**\n+     * Test if the connection to the given node has reached its timeout\n+     * @param id the connection to fetch the state for\n+     * @param now the current time in ms\n+     */\n+    public boolean isConnectionSetupTimeout(String id, long now) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);", "originalCommit": "3a945cfa4eeb367394b32cc6f99a1bf107333e4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxMTM2Mw==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445911363", "bodyText": "Good catch. Refactored.", "author": "ctan888", "createdAt": "2020-06-26T00:42:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NDc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NzEyMA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445657120", "bodyText": "Replace scaleFactor and termMax with the new terms.", "author": "dajac", "createdAt": "2020-06-25T15:45:43Z", "path": "clients/src/main/java/org/apache/kafka/common/utils/ExponentialBackoff.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * An utility class for keeping the parameters and providing the value of exponential\n+ * retry backoff, exponential reconnect backoff, exponential timeout, etc.\n+ * The formula is\n+ * Backoff(attempts) = random(1 - jitter, 1 + jitter) * initialInterval * multiplier ^ attempts\n+ * If scaleFactor is greater or equal than termMax, a constant backoff of will be provided", "originalCommit": "3a945cfa4eeb367394b32cc6f99a1bf107333e4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxMTYzOA==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445911638", "bodyText": "Replaced.", "author": "ctan888", "createdAt": "2020-06-26T00:43:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NzEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NzQ3MQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445657471", "bodyText": "nit: The formula is -> The formula is:", "author": "dajac", "createdAt": "2020-06-25T15:46:12Z", "path": "clients/src/main/java/org/apache/kafka/common/utils/ExponentialBackoff.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * An utility class for keeping the parameters and providing the value of exponential\n+ * retry backoff, exponential reconnect backoff, exponential timeout, etc.\n+ * The formula is", "originalCommit": "3a945cfa4eeb367394b32cc6f99a1bf107333e4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxMTkxNQ==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445911915", "bodyText": ": added", "author": "ctan888", "createdAt": "2020-06-26T00:44:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NzQ3MQ=="}], "type": "inlineReview"}, {"oid": "36c9cdd4d6815e56904d5b2657e5f605888e2ea5", "url": "https://github.com/apache/kafka/commit/36c9cdd4d6815e56904d5b2657e5f605888e2ea5", "message": "4th comment", "committedDate": "2020-06-26T00:44:15Z", "type": "commit"}, {"oid": "a160400df526c60ce7d6550592bbafc45ecd3539", "url": "https://github.com/apache/kafka/commit/a160400df526c60ce7d6550592bbafc45ecd3539", "message": "merge upstream", "committedDate": "2020-06-27T23:48:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcwNjAyNg==", "url": "https://github.com/apache/kafka/pull/8683#discussion_r450706026", "bodyText": "@guozhangwang Thanks for reporting the exception in this code.\n@d8tltanc @dajac This code segment is unsafe, we are removing node from connectingNodes in pprocessDisconnection() while iterating over the set. We must be missing a test too (or we have a test with only one connection).", "author": "rajinisivaram", "createdAt": "2020-07-07T08:45:49Z", "path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java", "diffHunk": "@@ -786,6 +809,29 @@ private void handleAbortedSends(List<ClientResponse> responses) {\n         abortedSends.clear();\n     }\n \n+    /**\n+     * Handle socket channel connection timeout. The timeout will hit iff a connection\n+     * stays at the ConnectionState.CONNECTING state longer than the timeout value,\n+     * as indicated by ClusterConnectionStates.NodeConnectionState.\n+     *\n+     * @param responses The list of responses to update\n+     * @param now The current time\n+     */\n+    private void handleTimedOutConnections(List<ClientResponse> responses, long now) {\n+        Set<String> connectingNodes = connectionStates.connectingNodes();\n+        for (String nodeId : connectingNodes) {\n+            if (connectionStates.isConnectionSetupTimeout(nodeId, now)) {\n+                this.selector.close(nodeId);\n+                log.debug(\n+                    \"Disconnecting from node {} due to socket connection setup timeout. \" +\n+                    \"The timeout value is {} ms.\",\n+                    nodeId,\n+                    connectionStates.connectionSetupTimeoutMs(nodeId));\n+                processDisconnection(responses, nodeId, now, ChannelState.LOCAL_CLOSE);", "originalCommit": "a160400df526c60ce7d6550592bbafc45ecd3539", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}