{"pr_number": 8326, "pr_title": "KAFKA-8639: Replace AddPartitionsToTxn with Automated Protocol ", "pr_createdAt": "2020-03-21T16:32:28Z", "pr_url": "https://github.com/apache/kafka/pull/8326", "timeline": [{"oid": "1e2c2839303eb3e1c8c010e93d752510aa7995ae", "url": "https://github.com/apache/kafka/commit/1e2c2839303eb3e1c8c010e93d752510aa7995ae", "message": "replace AddPartition", "committedDate": "2020-04-11T17:16:33Z", "type": "commit"}, {"oid": "1e2c2839303eb3e1c8c010e93d752510aa7995ae", "url": "https://github.com/apache/kafka/commit/1e2c2839303eb3e1c8c010e93d752510aa7995ae", "message": "replace AddPartition", "committedDate": "2020-04-11T17:16:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2NzcxOQ==", "url": "https://github.com/apache/kafka/pull/8326#discussion_r413367719", "bodyText": "nit: we can use map#compute to replace getOrDefault + put.", "author": "guozhangwang", "createdAt": "2020-04-22T22:11:25Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/AddPartitionsToTxnRequest.java", "diffHunk": "@@ -17,157 +17,109 @@\n package org.apache.kafka.common.requests;\n \n import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.message.AddPartitionsToTxnRequestData;\n+import org.apache.kafka.common.message.AddPartitionsToTxnRequestData.AddPartitionsToTxnTopic;\n+import org.apache.kafka.common.message.AddPartitionsToTxnRequestData.AddPartitionsToTxnTopicCollection;\n import org.apache.kafka.common.protocol.ApiKeys;\n import org.apache.kafka.common.protocol.Errors;\n-import org.apache.kafka.common.protocol.types.ArrayOf;\n-import org.apache.kafka.common.protocol.types.Field;\n-import org.apache.kafka.common.protocol.types.Schema;\n import org.apache.kafka.common.protocol.types.Struct;\n-import org.apache.kafka.common.utils.CollectionUtils;\n \n import java.nio.ByteBuffer;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n-import static org.apache.kafka.common.protocol.CommonFields.PRODUCER_EPOCH;\n-import static org.apache.kafka.common.protocol.CommonFields.PRODUCER_ID;\n-import static org.apache.kafka.common.protocol.CommonFields.TOPIC_NAME;\n-import static org.apache.kafka.common.protocol.CommonFields.TRANSACTIONAL_ID;\n-import static org.apache.kafka.common.protocol.types.Type.INT32;\n-\n public class AddPartitionsToTxnRequest extends AbstractRequest {\n-    private static final String TOPICS_KEY_NAME = \"topics\";\n-    private static final String PARTITIONS_KEY_NAME = \"partitions\";\n-\n-    private static final Schema ADD_PARTITIONS_TO_TXN_REQUEST_V0 = new Schema(\n-            TRANSACTIONAL_ID,\n-            PRODUCER_ID,\n-            PRODUCER_EPOCH,\n-            new Field(TOPICS_KEY_NAME, new ArrayOf(new Schema(\n-                    TOPIC_NAME,\n-                    new Field(PARTITIONS_KEY_NAME, new ArrayOf(INT32)))),\n-                    \"The partitions to add to the transaction.\"));\n-\n-    /**\n-     * The version number is bumped to indicate that on quota violation brokers send out responses before throttling.\n-     */\n-    private static final Schema ADD_PARTITIONS_TO_TXN_REQUEST_V1 = ADD_PARTITIONS_TO_TXN_REQUEST_V0;\n-\n-    public static Schema[] schemaVersions() {\n-        return new Schema[]{ADD_PARTITIONS_TO_TXN_REQUEST_V0, ADD_PARTITIONS_TO_TXN_REQUEST_V1};\n-    }\n+\n+    public final AddPartitionsToTxnRequestData data;\n \n     public static class Builder extends AbstractRequest.Builder<AddPartitionsToTxnRequest> {\n-        private final String transactionalId;\n-        private final long producerId;\n-        private final short producerEpoch;\n-        private final List<TopicPartition> partitions;\n+        public final AddPartitionsToTxnRequestData data;\n \n-        public Builder(String transactionalId, long producerId, short producerEpoch, List<TopicPartition> partitions) {\n+        public Builder(final AddPartitionsToTxnRequestData data) {\n             super(ApiKeys.ADD_PARTITIONS_TO_TXN);\n-            this.transactionalId = transactionalId;\n-            this.producerId = producerId;\n-            this.producerEpoch = producerEpoch;\n-            this.partitions = partitions;\n+            this.data = data;\n+        }\n+\n+        public Builder(final String transactionalId,\n+                       final long producerId,\n+                       final short producerEpoch,\n+                       final List<TopicPartition> partitions) {\n+            super(ApiKeys.ADD_PARTITIONS_TO_TXN);\n+\n+            Map<String, List<Integer>> partitionMap = new HashMap<>();\n+            for (TopicPartition topicPartition : partitions) {\n+                String topicName = topicPartition.topic();\n+\n+                List<Integer> subPartitions = partitionMap.getOrDefault(topicName,", "originalCommit": "1e2c2839303eb3e1c8c010e93d752510aa7995ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3NDM1NQ==", "url": "https://github.com/apache/kafka/pull/8326#discussion_r413374355", "bodyText": "Although today we are only calling this func once, if in the future we call it multiple times we'd pay the cycles each time to parse the map into the list. Could we cache the parsed list locally and when it is called again we can avoid Builder.getPartitions?", "author": "guozhangwang", "createdAt": "2020-04-22T22:25:25Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/AddPartitionsToTxnRequest.java", "diffHunk": "@@ -17,157 +17,109 @@\n package org.apache.kafka.common.requests;\n \n import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.message.AddPartitionsToTxnRequestData;\n+import org.apache.kafka.common.message.AddPartitionsToTxnRequestData.AddPartitionsToTxnTopic;\n+import org.apache.kafka.common.message.AddPartitionsToTxnRequestData.AddPartitionsToTxnTopicCollection;\n import org.apache.kafka.common.protocol.ApiKeys;\n import org.apache.kafka.common.protocol.Errors;\n-import org.apache.kafka.common.protocol.types.ArrayOf;\n-import org.apache.kafka.common.protocol.types.Field;\n-import org.apache.kafka.common.protocol.types.Schema;\n import org.apache.kafka.common.protocol.types.Struct;\n-import org.apache.kafka.common.utils.CollectionUtils;\n \n import java.nio.ByteBuffer;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n-import static org.apache.kafka.common.protocol.CommonFields.PRODUCER_EPOCH;\n-import static org.apache.kafka.common.protocol.CommonFields.PRODUCER_ID;\n-import static org.apache.kafka.common.protocol.CommonFields.TOPIC_NAME;\n-import static org.apache.kafka.common.protocol.CommonFields.TRANSACTIONAL_ID;\n-import static org.apache.kafka.common.protocol.types.Type.INT32;\n-\n public class AddPartitionsToTxnRequest extends AbstractRequest {\n-    private static final String TOPICS_KEY_NAME = \"topics\";\n-    private static final String PARTITIONS_KEY_NAME = \"partitions\";\n-\n-    private static final Schema ADD_PARTITIONS_TO_TXN_REQUEST_V0 = new Schema(\n-            TRANSACTIONAL_ID,\n-            PRODUCER_ID,\n-            PRODUCER_EPOCH,\n-            new Field(TOPICS_KEY_NAME, new ArrayOf(new Schema(\n-                    TOPIC_NAME,\n-                    new Field(PARTITIONS_KEY_NAME, new ArrayOf(INT32)))),\n-                    \"The partitions to add to the transaction.\"));\n-\n-    /**\n-     * The version number is bumped to indicate that on quota violation brokers send out responses before throttling.\n-     */\n-    private static final Schema ADD_PARTITIONS_TO_TXN_REQUEST_V1 = ADD_PARTITIONS_TO_TXN_REQUEST_V0;\n-\n-    public static Schema[] schemaVersions() {\n-        return new Schema[]{ADD_PARTITIONS_TO_TXN_REQUEST_V0, ADD_PARTITIONS_TO_TXN_REQUEST_V1};\n-    }\n+\n+    public final AddPartitionsToTxnRequestData data;\n \n     public static class Builder extends AbstractRequest.Builder<AddPartitionsToTxnRequest> {\n-        private final String transactionalId;\n-        private final long producerId;\n-        private final short producerEpoch;\n-        private final List<TopicPartition> partitions;\n+        public final AddPartitionsToTxnRequestData data;\n \n-        public Builder(String transactionalId, long producerId, short producerEpoch, List<TopicPartition> partitions) {\n+        public Builder(final AddPartitionsToTxnRequestData data) {\n             super(ApiKeys.ADD_PARTITIONS_TO_TXN);\n-            this.transactionalId = transactionalId;\n-            this.producerId = producerId;\n-            this.producerEpoch = producerEpoch;\n-            this.partitions = partitions;\n+            this.data = data;\n+        }\n+\n+        public Builder(final String transactionalId,\n+                       final long producerId,\n+                       final short producerEpoch,\n+                       final List<TopicPartition> partitions) {\n+            super(ApiKeys.ADD_PARTITIONS_TO_TXN);\n+\n+            Map<String, List<Integer>> partitionMap = new HashMap<>();\n+            for (TopicPartition topicPartition : partitions) {\n+                String topicName = topicPartition.topic();\n+\n+                List<Integer> subPartitions = partitionMap.getOrDefault(topicName,\n+                    new ArrayList<>());\n+                subPartitions.add(topicPartition.partition());\n+                partitionMap.put(topicName, subPartitions);\n+            }\n+\n+            AddPartitionsToTxnTopicCollection topics = new AddPartitionsToTxnTopicCollection();\n+            for (Map.Entry<String, List<Integer>> partitionEntry : partitionMap.entrySet()) {\n+                topics.add(new AddPartitionsToTxnTopic()\n+                               .setName(partitionEntry.getKey())\n+                               .setPartitions(partitionEntry.getValue()));\n+            }\n+\n+            this.data = new AddPartitionsToTxnRequestData()\n+                            .setTransactionalId(transactionalId)\n+                            .setProducerId(producerId)\n+                            .setProducerEpoch(producerEpoch)\n+                            .setTopics(topics);\n         }\n \n         @Override\n         public AddPartitionsToTxnRequest build(short version) {\n-            return new AddPartitionsToTxnRequest(version, transactionalId, producerId, producerEpoch, partitions);\n+            return new AddPartitionsToTxnRequest(data, version);\n         }\n \n         public List<TopicPartition> partitions() {\n+            return getPartitions(data);\n+        }\n+\n+        static List<TopicPartition> getPartitions(AddPartitionsToTxnRequestData data) {\n+            List<TopicPartition> partitions = new ArrayList<>();\n+            for (AddPartitionsToTxnTopic topicCollection : data.topics()) {\n+                for (Integer partition : topicCollection.partitions()) {\n+                    partitions.add(new TopicPartition(topicCollection.name(), partition));\n+                }\n+            }\n             return partitions;\n         }\n \n         @Override\n         public String toString() {\n-            StringBuilder bld = new StringBuilder();\n-            bld.append(\"(type=AddPartitionsToTxnRequest\").\n-                    append(\", transactionalId=\").append(transactionalId).\n-                    append(\", producerId=\").append(producerId).\n-                    append(\", producerEpoch=\").append(producerEpoch).\n-                    append(\", partitions=\").append(partitions).\n-                    append(\")\");\n-            return bld.toString();\n+            return data.toString();\n         }\n     }\n \n-    private final String transactionalId;\n-    private final long producerId;\n-    private final short producerEpoch;\n-    private final List<TopicPartition> partitions;\n-\n-    private AddPartitionsToTxnRequest(short version, String transactionalId, long producerId, short producerEpoch,\n-                                      List<TopicPartition> partitions) {\n+    public AddPartitionsToTxnRequest(final AddPartitionsToTxnRequestData data, short version) {\n         super(ApiKeys.ADD_PARTITIONS_TO_TXN, version);\n-        this.transactionalId = transactionalId;\n-        this.producerId = producerId;\n-        this.producerEpoch = producerEpoch;\n-        this.partitions = partitions;\n+        this.data = data;\n     }\n \n     public AddPartitionsToTxnRequest(Struct struct, short version) {\n         super(ApiKeys.ADD_PARTITIONS_TO_TXN, version);\n-        this.transactionalId = struct.get(TRANSACTIONAL_ID);\n-        this.producerId = struct.get(PRODUCER_ID);\n-        this.producerEpoch = struct.get(PRODUCER_EPOCH);\n-\n-        List<TopicPartition> partitions = new ArrayList<>();\n-        Object[] topicPartitionsArray = struct.getArray(TOPICS_KEY_NAME);\n-        for (Object topicPartitionObj : topicPartitionsArray) {\n-            Struct topicPartitionStruct = (Struct) topicPartitionObj;\n-            String topic = topicPartitionStruct.get(TOPIC_NAME);\n-            for (Object partitionObj : topicPartitionStruct.getArray(PARTITIONS_KEY_NAME)) {\n-                partitions.add(new TopicPartition(topic, (Integer) partitionObj));\n-            }\n-        }\n-        this.partitions = partitions;\n-    }\n-\n-    public String transactionalId() {\n-        return transactionalId;\n-    }\n-\n-    public long producerId() {\n-        return producerId;\n-    }\n-\n-    public short producerEpoch() {\n-        return producerEpoch;\n+        this.data = new AddPartitionsToTxnRequestData(struct, version);\n     }\n \n     public List<TopicPartition> partitions() {\n-        return partitions;\n+        return Builder.getPartitions(data);", "originalCommit": "1e2c2839303eb3e1c8c010e93d752510aa7995ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ3MTg0MA==", "url": "https://github.com/apache/kafka/pull/8326#discussion_r413471840", "bodyText": "Sg", "author": "abbccdda", "createdAt": "2020-04-23T02:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3NDM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3NDgxOQ==", "url": "https://github.com/apache/kafka/pull/8326#discussion_r413374819", "bodyText": "Same here, we can cache the result of Builder.getPartitions(data) for re-use.", "author": "guozhangwang", "createdAt": "2020-04-22T22:26:22Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/AddPartitionsToTxnRequest.java", "diffHunk": "@@ -17,157 +17,109 @@\n package org.apache.kafka.common.requests;\n \n import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.message.AddPartitionsToTxnRequestData;\n+import org.apache.kafka.common.message.AddPartitionsToTxnRequestData.AddPartitionsToTxnTopic;\n+import org.apache.kafka.common.message.AddPartitionsToTxnRequestData.AddPartitionsToTxnTopicCollection;\n import org.apache.kafka.common.protocol.ApiKeys;\n import org.apache.kafka.common.protocol.Errors;\n-import org.apache.kafka.common.protocol.types.ArrayOf;\n-import org.apache.kafka.common.protocol.types.Field;\n-import org.apache.kafka.common.protocol.types.Schema;\n import org.apache.kafka.common.protocol.types.Struct;\n-import org.apache.kafka.common.utils.CollectionUtils;\n \n import java.nio.ByteBuffer;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n-import static org.apache.kafka.common.protocol.CommonFields.PRODUCER_EPOCH;\n-import static org.apache.kafka.common.protocol.CommonFields.PRODUCER_ID;\n-import static org.apache.kafka.common.protocol.CommonFields.TOPIC_NAME;\n-import static org.apache.kafka.common.protocol.CommonFields.TRANSACTIONAL_ID;\n-import static org.apache.kafka.common.protocol.types.Type.INT32;\n-\n public class AddPartitionsToTxnRequest extends AbstractRequest {\n-    private static final String TOPICS_KEY_NAME = \"topics\";\n-    private static final String PARTITIONS_KEY_NAME = \"partitions\";\n-\n-    private static final Schema ADD_PARTITIONS_TO_TXN_REQUEST_V0 = new Schema(\n-            TRANSACTIONAL_ID,\n-            PRODUCER_ID,\n-            PRODUCER_EPOCH,\n-            new Field(TOPICS_KEY_NAME, new ArrayOf(new Schema(\n-                    TOPIC_NAME,\n-                    new Field(PARTITIONS_KEY_NAME, new ArrayOf(INT32)))),\n-                    \"The partitions to add to the transaction.\"));\n-\n-    /**\n-     * The version number is bumped to indicate that on quota violation brokers send out responses before throttling.\n-     */\n-    private static final Schema ADD_PARTITIONS_TO_TXN_REQUEST_V1 = ADD_PARTITIONS_TO_TXN_REQUEST_V0;\n-\n-    public static Schema[] schemaVersions() {\n-        return new Schema[]{ADD_PARTITIONS_TO_TXN_REQUEST_V0, ADD_PARTITIONS_TO_TXN_REQUEST_V1};\n-    }\n+\n+    public final AddPartitionsToTxnRequestData data;\n \n     public static class Builder extends AbstractRequest.Builder<AddPartitionsToTxnRequest> {\n-        private final String transactionalId;\n-        private final long producerId;\n-        private final short producerEpoch;\n-        private final List<TopicPartition> partitions;\n+        public final AddPartitionsToTxnRequestData data;\n \n-        public Builder(String transactionalId, long producerId, short producerEpoch, List<TopicPartition> partitions) {\n+        public Builder(final AddPartitionsToTxnRequestData data) {\n             super(ApiKeys.ADD_PARTITIONS_TO_TXN);\n-            this.transactionalId = transactionalId;\n-            this.producerId = producerId;\n-            this.producerEpoch = producerEpoch;\n-            this.partitions = partitions;\n+            this.data = data;\n+        }\n+\n+        public Builder(final String transactionalId,\n+                       final long producerId,\n+                       final short producerEpoch,\n+                       final List<TopicPartition> partitions) {\n+            super(ApiKeys.ADD_PARTITIONS_TO_TXN);\n+\n+            Map<String, List<Integer>> partitionMap = new HashMap<>();\n+            for (TopicPartition topicPartition : partitions) {\n+                String topicName = topicPartition.topic();\n+\n+                List<Integer> subPartitions = partitionMap.getOrDefault(topicName,\n+                    new ArrayList<>());\n+                subPartitions.add(topicPartition.partition());\n+                partitionMap.put(topicName, subPartitions);\n+            }\n+\n+            AddPartitionsToTxnTopicCollection topics = new AddPartitionsToTxnTopicCollection();\n+            for (Map.Entry<String, List<Integer>> partitionEntry : partitionMap.entrySet()) {\n+                topics.add(new AddPartitionsToTxnTopic()\n+                               .setName(partitionEntry.getKey())\n+                               .setPartitions(partitionEntry.getValue()));\n+            }\n+\n+            this.data = new AddPartitionsToTxnRequestData()\n+                            .setTransactionalId(transactionalId)\n+                            .setProducerId(producerId)\n+                            .setProducerEpoch(producerEpoch)\n+                            .setTopics(topics);\n         }\n \n         @Override\n         public AddPartitionsToTxnRequest build(short version) {\n-            return new AddPartitionsToTxnRequest(version, transactionalId, producerId, producerEpoch, partitions);\n+            return new AddPartitionsToTxnRequest(data, version);\n         }\n \n         public List<TopicPartition> partitions() {\n+            return getPartitions(data);\n+        }\n+\n+        static List<TopicPartition> getPartitions(AddPartitionsToTxnRequestData data) {\n+            List<TopicPartition> partitions = new ArrayList<>();\n+            for (AddPartitionsToTxnTopic topicCollection : data.topics()) {\n+                for (Integer partition : topicCollection.partitions()) {\n+                    partitions.add(new TopicPartition(topicCollection.name(), partition));\n+                }\n+            }\n             return partitions;\n         }\n \n         @Override\n         public String toString() {\n-            StringBuilder bld = new StringBuilder();\n-            bld.append(\"(type=AddPartitionsToTxnRequest\").\n-                    append(\", transactionalId=\").append(transactionalId).\n-                    append(\", producerId=\").append(producerId).\n-                    append(\", producerEpoch=\").append(producerEpoch).\n-                    append(\", partitions=\").append(partitions).\n-                    append(\")\");\n-            return bld.toString();\n+            return data.toString();\n         }\n     }\n \n-    private final String transactionalId;\n-    private final long producerId;\n-    private final short producerEpoch;\n-    private final List<TopicPartition> partitions;\n-\n-    private AddPartitionsToTxnRequest(short version, String transactionalId, long producerId, short producerEpoch,\n-                                      List<TopicPartition> partitions) {\n+    public AddPartitionsToTxnRequest(final AddPartitionsToTxnRequestData data, short version) {\n         super(ApiKeys.ADD_PARTITIONS_TO_TXN, version);\n-        this.transactionalId = transactionalId;\n-        this.producerId = producerId;\n-        this.producerEpoch = producerEpoch;\n-        this.partitions = partitions;\n+        this.data = data;\n     }\n \n     public AddPartitionsToTxnRequest(Struct struct, short version) {\n         super(ApiKeys.ADD_PARTITIONS_TO_TXN, version);\n-        this.transactionalId = struct.get(TRANSACTIONAL_ID);\n-        this.producerId = struct.get(PRODUCER_ID);\n-        this.producerEpoch = struct.get(PRODUCER_EPOCH);\n-\n-        List<TopicPartition> partitions = new ArrayList<>();\n-        Object[] topicPartitionsArray = struct.getArray(TOPICS_KEY_NAME);\n-        for (Object topicPartitionObj : topicPartitionsArray) {\n-            Struct topicPartitionStruct = (Struct) topicPartitionObj;\n-            String topic = topicPartitionStruct.get(TOPIC_NAME);\n-            for (Object partitionObj : topicPartitionStruct.getArray(PARTITIONS_KEY_NAME)) {\n-                partitions.add(new TopicPartition(topic, (Integer) partitionObj));\n-            }\n-        }\n-        this.partitions = partitions;\n-    }\n-\n-    public String transactionalId() {\n-        return transactionalId;\n-    }\n-\n-    public long producerId() {\n-        return producerId;\n-    }\n-\n-    public short producerEpoch() {\n-        return producerEpoch;\n+        this.data = new AddPartitionsToTxnRequestData(struct, version);\n     }\n \n     public List<TopicPartition> partitions() {\n-        return partitions;\n+        return Builder.getPartitions(data);\n     }\n \n     @Override\n     protected Struct toStruct() {\n-        Struct struct = new Struct(ApiKeys.ADD_PARTITIONS_TO_TXN.requestSchema(version()));\n-        struct.set(TRANSACTIONAL_ID, transactionalId);\n-        struct.set(PRODUCER_ID, producerId);\n-        struct.set(PRODUCER_EPOCH, producerEpoch);\n-\n-        Map<String, List<Integer>> mappedPartitions = CollectionUtils.groupPartitionsByTopic(partitions);\n-        Object[] partitionsArray = new Object[mappedPartitions.size()];\n-        int i = 0;\n-        for (Map.Entry<String, List<Integer>> topicAndPartitions : mappedPartitions.entrySet()) {\n-            Struct topicPartitionsStruct = struct.instance(TOPICS_KEY_NAME);\n-            topicPartitionsStruct.set(TOPIC_NAME, topicAndPartitions.getKey());\n-            topicPartitionsStruct.set(PARTITIONS_KEY_NAME, topicAndPartitions.getValue().toArray());\n-            partitionsArray[i++] = topicPartitionsStruct;\n-        }\n-\n-        struct.set(TOPICS_KEY_NAME, partitionsArray);\n-        return struct;\n+        return data.toStruct(version());\n     }\n \n     @Override\n     public AddPartitionsToTxnResponse getErrorResponse(int throttleTimeMs, Throwable e) {\n         final HashMap<TopicPartition, Errors> errors = new HashMap<>();\n-        for (TopicPartition partition : partitions) {\n+        for (TopicPartition partition : Builder.getPartitions(data)) {", "originalCommit": "1e2c2839303eb3e1c8c010e93d752510aa7995ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3NTk5NA==", "url": "https://github.com/apache/kafka/pull/8326#discussion_r413375994", "bodyText": "Similar here, we can cache the result in case to be reused.", "author": "guozhangwang", "createdAt": "2020-04-22T22:29:03Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/AddPartitionsToTxnResponse.java", "diffHunk": "@@ -17,129 +17,108 @@\n package org.apache.kafka.common.requests;\n \n import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.message.AddPartitionsToTxnResponseData;\n+import org.apache.kafka.common.message.AddPartitionsToTxnResponseData.AddPartitionsToTxnPartitionResult;\n+import org.apache.kafka.common.message.AddPartitionsToTxnResponseData.AddPartitionsToTxnPartitionResultCollection;\n+import org.apache.kafka.common.message.AddPartitionsToTxnResponseData.AddPartitionsToTxnTopicResult;\n+import org.apache.kafka.common.message.AddPartitionsToTxnResponseData.AddPartitionsToTxnTopicResultCollection;\n import org.apache.kafka.common.protocol.ApiKeys;\n import org.apache.kafka.common.protocol.Errors;\n-import org.apache.kafka.common.protocol.types.ArrayOf;\n-import org.apache.kafka.common.protocol.types.Field;\n-import org.apache.kafka.common.protocol.types.Schema;\n import org.apache.kafka.common.protocol.types.Struct;\n-import org.apache.kafka.common.utils.CollectionUtils;\n \n import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n import java.util.HashMap;\n-import java.util.List;\n import java.util.Map;\n \n-import static org.apache.kafka.common.protocol.CommonFields.ERROR_CODE;\n-import static org.apache.kafka.common.protocol.CommonFields.PARTITION_ID;\n-import static org.apache.kafka.common.protocol.CommonFields.THROTTLE_TIME_MS;\n-import static org.apache.kafka.common.protocol.CommonFields.TOPIC_NAME;\n-\n+/**\n+ * Possible error codes:\n+ *\n+ *   - {@link Errors#NOT_COORDINATOR}\n+ *   - {@link Errors#COORDINATOR_NOT_AVAILABLE}\n+ *   - {@link Errors#COORDINATOR_LOAD_IN_PROGRESS}\n+ *   - {@link Errors#INVALID_TXN_STATE}\n+ *   - {@link Errors#INVALID_PRODUCER_ID_MAPPING}\n+ *   - {@link Errors#INVALID_PRODUCER_EPOCH}\n+ *   - {@link Errors#TOPIC_AUTHORIZATION_FAILED}\n+ *   - {@link Errors#TRANSACTIONAL_ID_AUTHORIZATION_FAILED}\n+ *   - {@link Errors#UNKNOWN_TOPIC_OR_PARTITION}\n+ */\n public class AddPartitionsToTxnResponse extends AbstractResponse {\n-    private static final String ERRORS_KEY_NAME = \"errors\";\n-    private static final String PARTITION_ERRORS = \"partition_errors\";\n-\n-    private static final Schema ADD_PARTITIONS_TO_TXN_RESPONSE_V0 = new Schema(\n-            THROTTLE_TIME_MS,\n-            new Field(ERRORS_KEY_NAME, new ArrayOf(new Schema(\n-                    TOPIC_NAME,\n-                    new Field(PARTITION_ERRORS, new ArrayOf(new Schema(\n-                            PARTITION_ID,\n-                            ERROR_CODE)))))));\n-\n-    /**\n-     * The version number is bumped to indicate that on quota violation brokers send out responses before throttling.\n-     */\n-    private static final Schema ADD_PARTITIONS_TO_TXN_RESPONSE_V1 = ADD_PARTITIONS_TO_TXN_RESPONSE_V0;\n-\n-    public static Schema[] schemaVersions() {\n-        return new Schema[]{ADD_PARTITIONS_TO_TXN_RESPONSE_V0, ADD_PARTITIONS_TO_TXN_RESPONSE_V1};\n-    }\n \n-    private final int throttleTimeMs;\n-\n-    // Possible error codes:\n-    //   NotCoordinator\n-    //   CoordinatorNotAvailable\n-    //   CoordinatorLoadInProgress\n-    //   InvalidTxnState\n-    //   InvalidProducerIdMapping\n-    //   TopicAuthorizationFailed\n-    //   InvalidProducerEpoch\n-    //   UnknownTopicOrPartition\n-    //   TopicAuthorizationFailed\n-    //   TransactionalIdAuthorizationFailed\n-    private final Map<TopicPartition, Errors> errors;\n+    public final AddPartitionsToTxnResponseData data;\n \n-    public AddPartitionsToTxnResponse(int throttleTimeMs, Map<TopicPartition, Errors> errors) {\n-        this.throttleTimeMs = throttleTimeMs;\n-        this.errors = errors;\n+    public AddPartitionsToTxnResponse(Struct struct, short version) {\n+        this.data = new AddPartitionsToTxnResponseData(struct, version);\n     }\n \n-    public AddPartitionsToTxnResponse(Struct struct) {\n-        this.throttleTimeMs = struct.get(THROTTLE_TIME_MS);\n-        errors = new HashMap<>();\n-        for (Object topic : struct.getArray(ERRORS_KEY_NAME)) {\n-            Struct topicStruct = (Struct) topic;\n-            final String topicName = topicStruct.get(TOPIC_NAME);\n-            for (Object partition : topicStruct.getArray(PARTITION_ERRORS)) {\n-                Struct partitionStruct = (Struct) partition;\n-                TopicPartition topicPartition = new TopicPartition(topicName, partitionStruct.get(PARTITION_ID));\n-                errors.put(topicPartition, Errors.forCode(partitionStruct.get(ERROR_CODE)));\n-            }\n+    public AddPartitionsToTxnResponse(int throttleTimeMs, Map<TopicPartition, Errors> errors) {\n+\n+        Map<String, AddPartitionsToTxnPartitionResultCollection> resultMap = new HashMap<>();\n+\n+        for (Map.Entry<TopicPartition, Errors> entry : errors.entrySet()) {\n+            TopicPartition topicPartition = entry.getKey();\n+            String topicName = topicPartition.topic();\n+\n+            AddPartitionsToTxnPartitionResult partitionResult =\n+                new AddPartitionsToTxnPartitionResult()\n+                    .setErrorCode(entry.getValue().code())\n+                    .setPartitionIndex(topicPartition.partition());\n+\n+            AddPartitionsToTxnPartitionResultCollection partitionResultCollection = resultMap.getOrDefault(\n+                topicName, new AddPartitionsToTxnPartitionResultCollection()\n+            );\n+\n+            partitionResultCollection.add(partitionResult);\n+            resultMap.put(topicName, partitionResultCollection);\n+        }\n+\n+        AddPartitionsToTxnTopicResultCollection topicCollection = new AddPartitionsToTxnTopicResultCollection();\n+        for (Map.Entry<String, AddPartitionsToTxnPartitionResultCollection> entry : resultMap.entrySet()) {\n+            topicCollection.add(new AddPartitionsToTxnTopicResult()\n+                                    .setName(entry.getKey())\n+                                    .setResults(entry.getValue()));\n         }\n+\n+        this.data = new AddPartitionsToTxnResponseData()\n+                        .setThrottleTimeMs(throttleTimeMs)\n+                        .setResults(topicCollection);\n     }\n \n     @Override\n     public int throttleTimeMs() {\n-        return throttleTimeMs;\n+        return data.throttleTimeMs();\n     }\n \n     public Map<TopicPartition, Errors> errors() {\n-        return errors;\n+        Map<TopicPartition, Errors> errorsMap = new HashMap<>();", "originalCommit": "1e2c2839303eb3e1c8c010e93d752510aa7995ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4cb06d77b368276acc88df339ac456105af76e53", "url": "https://github.com/apache/kafka/commit/4cb06d77b368276acc88df339ac456105af76e53", "message": "add cached partitions", "committedDate": "2020-04-23T03:01:17Z", "type": "commit"}, {"oid": "32980c7e32353d195081f8d027dd71b09a6fbfc7", "url": "https://github.com/apache/kafka/commit/32980c7e32353d195081f8d027dd71b09a6fbfc7", "message": "address comments", "committedDate": "2020-04-23T04:09:21Z", "type": "commit"}]}