{"pr_number": 9582, "pr_title": "KAFKA-6687: rewrite topology to allow reading the same topic multiple times in the DSL", "pr_createdAt": "2020-11-10T04:29:23Z", "pr_url": "https://github.com/apache/kafka/pull/9582", "timeline": [{"oid": "cade4f52f7ac487ac7e84b3e4babdfed4deac91a", "url": "https://github.com/apache/kafka/commit/cade4f52f7ac487ac7e84b3e4babdfed4deac91a", "message": "merge source nodes and remove duplicates", "committedDate": "2020-11-13T19:12:50Z", "type": "commit"}, {"oid": "cf3d911f4eb17511a5594fccfea2f4ab94ed051f", "url": "https://github.com/apache/kafka/commit/cf3d911f4eb17511a5594fccfea2f4ab94ed051f", "message": "improve error message", "committedDate": "2020-11-13T19:12:50Z", "type": "commit"}, {"oid": "603eb0527579d7c08e2f57a9cd27a6cab4ddaf1d", "url": "https://github.com/apache/kafka/commit/603eb0527579d7c08e2f57a9cd27a6cab4ddaf1d", "message": "tests and minor fixes", "committedDate": "2020-11-13T19:12:50Z", "type": "commit"}, {"oid": "ac03bddcf15468f5f7026e1dec6fae9b796eada1", "url": "https://github.com/apache/kafka/commit/ac03bddcf15468f5f7026e1dec6fae9b796eada1", "message": "fix Pattern subscription", "committedDate": "2020-11-13T19:12:50Z", "type": "commit"}, {"oid": "9483ae9aef4bb2b0627d14003a9f4145617b8008", "url": "https://github.com/apache/kafka/commit/9483ae9aef4bb2b0627d14003a9f4145617b8008", "message": "simplify", "committedDate": "2020-11-13T19:12:50Z", "type": "commit"}, {"oid": "7eaa50be9d8a08405308207cab1390a909cbc4fa", "url": "https://github.com/apache/kafka/commit/7eaa50be9d8a08405308207cab1390a909cbc4fa", "message": "more unit test coverage", "committedDate": "2020-11-13T19:12:50Z", "type": "commit"}, {"oid": "3ad0fb057089039874b72aa62d772bebf49e24a6", "url": "https://github.com/apache/kafka/commit/3ad0fb057089039874b72aa62d772bebf49e24a6", "message": "unused import", "committedDate": "2020-11-13T19:12:50Z", "type": "commit"}, {"oid": "70a9cb690011eba3112866d0a6cc86b366ec0ef5", "url": "https://github.com/apache/kafka/commit/70a9cb690011eba3112866d0a6cc86b366ec0ef5", "message": "remove weird regex check and fix letter in test exception", "committedDate": "2020-11-13T19:12:50Z", "type": "commit"}, {"oid": "cf32d6925b2ad8506179c2694595067cc26e1b43", "url": "https://github.com/apache/kafka/commit/cf32d6925b2ad8506179c2694595067cc26e1b43", "message": "review feedback", "committedDate": "2020-11-13T19:28:33Z", "type": "commit"}, {"oid": "cf32d6925b2ad8506179c2694595067cc26e1b43", "url": "https://github.com/apache/kafka/commit/cf32d6925b2ad8506179c2694595067cc26e1b43", "message": "review feedback", "committedDate": "2020-11-13T19:28:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE4MzgyMQ==", "url": "https://github.com/apache/kafka/pull/9582#discussion_r523183821", "bodyText": "Filed https://issues.apache.org/jira/browse/KAFKA-10721", "author": "ableegoldman", "createdAt": "2020-11-13T19:41:52Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/InternalStreamsBuilder.java", "diffHunk": "@@ -314,6 +317,50 @@ public void buildAndOptimizeTopology(final Properties props) {\n         internalTopologyBuilder.validateCopartition();\n     }\n \n+    private void mergeDuplicateSourceNodes() {\n+        final Map<String, StreamSourceNode<?, ?>> topicsToSourceNodes = new HashMap<>();\n+\n+        // We don't really care about the order here, but since Pattern does not implement equals() we can't rely on\n+        // a regular HashMap and containsKey(Pattern). But for our purposes it's sufficient to compare the compiled\n+        // string and flags to determine if two pattern subscriptions can be merged into a single source node\n+        final Map<Pattern, StreamSourceNode<?, ?>> patternsToSourceNodes =\n+            new TreeMap<>(Comparator.comparing(Pattern::pattern).thenComparing(Pattern::flags));\n+\n+        for (final StreamsGraphNode graphNode : root.children()) {\n+            if (graphNode instanceof StreamSourceNode) {\n+                final StreamSourceNode<?, ?> currentSourceNode = (StreamSourceNode<?, ?>) graphNode;\n+\n+                if (currentSourceNode.topicPattern() != null) {\n+                    if (!patternsToSourceNodes.containsKey(currentSourceNode.topicPattern())) {\n+                        patternsToSourceNodes.put(currentSourceNode.topicPattern(), currentSourceNode);\n+                    } else {\n+                        final StreamSourceNode<?, ?> mainSourceNode = patternsToSourceNodes.get(currentSourceNode.topicPattern());\n+                        mainSourceNode.merge(currentSourceNode);\n+                        root.removeChild(graphNode);\n+                    }\n+                } else {\n+                    for (final String topic : currentSourceNode.topicNames()) {\n+                        if (!topicsToSourceNodes.containsKey(topic)) {\n+                            topicsToSourceNodes.put(topic, currentSourceNode);\n+                        } else {\n+                            final StreamSourceNode<?, ?> mainSourceNode = topicsToSourceNodes.get(topic);\n+                            // TODO we only merge source nodes if the subscribed topic(s) are an exact match, so it's still not\n+                            // possible to subscribe to topicA in one KStream and topicA + topicB in another. We could achieve\n+                            // this by splitting these source nodes into one topic per node and routing to the subscribed children", "originalCommit": "cf32d6925b2ad8506179c2694595067cc26e1b43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}