{"pr_number": 8312, "pr_title": "KAFKA-9432 automated protocol for DescribeConfigs", "pr_createdAt": "2020-03-18T17:47:52Z", "pr_url": "https://github.com/apache/kafka/pull/8312", "timeline": [{"oid": "141ca726f6c57470a5792f201177d6ad2d1ba4ec", "url": "https://github.com/apache/kafka/commit/141ca726f6c57470a5792f201177d6ad2d1ba4ec", "message": "KAFKA-9432 automated protocol for DescribeConfigs", "committedDate": "2020-06-08T10:42:20Z", "type": "commit"}, {"oid": "ca2e5e83c96d35a34a383101bcf50e3dff688f64", "url": "https://github.com/apache/kafka/commit/ca2e5e83c96d35a34a383101bcf50e3dff688f64", "message": "rebase", "committedDate": "2020-06-08T10:42:20Z", "type": "commit"}, {"oid": "2962bf7dacb5e7e55ebd905d3134965bdf94fde0", "url": "https://github.com/apache/kafka/commit/2962bf7dacb5e7e55ebd905d3134965bdf94fde0", "message": "Review comments", "committedDate": "2020-06-08T10:42:20Z", "type": "commit"}, {"oid": "55783db555de04aed2b949bc0787099490c55567", "url": "https://github.com/apache/kafka/commit/55783db555de04aed2b949bc0787099490c55567", "message": "Fix rebase", "committedDate": "2020-06-08T15:20:12Z", "type": "commit"}, {"oid": "c89ec9691b4438d904b89146f8ab851642100d6d", "url": "https://github.com/apache/kafka/commit/c89ec9691b4438d904b89146f8ab851642100d6d", "message": "Better test", "committedDate": "2020-06-08T15:20:12Z", "type": "commit"}, {"oid": "b5b300656a63cd53238be781d6d93d4149401083", "url": "https://github.com/apache/kafka/commit/b5b300656a63cd53238be781d6d93d4149401083", "message": "Use single request when getting BROKER & BROKER_LOGGER from same broker", "committedDate": "2020-06-08T15:20:12Z", "type": "commit"}, {"oid": "b5b300656a63cd53238be781d6d93d4149401083", "url": "https://github.com/apache/kafka/commit/b5b300656a63cd53238be781d6d93d4149401083", "message": "Use single request when getting BROKER & BROKER_LOGGER from same broker", "committedDate": "2020-06-08T15:20:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1NDEwOA==", "url": "https://github.com/apache/kafka/pull/8312#discussion_r438654108", "bodyText": "It looks like configType() is not used anymore. Can we delete it?", "author": "mimaison", "createdAt": "2020-06-11T09:19:39Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -1916,129 +1917,96 @@ void handleFailure(Throwable throwable) {\n \n     @Override\n     public DescribeConfigsResult describeConfigs(Collection<ConfigResource> configResources, final DescribeConfigsOptions options) {\n-        final Map<ConfigResource, KafkaFutureImpl<Config>> unifiedRequestFutures = new HashMap<>();\n-        final Map<ConfigResource, KafkaFutureImpl<Config>> brokerFutures = new HashMap<>(configResources.size());\n-\n-        // The BROKER resources which we want to describe.  We must make a separate DescribeConfigs\n-        // request for every BROKER resource we want to describe.\n-        final Collection<ConfigResource> brokerResources = new ArrayList<>();\n-\n-        // The non-BROKER resources which we want to describe.  These resources can be described by a\n-        // single, unified DescribeConfigs request.\n-        final Collection<ConfigResource> unifiedRequestResources = new ArrayList<>(configResources.size());\n+        // Partition the requested config resources based on which broker they must be sent to with the\n+        // null broker being used for config resources which can be obtained from any broker\n+        final Map<Integer, Map<ConfigResource, KafkaFutureImpl<Config>>> brokerFutures = new HashMap<>(configResources.size());\n \n         for (ConfigResource resource : configResources) {\n-            if (dependsOnSpecificNode(resource)) {\n-                brokerFutures.put(resource, new KafkaFutureImpl<>());\n-                brokerResources.add(resource);\n-            } else {\n-                unifiedRequestFutures.put(resource, new KafkaFutureImpl<>());\n-                unifiedRequestResources.add(resource);\n-            }\n+            Integer broker = nodeFor(resource);\n+            brokerFutures.compute(broker, (key, value) -> {\n+                if (value == null) {\n+                    // Only BROKER and BROKER_LOGGER configs are broker-specific\n+                    value = new HashMap<>(broker != null ? 2 : 16);\n+                }\n+                value.put(resource, new KafkaFutureImpl<>());\n+                return value;\n+            });\n         }\n \n         final long now = time.milliseconds();\n-        if (!unifiedRequestResources.isEmpty()) {\n+        for (Map.Entry<Integer, Map<ConfigResource, KafkaFutureImpl<Config>>> entry : brokerFutures.entrySet()) {\n+            Integer broker = entry.getKey();\n+            Map<ConfigResource, KafkaFutureImpl<Config>> unified = entry.getValue();\n+\n             runnable.call(new Call(\"describeConfigs\", calcDeadlineMs(now, options.timeoutMs()),\n-                new LeastLoadedNodeProvider()) {\n+                broker != null ? new ConstantNodeIdProvider(broker) : new LeastLoadedNodeProvider()) {\n \n                 @Override\n                 DescribeConfigsRequest.Builder createRequest(int timeoutMs) {\n-                    return new DescribeConfigsRequest.Builder(unifiedRequestResources)\n-                            .includeSynonyms(options.includeSynonyms())\n-                            .includeDocumentation(options.includeDocumentation());\n+                    return new DescribeConfigsRequest.Builder(new DescribeConfigsRequestData()\n+                        .setResources(unified.keySet().stream()\n+                            .map(config ->\n+                                new DescribeConfigsRequestData.DescribeConfigsResource()\n+                                    .setResourceName(config.name())\n+                                    .setResourceType(config.type().id()))\n+                            .collect(Collectors.toList()))\n+                        .setIncludeSynonyms(options.includeSynonyms())\n+                        .setIncludeDocumentation(options.includeDocumentation()));\n                 }\n \n                 @Override\n                 void handleResponse(AbstractResponse abstractResponse) {\n                     DescribeConfigsResponse response = (DescribeConfigsResponse) abstractResponse;\n-                    for (Map.Entry<ConfigResource, KafkaFutureImpl<Config>> entry : unifiedRequestFutures.entrySet()) {\n+                    for (Map.Entry<ConfigResource, DescribeConfigsResponseData.DescribeConfigsResult> entry : response.resultMap().entrySet()) {\n                         ConfigResource configResource = entry.getKey();\n-                        KafkaFutureImpl<Config> future = entry.getValue();\n-                        DescribeConfigsResponse.Config config = response.config(configResource);\n-                        if (config == null) {\n-                            future.completeExceptionally(new UnknownServerException(\n-                                \"Malformed broker response: missing config for \" + configResource));\n-                            continue;\n-                        }\n-                        if (config.error().isFailure()) {\n-                            future.completeExceptionally(config.error().exception());\n-                            continue;\n-                        }\n-                        List<ConfigEntry> configEntries = new ArrayList<>();\n-                        for (DescribeConfigsResponse.ConfigEntry configEntry : config.entries()) {\n-                            configEntries.add(new ConfigEntry(configEntry.name(),\n-                                    configEntry.value(), configSource(configEntry.source()),\n-                                    configEntry.isSensitive(), configEntry.isReadOnly(),\n-                                    configSynonyms(configEntry), configType(configEntry.type()),\n-                                    configEntry.documentation()));\n+                        DescribeConfigsResponseData.DescribeConfigsResult describeConfigsResult = entry.getValue();\n+                        KafkaFutureImpl<Config> future = unified.get(configResource);\n+                        if (future == null) {\n+                            if (broker != null) {\n+                                log.warn(\"The config {} in the response from broker {} is not in the request\",\n+                                        configResource, broker);\n+                            } else {\n+                                log.warn(\"The config {} in the response from the least loaded broker is not in the request\",\n+                                        configResource);\n+                            }\n+                        } else {\n+                            if (describeConfigsResult.errorCode() != Errors.NONE.code()) {\n+                                future.completeExceptionally(Errors.forCode(describeConfigsResult.errorCode())\n+                                        .exception(describeConfigsResult.errorMessage()));\n+                            } else {\n+                                future.complete(describeConfigResult(describeConfigsResult));\n+                            }\n                         }\n-                        future.complete(new Config(configEntries));\n                     }\n+                    completeUnrealizedFutures(\n+                        unified.entrySet().stream(),\n+                        configResource -> \"The broker response did not contain a result for config resource \" + configResource);\n                 }\n \n                 @Override\n                 void handleFailure(Throwable throwable) {\n-                    completeAllExceptionally(unifiedRequestFutures.values(), throwable);\n+                    completeAllExceptionally(unified.values(), throwable);\n                 }\n             }, now);\n         }\n \n-        for (Map.Entry<ConfigResource, KafkaFutureImpl<Config>> entry : brokerFutures.entrySet()) {\n-            final KafkaFutureImpl<Config> brokerFuture = entry.getValue();\n-            final ConfigResource resource = entry.getKey();\n-            final int nodeId = Integer.parseInt(resource.name());\n-            runnable.call(new Call(\"describeBrokerConfigs\", calcDeadlineMs(now, options.timeoutMs()),\n-                    new ConstantNodeIdProvider(nodeId)) {\n-\n-                @Override\n-                DescribeConfigsRequest.Builder createRequest(int timeoutMs) {\n-                    return new DescribeConfigsRequest.Builder(Collections.singleton(resource))\n-                            .includeSynonyms(options.includeSynonyms())\n-                            .includeDocumentation(options.includeDocumentation());\n-                }\n-\n-                @Override\n-                void handleResponse(AbstractResponse abstractResponse) {\n-                    DescribeConfigsResponse response = (DescribeConfigsResponse) abstractResponse;\n-                    DescribeConfigsResponse.Config config = response.configs().get(resource);\n-\n-                    if (config == null) {\n-                        brokerFuture.completeExceptionally(new UnknownServerException(\n-                            \"Malformed broker response: missing config for \" + resource));\n-                        return;\n-                    }\n-                    if (config.error().isFailure())\n-                        brokerFuture.completeExceptionally(config.error().exception());\n-                    else {\n-                        List<ConfigEntry> configEntries = new ArrayList<>();\n-                        for (DescribeConfigsResponse.ConfigEntry configEntry : config.entries()) {\n-                            configEntries.add(new ConfigEntry(configEntry.name(), configEntry.value(),\n-                                configSource(configEntry.source()), configEntry.isSensitive(), configEntry.isReadOnly(),\n-                                configSynonyms(configEntry), configType(configEntry.type()), configEntry.documentation()));", "originalCommit": "b5b300656a63cd53238be781d6d93d4149401083", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcwODUxMQ==", "url": "https://github.com/apache/kafka/pull/8312#discussion_r438708511", "bodyText": "I wonder if we can just get a Map with the default size. I don't expect this code path to be very hot", "author": "mimaison", "createdAt": "2020-06-11T11:07:32Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -1916,129 +1917,96 @@ void handleFailure(Throwable throwable) {\n \n     @Override\n     public DescribeConfigsResult describeConfigs(Collection<ConfigResource> configResources, final DescribeConfigsOptions options) {\n-        final Map<ConfigResource, KafkaFutureImpl<Config>> unifiedRequestFutures = new HashMap<>();\n-        final Map<ConfigResource, KafkaFutureImpl<Config>> brokerFutures = new HashMap<>(configResources.size());\n-\n-        // The BROKER resources which we want to describe.  We must make a separate DescribeConfigs\n-        // request for every BROKER resource we want to describe.\n-        final Collection<ConfigResource> brokerResources = new ArrayList<>();\n-\n-        // The non-BROKER resources which we want to describe.  These resources can be described by a\n-        // single, unified DescribeConfigs request.\n-        final Collection<ConfigResource> unifiedRequestResources = new ArrayList<>(configResources.size());\n+        // Partition the requested config resources based on which broker they must be sent to with the\n+        // null broker being used for config resources which can be obtained from any broker\n+        final Map<Integer, Map<ConfigResource, KafkaFutureImpl<Config>>> brokerFutures = new HashMap<>(configResources.size());\n \n         for (ConfigResource resource : configResources) {\n-            if (dependsOnSpecificNode(resource)) {\n-                brokerFutures.put(resource, new KafkaFutureImpl<>());\n-                brokerResources.add(resource);\n-            } else {\n-                unifiedRequestFutures.put(resource, new KafkaFutureImpl<>());\n-                unifiedRequestResources.add(resource);\n-            }\n+            Integer broker = nodeFor(resource);\n+            brokerFutures.compute(broker, (key, value) -> {\n+                if (value == null) {\n+                    // Only BROKER and BROKER_LOGGER configs are broker-specific\n+                    value = new HashMap<>(broker != null ? 2 : 16);", "originalCommit": "b5b300656a63cd53238be781d6d93d4149401083", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5a9c778df4037bde613452293667fd9053fdbe7d", "url": "https://github.com/apache/kafka/commit/5a9c778df4037bde613452293667fd9053fdbe7d", "message": "Review comments", "committedDate": "2020-06-11T18:15:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5MzA2NA==", "url": "https://github.com/apache/kafka/pull/8312#discussion_r439693064", "bodyText": "Hey @mimaison @tombentley, removing this constructor seems to have broken the build (it was used in TopicAdminTest). Can we get a hotfix for this to unblock other PRs?\nedit: nevermind, a PR was just opened for it (pull/8866)", "author": "ableegoldman", "createdAt": "2020-06-13T00:53:37Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/DescribeConfigsResponse.java", "diffHunk": "@@ -293,158 +208,66 @@ public ConfigSource source() {\n         }\n     }\n \n+    public Map<ConfigResource, DescribeConfigsResponseData.DescribeConfigsResult> resultMap() {\n+        return data().results().stream().collect(Collectors.toMap(\n+            configsResult ->\n+                    new ConfigResource(ConfigResource.Type.forId(configsResult.resourceType()),\n+                            configsResult.resourceName()),\n+            Function.identity()));\n+    }\n \n-    private final int throttleTimeMs;\n-    private final Map<ConfigResource, Config> configs;\n+    private final DescribeConfigsResponseData data;\n \n-    public DescribeConfigsResponse(int throttleTimeMs, Map<ConfigResource, Config> configs) {\n-        this.throttleTimeMs = throttleTimeMs;\n-        this.configs = Objects.requireNonNull(configs, \"configs\");", "originalCommit": "5a9c778df4037bde613452293667fd9053fdbe7d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}