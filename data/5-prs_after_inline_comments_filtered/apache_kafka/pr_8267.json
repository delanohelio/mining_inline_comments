{"pr_number": 8267, "pr_title": "KAFKA-6647: Do note delete the lock file while holding the lock", "pr_createdAt": "2020-03-10T23:13:53Z", "pr_url": "https://github.com/apache/kafka/pull/8267", "timeline": [{"oid": "0d3aceb5702c0f07ebae8524ec973abd8126695a", "url": "https://github.com/apache/kafka/commit/0d3aceb5702c0f07ebae8524ec973abd8126695a", "message": "first try", "committedDate": "2020-03-10T00:25:27Z", "type": "commit"}, {"oid": "7e0a5038991cc473f376c8d43c8a26c8a484b404", "url": "https://github.com/apache/kafka/commit/7e0a5038991cc473f376c8d43c8a26c8a484b404", "message": "pass in LOCK_FILE_NAME", "committedDate": "2020-03-10T00:26:23Z", "type": "commit"}, {"oid": "fe259171a744f9fcc52c09e008621e03d0ee0558", "url": "https://github.com/apache/kafka/commit/fe259171a744f9fcc52c09e008621e03d0ee0558", "message": "refactoring", "committedDate": "2020-03-10T01:15:39Z", "type": "commit"}, {"oid": "22844d00ccdf50a003f4407d5ba167969c3014dd", "url": "https://github.com/apache/kafka/commit/22844d00ccdf50a003f4407d5ba167969c3014dd", "message": "final fix", "committedDate": "2020-03-10T03:15:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2NDI1Mg==", "url": "https://github.com/apache/kafka/pull/8267#discussion_r390664252", "bodyText": "This is a minor code clean up.", "author": "guozhangwang", "createdAt": "2020-03-10T23:15:05Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -294,61 +302,69 @@ private synchronized void cleanRemovedTasks(final long cleanupDelayMs,\n             final String dirName = taskDir.getName();\n             final TaskId id = TaskId.parse(dirName);\n             if (!locks.containsKey(id)) {\n+                Exception exception = null;\n                 try {\n                     if (lock(id)) {\n                         final long now = time.milliseconds();\n                         final long lastModifiedMs = taskDir.lastModified();\n-                        if (now > lastModifiedMs + cleanupDelayMs || manualUserCall) {\n-                            if (!manualUserCall) {\n-                                log.info(\n-                                    \"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n-                                    logPrefix(),\n-                                    dirName,\n-                                    id,\n-                                    now - lastModifiedMs,\n-                                    cleanupDelayMs);\n-                            } else {\n-                                log.info(\n-                                        \"{} Deleting state directory {} for task {} as user calling cleanup.\",\n-                                        logPrefix(),\n-                                        dirName,\n-                                        id);\n-                            }\n-                            Utils.delete(taskDir);\n+                        if (now > lastModifiedMs + cleanupDelayMs) {\n+                            log.info(\"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n+                                logPrefix(), dirName, id, now - lastModifiedMs, cleanupDelayMs);\n+\n+                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n+                        } else if (manualUserCall) {\n+                            log.info(\"{} Deleting state directory {} for task {} as user calling cleanup.\",\n+                                logPrefix(), dirName, id);\n+\n+                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n                         }\n                     }\n-                } catch (final OverlappingFileLockException e) {\n-                    // locked by another thread\n-                    if (manualUserCall) {\n-                        log.error(\"{} Failed to get the state directory lock.\", logPrefix(), e);\n-                        throw e;\n-                    }\n-                } catch (final IOException e) {\n-                    log.error(\"{} Failed to delete the state directory.\", logPrefix(), e);\n-                    if (manualUserCall) {\n-                        throw e;\n-                    }\n+                } catch (final OverlappingFileLockException | IOException e) {", "originalCommit": "22844d00ccdf50a003f4407d5ba167969c3014dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2NDY5OQ==", "url": "https://github.com/apache/kafka/pull/8267#discussion_r390664699", "bodyText": "This is a bit tricky: for the root file, we only consider deleting it if there's no specified skipping sub-files; otherwise we never try to delete since it would doom with DirectoryNotEmpty.", "author": "guozhangwang", "createdAt": "2020-03-10T23:16:14Z", "path": "clients/src/main/java/org/apache/kafka/common/utils/Utils.java", "diffHunk": "@@ -736,29 +736,56 @@ public static Properties mkProperties(final Map<String, String> properties) {\n     /**\n      * Recursively delete the given file/directory and any subfiles (if any exist)\n      *\n-     * @param file The root file at which to begin deleting\n+     * @param rootFile The root file at which to begin deleting\n      */\n-    public static void delete(final File file) throws IOException {\n-        if (file == null)\n+    public static void delete(final File rootFile) throws IOException {\n+        delete(rootFile, Collections.emptyList());\n+    }\n+\n+    /**\n+     * Recursively delete the subfiles (if any exist) of the passed in root file that are not included\n+     * in the list to keep\n+     *\n+     * @param rootFile The root file at which to begin deleting\n+     * @param filesToKeep The subfiles to keep (note that if a subfile is to be kept, so are all its parent\n+     *                    files in its pat)h; if empty we would also delete the root file\n+     */\n+    public static void delete(final File rootFile, final List<File> filesToKeep) throws IOException {\n+        if (rootFile == null)\n             return;\n-        Files.walkFileTree(file.toPath(), new SimpleFileVisitor<Path>() {\n+        Files.walkFileTree(rootFile.toPath(), new SimpleFileVisitor<Path>() {\n             @Override\n             public FileVisitResult visitFileFailed(Path path, IOException exc) throws IOException {\n                 // If the root path did not exist, ignore the error; otherwise throw it.\n-                if (exc instanceof NoSuchFileException && path.toFile().equals(file))\n+                if (exc instanceof NoSuchFileException && path.toFile().equals(rootFile))\n                     return FileVisitResult.TERMINATE;\n                 throw exc;\n             }\n \n             @Override\n             public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException {\n-                Files.delete(path);\n+                if (!filesToKeep.contains(path.toFile())) {\n+                    Files.delete(path);\n+                }\n                 return FileVisitResult.CONTINUE;\n             }\n \n             @Override\n             public FileVisitResult postVisitDirectory(Path path, IOException exc) throws IOException {\n-                Files.delete(path);\n+                // KAFKA-8999: if there's an exception thrown previously already, we should throw it\n+                if (exc != null) {\n+                    throw exc;\n+                }\n+\n+                if (rootFile.toPath().equals(path)) {", "originalCommit": "22844d00ccdf50a003f4407d5ba167969c3014dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYyNDA0Mw==", "url": "https://github.com/apache/kafka/pull/8267#discussion_r392624043", "bodyText": "It would be good to avoid the unnecessary conversions in this method (rootFile.toPath, path.toFile). We can do some work at the start of the method to improve efficiency.", "author": "ijuma", "createdAt": "2020-03-14T22:23:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2NDY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY4OTE1OA==", "url": "https://github.com/apache/kafka/pull/8267#discussion_r390689158", "bodyText": "What do you think about renaming this, eg  something like isStateful, hasStatefulTopology`, etc?\nIt's really confusing to reason about in its usage, for example why createStateDirectory => #lock returns true.  You have to backtrack to where createStateDirectory is set to understand this. However, I think it's easy to reason about why isStateful => should create state directory.\nAlternatively, what if we have a stateless version of the StateDirectory class that just stubs things where appropriate. Then we could get rid of this altogether. WDYT?", "author": "ableegoldman", "createdAt": "2020-03-11T00:42:48Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -50,11 +51,12 @@\n     static final String LOCK_FILE_NAME = \".lock\";\n     private static final Logger log = LoggerFactory.getLogger(StateDirectory.class);\n \n+    private final Time time;\n+    private final String appId;\n     private final File stateDir;\n     private final boolean createStateDirectory;", "originalCommit": "22844d00ccdf50a003f4407d5ba167969c3014dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzODYzNg==", "url": "https://github.com/apache/kafka/pull/8267#discussion_r392338636", "bodyText": "That makes sense, I will do the renaming.", "author": "guozhangwang", "createdAt": "2020-03-13T16:32:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY4OTE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY5MTY1NQ==", "url": "https://github.com/apache/kafka/pull/8267#discussion_r390691655", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                File[] lisAllTaskDirectories() {\n          \n          \n            \n                File[] listAllTaskDirectories() {", "author": "ableegoldman", "createdAt": "2020-03-11T00:52:50Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -294,61 +302,69 @@ private synchronized void cleanRemovedTasks(final long cleanupDelayMs,\n             final String dirName = taskDir.getName();\n             final TaskId id = TaskId.parse(dirName);\n             if (!locks.containsKey(id)) {\n+                Exception exception = null;\n                 try {\n                     if (lock(id)) {\n                         final long now = time.milliseconds();\n                         final long lastModifiedMs = taskDir.lastModified();\n-                        if (now > lastModifiedMs + cleanupDelayMs || manualUserCall) {\n-                            if (!manualUserCall) {\n-                                log.info(\n-                                    \"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n-                                    logPrefix(),\n-                                    dirName,\n-                                    id,\n-                                    now - lastModifiedMs,\n-                                    cleanupDelayMs);\n-                            } else {\n-                                log.info(\n-                                        \"{} Deleting state directory {} for task {} as user calling cleanup.\",\n-                                        logPrefix(),\n-                                        dirName,\n-                                        id);\n-                            }\n-                            Utils.delete(taskDir);\n+                        if (now > lastModifiedMs + cleanupDelayMs) {\n+                            log.info(\"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n+                                logPrefix(), dirName, id, now - lastModifiedMs, cleanupDelayMs);\n+\n+                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n+                        } else if (manualUserCall) {\n+                            log.info(\"{} Deleting state directory {} for task {} as user calling cleanup.\",\n+                                logPrefix(), dirName, id);\n+\n+                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n                         }\n                     }\n-                } catch (final OverlappingFileLockException e) {\n-                    // locked by another thread\n-                    if (manualUserCall) {\n-                        log.error(\"{} Failed to get the state directory lock.\", logPrefix(), e);\n-                        throw e;\n-                    }\n-                } catch (final IOException e) {\n-                    log.error(\"{} Failed to delete the state directory.\", logPrefix(), e);\n-                    if (manualUserCall) {\n-                        throw e;\n-                    }\n+                } catch (final OverlappingFileLockException | IOException e) {\n+                    exception = e;\n                 } finally {\n                     try {\n                         unlock(id);\n-                    } catch (final IOException e) {\n-                        log.error(\"{} Failed to release the state directory lock.\", logPrefix());\n+\n+                        // for manual user call, stream threads are not running so it is safe to delete\n+                        // the whole directory\n                         if (manualUserCall) {\n-                            throw e;\n+                            Utils.delete(taskDir);\n                         }\n+                    } catch (final IOException e) {\n+                        exception = e;\n                     }\n                 }\n+\n+                if (exception != null && manualUserCall) {\n+                    log.error(\"{} Failed to release the state directory lock.\", logPrefix());\n+                    throw exception;\n+                }\n             }\n         }\n     }\n \n+    /**\n+     * List all of the task directories that are non-empty\n+     * @return The list of all the non-empty local directories for stream tasks\n+     */\n+    File[] listNonEmptyTaskDirectories() {\n+        return !stateDir.exists() ? new File[0] :\n+            stateDir.listFiles(pathname -> {\n+                if (!pathname.isDirectory() || !PATH_NAME.matcher(pathname.getName()).matches()) {\n+                    return false;\n+                } else {\n+                    return !taskDirEmpty(pathname);\n+                }\n+            });\n+    }\n+\n     /**\n      * List all of the task directories\n      * @return The list of all the existing local directories for stream tasks\n      */\n-    File[] listTaskDirectories() {\n+    File[] lisAllTaskDirectories() {", "originalCommit": "22844d00ccdf50a003f4407d5ba167969c3014dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "83b7fbe6885123011ef90d2220e18b2150c6a9aa", "url": "https://github.com/apache/kafka/commit/83b7fbe6885123011ef90d2220e18b2150c6a9aa", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into K6647-do-not-delete-lock-filet", "committedDate": "2020-03-12T23:07:25Z", "type": "commit"}, {"oid": "e9618b165e97b3f54d5cff0a43ab7d812212896d", "url": "https://github.com/apache/kafka/commit/e9618b165e97b3f54d5cff0a43ab7d812212896d", "message": "unit tests", "committedDate": "2020-03-13T01:26:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAyMjA0NA==", "url": "https://github.com/apache/kafka/pull/8267#discussion_r392022044", "bodyText": "Is the double negative intentional here?", "author": "vvcephei", "createdAt": "2020-03-13T04:11:32Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StateDirectoryTest.java", "diffHunk": "@@ -290,15 +307,21 @@ public void shouldNotRemoveNonTaskDirectoriesAndFiles() {\n     }\n \n     @Test\n-    public void shouldListAllTaskDirectories() {\n+    public void shouldNotListNonEmptyTaskDirectories() {", "originalCommit": "e9618b165e97b3f54d5cff0a43ab7d812212896d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM0NDMyMg==", "url": "https://github.com/apache/kafka/pull/8267#discussion_r392344322", "bodyText": "Good call, will change.", "author": "guozhangwang", "createdAt": "2020-03-13T16:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAyMjA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAyMzAzMw==", "url": "https://github.com/apache/kafka/pull/8267#discussion_r392023033", "bodyText": "This comment makes me wonder why we even bother with locking at all for manual calls. If we know there\u2019s no app running, why not just delete the whole state directory and not bother with locks?", "author": "vvcephei", "createdAt": "2020-03-13T04:16:48Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -294,61 +302,69 @@ private synchronized void cleanRemovedTasks(final long cleanupDelayMs,\n             final String dirName = taskDir.getName();\n             final TaskId id = TaskId.parse(dirName);\n             if (!locks.containsKey(id)) {\n+                Exception exception = null;\n                 try {\n                     if (lock(id)) {\n                         final long now = time.milliseconds();\n                         final long lastModifiedMs = taskDir.lastModified();\n-                        if (now > lastModifiedMs + cleanupDelayMs || manualUserCall) {\n-                            if (!manualUserCall) {\n-                                log.info(\n-                                    \"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n-                                    logPrefix(),\n-                                    dirName,\n-                                    id,\n-                                    now - lastModifiedMs,\n-                                    cleanupDelayMs);\n-                            } else {\n-                                log.info(\n-                                        \"{} Deleting state directory {} for task {} as user calling cleanup.\",\n-                                        logPrefix(),\n-                                        dirName,\n-                                        id);\n-                            }\n-                            Utils.delete(taskDir);\n+                        if (now > lastModifiedMs + cleanupDelayMs) {\n+                            log.info(\"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n+                                logPrefix(), dirName, id, now - lastModifiedMs, cleanupDelayMs);\n+\n+                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n+                        } else if (manualUserCall) {\n+                            log.info(\"{} Deleting state directory {} for task {} as user calling cleanup.\",\n+                                logPrefix(), dirName, id);\n+\n+                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n                         }\n                     }\n-                } catch (final OverlappingFileLockException e) {\n-                    // locked by another thread\n-                    if (manualUserCall) {\n-                        log.error(\"{} Failed to get the state directory lock.\", logPrefix(), e);\n-                        throw e;\n-                    }\n-                } catch (final IOException e) {\n-                    log.error(\"{} Failed to delete the state directory.\", logPrefix(), e);\n-                    if (manualUserCall) {\n-                        throw e;\n-                    }\n+                } catch (final OverlappingFileLockException | IOException e) {\n+                    exception = e;\n                 } finally {\n                     try {\n                         unlock(id);\n-                    } catch (final IOException e) {\n-                        log.error(\"{} Failed to release the state directory lock.\", logPrefix());\n+\n+                        // for manual user call, stream threads are not running so it is safe to delete", "originalCommit": "e9618b165e97b3f54d5cff0a43ab7d812212896d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM0NjE2Nw==", "url": "https://github.com/apache/kafka/pull/8267#discussion_r392346167", "bodyText": "I thought about that too, and tried it out, it's just that based on manualUserCall to decide whether lock / unlock the block, we ended up with either much more code duplicates or clumsy and finer-grained if else condition, neither of which I like. On the other hand, since streams.cleanUp is usually a one-time thing compared with the periodic internal clean I think having two delete calls are okay to same some code duplication here.", "author": "guozhangwang", "createdAt": "2020-03-13T16:44:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAyMzAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM5NjQ5Mg==", "url": "https://github.com/apache/kafka/pull/8267#discussion_r392396492", "bodyText": "Ok!", "author": "vvcephei", "createdAt": "2020-03-13T18:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAyMzAzMw=="}], "type": "inlineReview"}, {"oid": "b963e3afdc15491dcb7e69e8880324d3cb6cfa3b", "url": "https://github.com/apache/kafka/commit/b963e3afdc15491dcb7e69e8880324d3cb6cfa3b", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into K6647-do-not-delete-lock-file", "committedDate": "2020-03-13T16:32:01Z", "type": "commit"}, {"oid": "9e3146062c7acfbfd8aab05bc574016ad6a4a398", "url": "https://github.com/apache/kafka/commit/9e3146062c7acfbfd8aab05bc574016ad6a4a398", "message": "address github comments", "committedDate": "2020-03-13T16:45:27Z", "type": "commit"}, {"oid": "e55dd4f1672ec1dd1e15d35b5de54afc8cb6f826", "url": "https://github.com/apache/kafka/commit/e55dd4f1672ec1dd1e15d35b5de54afc8cb6f826", "message": "resolve conflicts from trunk", "committedDate": "2020-03-14T20:14:16Z", "type": "commit"}, {"oid": "e76956090f1b8010efb5b1be9dc7a24a7b9884a6", "url": "https://github.com/apache/kafka/commit/e76956090f1b8010efb5b1be9dc7a24a7b9884a6", "message": "fix unit tests and renaming", "committedDate": "2020-03-14T20:46:51Z", "type": "commit"}]}