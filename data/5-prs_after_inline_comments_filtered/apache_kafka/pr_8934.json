{"pr_number": 8934, "pr_title": "KAFKA-10134: Use long poll if we do not have fetchable partitions", "pr_createdAt": "2020-06-27T00:40:15Z", "pr_url": "https://github.com/apache/kafka/pull/8934", "timeline": [{"oid": "c102aaac5ce3237f347e35e950bcd199d87645df", "url": "https://github.com/apache/kafka/commit/c102aaac5ce3237f347e35e950bcd199d87645df", "message": "only block if we do not have fetchable partitions", "committedDate": "2020-06-27T00:35:53Z", "type": "commit"}, {"oid": "830d4dd779376ddb9d1c0faee3b7afab01d177ad", "url": "https://github.com/apache/kafka/commit/830d4dd779376ddb9d1c0faee3b7afab01d177ad", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into K10134-long-poll-metadata-update", "committedDate": "2020-07-01T03:27:20Z", "type": "commit"}, {"oid": "333a967ec22ea22babf32b18349b76b6552a2fac", "url": "https://github.com/apache/kafka/commit/333a967ec22ea22babf32b18349b76b6552a2fac", "message": "use binary exponential timeout", "committedDate": "2020-07-01T05:36:50Z", "type": "commit"}, {"oid": "2242b0224943134bd682c0b1d3f7b1d4950dd15a", "url": "https://github.com/apache/kafka/commit/2242b0224943134bd682c0b1d3f7b1d4950dd15a", "message": "remove func", "committedDate": "2020-07-01T18:15:17Z", "type": "commit"}, {"oid": "0516d9a879a229e74e25ae2f06f022512861a437", "url": "https://github.com/apache/kafka/commit/0516d9a879a229e74e25ae2f06f022512861a437", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into K10134-long-poll-metadata-update", "committedDate": "2020-07-05T01:05:37Z", "type": "commit"}, {"oid": "f5fd17e7531fc73031f32406bbe181f67f0d0cab", "url": "https://github.com/apache/kafka/commit/f5fd17e7531fc73031f32406bbe181f67f0d0cab", "message": "push the best-effort into coordinator", "committedDate": "2020-07-05T02:40:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwMzgwMg==", "url": "https://github.com/apache/kafka/pull/8934#discussion_r450503802", "bodyText": "nit: seems unused?", "author": "hachikuji", "createdAt": "2020-07-06T22:04:56Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/KafkaConsumer.java", "diffHunk": "@@ -1258,11 +1261,19 @@ public void assign(Collection<TopicPartition> partitions) {\n         }\n     }\n \n+    private boolean coordinatorNeededForAssignment() {", "originalCommit": "f5fd17e7531fc73031f32406bbe181f67f0d0cab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwNDAyOA==", "url": "https://github.com/apache/kafka/pull/8934#discussion_r450504028", "bodyText": "flag?", "author": "hachikuji", "createdAt": "2020-07-06T22:05:34Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -416,7 +428,13 @@ boolean joinGroupIfNeeded(final Timer timer) {\n             }\n \n             final RequestFuture<ByteBuffer> future = initiateJoinGroup();\n-            client.poll(future, timer);\n+\n+            // if the flat is not set to true; we only try once and not block on the join result", "originalCommit": "f5fd17e7531fc73031f32406bbe181f67f0d0cab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwNDY0OA==", "url": "https://github.com/apache/kafka/pull/8934#discussion_r450504648", "bodyText": "Do we want this to be poll(0)? Otherwise we're still blocking here.", "author": "hachikuji", "createdAt": "2020-07-06T22:07:20Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -416,7 +428,13 @@ boolean joinGroupIfNeeded(final Timer timer) {\n             }\n \n             final RequestFuture<ByteBuffer> future = initiateJoinGroup();\n-            client.poll(future, timer);\n+\n+            // if the flat is not set to true; we only try once and not block on the join result\n+            if (waitUntilComplete)\n+                client.poll(future, timer);\n+            else\n+                client.poll(timer);", "originalCommit": "f5fd17e7531fc73031f32406bbe181f67f0d0cab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5NzYyMg==", "url": "https://github.com/apache/kafka/pull/8934#discussion_r450597622", "bodyText": "My rationale after thinking about this, is that it may be better to wait on at least some IOs to be done, especially if there are on-going fetch requests as well: we may complete writing a fetch request, or join / sync group request, or reading a response before returning.", "author": "guozhangwang", "createdAt": "2020-07-07T03:55:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwNDY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwNTY2NA==", "url": "https://github.com/apache/kafka/pull/8934#discussion_r450505664", "bodyText": "This call to fetchablePartitions is unfortunate. It is an entire pass over all the assigned partitions on every poll. Is there any way it can be avoided?", "author": "hachikuji", "createdAt": "2020-07-06T22:10:10Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/KafkaConsumer.java", "diffHunk": "@@ -1218,17 +1218,20 @@ public void assign(Collection<TopicPartition> partitions) {\n                 throw new IllegalStateException(\"Consumer is not subscribed to any topics or assigned any partitions\");\n             }\n \n-            // poll for new data until the timeout expires\n             do {\n                 client.maybeTriggerWakeup();\n \n                 if (includeMetadataInTimeout) {\n-                    // try to update assignment metadata BUT do not need to block on the timer,\n-                    // since even if we are 1) in the middle of a rebalance or 2) have partitions\n-                    // with unknown starting positions we may still want to return some data\n-                    // as long as there are some partitions fetchable; NOTE we always use a timer with 0ms\n-                    // to never block on completing the rebalance procedure if there's any\n-                    updateAssignmentMetadataIfNeeded(time.timer(0L));\n+                    // try to update assignment metadata BUT do not need to block on the timer if we still have\n+                    // some assigned partitions, since even if we are 1) in the middle of a rebalance\n+                    // or 2) have partitions with unknown starting positions we may still want to return some data\n+                    // as long as there are some partitions fetchable; NOTE we do not block on rebalancing to complete\n+                    // if there's one pending if we still have some fetchable partitions\n+                    if (subscriptions.fetchablePartitions(tp -> true).isEmpty()) {", "originalCommit": "f5fd17e7531fc73031f32406bbe181f67f0d0cab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5NDc5NQ==", "url": "https://github.com/apache/kafka/pull/8934#discussion_r450594795", "bodyText": "Agree, I can think of caching a boolean to avoid it.", "author": "guozhangwang", "createdAt": "2020-07-07T03:43:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwNTY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwOTMyMg==", "url": "https://github.com/apache/kafka/pull/8934#discussion_r450509322", "bodyText": "Just making sure I understand the problem. In the old logic, updateAssignmentMetadataIfNeeded never blocks. Even if we have no assignment and do not know the coordinator, we won't block here. That means we should fall through to pollForFetches. The poll timeout is set by the following logic:\n        long pollTimeout = coordinator == null ? timer.remainingMs() :\n                Math.min(coordinator.timeToNextPoll(timer.currentTimeMs()), timer.remainingMs());\nI think the only way I can see this logic getting into trouble is if Heartbeat.timeToNextHeartbeat returns a small value. So if the coordinator remains unknown for a little while and we need to heartbeat, we might get into a busy loop. Is that about right or are there other cases?", "author": "hachikuji", "createdAt": "2020-07-06T22:20:31Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/KafkaConsumer.java", "diffHunk": "@@ -1218,17 +1218,20 @@ public void assign(Collection<TopicPartition> partitions) {\n                 throw new IllegalStateException(\"Consumer is not subscribed to any topics or assigned any partitions\");\n             }\n \n-            // poll for new data until the timeout expires\n             do {\n                 client.maybeTriggerWakeup();\n \n                 if (includeMetadataInTimeout) {\n-                    // try to update assignment metadata BUT do not need to block on the timer,\n-                    // since even if we are 1) in the middle of a rebalance or 2) have partitions\n-                    // with unknown starting positions we may still want to return some data\n-                    // as long as there are some partitions fetchable; NOTE we always use a timer with 0ms\n-                    // to never block on completing the rebalance procedure if there's any\n-                    updateAssignmentMetadataIfNeeded(time.timer(0L));\n+                    // try to update assignment metadata BUT do not need to block on the timer if we still have", "originalCommit": "f5fd17e7531fc73031f32406bbe181f67f0d0cab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5NDgwNg==", "url": "https://github.com/apache/kafka/pull/8934#discussion_r450594806", "bodyText": "My guess is that the pollDelayMs from trySend(timer.currentTimeMs()) is zero and hence\nlong pollTimeout = Math.min(timer.remainingMs(), pollDelayMs);\n\nwould become zero.", "author": "guozhangwang", "createdAt": "2020-07-07T03:43:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwOTMyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk2MDk3MQ==", "url": "https://github.com/apache/kafka/pull/8934#discussion_r450960971", "bodyText": "Hmm, not sure if I buy that. trySend would only return a value less than 5s if there was a pending request which needed to be send. However, as soon as it got sent, it would go back to 5s. So I'm not sure if it alone can account for a tight poll loop.", "author": "hachikuji", "createdAt": "2020-07-07T15:40:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwOTMyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3ODIxNw==", "url": "https://github.com/apache/kafka/pull/8934#discussion_r450978217", "bodyText": "I did a simple experiment with one broker and one consumer. After the consumer joined the group, I did a kill -9 to stop the broker. I had the consumer log the poll timeout that was used in pollForFetches. What I saw is this:\n[2020-07-07 08:53:10,825] INFO [Consumer clientId=consumer-foo-1, groupId=foo] Polling for fetches with timeout 0 (org.apache.kafka.clients.consumer.KafkaConsumer)\n[2020-07-07 08:53:10,825] INFO [Consumer clientId=consumer-foo-1, groupId=foo] Polling for fetches with timeout 0 (org.apache.kafka.clients.consumer.KafkaConsumer)\n[2020-07-07 08:53:10,825] INFO [Consumer clientId=consumer-foo-1, groupId=foo] Polling for fetches with timeout 0 (org.apache.kafka.clients.consumer.KafkaConsumer)\n[2020-07-07 08:53:10,825] INFO [Consumer clientId=consumer-foo-1, groupId=foo] Polling for fetches with timeout 0 (org.apache.kafka.clients.consumer.KafkaConsumer)\n[2020-07-07 08:53:10,839] INFO [Consumer clientId=consumer-foo-1, groupId=foo] Polling for fetches with timeout 0 (org.apache.kafka.clients.consumer.KafkaConsumer)\n[2020-07-07 08:53:10,839] INFO [Consumer clientId=consumer-foo-1, groupId=foo] Polling for fetches with timeout 0 (org.apache.kafka.clients.consumer.KafkaConsumer)\n[2020-07-07 08:53:10,839] INFO [Consumer clientId=consumer-foo-1, groupId=foo] Polling for fetches with timeout 0 (org.apache.kafka.clients.consumer.KafkaConsumer)\n[2020-07-07 08:53:10,839] INFO [Consumer clientId=consumer-foo-1, groupId=foo] Polling for fetches with timeout 0 (org.apache.kafka.clients.consumer.KafkaConsumer)", "author": "hachikuji", "createdAt": "2020-07-07T16:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwOTMyMg=="}], "type": "inlineReview"}, {"oid": "bd518e4dcb0924163fc3442ec6484a13c1c8bf43", "url": "https://github.com/apache/kafka/commit/bd518e4dcb0924163fc3442ec6484a13c1c8bf43", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into K10134-long-poll-metadata-update", "committedDate": "2020-07-07T03:26:43Z", "type": "commit"}, {"oid": "c7a6d7f49632e022cf921b547d67e0aff270bba8", "url": "https://github.com/apache/kafka/commit/c7a6d7f49632e022cf921b547d67e0aff270bba8", "message": "revert change", "committedDate": "2020-07-08T01:18:05Z", "type": "commit"}, {"oid": "0675adee1c9ab8609c6d49b1548dc6b455d03a9b", "url": "https://github.com/apache/kafka/commit/0675adee1c9ab8609c6d49b1548dc6b455d03a9b", "message": "revert joinGroupIfNeeded", "committedDate": "2020-07-08T02:29:10Z", "type": "commit"}, {"oid": "6b4fda2262dfa4e956ae7eebbf3f12d459af0aa6", "url": "https://github.com/apache/kafka/commit/6b4fda2262dfa4e956ae7eebbf3f12d459af0aa6", "message": "github comments", "committedDate": "2020-07-08T02:32:00Z", "type": "commit"}]}