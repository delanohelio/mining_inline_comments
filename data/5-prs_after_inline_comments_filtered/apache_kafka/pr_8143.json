{"pr_number": 8143, "pr_title": "KAFKA-9582: Do not abort transaction in unclean close", "pr_createdAt": "2020-02-20T22:44:01Z", "pr_url": "https://github.com/apache/kafka/pull/8143", "timeline": [{"oid": "80562ef117bd01ce269c609f7ff6a1484792e29a", "url": "https://github.com/apache/kafka/commit/80562ef117bd01ce269c609f7ff6a1484792e29a", "message": "do not abort transaction in unclean close", "committedDate": "2020-02-20T22:48:04Z", "type": "commit"}, {"oid": "80562ef117bd01ce269c609f7ff6a1484792e29a", "url": "https://github.com/apache/kafka/commit/80562ef117bd01ce269c609f7ff6a1484792e29a", "message": "do not abort transaction in unclean close", "committedDate": "2020-02-20T22:48:04Z", "type": "forcePushed"}, {"oid": "f4f23e527a8e9dc3fcaccc0bb1083edc7cfdaa5f", "url": "https://github.com/apache/kafka/commit/f4f23e527a8e9dc3fcaccc0bb1083edc7cfdaa5f", "message": "deprecate isZombie", "committedDate": "2020-02-20T23:34:43Z", "type": "commit"}, {"oid": "f4f23e527a8e9dc3fcaccc0bb1083edc7cfdaa5f", "url": "https://github.com/apache/kafka/commit/f4f23e527a8e9dc3fcaccc0bb1083edc7cfdaa5f", "message": "deprecate isZombie", "committedDate": "2020-02-20T23:34:43Z", "type": "forcePushed"}, {"oid": "4f315cac4a96db56ec72d3d5524a7e9042537234", "url": "https://github.com/apache/kafka/commit/4f315cac4a96db56ec72d3d5524a7e9042537234", "message": "do not test on txn abort", "committedDate": "2020-02-21T00:42:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2MzgyNw==", "url": "https://github.com/apache/kafka/pull/8143#discussion_r382363827", "bodyText": "This one in particular might be worth a comment that we're specifically checking because we don't want to call methods on the producer during an unclean close.", "author": "vvcephei", "createdAt": "2020-02-21T02:16:40Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -1317,26 +1317,24 @@ public void shouldNotCloseProducerIfFencedOnCloseDuringCleanCloseWithEosEnabled(\n     }\n \n     @Test\n-    public void shouldAbortTransactionAndCloseProducerOnUncleanCloseWithEosEnabled() {\n+    public void shouldCloseProducerOnUncleanCloseWithEosEnabled() {\n         task = createStatelessTask(createConfig(true), StreamsConfig.METRICS_LATEST);\n         task.initializeTopology();\n \n         task.close(false, false);\n         task = null;\n \n-        assertTrue(producer.transactionAborted());\n-        assertFalse(producer.transactionInFlight());\n+        assertTrue(producer.transactionInFlight());", "originalCommit": "4f315cac4a96db56ec72d3d5524a7e9042537234", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NDE3MQ==", "url": "https://github.com/apache/kafka/pull/8143#discussion_r382374171", "bodyText": "Sounds good!", "author": "abbccdda", "createdAt": "2020-02-21T03:00:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2MzgyNw=="}], "type": "inlineReview"}, {"oid": "79860652913ae6f48141dbea92fefb06f65292ea", "url": "https://github.com/apache/kafka/commit/79860652913ae6f48141dbea92fefb06f65292ea", "message": "add comment", "committedDate": "2020-02-21T03:02:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNDYwNA==", "url": "https://github.com/apache/kafka/pull/8143#discussion_r382714604", "bodyText": "I think there are some callers of suspend that would set clean to false while isZombie to false as well, e.g. suspendRunningTasks in this case should we still call abortTxn?", "author": "guozhangwang", "createdAt": "2020-02-21T17:38:57Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -662,37 +650,26 @@ void suspend(final boolean clean,\n             }\n \n             if (eosEnabled) {\n-                maybeAbortTransactionAndCloseRecordCollector(isZombie);\n+                // Ignore any exceptions whilee closing the record collector, i.e task producer.\n+                closeRecordCollector();\n             }\n         }\n     }\n \n-    private void maybeAbortTransactionAndCloseRecordCollector(final boolean isZombie) {\n-        if (!isZombie) {", "originalCommit": "79860652913ae6f48141dbea92fefb06f65292ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNzgyOA==", "url": "https://github.com/apache/kafka/pull/8143#discussion_r382717828", "bodyText": "That call is inside the catch block of task.suspend. For simplicity, I think calling abortTxn is not very tempting at this point as well.", "author": "abbccdda", "createdAt": "2020-02-21T17:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNDYwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMTkwMQ==", "url": "https://github.com/apache/kafka/pull/8143#discussion_r382731901", "bodyText": "After another thought, I'm pretty sure the purpose of this PR is not to maintain the caller of abortTxn in either mode to simplify our error handling. The other txn mechanism like InitPid will make sure to cleanup the pending transactions or through the txn timeout. However the risk of calling abortTxn during close is much higher than a normal processing loop, at least for today's producer. If the producer is in FATAL_ERROR, it becomes a bomb for any caller touching on its APIs except close().\nWe could think of doing some safe abort operations for producer internally instead of externally, which could be done by either getting a new API or just change the default behavior of producer.close to do the transaction abortion when time allowed.", "author": "abbccdda", "createdAt": "2020-02-21T18:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNDYwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczNjUyNg==", "url": "https://github.com/apache/kafka/pull/8143#discussion_r382736526", "bodyText": "Cool I think I am convinced, let's just ignore the isZombie flag then.", "author": "guozhangwang", "createdAt": "2020-02-21T18:27:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNDYwNA=="}], "type": "inlineReview"}]}