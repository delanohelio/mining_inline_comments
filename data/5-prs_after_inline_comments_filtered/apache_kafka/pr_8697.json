{"pr_number": 8697, "pr_title": "KAFKA-9983: KIP-613, add INFO level e2e latency metrics", "pr_createdAt": "2020-05-20T04:15:32Z", "pr_url": "https://github.com/apache/kafka/pull/8697", "timeline": [{"oid": "80f1194441cfafda8d122c71e4b3f6bf88292541", "url": "https://github.com/apache/kafka/commit/80f1194441cfafda8d122c71e4b3f6bf88292541", "message": "get terminal nodes", "committedDate": "2020-05-23T00:03:10Z", "type": "commit"}, {"oid": "9471ef214ca6a6a413d91402e178fbc841943b7a", "url": "https://github.com/apache/kafka/commit/9471ef214ca6a6a413d91402e178fbc841943b7a", "message": "add percentiles test", "committedDate": "2020-05-23T00:03:10Z", "type": "commit"}, {"oid": "0a97427912cfbee9631194294d7a9d2e1b3cb8e2", "url": "https://github.com/apache/kafka/commit/0a97427912cfbee9631194294d7a9d2e1b3cb8e2", "message": "add tests", "committedDate": "2020-05-23T00:03:10Z", "type": "commit"}, {"oid": "8e0b85c1c22cfe5bfb431b8cc2b20018cc3ab61e", "url": "https://github.com/apache/kafka/commit/8e0b85c1c22cfe5bfb431b8cc2b20018cc3ab61e", "message": "add test for process", "committedDate": "2020-05-23T00:03:10Z", "type": "commit"}, {"oid": "f9e7114afc6a10868c7202d60f36064304fc820d", "url": "https://github.com/apache/kafka/commit/f9e7114afc6a10868c7202d60f36064304fc820d", "message": "move method to correct place", "committedDate": "2020-05-23T00:03:10Z", "type": "commit"}, {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97", "url": "https://github.com/apache/kafka/commit/a31d4f97d0e11e3842633bbf08deccdf06cc9f97", "message": "change to double", "committedDate": "2020-05-23T00:03:10Z", "type": "commit"}, {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97", "url": "https://github.com/apache/kafka/commit/a31d4f97d0e11e3842633bbf08deccdf06cc9f97", "message": "change to double", "committedDate": "2020-05-23T00:03:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTgzOQ==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429499839", "bodyText": "Not sure about this... Why do we need/want to have a limit?\nNit: double space", "author": "mjsax", "createdAt": "2020-05-23T01:01:58Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -899,6 +920,28 @@ public boolean maybePunctuateSystemTime() {\n         return punctuated;\n     }\n \n+    void maybeRecordE2ELatency(final long recordTimestamp, final String nodeName) {\n+        maybeRecordE2ELatency(recordTimestamp, time.milliseconds(), nodeName);\n+    }\n+\n+    private void maybeRecordE2ELatency(final long recordTimestamp, final long now, final String nodeName) {\n+        final Sensor e2eLatencySensor = e2eLatencySensors.get(nodeName);\n+        if (e2eLatencySensor == null) {\n+            throw new IllegalStateException(\"Requested to record e2e latency but could not find sensor for node \" + nodeName);\n+        } else if (e2eLatencySensor.shouldRecord() && e2eLatencySensor.hasMetrics()) {\n+            final long e2eLatency = now - recordTimestamp;\n+            if (e2eLatency >  MAXIMUM_E2E_LATENCY) {", "originalCommit": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwNTUxNw==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429505517", "bodyText": "Ack (limit explanation on comment below)", "author": "ableegoldman", "createdAt": "2020-05-23T02:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjUzNQ==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429896535", "bodyText": "Q: Wouldn't it be better to count measurements beyond the maximum latency towards the highest bucket as the Percentiles metric does?\nAdmittedly, the measured value would be quite wrong in the case of a lot of measurements greater than the maximum latency. However, with the sizes of the buckets that increase linearly, the reported values would be quite wrong anyways due to the increased approximation error. Furthermore, I guess users would put an alert on substantially smaller values.\nOTOH, not counting measurements beyond the maximum latency would falsify a bit the metric because they would not count towards the remaining 1% or 10% (for p99 and p90, respectively). Additionally, the max metric would also be falsified by not counting those measurements.", "author": "cadonna", "createdAt": "2020-05-25T11:58:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MzQ0NQ==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430573445", "bodyText": "Meta-review procedural question: In the future, can we try to avoid making the same comment in multiple places in the PR, since it leads to split discussions like this one?", "author": "vvcephei", "createdAt": "2020-05-26T17:09:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTg4Nw==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429499887", "bodyText": "For this case, should we record \"zero\" instead?", "author": "mjsax", "createdAt": "2020-05-23T01:02:23Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -899,6 +920,28 @@ public boolean maybePunctuateSystemTime() {\n         return punctuated;\n     }\n \n+    void maybeRecordE2ELatency(final long recordTimestamp, final String nodeName) {\n+        maybeRecordE2ELatency(recordTimestamp, time.milliseconds(), nodeName);\n+    }\n+\n+    private void maybeRecordE2ELatency(final long recordTimestamp, final long now, final String nodeName) {\n+        final Sensor e2eLatencySensor = e2eLatencySensors.get(nodeName);\n+        if (e2eLatencySensor == null) {\n+            throw new IllegalStateException(\"Requested to record e2e latency but could not find sensor for node \" + nodeName);\n+        } else if (e2eLatencySensor.shouldRecord() && e2eLatencySensor.hasMetrics()) {\n+            final long e2eLatency = now - recordTimestamp;\n+            if (e2eLatency >  MAXIMUM_E2E_LATENCY) {\n+                log.warn(\"Skipped recording e2e latency for node {} because {} is higher than maximum allowed latency {}\",\n+                         nodeName, e2eLatency, MAXIMUM_E2E_LATENCY);\n+            } else if (e2eLatency < MINIMUM_E2E_LATENCY) {", "originalCommit": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwNTQ0MQ==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429505441", "bodyText": "I was debating this...my thinking here was that a negative value probably means you're processing some records with \"future\" timestamps, for whatever reason, in which case the e2e latency isn't meaningful and they shouldn't affect the statistics.\nOr, your clocks are out of sync. I suppose we could add a separate metric that counts the number of records with negative e2e latency?", "author": "ableegoldman", "createdAt": "2020-05-23T02:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4NjA0Mg==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429886042", "bodyText": "@ableegoldman I agree with your thinking here. IMO, we should just log the warning for now. If we see that there is a demand for such a metric, we can add it later on.", "author": "cadonna", "createdAt": "2020-05-25T11:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MjQzNw==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430572437", "bodyText": "I'm fine with this as well, although I think it makes more sense either to pin to zero and warn or to just record the negative latency and warn. It feels like we're overthinking it. If the clocks are drifting a little and we report small negative numbers, the e2e latency is still low, which is still meaningful information. I really don't see a problem with just naively reporting it and not even bothering with a warning.", "author": "vvcephei", "createdAt": "2020-05-26T17:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1NDk3MQ==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430754971", "bodyText": "I would not record a negative latency. That seems to be kinda weird. I am fine with skipping and warning, too. Just wanted to clarify.", "author": "mjsax", "createdAt": "2020-05-26T23:05:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDAxMA==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429500010", "bodyText": "Not sure about this. Why do we need a maximum to begin with? And why pick 10 days? Rather arbitrary?", "author": "mjsax", "createdAt": "2020-05-23T01:03:31Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "diffHunk": "@@ -149,6 +154,10 @@ public int hashCode() {\n     public static final String RATE_DESCRIPTION_PREFIX = \"The average number of \";\n     public static final String RATE_DESCRIPTION_SUFFIX = \" per second\";\n \n+    public static final int PERCENTILES_SIZE_IN_BYTES = 1000 * 1000;    // 1 MB\n+    public static long MAXIMUM_E2E_LATENCY = 10 * 24 * 60 * 60 * 1000L; // maximum latency is 10 days", "originalCommit": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwNTAyOQ==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429505029", "bodyText": "10 days was just rounding up from the 7 day default retention limit. The maximum is due to the percentiles calculation which is based on incrementally sized buckets. It's a tradeoff with accuracy\nFor example if I increase it by a factor of 1000, the StreamTask percentiles test is off by almost 20% (p99 is 82.9 instead of 99). This test uses values between 0 and 100, which is probably considerably lower than most e2e latencies will be.If you look at the MetricsTest percentiles test I added, this uses random values up to the max value and can maintain the 10% accuracy up to a higher max value.\nOf course we don't know what the distribution will be, but it seems likely to be somewhere in the middle (not in the 100s of ms, not in the 10s or 1000s of days) so for reasonable accuracy we need to pick a reasonable maximum. We can definitely go higher than 10 days, but I reasoned that if you have records earlier than 10 days you're probably processing historical data and in that case the e2e latency isn't that meaningful.", "author": "ableegoldman", "createdAt": "2020-05-23T02:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4NDIzNQ==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429884235", "bodyText": "I understand that we need a maximum due to the way the percentiles are approximated. Since the e2e latency depends on user requirements, it would make sense to consider a config for the max latency. I see two reasons for such a config.\n\n\nWe always think about near-realtime use cases, but there could also be use cases that are allowed to provide a much higher latency but the latency should still be within a certain limit. For example, one were producers are not always online. Admittedly, 10 days is already quite high.\n\n\nOTOH, decreasing the max latency would also make the metric more accurate, AFAIU. That would also be a reason for a config that users can tweak.\n\n\nFor both cases, we could leave it like it is for now and see if there is really the need for such a config. WDYT?", "author": "cadonna", "createdAt": "2020-05-25T11:28:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3NTgyMg==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430575822", "bodyText": "This necessity makes me think that our Percentiles metric algorithm needs to be improved. Admittedly, I haven't looked at the math, but it seems like it should be possible to be more adaptive.\nI'm in favor of not adding a config and just leaving it alone for now, so that we can take the option in the future to fix the problem by fixing the algorithm.", "author": "vvcephei", "createdAt": "2020-05-26T17:13:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3NzA5Mg==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430577092", "bodyText": "However, I do not think we should restrict the max value for other metrics than the percentiles one. E.g., there's no reason to restrict the value we record for the max and min metrics. You should be able to update the Percentiles implementation to apply the maximum bound in the metric record method. Otherwise, I'd recommend recording two sensors separately; one for the bounded metrics, and one for the unbounded ones.", "author": "vvcephei", "createdAt": "2020-05-26T17:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1Mzg1Mw==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430753853", "bodyText": "Thanks for the details. Avoiding a config for now sounds good to me. This leave the path open to add a config later, or as John suggested to maybe change the algorithm (that might not need a max). I am fine with a hard coded max of 10 days.\nAlso +1 to John's suggestion to split percentiles and min/max to avoid applying the hard coded limed to min/max metric.", "author": "mjsax", "createdAt": "2020-05-26T23:02:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1OTk3NA==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430759974", "bodyText": "@cadonna @vvcephei @mjsax We have several related discussions going on across this PR so I'm just going to try and summarize here: let me know if I miss anything you still feel is important\nThe plan is to pin large/small values in the percentiles to the min/max for now and just log a warning. Since we're the only users of the Percentiles class, we can just modify it directly and avoid restricting the values for the min/max metrics as John mentioned above. If a user is experiencing small negative e2e latencies it's likely due to clock drift, and approximating as 0 seems reasonable. If they're experiencing large negative e2e latencies, there's clearly something odd going on and the e2e latency percentiles aren't meaningful. But it will still show up in the min metric and alert them to this. Presumably users may be interested to know.\nI'd like to avoid introducing a config in particular because the maximum isn't an inherent mathematical property of percentiles (obviously), it's just an artifact of the existing percentiles algorithm. We can improve this and presumably remove the requirement to set a static max, but I felt the algorithm was \"good enough\" for now (and didn't want to make large scale changes and/or rewrite it entirely right before the 2.6 deadline).\nIn sum I'd say the guiding principle for this PR and the initial metrics was to be useful without being misleadingly wrong. I think pinning the percentiles to the bounds but reporting the min/max as is achieves this, and allows us flexibility in improving the situation later", "author": "ableegoldman", "createdAt": "2020-05-26T23:22:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxNDU0OA==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429814548", "bodyText": "req:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    replay(StreamsMetricsImpl.class, streamsMetrics);\n          \n          \n            \n            \n          \n          \n            \n                    final Sensor sensor = ProcessorNodeMetrics.recordE2ELatencySensor(THREAD_ID, TASK_ID, PROCESSOR_NODE_ID, RecordingLevel.INFO, streamsMetrics);\n          \n          \n            \n            \n          \n          \n            \n                    verify(StreamsMetricsImpl.class, streamsMetrics);\n          \n          \n            \n                    assertThat(sensor, is(expectedSensor));\n          \n          \n            \n                    verifySensor(() -> ProcessorNodeMetrics.recordE2ELatencySensor(THREAD_ID, TASK_ID, PROCESSOR_NODE_ID, RecordingLevel.INFO, streamsMetrics));", "author": "cadonna", "createdAt": "2020-05-25T08:50:45Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/metrics/ProcessorNodeMetricsTest.java", "diffHunk": "@@ -260,6 +261,43 @@ public void shouldGetProcessAtSourceSensorOrForwardSensor() {\n         }\n     }\n \n+    @Test\n+    public void shouldGetRecordE2ELatencySensor() {\n+        final String operation = \"record-e2e-latency\";\n+        final String recordE2ELatencyMinDescription =\n+            \"The minimum end-to-end latency of a record, measuring by comparing the record timestamp with the \"\n+                + \"system time when it has been fully processed by the node\";\n+        final String recordE2ELatencyMaxDescription =\n+            \"The maximum end-to-end latency of a record, measuring by comparing the record timestamp with the \"\n+                + \"system time when it has been fully processed by the node\";\n+        final String recordE2ELatencyP99Description =\n+            \"The 99th percentile end-to-end latency of a record, measuring by comparing the record timestamp with the \"\n+                + \"system time when it has been fully processed by the node\";\n+        final String recordE2ELatencyP90Description =\n+            \"The 90th percentile end-to-end latency of a record, measuring by comparing the record timestamp with the \"\n+                + \"system time when it has been fully processed by the node\";\n+        expect(streamsMetrics.nodeLevelSensor(THREAD_ID, TASK_ID, PROCESSOR_NODE_ID, operation, RecordingLevel.INFO))\n+            .andReturn(expectedSensor);\n+        expect(streamsMetrics.nodeLevelTagMap(THREAD_ID, TASK_ID, PROCESSOR_NODE_ID)).andReturn(tagMap);\n+        StreamsMetricsImpl.addMinAndMaxAndP99AndP90ToSensor(\n+            expectedSensor,\n+            PROCESSOR_NODE_LEVEL_GROUP,\n+            tagMap,\n+            operation,\n+            recordE2ELatencyMinDescription,\n+            recordE2ELatencyMaxDescription,\n+            recordE2ELatencyP99Description,\n+            recordE2ELatencyP90Description\n+        );\n+\n+        replay(StreamsMetricsImpl.class, streamsMetrics);\n+\n+        final Sensor sensor = ProcessorNodeMetrics.recordE2ELatencySensor(THREAD_ID, TASK_ID, PROCESSOR_NODE_ID, RecordingLevel.INFO, streamsMetrics);\n+\n+        verify(StreamsMetricsImpl.class, streamsMetrics);\n+        assertThat(sensor, is(expectedSensor));", "originalCommit": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgyMTY3Nw==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429821677", "bodyText": "prop: For the sake of readability, could you extract this check to a method named isTerminalNode()? Even better would be to add a method named isTerminalNode() to ProcessorNode and use it here and in ProcessorTopology.", "author": "cadonna", "createdAt": "2020-05-25T09:04:39Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorContextImpl.java", "diffHunk": "@@ -223,6 +223,9 @@ public StateStore getStateStore(final String name) {\n                                 final V value) {\n         setCurrentNode(child);\n         child.process(key, value);\n+        if (child.children().isEmpty()) {", "originalCommit": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcwNzU4MQ==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430707581", "bodyText": "ack", "author": "ableegoldman", "createdAt": "2020-05-26T21:05:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgyMTY3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgyODgwNg==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429828806", "bodyText": "See my comment in ProcessorContextImpl.", "author": "cadonna", "createdAt": "2020-05-25T09:18:43Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorTopology.java", "diffHunk": "@@ -50,6 +51,13 @@ public ProcessorTopology(final List<ProcessorNode<?, ?>> processorNodes,\n         this.globalStateStores = Collections.unmodifiableList(globalStateStores);\n         this.storeToChangelogTopic = Collections.unmodifiableMap(storeToChangelogTopic);\n         this.repartitionTopics = Collections.unmodifiableSet(repartitionTopics);\n+\n+        this.terminalNodes = new HashSet<>();\n+        for (final ProcessorNode<?, ?> node : processorNodes) {\n+            if (node.children().isEmpty()) {", "originalCommit": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkwMDQxMA==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429900410", "bodyText": "prop: Take a look into StreamsTestUtils and see what you can re-use there to retrieve specific metrics.", "author": "cadonna", "createdAt": "2020-05-25T12:07:42Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -547,6 +624,28 @@ private KafkaMetric getMetric(final String operation,\n         ));\n     }\n \n+    private KafkaMetric getProcessorMetric(final String operation,\n+                                           final String nameFormat,\n+                                           final String taskId,\n+                                           final String processorNodeId,\n+                                           final String builtInMetricsVersion) {\n+        final String descriptionIsNotVerified = \"\";\n+        return metrics.metrics().get(metrics.metricName(\n+            String.format(nameFormat, operation),\n+            \"stream-processor-node-metrics\",\n+            descriptionIsNotVerified,\n+            mkMap(\n+                mkEntry(\"task-id\", taskId),\n+                mkEntry(\"processor-node-id\", processorNodeId),\n+                mkEntry(\n+                    StreamsConfig.METRICS_LATEST.equals(builtInMetricsVersion) ? THREAD_ID_TAG\n+                        : THREAD_ID_TAG_0100_TO_24,\n+                    Thread.currentThread().getName()\n+                )\n+            )\n+        ));\n+    }\n+", "originalCommit": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkwNDc3Mg==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429904772", "bodyText": "req: Please add unit tests in StreamsMetricsImplTest.", "author": "cadonna", "createdAt": "2020-05-25T12:18:45Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "diffHunk": "@@ -642,6 +651,55 @@ public static void addAvgAndMaxToSensor(final Sensor sensor,\n         );\n     }\n \n+    public static void addMinAndMaxAndP99AndP90ToSensor(final Sensor sensor,", "originalCommit": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2MjAzOA==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430562038", "bodyText": "Not sure if it really matters, but this is not a uniform distribution (because MAX_VALUE and MIN_VALUE are not integer multiples of 1000 days. If you wanted a uniform distribution, it looks like you can use the bounded nextInt and cast to long.\nAlso, FYI, Math.abs(Long.MIN_VALUE) == Long.MIN_VALUE (which is a negative number), due to overflow.", "author": "vvcephei", "createdAt": "2020-05-26T16:50:39Z", "path": "clients/src/test/java/org/apache/kafka/common/metrics/MetricsTest.java", "diffHunk": "@@ -492,6 +493,52 @@ public void testPercentiles() {\n         assertEquals(75, (Double) p75.metricValue(), 1.0);\n     }\n \n+    @Test\n+    public void testPercentilesWithRandomNumbersAndLinearBucketing() {\n+        long seed = new Random().nextLong();\n+        int sizeInBytes = 1000 * 1000;   // 1MB\n+        long maximumValue = 1000 * 24 * 60 * 60 * 1000L; // if values are ms, max is 1000 days\n+\n+        try {\n+            Random prng = new Random(seed);\n+            int numberOfValues = 5000 + prng.nextInt(10_000);  // ranges is [5000, 15000]\n+\n+            Percentiles percs = new Percentiles(sizeInBytes,\n+                                                maximumValue,\n+                                                BucketSizing.LINEAR,\n+                                                new Percentile(metrics.metricName(\"test.p90\", \"grp1\"), 90),\n+                                                new Percentile(metrics.metricName(\"test.p99\", \"grp1\"), 99));\n+            MetricConfig config = new MetricConfig().eventWindow(50).samples(2);\n+            Sensor sensor = metrics.sensor(\"test\", config);\n+            sensor.add(percs);\n+            Metric p90 = this.metrics.metrics().get(metrics.metricName(\"test.p90\", \"grp1\"));\n+            Metric p99 = this.metrics.metrics().get(metrics.metricName(\"test.p99\", \"grp1\"));\n+\n+            final List<Long> values = new ArrayList<>(numberOfValues);\n+            // record two windows worth of sequential values\n+            for (int i = 0; i < numberOfValues; ++i) {\n+                long value = Math.abs(prng.nextLong()) % maximumValue;", "originalCommit": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxMDgxMg==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430710812", "bodyText": "I wasn't going for a uniform distribution, just any non-pidgeonholed distribution (see existing testPercentiles for comparison). I was just trying to verify the basic validity and get a rough estimate on the accuracy here in case it turned out to be 5000% off.\nGood point about the overflow though. Pretty annoying that you can't give a bound for nextLong like you can with nextInt :/", "author": "ableegoldman", "createdAt": "2020-05-26T21:12:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2MjAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU4MDE4Mg==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430580182", "bodyText": "If I understand this right, we are recording sink latencies after processing, but source latencies before processing. This nicely avoids the problem with recording non-sink latencies after processing, but is it accurate?", "author": "vvcephei", "createdAt": "2020-05-26T17:21:21Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -586,6 +606,7 @@ public boolean process(final long wallClockTime) {\n             log.trace(\"Start processing one record [{}]\", record);\n \n             updateProcessorContext(record, currNode, wallClockTime);\n+            maybeRecordE2ELatency(record.timestamp, wallClockTime, currNode.name());", "originalCommit": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNDQ0OQ==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430714449", "bodyText": "We discussed this offline, but in case anyone else was wondering:\nYes. We can't record the latency after processing for source nodes due to our recursive DFS approach to processing, as the source node's #process actually doesn't complete until the record has been processed by every other node in the subtopology. And anyways, the intent of the source node metric is to gauge the e2e latency when the record arrives at the subtopology, which is what we are recording here.", "author": "ableegoldman", "createdAt": "2020-05-26T21:20:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU4MDE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNjI2Mw==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430716263", "bodyText": "Thanks, @ableegoldman , I think this is a fine tradeoff. Also helping is the fact that we know all \"source nodes\" are actually instances of SourceNode, which specifically do nothing except forward every record, so whether we measure these nodes before or \"after\" their processing logic should make no practical difference at all.", "author": "vvcephei", "createdAt": "2020-05-26T21:24:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU4MDE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1NzI5NA==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430757294", "bodyText": "o whether we measure these nodes before or \"after\" their processing logic should make no practical difference at all.\n\nI think it make a big difference, and only recording before processing is what we want (according to what the KIP says). Otherwise, the latency includes the processing time for one or more processors (in the worst case even all processors).", "author": "mjsax", "createdAt": "2020-05-26T23:13:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU4MDE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NjkzOQ==", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430846939", "bodyText": "Sorry for my ambiguity. Please let me clarify my terms. Currently if you wait until the end of the \"process\" method, you wind up including the call to forward, which recursively calls process on all descendents of the source node. This is not what I was talking about. I meant only the time spent just in processing the SourceNode, excluding the time in \"forward\". What shall we call this? Maybe \"actual\", or \"proper\", or \"internal\" processing time?\nSo, my comment was that, given that we know the implementation of SourceNode, we know that it's \"actual\", \"proper\", \"internal\" processing time is going to be very small, probably far less than a single millisecond. So it doesn't make any practical difference whether we measure before the call for just the special case of source nodes, or magically solve the problem of measuring the e2e latency after internal processing, but not including the calls to \"forward\".\nThis is why I think it's fine to measure SourceNodes before the call to process, even though the KIP technically specifies that processors' end-to-end latencies should include processing latency. We're making a simplifying assumption that for source nodes specifically, the processing latency would be << 1, so we can ignore it.", "author": "vvcephei", "createdAt": "2020-05-27T04:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU4MDE4Mg=="}], "type": "inlineReview"}, {"oid": "bf6e95b45d0858572556f1bcbef7d93ffc5bdc08", "url": "https://github.com/apache/kafka/commit/bf6e95b45d0858572556f1bcbef7d93ffc5bdc08", "message": "review comments; pin values outside min/max to bounds and log warning", "committedDate": "2020-05-26T22:41:17Z", "type": "commit"}, {"oid": "452170d0906175c73b7ea5a15697aa00906d2a01", "url": "https://github.com/apache/kafka/commit/452170d0906175c73b7ea5a15697aa00906d2a01", "message": "checkstyle", "committedDate": "2020-05-26T22:42:13Z", "type": "commit"}, {"oid": "ddf0e569ff0d33560ef70bbf07d9d4b7a7814e6e", "url": "https://github.com/apache/kafka/commit/ddf0e569ff0d33560ef70bbf07d9d4b7a7814e6e", "message": "fix last remaining bit of spotBugs nonsense", "committedDate": "2020-05-26T22:49:17Z", "type": "commit"}, {"oid": "18bddac4d8ca88fd4da5bcc5b799531ba66888e5", "url": "https://github.com/apache/kafka/commit/18bddac4d8ca88fd4da5bcc5b799531ba66888e5", "message": "add to MetricsIntegrationTest", "committedDate": "2020-05-26T22:55:47Z", "type": "commit"}, {"oid": "faa3c30b4e4118961cd8d472361b5b0ae5886038", "url": "https://github.com/apache/kafka/commit/faa3c30b4e4118961cd8d472361b5b0ae5886038", "message": "fix ActiveTaskCreatorTest", "committedDate": "2020-05-26T23:12:24Z", "type": "commit"}, {"oid": "8223ea29b07d9754b28ef4b06e765c66f208863c", "url": "https://github.com/apache/kafka/commit/8223ea29b07d9754b28ef4b06e765c66f208863c", "message": "clients checkstyle", "committedDate": "2020-05-26T23:33:19Z", "type": "commit"}]}