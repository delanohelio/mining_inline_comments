{"pr_number": 8712, "pr_title": " KAFKA-10006: Don't create internal topics when LeaderNotAvailableException", "pr_createdAt": "2020-05-22T10:16:05Z", "pr_url": "https://github.com/apache/kafka/pull/8712", "timeline": [{"oid": "6b01ecdd8fa22d812b6f6590144c733b43e87060", "url": "https://github.com/apache/kafka/commit/6b01ecdd8fa22d812b6f6590144c733b43e87060", "message": "KAFKA-10006: do not attempt to create internal topics if got LeaderNotAvailableException", "committedDate": "2020-05-22T09:08:23Z", "type": "commit"}, {"oid": "e3fb9fdc1239d14d6b2eb9a33224f23e5ee7f052", "url": "https://github.com/apache/kafka/commit/e3fb9fdc1239d14d6b2eb9a33224f23e5ee7f052", "message": "KAFKA-10006: add tests", "committedDate": "2020-05-22T10:12:46Z", "type": "commit"}, {"oid": "608e52b86d40de8b4031894d7a513869a65dd6bb", "url": "https://github.com/apache/kafka/commit/608e52b86d40de8b4031894d7a513869a65dd6bb", "message": "KAFKA-10006: refactor", "committedDate": "2020-05-22T14:28:56Z", "type": "commit"}, {"oid": "608e52b86d40de8b4031894d7a513869a65dd6bb", "url": "https://github.com/apache/kafka/commit/608e52b86d40de8b4031894d7a513869a65dd6bb", "message": "KAFKA-10006: refactor", "committedDate": "2020-05-22T14:28:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4ODQ0OQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r429288449", "bodyText": "Try to simulate the LeaderNotAvailableException in the MockAdminClient, if the topic name isLeaderNotAvailableTopic.", "author": "showuon", "createdAt": "2020-05-22T14:41:48Z", "path": "clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java", "diffHunk": "@@ -330,6 +331,12 @@ synchronized public DescribeTopicsResult describeTopics(Collection<String> topic\n                 future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                 topicDescriptions.put(requestedTopic, future);\n             }\n+            // try to simulate the leader not available situation when topic name is \"LeaderNotAvailableTopic\"\n+            if (requestedTopic.equals(\"LeaderNotAvailableTopic\")) {\n+                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n+                future.completeExceptionally(new LeaderNotAvailableException(\"The leader of Topic \" + requestedTopic + \" is not available.\"));", "originalCommit": "608e52b86d40de8b4031894d7a513869a65dd6bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NDM2OA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444554368", "bodyText": "Is it possible to use EasyMock instead of adding this to the actual MockAdminClient? I know it's kind of a pain to set up but I think it'll make the test a lot more clear. I did something similar in StreamsPartitionAssignorTest to mock the results of the listOffsets request", "author": "ableegoldman", "createdAt": "2020-06-23T23:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4ODQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4OTM4MA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r429289380", "bodyText": "If there's topic with LeaderNotAvailableException, we also need to retry.", "author": "showuon", "createdAt": "2020-05-22T14:43:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -247,11 +261,19 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n                     log.error(errorMsg);\n                     throw new StreamsException(errorMsg);\n                 }\n-            } else {\n+            } else if (!needRetryTopics.contains(topicName)) {\n                 topicsToCreate.add(topicName);\n             }\n         }\n \n         return topicsToCreate;\n     }\n+\n+    private boolean isNeedRetry(final Set<String> topicsNotReady) {\n+        return !topicsNotReady.isEmpty() || hasNeedRetryTopic();", "originalCommit": "608e52b86d40de8b4031894d7a513869a65dd6bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6", "url": "https://github.com/apache/kafka/commit/ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6", "message": "KAFKA-10006: refactor", "committedDate": "2020-05-25T02:25:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mjc1MQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436282751", "bodyText": "This should be declared final.", "author": "abbccdda", "createdAt": "2020-06-06T16:45:15Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -59,6 +59,9 @@ private InternalAdminClientConfig(final Map<?, ?> props) {\n \n     private final int retries;\n     private final long retryBackOffMs;\n+    private int remainingRetries;\n+\n+    private HashSet<String> leaderNotAvailableTopics = new HashSet<>();", "originalCommit": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mzc0NQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436283745", "bodyText": "Similar to this struct, it doesn't make sense to have a non-empty leaderNotAvailableTopics after each call to makeReady, I would prefer building it as local variable, cc @ableegoldman", "author": "abbccdda", "createdAt": "2020-06-06T16:58:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mjc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3OTUxNQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436479515", "bodyText": "Oh, Nice catch! You're correct, @abbccdda , it might have a non-empty leaderNotAvailableTopics after each call to makeReady. I changed it to using local variable. Thank you.", "author": "showuon", "createdAt": "2020-06-08T06:27:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mjc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjkyMw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436282923", "bodyText": "This contains check is unnecessary.", "author": "abbccdda", "createdAt": "2020-06-06T16:47:21Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -195,20 +198,30 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n             final String topicName = topicFuture.getKey();\n             try {\n                 final TopicDescription topicDescription = topicFuture.getValue().get();\n-                existedTopicPartition.put(\n-                    topicFuture.getKey(),\n-                    topicDescription.partitions().size());\n+                existedTopicPartition.put(topicName, topicDescription.partitions().size());\n+                if (leaderNotAvailableTopics.contains(topicName)) {", "originalCommit": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDAyNw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436444027", "bodyText": "Good point! The remove method will return true/false for key found/not found. Fixed.", "author": "showuon", "createdAt": "2020-06-08T03:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MzQ3Mw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436283473", "bodyText": "This is a personal preference, but I think we should not attempt to include a temporal variable as part of the class struct. We could change the internal function signatures to pass around remainingRetries (like validateTopics) instead.", "author": "abbccdda", "createdAt": "2020-06-06T16:54:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -100,11 +103,11 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         // have existed with the expected number of partitions, or some create topic returns fatal errors.\n         log.debug(\"Starting to validate internal topics {} in partition assignor.\", topics);\n \n-        int remainingRetries = retries;\n+        remainingRetries = retries;", "originalCommit": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ2MDY5MQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436460691", "bodyText": "OK, fixed. Thanks.", "author": "showuon", "createdAt": "2020-06-08T05:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MzQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mzk2OQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436283969", "bodyText": "This workaround is very hard to be found by other developers, as a minimum we should define a constant and make it part of MockAdminClient class", "author": "abbccdda", "createdAt": "2020-06-06T17:01:35Z", "path": "clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java", "diffHunk": "@@ -330,6 +331,12 @@ synchronized public DescribeTopicsResult describeTopics(Collection<String> topic\n                 future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                 topicDescriptions.put(requestedTopic, future);\n             }\n+            // try to simulate the leader not available situation when topic name is \"LeaderNotAvailableTopic\"", "originalCommit": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NjU1Mg==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436446552", "bodyText": "Good suggestion. I put it as a constant. Thanks.", "author": "showuon", "createdAt": "2020-06-08T04:00:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mzk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDA0OQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436284049", "bodyText": "Testing against log message is error-prone and hard to maintain, I think just making sure the thrown exception type is expected should be sufficient.", "author": "abbccdda", "createdAt": "2020-06-06T17:02:40Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,49 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldLogWhenTopicLeaderNotAvailableAndThrowException() {\n+        final String topicLeaderNotAvailable = \"LeaderNotAvailableTopic\";\n+        mockAdminClient.addTopic(\n+            false,\n+            topicLeaderNotAvailable,\n+            Collections.singletonList(new TopicPartitionInfo(0, broker1, cluster, Collections.emptyList())),\n+            null);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(topicLeaderNotAvailable, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(topicLeaderNotAvailable, internalTopicConfig);\n+\n+        LogCaptureAppender.setClassLoggerToDebug(InternalTopicManager.class);\n+        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister(InternalTopicManager.class)) {\n+            final StreamsException exception = assertThrows(\n+                StreamsException.class,\n+                () -> internalTopicManager.makeReady(topicConfigMap));\n+\n+            final String expectedMessage = \"Could not create topics after 1 retries. This can happen if the Kafka cluster is temporary not available\";", "originalCommit": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NjkwNw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436446907", "bodyText": "Good suggestion. Remove the log message check and only verify the exception thrown. Thanks.", "author": "showuon", "createdAt": "2020-06-08T04:02:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDA0OQ=="}], "type": "inlineReview"}, {"oid": "2f015fa945537b73725b48fd2554dc1327a41a80", "url": "https://github.com/apache/kafka/commit/2f015fa945537b73725b48fd2554dc1327a41a80", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into KAFKA-10006", "committedDate": "2020-06-08T03:16:27Z", "type": "commit"}, {"oid": "0567ecbc82c01b0c6e596fe5c28918f3b530a263", "url": "https://github.com/apache/kafka/commit/0567ecbc82c01b0c6e596fe5c28918f3b530a263", "message": "KAFKA-10006: address reviewer's comments", "committedDate": "2020-06-08T06:18:01Z", "type": "commit"}, {"oid": "0567ecbc82c01b0c6e596fe5c28918f3b530a263", "url": "https://github.com/apache/kafka/commit/0567ecbc82c01b0c6e596fe5c28918f3b530a263", "message": "KAFKA-10006: address reviewer's comments", "committedDate": "2020-06-08T06:18:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NTcyNA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444555724", "bodyText": "Can we give this a more descriptive name? It might be obvious to you, but I think someone just looking at this code for the first time would not get that this actually means topics that may or may not already exist.\nThat said, I'm struggling to think of a good alternative...maybe possiblyCreatedTopics or unknownTopics...any better ideas?", "author": "ableegoldman", "createdAt": "2020-06-23T23:05:58Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -98,9 +98,10 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         int remainingRetries = retries;\n         Set<String> topicsNotReady = new HashSet<>(topics.keySet());\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n+        final HashSet<String> leaderNotAvailableTopics = new HashSet<>();", "originalCommit": "0567ecbc82c01b0c6e596fe5c28918f3b530a263", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDczOTc1OA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444739758", "bodyText": "Good suggestion, I changed to tempUnknownTopics, because they are temporarily unknown topics for now. How do you think?", "author": "showuon", "createdAt": "2020-06-24T08:44:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NTcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NjU2OA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444556568", "bodyText": "Can we just use !isEmpty for both sets?", "author": "ableegoldman", "createdAt": "2020-06-23T23:08:32Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -242,11 +256,16 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n                     log.error(errorMsg);\n                     throw new StreamsException(errorMsg);\n                 }\n-            } else {\n+            } else if (!leaderNotAvailableTopics.contains(topicName)) {\n                 topicsToCreate.add(topicName);\n             }\n         }\n \n         return topicsToCreate;\n     }\n+\n+    private boolean shouldRetry(final Set<String> topicsNotReady, final HashSet<String> leaderNotAvailableTopics) {\n+        // If there's topic with LeaderNotAvailableException, we still need retry\n+        return !topicsNotReady.isEmpty() || leaderNotAvailableTopics.size() > 0;", "originalCommit": "0567ecbc82c01b0c6e596fe5c28918f3b530a263", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc0MTAzNw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444741037", "bodyText": "Good suggestion. Updated.", "author": "showuon", "createdAt": "2020-06-24T08:46:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NjU2OA=="}], "type": "inlineReview"}, {"oid": "f378c34d10c57d796412ac946f867e5787f93af0", "url": "https://github.com/apache/kafka/commit/f378c34d10c57d796412ac946f867e5787f93af0", "message": "KAFKA-10006: use EasyMock to rewrite the test, and remove the unneeded hack in MockAdminClient", "committedDate": "2020-06-24T14:07:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNTE5Ng==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445135196", "bodyText": "s/HashSet/Set?", "author": "abbccdda", "createdAt": "2020-06-24T19:54:53Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -98,9 +98,10 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         int remainingRetries = retries;\n         Set<String> topicsNotReady = new HashSet<>(topics.keySet());\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n+        final HashSet<String> tempUnknownTopics = new HashSet<>();", "originalCommit": "f378c34d10c57d796412ac946f867e5787f93af0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTQzNQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601435", "bodyText": "Fixed. Thanks.", "author": "showuon", "createdAt": "2020-06-25T14:28:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNTE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNjE3Nw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445136177", "bodyText": "Could be merged with above else", "author": "abbccdda", "createdAt": "2020-06-24T19:56:44Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -243,10 +259,18 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n                     throw new StreamsException(errorMsg);\n                 }\n             } else {\n-                topicsToCreate.add(topicName);\n+                // for the tempUnknownTopics, we'll check again later if retries > 0", "originalCommit": "f378c34d10c57d796412ac946f867e5787f93af0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTM4OA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601388", "bodyText": "Fixed", "author": "showuon", "createdAt": "2020-06-25T14:28:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNjE3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNzE0Ng==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445137146", "bodyText": "Use 4 space format to align with other tests.", "author": "abbccdda", "createdAt": "2020-06-24T19:58:25Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +291,41 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldLogWhenTopicLeaderNotAvailableAndThrowException() {\n+        final String leaderNotAvailableTopic = \"LeaderNotAvailableTopic\";\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+\n+        // simulate describeTopics got LeaderNotAvailableException\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+                .andReturn(new MockDescribeTopicsResult(", "originalCommit": "f378c34d10c57d796412ac946f867e5787f93af0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTM1Mg==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601352", "bodyText": "Nice catch! Fixed.", "author": "showuon", "createdAt": "2020-06-25T14:28:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNzE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3NzU0OQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445277549", "bodyText": "We could just pass in a boolean here to indicate whether there are remaining retries", "author": "abbccdda", "createdAt": "2020-06-25T02:46:40Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -179,31 +180,43 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n      * Topics that were not able to get its description will simply not be returned\n      */\n     // visible for testing\n-    protected Map<String, Integer> getNumPartitions(final Set<String> topics) {\n-        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", topics);\n-\n-        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(topics);\n+    protected Map<String, Integer> getNumPartitions(final Set<String> topics,\n+                                                    final HashSet<String> tempUnknownTopics,\n+                                                    final int remainingRetries) {", "originalCommit": "f378c34d10c57d796412ac946f867e5787f93af0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTMyNQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601325", "bodyText": "Updated.", "author": "showuon", "createdAt": "2020-06-25T14:28:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3NzU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3Nzk2MQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445277961", "bodyText": "Could reduce the if-else block as:\nif (remainingRetries <= 0) {\n  // run out of retries, throw exception directly \n  throw new StreamsException(\n    String.format(\"The leader of the Topic %s is not available after %d retries.\", topicName, retries), cause);\n }\n log.debug(\"The leader of the Topic {} is not available, with {} retries left.\\n\" +\n   \"Error message was: {}\", topicName, remainingRetries, cause.toString());", "author": "abbccdda", "createdAt": "2020-06-25T02:48:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -179,31 +180,43 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n      * Topics that were not able to get its description will simply not be returned\n      */\n     // visible for testing\n-    protected Map<String, Integer> getNumPartitions(final Set<String> topics) {\n-        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", topics);\n-\n-        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(topics);\n+    protected Map<String, Integer> getNumPartitions(final Set<String> topics,\n+                                                    final HashSet<String> tempUnknownTopics,\n+                                                    final int remainingRetries) {\n+        final Set<String> allTopicsToDescribe = new HashSet<>(topics);\n+        allTopicsToDescribe.addAll(tempUnknownTopics);\n+        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", allTopicsToDescribe);\n+\n+        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(allTopicsToDescribe);\n         final Map<String, KafkaFuture<TopicDescription>> futures = describeTopicsResult.values();\n \n         final Map<String, Integer> existedTopicPartition = new HashMap<>();\n         for (final Map.Entry<String, KafkaFuture<TopicDescription>> topicFuture : futures.entrySet()) {\n             final String topicName = topicFuture.getKey();\n             try {\n                 final TopicDescription topicDescription = topicFuture.getValue().get();\n-                existedTopicPartition.put(\n-                    topicFuture.getKey(),\n-                    topicDescription.partitions().size());\n+                existedTopicPartition.put(topicName, topicDescription.partitions().size());\n+                tempUnknownTopics.remove(topicName);\n             } catch (final InterruptedException fatalException) {\n                 // this should not happen; if it ever happens it indicate a bug\n                 Thread.currentThread().interrupt();\n                 log.error(INTERRUPTED_ERROR_MESSAGE, fatalException);\n                 throw new IllegalStateException(INTERRUPTED_ERROR_MESSAGE, fatalException);\n             } catch (final ExecutionException couldNotDescribeTopicException) {\n                 final Throwable cause = couldNotDescribeTopicException.getCause();\n-                if (cause instanceof UnknownTopicOrPartitionException ||\n-                    cause instanceof LeaderNotAvailableException) {\n-                    // This topic didn't exist or leader is not known yet, proceed to try to create it\n-                    log.debug(\"Topic {} is unknown or not found, hence not existed yet: {}\", topicName, cause.toString());\n+                if (cause instanceof UnknownTopicOrPartitionException) {\n+                    // This topic didn't exist, proceed to try to create it\n+                    log.debug(\"Topic {} is unknown or not found, hence not existed yet.\\n\" +\n+                        \"Error message was: {}\", topicName, cause.toString());\n+                } else if (cause instanceof LeaderNotAvailableException) {\n+                    tempUnknownTopics.add(topicName);\n+                    if (remainingRetries > 0) {", "originalCommit": "f378c34d10c57d796412ac946f867e5787f93af0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTI3OQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601279", "bodyText": "Updated.", "author": "showuon", "createdAt": "2020-06-25T14:28:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3Nzk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODQ1Nw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445278457", "bodyText": "Why do we need allTopicsToDescribe? It seems only queried once locally.", "author": "abbccdda", "createdAt": "2020-06-25T02:50:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -179,31 +180,43 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n      * Topics that were not able to get its description will simply not be returned\n      */\n     // visible for testing\n-    protected Map<String, Integer> getNumPartitions(final Set<String> topics) {\n-        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", topics);\n-\n-        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(topics);\n+    protected Map<String, Integer> getNumPartitions(final Set<String> topics,\n+                                                    final HashSet<String> tempUnknownTopics,\n+                                                    final int remainingRetries) {\n+        final Set<String> allTopicsToDescribe = new HashSet<>(topics);\n+        allTopicsToDescribe.addAll(tempUnknownTopics);", "originalCommit": "f378c34d10c57d796412ac946f867e5787f93af0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYyNTExMg==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445625112", "bodyText": "The allTopicsToDescribe is for tempUnknownTopics to have chance to get described again, by the retries in makeReady method. In the makeReady, we want to know which topics existed and to validate it, and which topics not existed that needed to be created. But for the LeaderNotAvailabletopics, we can't know if topics existed or not. So, we need to merge topics(topics to validate) and tempUnknownTopics here to describe them all (again) here.\nThanks.", "author": "showuon", "createdAt": "2020-06-25T15:00:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODY2Mg==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445278662", "bodyText": "Similar here, we could reduce to Set", "author": "abbccdda", "createdAt": "2020-06-25T02:51:13Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -218,13 +231,16 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n     /**\n      * Check the existing topics to have correct number of partitions; and return the remaining topics that needs to be created\n      */\n-    private Set<String> validateTopics(final Set<String> topicsToValidate, final Map<String, InternalTopicConfig> topicsMap) {\n+    private Set<String> validateTopics(final Set<String> topicsToValidate,\n+                                       final Map<String, InternalTopicConfig> topicsMap,\n+                                       final HashSet<String> tempUnknownTopics,", "originalCommit": "f378c34d10c57d796412ac946f867e5787f93af0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTIzOA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601238", "bodyText": "Fixed.", "author": "showuon", "createdAt": "2020-06-25T14:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODg2Mw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445278863", "bodyText": "Could use Collections.emptySet() if reduced to Set", "author": "abbccdda", "createdAt": "2020-06-25T02:52:09Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -108,7 +111,8 @@ public void shouldReturnCorrectPartitionCounts() {\n             topic,\n             Collections.singletonList(new TopicPartitionInfo(0, broker1, singleReplica, Collections.emptyList())),\n             null);\n-        assertEquals(Collections.singletonMap(topic, 1), internalTopicManager.getNumPartitions(Collections.singleton(topic)));\n+        assertEquals(Collections.singletonMap(topic, 1),\n+                internalTopicManager.getNumPartitions(Collections.singleton(topic), new HashSet<String>(), 1));", "originalCommit": "f378c34d10c57d796412ac946f867e5787f93af0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTIwNw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601207", "bodyText": "Updated. Thanks.", "author": "showuon", "createdAt": "2020-06-25T14:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODg2Mw=="}], "type": "inlineReview"}, {"oid": "70d41212fe8a4d5055993c56e30c2342498e1664", "url": "https://github.com/apache/kafka/commit/70d41212fe8a4d5055993c56e30c2342498e1664", "message": "KAFKA-10006: address reviewer's comments", "committedDate": "2020-06-25T14:30:29Z", "type": "commit"}, {"oid": "70d41212fe8a4d5055993c56e30c2342498e1664", "url": "https://github.com/apache/kafka/commit/70d41212fe8a4d5055993c56e30c2342498e1664", "message": "KAFKA-10006: address reviewer's comments", "committedDate": "2020-06-25T14:30:29Z", "type": "forcePushed"}, {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00", "url": "https://github.com/apache/kafka/commit/9089b4bb8ddef924e45e19d7806343627f206b00", "message": "KAFKA-10006: fix the log flaw to count the tempUnkonwnTopics as topicsNotReady and add 2 more tests\n\n1. Return the topicsNotReady to makeReady including tempUnknownTopics, and not create topic to wait for next retry\n2. tempUnknownTopics will be created each retry since we count the tempUnknownTopics as part of topicsNotReady\n3. add 2 more tests to total test 3 cases:\n  3.1 shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound\n  3.2 shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess\n  3.3 shouldThrowExceptionWhenKeepsTopicLeaderNotAvailable", "committedDate": "2020-06-27T02:02:24Z", "type": "commit"}, {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00", "url": "https://github.com/apache/kafka/commit/9089b4bb8ddef924e45e19d7806343627f206b00", "message": "KAFKA-10006: fix the log flaw to count the tempUnkonwnTopics as topicsNotReady and add 2 more tests\n\n1. Return the topicsNotReady to makeReady including tempUnknownTopics, and not create topic to wait for next retry\n2. tempUnknownTopics will be created each retry since we count the tempUnknownTopics as part of topicsNotReady\n3. add 2 more tests to total test 3 cases:\n  3.1 shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound\n  3.2 shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess\n  3.3 shouldThrowExceptionWhenKeepsTopicLeaderNotAvailable", "committedDate": "2020-06-27T02:02:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMTk1Mw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447831953", "bodyText": "Better to be name as leaderUnavailableTopics to match the error code.", "author": "abbccdda", "createdAt": "2020-06-30T16:48:18Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -100,13 +100,19 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n \n         while (!topicsNotReady.isEmpty() && remainingRetries >= 0) {\n-            topicsNotReady = validateTopics(topicsNotReady, topics);\n+            final Set<String> tempUnknownTopics = new HashSet<>();", "originalCommit": "9089b4bb8ddef924e45e19d7806343627f206b00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5NTEyNA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448095124", "bodyText": "Well, this variable naming is actually suggested by @ableegoldman , and I also think the tempUnknownTopics is more descriptive. Is that OK for you?\n#8712 (comment)", "author": "showuon", "createdAt": "2020-07-01T03:29:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMTk1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1NzM4MQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448457381", "bodyText": "Sure, I don't feel strong about reverting the naming once we already got a reason there.", "author": "abbccdda", "createdAt": "2020-07-01T15:49:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMTk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNDM3Mg==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447834372", "bodyText": "Could be simplified as topicManager.makeReady(Collections.singletonMap(leaderNotAvailableTopic, internalTopicConfig));", "author": "abbccdda", "createdAt": "2020-06-30T16:52:07Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);", "originalCommit": "9089b4bb8ddef924e45e19d7806343627f206b00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEwMDk5NA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448100994", "bodyText": "good. Thanks.", "author": "showuon", "createdAt": "2020-07-01T03:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNDM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNTg5MQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447835891", "bodyText": "This test seems to be overlapping with shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound. I don't think we need both to return LeaderNotAvailable unless they are evaluating different scenarios.", "author": "abbccdda", "createdAt": "2020-06-30T16:54:25Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {", "originalCommit": "9089b4bb8ddef924e45e19d7806343627f206b00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5OTM1OA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448099358", "bodyText": "Yes, they are different scenarios. You can check below diagram for reference. (red and green for different cases)", "author": "showuon", "createdAt": "2020-07-01T03:48:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNTg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MDE5Nw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448460197", "bodyText": "Thanks for explaining! May I know what this software you uses to generate the graph?", "author": "abbccdda", "createdAt": "2020-07-01T15:54:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNTg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4NTIyNA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448685224", "bodyText": "Actually, I drew it by myself on the MS office powerpoint. haha", "author": "showuon", "createdAt": "2020-07-02T00:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNTg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNjM3Mw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447836373", "bodyText": "nit: if it will return topicDescriptionSuccessFuture, then we should not use leaderNotAvailableTopic", "author": "abbccdda", "createdAt": "2020-06-30T16:55:09Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+        final TopicPartitionInfo partitionInfo = new TopicPartitionInfo(0, broker1,\n+                Collections.singletonList(broker1), Collections.singletonList(broker1));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionSuccessFuture = new KafkaFutureImpl<>();\n+        topicDescriptionSuccessFuture.complete(\n+            new TopicDescription(topic, false, Collections.singletonList(partitionInfo), Collections.emptySet())\n+        );\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))", "originalCommit": "9089b4bb8ddef924e45e19d7806343627f206b00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEwMzMzMQ==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448103331", "bodyText": "good. Thanks.", "author": "showuon", "createdAt": "2020-07-01T04:07:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNjM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNjg1Nw==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447836857", "bodyText": "exception not used.", "author": "abbccdda", "createdAt": "2020-06-30T16:55:49Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+        final TopicPartitionInfo partitionInfo = new TopicPartitionInfo(0, broker1,\n+                Collections.singletonList(broker1), Collections.singletonList(broker1));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionSuccessFuture = new KafkaFutureImpl<>();\n+        topicDescriptionSuccessFuture.complete(\n+            new TopicDescription(topic, false, Collections.singletonList(partitionInfo), Collections.emptySet())\n+        );\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionSuccessFuture)))\n+            .once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldThrowExceptionWhenKeepsTopicLeaderNotAvailable() {\n+        final String leaderNotAvailableTopic = \"LeaderNotAvailableTopic\";\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+\n+        // simulate describeTopics got LeaderNotAvailableException\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .times(2);\n+\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+\n+        final StreamsException exception = assertThrows(", "originalCommit": "9089b4bb8ddef924e45e19d7806343627f206b00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5OTU5OA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448099598", "bodyText": "Nice catch!", "author": "showuon", "createdAt": "2020-07-01T03:49:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNjg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzODUyMA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447838520", "bodyText": "nit: we could set a final int for numRetries as:\n            put(StreamsConfig.adminClientPrefix(StreamsConfig.RETRIES_CONFIG), numRetries);\n\n\nand use (numRetries + 1) here to clearly indicate we are trying to go beyond the retry limit.", "author": "abbccdda", "createdAt": "2020-06-30T16:58:24Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+        final TopicPartitionInfo partitionInfo = new TopicPartitionInfo(0, broker1,\n+                Collections.singletonList(broker1), Collections.singletonList(broker1));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionSuccessFuture = new KafkaFutureImpl<>();\n+        topicDescriptionSuccessFuture.complete(\n+            new TopicDescription(topic, false, Collections.singletonList(partitionInfo), Collections.emptySet())\n+        );\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionSuccessFuture)))\n+            .once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldThrowExceptionWhenKeepsTopicLeaderNotAvailable() {\n+        final String leaderNotAvailableTopic = \"LeaderNotAvailableTopic\";\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+\n+        // simulate describeTopics got LeaderNotAvailableException\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .times(2);", "originalCommit": "9089b4bb8ddef924e45e19d7806343627f206b00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEwMDkzMA==", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448100930", "bodyText": "good suggestion!", "author": "showuon", "createdAt": "2020-07-01T03:56:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzODUyMA=="}], "type": "inlineReview"}, {"oid": "4b57a606a3834323302b6d3d33ab95e5b88d183b", "url": "https://github.com/apache/kafka/commit/4b57a606a3834323302b6d3d33ab95e5b88d183b", "message": "KAFKA-10006: address reviewer's comments\n\n1. simplifiy code\n2. use the existing topic name in tests, instead of creating a new one\n3. use numRetries to indicate we are trying to go beyond the retry limit", "committedDate": "2020-07-01T04:08:41Z", "type": "commit"}, {"oid": "de9be72f4ccfddd7dc2e2b5b4968f4ecdb1693b0", "url": "https://github.com/apache/kafka/commit/de9be72f4ccfddd7dc2e2b5b4968f4ecdb1693b0", "message": "KAFKA-10006: remove duplicate properties", "committedDate": "2020-07-02T00:32:20Z", "type": "commit"}]}