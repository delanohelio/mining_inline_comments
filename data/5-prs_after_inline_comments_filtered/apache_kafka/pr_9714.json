{"pr_number": 9714, "pr_title": "MINOR: Remove connection id from Send and consolidate request/message utils", "pr_createdAt": "2020-12-08T20:30:17Z", "pr_url": "https://github.com/apache/kafka/pull/9714", "timeline": [{"oid": "87db298e186a9ec2e39acab57c0173982f8d5dc1", "url": "https://github.com/apache/kafka/commit/87db298e186a9ec2e39acab57c0173982f8d5dc1", "message": "MINOR: Remove connection id from Send and consolidate serialization utils", "committedDate": "2020-12-08T20:32:30Z", "type": "forcePushed"}, {"oid": "9b849c4cbb002801841b5c59c2cd67b2ffa78cee", "url": "https://github.com/apache/kafka/commit/9b849c4cbb002801841b5c59c2cd67b2ffa78cee", "message": "MINOR: Remove connection id from Send and consolidate serialization utils", "committedDate": "2020-12-08T23:49:24Z", "type": "commit"}, {"oid": "9b849c4cbb002801841b5c59c2cd67b2ffa78cee", "url": "https://github.com/apache/kafka/commit/9b849c4cbb002801841b5c59c2cd67b2ffa78cee", "message": "MINOR: Remove connection id from Send and consolidate serialization utils", "committedDate": "2020-12-08T23:49:24Z", "type": "forcePushed"}, {"oid": "59c1fffa25c461d20d03a65ad9eef6eaa3ab3d78", "url": "https://github.com/apache/kafka/commit/59c1fffa25c461d20d03a65ad9eef6eaa3ab3d78", "message": "Minor tweak", "committedDate": "2020-12-09T03:50:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk5MDk5OA==", "url": "https://github.com/apache/kafka/pull/9714#discussion_r538990998", "bodyText": "Why it need 4 byte if it exclude size prefix?", "author": "chia7712", "createdAt": "2020-12-09T04:09:07Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/RequestUtils.java", "diffHunk": "@@ -76,36 +75,22 @@ public static boolean hasTransactionalRecords(ProduceRequest request) {\n         return new AbstractMap.SimpleEntry<>(hasIdempotentRecords, hasTransactionalRecords);\n     }\n \n-    public static MessageSizeAccumulator size(\n-        ObjectSerializationCache serializationCache,\n-        Message header,\n-        short headerVersion,\n-        Message apiMessage,\n-        short apiVersion\n-    ) {\n-        MessageSizeAccumulator messageSize = new MessageSizeAccumulator();\n-        if (header != null)\n-            header.addSize(messageSize, serializationCache, headerVersion);\n-        apiMessage.addSize(messageSize, serializationCache, apiVersion);\n-        return messageSize;\n-    }\n-\n     public static ByteBuffer serialize(\n         Message header,\n         short headerVersion,\n         Message apiMessage,\n         short apiVersion\n     ) {\n-        ObjectSerializationCache serializationCache = new ObjectSerializationCache();\n-        MessageSizeAccumulator messageSize = RequestUtils.size(serializationCache, header, headerVersion, apiMessage, apiVersion);\n+        ObjectSerializationCache cache = new ObjectSerializationCache();\n+\n+        int headerSize = header.size(cache, headerVersion);\n+        int messageSize = apiMessage.size(cache, apiVersion);\n+        ByteBufferAccessor writable = new ByteBufferAccessor(ByteBuffer.allocate(4 + headerSize + messageSize));", "originalCommit": "59c1fffa25c461d20d03a65ad9eef6eaa3ab3d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAyMDg4Mg==", "url": "https://github.com/apache/kafka/pull/9714#discussion_r539020882", "bodyText": "Great catch. This was a copy and paste bug and we had no tests verifying this. I have fixed it and added a test.", "author": "ijuma", "createdAt": "2020-12-09T05:40:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk5MDk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk5NDA4OQ==", "url": "https://github.com/apache/kafka/pull/9714#discussion_r538994089", "bodyText": "This comment need to be updated.", "author": "chia7712", "createdAt": "2020-12-09T04:18:45Z", "path": "clients/src/main/java/org/apache/kafka/common/record/MultiRecordsSend.java", "diffHunk": "@@ -46,8 +45,7 @@\n      * Construct a MultiRecordsSend for the given destination from a queue of Send objects. The queue will be", "originalCommit": "59c1fffa25c461d20d03a65ad9eef6eaa3ab3d78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk5NDI4OQ==", "url": "https://github.com/apache/kafka/pull/9714#discussion_r538994289", "bodyText": "please remove \"destination\" from the docs", "author": "chia7712", "createdAt": "2020-12-09T04:19:20Z", "path": "clients/src/main/java/org/apache/kafka/common/network/Send.java", "diffHunk": "@@ -24,11 +24,6 @@\n  */\n public interface Send {", "originalCommit": "59c1fffa25c461d20d03a65ad9eef6eaa3ab3d78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAwMjE4OQ==", "url": "https://github.com/apache/kafka/pull/9714#discussion_r539002189", "bodyText": "unused argument", "author": "chia7712", "createdAt": "2020-12-09T04:44:58Z", "path": "clients/src/test/java/org/apache/kafka/common/requests/RequestTestUtils.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.requests;\n+\n+import org.apache.kafka.common.Node;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.internals.Topic;\n+import org.apache.kafka.common.message.MetadataResponseData;\n+import org.apache.kafka.common.protocol.ApiKeys;\n+import org.apache.kafka.common.protocol.Errors;\n+import org.apache.kafka.common.protocol.ObjectSerializationCache;\n+import org.apache.kafka.common.record.RecordBatch;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+public class RequestTestUtils {\n+\n+    public static ByteBuffer serializeRequestHeader(RequestHeader header) {\n+        ObjectSerializationCache serializationCache = new ObjectSerializationCache();\n+        ByteBuffer buffer = ByteBuffer.allocate(header.size(serializationCache));\n+        header.write(buffer, serializationCache);\n+        buffer.flip();\n+        return buffer;\n+    }\n+\n+    public static ByteBuffer serializeRequestWithHeader(RequestHeader header, AbstractRequest request) {\n+        return RequestUtils.serialize(header.data(), header.headerVersion(), request.data(), request.version());\n+    }\n+\n+    public static ByteBuffer serializeResponseWithHeader(AbstractResponse response, short version, int correlationId) {\n+        return response.serializeWithHeader(new ResponseHeader(correlationId,\n+            response.apiKey().responseHeaderVersion(version)), version);\n+    }\n+\n+    public static MetadataResponse metadataResponse(Collection<Node> brokers,\n+                                                    String clusterId, int controllerId,\n+                                                    List<MetadataResponse.TopicMetadata> topicMetadataList) {\n+        return metadataResponse(MetadataResponse.DEFAULT_THROTTLE_TIME, brokers, clusterId, controllerId,\n+                topicMetadataList, MetadataResponse.AUTHORIZED_OPERATIONS_OMITTED);\n+    }\n+\n+    public static MetadataResponse metadataResponse(int throttleTimeMs, Collection<Node> brokers,\n+                                                    String clusterId, int controllerId,\n+                                                    List<MetadataResponse.TopicMetadata> topicMetadatas,\n+                                                    int clusterAuthorizedOperations) {\n+        List<MetadataResponseData.MetadataResponseTopic> topics = new ArrayList<>();\n+        topicMetadatas.forEach(topicMetadata -> {\n+            MetadataResponseData.MetadataResponseTopic metadataResponseTopic = new MetadataResponseData.MetadataResponseTopic();\n+            metadataResponseTopic\n+                    .setErrorCode(topicMetadata.error().code())\n+                    .setName(topicMetadata.topic())\n+                    .setIsInternal(topicMetadata.isInternal())\n+                    .setTopicAuthorizedOperations(topicMetadata.authorizedOperations());\n+\n+            for (MetadataResponse.PartitionMetadata partitionMetadata : topicMetadata.partitionMetadata()) {\n+                metadataResponseTopic.partitions().add(new MetadataResponseData.MetadataResponsePartition()\n+                        .setErrorCode(partitionMetadata.error.code())\n+                        .setPartitionIndex(partitionMetadata.partition())\n+                        .setLeaderId(partitionMetadata.leaderId.orElse(MetadataResponse.NO_LEADER_ID))\n+                        .setLeaderEpoch(partitionMetadata.leaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH))\n+                        .setReplicaNodes(partitionMetadata.replicaIds)\n+                        .setIsrNodes(partitionMetadata.inSyncReplicaIds)\n+                        .setOfflineReplicas(partitionMetadata.offlineReplicaIds));\n+            }\n+            topics.add(metadataResponseTopic);\n+        });\n+        return MetadataResponse.prepareResponse(true, throttleTimeMs, brokers, clusterId, controllerId,\n+                topics, clusterAuthorizedOperations); }\n+\n+    public static MetadataResponse metadataUpdateWith(final int numNodes,\n+                                                      final Map<String, Integer> topicPartitionCounts) {\n+        return metadataUpdateWith(\"kafka-cluster\", numNodes, topicPartitionCounts);\n+    }\n+\n+    public static MetadataResponse metadataUpdateWith(final int numNodes,\n+                                                      final Map<String, Integer> topicPartitionCounts,\n+                                                      final Function<TopicPartition, Integer> epochSupplier) {\n+        return metadataUpdateWith(\"kafka-cluster\", numNodes, Collections.emptyMap(),\n+                topicPartitionCounts, epochSupplier, MetadataResponse.PartitionMetadata::new, ApiKeys.METADATA.latestVersion());\n+    }\n+\n+    public static MetadataResponse metadataUpdateWith(final String clusterId,\n+                                                      final int numNodes,\n+                                                      final Map<String, Integer> topicPartitionCounts) {\n+        return metadataUpdateWith(clusterId, numNodes, Collections.emptyMap(),\n+                topicPartitionCounts, tp -> null, MetadataResponse.PartitionMetadata::new, ApiKeys.METADATA.latestVersion());\n+    }\n+\n+    public static MetadataResponse metadataUpdateWith(final String clusterId,\n+                                                      final int numNodes,\n+                                                      final Map<String, Errors> topicErrors,\n+                                                      final Map<String, Integer> topicPartitionCounts) {\n+        return metadataUpdateWith(clusterId, numNodes, topicErrors,\n+                topicPartitionCounts, tp -> null, MetadataResponse.PartitionMetadata::new, ApiKeys.METADATA.latestVersion());\n+    }\n+\n+    public static MetadataResponse metadataUpdateWith(final String clusterId,\n+                                                      final int numNodes,\n+                                                      final Map<String, Errors> topicErrors,\n+                                                      final Map<String, Integer> topicPartitionCounts,\n+                                                      final short responseVersion) {", "originalCommit": "59c1fffa25c461d20d03a65ad9eef6eaa3ab3d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAxNjg4MA==", "url": "https://github.com/apache/kafka/pull/9714#discussion_r539016880", "bodyText": "Looks like a test bug from the previous PR. Will fix so that it's used.", "author": "ijuma", "createdAt": "2020-12-09T05:30:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAwMjE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAwNDI4Mw==", "url": "https://github.com/apache/kafka/pull/9714#discussion_r539004283", "bodyText": "RequestHeader#write has only 2 usages and both of them are in test scope. It should be fine to remove RequestHeader#write from production.", "author": "chia7712", "createdAt": "2020-12-09T04:51:44Z", "path": "clients/src/test/java/org/apache/kafka/common/requests/RequestTestUtils.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.requests;\n+\n+import org.apache.kafka.common.Node;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.internals.Topic;\n+import org.apache.kafka.common.message.MetadataResponseData;\n+import org.apache.kafka.common.protocol.ApiKeys;\n+import org.apache.kafka.common.protocol.Errors;\n+import org.apache.kafka.common.protocol.ObjectSerializationCache;\n+import org.apache.kafka.common.record.RecordBatch;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+public class RequestTestUtils {\n+\n+    public static ByteBuffer serializeRequestHeader(RequestHeader header) {\n+        ObjectSerializationCache serializationCache = new ObjectSerializationCache();\n+        ByteBuffer buffer = ByteBuffer.allocate(header.size(serializationCache));\n+        header.write(buffer, serializationCache);", "originalCommit": "59c1fffa25c461d20d03a65ad9eef6eaa3ab3d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAxNzMxNw==", "url": "https://github.com/apache/kafka/pull/9714#discussion_r539017317", "bodyText": "It's about conceptual integrity for the class. It should provide a mechanism for serialization that doesn't require reaching into its internal structures.", "author": "ijuma", "createdAt": "2020-12-09T05:31:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAwNDI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAyOTU5NA==", "url": "https://github.com/apache/kafka/pull/9714#discussion_r539029594", "bodyText": "fair enough", "author": "chia7712", "createdAt": "2020-12-09T05:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAwNDI4Mw=="}], "type": "inlineReview"}, {"oid": "13c7d5c2518d0d5e4272c23209f789ad0a383c95", "url": "https://github.com/apache/kafka/commit/13c7d5c2518d0d5e4272c23209f789ad0a383c95", "message": "Comment updates", "committedDate": "2020-12-09T05:38:05Z", "type": "commit"}, {"oid": "c1db89cde51599d859d24483b9c0ce2a1690b008", "url": "https://github.com/apache/kafka/commit/c1db89cde51599d859d24483b9c0ce2a1690b008", "message": "Fix 4 bytes wasted in `RequestUtils.serialize`", "committedDate": "2020-12-09T05:38:39Z", "type": "commit"}, {"oid": "b164ecab501fd4cbf051ad1492b7192bf6e92aca", "url": "https://github.com/apache/kafka/commit/b164ecab501fd4cbf051ad1492b7192bf6e92aca", "message": "Remove unnecessary `rewind` calls", "committedDate": "2020-12-09T05:39:04Z", "type": "commit"}, {"oid": "742ea7dc11c33c00b74ca0b742e894a0de72f2bd", "url": "https://github.com/apache/kafka/commit/742ea7dc11c33c00b74ca0b742e894a0de72f2bd", "message": "Use responseVersion in RequestTestUtils.metadataResponse", "committedDate": "2020-12-09T05:39:42Z", "type": "commit"}, {"oid": "f00dbe332cc4ccacab55a5fd1804e22b0ec62722", "url": "https://github.com/apache/kafka/commit/f00dbe332cc4ccacab55a5fd1804e22b0ec62722", "message": "Style fixes", "committedDate": "2020-12-09T05:40:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA2MzMwNQ==", "url": "https://github.com/apache/kafka/pull/9714#discussion_r539063305", "bodyText": "How about making SizeDelimitedSend be a static method in ByteBufferSend? For example:\n    public static Send withSizeDelimited(ByteBuffer buffer) {\n        ByteBuffer sizeBuffer = ByteBuffer.allocate(4);\n        sizeBuffer.putInt(0, buffer.remaining());\n        return new ByteBufferSend(sizeBuffer, buffer);\n    }", "author": "chia7712", "createdAt": "2020-12-09T07:16:49Z", "path": "clients/src/main/java/org/apache/kafka/common/network/SizeDelimitedSend.java", "diffHunk": "@@ -14,18 +14,22 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-\n-package org.apache.kafka.common.protocol;\n+package org.apache.kafka.common.network;\n \n import java.nio.ByteBuffer;\n \n-public final class MessageTestUtil {\n-    public static ByteBuffer messageToByteBuffer(Message message, short version) {\n-        ObjectSerializationCache cache = new ObjectSerializationCache();\n-        int size = message.size(cache, version);\n-        ByteBuffer bytes = ByteBuffer.allocate(size);\n-        message.write(new ByteBufferAccessor(bytes), cache, version);\n-        bytes.rewind();\n-        return bytes;\n+/**\n+ * A size delimited Send that consists of a 4 byte network-ordered size N followed by N bytes of content.\n+ */\n+public class SizeDelimitedSend extends ByteBufferSend {", "originalCommit": "f00dbe332cc4ccacab55a5fd1804e22b0ec62722", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3OTY4MQ==", "url": "https://github.com/apache/kafka/pull/9714#discussion_r539079681", "bodyText": "I had the same thought and initially did that, but it's an issue for many tests since they verify the properties of the ByteBuffer and it is not accessible if we do this.", "author": "ijuma", "createdAt": "2020-12-09T07:49:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA2MzMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4NjM4MQ==", "url": "https://github.com/apache/kafka/pull/9714#discussion_r539086381", "bodyText": "but it's an issue for many tests since they verify the properties of the ByteBuffer and it is not accessible if we do this.\n\nCan it be resolved if we return ByteBuffer rather than Send?", "author": "chia7712", "createdAt": "2020-12-09T08:02:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA2MzMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMyMzU4Ng==", "url": "https://github.com/apache/kafka/pull/9714#discussion_r539323586", "bodyText": "It has to be a Send too. I looked at this a bit closer and we can just return ByteBufferSend from the static factory method. The thing I attempted before was to combine at the NetworkSend level and that doesn't work since NetworkSend can work with Sends that are not backed by a ByteBuffer. But it actually works fine at ByteBufferSend level. Thanks for the suggestion, please check the update.", "author": "ijuma", "createdAt": "2020-12-09T13:53:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA2MzMwNQ=="}], "type": "inlineReview"}, {"oid": "e86ed57b683688e56b031287b0588284935e78cc", "url": "https://github.com/apache/kafka/commit/e86ed57b683688e56b031287b0588284935e78cc", "message": "Replace SizeDelimitedSend with ByteBufferSend.sizePrefixed static factory method", "committedDate": "2020-12-09T13:51:17Z", "type": "commit"}]}