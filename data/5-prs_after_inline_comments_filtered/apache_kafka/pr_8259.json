{"pr_number": 8259, "pr_title": "KAFKA-7421: Ensure Connect's PluginClassLoader is truly parallel capable and resolve deadlock occurrences", "pr_createdAt": "2020-03-09T20:58:21Z", "pr_url": "https://github.com/apache/kafka/pull/8259", "timeline": [{"oid": "9903b7798d842d3f373468e39c2a9924224a61e5", "url": "https://github.com/apache/kafka/commit/9903b7798d842d3f373468e39c2a9924224a61e5", "message": "KAFKA-7421: Reproduce Plugin/Delegating ClassLoader deadlock\n\n* Adds SynchronizationTest with a single case\n* Simulates Worker::startConnector and Worker::startTask classloading difference\n\nSigned-off-by: Greg Harris <gregh@confluent.io>", "committedDate": "2020-03-09T20:53:40Z", "type": "commit"}, {"oid": "2686516f494f52fe9089cdf760a3a858c0b50a40", "url": "https://github.com/apache/kafka/commit/2686516f494f52fe9089cdf760a3a858c0b50a40", "message": "Fix some comments and factor out the thread factory to a function\n\nSigned-off-by: Greg Harris <gregh@confluent.io>", "committedDate": "2020-03-10T01:08:54Z", "type": "commit"}, {"oid": "f376a1799a021a02684714219b24e94bfbb208cf", "url": "https://github.com/apache/kafka/commit/f376a1799a021a02684714219b24e94bfbb208cf", "message": "Simplify test by removing second breakpoint\n\nSigned-off-by: Greg Harris <gregh@confluent.io>", "committedDate": "2020-03-10T01:09:47Z", "type": "commit"}, {"oid": "f2aadadd16a4c42f543ee61810b18c37f1084c94", "url": "https://github.com/apache/kafka/commit/f2aadadd16a4c42f543ee61810b18c37f1084c94", "message": "Refactor SynchronizationTest to support multiple test methods\n\n* Scope executor pool naming to per-method with TestName rule\n* Don't fail teardown if test contains a deadlock\n* Scope deadlock assertion to only test threads\n\nSigned-off-by: Greg Harris <gregh@confluent.io>", "committedDate": "2020-03-12T23:41:32Z", "type": "commit"}, {"oid": "f499c794580782d73914114b05b778545e2b4e56", "url": "https://github.com/apache/kafka/commit/f499c794580782d73914114b05b778545e2b4e56", "message": "Add back double-breakpoint to SynchronizedDelegatingClassLoader\n\n* Ensures that threads make progress and hold locks before continuing\n* This prevents a race condition in the test where we depended on the debug sleeps\n\nSigned-off-by: Greg Harris <gregh@confluent.io>", "committedDate": "2020-03-12T23:41:32Z", "type": "commit"}, {"oid": "03db64863f5fc22d34b91c2ec5f18abd494b4e88", "url": "https://github.com/apache/kafka/commit/03db64863f5fc22d34b91c2ec5f18abd494b4e88", "message": "Add informative test that isolates forName as the call locking the classloader\n\nSigned-off-by: Greg Harris <gregh@confluent.io>", "committedDate": "2020-03-12T23:41:32Z", "type": "commit"}, {"oid": "252af473c0b5aa1505a7eb90705063b82818e92a", "url": "https://github.com/apache/kafka/commit/252af473c0b5aa1505a7eb90705063b82818e92a", "message": "KAFKA-7421: Remove method lock from PluginClassLoader loadClass", "committedDate": "2021-02-25T07:42:33Z", "type": "commit"}, {"oid": "43c856917efe49853625ca6d0b6512f6370e6736", "url": "https://github.com/apache/kafka/commit/43c856917efe49853625ca6d0b6512f6370e6736", "message": "KAFKA-7421: Use concurrent maps in loadClass of DelegatingClassLoader", "committedDate": "2021-02-25T07:44:00Z", "type": "commit"}, {"oid": "858a37a8bf88db23e5bdd93683c799b840fbf693", "url": "https://github.com/apache/kafka/commit/858a37a8bf88db23e5bdd93683c799b840fbf693", "message": "KAFKA-7421: Make the test classloader a parallel classloader in tests", "committedDate": "2021-02-25T07:44:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjYxNDQ0Mw==", "url": "https://github.com/apache/kafka/pull/8259#discussion_r582614443", "bodyText": "@gharris1727 I had to remove the expectation for an AssertionError because this test does not reproduce a deadlock anymore. Do we think this test case is still valuable?", "author": "kkonstantine", "createdAt": "2021-02-25T07:56:02Z", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/SynchronizationTest.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.connect.runtime.isolation;\n+\n+import static org.junit.Assert.fail;\n+\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.common.config.AbstractConfig;\n+import org.apache.kafka.common.config.ConfigDef;\n+import org.apache.kafka.common.config.ConfigDef.Importance;\n+import org.apache.kafka.common.config.ConfigDef.Type;\n+import org.apache.kafka.connect.runtime.WorkerConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SynchronizationTest {\n+\n+    public static final Logger log = LoggerFactory.getLogger(SynchronizationTest.class);\n+\n+    @Rule\n+    public final TestName testName = new TestName();\n+\n+    private String threadPrefix;\n+    private Plugins plugins;\n+    private ThreadPoolExecutor exec;\n+    private Breakpoint<String> dclBreakpoint;\n+    private Breakpoint<String> pclBreakpoint;\n+\n+    @Before\n+    public void setup() {\n+        TestPlugins.assertAvailable();\n+        Map<String, String> pluginProps = Collections.singletonMap(\n+            WorkerConfig.PLUGIN_PATH_CONFIG,\n+            String.join(\",\", TestPlugins.pluginPath())\n+        );\n+        threadPrefix = SynchronizationTest.class.getSimpleName()\n+            + \".\" + testName.getMethodName() + \"-\";\n+        dclBreakpoint = new Breakpoint<>();\n+        pclBreakpoint = new Breakpoint<>();\n+        plugins = new Plugins(pluginProps) {\n+            @Override\n+            protected DelegatingClassLoader newDelegatingClassLoader(List<String> paths) {\n+                return AccessController.doPrivileged(\n+                    (PrivilegedAction<DelegatingClassLoader>) () ->\n+                        new SynchronizedDelegatingClassLoader(paths)\n+                );\n+            }\n+        };\n+        exec = new ThreadPoolExecutor(\n+            2,\n+            2,\n+            1000L,\n+            TimeUnit.MILLISECONDS,\n+            new LinkedBlockingDeque<>(),\n+            threadFactoryWithNamedThreads(threadPrefix)\n+        );\n+\n+    }\n+\n+    @After\n+    public void tearDown() throws InterruptedException {\n+        dclBreakpoint.clear();\n+        pclBreakpoint.clear();\n+        exec.shutdown();\n+        exec.awaitTermination(1L, TimeUnit.SECONDS);\n+    }\n+\n+    private static class Breakpoint<T> {\n+\n+        private Predicate<T> predicate;\n+        private CyclicBarrier barrier;\n+\n+        public synchronized void clear() {\n+            if (barrier != null) {\n+                barrier.reset();\n+            }\n+            predicate = null;\n+            barrier = null;\n+        }\n+\n+        public synchronized void set(Predicate<T> predicate) {\n+            clear();\n+            this.predicate = predicate;\n+            // As soon as the barrier is tripped, the barrier will be reset for the next round.\n+            barrier = new CyclicBarrier(2);\n+        }\n+\n+        /**\n+         * From a thread under test, await for the test orchestrator to continue execution\n+         * @param obj Object to test with the breakpoint's current predicate\n+         */\n+        public void await(T obj) {\n+            Predicate<T> predicate;\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                predicate  = this.predicate;\n+                barrier = this.barrier;\n+            }\n+            if (predicate != null && !predicate.test(obj)) {\n+                return;\n+            }\n+            if (barrier != null) {\n+                try {\n+                    barrier.await();\n+                } catch (InterruptedException | BrokenBarrierException e) {\n+                    throw new RuntimeException(\"Interrupted while waiting for load gate\", e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * From the test orchestrating thread, await for the test thread to continue execution\n+         * @throws InterruptedException If the current thread is interrupted while waiting\n+         * @throws BrokenBarrierException If the test thread is interrupted while waiting\n+         * @throws TimeoutException If the barrier is not reached before 1s passes.\n+         */\n+        public void testAwait()\n+            throws InterruptedException, BrokenBarrierException, TimeoutException {\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                barrier = this.barrier;\n+            }\n+            Objects.requireNonNull(barrier, \"Barrier must be set up before awaiting\");\n+            barrier.await(1L, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private class SynchronizedDelegatingClassLoader extends DelegatingClassLoader {\n+\n+        public SynchronizedDelegatingClassLoader(List<String> pluginPaths) {\n+            super(pluginPaths);\n+        }\n+\n+        @Override\n+        protected PluginClassLoader newPluginClassLoader(\n+            URL pluginLocation,\n+            URL[] urls,\n+            ClassLoader parent\n+        ) {\n+            return AccessController.doPrivileged(\n+                (PrivilegedAction<PluginClassLoader>) () ->\n+                    new SynchronizedPluginClassLoader(pluginLocation, urls, parent)\n+            );\n+        }\n+\n+        @Override\n+        public PluginClassLoader pluginClassLoader(String name) {\n+            dclBreakpoint.await(name);\n+            dclBreakpoint.await(name);\n+            return super.pluginClassLoader(name);\n+        }\n+    }\n+\n+    private class SynchronizedPluginClassLoader extends PluginClassLoader {\n+        {\n+            ClassLoader.registerAsParallelCapable();\n+        }\n+\n+\n+        public SynchronizedPluginClassLoader(URL pluginLocation, URL[] urls, ClassLoader parent) {\n+            super(pluginLocation, urls, parent);\n+        }\n+\n+        @Override\n+        protected Object getClassLoadingLock(String className) {\n+            pclBreakpoint.await(className);\n+            return super.getClassLoadingLock(className);\n+        }\n+    }\n+\n+    @Test(timeout = 15000L)\n+    // If the test times out, then there's a deadlock in the test but not necessarily the code\n+    public void workerContextClassLoaderMismatch() throws Exception {\n+        // Grab a reference to the target PluginClassLoader before activating breakpoints\n+        ClassLoader connectorLoader = plugins.delegatingLoader()\n+            .connectorLoader(TestPlugins.SAMPLING_CONVERTER);\n+\n+        // Simulate Worker::startConnector that creates configs with the delegating classloader\n+        Runnable delegatingToPlugin = () -> {\n+            // Use the DelegatingClassLoader as the current context loader\n+            ClassLoader savedLoader = Plugins.compareAndSwapLoaders(plugins.delegatingLoader());\n+\n+            // Load an isolated plugin from the delegating classloader, which will\n+            // 1. Lock the DelegatingClassLoader (via Class.forName)\n+            // 2. Wait for test to continue\n+            // 3. Attempt to lock the PluginClassLoader (via PluginClassLoader::loadClass)\n+            // 4. Deadlock\n+            new AbstractConfig(\n+                new ConfigDef().define(\"a.class\", Type.CLASS, Importance.HIGH, \"\"),\n+                Collections.singletonMap(\"a.class\", TestPlugins.SAMPLING_CONVERTER));\n+            Plugins.compareAndSwapLoaders(savedLoader);\n+        };\n+        // DelegatingClassLoader breakpoint will only trigger on this thread\n+        dclBreakpoint.set(TestPlugins.SAMPLING_CONVERTER::equals);\n+\n+        // Simulate Worker::startTask that creates configs with the plugin classloader\n+        Runnable pluginToDelegating = () -> {\n+            // Use the PluginClassLoader as the current context loader\n+            ClassLoader savedLoader = Plugins.compareAndSwapLoaders(connectorLoader);\n+            // Load a non-isolated class from the plugin classloader, which will\n+            // 1. Lock the PluginClassLoader (via PluginClassLoader::loadClass)\n+            // 2. Wait for the test to continue\n+            // 3. Attempt to lock the DelegatingClassLoader (via ClassLoader::loadClass)\n+            // 4. Deadlock\n+            new AbstractConfig(new ConfigDef().define(\"a.class\", Type.CLASS, Importance.HIGH, \"\"),\n+                Collections.singletonMap(\"a.class\", \"org.apache.kafka.connect.storage.JsonConverter\"));\n+            Plugins.compareAndSwapLoaders(savedLoader);\n+        };\n+        // PluginClassLoader breakpoint will only trigger on this thread\n+        pclBreakpoint.set(\"org.apache.kafka.connect.storage.JsonConverter\"::equals);\n+\n+        // Step 1: Lock the delegating classloader and pause\n+        exec.submit(delegatingToPlugin);\n+        // d2p enters ConfigDef::parseType\n+        // d2p enters DelegatingClassLoader::loadClass\n+        dclBreakpoint.testAwait();\n+        dclBreakpoint.testAwait();\n+        // d2p exits DelegatingClassLoader::loadClass\n+        // d2p enters Class::forName\n+        // d2p LOCKS DelegatingClassLoader\n+        // d2p enters DelegatingClassLoader::loadClass\n+        dclBreakpoint.testAwait();\n+        // d2p waits in the delegating classloader while we set up the other thread\n+        dumpThreads(\"d2p waiting with DelegatingClassLoader locked\");\n+\n+        // Step 2: Lock the plugin classloader and then the delegating classloader\n+        exec.submit(pluginToDelegating);\n+        // p2d enters PluginClassLoader::loadClass\n+        // p2d LOCKS PluginClassLoader\n+        pclBreakpoint.testAwait();\n+        // p2d locks the class-specific classLoadingLock\n+        // p2d falls through to ClassLoader::loadClass\n+        pclBreakpoint.testAwait();\n+        // p2d locks the class-specific classLoadingLock\n+        // p2d delegates upwards to DelegatingClassLoader::loadClass\n+        // p2d enters ClassLoader::loadClass\n+        // p2d LOCKS DelegatingClassLoader (starting the deadlock)\n+        dumpThreads(\"p2d blocked trying to acquire the DelegatingClassLoader lock\");\n+\n+        // Step 3: Resume the first thread and try to lock the plugin classloader\n+        dclBreakpoint.testAwait();\n+        // d2p enters PluginClassLoader::loadClass\n+        // d2p LOCKS PluginClassLoader (completing the deadlock)\n+        dumpThreads(\"d2p blocked trying to acquire the PluginClassLoader lock\");\n+        assertNoDeadlocks();\n+    }\n+\n+    // This is an informative test that is supposed to fail, demonstrating that forName is\n+    // locking the connectorLoader in this JVM implementation, when initialize is true.\n+    @Test", "originalCommit": "858a37a8bf88db23e5bdd93683c799b840fbf693", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTAyMDczNw==", "url": "https://github.com/apache/kafka/pull/8259#discussion_r585020737", "bodyText": "This test was useful for narrowing down on the root-cause of the issue (forName locking the PCL) and it's nice to see that the deadlock in both tests was prevented by the fix. I think it was oversight on my part to mark it expected, as at the time I believed that it was the expected behavior. I realize now that it was a side-effect of the bug, and of the classloader not being marked parallel.\nAt this time, I would call this test a targeted subset (\"unit\") of the above test (\"integration\"), and is pretty low-cost to keep around.", "author": "gharris1727", "createdAt": "2021-03-01T20:17:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjYxNDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTA3ODI5Mg==", "url": "https://github.com/apache/kafka/pull/8259#discussion_r585078292", "bodyText": "Ok, great to hear. I'm all up for leaving a functional unit test in this topic where we were lacking good coverage.\nFeel free to update the comments to make them current.\nEven more importantly, maybe consider adding a high level description on every test to say what we expect to test and assert, because just following each expected call (with most sections having already good comments) does not make it too easy to understand the gist of each test.", "author": "kkonstantine", "createdAt": "2021-03-01T21:56:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjYxNDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4OTU1MzYxNQ==", "url": "https://github.com/apache/kafka/pull/8259#discussion_r589553615", "bodyText": "+1 for correcting the existing comments and adding more descriptive comments where there are none.\nAlso, in some other places (including ConnectWorkerIntegrationTest) we've used a \"When ...\" comment (sometimes followed by one or more \"And when ...\" comments) to describe the preconditions, followed by a \"Then ...\" comment (and maybe more \"And then ...\" comments) stating the expected behaviors. These can help make it easier to explain the purpose of the tests beyond a simple description.", "author": "rhauch", "createdAt": "2021-03-08T16:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjYxNDQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTA3NjU0MA==", "url": "https://github.com/apache/kafka/pull/8259#discussion_r585076540", "bodyText": "Let's remove if this does not apply.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // This also becomes non-functional\n          \n          \n            \n                    //if (i < stackTrace.length) {\n          \n          \n            \n                    //sb.append(\"\\t...\");\n          \n          \n            \n                    //sb.append('\\n');\n          \n          \n            \n                    //}", "author": "kkonstantine", "createdAt": "2021-03-01T21:53:16Z", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/SynchronizationTest.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.connect.runtime.isolation;\n+\n+import static org.junit.Assert.fail;\n+\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.common.config.AbstractConfig;\n+import org.apache.kafka.common.config.ConfigDef;\n+import org.apache.kafka.common.config.ConfigDef.Importance;\n+import org.apache.kafka.common.config.ConfigDef.Type;\n+import org.apache.kafka.connect.runtime.WorkerConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SynchronizationTest {\n+\n+    public static final Logger log = LoggerFactory.getLogger(SynchronizationTest.class);\n+\n+    @Rule\n+    public final TestName testName = new TestName();\n+\n+    private String threadPrefix;\n+    private Plugins plugins;\n+    private ThreadPoolExecutor exec;\n+    private Breakpoint<String> dclBreakpoint;\n+    private Breakpoint<String> pclBreakpoint;\n+\n+    @Before\n+    public void setup() {\n+        TestPlugins.assertAvailable();\n+        Map<String, String> pluginProps = Collections.singletonMap(\n+            WorkerConfig.PLUGIN_PATH_CONFIG,\n+            String.join(\",\", TestPlugins.pluginPath())\n+        );\n+        threadPrefix = SynchronizationTest.class.getSimpleName()\n+            + \".\" + testName.getMethodName() + \"-\";\n+        dclBreakpoint = new Breakpoint<>();\n+        pclBreakpoint = new Breakpoint<>();\n+        plugins = new Plugins(pluginProps) {\n+            @Override\n+            protected DelegatingClassLoader newDelegatingClassLoader(List<String> paths) {\n+                return AccessController.doPrivileged(\n+                    (PrivilegedAction<DelegatingClassLoader>) () ->\n+                        new SynchronizedDelegatingClassLoader(paths)\n+                );\n+            }\n+        };\n+        exec = new ThreadPoolExecutor(\n+            2,\n+            2,\n+            1000L,\n+            TimeUnit.MILLISECONDS,\n+            new LinkedBlockingDeque<>(),\n+            threadFactoryWithNamedThreads(threadPrefix)\n+        );\n+\n+    }\n+\n+    @After\n+    public void tearDown() throws InterruptedException {\n+        dclBreakpoint.clear();\n+        pclBreakpoint.clear();\n+        exec.shutdown();\n+        exec.awaitTermination(1L, TimeUnit.SECONDS);\n+    }\n+\n+    private static class Breakpoint<T> {\n+\n+        private Predicate<T> predicate;\n+        private CyclicBarrier barrier;\n+\n+        public synchronized void clear() {\n+            if (barrier != null) {\n+                barrier.reset();\n+            }\n+            predicate = null;\n+            barrier = null;\n+        }\n+\n+        public synchronized void set(Predicate<T> predicate) {\n+            clear();\n+            this.predicate = predicate;\n+            // As soon as the barrier is tripped, the barrier will be reset for the next round.\n+            barrier = new CyclicBarrier(2);\n+        }\n+\n+        /**\n+         * From a thread under test, await for the test orchestrator to continue execution\n+         * @param obj Object to test with the breakpoint's current predicate\n+         */\n+        public void await(T obj) {\n+            Predicate<T> predicate;\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                predicate  = this.predicate;\n+                barrier = this.barrier;\n+            }\n+            if (predicate != null && !predicate.test(obj)) {\n+                return;\n+            }\n+            if (barrier != null) {\n+                try {\n+                    barrier.await();\n+                } catch (InterruptedException | BrokenBarrierException e) {\n+                    throw new RuntimeException(\"Interrupted while waiting for load gate\", e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * From the test orchestrating thread, await for the test thread to continue execution\n+         * @throws InterruptedException If the current thread is interrupted while waiting\n+         * @throws BrokenBarrierException If the test thread is interrupted while waiting\n+         * @throws TimeoutException If the barrier is not reached before 1s passes.\n+         */\n+        public void testAwait()\n+            throws InterruptedException, BrokenBarrierException, TimeoutException {\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                barrier = this.barrier;\n+            }\n+            Objects.requireNonNull(barrier, \"Barrier must be set up before awaiting\");\n+            barrier.await(1L, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private class SynchronizedDelegatingClassLoader extends DelegatingClassLoader {\n+\n+        public SynchronizedDelegatingClassLoader(List<String> pluginPaths) {\n+            super(pluginPaths);\n+        }\n+\n+        @Override\n+        protected PluginClassLoader newPluginClassLoader(\n+            URL pluginLocation,\n+            URL[] urls,\n+            ClassLoader parent\n+        ) {\n+            return AccessController.doPrivileged(\n+                (PrivilegedAction<PluginClassLoader>) () ->\n+                    new SynchronizedPluginClassLoader(pluginLocation, urls, parent)\n+            );\n+        }\n+\n+        @Override\n+        public PluginClassLoader pluginClassLoader(String name) {\n+            dclBreakpoint.await(name);\n+            dclBreakpoint.await(name);\n+            return super.pluginClassLoader(name);\n+        }\n+    }\n+\n+    private class SynchronizedPluginClassLoader extends PluginClassLoader {\n+        {\n+            ClassLoader.registerAsParallelCapable();\n+        }\n+\n+\n+        public SynchronizedPluginClassLoader(URL pluginLocation, URL[] urls, ClassLoader parent) {\n+            super(pluginLocation, urls, parent);\n+        }\n+\n+        @Override\n+        protected Object getClassLoadingLock(String className) {\n+            pclBreakpoint.await(className);\n+            return super.getClassLoadingLock(className);\n+        }\n+    }\n+\n+    @Test(timeout = 15000L)\n+    // If the test times out, then there's a deadlock in the test but not necessarily the code\n+    public void workerContextClassLoaderMismatch() throws Exception {\n+        // Grab a reference to the target PluginClassLoader before activating breakpoints\n+        ClassLoader connectorLoader = plugins.delegatingLoader()\n+            .connectorLoader(TestPlugins.SAMPLING_CONVERTER);\n+\n+        // Simulate Worker::startConnector that creates configs with the delegating classloader\n+        Runnable delegatingToPlugin = () -> {\n+            // Use the DelegatingClassLoader as the current context loader\n+            ClassLoader savedLoader = Plugins.compareAndSwapLoaders(plugins.delegatingLoader());\n+\n+            // Load an isolated plugin from the delegating classloader, which will\n+            // 1. Lock the DelegatingClassLoader (via Class.forName)\n+            // 2. Wait for test to continue\n+            // 3. Attempt to lock the PluginClassLoader (via PluginClassLoader::loadClass)\n+            // 4. Deadlock\n+            new AbstractConfig(\n+                new ConfigDef().define(\"a.class\", Type.CLASS, Importance.HIGH, \"\"),\n+                Collections.singletonMap(\"a.class\", TestPlugins.SAMPLING_CONVERTER));\n+            Plugins.compareAndSwapLoaders(savedLoader);\n+        };\n+        // DelegatingClassLoader breakpoint will only trigger on this thread\n+        dclBreakpoint.set(TestPlugins.SAMPLING_CONVERTER::equals);\n+\n+        // Simulate Worker::startTask that creates configs with the plugin classloader\n+        Runnable pluginToDelegating = () -> {\n+            // Use the PluginClassLoader as the current context loader\n+            ClassLoader savedLoader = Plugins.compareAndSwapLoaders(connectorLoader);\n+            // Load a non-isolated class from the plugin classloader, which will\n+            // 1. Lock the PluginClassLoader (via PluginClassLoader::loadClass)\n+            // 2. Wait for the test to continue\n+            // 3. Attempt to lock the DelegatingClassLoader (via ClassLoader::loadClass)\n+            // 4. Deadlock\n+            new AbstractConfig(new ConfigDef().define(\"a.class\", Type.CLASS, Importance.HIGH, \"\"),\n+                Collections.singletonMap(\"a.class\", \"org.apache.kafka.connect.storage.JsonConverter\"));\n+            Plugins.compareAndSwapLoaders(savedLoader);\n+        };\n+        // PluginClassLoader breakpoint will only trigger on this thread\n+        pclBreakpoint.set(\"org.apache.kafka.connect.storage.JsonConverter\"::equals);\n+\n+        // Step 1: Lock the delegating classloader and pause\n+        exec.submit(delegatingToPlugin);\n+        // d2p enters ConfigDef::parseType\n+        // d2p enters DelegatingClassLoader::loadClass\n+        dclBreakpoint.testAwait();\n+        dclBreakpoint.testAwait();\n+        // d2p exits DelegatingClassLoader::loadClass\n+        // d2p enters Class::forName\n+        // d2p LOCKS DelegatingClassLoader\n+        // d2p enters DelegatingClassLoader::loadClass\n+        dclBreakpoint.testAwait();\n+        // d2p waits in the delegating classloader while we set up the other thread\n+        dumpThreads(\"d2p waiting with DelegatingClassLoader locked\");\n+\n+        // Step 2: Lock the plugin classloader and then the delegating classloader\n+        exec.submit(pluginToDelegating);\n+        // p2d enters PluginClassLoader::loadClass\n+        // p2d LOCKS PluginClassLoader\n+        pclBreakpoint.testAwait();\n+        // p2d locks the class-specific classLoadingLock\n+        // p2d falls through to ClassLoader::loadClass\n+        pclBreakpoint.testAwait();\n+        // p2d locks the class-specific classLoadingLock\n+        // p2d delegates upwards to DelegatingClassLoader::loadClass\n+        // p2d enters ClassLoader::loadClass\n+        // p2d LOCKS DelegatingClassLoader (starting the deadlock)\n+        dumpThreads(\"p2d blocked trying to acquire the DelegatingClassLoader lock\");\n+\n+        // Step 3: Resume the first thread and try to lock the plugin classloader\n+        dclBreakpoint.testAwait();\n+        // d2p enters PluginClassLoader::loadClass\n+        // d2p LOCKS PluginClassLoader (completing the deadlock)\n+        dumpThreads(\"d2p blocked trying to acquire the PluginClassLoader lock\");\n+        assertNoDeadlocks();\n+    }\n+\n+    // This is an informative test that is supposed to fail, demonstrating that forName is\n+    // locking the connectorLoader in this JVM implementation, when initialize is true.\n+    @Test\n+    public void forNameLocksClassloader()\n+        throws InterruptedException, TimeoutException, BrokenBarrierException {\n+        // It is not important here that we're using the PluginClassLoader.\n+        // This behavior is specific to the JVM, not the classloader implementation\n+        // It is just a convenient classloader instance that we can throw away after the test\n+        ClassLoader connectorLoader = plugins.delegatingLoader()\n+            .connectorLoader(TestPlugins.SAMPLING_CONVERTER);\n+\n+        Object monitor = new Object();\n+        Breakpoint<Object> monitorBreakpoint = new Breakpoint<>();\n+        Breakpoint<Object> progress = new Breakpoint<>();\n+\n+        Runnable executeForName = () -> {\n+            synchronized (monitor) {\n+                try {\n+                    progress.await(null);\n+                    Class.forName(TestPlugins.SAMPLING_CONVERTER, true, connectorLoader);\n+                } catch (ClassNotFoundException e) {\n+                    throw new RuntimeException(\"Failed to load test plugin\", e);\n+                }\n+            }\n+        };\n+        progress.set(null);\n+\n+        Runnable holdsMonitorLock = () -> {\n+            synchronized (connectorLoader) {\n+                monitorBreakpoint.await(null);\n+                monitorBreakpoint.await(null);\n+                synchronized (monitor) {\n+                }\n+            }\n+        };\n+        monitorBreakpoint.set(null);\n+\n+        exec.submit(holdsMonitorLock);\n+        // LOCK the classloader\n+        // wait for test to progress\n+        dumpThreads(\"locked the classloader\");\n+        monitorBreakpoint.testAwait();\n+\n+        exec.submit(executeForName);\n+        progress.testAwait();\n+        // LOCK the monitor\n+        // LOCK the classloader (starting the deadlock)\n+        dumpThreads(\"half-deadlocked\");\n+        monitorBreakpoint.testAwait();\n+        // LOCK the monitor (completing the deadlock)\n+\n+        assertNoDeadlocks();\n+    }\n+\n+    private boolean threadFromCurrentTest(ThreadInfo threadInfo) {\n+        return threadInfo.getThreadName().startsWith(threadPrefix);\n+    }\n+\n+    private void assertNoDeadlocks() {\n+        long[] deadlockedThreads = ManagementFactory.getThreadMXBean().findDeadlockedThreads();\n+        if (deadlockedThreads != null && deadlockedThreads.length > 0) {\n+            final String threads = Arrays\n+                .stream(ManagementFactory.getThreadMXBean().getThreadInfo(deadlockedThreads))\n+                .filter(this::threadFromCurrentTest)\n+                .map(SynchronizationTest::threadInfoToString)\n+                .collect(Collectors.joining(\"\"));\n+            if (!threads.isEmpty()) {\n+                fail(\"Found deadlocked threads while classloading\\n\" + threads);\n+            }\n+        }\n+    }\n+\n+    private void dumpThreads(String msg) throws InterruptedException {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"{}:\\n{}\",\n+                msg,\n+                Arrays.stream(ManagementFactory.getThreadMXBean().dumpAllThreads(true, true))\n+                    .filter(this::threadFromCurrentTest)\n+                    .map(SynchronizationTest::threadInfoToString)\n+                    .collect(Collectors.joining(\"\\n\"))\n+            );\n+        }\n+    }\n+\n+    private static String threadInfoToString(ThreadInfo info) {\n+        StringBuilder sb = new StringBuilder(\"\\\"\" + info.getThreadName() + \"\\\"\" +\n+            \" Id=\" + info.getThreadId() + \" \" +\n+            info.getThreadState());\n+        if (info.getLockName() != null) {\n+            sb.append(\" on \" + info.getLockName());\n+        }\n+        if (info.getLockOwnerName() != null) {\n+            sb.append(\" owned by \\\"\" + info.getLockOwnerName() +\n+                \"\\\" Id=\" + info.getLockOwnerId());\n+        }\n+        if (info.isSuspended()) {\n+            sb.append(\" (suspended)\");\n+        }\n+        if (info.isInNative()) {\n+            sb.append(\" (in native)\");\n+        }\n+        sb.append('\\n');\n+        // this has been refactored for checkstyle\n+        printStacktrace(info, sb);\n+        LockInfo[] locks = info.getLockedSynchronizers();\n+        if (locks.length > 0) {\n+            sb.append(\"\\n\\tNumber of locked synchronizers = \" + locks.length);\n+            sb.append('\\n');\n+            for (LockInfo li : locks) {\n+                sb.append(\"\\t- \" + li);\n+                sb.append('\\n');\n+            }\n+        }\n+        sb.append('\\n');\n+        return sb.toString();\n+    }\n+\n+    private static void printStacktrace(ThreadInfo info, StringBuilder sb) {\n+        StackTraceElement[] stackTrace = info.getStackTrace();\n+        int i = 0;\n+        // This is a copy of ThreadInfo::toString but with an unlimited number of frames shown.\n+        //for (; i < stackTrace.length && i < MAX_FRAMES; i++) {\n+        for (; i < stackTrace.length; i++) {\n+            StackTraceElement ste = stackTrace[i];\n+            sb.append(\"\\tat \" + ste.toString());\n+            sb.append('\\n');\n+            if (i == 0 && info.getLockInfo() != null) {\n+                Thread.State ts = info.getThreadState();\n+                switch (ts) {\n+                    case BLOCKED:\n+                        sb.append(\"\\t-  blocked on \" + info.getLockInfo());\n+                        sb.append('\\n');\n+                        break;\n+                    case WAITING:\n+                        sb.append(\"\\t-  waiting on \" + info.getLockInfo());\n+                        sb.append('\\n');\n+                        break;\n+                    case TIMED_WAITING:\n+                        sb.append(\"\\t-  waiting on \" + info.getLockInfo());\n+                        sb.append('\\n');\n+                        break;\n+                    default:\n+                }\n+            }\n+\n+            for (MonitorInfo mi : info.getLockedMonitors()) {\n+                if (mi.getLockedStackDepth() == i) {\n+                    sb.append(\"\\t-  locked \" + mi);\n+                    sb.append('\\n');\n+                }\n+            }\n+        }\n+        // This also becomes non-functional\n+        //if (i < stackTrace.length) {\n+        //sb.append(\"\\t...\");\n+        //sb.append('\\n');\n+        //}", "originalCommit": "858a37a8bf88db23e5bdd93683c799b840fbf693", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTA3ODU3Mg==", "url": "https://github.com/apache/kafka/pull/8259#discussion_r585078572", "bodyText": "let's remove if we don't need it.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    //for (; i < stackTrace.length && i < MAX_FRAMES; i++) {", "author": "kkonstantine", "createdAt": "2021-03-01T21:56:39Z", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/SynchronizationTest.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.connect.runtime.isolation;\n+\n+import static org.junit.Assert.fail;\n+\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.common.config.AbstractConfig;\n+import org.apache.kafka.common.config.ConfigDef;\n+import org.apache.kafka.common.config.ConfigDef.Importance;\n+import org.apache.kafka.common.config.ConfigDef.Type;\n+import org.apache.kafka.connect.runtime.WorkerConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SynchronizationTest {\n+\n+    public static final Logger log = LoggerFactory.getLogger(SynchronizationTest.class);\n+\n+    @Rule\n+    public final TestName testName = new TestName();\n+\n+    private String threadPrefix;\n+    private Plugins plugins;\n+    private ThreadPoolExecutor exec;\n+    private Breakpoint<String> dclBreakpoint;\n+    private Breakpoint<String> pclBreakpoint;\n+\n+    @Before\n+    public void setup() {\n+        TestPlugins.assertAvailable();\n+        Map<String, String> pluginProps = Collections.singletonMap(\n+            WorkerConfig.PLUGIN_PATH_CONFIG,\n+            String.join(\",\", TestPlugins.pluginPath())\n+        );\n+        threadPrefix = SynchronizationTest.class.getSimpleName()\n+            + \".\" + testName.getMethodName() + \"-\";\n+        dclBreakpoint = new Breakpoint<>();\n+        pclBreakpoint = new Breakpoint<>();\n+        plugins = new Plugins(pluginProps) {\n+            @Override\n+            protected DelegatingClassLoader newDelegatingClassLoader(List<String> paths) {\n+                return AccessController.doPrivileged(\n+                    (PrivilegedAction<DelegatingClassLoader>) () ->\n+                        new SynchronizedDelegatingClassLoader(paths)\n+                );\n+            }\n+        };\n+        exec = new ThreadPoolExecutor(\n+            2,\n+            2,\n+            1000L,\n+            TimeUnit.MILLISECONDS,\n+            new LinkedBlockingDeque<>(),\n+            threadFactoryWithNamedThreads(threadPrefix)\n+        );\n+\n+    }\n+\n+    @After\n+    public void tearDown() throws InterruptedException {\n+        dclBreakpoint.clear();\n+        pclBreakpoint.clear();\n+        exec.shutdown();\n+        exec.awaitTermination(1L, TimeUnit.SECONDS);\n+    }\n+\n+    private static class Breakpoint<T> {\n+\n+        private Predicate<T> predicate;\n+        private CyclicBarrier barrier;\n+\n+        public synchronized void clear() {\n+            if (barrier != null) {\n+                barrier.reset();\n+            }\n+            predicate = null;\n+            barrier = null;\n+        }\n+\n+        public synchronized void set(Predicate<T> predicate) {\n+            clear();\n+            this.predicate = predicate;\n+            // As soon as the barrier is tripped, the barrier will be reset for the next round.\n+            barrier = new CyclicBarrier(2);\n+        }\n+\n+        /**\n+         * From a thread under test, await for the test orchestrator to continue execution\n+         * @param obj Object to test with the breakpoint's current predicate\n+         */\n+        public void await(T obj) {\n+            Predicate<T> predicate;\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                predicate  = this.predicate;\n+                barrier = this.barrier;\n+            }\n+            if (predicate != null && !predicate.test(obj)) {\n+                return;\n+            }\n+            if (barrier != null) {\n+                try {\n+                    barrier.await();\n+                } catch (InterruptedException | BrokenBarrierException e) {\n+                    throw new RuntimeException(\"Interrupted while waiting for load gate\", e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * From the test orchestrating thread, await for the test thread to continue execution\n+         * @throws InterruptedException If the current thread is interrupted while waiting\n+         * @throws BrokenBarrierException If the test thread is interrupted while waiting\n+         * @throws TimeoutException If the barrier is not reached before 1s passes.\n+         */\n+        public void testAwait()\n+            throws InterruptedException, BrokenBarrierException, TimeoutException {\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                barrier = this.barrier;\n+            }\n+            Objects.requireNonNull(barrier, \"Barrier must be set up before awaiting\");\n+            barrier.await(1L, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private class SynchronizedDelegatingClassLoader extends DelegatingClassLoader {\n+\n+        public SynchronizedDelegatingClassLoader(List<String> pluginPaths) {\n+            super(pluginPaths);\n+        }\n+\n+        @Override\n+        protected PluginClassLoader newPluginClassLoader(\n+            URL pluginLocation,\n+            URL[] urls,\n+            ClassLoader parent\n+        ) {\n+            return AccessController.doPrivileged(\n+                (PrivilegedAction<PluginClassLoader>) () ->\n+                    new SynchronizedPluginClassLoader(pluginLocation, urls, parent)\n+            );\n+        }\n+\n+        @Override\n+        public PluginClassLoader pluginClassLoader(String name) {\n+            dclBreakpoint.await(name);\n+            dclBreakpoint.await(name);\n+            return super.pluginClassLoader(name);\n+        }\n+    }\n+\n+    private class SynchronizedPluginClassLoader extends PluginClassLoader {\n+        {\n+            ClassLoader.registerAsParallelCapable();\n+        }\n+\n+\n+        public SynchronizedPluginClassLoader(URL pluginLocation, URL[] urls, ClassLoader parent) {\n+            super(pluginLocation, urls, parent);\n+        }\n+\n+        @Override\n+        protected Object getClassLoadingLock(String className) {\n+            pclBreakpoint.await(className);\n+            return super.getClassLoadingLock(className);\n+        }\n+    }\n+\n+    @Test(timeout = 15000L)\n+    // If the test times out, then there's a deadlock in the test but not necessarily the code\n+    public void workerContextClassLoaderMismatch() throws Exception {\n+        // Grab a reference to the target PluginClassLoader before activating breakpoints\n+        ClassLoader connectorLoader = plugins.delegatingLoader()\n+            .connectorLoader(TestPlugins.SAMPLING_CONVERTER);\n+\n+        // Simulate Worker::startConnector that creates configs with the delegating classloader\n+        Runnable delegatingToPlugin = () -> {\n+            // Use the DelegatingClassLoader as the current context loader\n+            ClassLoader savedLoader = Plugins.compareAndSwapLoaders(plugins.delegatingLoader());\n+\n+            // Load an isolated plugin from the delegating classloader, which will\n+            // 1. Lock the DelegatingClassLoader (via Class.forName)\n+            // 2. Wait for test to continue\n+            // 3. Attempt to lock the PluginClassLoader (via PluginClassLoader::loadClass)\n+            // 4. Deadlock\n+            new AbstractConfig(\n+                new ConfigDef().define(\"a.class\", Type.CLASS, Importance.HIGH, \"\"),\n+                Collections.singletonMap(\"a.class\", TestPlugins.SAMPLING_CONVERTER));\n+            Plugins.compareAndSwapLoaders(savedLoader);\n+        };\n+        // DelegatingClassLoader breakpoint will only trigger on this thread\n+        dclBreakpoint.set(TestPlugins.SAMPLING_CONVERTER::equals);\n+\n+        // Simulate Worker::startTask that creates configs with the plugin classloader\n+        Runnable pluginToDelegating = () -> {\n+            // Use the PluginClassLoader as the current context loader\n+            ClassLoader savedLoader = Plugins.compareAndSwapLoaders(connectorLoader);\n+            // Load a non-isolated class from the plugin classloader, which will\n+            // 1. Lock the PluginClassLoader (via PluginClassLoader::loadClass)\n+            // 2. Wait for the test to continue\n+            // 3. Attempt to lock the DelegatingClassLoader (via ClassLoader::loadClass)\n+            // 4. Deadlock\n+            new AbstractConfig(new ConfigDef().define(\"a.class\", Type.CLASS, Importance.HIGH, \"\"),\n+                Collections.singletonMap(\"a.class\", \"org.apache.kafka.connect.storage.JsonConverter\"));\n+            Plugins.compareAndSwapLoaders(savedLoader);\n+        };\n+        // PluginClassLoader breakpoint will only trigger on this thread\n+        pclBreakpoint.set(\"org.apache.kafka.connect.storage.JsonConverter\"::equals);\n+\n+        // Step 1: Lock the delegating classloader and pause\n+        exec.submit(delegatingToPlugin);\n+        // d2p enters ConfigDef::parseType\n+        // d2p enters DelegatingClassLoader::loadClass\n+        dclBreakpoint.testAwait();\n+        dclBreakpoint.testAwait();\n+        // d2p exits DelegatingClassLoader::loadClass\n+        // d2p enters Class::forName\n+        // d2p LOCKS DelegatingClassLoader\n+        // d2p enters DelegatingClassLoader::loadClass\n+        dclBreakpoint.testAwait();\n+        // d2p waits in the delegating classloader while we set up the other thread\n+        dumpThreads(\"d2p waiting with DelegatingClassLoader locked\");\n+\n+        // Step 2: Lock the plugin classloader and then the delegating classloader\n+        exec.submit(pluginToDelegating);\n+        // p2d enters PluginClassLoader::loadClass\n+        // p2d LOCKS PluginClassLoader\n+        pclBreakpoint.testAwait();\n+        // p2d locks the class-specific classLoadingLock\n+        // p2d falls through to ClassLoader::loadClass\n+        pclBreakpoint.testAwait();\n+        // p2d locks the class-specific classLoadingLock\n+        // p2d delegates upwards to DelegatingClassLoader::loadClass\n+        // p2d enters ClassLoader::loadClass\n+        // p2d LOCKS DelegatingClassLoader (starting the deadlock)\n+        dumpThreads(\"p2d blocked trying to acquire the DelegatingClassLoader lock\");\n+\n+        // Step 3: Resume the first thread and try to lock the plugin classloader\n+        dclBreakpoint.testAwait();\n+        // d2p enters PluginClassLoader::loadClass\n+        // d2p LOCKS PluginClassLoader (completing the deadlock)\n+        dumpThreads(\"d2p blocked trying to acquire the PluginClassLoader lock\");\n+        assertNoDeadlocks();\n+    }\n+\n+    // This is an informative test that is supposed to fail, demonstrating that forName is\n+    // locking the connectorLoader in this JVM implementation, when initialize is true.\n+    @Test\n+    public void forNameLocksClassloader()\n+        throws InterruptedException, TimeoutException, BrokenBarrierException {\n+        // It is not important here that we're using the PluginClassLoader.\n+        // This behavior is specific to the JVM, not the classloader implementation\n+        // It is just a convenient classloader instance that we can throw away after the test\n+        ClassLoader connectorLoader = plugins.delegatingLoader()\n+            .connectorLoader(TestPlugins.SAMPLING_CONVERTER);\n+\n+        Object monitor = new Object();\n+        Breakpoint<Object> monitorBreakpoint = new Breakpoint<>();\n+        Breakpoint<Object> progress = new Breakpoint<>();\n+\n+        Runnable executeForName = () -> {\n+            synchronized (monitor) {\n+                try {\n+                    progress.await(null);\n+                    Class.forName(TestPlugins.SAMPLING_CONVERTER, true, connectorLoader);\n+                } catch (ClassNotFoundException e) {\n+                    throw new RuntimeException(\"Failed to load test plugin\", e);\n+                }\n+            }\n+        };\n+        progress.set(null);\n+\n+        Runnable holdsMonitorLock = () -> {\n+            synchronized (connectorLoader) {\n+                monitorBreakpoint.await(null);\n+                monitorBreakpoint.await(null);\n+                synchronized (monitor) {\n+                }\n+            }\n+        };\n+        monitorBreakpoint.set(null);\n+\n+        exec.submit(holdsMonitorLock);\n+        // LOCK the classloader\n+        // wait for test to progress\n+        dumpThreads(\"locked the classloader\");\n+        monitorBreakpoint.testAwait();\n+\n+        exec.submit(executeForName);\n+        progress.testAwait();\n+        // LOCK the monitor\n+        // LOCK the classloader (starting the deadlock)\n+        dumpThreads(\"half-deadlocked\");\n+        monitorBreakpoint.testAwait();\n+        // LOCK the monitor (completing the deadlock)\n+\n+        assertNoDeadlocks();\n+    }\n+\n+    private boolean threadFromCurrentTest(ThreadInfo threadInfo) {\n+        return threadInfo.getThreadName().startsWith(threadPrefix);\n+    }\n+\n+    private void assertNoDeadlocks() {\n+        long[] deadlockedThreads = ManagementFactory.getThreadMXBean().findDeadlockedThreads();\n+        if (deadlockedThreads != null && deadlockedThreads.length > 0) {\n+            final String threads = Arrays\n+                .stream(ManagementFactory.getThreadMXBean().getThreadInfo(deadlockedThreads))\n+                .filter(this::threadFromCurrentTest)\n+                .map(SynchronizationTest::threadInfoToString)\n+                .collect(Collectors.joining(\"\"));\n+            if (!threads.isEmpty()) {\n+                fail(\"Found deadlocked threads while classloading\\n\" + threads);\n+            }\n+        }\n+    }\n+\n+    private void dumpThreads(String msg) throws InterruptedException {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"{}:\\n{}\",\n+                msg,\n+                Arrays.stream(ManagementFactory.getThreadMXBean().dumpAllThreads(true, true))\n+                    .filter(this::threadFromCurrentTest)\n+                    .map(SynchronizationTest::threadInfoToString)\n+                    .collect(Collectors.joining(\"\\n\"))\n+            );\n+        }\n+    }\n+\n+    private static String threadInfoToString(ThreadInfo info) {\n+        StringBuilder sb = new StringBuilder(\"\\\"\" + info.getThreadName() + \"\\\"\" +\n+            \" Id=\" + info.getThreadId() + \" \" +\n+            info.getThreadState());\n+        if (info.getLockName() != null) {\n+            sb.append(\" on \" + info.getLockName());\n+        }\n+        if (info.getLockOwnerName() != null) {\n+            sb.append(\" owned by \\\"\" + info.getLockOwnerName() +\n+                \"\\\" Id=\" + info.getLockOwnerId());\n+        }\n+        if (info.isSuspended()) {\n+            sb.append(\" (suspended)\");\n+        }\n+        if (info.isInNative()) {\n+            sb.append(\" (in native)\");\n+        }\n+        sb.append('\\n');\n+        // this has been refactored for checkstyle\n+        printStacktrace(info, sb);\n+        LockInfo[] locks = info.getLockedSynchronizers();\n+        if (locks.length > 0) {\n+            sb.append(\"\\n\\tNumber of locked synchronizers = \" + locks.length);\n+            sb.append('\\n');\n+            for (LockInfo li : locks) {\n+                sb.append(\"\\t- \" + li);\n+                sb.append('\\n');\n+            }\n+        }\n+        sb.append('\\n');\n+        return sb.toString();\n+    }\n+\n+    private static void printStacktrace(ThreadInfo info, StringBuilder sb) {\n+        StackTraceElement[] stackTrace = info.getStackTrace();\n+        int i = 0;\n+        // This is a copy of ThreadInfo::toString but with an unlimited number of frames shown.\n+        //for (; i < stackTrace.length && i < MAX_FRAMES; i++) {", "originalCommit": "858a37a8bf88db23e5bdd93683c799b840fbf693", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d20e98f2dc81347e05b6de4cc530437220bf2e85", "url": "https://github.com/apache/kafka/commit/d20e98f2dc81347e05b6de4cc530437220bf2e85", "message": "Update comments and test code for better readability, now that bug is fixed.\n\nSigned-off-by: Greg Harris <gregh@confluent.io>", "committedDate": "2021-05-12T01:34:36Z", "type": "commit"}, {"oid": "2fdb7a14b7fe9e8bd9149bcf95d119e29fc10d19", "url": "https://github.com/apache/kafka/commit/2fdb7a14b7fe9e8bd9149bcf95d119e29fc10d19", "message": "Revert accidentally added generated files\n\nSigned-off-by: Greg Harris <gregh@confluent.io>", "committedDate": "2021-05-17T17:40:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMzcyNjI3Ng==", "url": "https://github.com/apache/kafka/pull/8259#discussion_r633726276", "bodyText": "I understand why the implementations need to be ConcurrentMap, but IIUC we're not using any of the methods specific to ConcurrentMap. Is there a reason we don't want to keep Map for the type of these fields?", "author": "rhauch", "createdAt": "2021-05-17T17:35:13Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/DelegatingClassLoader.java", "diffHunk": "@@ -48,25 +48,25 @@\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Enumeration;\n-import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n-import java.util.Map;\n import java.util.ServiceLoader;\n import java.util.Set;\n import java.util.SortedMap;\n import java.util.SortedSet;\n import java.util.TreeMap;\n import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n import java.util.stream.Collectors;\n \n public class DelegatingClassLoader extends URLClassLoader {\n     private static final Logger log = LoggerFactory.getLogger(DelegatingClassLoader.class);\n     private static final String CLASSPATH_NAME = \"classpath\";\n     private static final String UNDEFINED_VERSION = \"undefined\";\n \n-    private final Map<String, SortedMap<PluginDesc<?>, ClassLoader>> pluginLoaders;\n-    private final Map<String, String> aliases;\n+    private final ConcurrentMap<String, SortedMap<PluginDesc<?>, ClassLoader>> pluginLoaders;\n+    private final ConcurrentMap<String, String> aliases;", "originalCommit": "d20e98f2dc81347e05b6de4cc530437220bf2e85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMzc4MDQ2Nw==", "url": "https://github.com/apache/kafka/pull/8259#discussion_r633780467", "bodyText": "This was added by @kkonstantine but it does seem to be non-functional. I'll revert the type change.", "author": "gharris1727", "createdAt": "2021-05-17T18:47:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMzcyNjI3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTA0MjE1MA==", "url": "https://github.com/apache/kafka/pull/8259#discussion_r669042150", "bodyText": "The purpose of this change was to highlight that the data structure is required to be concurrent.\nOf course if a method that existed in ConcurrentMap and not in Map was used, that would be a hard requirement.\nputIfAbsent used to be such a method but that's not the case after 1.8. In any case, the use of the more accurate interface is valid even if we don't explicitly use methods that don't exist in the parent. That's because the need for this implementation to be thread safe is a requirement here.", "author": "kkonstantine", "createdAt": "2021-07-13T19:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMzcyNjI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMzc3ODUyNA==", "url": "https://github.com/apache/kafka/pull/8259#discussion_r633778524", "bodyText": "IIUC, this PR changes the PluginClassLoader to be parallel-capable, but changes DelegatingClassLoader to only be thread safe and non parallel-capable. Is that right?\nCan we modify the JavaDoc in DelegatingClassLoader and PluginClassLoader to identify whether or not we intend for them to be parallel-capable, linking to the relevant portion of the language guide?", "author": "rhauch", "createdAt": "2021-05-17T18:44:48Z", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/SynchronizationTest.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.connect.runtime.isolation;\n+\n+import static org.junit.Assert.fail;\n+\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.common.config.AbstractConfig;\n+import org.apache.kafka.common.config.ConfigDef;\n+import org.apache.kafka.common.config.ConfigDef.Importance;\n+import org.apache.kafka.common.config.ConfigDef.Type;\n+import org.apache.kafka.connect.json.JsonConverter;\n+import org.apache.kafka.connect.runtime.WorkerConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SynchronizationTest {\n+\n+    public static final Logger log = LoggerFactory.getLogger(SynchronizationTest.class);\n+\n+    @Rule\n+    public final TestName testName = new TestName();\n+\n+    private String threadPrefix;\n+    private Plugins plugins;\n+    private ThreadPoolExecutor exec;\n+    private Breakpoint<String> dclBreakpoint;\n+    private Breakpoint<String> pclBreakpoint;\n+\n+    @Before\n+    public void setup() {\n+        TestPlugins.assertAvailable();\n+        Map<String, String> pluginProps = Collections.singletonMap(\n+            WorkerConfig.PLUGIN_PATH_CONFIG,\n+            String.join(\",\", TestPlugins.pluginPath())\n+        );\n+        threadPrefix = SynchronizationTest.class.getSimpleName()\n+            + \".\" + testName.getMethodName() + \"-\";\n+        dclBreakpoint = new Breakpoint<>();\n+        pclBreakpoint = new Breakpoint<>();\n+        plugins = new Plugins(pluginProps) {\n+            @Override\n+            protected DelegatingClassLoader newDelegatingClassLoader(List<String> paths) {\n+                return AccessController.doPrivileged(\n+                    (PrivilegedAction<DelegatingClassLoader>) () ->\n+                        new SynchronizedDelegatingClassLoader(paths)\n+                );\n+            }\n+        };\n+        exec = new ThreadPoolExecutor(\n+            2,\n+            2,\n+            1000L,\n+            TimeUnit.MILLISECONDS,\n+            new LinkedBlockingDeque<>(),\n+            threadFactoryWithNamedThreads(threadPrefix)\n+        );\n+\n+    }\n+\n+    @After\n+    public void tearDown() throws InterruptedException {\n+        dclBreakpoint.clear();\n+        pclBreakpoint.clear();\n+        exec.shutdown();\n+        exec.awaitTermination(1L, TimeUnit.SECONDS);\n+    }\n+\n+    private static class Breakpoint<T> {\n+\n+        private Predicate<T> predicate;\n+        private CyclicBarrier barrier;\n+\n+        public synchronized void clear() {\n+            if (barrier != null) {\n+                barrier.reset();\n+            }\n+            predicate = null;\n+            barrier = null;\n+        }\n+\n+        public synchronized void set(Predicate<T> predicate) {\n+            clear();\n+            this.predicate = predicate;\n+            // As soon as the barrier is tripped, the barrier will be reset for the next round.\n+            barrier = new CyclicBarrier(2);\n+        }\n+\n+        /**\n+         * From a thread under test, await for the test orchestrator to continue execution\n+         * @param obj Object to test with the breakpoint's current predicate\n+         */\n+        public void await(T obj) {\n+            Predicate<T> predicate;\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                predicate  = this.predicate;\n+                barrier = this.barrier;\n+            }\n+            if (predicate != null && !predicate.test(obj)) {\n+                return;\n+            }\n+            if (barrier != null) {\n+                try {\n+                    barrier.await();\n+                } catch (InterruptedException | BrokenBarrierException e) {\n+                    throw new RuntimeException(\"Interrupted while waiting for load gate\", e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * From the test orchestrating thread, await for the test thread to continue execution\n+         * @throws InterruptedException If the current thread is interrupted while waiting\n+         * @throws BrokenBarrierException If the test thread is interrupted while waiting\n+         * @throws TimeoutException If the barrier is not reached before 1s passes.\n+         */\n+        public void testAwait()\n+            throws InterruptedException, BrokenBarrierException, TimeoutException {\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                barrier = this.barrier;\n+            }\n+            Objects.requireNonNull(barrier, \"Barrier must be set up before awaiting\");\n+            barrier.await(1L, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private class SynchronizedDelegatingClassLoader extends DelegatingClassLoader {\n+        // NOTE: the DelegatingClassLoader is not parallel capable, and neither is this subclass.", "originalCommit": "d20e98f2dc81347e05b6de4cc530437220bf2e85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMzc5NDg3Mg==", "url": "https://github.com/apache/kafka/pull/8259#discussion_r633794872", "bodyText": "I think your summary is currently accurate.\n@kkonstantine It seems like this change made the DelegatingClassLoader thread safe, but should it also be marked as parallel capable? It is not required to fix this specific deadlock bug, but I'm wondering if we should enable the parallel class loading in the super calls. It seems to me that it should be safe to make this change.\nI can add these tweaks to the javadoc once we settle on the expectations.", "author": "gharris1727", "createdAt": "2021-05-17T19:09:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMzc3ODUyNA=="}], "type": "inlineReview"}, {"oid": "7d9030004a0ef61ef5d5a26e188cd26184ef5ab9", "url": "https://github.com/apache/kafka/commit/7d9030004a0ef61ef5d5a26e188cd26184ef5ab9", "message": "Change field types to Map, clarify javadocs on threadsafety+parallel capability\n\nSigned-off-by: Greg Harris <gregh@confluent.io>", "committedDate": "2021-06-08T22:15:29Z", "type": "commit"}, {"oid": "52614025a0ba5384da806b8b5bb8e94e0645cb86", "url": "https://github.com/apache/kafka/commit/52614025a0ba5384da806b8b5bb8e94e0645cb86", "message": "Declare DelegatingClassLoader parallel capable", "committedDate": "2021-07-14T02:09:13Z", "type": "commit"}, {"oid": "09573d66695a4c663a04dec102ebb14bc372657e", "url": "https://github.com/apache/kafka/commit/09573d66695a4c663a04dec102ebb14bc372657e", "message": "Maps are not ConcurrentMaps", "committedDate": "2021-07-14T05:40:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTQ5NjQyNw==", "url": "https://github.com/apache/kafka/pull/8259#discussion_r669496427", "bodyText": "I think it would be clearer to put this with the static fields rather than here after the member fields.\nAlso, is it worth mentioning that this CL is parallel-capable because it's superclass is, and we haven't overridden loadClass/defineClass, and so no additional sychronization is necessary?", "author": "tombentley", "createdAt": "2021-07-14T10:41:17Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/DelegatingClassLoader.java", "diffHunk": "@@ -82,11 +93,19 @@\n         Arrays.stream(SERVICE_LOADER_PLUGINS).map(serviceLoaderPlugin -> MANIFEST_PREFIX + serviceLoaderPlugin.getName())\n             .collect(Collectors.toSet());\n \n+    // Although this classloader does not load classes directly but rather delegates loading to a\n+    // PluginClassLoader or its parent through its base class, because of the use of inheritance in\n+    // in the latter case, this classloader needs to also be declared as parallel capable to use\n+    // fine-grain locking when loading classes.\n+    static {", "originalCommit": "09573d66695a4c663a04dec102ebb14bc372657e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTgwNjMxMw==", "url": "https://github.com/apache/kafka/pull/8259#discussion_r669806313", "bodyText": "Keeping the static block here, because it's a block and that's what we have in PluginClassLoader. Our style is not too strict with respect of this ordering.\nThe class overwrites the loadClass method. But it's delegating the loading to different classloaders and the locking is embedded in these classes.", "author": "kkonstantine", "createdAt": "2021-07-14T17:17:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTQ5NjQyNw=="}], "type": "inlineReview"}]}