{"pr_number": 8910, "pr_title": "KAFKA-10188: Prevent SinkTask::preCommit from being called after SinkTask::stop", "pr_createdAt": "2020-06-22T02:59:40Z", "pr_url": "https://github.com/apache/kafka/pull/8910", "timeline": [{"oid": "9e5b217f1274dd896730403a8bd8fc36383ee5ae", "url": "https://github.com/apache/kafka/commit/9e5b217f1274dd896730403a8bd8fc36383ee5ae", "message": "KAFKA-10188: Prevent SinkTask::preCommit from being called after SinkTask::stop", "committedDate": "2020-06-19T22:44:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM3OTk1Mw==", "url": "https://github.com/apache/kafka/pull/8910#discussion_r446379953", "bodyText": "I think this gets called by the consumer thread, which is different from the thread which calls close(). I think that it may be necessary to mark this variable as volatile.", "author": "gharris1727", "createdAt": "2020-06-26T19:51:30Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerSinkTask.java", "diffHunk": "@@ -689,6 +692,10 @@ else if (!context.pausedPartitions().isEmpty())\n \n         @Override\n         public void onPartitionsRevoked(Collection<TopicPartition> partitions) {\n+            if (taskStopped) {", "originalCommit": "9e5b217f1274dd896730403a8bd8fc36383ee5ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5MDMxMA==", "url": "https://github.com/apache/kafka/pull/8910#discussion_r446490310", "bodyText": "The callback gets invoked on the same thread as the one that KafkaConsumer::close is invoked on, so volatile isn't strictly necessary. If you (or others) think it'd be good to include just in case that changes or this callback gets invoked after the task is stopped on a different thread (which afaik is not possible atm), I don't have any major objections to adding it. Just didn't want to add it unnecessarily as it might be misleading to people reading the code base down the road. LMKWYT", "author": "C0urante", "createdAt": "2020-06-27T06:05:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM3OTk1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM4MDI5Mg==", "url": "https://github.com/apache/kafka/pull/8910#discussion_r447380292", "bodyText": "I wasn't aware that the onPartitionsRevoked was called by close on the same thread, good to know for the future.\nI'm fine with this as-is.", "author": "gharris1727", "createdAt": "2020-06-30T03:04:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM3OTk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5Njk4NA==", "url": "https://github.com/apache/kafka/pull/8910#discussion_r446496984", "bodyText": "Could it be replaced by isStopping()? It seems to me both flags are similar and we don't need to add more duplicate.", "author": "chia7712", "createdAt": "2020-06-27T07:32:18Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerSinkTask.java", "diffHunk": "@@ -138,6 +139,7 @@ public WorkerSinkTask(ConnectorTaskId id,\n         this.sinkTaskMetricsGroup.recordOffsetSequenceNumber(commitSeqno);\n         this.consumer = consumer;\n         this.isTopicTrackingEnabled = workerConfig.getBoolean(TOPIC_TRACKING_ENABLE_CONFIG);\n+        this.taskStopped = false;", "originalCommit": "9e5b217f1274dd896730403a8bd8fc36383ee5ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NjYxMg==", "url": "https://github.com/apache/kafka/pull/8910#discussion_r446586612", "bodyText": "I originally considered this approach, but it won't work for cases where the task stops on its own due to failure instead of being stopped externally by the worker.", "author": "C0urante", "createdAt": "2020-06-28T01:21:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5Njk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYwMDQxOQ==", "url": "https://github.com/apache/kafka/pull/8910#discussion_r446600419", "bodyText": "it won't work for cases where the task stops on its own due to failure instead of being stopped externally by the worker.\n\nthanks for the explanation. The case you mentioned is that we don't call onFailure before closing task so isStopping still return true. Could you add unit test for that case?", "author": "chia7712", "createdAt": "2020-06-28T04:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5Njk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE2Mjk1Mw==", "url": "https://github.com/apache/kafka/pull/8910#discussion_r447162953", "bodyText": "Given the complexity of the unit tests for the WorkerSinkTask class and the guarantees we get from the coverage of the existing tests, I'm not sure it's really worth the effort. The code path that's modified in this PR is agnostic about the cause of shutdown for the task and we won't really get any more coverage by simulating a shutdown triggered by an exception from the SinkTask instance instead of external request from the Worker instance.", "author": "C0urante", "createdAt": "2020-06-29T18:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5Njk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzOTc3MQ==", "url": "https://github.com/apache/kafka/pull/8910#discussion_r496239771", "bodyText": "Shouldn't this be volatile?\nYes, it's true that WorkerSinkTask.close() is always and only called from within the WorkerTask.doRun() after the tasks determines it will stop. However, the onPartitionsRevoked(...) method is called from the consumer thread, and making the field volatile is the only way to ensure that the consumer thread reads a non-cached value.", "author": "rhauch", "createdAt": "2020-09-28T21:21:21Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerSinkTask.java", "diffHunk": "@@ -138,6 +139,7 @@ public WorkerSinkTask(ConnectorTaskId id,\n         this.sinkTaskMetricsGroup.recordOffsetSequenceNumber(commitSeqno);\n         this.consumer = consumer;\n         this.isTopicTrackingEnabled = workerConfig.getBoolean(TOPIC_TRACKING_ENABLE_CONFIG);\n+        this.taskStopped = false;", "originalCommit": "9e5b217f1274dd896730403a8bd8fc36383ee5ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA0OTczNw==", "url": "https://github.com/apache/kafka/pull/8910#discussion_r497049737", "bodyText": "The Javadocs for the ConsumerRebalanceLister state that the callback \"will only execute in the user thread as part of the poll(long) call\"; I think we have a guarantee here that onPartitionsRevoked will be called on the same thread that sets taskStopped to false. A fun way to verify this is to view the exceptions that get thrown by this bug; the stack traces include these lines:\n\tat org.apache.kafka.connect.runtime.WorkerSinkTask$HandleRebalance.onPartitionsRevoked(WorkerSinkTask.java:695)\n\tat org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invokePartitionsRevoked(ConsumerCoordinator.java:312)\n\tat org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.onLeavePrepare(ConsumerCoordinator.java:744)\n\tat org.apache.kafka.clients.consumer.internals.AbstractCoordinator.close(AbstractCoordinator.java:976)\n\tat org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.close(ConsumerCoordinator.java:888)\n\tat org.apache.kafka.clients.consumer.KafkaConsumer.close(KafkaConsumer.java:2368)\n\tat org.apache.kafka.clients.consumer.KafkaConsumer.close(KafkaConsumer.java:2335)\n\tat org.apache.kafka.clients.consumer.KafkaConsumer.close(KafkaConsumer.java:2285)\n\tat org.apache.kafka.common.utils.Utils.closeQuietly(Utils.java:933)\n\tat org.apache.kafka.connect.runtime.WorkerSinkTask.close(WorkerSinkTask.java:174)\n\tat org.apache.kafka.connect.runtime.WorkerTask.doClose(WorkerTask.java:164)\n\tat org.apache.kafka.connect.runtime.WorkerTask.doRun(WorkerTask.java:191)\n\tat org.apache.kafka.connect.runtime.WorkerTask.run(WorkerTask.java:235)\n\nThe only edge case I can think of might be with asynchronous offset commits, but fwict those don't trigger asynchronous rebalance listener callbacks (if they trigger rebalances or rebalance listener callbacks at all).", "author": "C0urante", "createdAt": "2020-09-29T20:55:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzOTc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI3NTE0NA==", "url": "https://github.com/apache/kafka/pull/8910#discussion_r496275144", "bodyText": "Verified locally that this test fails when the additions to the onPartitionsRevoked(...) method above are removed locally. Nice work, @C0urante.", "author": "rhauch", "createdAt": "2020-09-28T22:41:08Z", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/WorkerSinkTaskTest.java", "diffHunk": "@@ -315,6 +315,56 @@ public void testPause() throws Exception {\n         PowerMock.verifyAll();\n     }\n \n+    @Test\n+    public void testShutdown() throws Exception {\n+        createTask(initialState);\n+\n+        expectInitializeTask();\n+        expectTaskGetTopic(true);\n+\n+        // first iteration\n+        expectPollInitialAssignment();\n+\n+        // second iteration\n+        EasyMock.expect(sinkTask.preCommit(EasyMock.anyObject())).andReturn(Collections.emptyMap());\n+        expectConsumerPoll(1);\n+        expectConversionAndTransformation(1);\n+        sinkTask.put(EasyMock.<Collection<SinkRecord>>anyObject());\n+        EasyMock.expectLastCall();\n+\n+        // WorkerSinkTask::stop\n+        consumer.wakeup();\n+        PowerMock.expectLastCall();\n+        sinkTask.stop();\n+        PowerMock.expectLastCall();\n+\n+        // WorkerSinkTask::close\n+        consumer.close();\n+        PowerMock.expectLastCall().andAnswer(new IAnswer<Object>() {\n+            @Override\n+            public Object answer() throws Throwable {\n+                rebalanceListener.getValue().onPartitionsRevoked(\n+                    asList(TOPIC_PARTITION, TOPIC_PARTITION2)\n+                );\n+                return null;\n+            }\n+        });\n+        transformationChain.close();\n+        PowerMock.expectLastCall();\n+\n+        PowerMock.replayAll();\n+\n+        workerTask.initialize(TASK_CONFIG);\n+        workerTask.initializeAndStart();\n+        workerTask.iteration();\n+        sinkTaskContext.getValue().requestCommit(); // Force an offset commit\n+        workerTask.iteration();\n+        workerTask.stop();\n+        workerTask.close();\n+\n+        PowerMock.verifyAll();", "originalCommit": "9e5b217f1274dd896730403a8bd8fc36383ee5ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}