{"pr_number": 8497, "pr_title": "KAFKA-6145: KIP-441 Build state constrained assignment from balanced one", "pr_createdAt": "2020-04-16T05:10:35Z", "pr_url": "https://github.com/apache/kafka/pull/8497", "timeline": [{"oid": "42b300e7c21d31ac08354ab3419c96181339a37a", "url": "https://github.com/apache/kafka/commit/42b300e7c21d31ac08354ab3419c96181339a37a", "message": "fix bugs in previousAssignmentIsValid", "committedDate": "2020-04-20T22:26:01Z", "type": "commit"}, {"oid": "22a670750c1998b2ada9d732dba3acb4360dcf9e", "url": "https://github.com/apache/kafka/commit/22a670750c1998b2ada9d732dba3acb4360dcf9e", "message": "random convergence test is passing", "committedDate": "2020-04-20T22:26:01Z", "type": "commit"}, {"oid": "957ee75f9fea26907609dc129697be70ecff3a73", "url": "https://github.com/apache/kafka/commit/957ee75f9fea26907609dc129697be70ecff3a73", "message": "remove unused classes", "committedDate": "2020-04-20T22:26:01Z", "type": "commit"}, {"oid": "c2ba04e79c5dd0fe92a92d3d03717c22481a2739", "url": "https://github.com/apache/kafka/commit/c2ba04e79c5dd0fe92a92d3d03717c22481a2739", "message": "clean up TaskMovementTest", "committedDate": "2020-04-20T22:26:01Z", "type": "commit"}, {"oid": "73aa71a13bbd02ab915b0a7996a1fcd0549cf443", "url": "https://github.com/apache/kafka/commit/73aa71a13bbd02ab915b0a7996a1fcd0549cf443", "message": "fix broken HATAT test", "committedDate": "2020-04-20T22:26:01Z", "type": "commit"}, {"oid": "ae3aebf2b2a4b0600d66ad6480023e68410fa564", "url": "https://github.com/apache/kafka/commit/ae3aebf2b2a4b0600d66ad6480023e68410fa564", "message": "fix remaining HATAT tests", "committedDate": "2020-04-20T22:26:01Z", "type": "commit"}, {"oid": "1e5cddb00c1535406a3ac85da19c1b16d66148a7", "url": "https://github.com/apache/kafka/commit/1e5cddb00c1535406a3ac85da19c1b16d66148a7", "message": "checkstyle", "committedDate": "2020-04-20T22:26:01Z", "type": "commit"}, {"oid": "e3271af6a83daded756be70e8026cb92ad701fa3", "url": "https://github.com/apache/kafka/commit/e3271af6a83daded756be70e8026cb92ad701fa3", "message": "fix up SPAT tests", "committedDate": "2020-04-20T22:26:01Z", "type": "commit"}, {"oid": "e0071faf053d48961272d0c8c9d4a1ee2c59d074", "url": "https://github.com/apache/kafka/commit/e0071faf053d48961272d0c8c9d4a1ee2c59d074", "message": "first set of github reviews", "committedDate": "2020-04-20T22:26:01Z", "type": "commit"}, {"oid": "8ebc11ce1bd2e3185b62454598a0a0a6c83503ef", "url": "https://github.com/apache/kafka/commit/8ebc11ce1bd2e3185b62454598a0a0a6c83503ef", "message": "remove ignore annotation from convergence tests", "committedDate": "2020-04-20T22:26:01Z", "type": "commit"}, {"oid": "2709ba0245cddcf4a6c4051050f34923f99cd36a", "url": "https://github.com/apache/kafka/commit/2709ba0245cddcf4a6c4051050f34923f99cd36a", "message": "remove unused ignore import", "committedDate": "2020-04-20T22:26:01Z", "type": "commit"}, {"oid": "864a539e33f5927d00d0914901d918da78662260", "url": "https://github.com/apache/kafka/commit/864a539e33f5927d00d0914901d918da78662260", "message": "first set of github review comments", "committedDate": "2020-04-21T03:30:46Z", "type": "commit"}, {"oid": "864a539e33f5927d00d0914901d918da78662260", "url": "https://github.com/apache/kafka/commit/864a539e33f5927d00d0914901d918da78662260", "message": "first set of github review comments", "committedDate": "2020-04-21T03:30:46Z", "type": "forcePushed"}, {"oid": "67d20fdc83eb780157be6f1aecd20932b94c916b", "url": "https://github.com/apache/kafka/commit/67d20fdc83eb780157be6f1aecd20932b94c916b", "message": "add tests, helper method for ClientState in tests", "committedDate": "2020-04-21T04:12:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA0NzMzMg==", "url": "https://github.com/apache/kafka/pull/8497#discussion_r412047332", "bodyText": "prop: I would not add the client if it is already contained in the set.", "author": "cadonna", "createdAt": "2020-04-21T09:59:32Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/ValidClientsByTaskLoadQueue.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+/**\n+ * Wraps a priority queue of clients and returns the next valid candidate(s) based on the current task assignment\n+ */\n+class ValidClientsByTaskLoadQueue {\n+\n+    private final PriorityQueue<UUID> clientsByTaskLoad;\n+    private final BiFunction<UUID, TaskId, Boolean> validClientCriteria;\n+    private final Set<UUID> uniqueClients = new HashSet<>();\n+\n+    ValidClientsByTaskLoadQueue(final Map<UUID, ClientState> clientStates,\n+                                final BiFunction<UUID, TaskId, Boolean> validClientCriteria) {\n+        this.validClientCriteria = validClientCriteria;\n+\n+        clientsByTaskLoad = new PriorityQueue<>(\n+            (client, other) -> {\n+                final double clientTaskLoad = clientStates.get(client).taskLoad();\n+                final double otherTaskLoad = clientStates.get(other).taskLoad();\n+                if (clientTaskLoad < otherTaskLoad) {\n+                    return -1;\n+                } else if (clientTaskLoad > otherTaskLoad) {\n+                    return 1;\n+                } else {\n+                    return client.compareTo(other);\n+                }\n+            });\n+    }\n+\n+    /**\n+     * @return the next least loaded client that satisfies the given criteria, or null if none do\n+     */\n+    UUID poll(final TaskId task) {\n+        final List<UUID> validClient = poll(task, 1);\n+        return validClient.isEmpty() ? null : validClient.get(0);\n+    }\n+\n+    /**\n+     * @return the next N <= {@code numClientsPerTask} clients in the underlying priority queue that are valid candidates for the given task\n+     */\n+    List<UUID> poll(final TaskId task, final int numClients) {\n+        final List<UUID> nextLeastLoadedValidClients = new LinkedList<>();\n+        final Set<UUID> invalidPolledClients = new HashSet<>();\n+        while (nextLeastLoadedValidClients.size() < numClients) {\n+            UUID candidateClient;\n+            while (true) {\n+                candidateClient = clientsByTaskLoad.poll();\n+                if (candidateClient == null) {\n+                    offerAll(invalidPolledClients);\n+                    return nextLeastLoadedValidClients;\n+                }\n+\n+                if (validClientCriteria.apply(candidateClient, task)) {\n+                    nextLeastLoadedValidClients.add(candidateClient);\n+                    break;\n+                } else {\n+                    invalidPolledClients.add(candidateClient);\n+                }\n+            }\n+        }\n+        offerAll(invalidPolledClients);\n+        return nextLeastLoadedValidClients;\n+    }\n+\n+    void offerAll(final Collection<UUID> clients) {\n+        for (final UUID client : clients) {\n+            offer(client);\n+        }\n+    }\n+\n+    void offer(final UUID client) {\n+        if (uniqueClients.contains(client)) {\n+            clientsByTaskLoad.remove(client);\n+        }\n+        clientsByTaskLoad.offer(client);\n+        uniqueClients.add(client);", "originalCommit": "67d20fdc83eb780157be6f1aecd20932b94c916b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MTEyNQ==", "url": "https://github.com/apache/kafka/pull/8497#discussion_r412081125", "bodyText": "This question from my previous review went unnoticed (or you did simply not care ;-)).\n\nQ: Why do we even care at all whether the task was running on the client? What if we just assign a real stand-by task if we have a spare one?", "author": "cadonna", "createdAt": "2020-04-21T10:53:14Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -16,128 +16,103 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentUtils.taskIsCaughtUpOnClientOrNoCaughtUpClientsExist;\n+\n import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n import java.util.SortedSet;\n+import java.util.TreeSet;\n import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n import org.apache.kafka.streams.processor.TaskId;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class TaskMovement {\n-    private static final Logger log = LoggerFactory.getLogger(TaskMovement.class);\n \n-    final TaskId task;\n-    final UUID source;\n-    final UUID destination;\n+class TaskMovement {\n+    private final TaskId task;\n+    private final UUID destination;\n+    private final SortedSet<UUID> caughtUpClients;\n \n-    TaskMovement(final TaskId task, final UUID source, final UUID destination) {\n+    private TaskMovement(final TaskId task, final UUID destination, final SortedSet<UUID> caughtUpClients) {\n         this.task = task;\n-        this.source = source;\n         this.destination = destination;\n-    }\n+        this.caughtUpClients = caughtUpClients;\n \n-    @Override\n-    public boolean equals(final Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n+        if (caughtUpClients == null || caughtUpClients.isEmpty()) {\n+            throw new IllegalStateException(\"Should not attempt to move a task if no caught up clients exist\");\n         }\n-        final TaskMovement movement = (TaskMovement) o;\n-        return Objects.equals(task, movement.task) &&\n-                   Objects.equals(source, movement.source) &&\n-                   Objects.equals(destination, movement.destination);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(task, source, destination);\n     }\n \n     /**\n-     * Computes the movement of tasks from the state constrained to the balanced assignment, up to the configured\n-     * {@code max.warmup.replicas}. A movement corresponds to a warmup replica on the destination client, with\n-     * a few exceptional cases:\n-     * <p>\n-     * 1. Tasks whose destination clients are caught-up, or whose source clients are not caught-up, will be moved\n-     * immediately from the source to the destination in the state constrained assignment\n-     * 2. Tasks whose destination client previously had this task as a standby will not be counted towards the total\n-     * {@code max.warmup.replicas}. Instead they will be counted against that task's total {@code num.standby.replicas}.\n-     *\n-     * @param statefulActiveTaskAssignment the initial, state constrained assignment, with the source clients\n-     * @param balancedStatefulActiveTaskAssignment the final, balanced assignment, with the destination clients\n-     * @return list of the task movements from statefulActiveTaskAssignment to balancedStatefulActiveTaskAssignment\n+     * @return whether any warmup replicas were assigned\n      */\n-    static List<TaskMovement> getMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n-                                           final Map<UUID, List<TaskId>> balancedStatefulActiveTaskAssignment,\n-                                           final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n-                                           final Map<UUID, ClientState> clientStates,\n-                                           final Map<TaskId, Integer> tasksToRemainingStandbys,\n-                                           final int maxWarmupReplicas) {\n-        if (statefulActiveTaskAssignment.size() != balancedStatefulActiveTaskAssignment.size()) {\n-            throw new IllegalStateException(\"Tried to compute movements but assignments differ in size.\");\n-        }\n+    static boolean assignTaskMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n+                                       final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n+                                       final Map<UUID, ClientState> clientStates,\n+                                       final Map<TaskId, Integer> tasksToRemainingStandbys,\n+                                       final int maxWarmupReplicas) {\n+        boolean warmupReplicasAssigned = false;\n+\n+        final ValidClientsByTaskLoadQueue clientsByTaskLoad = new ValidClientsByTaskLoadQueue(\n+            clientStates,\n+            (client, task) -> taskIsCaughtUpOnClientOrNoCaughtUpClientsExist(task, client, tasksToCaughtUpClients)\n+        );\n \n-        final Map<TaskId, UUID> taskToDestinationClient = new HashMap<>();\n-        for (final Map.Entry<UUID, List<TaskId>> clientEntry : balancedStatefulActiveTaskAssignment.entrySet()) {\n-            final UUID destination = clientEntry.getKey();\n-            for (final TaskId task : clientEntry.getValue()) {\n-                taskToDestinationClient.put(task, destination);\n+        final SortedSet<TaskMovement> taskMovements = new TreeSet<>(\n+            (movement, other) -> {\n+                final int numCaughtUpClients = movement.caughtUpClients.size();\n+                final int otherNumCaughtUpClients = other.caughtUpClients.size();\n+                if (numCaughtUpClients != otherNumCaughtUpClients) {\n+                    return Integer.compare(numCaughtUpClients, otherNumCaughtUpClients);\n+                } else {\n+                    return movement.task.compareTo(other.task);\n+                }\n             }\n+        );\n+\n+        for (final Map.Entry<UUID, List<TaskId>> assignmentEntry : statefulActiveTaskAssignment.entrySet()) {\n+            final UUID client = assignmentEntry.getKey();\n+            final ClientState state = clientStates.get(client);\n+            for (final TaskId task : assignmentEntry.getValue()) {\n+                if (taskIsCaughtUpOnClientOrNoCaughtUpClientsExist(task, client, tasksToCaughtUpClients)) {\n+                    state.assignActive(task);\n+                } else {\n+                    final TaskMovement taskMovement = new TaskMovement(task, client, tasksToCaughtUpClients.get(task));\n+                    taskMovements.add(taskMovement);\n+                }\n+            }\n+            clientsByTaskLoad.offer(client);\n         }\n \n-        int remainingAllowedWarmupReplicas = maxWarmupReplicas;\n-        final List<TaskMovement> movements = new LinkedList<>();\n-        for (final Map.Entry<UUID, List<TaskId>> sourceClientEntry : statefulActiveTaskAssignment.entrySet()) {\n-            final UUID source = sourceClientEntry.getKey();\n+        final AtomicInteger remainingWarmupReplicas = new AtomicInteger(maxWarmupReplicas);\n+        for (final TaskMovement movement : taskMovements) {\n+            final UUID sourceClient = clientsByTaskLoad.poll(movement.task);\n+            if (sourceClient == null) {\n+                throw new IllegalStateException(\"Tried to move task to caught-up client but none exist\");\n+            }\n \n-            final Iterator<TaskId> sourceClientTasksIterator = sourceClientEntry.getValue().iterator();\n-            while (sourceClientTasksIterator.hasNext()) {\n-                final TaskId task = sourceClientTasksIterator.next();\n-                final UUID destination = taskToDestinationClient.get(task);\n-                if (destination == null) {\n-                    log.error(\"Task {} is assigned to client {} in initial assignment but has no owner in the final \" +\n-                                  \"balanced assignment.\", task, source);\n-                    throw new IllegalStateException(\"Found task in initial assignment that was not assigned in the final.\");\n-                } else if (!source.equals(destination)) {\n-                    if (destinationClientIsCaughtUp(task, destination, tasksToCaughtUpClients)) {\n-                        sourceClientTasksIterator.remove();\n-                        statefulActiveTaskAssignment.get(destination).add(task);\n-                    } else {\n-                        if (clientStates.get(destination).prevStandbyTasks().contains(task)\n-                                && tasksToRemainingStandbys.get(task) > 0\n-                        ) {\n-                            decrementRemainingStandbys(task, tasksToRemainingStandbys);\n-                        } else {\n-                            --remainingAllowedWarmupReplicas;\n-                        }\n+            final ClientState sourceClientState = clientStates.get(sourceClient);\n+            sourceClientState.assignActive(movement.task);\n+            clientsByTaskLoad.offer(sourceClient);\n \n-                        movements.add(new TaskMovement(task, source, destination));\n-                        if (remainingAllowedWarmupReplicas == 0) {\n-                            return movements;\n-                        }\n-                    }\n-                }\n+            final ClientState destinationClientState = clientStates.get(movement.destination);\n+            if (shouldAssignWarmupReplica(movement.task, destinationClientState, remainingWarmupReplicas, tasksToRemainingStandbys)) {\n+                destinationClientState.assignStandby(movement.task);\n+                clientsByTaskLoad.offer(movement.destination);\n+                warmupReplicasAssigned = true;\n             }\n         }\n-        return movements;\n+        return warmupReplicasAssigned;\n     }\n \n-    private static boolean destinationClientIsCaughtUp(final TaskId task,\n-                                                       final UUID destination,\n-                                                       final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients) {\n-        final Set<UUID> caughtUpClients = tasksToCaughtUpClients.get(task);\n-        return caughtUpClients != null && caughtUpClients.contains(destination);\n+    private static boolean shouldAssignWarmupReplica(final TaskId task,\n+                                                     final ClientState destinationClientState,\n+                                                     final AtomicInteger remainingWarmupReplicas,\n+                                                     final Map<TaskId, Integer> tasksToRemainingStandbys) {\n+        if (destinationClientState.previousAssignedTasks().contains(task) && tasksToRemainingStandbys.get(task) > 0) {", "originalCommit": "67d20fdc83eb780157be6f1aecd20932b94c916b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyMjA4Mg==", "url": "https://github.com/apache/kafka/pull/8497#discussion_r412422082", "bodyText": "I think I answered this already. We're trying not to decrease the overall availability the standbys are providing, which could happen if we drop a caught-up standby in order to warm up an empty node. We can certainly do better than what we do now, which is not very efficient in terms of task movement, but I think it's good enough for this PR.", "author": "vvcephei", "createdAt": "2020-04-21T19:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MTEyNQ=="}], "type": "inlineReview"}, {"oid": "2ab532fa1c932b177bc82a08c75374228dabae77", "url": "https://github.com/apache/kafka/commit/2ab532fa1c932b177bc82a08c75374228dabae77", "message": "github review prop", "committedDate": "2020-04-21T19:14:24Z", "type": "commit"}, {"oid": "7500412b14201520525b5027849cdd79585c1751", "url": "https://github.com/apache/kafka/commit/7500412b14201520525b5027849cdd79585c1751", "message": "queue fix", "committedDate": "2020-04-21T19:19:13Z", "type": "commit"}, {"oid": "2a6dc0b002bf6e6f46d9a910d0358cbcf81dd1f7", "url": "https://github.com/apache/kafka/commit/2a6dc0b002bf6e6f46d9a910d0358cbcf81dd1f7", "message": "wrap in method", "committedDate": "2020-04-21T19:20:43Z", "type": "commit"}]}