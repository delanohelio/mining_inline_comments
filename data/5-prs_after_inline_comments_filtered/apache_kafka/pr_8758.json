{"pr_number": 8758, "pr_title": "KAFKA-8104: Consumer cannot rejoin to the group after rebalancing", "pr_createdAt": "2020-05-29T20:05:27Z", "pr_url": "https://github.com/apache/kafka/pull/8758", "timeline": [{"oid": "314d2b6c1a993bd9ad24fc7f92515ee182be98e2", "url": "https://github.com/apache/kafka/commit/314d2b6c1a993bd9ad24fc7f92515ee182be98e2", "message": "KAFKA-8104: Consumer cannot rejoin to the group after rebalancing (#7460)\n\nThis PR is a backport of #7460 for 2.2.", "committedDate": "2020-05-29T19:50:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcxMDIyOQ==", "url": "https://github.com/apache/kafka/pull/8758#discussion_r432710229", "bodyText": "Note this assertion is a bit different form 2.3 onwards because we do not have the groupInstanceId which prevents the sending of LeaveGroup in the call to maybeLeaveGroup above.", "author": "hachikuji", "createdAt": "2020-05-29T20:06:09Z", "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinatorTest.java", "diffHunk": "@@ -1956,6 +1957,60 @@ public void testAutoCommitAfterCoordinatorBackToService() {\n         assertEquals(100L, subscriptions.position(t1p).longValue());\n     }\n \n+    @Test\n+    public void testConsumerRejoinAfterRebalance() throws Exception {\n+        try (ConsumerCoordinator coordinator = prepareCoordinatorForCloseTest(true, false, false)) {\n+            coordinator.ensureActiveGroup();\n+\n+            prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.REBALANCE_IN_PROGRESS);\n+\n+            try {\n+                coordinator.commitOffsetsSync(singletonMap(t1p, new OffsetAndMetadata(100L)),\n+                    time.timer(Long.MAX_VALUE));\n+                fail(\"Expected commit failure\");\n+            } catch (CommitFailedException e) {\n+                // Expected\n+            }\n+\n+            assertFalse(client.hasPendingResponses());\n+            assertFalse(client.hasInFlightRequests());\n+\n+            int generationId = 42;\n+            String memberId = \"consumer-42\";\n+\n+            client.prepareResponse(joinGroupFollowerResponse(generationId, memberId, \"leader\", Errors.NONE));\n+\n+            MockTime time = new MockTime(1);\n+\n+            //onJoinPrepare will be executed and onJoinComplete will not.\n+            boolean res = coordinator.joinGroupIfNeeded(time.timer(2));\n+\n+            assertFalse(res);\n+            assertFalse(client.hasPendingResponses());\n+            //SynGroupRequest not responded.\n+            assertEquals(1, client.inFlightRequestCount());\n+            assertEquals(generationId, coordinator.generation().generationId);\n+            assertEquals(memberId, coordinator.generation().memberId);\n+\n+            // Imitating heartbeat thread that clears generation data.\n+            coordinator.maybeLeaveGroup();\n+\n+            assertEquals(AbstractCoordinator.Generation.NO_GENERATION, coordinator.generation());\n+\n+            client.respond(syncGroupResponse(singletonList(t1p), Errors.NONE));\n+\n+            //Join future should succeed but generation already cleared so result of join is false.\n+            res = coordinator.joinGroupIfNeeded(time.timer(1));\n+\n+            assertFalse(res);\n+            assertFalse(client.hasPendingResponses());\n+\n+            // We just have the LeaveGroup\n+            assertEquals(1, client.inFlightRequestCount());", "originalCommit": "314d2b6c1a993bd9ad24fc7f92515ee182be98e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}