{"pr_number": 8541, "pr_title": "KAFKA-6145: KIP-441: Add TaskAssignor class config", "pr_createdAt": "2020-04-23T23:21:42Z", "pr_url": "https://github.com/apache/kafka/pull/8541", "timeline": [{"oid": "97228a5fbdb9b8d64aa609d59c0b64e4fe7bbe0c", "url": "https://github.com/apache/kafka/commit/97228a5fbdb9b8d64aa609d59c0b64e4fe7bbe0c", "message": "KAFKA-6145: KIP-441: Add TaskAssignor class config\n\n* add a config to set the TaskAssignor\n* set the default assignor to HighAvailabilityTaskAssignor\n* fix broken tests", "committedDate": "2020-04-24T00:22:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIxMDY1Mw==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r414210653", "bodyText": "These first tests are really the only ones to change. They're still asserting the same basic fact, but previousAssignmentIsValid is now an internal method, so we instead make assertions about the black-box semantics of the assignor, instead of a specific \"visible for testing\" method.", "author": "vvcephei", "createdAt": "2020-04-24T00:24:04Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignorTest.java", "diffHunk": "@@ -41,132 +54,107 @@\n import static org.easymock.EasyMock.replay;\n import static org.hamcrest.CoreMatchers.equalTo;\n import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertTrue;\n-\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.UUID;\n-import org.apache.kafka.streams.processor.TaskId;\n-import org.apache.kafka.streams.processor.internals.assignment.AssignorConfiguration.AssignmentConfigs;\n-import org.easymock.EasyMock;\n-import org.junit.Test;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n \n public class HighAvailabilityTaskAssignorTest {\n-    private long acceptableRecoveryLag = 100L;\n-    private int balanceFactor = 1;\n-    private int maxWarmupReplicas = 2;\n-    private int numStandbyReplicas = 0;\n-    private long probingRebalanceInterval = 60 * 1000L;\n-\n-    private Map<UUID, ClientState> clientStates = new HashMap<>();\n-    private Set<TaskId> allTasks = new HashSet<>();\n-    private Set<TaskId> statefulTasks = new HashSet<>();\n-\n-    private ClientState client1;\n-    private ClientState client2;\n-    private ClientState client3;\n-    \n-    private HighAvailabilityTaskAssignor taskAssignor;\n-\n-    private void createTaskAssignor() {\n-        final AssignmentConfigs configs = new AssignmentConfigs(\n-            acceptableRecoveryLag,\n-            balanceFactor,\n-            maxWarmupReplicas,\n-            numStandbyReplicas,\n-            probingRebalanceInterval\n-        );\n-        taskAssignor = new HighAvailabilityTaskAssignor(\n-            clientStates,\n-            allTasks,\n-            statefulTasks,\n-            configs);\n-    }\n+    private final AssignmentConfigs configWithoutStandbys = new AssignmentConfigs(\n+        /*acceptableRecoveryLag*/ 100L,\n+        /*balanceFactor*/ 1,\n+        /*maxWarmupReplicas*/ 2,\n+        /*numStandbyReplicas*/ 0,\n+        /*probingRebalanceIntervalMs*/ 60 * 1000L\n+    );\n+\n+    private final AssignmentConfigs configWithStandbys = new AssignmentConfigs(\n+        /*acceptableRecoveryLag*/ 100L,\n+        /*balanceFactor*/ 1,\n+        /*maxWarmupReplicas*/ 2,\n+        /*numStandbyReplicas*/ 1,\n+        /*probingRebalanceIntervalMs*/ 60 * 1000L\n+    );\n \n-    @Test\n-    public void shouldDecidePreviousAssignmentIsInvalidIfThereAreUnassignedActiveTasks() {\n-        client1 = EasyMock.createNiceMock(ClientState.class);\n-        expect(client1.prevActiveTasks()).andReturn(singleton(TASK_0_0));\n-        expect(client1.prevStandbyTasks()).andStubReturn(EMPTY_TASKS);\n-        replay(client1);\n-        allTasks =  mkSet(TASK_0_0, TASK_0_1);\n-        clientStates = singletonMap(UUID_1, client1);\n-        createTaskAssignor();\n \n-        assertFalse(taskAssignor.previousAssignmentIsValid());\n+    @Test\n+    public void shouldComputeNewAssignmentIfThereAreUnassignedActiveTasks() {", "originalCommit": "97228a5fbdb9b8d64aa609d59c0b64e4fe7bbe0c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIxMTExMA==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r414211110", "bodyText": "Since I added the new assignor, I added a regression test to verify its most important special function. Most of its validity is verified by the parameterized StreamsPartitionAssignorTest.", "author": "vvcephei", "createdAt": "2020-04-24T00:25:31Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/PriorTaskAssignorTest.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.junit.Test;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import static java.util.Arrays.asList;\n+import static org.apache.kafka.common.utils.Utils.mkSet;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.TASK_0_0;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.TASK_0_1;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.TASK_0_2;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.UUID_1;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.UUID_2;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+\n+public class PriorTaskAssignorTest {\n+\n+    private final Map<UUID, ClientState> clients = new TreeMap<>();\n+\n+    @Test\n+    public void shouldViolateBalanceToPreserveActiveTaskStickiness() {", "originalCommit": "97228a5fbdb9b8d64aa609d59c0b64e4fe7bbe0c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIzMDM1OQ==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r414230359", "bodyText": "Should we put this with the other Streams internal configs? And/or follow the pattern of prefix+suffixing with __ ?", "author": "ableegoldman", "createdAt": "2020-04-24T01:31:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/AssignorConfiguration.java", "diffHunk": "@@ -41,8 +42,8 @@\n import static org.apache.kafka.streams.processor.internals.assignment.StreamsAssignmentProtocolVersions.LATEST_SUPPORTED_VERSION;\n \n public final class AssignorConfiguration {\n-    public static final String HIGH_AVAILABILITY_ENABLED_CONFIG = \"internal.high.availability.enabled\";\n-    private final boolean highAvailabilityEnabled;\n+    public static final String INTERNAL_TASK_ASSIGNOR_CLASS = \"internal.task.assignor.class\";", "originalCommit": "97228a5fbdb9b8d64aa609d59c0b64e4fe7bbe0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY1NTgzNw==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r414655837", "bodyText": "Oh, yeah, good idea.", "author": "vvcephei", "createdAt": "2020-04-24T15:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIzMDM1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2MjExNg==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r414662116", "bodyText": "Ok, I moved it to org.apache.kafka.streams.StreamsConfig.InternalConfig#INTERNAL_TASK_ASSIGNOR_CLASS. I made an ad-hoc decision not to add the underscores, though, because this config is different than the other internal configs. I added comments to InternalConfig to explain the difference.", "author": "vvcephei", "createdAt": "2020-04-24T15:24:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIzMDM1OQ=="}], "type": "inlineReview"}, {"oid": "fed2506de71a1a661b7ddaa07592dd8599e868e6", "url": "https://github.com/apache/kafka/commit/fed2506de71a1a661b7ddaa07592dd8599e868e6", "message": "restore LagFetchIntegrationTest", "committedDate": "2020-04-24T02:41:05Z", "type": "commit"}, {"oid": "b7373de4dd29699868a6c7317b8e6ec71d2220ae", "url": "https://github.com/apache/kafka/commit/b7373de4dd29699868a6c7317b8e6ec71d2220ae", "message": "cr feedback", "committedDate": "2020-04-24T15:25:47Z", "type": "commit"}, {"oid": "deefb582a3a8c3f3c15d1a403b064dc77fa5dc1b", "url": "https://github.com/apache/kafka/commit/deefb582a3a8c3f3c15d1a403b064dc77fa5dc1b", "message": "cr comments and fixing system tests in progress", "committedDate": "2020-04-24T15:39:49Z", "type": "commit"}, {"oid": "77fbb4193766c72eaf2a8b2ab34c96a4482de14f", "url": "https://github.com/apache/kafka/commit/77fbb4193766c72eaf2a8b2ab34c96a4482de14f", "message": "fix system tests", "committedDate": "2020-04-24T19:41:10Z", "type": "commit"}, {"oid": "9015be8cb3ed6cbd3865758660d4023da350a702", "url": "https://github.com/apache/kafka/commit/9015be8cb3ed6cbd3865758660d4023da350a702", "message": "fix tests", "committedDate": "2020-04-24T21:25:37Z", "type": "commit"}, {"oid": "126afd1f2249cb70d7f23c57965d1fdf01a4d957", "url": "https://github.com/apache/kafka/commit/126afd1f2249cb70d7f23c57965d1fdf01a4d957", "message": "revert unnecessary change", "committedDate": "2020-04-24T22:27:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5OTIwMw==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r414899203", "bodyText": "This is not a TODO. I'm planning to leave the test like this. (Just opening the floor for objections)", "author": "vvcephei", "createdAt": "2020-04-24T22:32:14Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/LagFetchIntegrationTest.java", "diffHunk": "@@ -147,6 +149,9 @@ private void shouldFetchLagsDuringRebalancing(final String optimization) throws\n         // create stream threads\n         for (int i = 0; i < 2; i++) {\n             final Properties props = (Properties) streamsConfiguration.clone();\n+            // this test relies on the second instance getting the standby, so we specify\n+            // an assignor with this contract.\n+            props.put(StreamsConfig.InternalConfig.INTERNAL_TASK_ASSIGNOR_CLASS, PriorTaskAssignor.class.getName());", "originalCommit": "126afd1f2249cb70d7f23c57965d1fdf01a4d957", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE3ODg2NQ==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r416178865", "bodyText": "It would be nice to take advantage of the now-pluggable assignor and write a test utility assignor that allows you to specify the assignment you want and the validate the inputs that you get. Obviously beyond the scope of the current PR, just a thought I had. Using the PriorTaskAssignor seems like the next best thing so \ud83d\udc4d", "author": "ableegoldman", "createdAt": "2020-04-27T21:59:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5OTIwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIxNzM3MA==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r416217370", "bodyText": "Yep, I had a similar thought, just ran out of motivation after debugging the integration tests.", "author": "vvcephei", "createdAt": "2020-04-27T23:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5OTIwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIzMzkyMg==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r416233922", "bodyText": "Very understandable", "author": "ableegoldman", "createdAt": "2020-04-28T00:10:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5OTIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5NzA3MQ==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r415797071", "bodyText": "prop:\nCould we package this logic into a factory method to make the code more readable?\nfinal TaskAssignor taskAssignor = createTaskAssignor(boolean lagComputationSuccessful);", "author": "cadonna", "createdAt": "2020-04-27T13:08:32Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamsPartitionAssignor.java", "diffHunk": "@@ -713,23 +713,18 @@ private boolean assignTasksToClients(final Set<String> allSourceTopics,\n             allTasks, clientStates, numStandbyReplicas());\n \n         final TaskAssignor taskAssignor;\n-        if (highAvailabilityEnabled) {\n-            if (lagComputationSuccessful) {\n-                taskAssignor = new HighAvailabilityTaskAssignor(\n-                    clientStates,\n-                    allTasks,\n-                    statefulTasks,\n-                    assignmentConfigs);\n-            } else {\n-                log.info(\"Failed to fetch end offsets for changelogs, will return previous assignment to clients and \"\n-                             + \"trigger another rebalance to retry.\");\n-                setAssignmentErrorCode(AssignorError.REBALANCE_NEEDED.code());\n-                taskAssignor = new StickyTaskAssignor(clientStates, allTasks, statefulTasks, assignmentConfigs, true);\n-            }\n+        if (!lagComputationSuccessful) {\n+            log.info(\"Failed to fetch end offsets for changelogs, will return previous assignment to clients and \"\n+                         + \"trigger another rebalance to retry.\");\n+            setAssignmentErrorCode(AssignorError.REBALANCE_NEEDED.code());\n+            taskAssignor = new PriorTaskAssignor();\n         } else {\n-            taskAssignor = new StickyTaskAssignor(clientStates, allTasks, statefulTasks, assignmentConfigs, false);\n+            taskAssignor = this.taskAssignor.get();\n         }", "originalCommit": "126afd1f2249cb70d7f23c57965d1fdf01a4d957", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2ODk0NA==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r416168944", "bodyText": "sure!", "author": "vvcephei", "createdAt": "2020-04-27T21:41:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5NzA3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgxNzM0OA==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r415817348", "bodyText": "req: Please add a unit test.", "author": "cadonna", "createdAt": "2020-04-27T13:35:04Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/ClientState.java", "diffHunk": "@@ -86,6 +90,22 @@ private ClientState(final Set<TaskId> activeTasks,\n         this.capacity = capacity;\n     }\n \n+    public ClientState(final Set<TaskId> previousActiveTasks,", "originalCommit": "126afd1f2249cb70d7f23c57965d1fdf01a4d957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgxODk3OQ==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r415818979", "bodyText": "You are an exemplary boy scout!", "author": "cadonna", "createdAt": "2020-04-27T13:37:22Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignor.java", "diffHunk": "@@ -16,49 +16,50 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n-import static org.apache.kafka.streams.processor.internals.assignment.AssignmentUtils.taskIsCaughtUpOnClientOrNoCaughtUpClientsExist;\n-import static org.apache.kafka.streams.processor.internals.assignment.RankedClient.buildClientRankingsByTask;\n-import static org.apache.kafka.streams.processor.internals.assignment.RankedClient.tasksToCaughtUpClients;\n-import static org.apache.kafka.streams.processor.internals.assignment.TaskMovement.assignTaskMovements;\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.assignment.AssignorConfiguration.AssignmentConfigs;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.SortedMap;\n import java.util.SortedSet;\n import java.util.TreeSet;\n import java.util.UUID;\n import java.util.stream.Collectors;\n-import org.apache.kafka.streams.processor.TaskId;\n-import org.apache.kafka.streams.processor.internals.assignment.AssignorConfiguration.AssignmentConfigs;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import java.util.Map;\n-import java.util.Set;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentUtils.taskIsCaughtUpOnClientOrNoCaughtUpClientsExist;\n+import static org.apache.kafka.streams.processor.internals.assignment.RankedClient.buildClientRankingsByTask;\n+import static org.apache.kafka.streams.processor.internals.assignment.RankedClient.tasksToCaughtUpClients;\n+import static org.apache.kafka.streams.processor.internals.assignment.TaskMovement.assignTaskMovements;", "originalCommit": "126afd1f2249cb70d7f23c57965d1fdf01a4d957", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MTA5MQ==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r416161091", "bodyText": "haha, how'd you know? ;)", "author": "vvcephei", "createdAt": "2020-04-27T21:27:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgxODk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg3MDQ5NA==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r415870494", "bodyText": "prop:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        rebalancePending = new HighAvailabilityTaskAssignor().assign(harness.clientStates,\n          \n          \n            \n                                                                                     allTasks,\n          \n          \n            \n                                                                                     harness.statefulTaskEndOffsetSums.keySet(),\n          \n          \n            \n                                                                                     configs);\n          \n          \n            \n                        rebalancePending = new HighAvailabilityTaskAssignor().assign(\n          \n          \n            \n                            harness.clientStates,\n          \n          \n            \n                            allTasks,\n          \n          \n            \n                            harness.statefulTaskEndOffsetSums.keySet(),\n          \n          \n            \n                            configs\n          \n          \n            \n                        );", "author": "cadonna", "createdAt": "2020-04-27T14:40:01Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskAssignorConvergenceTest.java", "diffHunk": "@@ -416,11 +416,10 @@ private static void testForConvergence(final Harness harness,\n             iteration++;\n             harness.prepareForNextRebalance();\n             harness.recordBefore(iteration);\n-            rebalancePending = new HighAvailabilityTaskAssignor(\n-                harness.clientStates, allTasks,\n-                harness.statefulTaskEndOffsetSums.keySet(),\n-                configs\n-            ).assign();\n+            rebalancePending = new HighAvailabilityTaskAssignor().assign(harness.clientStates,\n+                                                                         allTasks,\n+                                                                         harness.statefulTaskEndOffsetSums.keySet(),\n+                                                                         configs);", "originalCommit": "126afd1f2249cb70d7f23c57965d1fdf01a4d957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg3MTI1Mw==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r415871253", "bodyText": "prop:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final boolean followupRebalanceNeeded = assign(TASK_0_0,\n          \n          \n            \n                                                                   TASK_0_1,\n          \n          \n            \n                                                                   TASK_0_2,\n          \n          \n            \n                                                                   new TaskId(1, 0),\n          \n          \n            \n                                                                   new TaskId(1, 1),\n          \n          \n            \n                                                                   new TaskId(1, 2),\n          \n          \n            \n                                                                   new TaskId(2, 0),\n          \n          \n            \n                                                                   new TaskId(2, 1),\n          \n          \n            \n                                                                   new TaskId(2, 2),\n          \n          \n            \n                                                                   new TaskId(3, 0),\n          \n          \n            \n                                                                   new TaskId(3, 1),\n          \n          \n            \n                                                                   new TaskId(3, 2));\n          \n          \n            \n                    final boolean followupRebalanceNeeded = assign(\n          \n          \n            \n                        TASK_0_0,\n          \n          \n            \n                        TASK_0_1,\n          \n          \n            \n                        TASK_0_2,\n          \n          \n            \n                        new TaskId(1, 0),\n          \n          \n            \n                        new TaskId(1, 1),\n          \n          \n            \n                        new TaskId(1, 2),\n          \n          \n            \n                        new TaskId(2, 0),\n          \n          \n            \n                        new TaskId(2, 1),\n          \n          \n            \n                        new TaskId(2, 2),\n          \n          \n            \n                        new TaskId(3, 0),\n          \n          \n            \n                        new TaskId(3, 1),\n          \n          \n            \n                        new TaskId(3, 2)\n          \n          \n            \n                    );", "author": "cadonna", "createdAt": "2020-04-27T14:40:54Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignorTest.java", "diffHunk": "@@ -350,20 +350,20 @@ public void shouldAssignMoreTasksToClientWithMoreCapacity() {\n         createClient(UUID_2, 2);\n         createClient(UUID_1, 1);\n \n-        final StickyTaskAssignor taskAssignor = createTaskAssignor(TASK_0_0,\n-                                                                            TASK_0_1,\n-                                                                            TASK_0_2,\n-                                                                            new TaskId(1, 0),\n-                                                                            new TaskId(1, 1),\n-                                                                            new TaskId(1, 2),\n-                                                                            new TaskId(2, 0),\n-                                                                            new TaskId(2, 1),\n-                                                                            new TaskId(2, 2),\n-                                                                            new TaskId(3, 0),\n-                                                                            new TaskId(3, 1),\n-                                                                            new TaskId(3, 2));\n-\n-        taskAssignor.assign();\n+        final boolean followupRebalanceNeeded = assign(TASK_0_0,\n+                                                       TASK_0_1,\n+                                                       TASK_0_2,\n+                                                       new TaskId(1, 0),\n+                                                       new TaskId(1, 1),\n+                                                       new TaskId(1, 2),\n+                                                       new TaskId(2, 0),\n+                                                       new TaskId(2, 1),\n+                                                       new TaskId(2, 2),\n+                                                       new TaskId(3, 0),\n+                                                       new TaskId(3, 1),\n+                                                       new TaskId(3, 2));", "originalCommit": "126afd1f2249cb70d7f23c57965d1fdf01a4d957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "98e317e93a9b961f32a8c6187dc2324748ab0749", "url": "https://github.com/apache/kafka/commit/98e317e93a9b961f32a8c6187dc2324748ab0749", "message": "Update streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/StickyTaskAssignorTest.java\n\nCo-Authored-By: Bruno Cadonna <bruno@confluent.io>", "committedDate": "2020-04-27T21:26:19Z", "type": "commit"}, {"oid": "e3bf615ecd9842630013745174bafb98a9fa8a3e", "url": "https://github.com/apache/kafka/commit/e3bf615ecd9842630013745174bafb98a9fa8a3e", "message": "Update streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskAssignorConvergenceTest.java\n\nCo-Authored-By: Bruno Cadonna <bruno@confluent.io>", "committedDate": "2020-04-27T21:26:43Z", "type": "commit"}, {"oid": "e077be2947f06b9a8dc4797c01687aaa4620ddf6", "url": "https://github.com/apache/kafka/commit/e077be2947f06b9a8dc4797c01687aaa4620ddf6", "message": "cr feedback", "committedDate": "2020-04-27T23:24:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIzNDQyNQ==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r416234425", "bodyText": "I renamed the PriorTaskAssignor and added a Javadoc to make its role clear.\nNote that \"PriorTaskAssignor\" would be an appropriate behavioral name, except that it also always returns \"true\", and that it must ignore the lags, which is what makes it a \"fallback\" assignor here.", "author": "vvcephei", "createdAt": "2020-04-28T00:12:06Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/FallbackPriorTaskAssignor.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.assignment.AssignorConfiguration.AssignmentConfigs;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+/**\n+ * A special task assignor implementation to be used as a fallback in case the\n+ * configured assignor couldn't be invoked.\n+ *\n+ * Specifically, this assignor must:\n+ * 1. ignore the task lags in the ClientState map\n+ * 2. always return true, indicating that a follow-up rebalance is needed\n+ */\n+public class FallbackPriorTaskAssignor implements TaskAssignor {\n+    private final StickyTaskAssignor delegate;", "originalCommit": "e077be2947f06b9a8dc4797c01687aaa4620ddf6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIzNzgyOQ==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r416237829", "bodyText": "We should probably rename this to probingRebalanceRequired or so on, see comment on FallbackPriorTaskAssignor", "author": "ableegoldman", "createdAt": "2020-04-28T00:21:32Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamsPartitionAssignor.java", "diffHunk": "@@ -712,31 +712,32 @@ private boolean assignTasksToClients(final Set<String> allSourceTopics,\n         log.debug(\"Assigning tasks {} to clients {} with number of replicas {}\",\n             allTasks, clientStates, numStandbyReplicas());\n \n-        final TaskAssignor taskAssignor;\n-        if (highAvailabilityEnabled) {\n-            if (lagComputationSuccessful) {\n-                taskAssignor = new HighAvailabilityTaskAssignor(\n-                    clientStates,\n-                    allTasks,\n-                    statefulTasks,\n-                    assignmentConfigs);\n-            } else {\n-                log.info(\"Failed to fetch end offsets for changelogs, will return previous assignment to clients and \"\n-                             + \"trigger another rebalance to retry.\");\n-                setAssignmentErrorCode(AssignorError.REBALANCE_NEEDED.code());\n-                taskAssignor = new StickyTaskAssignor(clientStates, allTasks, statefulTasks, assignmentConfigs, true);\n-            }\n-        } else {\n-            taskAssignor = new StickyTaskAssignor(clientStates, allTasks, statefulTasks, assignmentConfigs, false);\n-        }\n-        final boolean followupRebalanceNeeded = taskAssignor.assign();\n+        final TaskAssignor taskAssignor = createTaskAssignor(lagComputationSuccessful);\n+\n+        final boolean followupRebalanceNeeded = taskAssignor.assign(clientStates,", "originalCommit": "e077be2947f06b9a8dc4797c01687aaa4620ddf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5NzI0OA==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r416297248", "bodyText": "Yeah, seems legit.", "author": "vvcephei", "createdAt": "2020-04-28T03:21:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIzNzgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI0NTM3NA==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r416245374", "bodyText": "Returning true here will schedule a followup rebalance at the probing interval, but we also schedule a followup rebalance immediately before instantiating this assignor (line 735). Is this intentional? IIUC your proposal was to trigger a followup rebalance right away, which we do by means of the assignment error code.\nOf course, this is in memory so if the instance crashes and restarts we lose this information. I think we should actually avoid using the REBALANCE_NEEDED error code inside the assign method, and only allow. it during onAssignment. If we know that a followup rebalance is needed during assign we should just encode the nextScheduledRebalance with the current time", "author": "ableegoldman", "createdAt": "2020-04-28T00:41:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/FallbackPriorTaskAssignor.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.assignment.AssignorConfiguration.AssignmentConfigs;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+/**\n+ * A special task assignor implementation to be used as a fallback in case the\n+ * configured assignor couldn't be invoked.\n+ *\n+ * Specifically, this assignor must:\n+ * 1. ignore the task lags in the ClientState map\n+ * 2. always return true, indicating that a follow-up rebalance is needed", "originalCommit": "e077be2947f06b9a8dc4797c01687aaa4620ddf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI4MDE3MQ==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r416280171", "bodyText": "Ah, this is a good point. Actually, I overlooked line 735. I'll remove that one.\nMy proposal actually was to just wait for the probing rebalance interval in case the lag computation failed. It seems like this should be ok, since Streams will still make progress in the mean time, and it avoids the pathological case where we could just constantly rebalance if the end-offsets API is down for some reason.", "author": "vvcephei", "createdAt": "2020-04-28T02:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI0NTM3NA=="}], "type": "inlineReview"}, {"oid": "d22de81d1e873c13b208ddedbb8eec1bd44628a9", "url": "https://github.com/apache/kafka/commit/d22de81d1e873c13b208ddedbb8eec1bd44628a9", "message": "cr feedback", "committedDate": "2020-04-28T02:58:29Z", "type": "commit"}, {"oid": "d58f62dc73dc3f4832cb89b5be6a8c8ce2f32e60", "url": "https://github.com/apache/kafka/commit/d58f62dc73dc3f4832cb89b5be6a8c8ce2f32e60", "message": "rename 'followup' to 'probing'", "committedDate": "2020-04-28T03:21:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2MTcxOQ==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r416761719", "bodyText": "req: I think, you can now restrict access to previousAssignmentIsValid() to private.", "author": "cadonna", "createdAt": "2020-04-28T16:39:58Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignorTest.java", "diffHunk": "@@ -41,132 +54,107 @@\n import static org.easymock.EasyMock.replay;\n import static org.hamcrest.CoreMatchers.equalTo;\n import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertTrue;\n-\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.UUID;\n-import org.apache.kafka.streams.processor.TaskId;\n-import org.apache.kafka.streams.processor.internals.assignment.AssignorConfiguration.AssignmentConfigs;\n-import org.easymock.EasyMock;\n-import org.junit.Test;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n \n public class HighAvailabilityTaskAssignorTest {\n-    private long acceptableRecoveryLag = 100L;\n-    private int balanceFactor = 1;\n-    private int maxWarmupReplicas = 2;\n-    private int numStandbyReplicas = 0;\n-    private long probingRebalanceInterval = 60 * 1000L;\n-\n-    private Map<UUID, ClientState> clientStates = new HashMap<>();\n-    private Set<TaskId> allTasks = new HashSet<>();\n-    private Set<TaskId> statefulTasks = new HashSet<>();\n-\n-    private ClientState client1;\n-    private ClientState client2;\n-    private ClientState client3;\n-    \n-    private HighAvailabilityTaskAssignor taskAssignor;\n-\n-    private void createTaskAssignor() {\n-        final AssignmentConfigs configs = new AssignmentConfigs(\n-            acceptableRecoveryLag,\n-            balanceFactor,\n-            maxWarmupReplicas,\n-            numStandbyReplicas,\n-            probingRebalanceInterval\n-        );\n-        taskAssignor = new HighAvailabilityTaskAssignor(\n-            clientStates,\n-            allTasks,\n-            statefulTasks,\n-            configs);\n-    }\n+    private final AssignmentConfigs configWithoutStandbys = new AssignmentConfigs(\n+        /*acceptableRecoveryLag*/ 100L,\n+        /*balanceFactor*/ 1,\n+        /*maxWarmupReplicas*/ 2,\n+        /*numStandbyReplicas*/ 0,\n+        /*probingRebalanceIntervalMs*/ 60 * 1000L\n+    );\n+\n+    private final AssignmentConfigs configWithStandbys = new AssignmentConfigs(\n+        /*acceptableRecoveryLag*/ 100L,\n+        /*balanceFactor*/ 1,\n+        /*maxWarmupReplicas*/ 2,\n+        /*numStandbyReplicas*/ 1,\n+        /*probingRebalanceIntervalMs*/ 60 * 1000L\n+    );\n \n-    @Test\n-    public void shouldDecidePreviousAssignmentIsInvalidIfThereAreUnassignedActiveTasks() {\n-        client1 = EasyMock.createNiceMock(ClientState.class);\n-        expect(client1.prevActiveTasks()).andReturn(singleton(TASK_0_0));\n-        expect(client1.prevStandbyTasks()).andStubReturn(EMPTY_TASKS);\n-        replay(client1);\n-        allTasks =  mkSet(TASK_0_0, TASK_0_1);\n-        clientStates = singletonMap(UUID_1, client1);\n-        createTaskAssignor();\n \n-        assertFalse(taskAssignor.previousAssignmentIsValid());", "originalCommit": "d58f62dc73dc3f4832cb89b5be6a8c8ce2f32e60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgxMDcxMw==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r416810713", "bodyText": "Or just remove it completely \ud83d\ude09", "author": "ableegoldman", "createdAt": "2020-04-28T17:54:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2MTcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkxNjI5NQ==", "url": "https://github.com/apache/kafka/pull/8541#discussion_r416916295", "bodyText": "Since you have a follow-on PR that touches this method, I'll leave it alone and just proceed to merge. We should consider both of these options in the follow-on.\nThanks!", "author": "vvcephei", "createdAt": "2020-04-28T20:55:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2MTcxOQ=="}], "type": "inlineReview"}]}