{"pr_number": 9521, "pr_title": "KAFKA-10638: Fix QueryableStateIntegrationTest", "pr_createdAt": "2020-10-28T17:22:10Z", "pr_url": "https://github.com/apache/kafka/pull/9521", "timeline": [{"oid": "500cdaee8a53d610d6f9db2d79f8add1554893db", "url": "https://github.com/apache/kafka/commit/500cdaee8a53d610d6f9db2d79f8add1554893db", "message": "KAFKA-10638: Fix QueryableStateIntegrationTest", "committedDate": "2020-10-28T17:14:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNzg5Mg==", "url": "https://github.com/apache/kafka/pull/9521#discussion_r513627892", "bodyText": "I went ahead and fixed the whitespace also, since this PR is relatively small.", "author": "vvcephei", "createdAt": "2020-10-28T17:23:07Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StoreQueryIntegrationTest.java", "diffHunk": "@@ -102,10 +111,10 @@ public void shouldQueryOnlyActivePartitionStoresByDefault() throws Exception {\n \n         final StreamsBuilder builder = new StreamsBuilder();\n         builder.table(INPUT_TOPIC_NAME, Consumed.with(Serdes.Integer(), Serdes.Integer()),\n-                        Materialized.<Integer, Integer, KeyValueStore<Bytes, byte[]>>as(TABLE_NAME)\n-                                .withCachingDisabled())\n-                .toStream()\n-                .peek((k, v) -> semaphore.release());\n+                      Materialized.<Integer, Integer, KeyValueStore<Bytes, byte[]>>as(TABLE_NAME)\n+                          .withCachingDisabled())\n+               .toStream()\n+               .peek((k, v) -> semaphore.release());", "originalCommit": "500cdaee8a53d610d6f9db2d79f8add1554893db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyODE3Nw==", "url": "https://github.com/apache/kafka/pull/9521#discussion_r513628177", "bodyText": "This class is in the same package, so the fully-qualified name is not necessary.", "author": "vvcephei", "createdAt": "2020-10-28T17:23:33Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/QueryableStoreType.java", "diffHunk": "@@ -44,7 +44,7 @@\n      * @param storeProvider     provides access to all the underlying StateStore instances\n      * @param storeName         The name of the Store\n      * @return a read-only interface over a {@code StateStore}\n-     *        (cf. {@link org.apache.kafka.streams.state.QueryableStoreTypes.KeyValueStoreType})\n+     *        (cf. {@link QueryableStoreTypes.KeyValueStoreType})", "originalCommit": "500cdaee8a53d610d6f9db2d79f8add1554893db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyOTI0MA==", "url": "https://github.com/apache/kafka/pull/9521#discussion_r513629240", "bodyText": "This is the meat of this change. If we do get an exception, we can still verify the exception is the one we expected to get, and then we return false to indicate we should try again later to get a successful verification.", "author": "vvcephei", "createdAt": "2020-10-28T17:25:03Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StoreQueryIntegrationTest.java", "diffHunk": "@@ -117,17 +126,34 @@ public void shouldQueryOnlyActivePartitionStoresByDefault() throws Exception {\n \n         // Assert that all messages in the first batch were processed in a timely manner\n         assertThat(semaphore.tryAcquire(batch1NumMessages, 60, TimeUnit.SECONDS), is(equalTo(true)));\n-        final KeyQueryMetadata keyQueryMetadata = kafkaStreams1.queryMetadataForKey(TABLE_NAME, key, (topic, somekey, value, numPartitions) -> 0);\n-\n-        final QueryableStoreType<ReadOnlyKeyValueStore<Integer, Integer>> queryableStoreType = QueryableStoreTypes.keyValueStore();\n-        final ReadOnlyKeyValueStore<Integer, Integer> store1 = IntegrationTestUtils.getStore(TABLE_NAME, kafkaStreams1, queryableStoreType);\n-        final ReadOnlyKeyValueStore<Integer, Integer> store2 = IntegrationTestUtils.getStore(TABLE_NAME, kafkaStreams2, queryableStoreType);\n-\n-        final boolean kafkaStreams1IsActive = (keyQueryMetadata.activeHost().port() % 2) == 1;\n-\n-        // Assert that only active is able to query for a key by default\n-        assertThat(kafkaStreams1IsActive ? store1.get(key) : store2.get(key), is(notNullValue()));\n-        assertThat(kafkaStreams1IsActive ? store2.get(key) : store1.get(key), is(nullValue()));\n+        until(() -> {\n+\n+            final KeyQueryMetadata keyQueryMetadata = kafkaStreams1.queryMetadataForKey(TABLE_NAME, key, (topic, somekey, value, numPartitions) -> 0);\n+\n+            final QueryableStoreType<ReadOnlyKeyValueStore<Integer, Integer>> queryableStoreType = keyValueStore();\n+            final ReadOnlyKeyValueStore<Integer, Integer> store1 = getStore(TABLE_NAME, kafkaStreams1, queryableStoreType);\n+            final ReadOnlyKeyValueStore<Integer, Integer> store2 = getStore(TABLE_NAME, kafkaStreams2, queryableStoreType);\n+\n+            final boolean kafkaStreams1IsActive = (keyQueryMetadata.activeHost().port() % 2) == 1;\n+\n+            // Assert that only active is able to query for a key by default\n+            assertThat(kafkaStreams1IsActive ? store1.get(key) : store2.get(key), is(notNullValue()));\n+            try {\n+                if (kafkaStreams1IsActive) {\n+                    assertThat(store2.get(key), is(nullValue()));\n+                } else {\n+                    assertThat(store1.get(key), is(nullValue()));\n+                }\n+                return true;\n+            } catch (final InvalidStateStoreException exception) {\n+                assertThat(\n+                    exception.getMessage(),\n+                    containsString(\"Cannot get state store source-table because the stream thread is PARTITIONS_ASSIGNED, not RUNNING\")\n+                );\n+                LOG.info(\"Streams wasn't running. Will try again.\");\n+                return false;", "originalCommit": "500cdaee8a53d610d6f9db2d79f8add1554893db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMTA4NQ==", "url": "https://github.com/apache/kafka/pull/9521#discussion_r513631085", "bodyText": "Also, here, if we find that Streams is rebalancing, we'll try the whole verification again, including to re-discover the stores in case the stores have swapped ownership.", "author": "vvcephei", "createdAt": "2020-10-28T17:27:30Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StoreQueryIntegrationTest.java", "diffHunk": "@@ -153,51 +179,75 @@ public void shouldQuerySpecificActivePartitionStores() throws Exception {\n \n         // Assert that all messages in the first batch were processed in a timely manner\n         assertThat(semaphore.tryAcquire(batch1NumMessages, 60, TimeUnit.SECONDS), is(equalTo(true)));\n-        final KeyQueryMetadata keyQueryMetadata = kafkaStreams1.queryMetadataForKey(TABLE_NAME, key, (topic, somekey, value, numPartitions) -> 0);\n-\n-        //key belongs to this partition\n-        final int keyPartition = keyQueryMetadata.partition();\n-\n-        //key doesn't belongs to this partition\n-        final int keyDontBelongPartition = (keyPartition == 0) ? 1 : 0;\n-        final boolean kafkaStreams1IsActive = (keyQueryMetadata.activeHost().port() % 2) == 1;\n-\n-        StoreQueryParameters<ReadOnlyKeyValueStore<Integer, Integer>> storeQueryParam =\n-            StoreQueryParameters.<ReadOnlyKeyValueStore<Integer, Integer>>fromNameAndType(TABLE_NAME, QueryableStoreTypes.keyValueStore())\n-                .withPartition(keyPartition);\n-        ReadOnlyKeyValueStore<Integer, Integer> store1 = null;\n-        ReadOnlyKeyValueStore<Integer, Integer> store2 = null;\n-        if (kafkaStreams1IsActive) {\n-            store1 = IntegrationTestUtils.getStore(kafkaStreams1, storeQueryParam);\n-        } else {\n-            store2 = IntegrationTestUtils.getStore(kafkaStreams2, storeQueryParam);\n-        }\n-\n-        if (kafkaStreams1IsActive) {\n-            assertThat(store1, is(notNullValue()));\n-            assertThat(store2, is(nullValue()));\n-        } else {\n-            assertThat(store2, is(notNullValue()));\n-            assertThat(store1, is(nullValue()));\n-        }\n+        until(() -> {\n+            final KeyQueryMetadata keyQueryMetadata = kafkaStreams1.queryMetadataForKey(TABLE_NAME, key, (topic, somekey, value, numPartitions) -> 0);\n+\n+            //key belongs to this partition\n+            final int keyPartition = keyQueryMetadata.partition();\n+\n+            //key doesn't belongs to this partition\n+            final int keyDontBelongPartition = (keyPartition == 0) ? 1 : 0;\n+            final boolean kafkaStreams1IsActive = (keyQueryMetadata.activeHost().port() % 2) == 1;\n+\n+            final StoreQueryParameters<ReadOnlyKeyValueStore<Integer, Integer>> storeQueryParam =\n+                StoreQueryParameters.<ReadOnlyKeyValueStore<Integer, Integer>>fromNameAndType(TABLE_NAME, keyValueStore())\n+                    .withPartition(keyPartition);\n+            ReadOnlyKeyValueStore<Integer, Integer> store1 = null;\n+            ReadOnlyKeyValueStore<Integer, Integer> store2 = null;\n+            if (kafkaStreams1IsActive) {\n+                store1 = getStore(kafkaStreams1, storeQueryParam);\n+            } else {\n+                store2 = getStore(kafkaStreams2, storeQueryParam);\n+            }\n+\n+            if (kafkaStreams1IsActive) {\n+                assertThat(store1, is(notNullValue()));\n+                assertThat(store2, is(nullValue()));\n+            } else {\n+                assertThat(store2, is(notNullValue()));\n+                assertThat(store1, is(nullValue()));\n+            }\n+\n+            // Assert that only active for a specific requested partition serves key if stale stores and not enabled\n+            assertThat(kafkaStreams1IsActive ? store1.get(key) : store2.get(key), is(notNullValue()));\n+\n+            final StoreQueryParameters<ReadOnlyKeyValueStore<Integer, Integer>> storeQueryParam2 =\n+                StoreQueryParameters.<ReadOnlyKeyValueStore<Integer, Integer>>fromNameAndType(TABLE_NAME, keyValueStore())\n+                .withPartition(keyDontBelongPartition);\n \n-        // Assert that only active for a specific requested partition serves key if stale stores and not enabled\n-        assertThat(kafkaStreams1IsActive ? store1.get(key) : store2.get(key), is(notNullValue()));\n \n-        storeQueryParam = StoreQueryParameters.<ReadOnlyKeyValueStore<Integer, Integer>>fromNameAndType(TABLE_NAME, QueryableStoreTypes.keyValueStore())\n-            .withPartition(keyDontBelongPartition);\n-        ReadOnlyKeyValueStore<Integer, Integer> store3 = null;\n-        ReadOnlyKeyValueStore<Integer, Integer> store4 = null;\n-        if (!kafkaStreams1IsActive) {\n-            store3 = IntegrationTestUtils.getStore(kafkaStreams1, storeQueryParam);\n-        } else {\n-            store4 = IntegrationTestUtils.getStore(kafkaStreams2, storeQueryParam);\n-        }\n \n-        // Assert that key is not served when wrong specific partition is requested\n-        // If kafkaStreams1 is active for keyPartition, kafkaStreams2 would be active for keyDontBelongPartition\n-        // So, in that case, store3 would be null and the store4 would not return the value for key as wrong partition was requested\n-        assertThat(kafkaStreams1IsActive ? store4.get(key) : store3.get(key), is(nullValue()));\n+            try {\n+                // Assert that key is not served when wrong specific partition is requested\n+                // If kafkaStreams1 is active for keyPartition, kafkaStreams2 would be active for keyDontBelongPartition\n+                // So, in that case, store3 would be null and the store4 would not return the value for key as wrong partition was requested\n+                if (kafkaStreams1IsActive) {\n+                    assertThat(getStore(kafkaStreams2, storeQueryParam2).get(key), is(nullValue()));\n+                    final InvalidStateStoreException exception =\n+                        assertThrows(InvalidStateStoreException.class, () -> getStore(kafkaStreams1, storeQueryParam2).get(key));\n+                    assertThat(\n+                        exception.getMessage(),\n+                        containsString(\"The specified partition 1 for store source-table does not exist.\")\n+                    );\n+                } else {\n+                    assertThat(getStore(kafkaStreams1, storeQueryParam2).get(key), is(nullValue()));\n+                    final InvalidStateStoreException exception =\n+                        assertThrows(InvalidStateStoreException.class, () -> getStore(kafkaStreams2, storeQueryParam2).get(key));\n+                    assertThat(\n+                        exception.getMessage(),\n+                        containsString(\"The specified partition 1 for store source-table does not exist.\")\n+                    );\n+                }\n+                return true;\n+            } catch (final InvalidStateStoreException exception) {\n+                assertThat(\n+                    exception.getMessage(),\n+                    containsString(\"Cannot get state store source-table because the stream thread is PARTITIONS_ASSIGNED, not RUNNING\")\n+                );\n+                LOG.info(\"Streams wasn't running. Will try again.\");\n+                return false;", "originalCommit": "500cdaee8a53d610d6f9db2d79f8add1554893db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMjY4NQ==", "url": "https://github.com/apache/kafka/pull/9521#discussion_r513632685", "bodyText": "Note, this is different than TestUtils.waitForCondition, which does the inverse thing. That one will retry on exceptions and otherwise verify that the return is true. We need to fail on exceptions and retry as long as the return is false.\nI opted to keep this method here, since it might be confusing next to the other util method.", "author": "vvcephei", "createdAt": "2020-10-28T17:29:50Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StoreQueryIntegrationTest.java", "diffHunk": "@@ -337,34 +385,49 @@ public void shouldQuerySpecificStalePartitionStoresMultiStreamThreads() throws E\n \n         //key doesn't belongs to this partition\n         final int keyDontBelongPartition = (keyPartition == 0) ? 1 : 0;\n-        final QueryableStoreType<ReadOnlyKeyValueStore<Integer, Integer>> queryableStoreType = QueryableStoreTypes.keyValueStore();\n+        final QueryableStoreType<ReadOnlyKeyValueStore<Integer, Integer>> queryableStoreType = keyValueStore();\n \n         // Assert that both active and standby are able to query for a key\n         final StoreQueryParameters<ReadOnlyKeyValueStore<Integer, Integer>> param = StoreQueryParameters\n-                .fromNameAndType(TABLE_NAME, queryableStoreType)\n-                .enableStaleStores()\n-                .withPartition(keyPartition);\n+            .fromNameAndType(TABLE_NAME, queryableStoreType)\n+            .enableStaleStores()\n+            .withPartition(keyPartition);\n         TestUtils.waitForCondition(() -> {\n-            final ReadOnlyKeyValueStore<Integer, Integer> store1 = IntegrationTestUtils.getStore(kafkaStreams1, param);\n+            final ReadOnlyKeyValueStore<Integer, Integer> store1 = getStore(kafkaStreams1, param);\n             return store1.get(key) != null;\n         }, \"store1 cannot find results for key\");\n         TestUtils.waitForCondition(() -> {\n-            final ReadOnlyKeyValueStore<Integer, Integer> store2 = IntegrationTestUtils.getStore(kafkaStreams2, param);\n+            final ReadOnlyKeyValueStore<Integer, Integer> store2 = getStore(kafkaStreams2, param);\n             return store2.get(key) != null;\n         }, \"store2 cannot find results for key\");\n \n         final StoreQueryParameters<ReadOnlyKeyValueStore<Integer, Integer>> otherParam = StoreQueryParameters\n-                .fromNameAndType(TABLE_NAME, queryableStoreType)\n-                .enableStaleStores()\n-                .withPartition(keyDontBelongPartition);\n-        final ReadOnlyKeyValueStore<Integer, Integer> store3 = IntegrationTestUtils.getStore(kafkaStreams1, otherParam);\n-        final ReadOnlyKeyValueStore<Integer, Integer> store4 = IntegrationTestUtils.getStore(kafkaStreams2, otherParam);\n+            .fromNameAndType(TABLE_NAME, queryableStoreType)\n+            .enableStaleStores()\n+            .withPartition(keyDontBelongPartition);\n+        final ReadOnlyKeyValueStore<Integer, Integer> store3 = getStore(kafkaStreams1, otherParam);\n+        final ReadOnlyKeyValueStore<Integer, Integer> store4 = getStore(kafkaStreams2, otherParam);\n \n         // Assert that\n         assertThat(store3.get(key), is(nullValue()));\n         assertThat(store4.get(key), is(nullValue()));\n     }\n \n+    private static void until(final TestCondition condition) {", "originalCommit": "500cdaee8a53d610d6f9db2d79f8add1554893db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkzOTkwNg==", "url": "https://github.com/apache/kafka/pull/9521#discussion_r513939906", "bodyText": "Why not handling the InvalidStateStoreException in the helper method until", "author": "chia7712", "createdAt": "2020-10-29T04:00:05Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StoreQueryIntegrationTest.java", "diffHunk": "@@ -117,17 +126,34 @@ public void shouldQueryOnlyActivePartitionStoresByDefault() throws Exception {\n \n         // Assert that all messages in the first batch were processed in a timely manner\n         assertThat(semaphore.tryAcquire(batch1NumMessages, 60, TimeUnit.SECONDS), is(equalTo(true)));\n-        final KeyQueryMetadata keyQueryMetadata = kafkaStreams1.queryMetadataForKey(TABLE_NAME, key, (topic, somekey, value, numPartitions) -> 0);\n-\n-        final QueryableStoreType<ReadOnlyKeyValueStore<Integer, Integer>> queryableStoreType = QueryableStoreTypes.keyValueStore();\n-        final ReadOnlyKeyValueStore<Integer, Integer> store1 = IntegrationTestUtils.getStore(TABLE_NAME, kafkaStreams1, queryableStoreType);\n-        final ReadOnlyKeyValueStore<Integer, Integer> store2 = IntegrationTestUtils.getStore(TABLE_NAME, kafkaStreams2, queryableStoreType);\n-\n-        final boolean kafkaStreams1IsActive = (keyQueryMetadata.activeHost().port() % 2) == 1;\n-\n-        // Assert that only active is able to query for a key by default\n-        assertThat(kafkaStreams1IsActive ? store1.get(key) : store2.get(key), is(notNullValue()));\n-        assertThat(kafkaStreams1IsActive ? store2.get(key) : store1.get(key), is(nullValue()));\n+        until(() -> {\n+\n+            final KeyQueryMetadata keyQueryMetadata = kafkaStreams1.queryMetadataForKey(TABLE_NAME, key, (topic, somekey, value, numPartitions) -> 0);\n+\n+            final QueryableStoreType<ReadOnlyKeyValueStore<Integer, Integer>> queryableStoreType = keyValueStore();\n+            final ReadOnlyKeyValueStore<Integer, Integer> store1 = getStore(TABLE_NAME, kafkaStreams1, queryableStoreType);\n+            final ReadOnlyKeyValueStore<Integer, Integer> store2 = getStore(TABLE_NAME, kafkaStreams2, queryableStoreType);\n+\n+            final boolean kafkaStreams1IsActive = (keyQueryMetadata.activeHost().port() % 2) == 1;\n+\n+            // Assert that only active is able to query for a key by default\n+            assertThat(kafkaStreams1IsActive ? store1.get(key) : store2.get(key), is(notNullValue()));\n+            try {\n+                if (kafkaStreams1IsActive) {\n+                    assertThat(store2.get(key), is(nullValue()));\n+                } else {\n+                    assertThat(store1.get(key), is(nullValue()));\n+                }\n+                return true;\n+            } catch (final InvalidStateStoreException exception) {", "originalCommit": "500cdaee8a53d610d6f9db2d79f8add1554893db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDMyMzYzOQ==", "url": "https://github.com/apache/kafka/pull/9521#discussion_r514323639", "bodyText": "I wanted to keep the concerns separate, so that unexpected exceptions would cause the test to fail fast. The idea is that until is the inverse of while, namely, it just loops as long as the condition evaluates to false. If the condition throws an exception, then the loop also throws, just like the real while loop.", "author": "vvcephei", "createdAt": "2020-10-29T14:55:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkzOTkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk0MTAwNg==", "url": "https://github.com/apache/kafka/pull/9521#discussion_r513941006", "bodyText": "which method can throw InvalidStateStoreException in this case? It seems to me the potential methods are caught by assertThrows", "author": "chia7712", "createdAt": "2020-10-29T04:01:49Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StoreQueryIntegrationTest.java", "diffHunk": "@@ -153,51 +179,75 @@ public void shouldQuerySpecificActivePartitionStores() throws Exception {\n \n         // Assert that all messages in the first batch were processed in a timely manner\n         assertThat(semaphore.tryAcquire(batch1NumMessages, 60, TimeUnit.SECONDS), is(equalTo(true)));\n-        final KeyQueryMetadata keyQueryMetadata = kafkaStreams1.queryMetadataForKey(TABLE_NAME, key, (topic, somekey, value, numPartitions) -> 0);\n-\n-        //key belongs to this partition\n-        final int keyPartition = keyQueryMetadata.partition();\n-\n-        //key doesn't belongs to this partition\n-        final int keyDontBelongPartition = (keyPartition == 0) ? 1 : 0;\n-        final boolean kafkaStreams1IsActive = (keyQueryMetadata.activeHost().port() % 2) == 1;\n-\n-        StoreQueryParameters<ReadOnlyKeyValueStore<Integer, Integer>> storeQueryParam =\n-            StoreQueryParameters.<ReadOnlyKeyValueStore<Integer, Integer>>fromNameAndType(TABLE_NAME, QueryableStoreTypes.keyValueStore())\n-                .withPartition(keyPartition);\n-        ReadOnlyKeyValueStore<Integer, Integer> store1 = null;\n-        ReadOnlyKeyValueStore<Integer, Integer> store2 = null;\n-        if (kafkaStreams1IsActive) {\n-            store1 = IntegrationTestUtils.getStore(kafkaStreams1, storeQueryParam);\n-        } else {\n-            store2 = IntegrationTestUtils.getStore(kafkaStreams2, storeQueryParam);\n-        }\n-\n-        if (kafkaStreams1IsActive) {\n-            assertThat(store1, is(notNullValue()));\n-            assertThat(store2, is(nullValue()));\n-        } else {\n-            assertThat(store2, is(notNullValue()));\n-            assertThat(store1, is(nullValue()));\n-        }\n+        until(() -> {\n+            final KeyQueryMetadata keyQueryMetadata = kafkaStreams1.queryMetadataForKey(TABLE_NAME, key, (topic, somekey, value, numPartitions) -> 0);\n+\n+            //key belongs to this partition\n+            final int keyPartition = keyQueryMetadata.partition();\n+\n+            //key doesn't belongs to this partition\n+            final int keyDontBelongPartition = (keyPartition == 0) ? 1 : 0;\n+            final boolean kafkaStreams1IsActive = (keyQueryMetadata.activeHost().port() % 2) == 1;\n+\n+            final StoreQueryParameters<ReadOnlyKeyValueStore<Integer, Integer>> storeQueryParam =\n+                StoreQueryParameters.<ReadOnlyKeyValueStore<Integer, Integer>>fromNameAndType(TABLE_NAME, keyValueStore())\n+                    .withPartition(keyPartition);\n+            ReadOnlyKeyValueStore<Integer, Integer> store1 = null;\n+            ReadOnlyKeyValueStore<Integer, Integer> store2 = null;\n+            if (kafkaStreams1IsActive) {\n+                store1 = getStore(kafkaStreams1, storeQueryParam);\n+            } else {\n+                store2 = getStore(kafkaStreams2, storeQueryParam);\n+            }\n+\n+            if (kafkaStreams1IsActive) {\n+                assertThat(store1, is(notNullValue()));\n+                assertThat(store2, is(nullValue()));\n+            } else {\n+                assertThat(store2, is(notNullValue()));\n+                assertThat(store1, is(nullValue()));\n+            }\n+\n+            // Assert that only active for a specific requested partition serves key if stale stores and not enabled\n+            assertThat(kafkaStreams1IsActive ? store1.get(key) : store2.get(key), is(notNullValue()));\n+\n+            final StoreQueryParameters<ReadOnlyKeyValueStore<Integer, Integer>> storeQueryParam2 =\n+                StoreQueryParameters.<ReadOnlyKeyValueStore<Integer, Integer>>fromNameAndType(TABLE_NAME, keyValueStore())\n+                .withPartition(keyDontBelongPartition);\n \n-        // Assert that only active for a specific requested partition serves key if stale stores and not enabled\n-        assertThat(kafkaStreams1IsActive ? store1.get(key) : store2.get(key), is(notNullValue()));\n \n-        storeQueryParam = StoreQueryParameters.<ReadOnlyKeyValueStore<Integer, Integer>>fromNameAndType(TABLE_NAME, QueryableStoreTypes.keyValueStore())\n-            .withPartition(keyDontBelongPartition);\n-        ReadOnlyKeyValueStore<Integer, Integer> store3 = null;\n-        ReadOnlyKeyValueStore<Integer, Integer> store4 = null;\n-        if (!kafkaStreams1IsActive) {\n-            store3 = IntegrationTestUtils.getStore(kafkaStreams1, storeQueryParam);\n-        } else {\n-            store4 = IntegrationTestUtils.getStore(kafkaStreams2, storeQueryParam);\n-        }\n \n-        // Assert that key is not served when wrong specific partition is requested\n-        // If kafkaStreams1 is active for keyPartition, kafkaStreams2 would be active for keyDontBelongPartition\n-        // So, in that case, store3 would be null and the store4 would not return the value for key as wrong partition was requested\n-        assertThat(kafkaStreams1IsActive ? store4.get(key) : store3.get(key), is(nullValue()));\n+            try {\n+                // Assert that key is not served when wrong specific partition is requested\n+                // If kafkaStreams1 is active for keyPartition, kafkaStreams2 would be active for keyDontBelongPartition\n+                // So, in that case, store3 would be null and the store4 would not return the value for key as wrong partition was requested\n+                if (kafkaStreams1IsActive) {\n+                    assertThat(getStore(kafkaStreams2, storeQueryParam2).get(key), is(nullValue()));\n+                    final InvalidStateStoreException exception =\n+                        assertThrows(InvalidStateStoreException.class, () -> getStore(kafkaStreams1, storeQueryParam2).get(key));\n+                    assertThat(\n+                        exception.getMessage(),\n+                        containsString(\"The specified partition 1 for store source-table does not exist.\")\n+                    );\n+                } else {\n+                    assertThat(getStore(kafkaStreams1, storeQueryParam2).get(key), is(nullValue()));\n+                    final InvalidStateStoreException exception =\n+                        assertThrows(InvalidStateStoreException.class, () -> getStore(kafkaStreams2, storeQueryParam2).get(key));\n+                    assertThat(\n+                        exception.getMessage(),\n+                        containsString(\"The specified partition 1 for store source-table does not exist.\")\n+                    );\n+                }\n+                return true;\n+            } catch (final InvalidStateStoreException exception) {", "originalCommit": "500cdaee8a53d610d6f9db2d79f8add1554893db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDMyNTcxMA==", "url": "https://github.com/apache/kafka/pull/9521#discussion_r514325710", "bodyText": "It's a little subtle, but each block of the if has two verifications: that it can fetch data from one of the instances and that it gets an exception from the other instance. If something goes wrong the \"can fetch data\" verification could throw.\nE.g., assertThat(getStore(kafkaStreams1, storeQueryParam2).get(key), is(nullValue())); could throw.", "author": "vvcephei", "createdAt": "2020-10-29T14:57:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk0MTAwNg=="}], "type": "inlineReview"}]}