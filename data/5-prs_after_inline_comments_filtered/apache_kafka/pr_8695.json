{"pr_number": 8695, "pr_title": "KAFKA-9320: Enable TLSv1.3 by default (KIP-573)", "pr_createdAt": "2020-05-19T19:12:57Z", "pr_url": "https://github.com/apache/kafka/pull/8695", "timeline": [{"oid": "18a1bca385d921292369650f3299b5ccb2e2f78d", "url": "https://github.com/apache/kafka/commit/18a1bca385d921292369650f3299b5ccb2e2f78d", "message": "KAFKA-9320: Initial commit.", "committedDate": "2020-05-19T09:36:57Z", "type": "commit"}, {"oid": "1076e5187fa045ec8198842e109b3afc14b6c059", "url": "https://github.com/apache/kafka/commit/1076e5187fa045ec8198842e109b3afc14b6c059", "message": "KAFKA-9320: Initial commit.", "committedDate": "2020-05-19T19:17:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODAyMDA3Mg==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r428020072", "bodyText": "I think you want to leave this as the default and see if it works correctly.", "author": "ijuma", "createdAt": "2020-05-20T13:41:38Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +622,34 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2() throws Exception {\n+        String node = \"0\";\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(SslConfigs.DEFAULT_SSL_ENABLED_PROTOCOLS.split(\",\")));", "originalCommit": "1076e5187fa045ec8198842e109b3afc14b6c059", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExNDU2OQ==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r428114569", "bodyText": "Hello. Sorry, I don't understand your concern :)\n\nDEFAULT_SSL_ENABLED_PROTOCOLS = TLSv1.2,TLSv1.3 for java11+\nDEFAULT_SSL_ENABLED_PROTOCOLS = TLSv1.2 for others jdk.\n\nThis property modified inside this test so I forcefully set it as default value.", "author": "nizhikov", "createdAt": "2020-05-20T15:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODAyMDA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE1MzEwNA==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r428153104", "bodyText": "Ah, I see, you are forcefully setting it to the default. Makes sense. OK, so this test shows that we can negotiate successfully even though we have no cipher suites that work with TLS 1.3. Can we also test that if the client sets TLS 1.3, it will fail?", "author": "ijuma", "createdAt": "2020-05-20T16:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODAyMDA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE3MzY0MA==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r428173640", "bodyText": "Tests added.", "author": "nizhikov", "createdAt": "2020-05-20T17:08:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODAyMDA3Mg=="}], "type": "inlineReview"}, {"oid": "7dec0d658a1972fff7d3cf37ab293c6b0460cdbc", "url": "https://github.com/apache/kafka/commit/7dec0d658a1972fff7d3cf37ab293c6b0460cdbc", "message": "KAFKA-9320: Test added", "committedDate": "2020-05-20T16:56:35Z", "type": "commit"}, {"oid": "f6afbb92ff2b5255e18ce76af2c1c20f6cef6eee", "url": "https://github.com/apache/kafka/commit/f6afbb92ff2b5255e18ce76af2c1c20f6cef6eee", "message": "KAFKA-9320: Test added", "committedDate": "2020-05-20T17:08:11Z", "type": "commit"}, {"oid": "142e487e9eea558d145a9487fcd054753ea50615", "url": "https://github.com/apache/kafka/commit/142e487e9eea558d145a9487fcd054753ea50615", "message": "KAFKA-9320: Test added", "committedDate": "2020-05-20T17:10:10Z", "type": "commit"}, {"oid": "ac448d173f5ce727d3aee02ef4dbac15a38f28ff", "url": "https://github.com/apache/kafka/commit/ac448d173f5ce727d3aee02ef4dbac15a38f28ff", "message": "KAFKA-9320: Test added", "committedDate": "2020-05-20T17:21:44Z", "type": "commit"}, {"oid": "e1287c610f938bf0c379fa892cb0a13dee27a444", "url": "https://github.com/apache/kafka/commit/e1287c610f938bf0c379fa892cb0a13dee27a444", "message": "KAFKA-9320: SslVersionsTransportLayerTest added.", "committedDate": "2020-05-25T14:58:50Z", "type": "commit"}, {"oid": "b310e6052600fde7db7187dfc781e5f650d56bf0", "url": "https://github.com/apache/kafka/commit/b310e6052600fde7db7187dfc781e5f650d56bf0", "message": "KAFKA-9320: Tests fix.", "committedDate": "2020-05-26T08:54:36Z", "type": "commit"}, {"oid": "518eb77b5bf4075db449bc4cf0aff89981987eae", "url": "https://github.com/apache/kafka/commit/518eb77b5bf4075db449bc4cf0aff89981987eae", "message": "KAFKA-9320: system tests updated.", "committedDate": "2020-05-26T16:49:20Z", "type": "commit"}, {"oid": "5b5f37e458e0bfb0a017cabfa8ac8b677a6efbc5", "url": "https://github.com/apache/kafka/commit/5b5f37e458e0bfb0a017cabfa8ac8b677a6efbc5", "message": "KAFKA-9320: system tests updated.", "committedDate": "2020-05-27T07:08:20Z", "type": "commit"}, {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32", "url": "https://github.com/apache/kafka/commit/c7000d9e7372824762db02cf4a5dd6688726ba32", "message": "KAFKA-9320: system tests updated.", "committedDate": "2020-05-27T09:41:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4NzcwMg==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431587702", "bodyText": "We can use assume to do this in a more idiomatic way. Same for other places where we do something similar.", "author": "ijuma", "createdAt": "2020-05-28T05:22:28Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +619,81 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2_FailsForTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;", "originalCommit": "c7000d9e7372824762db02cf4a5dd6688726ba32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc3NzIyNQ==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431777225", "bodyText": "Fixed.", "author": "nizhikov", "createdAt": "2020-05-28T11:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4NzcwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4Nzk1OQ==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431587959", "bodyText": "This comment seems incorrect.", "author": "ijuma", "createdAt": "2020-05-28T05:23:26Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +619,81 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2_FailsForTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.", "originalCommit": "c7000d9e7372824762db02cf4a5dd6688726ba32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4ODcxNw==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431588717", "bodyText": "Can we replace\nArrays.asList(SslConfigs.DEFAULT_SSL_ENABLED_PROTOCOLS.split(\",\"))\nwith\nSslConfigs.DEFAULT_SSL_ENABLED_PROTOCOLS\nDoesn't the code handle comma separated Strings?", "author": "ijuma", "createdAt": "2020-05-28T05:26:09Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +619,81 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2_FailsForTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteFailForServerTLSv1_2_ClientTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.2\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2() throws Exception {\n+        String node = \"0\";\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(SslConfigs.DEFAULT_SSL_ENABLED_PROTOCOLS.split(\",\")));", "originalCommit": "c7000d9e7372824762db02cf4a5dd6688726ba32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4MzcyNg==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431783726", "bodyText": "No, we can't. It leads to ClassCastException.\nPlease, see DefaultSslEngineFactory line 123.\n        List<String> enabledProtocolsList = (List<String>) configs.get(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG);", "author": "nizhikov", "createdAt": "2020-05-28T12:03:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4ODcxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzMDIzNw==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431830237", "bodyText": "Thanks.", "author": "ijuma", "createdAt": "2020-05-28T13:22:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4ODcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4ODk0Mg==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431588942", "bodyText": "Do these have to be public or can they be package private?", "author": "ijuma", "createdAt": "2020-05-28T05:27:01Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -1250,7 +1322,7 @@ private NioEchoServer createEchoServer(SecurityProtocol securityProtocol) throws\n         void run() throws IOException;\n     }\n \n-    private static class TestSslChannelBuilder extends SslChannelBuilder {\n+    public static class TestSslChannelBuilder extends SslChannelBuilder {", "originalCommit": "c7000d9e7372824762db02cf4a5dd6688726ba32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc3OTQzNw==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431779437", "bodyText": "The correct scope is package private.\nFixed.", "author": "nizhikov", "createdAt": "2020-05-28T11:54:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4ODk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4OTUyMw==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431589523", "bodyText": "The important detail is that TLS 1.3 is enabled too, right?", "author": "ijuma", "createdAt": "2020-05-28T05:28:48Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +619,81 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2_FailsForTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteFailForServerTLSv1_2_ClientTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.2\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.", "originalCommit": "c7000d9e7372824762db02cf4a5dd6688726ba32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4OTY3Mw==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431589673", "bodyText": "Can we set this to DEFAULT_SSL_PROTOCOL?", "author": "ijuma", "createdAt": "2020-05-28T05:29:26Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +619,81 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2_FailsForTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteFailForServerTLSv1_2_ClientTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.2\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2() throws Exception {\n+        String node = \"0\";\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");", "originalCommit": "c7000d9e7372824762db02cf4a5dd6688726ba32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc5OTQ2OA==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431799468", "bodyText": "Yes. Fixed.", "author": "nizhikov", "createdAt": "2020-05-28T12:32:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4OTY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzMDA3OQ==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431830079", "bodyText": "Did you push this change? I don't see it.", "author": "ijuma", "createdAt": "2020-05-28T13:22:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4OTY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4OTc1Nw==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431589757", "bodyText": "Same here, can we SslConfigs.DEFAULT_SSL_PROTOCOL?", "author": "ijuma", "createdAt": "2020-05-28T05:29:50Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +619,81 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2_FailsForTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteFailForServerTLSv1_2_ClientTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.2\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2() throws Exception {\n+        String node = \"0\";\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(SslConfigs.DEFAULT_SSL_ENABLED_PROTOCOLS.split(\",\")));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");", "originalCommit": "c7000d9e7372824762db02cf4a5dd6688726ba32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MTA2OQ==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431591069", "bodyText": "If we take the suggestions to use DEFAULT_SSL_PROTOCOL, then this test is checking that we can negotiate TLSv1.2 if the custom cipher suites are only compatible with TLSv1.2 and we use the default protocol configuration (TLSv1.3).", "author": "ijuma", "createdAt": "2020-05-28T05:34:12Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +619,81 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2_FailsForTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteFailForServerTLSv1_2_ClientTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.2\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2() throws Exception {", "originalCommit": "c7000d9e7372824762db02cf4a5dd6688726ba32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MjY0Ng==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431592646", "bodyText": "We should also add a similar test where the custom cipher is a TLS 1.3 cipher.", "author": "ijuma", "createdAt": "2020-05-28T05:39:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MTA2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1Nzg4Ng==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431857886", "bodyText": "Done.", "author": "nizhikov", "createdAt": "2020-05-28T14:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MTA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MTE2OQ==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431591169", "bodyText": "Why did we remove both lines above?", "author": "ijuma", "createdAt": "2020-05-28T05:34:32Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -591,10 +591,7 @@ public void testUnsupportedCipher() throws Exception {\n             createSelector(sslClientConfigs);\n \n             checkAuthentiationFailed(\"1\", \"TLSv1.1\");\n-            server.verifyAuthenticationMetrics(0, 1);\n-\n             checkAuthentiationFailed(\"2\", \"TLSv1\");\n-            server.verifyAuthenticationMetrics(0, 2);", "originalCommit": "c7000d9e7372824762db02cf4a5dd6688726ba32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MTUzNw==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431591537", "bodyText": "Nit: the test should be testTlsDefaults to match the naming convention.", "author": "ijuma", "createdAt": "2020-05-28T05:35:44Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslVersionsTransportLayerTest.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.network;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.kafka.common.metrics.Metrics;\n+import org.apache.kafka.common.security.TestSecurityConfig;\n+import org.apache.kafka.common.security.auth.SecurityProtocol;\n+import org.apache.kafka.common.utils.Java;\n+import org.apache.kafka.common.utils.LogContext;\n+import org.apache.kafka.common.utils.Time;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests for the SSL transport layer.\n+ * Checks different versions of the protocol usage on the server and client.\n+ */\n+@RunWith(value = Parameterized.class)\n+public class SslVersionsTransportLayerTest {\n+    private static final int BUFFER_SIZE = 4 * 1024;\n+    private static final Time TIME = Time.SYSTEM;\n+\n+    private final String tlsServerProtocol;\n+    private final String tlsClientProtocol;\n+\n+    @Parameterized.Parameters(name = \"tlsServerProtocol={0},tlsClientProtocol={1}\")\n+    public static Collection<Object[]> data() {\n+        List<Object[]> values = new ArrayList<>();\n+        values.add(new Object[] {\"TLSv1.2\", \"TLSv1.2\"});\n+        if (Java.IS_JAVA11_COMPATIBLE) {\n+            values.add(new Object[] {\"TLSv1.2\", \"TLSv1.3\"});\n+            values.add(new Object[] {\"TLSv1.3\", \"TLSv1.2\"});\n+            values.add(new Object[] {\"TLSv1.3\", \"TLSv1.3\"});\n+        }\n+        return values;\n+    }\n+\n+    public SslVersionsTransportLayerTest(String tlsServerProtocol, String tlsClientProtocol) {\n+        this.tlsServerProtocol = tlsServerProtocol;\n+        this.tlsClientProtocol = tlsClientProtocol;\n+    }\n+\n+    /**\n+     * Tests that connection success with the default TLS version.\n+     */\n+    @Test\n+    public void testTLSDefaults() throws Exception {", "originalCommit": "c7000d9e7372824762db02cf4a5dd6688726ba32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY2ODg0Ng==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431668846", "bodyText": "Fixed.", "author": "nizhikov", "createdAt": "2020-05-28T08:30:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MTUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MTkwMw==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431591903", "bodyText": "We probably don't need these empty lines.", "author": "ijuma", "createdAt": "2020-05-28T05:37:05Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslVersionsTransportLayerTest.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.network;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.kafka.common.metrics.Metrics;\n+import org.apache.kafka.common.security.TestSecurityConfig;\n+import org.apache.kafka.common.security.auth.SecurityProtocol;\n+import org.apache.kafka.common.utils.Java;\n+import org.apache.kafka.common.utils.LogContext;\n+import org.apache.kafka.common.utils.Time;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests for the SSL transport layer.\n+ * Checks different versions of the protocol usage on the server and client.\n+ */\n+@RunWith(value = Parameterized.class)\n+public class SslVersionsTransportLayerTest {\n+    private static final int BUFFER_SIZE = 4 * 1024;\n+    private static final Time TIME = Time.SYSTEM;\n+\n+    private final String tlsServerProtocol;\n+    private final String tlsClientProtocol;\n+\n+    @Parameterized.Parameters(name = \"tlsServerProtocol={0},tlsClientProtocol={1}\")\n+    public static Collection<Object[]> data() {\n+        List<Object[]> values = new ArrayList<>();\n+        values.add(new Object[] {\"TLSv1.2\", \"TLSv1.2\"});\n+        if (Java.IS_JAVA11_COMPATIBLE) {\n+            values.add(new Object[] {\"TLSv1.2\", \"TLSv1.3\"});\n+            values.add(new Object[] {\"TLSv1.3\", \"TLSv1.2\"});\n+            values.add(new Object[] {\"TLSv1.3\", \"TLSv1.3\"});\n+        }\n+        return values;\n+    }\n+\n+    public SslVersionsTransportLayerTest(String tlsServerProtocol, String tlsClientProtocol) {\n+        this.tlsServerProtocol = tlsServerProtocol;\n+        this.tlsClientProtocol = tlsClientProtocol;\n+    }\n+\n+    /**\n+     * Tests that connection success with the default TLS version.\n+     */\n+    @Test\n+    public void testTLSDefaults() throws Exception {\n+        // Create certificates for use by client and server. Add server cert to client truststore and vice versa.\n+        CertStores serverCertStores = new CertStores(true, \"server\",  \"localhost\");\n+        CertStores clientCertStores = new CertStores(false, \"client\", \"localhost\");\n+\n+        Map<String, Object> sslClientConfigs = getTrustingConfig(clientCertStores, serverCertStores, tlsClientProtocol);\n+        Map<String, Object> sslServerConfigs = getTrustingConfig(serverCertStores, clientCertStores, tlsServerProtocol);\n+\n+        NioEchoServer server = NetworkTestUtils.createEchoServer(ListenerName.forSecurityProtocol(SecurityProtocol.SSL),\n+             SecurityProtocol.SSL,\n+             new TestSecurityConfig(sslServerConfigs),\n+             null,\n+            TIME);\n+        Selector selector = createSelector(sslClientConfigs);\n+\n+        String node = \"0\";\n+        selector.connect(node, new InetSocketAddress(\"localhost\", server.port()), BUFFER_SIZE, BUFFER_SIZE);\n+\n+        if (tlsServerProtocol.equals(tlsClientProtocol)) {\n+            NetworkTestUtils.waitForChannelReady(selector, node);\n+\n+            int msgSz = 1024 * 1024;\n+            String message = TestUtils.randomString(msgSz);\n+            selector.send(new NetworkSend(node, ByteBuffer.wrap(message.getBytes())));\n+            while (selector.completedReceives().isEmpty()) {\n+                selector.poll(100L);\n+            }\n+            int totalBytes = msgSz + 4; // including 4-byte size\n+            server.waitForMetric(\"incoming-byte\", totalBytes);\n+            server.waitForMetric(\"outgoing-byte\", totalBytes);\n+            server.waitForMetric(\"request\", 1);\n+            server.waitForMetric(\"response\", 1);\n+        } else {\n+            NetworkTestUtils.waitForChannelClose(selector, node, ChannelState.State.AUTHENTICATION_FAILED);\n+        }\n+    }\n+\n+    public static Map<String, Object> sslConfig(String tlsServerProtocol) {\n+        Map<String, Object> sslConfig = new HashMap<>();\n+\n+        sslConfig.put(SslConfigs.SSL_PROTOCOL_CONFIG, tlsServerProtocol);\n+        sslConfig.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Collections.singletonList(tlsServerProtocol));\n+", "originalCommit": "c7000d9e7372824762db02cf4a5dd6688726ba32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MjM1Nw==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431592357", "bodyText": "Could we have each parameter be a list so that we can set enabled protocols with more than one element?", "author": "ijuma", "createdAt": "2020-05-28T05:38:32Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslVersionsTransportLayerTest.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.network;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.kafka.common.metrics.Metrics;\n+import org.apache.kafka.common.security.TestSecurityConfig;\n+import org.apache.kafka.common.security.auth.SecurityProtocol;\n+import org.apache.kafka.common.utils.Java;\n+import org.apache.kafka.common.utils.LogContext;\n+import org.apache.kafka.common.utils.Time;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests for the SSL transport layer.\n+ * Checks different versions of the protocol usage on the server and client.\n+ */\n+@RunWith(value = Parameterized.class)\n+public class SslVersionsTransportLayerTest {\n+    private static final int BUFFER_SIZE = 4 * 1024;\n+    private static final Time TIME = Time.SYSTEM;\n+\n+    private final String tlsServerProtocol;\n+    private final String tlsClientProtocol;\n+\n+    @Parameterized.Parameters(name = \"tlsServerProtocol={0},tlsClientProtocol={1}\")\n+    public static Collection<Object[]> data() {\n+        List<Object[]> values = new ArrayList<>();\n+        values.add(new Object[] {\"TLSv1.2\", \"TLSv1.2\"});\n+        if (Java.IS_JAVA11_COMPATIBLE) {\n+            values.add(new Object[] {\"TLSv1.2\", \"TLSv1.3\"});\n+            values.add(new Object[] {\"TLSv1.3\", \"TLSv1.2\"});\n+            values.add(new Object[] {\"TLSv1.3\", \"TLSv1.3\"});\n+        }\n+        return values;\n+    }\n+\n+    public SslVersionsTransportLayerTest(String tlsServerProtocol, String tlsClientProtocol) {", "originalCommit": "c7000d9e7372824762db02cf4a5dd6688726ba32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc3NjE1Nw==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431776157", "bodyText": "Fixed.", "author": "nizhikov", "createdAt": "2020-05-28T11:48:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MjM1Nw=="}], "type": "inlineReview"}, {"oid": "862f7ae4eceeb43135409da0762c3519260739a4", "url": "https://github.com/apache/kafka/commit/862f7ae4eceeb43135409da0762c3519260739a4", "message": "KAFKA-9320: code review fixes", "committedDate": "2020-05-28T08:48:24Z", "type": "commit"}, {"oid": "d1dd114ffbdf17f24253681c9b90186181bc560a", "url": "https://github.com/apache/kafka/commit/d1dd114ffbdf17f24253681c9b90186181bc560a", "message": "Merge branch 'trunk' into KAFKA-9320", "committedDate": "2020-05-28T08:49:03Z", "type": "commit"}, {"oid": "5578192735c999fc070b1c9559c7a3d3f3cbe2df", "url": "https://github.com/apache/kafka/commit/5578192735c999fc070b1c9559c7a3d3f3cbe2df", "message": "KAFKA-9320: code review fixes", "committedDate": "2020-05-28T09:09:28Z", "type": "commit"}, {"oid": "c1847e7e30e61633e6616e5c2e8bb93d8cfb4eb6", "url": "https://github.com/apache/kafka/commit/c1847e7e30e61633e6616e5c2e8bb93d8cfb4eb6", "message": "KAFKA-9320: code review fixes", "committedDate": "2020-05-28T09:13:39Z", "type": "commit"}, {"oid": "c9012549a724719e641e2ab8c3883c7aaf4c4fa1", "url": "https://github.com/apache/kafka/commit/c9012549a724719e641e2ab8c3883c7aaf4c4fa1", "message": "KAFKA-9320: code review fixes", "committedDate": "2020-05-28T09:14:27Z", "type": "commit"}, {"oid": "61cd6c5e667a9ca1f1b7b94dd0590c4b8c1d0899", "url": "https://github.com/apache/kafka/commit/61cd6c5e667a9ca1f1b7b94dd0590c4b8c1d0899", "message": "KAFKA-9320: code review fixes", "committedDate": "2020-05-28T11:48:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyNjkxNQ==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431826915", "bodyText": "Shouldn't this check if the intersection of server and client protocols is non empty?", "author": "ijuma", "createdAt": "2020-05-28T13:17:37Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslVersionsTransportLayerTest.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.network;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.kafka.common.metrics.Metrics;\n+import org.apache.kafka.common.security.TestSecurityConfig;\n+import org.apache.kafka.common.security.auth.SecurityProtocol;\n+import org.apache.kafka.common.utils.Java;\n+import org.apache.kafka.common.utils.LogContext;\n+import org.apache.kafka.common.utils.Time;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests for the SSL transport layer.\n+ * Checks different versions of the protocol usage on the server and client.\n+ */\n+@RunWith(value = Parameterized.class)\n+public class SslVersionsTransportLayerTest {\n+    private static final int BUFFER_SIZE = 4 * 1024;\n+    private static final Time TIME = Time.SYSTEM;\n+\n+    private final List<String> tlsServerProtocols;\n+    private final List<String> tlsClientProtocols;\n+\n+    @Parameterized.Parameters(name = \"tlsServerProtocol={0},tlsClientProtocol={1}\")\n+    public static Collection<Object[]> data() {\n+        List<Object[]> values = new ArrayList<>();\n+        values.add(new Object[] {Arrays.asList(\"TLSv1.2\"), Arrays.asList(\"TLSv1.2\")});\n+        if (Java.IS_JAVA11_COMPATIBLE) {\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\"), Arrays.asList(\"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Arrays.asList(\"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Arrays.asList(\"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+        }\n+        return values;\n+    }\n+\n+    public SslVersionsTransportLayerTest(List<String> tlsServerProtocols, List<String> tlsClientProtocols) {\n+        this.tlsServerProtocols = tlsServerProtocols;\n+        this.tlsClientProtocols = tlsClientProtocols;\n+    }\n+\n+    /**\n+     * Tests that connection success with the default TLS version.\n+     */\n+    @Test\n+    public void testTlsDefaults() throws Exception {\n+        // Create certificates for use by client and server. Add server cert to client truststore and vice versa.\n+        CertStores serverCertStores = new CertStores(true, \"server\",  \"localhost\");\n+        CertStores clientCertStores = new CertStores(false, \"client\", \"localhost\");\n+\n+        Map<String, Object> sslClientConfigs = getTrustingConfig(clientCertStores, serverCertStores, tlsClientProtocols);\n+        Map<String, Object> sslServerConfigs = getTrustingConfig(serverCertStores, clientCertStores, tlsServerProtocols);\n+\n+        NioEchoServer server = NetworkTestUtils.createEchoServer(ListenerName.forSecurityProtocol(SecurityProtocol.SSL),\n+             SecurityProtocol.SSL,\n+             new TestSecurityConfig(sslServerConfigs),\n+             null,\n+            TIME);\n+        Selector selector = createSelector(sslClientConfigs);\n+\n+        String node = \"0\";\n+        selector.connect(node, new InetSocketAddress(\"localhost\", server.port()), BUFFER_SIZE, BUFFER_SIZE);\n+\n+        if (tlsServerProtocols.contains(tlsClientProtocols.get(0))) {", "originalCommit": "61cd6c5e667a9ca1f1b7b94dd0590c4b8c1d0899", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMjE0NQ==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r432632145", "bodyText": "Fixed.", "author": "nizhikov", "createdAt": "2020-05-29T17:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyNjkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyOTc3MA==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431829770", "bodyText": "Do we want server.verifyAuthenticationMetrics(0, 1); here as in the other test?", "author": "ijuma", "createdAt": "2020-05-28T13:22:02Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +623,79 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2_FailsForTLSv1_3() throws Exception {\n+        assumeTrue(Java.IS_JAVA11_COMPATIBLE);\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteFailForServerTLSv1_2_ClientTLSv1_3() throws Exception {\n+        assumeTrue(Java.IS_JAVA11_COMPATIBLE);\n+\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.2\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");", "originalCommit": "61cd6c5e667a9ca1f1b7b94dd0590c4b8c1d0899", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMjI2Ng==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r432632266", "bodyText": "Fixed.", "author": "nizhikov", "createdAt": "2020-05-29T17:27:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyOTc3MA=="}], "type": "inlineReview"}, {"oid": "fd1f48b04519a65cdb91f5a28b6a2bd6886adc61", "url": "https://github.com/apache/kafka/commit/fd1f48b04519a65cdb91f5a28b6a2bd6886adc61", "message": "KAFKA-9320: code review fixes", "committedDate": "2020-05-29T08:47:11Z", "type": "commit"}, {"oid": "e1a2fe47c9eb4d8a6799a1086f7070edec148827", "url": "https://github.com/apache/kafka/commit/e1a2fe47c9eb4d8a6799a1086f7070edec148827", "message": "Merge branch 'trunk' into KAFKA-9320", "committedDate": "2020-05-29T08:47:47Z", "type": "commit"}, {"oid": "4e7eaec600e094062cdd312fadb1177119aabdfa", "url": "https://github.com/apache/kafka/commit/4e7eaec600e094062cdd312fadb1177119aabdfa", "message": "KAFKA-9320: test fix.", "committedDate": "2020-05-29T13:56:42Z", "type": "commit"}, {"oid": "c756720b15c35e22f09a1ee7613dae6e2a190a29", "url": "https://github.com/apache/kafka/commit/c756720b15c35e22f09a1ee7613dae6e2a190a29", "message": "KAFKA-9320: code review fixes.", "committedDate": "2020-05-29T17:33:53Z", "type": "commit"}, {"oid": "a231e2f3a556be7b0cbca51b46d290e3b70ef47e", "url": "https://github.com/apache/kafka/commit/a231e2f3a556be7b0cbca51b46d290e3b70ef47e", "message": "KAFKA-9320: code review fixes.", "committedDate": "2020-05-29T17:51:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2NjA1MA==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r432866050", "bodyText": "What is the reason for this?", "author": "ijuma", "createdAt": "2020-05-30T15:59:35Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -580,7 +581,16 @@ public void testTLSDefaults() throws Exception {\n \n     @Test\n     public void testUnsupportedCipher() throws Exception {\n-        String[] cipherSuites = ((SSLServerSocketFactory) SSLServerSocketFactory.getDefault()).getSupportedCipherSuites();\n+        String[] cipherSuites;\n+        if (Java.IS_JAVA11_COMPATIBLE) {\n+            cipherSuites = new String[] {\n+                \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\",", "originalCommit": "a231e2f3a556be7b0cbca51b46d290e3b70ef47e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEwMjE0MA==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433102140", "bodyText": "We should use correct cipher for the server(which uses TLSv1.3 in case Java11) otherwise server metrics not updated because we never get AuthenticationException on the server-side. Instead of it, we get IOException from SSLTransportLayer:\n    private SSLEngineResult handshakeUnwrap(boolean doRead, boolean ignoreHandshakeStatus) throws IOException {\n...\n        // Throw EOF exception for failed read after processing already received data\n        // so that handshake failures are reported correctly\n        if (read == -1)\n            throw new EOFException(\"EOF during handshake, handshake status is \" + handshakeStatus);\n}", "author": "nizhikov", "createdAt": "2020-06-01T08:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2NjA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI3MTA3Ng==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433271076", "bodyText": "The previous logic is weird, I agree. I think the idea here is to simply pick a different supported cipher in the server vs the client. I think we can drop getSupportedCipherSuites altogether and just pick two ciphers explicitly. The cipher names would be different for TLS 1.2 versus TLS 1.3.\nAlso, we should change the following to simply use the tlsVersion field.\n            checkAuthentiationFailed(\"1\", \"TLSv1.1\");\n            server.verifyAuthenticationMetrics(0, 1);\n            checkAuthentiationFailed(\"2\", \"TLSv1\");\n            server.verifyAuthenticationMetrics(0, 2);", "author": "ijuma", "createdAt": "2020-06-01T14:34:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2NjA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI3NDYxMw==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433274613", "bodyText": "Also, note that we also have testUnsupportedCiphers. I wonder if we can delete this test.", "author": "ijuma", "createdAt": "2020-06-01T14:40:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2NjA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI3OTY0OQ==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433279649", "bodyText": "Maybe we add checkAuthentiationFailed to testUnsupportedCiphers and delete this test.", "author": "ijuma", "createdAt": "2020-06-01T14:48:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2NjA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM1MjEyMg==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433352122", "bodyText": "Done.", "author": "nizhikov", "createdAt": "2020-06-01T16:36:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2NjA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4Nzc5Ng==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r432987796", "bodyText": "We normally don't have _ in method names. Can we remove it from here and other test methods?", "author": "ijuma", "createdAt": "2020-05-31T21:52:39Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +632,108 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTls12_FailsForTls13() throws Exception {", "originalCommit": "a231e2f3a556be7b0cbca51b46d290e3b70ef47e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7ab2f390cfda9601f69dc0000d3ec8ccba1ec2fb", "url": "https://github.com/apache/kafka/commit/7ab2f390cfda9601f69dc0000d3ec8ccba1ec2fb", "message": "KAFKA-9320: code review fixes.", "committedDate": "2020-06-01T09:54:31Z", "type": "commit"}, {"oid": "17612acc5acd40f33f133df18c679ad4fb07d8f4", "url": "https://github.com/apache/kafka/commit/17612acc5acd40f33f133df18c679ad4fb07d8f4", "message": "KAFKA-9320: code review fixes.", "committedDate": "2020-06-01T13:24:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI1MzA4OA==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433253088", "bodyText": "Why did we make these changes? I think what we had was good.", "author": "ijuma", "createdAt": "2020-06-01T14:03:50Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslVersionsTransportLayerTest.java", "diffHunk": "@@ -54,21 +54,16 @@\n         List<Object[]> values = new ArrayList<>();\n         values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Collections.singletonList(\"TLSv1.2\")});\n         if (Java.IS_JAVA11_COMPATIBLE) {\n-            values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Collections.singletonList(\"TLSv1.3\")});\n-            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Collections.singletonList(\"TLSv1.2\")});\n-            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Collections.singletonList(\"TLSv1.3\")});\n-            values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n-            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n-            values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n-            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n             values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Collections.singletonList(\"TLSv1.3\")});\n             values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Collections.singletonList(\"TLSv1.2\")});\n-            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Collections.singletonList(\"TLSv1.3\")});\n-            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Collections.singletonList(\"TLSv1.2\")});\n             values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n             values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Collections.singletonList(\"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Collections.singletonList(\"TLSv1.2\")});\n             values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n             values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+", "originalCommit": "17612acc5acd40f33f133df18c679ad4fb07d8f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI2NTM1Ng==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433265356", "bodyText": "Actually, test fails for a single case:\nFor now, I have no idea why this happen :)\nI need some time to dig into details and explain results.\nAnyway, I revert the test with all possible combinations(that will fail).\nvalues.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n\nThis means:\n#server config\nssl.protocol=TLSv1.3\nssl.enabled.protocols=TLSv1.3\n\n#client config\nssl.protocol=TLSv1.2\nssl.enabled.protocols=TLSv1.2,TLSv1.3", "author": "nizhikov", "createdAt": "2020-06-01T14:24:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI1MzA4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI4MzUwOQ==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433283509", "bodyText": "Interesting! Good that we added that test. :)", "author": "ijuma", "createdAt": "2020-06-01T14:55:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI1MzA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI2MDcxNg==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433260716", "bodyText": "Hmm, these tests seem to take a long time. Do you know why? See:", "author": "ijuma", "createdAt": "2020-06-01T14:16:38Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +632,108 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTls12FailsForTls13() throws Exception {\n+        assumeTrue(Java.IS_JAVA11_COMPATIBLE);\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Collections.singletonList(\"TLSv1.3\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Collections.singletonList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Collections.singletonList(\"TLSv1.3\"));\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Collections.singletonList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can't be made if server uses TLSv1.2 with custom cipher suite and client uses TLSv1.3.\n+     */\n+    @Test\n+    public void testCiphersSuiteFailForServerTls12ClientTls13() throws Exception {\n+        assumeTrue(Java.IS_JAVA11_COMPATIBLE);\n+\n+        String tls12CipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+        String tls13CipherSuite = \"TLS_AES_128_GCM_SHA256\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Collections.singletonList(\"TLSv1.2\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Collections.singletonList(tls12CipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Collections.singletonList(tls13CipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.3 cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTls13() throws Exception {", "originalCommit": "17612acc5acd40f33f133df18c679ad4fb07d8f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI3MDc2Nw==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433270767", "bodyText": "Fixed.\nThe cause was the line\nNetworkTestUtils.waitForChannelClose(selector, node, ChannelState.State.READY);\nchanged to - NetworkTestUtils.waitForChannelReady(selector, node);\nWe shouldn't wait channel to close.\nNow, locally test run less than second.", "author": "nizhikov", "createdAt": "2020-06-01T14:33:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI2MDcxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI4MzA5Ng==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433283096", "bodyText": "Great!", "author": "ijuma", "createdAt": "2020-06-01T14:54:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI2MDcxNg=="}], "type": "inlineReview"}, {"oid": "ebb20e1b1bf8d067f61e615eadcf5b760db56917", "url": "https://github.com/apache/kafka/commit/ebb20e1b1bf8d067f61e615eadcf5b760db56917", "message": "KAFKA-9320: revert test changes.", "committedDate": "2020-06-01T14:20:16Z", "type": "commit"}, {"oid": "1b5558745b59da61594b2b728d99593bc6c620f3", "url": "https://github.com/apache/kafka/commit/1b5558745b59da61594b2b728d99593bc6c620f3", "message": "KAFKA-9320: fix test duration.", "committedDate": "2020-06-01T14:35:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI3OTcwMQ==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433279701", "bodyText": "These two lines are unused. Similar for other tests.", "author": "ijuma", "createdAt": "2020-06-01T14:49:01Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +632,108 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTls12FailsForTls13() throws Exception {\n+        assumeTrue(Java.IS_JAVA11_COMPATIBLE);\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);", "originalCommit": "17612acc5acd40f33f133df18c679ad4fb07d8f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI4MzM2Nw==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433283367", "bodyText": "Fixed.", "author": "nizhikov", "createdAt": "2020-06-01T14:54:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI3OTcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI4MjcwOA==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433282708", "bodyText": "I had not noticed that this test is parameterized on tlsProtocol. Maybe we should move these tests to a separate class? It's a bit weird to run them twice and ignore the parameterized value.", "author": "ijuma", "createdAt": "2020-06-01T14:53:49Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +632,108 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTls12FailsForTls13() throws Exception {\n+        assumeTrue(Java.IS_JAVA11_COMPATIBLE);\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);", "originalCommit": "17612acc5acd40f33f133df18c679ad4fb07d8f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzOTE4MA==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433339180", "bodyText": "Moved.", "author": "nizhikov", "createdAt": "2020-06-01T16:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI4MjcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM1MTY4NA==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433351684", "bodyText": "Done. See SslTransportTls12Tls13Test", "author": "nizhikov", "createdAt": "2020-06-01T16:35:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI4MjcwOA=="}], "type": "inlineReview"}, {"oid": "9da1c210fcd6db5bc9f8c37c3fd13c1be88ae6f7", "url": "https://github.com/apache/kafka/commit/9da1c210fcd6db5bc9f8c37c3fd13c1be88ae6f7", "message": "KAFKA-9320: unused code removed.", "committedDate": "2020-06-01T15:12:05Z", "type": "commit"}, {"oid": "3e6c445cf9ef9f7d229c90bf3c6debdf19aa96bd", "url": "https://github.com/apache/kafka/commit/3e6c445cf9ef9f7d229c90bf3c6debdf19aa96bd", "message": "KAFKA-9320: code review fixes.", "committedDate": "2020-06-01T16:34:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQxMzI1MA==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433413250", "bodyText": "Shall we keep the authentication metrics check?", "author": "ijuma", "createdAt": "2020-06-01T18:31:41Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -732,11 +614,8 @@ public void testUnsupportedCiphers() throws Exception {\n \n         sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuites[1]));\n         createSelector(sslClientConfigs);\n-        InetSocketAddress addr = new InetSocketAddress(\"localhost\", server.port());\n-        selector.connect(node, addr, BUFFER_SIZE, BUFFER_SIZE);\n \n-        NetworkTestUtils.waitForChannelClose(selector, node, ChannelState.State.AUTHENTICATION_FAILED);\n-        server.verifyAuthenticationMetrics(0, 1);", "originalCommit": "3e6c445cf9ef9f7d229c90bf3c6debdf19aa96bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYzNjIzNg==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433636236", "bodyText": "Fixed.", "author": "nizhikov", "createdAt": "2020-06-02T05:55:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQxMzI1MA=="}], "type": "inlineReview"}, {"oid": "14bf85aab93eabd5eb5045315edf104079b4d353", "url": "https://github.com/apache/kafka/commit/14bf85aab93eabd5eb5045315edf104079b4d353", "message": "KAFKA-9320: TLSv1.3 vs TLSv1.2 explanation comments.", "committedDate": "2020-06-02T12:38:30Z", "type": "commit"}, {"oid": "67f0ef90d9f9e687b0f9792d043cb3819617d85c", "url": "https://github.com/apache/kafka/commit/67f0ef90d9f9e687b0f9792d043cb3819617d85c", "message": "Merge branch 'trunk' into KAFKA-9320", "committedDate": "2020-06-02T13:05:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5MjI2OQ==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433892269", "bodyText": "Should this be called createClientSelector?", "author": "ijuma", "createdAt": "2020-06-02T13:53:06Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslVersionsTransportLayerTest.java", "diffHunk": "@@ -117,24 +123,51 @@ public void testTlsDefaults() throws Exception {\n             server.waitForMetric(\"response\", 1);\n         } else {\n             NetworkTestUtils.waitForChannelClose(selector, node, ChannelState.State.AUTHENTICATION_FAILED);\n+            server.verifyAuthenticationMetrics(0, 1);\n         }\n     }\n \n+    /**\n+     * <p>\n+     * The explanation of this check in the structure of the ClientHello SSL message.\n+     * Please, take a look at the <a href=\"https://docs.oracle.com/en/java/javase/11/security/java-secure-socket-extension-jsse-reference-guide.html#GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6\">Guide</a>,\n+     * \"Send ClientHello Message\" section.\n+     * <p>\n+     * > Client version: For TLS 1.3, this has a fixed value, TLSv1.2; TLS 1.3 uses the extension supported_versions and not this field to negotiate protocol version\n+     * ...\n+     * > supported_versions: Lists which versions of TLS the client supports. In particular, if the client\n+     * > requests TLS 1.3, then the client version field has the value TLSv1.2 and this extension\n+     * > contains the value TLSv1.3; if the client requests TLS 1.2, then the client version field has the\n+     * > value TLSv1.2 and this extension either doesn\u2019t exist or contains the value TLSv1.2 but not the value TLSv1.3.\n+     * <p>\n+     *\n+     * This mean that TLSv1.3 client can fallback to TLSv1.2 but TLSv1.2 client can't change protocol to TLSv1.3.\n+     *\n+     * @param serverProtocols Server protocols.\n+     * @param clientProtocols Client protocols.\n+     * @return {@code True} if client should be able to connect to the server.\n+     */\n+    private boolean isCompatible(List<String> serverProtocols, List<String> clientProtocols) {\n+        return serverProtocols.contains(clientProtocols.get(0)) ||\n+            (clientProtocols.get(0).equals(\"TLSv1.3\") && clientProtocols.contains(\"TLSv1.2\"));\n+    }\n+\n     private static Map<String, Object> getTrustingConfig(CertStores certStores, CertStores peerCertStores, List<String> tlsProtocols) {\n         Map<String, Object> configs = certStores.getTrustingConfig(peerCertStores);\n         configs.putAll(sslConfig(tlsProtocols));\n         return configs;\n     }\n \n-    private static Map<String, Object> sslConfig(List<String> tlsServerProtocols) {\n+    private static Map<String, Object> sslConfig(List<String> tlsProtocols) {\n         Map<String, Object> sslConfig = new HashMap<>();\n-        sslConfig.put(SslConfigs.SSL_PROTOCOL_CONFIG, tlsServerProtocols.get(0));\n-        sslConfig.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsServerProtocols);\n+        sslConfig.put(SslConfigs.SSL_PROTOCOL_CONFIG, tlsProtocols.get(0));\n+        sslConfig.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsProtocols);\n         return sslConfig;\n     }\n \n     private Selector createSelector(Map<String, Object> sslClientConfigs) {", "originalCommit": "14bf85aab93eabd5eb5045315edf104079b4d353", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5OTc2MQ==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433899761", "bodyText": "Done.", "author": "nizhikov", "createdAt": "2020-06-02T14:02:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5MjI2OQ=="}], "type": "inlineReview"}, {"oid": "869e342f4cc0dd5b3f7120cfadb3175bb6f48ff7", "url": "https://github.com/apache/kafka/commit/869e342f4cc0dd5b3f7120cfadb3175bb6f48ff7", "message": "KAFKA-9320: code review fixes.", "committedDate": "2020-06-02T14:02:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5ODkwNw==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433898907", "bodyText": "Nit: True should be lower case.", "author": "ijuma", "createdAt": "2020-06-02T14:01:16Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslVersionsTransportLayerTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.network;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.kafka.common.metrics.Metrics;\n+import org.apache.kafka.common.security.TestSecurityConfig;\n+import org.apache.kafka.common.security.auth.SecurityProtocol;\n+import org.apache.kafka.common.utils.Java;\n+import org.apache.kafka.common.utils.LogContext;\n+import org.apache.kafka.common.utils.Time;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests for the SSL transport layer.\n+ * Checks different versions of the protocol usage on the server and client.\n+ */\n+@RunWith(value = Parameterized.class)\n+public class SslVersionsTransportLayerTest {\n+    private static final int BUFFER_SIZE = 4 * 1024;\n+    private static final Time TIME = Time.SYSTEM;\n+\n+    private final List<String> serverProtocols;\n+    private final List<String> clientProtocols;\n+\n+    @Parameterized.Parameters(name = \"tlsServerProtocol={0},tlsClientProtocol={1}\")\n+    public static Collection<Object[]> data() {\n+        List<Object[]> values = new ArrayList<>();\n+\n+        values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Collections.singletonList(\"TLSv1.2\")});\n+\n+        if (Java.IS_JAVA11_COMPATIBLE) {\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Collections.singletonList(\"TLSv1.3\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Collections.singletonList(\"TLSv1.2\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Collections.singletonList(\"TLSv1.3\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Collections.singletonList(\"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Collections.singletonList(\"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Collections.singletonList(\"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Collections.singletonList(\"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Be aware that you can turn on debug mode for a javax.net.ssl library with the line {@code System.setProperty(\"javax.net.debug\", \"ssl:handshake\");}\n+     * @param serverProtocols Server protocols.\n+     * @param clientProtocols Client protocols.\n+     */\n+    public SslVersionsTransportLayerTest(List<String> serverProtocols, List<String> clientProtocols) {\n+        this.serverProtocols = serverProtocols;\n+        this.clientProtocols = clientProtocols;\n+    }\n+\n+    /**\n+     * Tests that connection success with the default TLS version.\n+     */\n+    @Test\n+    public void testTlsDefaults() throws Exception {\n+        // Create certificates for use by client and server. Add server cert to client truststore and vice versa.\n+        CertStores serverCertStores = new CertStores(true, \"server\",  \"localhost\");\n+        CertStores clientCertStores = new CertStores(false, \"client\", \"localhost\");\n+\n+        Map<String, Object> sslClientConfigs = getTrustingConfig(clientCertStores, serverCertStores, clientProtocols);\n+        Map<String, Object> sslServerConfigs = getTrustingConfig(serverCertStores, clientCertStores, serverProtocols);\n+\n+        NioEchoServer server = NetworkTestUtils.createEchoServer(ListenerName.forSecurityProtocol(SecurityProtocol.SSL),\n+            SecurityProtocol.SSL,\n+            new TestSecurityConfig(sslServerConfigs),\n+            null,\n+            TIME);\n+        Selector selector = createSelector(sslClientConfigs);\n+\n+        String node = \"0\";\n+        selector.connect(node, new InetSocketAddress(\"localhost\", server.port()), BUFFER_SIZE, BUFFER_SIZE);\n+\n+        if (isCompatible(serverProtocols, clientProtocols)) {\n+            NetworkTestUtils.waitForChannelReady(selector, node);\n+\n+            int msgSz = 1024 * 1024;\n+            String message = TestUtils.randomString(msgSz);\n+            selector.send(new NetworkSend(node, ByteBuffer.wrap(message.getBytes())));\n+            while (selector.completedReceives().isEmpty()) {\n+                selector.poll(100L);\n+            }\n+            int totalBytes = msgSz + 4; // including 4-byte size\n+            server.waitForMetric(\"incoming-byte\", totalBytes);\n+            server.waitForMetric(\"outgoing-byte\", totalBytes);\n+            server.waitForMetric(\"request\", 1);\n+            server.waitForMetric(\"response\", 1);\n+        } else {\n+            NetworkTestUtils.waitForChannelClose(selector, node, ChannelState.State.AUTHENTICATION_FAILED);\n+            server.verifyAuthenticationMetrics(0, 1);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * The explanation of this check in the structure of the ClientHello SSL message.\n+     * Please, take a look at the <a href=\"https://docs.oracle.com/en/java/javase/11/security/java-secure-socket-extension-jsse-reference-guide.html#GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6\">Guide</a>,\n+     * \"Send ClientHello Message\" section.\n+     * <p>\n+     * > Client version: For TLS 1.3, this has a fixed value, TLSv1.2; TLS 1.3 uses the extension supported_versions and not this field to negotiate protocol version\n+     * ...\n+     * > supported_versions: Lists which versions of TLS the client supports. In particular, if the client\n+     * > requests TLS 1.3, then the client version field has the value TLSv1.2 and this extension\n+     * > contains the value TLSv1.3; if the client requests TLS 1.2, then the client version field has the\n+     * > value TLSv1.2 and this extension either doesn\u2019t exist or contains the value TLSv1.2 but not the value TLSv1.3.\n+     * <p>\n+     *\n+     * This mean that TLSv1.3 client can fallback to TLSv1.2 but TLSv1.2 client can't change protocol to TLSv1.3.\n+     *\n+     * @param serverProtocols Server protocols.\n+     * @param clientProtocols Client protocols.\n+     * @return {@code True} if client should be able to connect to the server.", "originalCommit": "67f0ef90d9f9e687b0f9792d043cb3819617d85c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwMzA5OQ==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433903099", "bodyText": "Maybe we should document that serverProtocols and clientProtocols are expected to be non empty as the code below assumes it.", "author": "ijuma", "createdAt": "2020-06-02T14:05:24Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslVersionsTransportLayerTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.network;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.kafka.common.metrics.Metrics;\n+import org.apache.kafka.common.security.TestSecurityConfig;\n+import org.apache.kafka.common.security.auth.SecurityProtocol;\n+import org.apache.kafka.common.utils.Java;\n+import org.apache.kafka.common.utils.LogContext;\n+import org.apache.kafka.common.utils.Time;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests for the SSL transport layer.\n+ * Checks different versions of the protocol usage on the server and client.\n+ */\n+@RunWith(value = Parameterized.class)\n+public class SslVersionsTransportLayerTest {\n+    private static final int BUFFER_SIZE = 4 * 1024;\n+    private static final Time TIME = Time.SYSTEM;\n+\n+    private final List<String> serverProtocols;\n+    private final List<String> clientProtocols;\n+\n+    @Parameterized.Parameters(name = \"tlsServerProtocol={0},tlsClientProtocol={1}\")\n+    public static Collection<Object[]> data() {\n+        List<Object[]> values = new ArrayList<>();\n+\n+        values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Collections.singletonList(\"TLSv1.2\")});\n+\n+        if (Java.IS_JAVA11_COMPATIBLE) {\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Collections.singletonList(\"TLSv1.3\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Collections.singletonList(\"TLSv1.2\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Collections.singletonList(\"TLSv1.3\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Collections.singletonList(\"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Collections.singletonList(\"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Collections.singletonList(\"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Collections.singletonList(\"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Be aware that you can turn on debug mode for a javax.net.ssl library with the line {@code System.setProperty(\"javax.net.debug\", \"ssl:handshake\");}\n+     * @param serverProtocols Server protocols.\n+     * @param clientProtocols Client protocols.\n+     */\n+    public SslVersionsTransportLayerTest(List<String> serverProtocols, List<String> clientProtocols) {\n+        this.serverProtocols = serverProtocols;\n+        this.clientProtocols = clientProtocols;\n+    }\n+\n+    /**\n+     * Tests that connection success with the default TLS version.\n+     */\n+    @Test\n+    public void testTlsDefaults() throws Exception {\n+        // Create certificates for use by client and server. Add server cert to client truststore and vice versa.\n+        CertStores serverCertStores = new CertStores(true, \"server\",  \"localhost\");\n+        CertStores clientCertStores = new CertStores(false, \"client\", \"localhost\");\n+\n+        Map<String, Object> sslClientConfigs = getTrustingConfig(clientCertStores, serverCertStores, clientProtocols);\n+        Map<String, Object> sslServerConfigs = getTrustingConfig(serverCertStores, clientCertStores, serverProtocols);\n+\n+        NioEchoServer server = NetworkTestUtils.createEchoServer(ListenerName.forSecurityProtocol(SecurityProtocol.SSL),\n+            SecurityProtocol.SSL,\n+            new TestSecurityConfig(sslServerConfigs),\n+            null,\n+            TIME);\n+        Selector selector = createSelector(sslClientConfigs);\n+\n+        String node = \"0\";\n+        selector.connect(node, new InetSocketAddress(\"localhost\", server.port()), BUFFER_SIZE, BUFFER_SIZE);\n+\n+        if (isCompatible(serverProtocols, clientProtocols)) {\n+            NetworkTestUtils.waitForChannelReady(selector, node);\n+\n+            int msgSz = 1024 * 1024;\n+            String message = TestUtils.randomString(msgSz);\n+            selector.send(new NetworkSend(node, ByteBuffer.wrap(message.getBytes())));\n+            while (selector.completedReceives().isEmpty()) {\n+                selector.poll(100L);\n+            }\n+            int totalBytes = msgSz + 4; // including 4-byte size\n+            server.waitForMetric(\"incoming-byte\", totalBytes);\n+            server.waitForMetric(\"outgoing-byte\", totalBytes);\n+            server.waitForMetric(\"request\", 1);\n+            server.waitForMetric(\"response\", 1);\n+        } else {\n+            NetworkTestUtils.waitForChannelClose(selector, node, ChannelState.State.AUTHENTICATION_FAILED);\n+            server.verifyAuthenticationMetrics(0, 1);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * The explanation of this check in the structure of the ClientHello SSL message.\n+     * Please, take a look at the <a href=\"https://docs.oracle.com/en/java/javase/11/security/java-secure-socket-extension-jsse-reference-guide.html#GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6\">Guide</a>,\n+     * \"Send ClientHello Message\" section.\n+     * <p>\n+     * > Client version: For TLS 1.3, this has a fixed value, TLSv1.2; TLS 1.3 uses the extension supported_versions and not this field to negotiate protocol version\n+     * ...\n+     * > supported_versions: Lists which versions of TLS the client supports. In particular, if the client\n+     * > requests TLS 1.3, then the client version field has the value TLSv1.2 and this extension\n+     * > contains the value TLSv1.3; if the client requests TLS 1.2, then the client version field has the\n+     * > value TLSv1.2 and this extension either doesn\u2019t exist or contains the value TLSv1.2 but not the value TLSv1.3.\n+     * <p>\n+     *\n+     * This mean that TLSv1.3 client can fallback to TLSv1.2 but TLSv1.2 client can't change protocol to TLSv1.3.\n+     *\n+     * @param serverProtocols Server protocols.\n+     * @param clientProtocols Client protocols.", "originalCommit": "67f0ef90d9f9e687b0f9792d043cb3819617d85c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwNjUzMw==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433906533", "bodyText": "Would the second check if clearer if it was like:\nclientProtocols.get(0).equals(\"TLSv1.3\") && !Collections.disjoint(tlsServerProtocols, tlsClientProtocols)\nWe're basically saying that we check all the client protocols against the broker protocols if the client uses TLS 1.3. The first condition checks the case where the first client protocol is supported by the server (TLS 1.2).", "author": "ijuma", "createdAt": "2020-06-02T14:09:16Z", "path": "clients/src/test/java/org/apache/kafka/common/network/SslVersionsTransportLayerTest.java", "diffHunk": "@@ -117,24 +123,51 @@ public void testTlsDefaults() throws Exception {\n             server.waitForMetric(\"response\", 1);\n         } else {\n             NetworkTestUtils.waitForChannelClose(selector, node, ChannelState.State.AUTHENTICATION_FAILED);\n+            server.verifyAuthenticationMetrics(0, 1);\n         }\n     }\n \n+    /**\n+     * <p>\n+     * The explanation of this check in the structure of the ClientHello SSL message.\n+     * Please, take a look at the <a href=\"https://docs.oracle.com/en/java/javase/11/security/java-secure-socket-extension-jsse-reference-guide.html#GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6\">Guide</a>,\n+     * \"Send ClientHello Message\" section.\n+     * <p>\n+     * > Client version: For TLS 1.3, this has a fixed value, TLSv1.2; TLS 1.3 uses the extension supported_versions and not this field to negotiate protocol version\n+     * ...\n+     * > supported_versions: Lists which versions of TLS the client supports. In particular, if the client\n+     * > requests TLS 1.3, then the client version field has the value TLSv1.2 and this extension\n+     * > contains the value TLSv1.3; if the client requests TLS 1.2, then the client version field has the\n+     * > value TLSv1.2 and this extension either doesn\u2019t exist or contains the value TLSv1.2 but not the value TLSv1.3.\n+     * <p>\n+     *\n+     * This mean that TLSv1.3 client can fallback to TLSv1.2 but TLSv1.2 client can't change protocol to TLSv1.3.\n+     *\n+     * @param serverProtocols Server protocols.\n+     * @param clientProtocols Client protocols.\n+     * @return {@code True} if client should be able to connect to the server.\n+     */\n+    private boolean isCompatible(List<String> serverProtocols, List<String> clientProtocols) {\n+        return serverProtocols.contains(clientProtocols.get(0)) ||\n+            (clientProtocols.get(0).equals(\"TLSv1.3\") && clientProtocols.contains(\"TLSv1.2\"));", "originalCommit": "14bf85aab93eabd5eb5045315edf104079b4d353", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyMDM1MA==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433920350", "bodyText": "Done.", "author": "nizhikov", "createdAt": "2020-06-02T14:27:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwNjUzMw=="}], "type": "inlineReview"}, {"oid": "ca81fcd1c1d40491cb756e12e0c26b875e12c0b4", "url": "https://github.com/apache/kafka/commit/ca81fcd1c1d40491cb756e12e0c26b875e12c0b4", "message": "KAFKA-9320: code review fixes.", "committedDate": "2020-06-02T14:37:05Z", "type": "commit"}, {"oid": "6a82441c99dbd97ce820fed4891b2b237a3f2ea9", "url": "https://github.com/apache/kafka/commit/6a82441c99dbd97ce820fed4891b2b237a3f2ea9", "message": "KAFKA-9320: SSL_PROTOCOL_DOC updated.", "committedDate": "2020-06-02T14:40:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk4MTg5Mg==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433981892", "bodyText": "How about:\n\"The SSL protocol used to generate the SSLContext. \"\n            + \"The default is TLSv1.3 when running with Java 11 or newer, TLSv1.2 otherwise. \"\n            + \"This value should be fine for most use cases. \"\n            + \"Allowed values in recent JVMs are TLSv1.2 and TLSv1.3. TLS, TLSv1.1, SSL, SSLv2 and SSLv3 \"\n            + \"may be supported in older JVMs, but their usage is discouraged due to known security vulnerabilities. \";\n            + \"With the default value for this config and ssl.enabled.protocols, clients will downgrade to TLSv1.2 if \"\n            + \"the server does not support TLSv1.3. If this config is set to TLSv1.2, clients will not use TLSv1.3 even \"\n            + \"if it is one of the values in ssl.enabled.protocols and the server only supports TLSv1.3.\"", "author": "ijuma", "createdAt": "2020-06-02T15:49:27Z", "path": "clients/src/main/java/org/apache/kafka/common/config/SslConfigs.java", "diffHunk": "@@ -49,11 +50,12 @@\n \n     public static final String SSL_PROTOCOL_CONFIG = \"ssl.protocol\";\n     public static final String SSL_PROTOCOL_DOC = \"The SSL protocol used to generate the SSLContext. \"\n-            + \"Default setting is TLSv1.2, which is fine for most cases. \"\n+            + \"Default setting is TLSv1.2(TLSv1.3 for modern JVM), which is fine for most cases. \"\n             + \"Allowed values in recent JVMs are TLSv1.2 and TLSv1.3. TLS, TLSv1.1, SSL, SSLv2 and SSLv3 \"\n-            + \"may be supported in older JVMs, but their usage is discouraged due to known security vulnerabilities.\";\n+            + \"may be supported in older JVMs, but their usage is discouraged due to known security vulnerabilities.\"\n+            + \"Please, note, TLSv1.2 clients can't connect to the servers with TLSv1.3 only even if ssl.enabled.protocols contains TLSv1.3\";", "originalCommit": "6a82441c99dbd97ce820fed4891b2b237a3f2ea9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk4NzM4NA==", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433987384", "bodyText": "How about:\nThe list of protocols enabled for SSL connections. The default is 'TLSv1.2,TLSv1.3' when running with Java 11 or newer, 'TLSv1.2' otherwise. With the default value for Java 11, clients and servers will prefer TLSv1.3 if both support it and fallback to TLSv1.2 otherwise (assuming both support at least TLSv1.2). This default should be fine for most cases. Also see the `ssl.protocol` config documentation.", "author": "ijuma", "createdAt": "2020-06-02T15:54:49Z", "path": "clients/src/main/java/org/apache/kafka/common/config/SslConfigs.java", "diffHunk": "@@ -64,7 +66,17 @@\n \n     public static final String SSL_ENABLED_PROTOCOLS_CONFIG = \"ssl.enabled.protocols\";\n     public static final String SSL_ENABLED_PROTOCOLS_DOC = \"The list of protocols enabled for SSL connections.\";", "originalCommit": "6a82441c99dbd97ce820fed4891b2b237a3f2ea9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ce7505f17c030b942dfa931a03fab6b779a92d94", "url": "https://github.com/apache/kafka/commit/ce7505f17c030b942dfa931a03fab6b779a92d94", "message": "Documentation tweaks", "committedDate": "2020-06-02T19:10:15Z", "type": "commit"}, {"oid": "ce7505f17c030b942dfa931a03fab6b779a92d94", "url": "https://github.com/apache/kafka/commit/ce7505f17c030b942dfa931a03fab6b779a92d94", "message": "Documentation tweaks", "committedDate": "2020-06-02T19:10:15Z", "type": "forcePushed"}, {"oid": "b2935783c54e17b208832a749600a12923b625d8", "url": "https://github.com/apache/kafka/commit/b2935783c54e17b208832a749600a12923b625d8", "message": "Merge branch 'trunk' into KAFKA-9320", "committedDate": "2020-06-02T19:56:57Z", "type": "commit"}]}