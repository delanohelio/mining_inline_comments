{"pr_number": 9001, "pr_title": "KAFKA-10028: Implement write path for feature versioning system (KIP-584)", "pr_createdAt": "2020-07-09T10:50:51Z", "pr_url": "https://github.com/apache/kafka/pull/9001", "timeline": [{"oid": "824e2f7141f208acc5cdb661043949d0977725c4", "url": "https://github.com/apache/kafka/commit/824e2f7141f208acc5cdb661043949d0977725c4", "message": "Implement KIP-584 write path", "committedDate": "2020-10-06T22:58:15Z", "type": "commit"}, {"oid": "cc23765e8c9244a4701c0e6ccbd281af6bd8b794", "url": "https://github.com/apache/kafka/commit/cc23765e8c9244a4701c0e6ccbd281af6bd8b794", "message": "Fix checkstyle issues", "committedDate": "2020-10-06T22:58:15Z", "type": "commit"}, {"oid": "114e24df5f08a42a4b9175cc57f1efc13e25df6e", "url": "https://github.com/apache/kafka/commit/114e24df5f08a42a4b9175cc57f1efc13e25df6e", "message": "Minor: Improved comment", "committedDate": "2020-10-06T22:58:15Z", "type": "commit"}, {"oid": "9af2a010ae81d2dc31383eb986cdf55fcd6f6509", "url": "https://github.com/apache/kafka/commit/9af2a010ae81d2dc31383eb986cdf55fcd6f6509", "message": "Minor: cosmetics", "committedDate": "2020-10-06T22:58:15Z", "type": "commit"}, {"oid": "afa3ab951dc92586165eca6baa7faa939e54deff", "url": "https://github.com/apache/kafka/commit/afa3ab951dc92586165eca6baa7faa939e54deff", "message": "Fix small bug", "committedDate": "2020-10-06T22:58:15Z", "type": "commit"}, {"oid": "59d80385ea222eca250b6459cc53212770353109", "url": "https://github.com/apache/kafka/commit/59d80385ea222eca250b6459cc53212770353109", "message": "Minor: improve one of the tests slightly to handle +1 case", "committedDate": "2020-10-06T22:58:15Z", "type": "commit"}, {"oid": "9cdfc3134b217df5adf90947bbff65662d822d68", "url": "https://github.com/apache/kafka/commit/9cdfc3134b217df5adf90947bbff65662d822d68", "message": "Address comments from Boyang", "committedDate": "2020-10-06T22:58:16Z", "type": "commit"}, {"oid": "08f064b6cb42e3cfed06285f10de4428ba1a6091", "url": "https://github.com/apache/kafka/commit/08f064b6cb42e3cfed06285f10de4428ba1a6091", "message": "Minor: add missing header in UpdateFeaturesTest.scala", "committedDate": "2020-10-06T22:58:16Z", "type": "commit"}, {"oid": "6b9e237c5b753fac69d2989ea5ade6c8ce759cf1", "url": "https://github.com/apache/kafka/commit/6b9e237c5b753fac69d2989ea5ade6c8ce759cf1", "message": "Minor cosmetic changes", "committedDate": "2020-10-06T22:58:16Z", "type": "commit"}, {"oid": "c2772a1196e0beb18c1581b43573e23b7a22a284", "url": "https://github.com/apache/kafka/commit/c2772a1196e0beb18c1581b43573e23b7a22a284", "message": "Address comments from Boyang", "committedDate": "2020-10-06T22:58:16Z", "type": "commit"}, {"oid": "7620c8803aeaebaeedc6a3ebbb4e94594397cbea", "url": "https://github.com/apache/kafka/commit/7620c8803aeaebaeedc6a3ebbb4e94594397cbea", "message": "Minor: Remove newline", "committedDate": "2020-10-06T22:58:16Z", "type": "commit"}, {"oid": "89372badb529d88219ff5035ebb590a9efcae70a", "url": "https://github.com/apache/kafka/commit/89372badb529d88219ff5035ebb590a9efcae70a", "message": "Minor: cosmetics", "committedDate": "2020-10-06T22:58:16Z", "type": "commit"}, {"oid": "78bfc4c1bdcfb25d9682f9afec36232e2c3ad61f", "url": "https://github.com/apache/kafka/commit/78bfc4c1bdcfb25d9682f9afec36232e2c3ad61f", "message": "Minor: Remove unused imports to fix checkstyle issues", "committedDate": "2020-10-06T22:58:16Z", "type": "commit"}, {"oid": "c3201a10d10fb0916b4dd2fc176f0eb129d0b75e", "url": "https://github.com/apache/kafka/commit/c3201a10d10fb0916b4dd2fc176f0eb129d0b75e", "message": "Minor cosmetics to fix checkstyle issue", "committedDate": "2020-10-06T22:58:16Z", "type": "commit"}, {"oid": "7a7f7168ff44feb92cc82840b2a32b426db859b6", "url": "https://github.com/apache/kafka/commit/7a7f7168ff44feb92cc82840b2a32b426db859b6", "message": "Minor cosmetics", "committedDate": "2020-10-06T22:58:16Z", "type": "commit"}, {"oid": "7afd81b242540f8445c0b399c86a1550d2b8e0d4", "url": "https://github.com/apache/kafka/commit/7afd81b242540f8445c0b399c86a1550d2b8e0d4", "message": "Minor: improve code slightly in KafkaController", "committedDate": "2020-10-06T22:58:16Z", "type": "commit"}, {"oid": "cec250594bcdea3fd0e8d2ee0e4d33f0ae8fca21", "url": "https://github.com/apache/kafka/commit/cec250594bcdea3fd0e8d2ee0e4d33f0ae8fca21", "message": "Address review comments from Boyang", "committedDate": "2020-10-06T22:58:16Z", "type": "commit"}, {"oid": "3b4b370b6f30d760e9395ea3c3f4e3ad7970e0b3", "url": "https://github.com/apache/kafka/commit/3b4b370b6f30d760e9395ea3c3f4e3ad7970e0b3", "message": "Minor cosmetics", "committedDate": "2020-10-06T22:58:16Z", "type": "commit"}, {"oid": "2a1dee2085a3beb7ec9fe811c88f7934518b51d9", "url": "https://github.com/apache/kafka/commit/2a1dee2085a3beb7ec9fe811c88f7934518b51d9", "message": "Minor cosmetics", "committedDate": "2020-10-06T22:58:16Z", "type": "commit"}, {"oid": "a7c32a0ee6eaf045e01981f5b047e2832a74a685", "url": "https://github.com/apache/kafka/commit/a7c32a0ee6eaf045e01981f5b047e2832a74a685", "message": "Address latest review comments", "committedDate": "2020-10-06T22:58:17Z", "type": "commit"}, {"oid": "47297375a0df522a6c70923e2776ddc3dc7b81fd", "url": "https://github.com/apache/kafka/commit/47297375a0df522a6c70923e2776ddc3dc7b81fd", "message": "Fix checkstyle issues for CI", "committedDate": "2020-10-06T22:58:17Z", "type": "commit"}, {"oid": "deaad42a8640d2322d9cc20ba0bd82d43ddfbc64", "url": "https://github.com/apache/kafka/commit/deaad42a8640d2322d9cc20ba0bd82d43ddfbc64", "message": "Small improvements", "committedDate": "2020-10-06T22:58:17Z", "type": "commit"}, {"oid": "21491b233eef172ef29642233ddc15848d32d3a1", "url": "https://github.com/apache/kafka/commit/21491b233eef172ef29642233ddc15848d32d3a1", "message": "Rebase on latest AK trunk", "committedDate": "2020-10-06T22:58:17Z", "type": "commit"}, {"oid": "8ec01e7d089412a190d95ab329256e466c41376e", "url": "https://github.com/apache/kafka/commit/8ec01e7d089412a190d95ab329256e466c41376e", "message": "Fix checkstyle issue", "committedDate": "2020-10-06T22:58:17Z", "type": "commit"}, {"oid": "436d816faff1bdabd7dd4cbde26e0f0303f7f484", "url": "https://github.com/apache/kafka/commit/436d816faff1bdabd7dd4cbde26e0f0303f7f484", "message": "Remove unused code", "committedDate": "2020-10-06T22:58:17Z", "type": "commit"}, {"oid": "1150a1fd9302e2e311ad3118bafab125a88da2d1", "url": "https://github.com/apache/kafka/commit/1150a1fd9302e2e311ad3118bafab125a88da2d1", "message": "Reinstante timeoutMs & change FinalizedFeaturesEpoch to long data type", "committedDate": "2020-10-06T22:58:17Z", "type": "commit"}, {"oid": "45372f3006d668835d96d5e0fb41a04225bc3b4a", "url": "https://github.com/apache/kafka/commit/45372f3006d668835d96d5e0fb41a04225bc3b4a", "message": "Minor improvements", "committedDate": "2020-10-06T22:58:17Z", "type": "commit"}, {"oid": "389b7aaaa60c53dd2e079fc60418187f22524e8a", "url": "https://github.com/apache/kafka/commit/389b7aaaa60c53dd2e079fc60418187f22524e8a", "message": "Cosmetics", "committedDate": "2020-10-06T22:58:17Z", "type": "commit"}, {"oid": "5f3af1873803372dd17ac828a19d7450cffbe0f0", "url": "https://github.com/apache/kafka/commit/5f3af1873803372dd17ac828a19d7450cffbe0f0", "message": "Small improvement", "committedDate": "2020-10-06T22:58:17Z", "type": "commit"}, {"oid": "4d067f9afa67cc4a3c7f592c31f9137c9836d609", "url": "https://github.com/apache/kafka/commit/4d067f9afa67cc4a3c7f592c31f9137c9836d609", "message": "Implement firstActiveVersion", "committedDate": "2020-10-06T22:58:17Z", "type": "commit"}, {"oid": "3342f147a4f9ef3a73f6e9264551519cdcaeb687", "url": "https://github.com/apache/kafka/commit/3342f147a4f9ef3a73f6e9264551519cdcaeb687", "message": "Small doc change", "committedDate": "2020-10-06T22:58:17Z", "type": "commit"}, {"oid": "3c59a17771de6ecbe89a93cc8ab1410e416a93fe", "url": "https://github.com/apache/kafka/commit/3c59a17771de6ecbe89a93cc8ab1410e416a93fe", "message": "Address comments from Jun", "committedDate": "2020-10-06T22:58:18Z", "type": "commit"}, {"oid": "cc378c6dabbf6ae749baaa89f268e3a2ad1fc940", "url": "https://github.com/apache/kafka/commit/cc378c6dabbf6ae749baaa89f268e3a2ad1fc940", "message": "Address comments from Boyang", "committedDate": "2020-10-06T22:58:18Z", "type": "commit"}, {"oid": "116352bcdd0aa9485db59cbd4e36cf7d03c81ffe", "url": "https://github.com/apache/kafka/commit/116352bcdd0aa9485db59cbd4e36cf7d03c81ffe", "message": "Address comments from Jun", "committedDate": "2020-10-06T22:58:18Z", "type": "commit"}, {"oid": "50f53dd4060bd70d0ffd22cf916fcbd359e8db1b", "url": "https://github.com/apache/kafka/commit/50f53dd4060bd70d0ffd22cf916fcbd359e8db1b", "message": "Address comment from Jun: Revert firstActiveVersion change", "committedDate": "2020-10-06T22:58:18Z", "type": "commit"}, {"oid": "0ba831d3fcf0a7b6c3099e87491114fe17d4d634", "url": "https://github.com/apache/kafka/commit/0ba831d3fcf0a7b6c3099e87491114fe17d4d634", "message": "Minor change to code format", "committedDate": "2020-10-06T22:58:18Z", "type": "commit"}, {"oid": "c821e8501793a40e40f461de7c96126840f4a02d", "url": "https://github.com/apache/kafka/commit/c821e8501793a40e40f461de7c96126840f4a02d", "message": "Fix ControllerIntegrationTest", "committedDate": "2020-10-06T22:58:18Z", "type": "commit"}, {"oid": "5e3fc96c48794d80ccaf56e6dfbfdde0c30313c5", "url": "https://github.com/apache/kafka/commit/5e3fc96c48794d80ccaf56e6dfbfdde0c30313c5", "message": "Minor cosmetic changes", "committedDate": "2020-10-06T22:58:18Z", "type": "commit"}, {"oid": "3c5c04f5910c50dd7f3e02b4a1f33c50d42fb43f", "url": "https://github.com/apache/kafka/commit/3c5c04f5910c50dd7f3e02b4a1f33c50d42fb43f", "message": "Address comments from Jun", "committedDate": "2020-10-06T22:58:18Z", "type": "commit"}, {"oid": "b69f7fe3da3b6f7a46480a0902f15db39bd8f946", "url": "https://github.com/apache/kafka/commit/b69f7fe3da3b6f7a46480a0902f15db39bd8f946", "message": "Minor formatting change", "committedDate": "2020-10-06T22:58:18Z", "type": "commit"}, {"oid": "e1c79cee2ab243d95647935d2b3e7abe371bf6ea", "url": "https://github.com/apache/kafka/commit/e1c79cee2ab243d95647935d2b3e7abe371bf6ea", "message": "Address comments from Jun", "committedDate": "2020-10-06T22:58:18Z", "type": "commit"}, {"oid": "e1c79cee2ab243d95647935d2b3e7abe371bf6ea", "url": "https://github.com/apache/kafka/commit/e1c79cee2ab243d95647935d2b3e7abe371bf6ea", "message": "Address comments from Jun", "committedDate": "2020-10-06T22:58:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQxODQ5Ng==", "url": "https://github.com/apache/kafka/pull/9001#discussion_r501418496", "bodyText": "the error message says it can't be null but there is no null check.\nfor another, this check can happen early (when creating updateFutures)", "author": "chia7712", "createdAt": "2020-10-08T02:53:08Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -4335,6 +4343,150 @@ void handleFailure(Throwable throwable) {\n                 .hi(password, salt, iterations);\n     }\n \n+    public DescribeFeaturesResult describeFeatures(final DescribeFeaturesOptions options) {\n+        final KafkaFutureImpl<FeatureMetadata> future = new KafkaFutureImpl<>();\n+        final long now = time.milliseconds();\n+        final NodeProvider provider =\n+            options.sendRequestToController() ? new ControllerNodeProvider() : new LeastLoadedNodeProvider();\n+\n+        final Call call = new Call(\n+            \"describeFeatures\", calcDeadlineMs(now, options.timeoutMs()), provider) {\n+\n+            private FeatureMetadata createFeatureMetadata(final ApiVersionsResponse response) {\n+                final Map<String, FinalizedVersionRange> finalizedFeatures = new HashMap<>();\n+                for (final FinalizedFeatureKey key : response.data().finalizedFeatures().valuesSet()) {\n+                    finalizedFeatures.put(key.name(), new FinalizedVersionRange(key.minVersionLevel(), key.maxVersionLevel()));\n+                }\n+\n+                Optional<Long> finalizedFeaturesEpoch;\n+                if (response.data().finalizedFeaturesEpoch() >= 0L) {\n+                    finalizedFeaturesEpoch = Optional.of(response.data().finalizedFeaturesEpoch());\n+                } else {\n+                    finalizedFeaturesEpoch = Optional.empty();\n+                }\n+\n+                final Map<String, SupportedVersionRange> supportedFeatures = new HashMap<>();\n+                for (final SupportedFeatureKey key : response.data().supportedFeatures().valuesSet()) {\n+                    supportedFeatures.put(key.name(), new SupportedVersionRange(key.minVersion(), key.maxVersion()));\n+                }\n+\n+                return new FeatureMetadata(finalizedFeatures, finalizedFeaturesEpoch, supportedFeatures);\n+            }\n+\n+            @Override\n+            ApiVersionsRequest.Builder createRequest(int timeoutMs) {\n+                return new ApiVersionsRequest.Builder();\n+            }\n+\n+            @Override\n+            void handleResponse(AbstractResponse response) {\n+                final ApiVersionsResponse apiVersionsResponse = (ApiVersionsResponse) response;\n+                if (apiVersionsResponse.data.errorCode() == Errors.NONE.code()) {\n+                    future.complete(createFeatureMetadata(apiVersionsResponse));\n+                } else if (options.sendRequestToController() &&\n+                           apiVersionsResponse.data.errorCode() == Errors.NOT_CONTROLLER.code()) {\n+                    handleNotControllerError(Errors.NOT_CONTROLLER);\n+                } else {\n+                    future.completeExceptionally(Errors.forCode(apiVersionsResponse.data.errorCode()).exception());\n+                }\n+            }\n+\n+            @Override\n+            void handleFailure(Throwable throwable) {\n+                completeAllExceptionally(Collections.singletonList(future), throwable);\n+            }\n+        };\n+\n+        runnable.call(call, now);\n+        return new DescribeFeaturesResult(future);\n+    }\n+\n+    @Override\n+    public UpdateFeaturesResult updateFeatures(final Map<String, FeatureUpdate> featureUpdates,\n+                                               final UpdateFeaturesOptions options) {\n+        if (featureUpdates.isEmpty()) {\n+            throw new IllegalArgumentException(\"Feature updates can not be null or empty.\");\n+        }\n+\n+        final Map<String, KafkaFutureImpl<Void>> updateFutures = new HashMap<>();\n+        for (final Map.Entry<String, FeatureUpdate> entry : featureUpdates.entrySet()) {\n+            updateFutures.put(entry.getKey(), new KafkaFutureImpl<>());\n+        }\n+\n+        final long now = time.milliseconds();\n+        final Call call = new Call(\"updateFeatures\", calcDeadlineMs(now, options.timeoutMs()),\n+            new ControllerNodeProvider()) {\n+\n+            @Override\n+            UpdateFeaturesRequest.Builder createRequest(int timeoutMs) {\n+                final UpdateFeaturesRequestData.FeatureUpdateKeyCollection featureUpdatesRequestData\n+                    = new UpdateFeaturesRequestData.FeatureUpdateKeyCollection();\n+                for (Map.Entry<String, FeatureUpdate> entry : featureUpdates.entrySet()) {\n+                    final String feature = entry.getKey();\n+                    final FeatureUpdate update = entry.getValue();\n+                    if (feature.trim().isEmpty()) {", "originalCommit": "e1c79cee2ab243d95647935d2b3e7abe371bf6ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU3NTQzMg==", "url": "https://github.com/apache/kafka/pull/9001#discussion_r501575432", "bodyText": "Done. Addressed in #9393.", "author": "kowshik", "createdAt": "2020-10-08T09:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQxODQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQzMjc3MA==", "url": "https://github.com/apache/kafka/pull/9001#discussion_r501432770", "bodyText": "Should we add an empty-parameter variety for describeFeatures? that is similar to other methods, like DescribeUserScramCredentialsResult and describeDelegationToken.", "author": "chia7712", "createdAt": "2020-10-08T03:51:37Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/Admin.java", "diffHunk": "@@ -1306,6 +1307,73 @@ default AlterUserScramCredentialsResult alterUserScramCredentials(List<UserScram\n     AlterUserScramCredentialsResult alterUserScramCredentials(List<UserScramCredentialAlteration> alterations,\n                                                               AlterUserScramCredentialsOptions options);\n \n+    /**\n+     * Describes finalized as well as supported features. By default, the request is issued to any\n+     * broker. It can be optionally directed only to the controller via DescribeFeaturesOptions\n+     * parameter. This is particularly useful if the user requires strongly consistent reads of\n+     * finalized features.\n+     * <p>\n+     * The following exceptions can be anticipated when calling {@code get()} on the future from the\n+     * returned {@link DescribeFeaturesResult}:\n+     * <ul>\n+     *   <li>{@link org.apache.kafka.common.errors.TimeoutException}\n+     *   If the request timed out before the describe operation could finish.</li>\n+     * </ul>\n+     * <p>\n+     * @param options   the options to use\n+     *\n+     * @return          the {@link DescribeFeaturesResult} containing the result\n+     */\n+    DescribeFeaturesResult describeFeatures(DescribeFeaturesOptions options);", "originalCommit": "e1c79cee2ab243d95647935d2b3e7abe371bf6ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU3NTQ4OQ==", "url": "https://github.com/apache/kafka/pull/9001#discussion_r501575489", "bodyText": "Done. Addressed in #9393.", "author": "kowshik", "createdAt": "2020-10-08T09:26:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQzMjc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ4OTA2MA==", "url": "https://github.com/apache/kafka/pull/9001#discussion_r501489060", "bodyText": "the top-level error message is not propagated.", "author": "chia7712", "createdAt": "2020-10-08T06:58:43Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -4335,6 +4343,150 @@ void handleFailure(Throwable throwable) {\n                 .hi(password, salt, iterations);\n     }\n \n+    public DescribeFeaturesResult describeFeatures(final DescribeFeaturesOptions options) {\n+        final KafkaFutureImpl<FeatureMetadata> future = new KafkaFutureImpl<>();\n+        final long now = time.milliseconds();\n+        final NodeProvider provider =\n+            options.sendRequestToController() ? new ControllerNodeProvider() : new LeastLoadedNodeProvider();\n+\n+        final Call call = new Call(\n+            \"describeFeatures\", calcDeadlineMs(now, options.timeoutMs()), provider) {\n+\n+            private FeatureMetadata createFeatureMetadata(final ApiVersionsResponse response) {\n+                final Map<String, FinalizedVersionRange> finalizedFeatures = new HashMap<>();\n+                for (final FinalizedFeatureKey key : response.data().finalizedFeatures().valuesSet()) {\n+                    finalizedFeatures.put(key.name(), new FinalizedVersionRange(key.minVersionLevel(), key.maxVersionLevel()));\n+                }\n+\n+                Optional<Long> finalizedFeaturesEpoch;\n+                if (response.data().finalizedFeaturesEpoch() >= 0L) {\n+                    finalizedFeaturesEpoch = Optional.of(response.data().finalizedFeaturesEpoch());\n+                } else {\n+                    finalizedFeaturesEpoch = Optional.empty();\n+                }\n+\n+                final Map<String, SupportedVersionRange> supportedFeatures = new HashMap<>();\n+                for (final SupportedFeatureKey key : response.data().supportedFeatures().valuesSet()) {\n+                    supportedFeatures.put(key.name(), new SupportedVersionRange(key.minVersion(), key.maxVersion()));\n+                }\n+\n+                return new FeatureMetadata(finalizedFeatures, finalizedFeaturesEpoch, supportedFeatures);\n+            }\n+\n+            @Override\n+            ApiVersionsRequest.Builder createRequest(int timeoutMs) {\n+                return new ApiVersionsRequest.Builder();\n+            }\n+\n+            @Override\n+            void handleResponse(AbstractResponse response) {\n+                final ApiVersionsResponse apiVersionsResponse = (ApiVersionsResponse) response;\n+                if (apiVersionsResponse.data.errorCode() == Errors.NONE.code()) {\n+                    future.complete(createFeatureMetadata(apiVersionsResponse));\n+                } else if (options.sendRequestToController() &&\n+                           apiVersionsResponse.data.errorCode() == Errors.NOT_CONTROLLER.code()) {\n+                    handleNotControllerError(Errors.NOT_CONTROLLER);\n+                } else {\n+                    future.completeExceptionally(Errors.forCode(apiVersionsResponse.data.errorCode()).exception());\n+                }\n+            }\n+\n+            @Override\n+            void handleFailure(Throwable throwable) {\n+                completeAllExceptionally(Collections.singletonList(future), throwable);\n+            }\n+        };\n+\n+        runnable.call(call, now);\n+        return new DescribeFeaturesResult(future);\n+    }\n+\n+    @Override\n+    public UpdateFeaturesResult updateFeatures(final Map<String, FeatureUpdate> featureUpdates,\n+                                               final UpdateFeaturesOptions options) {\n+        if (featureUpdates.isEmpty()) {\n+            throw new IllegalArgumentException(\"Feature updates can not be null or empty.\");\n+        }\n+\n+        final Map<String, KafkaFutureImpl<Void>> updateFutures = new HashMap<>();\n+        for (final Map.Entry<String, FeatureUpdate> entry : featureUpdates.entrySet()) {\n+            updateFutures.put(entry.getKey(), new KafkaFutureImpl<>());\n+        }\n+\n+        final long now = time.milliseconds();\n+        final Call call = new Call(\"updateFeatures\", calcDeadlineMs(now, options.timeoutMs()),\n+            new ControllerNodeProvider()) {\n+\n+            @Override\n+            UpdateFeaturesRequest.Builder createRequest(int timeoutMs) {\n+                final UpdateFeaturesRequestData.FeatureUpdateKeyCollection featureUpdatesRequestData\n+                    = new UpdateFeaturesRequestData.FeatureUpdateKeyCollection();\n+                for (Map.Entry<String, FeatureUpdate> entry : featureUpdates.entrySet()) {\n+                    final String feature = entry.getKey();\n+                    final FeatureUpdate update = entry.getValue();\n+                    if (feature.trim().isEmpty()) {\n+                        throw new IllegalArgumentException(\"Provided feature can not be null or empty.\");\n+                    }\n+\n+                    final UpdateFeaturesRequestData.FeatureUpdateKey requestItem =\n+                        new UpdateFeaturesRequestData.FeatureUpdateKey();\n+                    requestItem.setFeature(feature);\n+                    requestItem.setMaxVersionLevel(update.maxVersionLevel());\n+                    requestItem.setAllowDowngrade(update.allowDowngrade());\n+                    featureUpdatesRequestData.add(requestItem);\n+                }\n+                return new UpdateFeaturesRequest.Builder(\n+                    new UpdateFeaturesRequestData()\n+                        .setTimeoutMs(timeoutMs)\n+                        .setFeatureUpdates(featureUpdatesRequestData));\n+            }\n+\n+            @Override\n+            void handleResponse(AbstractResponse abstractResponse) {\n+                final UpdateFeaturesResponse response =\n+                    (UpdateFeaturesResponse) abstractResponse;\n+\n+                Errors topLevelError = Errors.forCode(response.data().errorCode());\n+                switch (topLevelError) {\n+                    case NONE:\n+                        for (final UpdatableFeatureResult result : response.data().results()) {\n+                            final KafkaFutureImpl<Void> future = updateFutures.get(result.feature());\n+                            if (future == null) {\n+                                log.warn(\"Server response mentioned unknown feature {}\", result.feature());\n+                            } else {\n+                                final Errors error = Errors.forCode(result.errorCode());\n+                                if (error == Errors.NONE) {\n+                                    future.complete(null);\n+                                } else {\n+                                    future.completeExceptionally(error.exception(result.errorMessage()));\n+                                }\n+                            }\n+                        }\n+                        // The server should send back a response for every feature, but we do a sanity check anyway.\n+                        completeUnrealizedFutures(updateFutures.entrySet().stream(),\n+                            feature -> \"The controller response did not contain a result for feature \" + feature);\n+                        break;\n+                    case NOT_CONTROLLER:\n+                        handleNotControllerError(topLevelError);\n+                        break;\n+                    default:\n+                        for (final Map.Entry<String, KafkaFutureImpl<Void>> entry : updateFutures.entrySet()) {\n+                            entry.getValue().completeExceptionally(topLevelError.exception());", "originalCommit": "e1c79cee2ab243d95647935d2b3e7abe371bf6ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU3NTUxOQ==", "url": "https://github.com/apache/kafka/pull/9001#discussion_r501575519", "bodyText": "Done. Addressed in #9393.", "author": "kowshik", "createdAt": "2020-10-08T09:26:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ4OTA2MA=="}], "type": "inlineReview"}]}