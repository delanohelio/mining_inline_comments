{"pr_number": 8338, "pr_title": "KAFKA-8890: KIP-519- Make SSL context/engine configuration extensible", "pr_createdAt": "2020-03-24T06:59:51Z", "pr_url": "https://github.com/apache/kafka/pull/8338", "timeline": [{"oid": "0e29088af2f61a5ac91fcefb14576928407c2e45", "url": "https://github.com/apache/kafka/commit/0e29088af2f61a5ac91fcefb14576928407c2e45", "message": "KAFKA-8890: KIP-519- Make SSL context/engine configuration extensible", "committedDate": "2020-03-24T06:29:38Z", "type": "commit"}, {"oid": "0c0f2174fdf2e2869a8323203db0f2b18f2726d3", "url": "https://github.com/apache/kafka/commit/0c0f2174fdf2e2869a8323203db0f2b18f2726d3", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into KAFKA-8890", "committedDate": "2020-03-24T06:56:43Z", "type": "commit"}, {"oid": "f709a4e3b6455c1f0028beb700994b5c62f3e0a0", "url": "https://github.com/apache/kafka/commit/f709a4e3b6455c1f0028beb700994b5c62f3e0a0", "message": "Removing older SslEngineBuilder class", "committedDate": "2020-03-24T17:49:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3ODAyOA==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r399378028", "bodyText": "Please make it possible to load the keystore not from a file but e.g. from a variable. This could be easily done by providing a protected method \"byte[] getKeyStoreContent\" (or similar). The default impl. would read the contents from the file. But I caould subclass the default impl. and just use a property set from outside.\nThe same applies for the truststore.", "author": "fml2", "createdAt": "2020-03-27T16:11:35Z", "path": "clients/src/main/java/org/apache/kafka/common/security/ssl/DefaultSslEngineFactory.java", "diffHunk": "@@ -281,7 +295,7 @@ public boolean shouldBeRebuilt(Map<String, Object> nextConfigs) {\n          * @throws KafkaException if the file could not be read or if the keystore could not be loaded\n          *   using the specified configs (e.g. if the password or keystore type is invalid)\n          */\n-        KeyStore load() {\n+        private KeyStore load() {\n             try (InputStream in = Files.newInputStream(Paths.get(path))) {", "originalCommit": "f709a4e3b6455c1f0028beb700994b5c62f3e0a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc1NzU4Ng==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r402757586", "bodyText": "@fml2 Currently the DefaultSslEngineFactory class is 'final' so you won't be able to override. I wrote my custom implementation for our needs for SslEngineFactory, primary reason for the KIP, and it resulted in total of 246 LOC with imports and 213 LOC without imports. I think it is reasonably good to have such a great flexibility with just 200+ LOC. Can you please try writing your custom impl (may be just by copying DefaultSslEngineFactory to start with) and see if it serves your needs? I completely agree that there will be duplicate code for your custom implementation but unless we get enough convincing case on making some methods overridable it is better to keep it the way it is.", "author": "maulin-vasavada", "createdAt": "2020-04-03T06:15:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3ODAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk0MjQxMA==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r402942410", "bodyText": "@maulin-vasavada Do you know the reason for making the class final? What is the rationale? Why make the developer's life harder than it is? :-)", "author": "fml2", "createdAt": "2020-04-03T11:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3ODAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM0NzI4Mw==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404347283", "bodyText": "@fml2 Your requirements are byte[], somebody else might require PEM format string. Sometimes you could have List<X509..cert> objects for Truststore etc. Due to various formats it is not easy to generalize it in a way which will fit every possible use-case if we expose the extension the way you are suggesting. Ultimately it is all byte[] but the formats matter.", "author": "maulin-vasavada", "createdAt": "2020-04-06T19:51:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3ODAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM3MDcwMw==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404370703", "bodyText": "Sure, the format matters. If I need a very custom loading routine then I'd reimplement the whole SslEngineFactory. But if I have a plain scenario (I bet it occurs quite often) that I have a standard keystore from the JDK but the application runs in a read only container then it would be a natural enhancement point to let the deployer specify the keystore contents via property. This does not prevent complex cases from being implemented and makes simple situations easy to implement. Having to work with files is a big limitation IMO.\nUpdate: I think I only understand your objection because of PEM format etc. I should have explained my idea better.\nI do NOT propose to introduce a property of type byte[]. My proposal is as follows.\nIn DefaultSslEngineFactory.java\nIntroduce a protected method with an implementation like this:\nprotected byte[] getKeyStoreContents() {\n    // Read and return the bytes from the path specified in the config\n}\n\nThen use this method when loading the keystore (in the load() method):\nInputStream in = new ByteArrayInputStream(getKeyStoreContents())\nThus, the DefaultSslEngineFactory fully retains its functionality (and even becomes better testable because now the getKeyStoreContents method can be mocked if necessary).\nIn my custom implementation I'd do the following:\npublic MyCustomImpl extends DefaultSslEngineFactory {\n    private String keystoreContents; // E.g. in PEM format or... Require here whatever format you like\n\n@Override\nprotected byte[] getKeyStoreContents() {\n   // Decode the property 'keystoreContents' according to the appropriate rules and return the bytes\n}\n\nNow I can provide the contents in a format I like. It could be a PEM string, a base64 string etc. It could be multiple properties, if needed. The main thing is that I'm able to produce the byte contents out of them.", "author": "fml2", "createdAt": "2020-04-06T20:33:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3ODAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY3ODE3OA==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404678178", "bodyText": "DefaultSslEngineFactory is an internal class. We don't encourage extending this for custom implementations since there is no guarantee that we won't change it in future. For custom implementations of SslEngineFactory, it would be better to rely on the interface.", "author": "rajinisivaram", "createdAt": "2020-04-07T09:44:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3ODAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzMDQzOQ==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r405130439", "bodyText": "OK, I see. But it's a pity I have to write/copy more than 200 lines of code to just have a functionality many systems (I'm quite sure) need.", "author": "fml2", "createdAt": "2020-04-07T21:41:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3ODAyOA=="}], "type": "inlineReview"}, {"oid": "f24d1566636565c84c10246119f3f78678d77c61", "url": "https://github.com/apache/kafka/commit/f24d1566636565c84c10246119f3f78678d77c61", "message": "Adding documentation for SslEngineFactory#shouldBeRebuilt method", "committedDate": "2020-03-31T05:29:12Z", "type": "commit"}, {"oid": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca", "url": "https://github.com/apache/kafka/commit/7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca", "message": "Update documentation on shouldBeRebuilt() to mention what happens to the existing SSL connections.", "committedDate": "2020-04-03T06:03:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA4ODA2Nw==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404088067", "bodyText": "nit: We can use the class instead of hard-coding classname.", "author": "rajinisivaram", "createdAt": "2020-04-06T13:25:51Z", "path": "clients/src/main/java/org/apache/kafka/common/config/SslConfigs.java", "diffHunk": "@@ -110,6 +110,10 @@\n     public static final String SSL_SECURE_RANDOM_IMPLEMENTATION_CONFIG = \"ssl.secure.random.implementation\";\n     public static final String SSL_SECURE_RANDOM_IMPLEMENTATION_DOC = \"The SecureRandom PRNG implementation to use for SSL cryptography operations. \";\n \n+    public static final String SSL_ENGINE_FACTORY_CLASS_CONFIG = \"ssl.engine.factory.class\";\n+    public static final String DEFAULT_SSL_ENGINE_FACTORY_CLASS = org.apache.kafka.common.security.ssl.DefaultSslEngineFactory.class.getCanonicalName();\n+    public static final String SSL_ENGINE_FACTORY_CLASS_DOC = \"The class of type org.apache.kafka.common.security.auth.SslEngineFactory to provide SSLEngine objects. Default value is \" + DEFAULT_SSL_ENGINE_FACTORY_CLASS;", "originalCommit": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA5MTcyNQ==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404091725", "bodyText": "It says client mode, but this is the server engine.", "author": "rajinisivaram", "createdAt": "2020-04-06T13:31:10Z", "path": "clients/src/main/java/org/apache/kafka/common/security/auth/SslEngineFactory.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.security.auth;\n+\n+import org.apache.kafka.common.Configurable;\n+\n+import javax.net.ssl.SSLEngine;\n+import java.io.Closeable;\n+import java.security.KeyStore;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Plugin interface for allowing creation of SSLEngine object in a custom way.\n+ * Example: You want to use custom way to load your key material and trust material needed for SSLContext.\n+ * However, keep in mind that this is complementary to the existing Java Security Provider's mechanism and not a competing\n+ * solution.\n+ */\n+public interface SslEngineFactory extends Configurable, Closeable {\n+\n+    /**\n+     * Create a new SSLEngine object to be used by the client.\n+     *\n+     * @param peerHost               The peer host to use. This is used in client mode if endpoint validation is enabled.\n+     * @param peerPort               The peer port to use. This is a hint and not used for validation.\n+     * @param endpointIdentification Endpoint identification algorithm for client mode.\n+     * @return The new SSLEngine.\n+     */\n+    SSLEngine createClientSslEngine(String peerHost, int peerPort, String endpointIdentification);\n+\n+    /**\n+     * Create a new SSLEngine object to be used by the server.\n+     *\n+     * @param peerHost               The peer host to use. This is used in client mode if endpoint validation is enabled.", "originalCommit": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA5MzIzNQ==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404093235", "bodyText": "nit: intendation", "author": "rajinisivaram", "createdAt": "2020-04-06T13:33:20Z", "path": "clients/src/main/java/org/apache/kafka/common/security/ssl/DefaultSslEngineFactory.java", "diffHunk": "@@ -104,13 +148,51 @@\n         this.sslContext = createSSLContext();\n     }\n \n+    @Override\n+    public void close() throws IOException {\n+        this.sslContext = null;\n+    }\n+\n+    //For Test only\n+    public SSLContext sslContext() {\n+        return this.sslContext;\n+    }\n+\n+    private SSLEngine createSslEngine(Mode mode, String peerHost, int peerPort, String endpointIdentification) {\n+        SSLEngine sslEngine = sslContext.createSSLEngine(peerHost, peerPort);\n+        if (cipherSuites != null) sslEngine.setEnabledCipherSuites(cipherSuites);\n+        if (enabledProtocols != null) sslEngine.setEnabledProtocols(enabledProtocols);\n+\n+        if (mode == Mode.SERVER) {\n+            sslEngine.setUseClientMode(false);\n+            switch (sslClientAuth) {\n+                case REQUIRED:\n+                    sslEngine.setNeedClientAuth(true);\n+                    break;\n+                case REQUESTED:\n+                    sslEngine.setWantClientAuth(true);\n+                    break;\n+                case NONE:\n+                    break;\n+            }\n+            sslEngine.setUseClientMode(false);\n+        } else {\n+            sslEngine.setUseClientMode(true);\n+            SSLParameters sslParams = sslEngine.getSSLParameters();\n+            // SSLParameters#setEndpointIdentificationAlgorithm enables endpoint validation\n+            // only in client mode. Hence, validation is enabled only for clients.\n+            sslParams.setEndpointIdentificationAlgorithm(endpointIdentification);\n+            sslEngine.setSSLParameters(sslParams);\n+        }\n+        return sslEngine;\n+    }\n     private static SslClientAuth createSslClientAuth(String key) {\n         SslClientAuth auth = SslClientAuth.forConfig(key);\n         if (auth != null) {\n             return auth;\n         }\n         log.warn(\"Unrecognized client authentication configuration {}.  Falling \" +\n-                \"back to NONE.  Recognized client authentication configurations are {}.\",\n+                        \"back to NONE.  Recognized client authentication configurations are {}.\",", "originalCommit": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwNzYwNA==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404107604", "bodyText": "Could just do  Map<String, Object> nextConfigs = new HashMap<>(configs);?", "author": "rajinisivaram", "createdAt": "2020-04-06T13:52:59Z", "path": "clients/src/main/java/org/apache/kafka/common/security/ssl/SslFactory.java", "diffHunk": "@@ -80,19 +80,17 @@ public SslFactory(Mode mode,\n \n     @Override\n     public void configure(Map<String, ?> configs) throws KafkaException {\n-        if (sslEngineBuilder != null) {\n+        if (sslEngineFactory != null) {\n             throw new IllegalStateException(\"SslFactory was already configured.\");\n         }\n         this.endpointIdentification = (String) configs.get(SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG);\n \n         Map<String, Object> nextConfigs = new HashMap<>();\n-        copyMapEntries(nextConfigs, configs, SslConfigs.NON_RECONFIGURABLE_CONFIGS);\n-        copyMapEntries(nextConfigs, configs, SslConfigs.RECONFIGURABLE_CONFIGS);\n-        copyMapEntry(nextConfigs, configs, SecurityConfig.SECURITY_PROVIDERS_CONFIG);\n+        copyAllConfigs(nextConfigs, configs);", "originalCommit": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwODc3MQ==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404108771", "bodyText": "As mentioned earlier, this can be removed if we just create the map with existing values.", "author": "rajinisivaram", "createdAt": "2020-04-06T13:54:28Z", "path": "clients/src/main/java/org/apache/kafka/common/security/ssl/SslFactory.java", "diffHunk": "@@ -101,88 +99,110 @@ public void configure(Map<String, ?> configs) throws KafkaException {\n                         \"can't connect to a server SSLEngine created with those settings.\", e);\n             }\n         }\n-        this.sslEngineBuilder = builder;\n+        this.sslEngineFactory = builder;\n     }\n \n     @Override\n     public Set<String> reconfigurableConfigs() {\n-        return SslConfigs.RECONFIGURABLE_CONFIGS;\n+        return sslEngineFactory.reconfigurableConfigs();\n     }\n \n     @Override\n     public void validateReconfiguration(Map<String, ?> newConfigs) {\n-        createNewSslEngineBuilder(newConfigs);\n+        createNewSslEngineFactory(newConfigs);\n     }\n \n     @Override\n     public void reconfigure(Map<String, ?> newConfigs) throws KafkaException {\n-        SslEngineBuilder newSslEngineBuilder = createNewSslEngineBuilder(newConfigs);\n-        if (newSslEngineBuilder != this.sslEngineBuilder) {\n-            this.sslEngineBuilder = newSslEngineBuilder;\n+        SslEngineFactory newSslEngineFactory = createNewSslEngineFactory(newConfigs);\n+        if (newSslEngineFactory != this.sslEngineFactory) {\n+            this.sslEngineFactory = newSslEngineFactory;\n             log.info(\"Created new {} SSL engine builder with keystore {} truststore {}\", mode,\n-                    newSslEngineBuilder.keystore(), newSslEngineBuilder.truststore());\n+                    newSslEngineFactory.keystore(), newSslEngineFactory.truststore());\n         }\n     }\n \n-    private SslEngineBuilder createNewSslEngineBuilder(Map<String, ?> newConfigs) {\n-        if (sslEngineBuilder == null) {\n+    private SslEngineFactory instantiateSslEngineFactory(Map<String, Object> configs) {\n+        @SuppressWarnings(\"unchecked\")\n+        Class<? extends SslEngineFactory> sslEngineFactoryClass =\n+                (Class<? extends SslEngineFactory>) configs.get(SslConfigs.SSL_ENGINE_FACTORY_CLASS_CONFIG);\n+        SslEngineFactory sslEngineFactory = Utils.newInstance(sslEngineFactoryClass);\n+        sslEngineFactory.configure(configs);\n+        this.sslEngineFactoryConfig = configs;\n+        return sslEngineFactory;\n+    }\n+\n+    private SslEngineFactory createNewSslEngineFactory(Map<String, ?> newConfigs) {\n+        if (sslEngineFactory == null) {\n             throw new IllegalStateException(\"SslFactory has not been configured.\");\n         }\n-        Map<String, Object> nextConfigs = new HashMap<>(sslEngineBuilder.configs());\n-        copyMapEntries(nextConfigs, newConfigs, SslConfigs.RECONFIGURABLE_CONFIGS);\n+        Map<String, Object> nextConfigs = new HashMap<>(sslEngineFactoryConfig);\n+        copyMapEntries(nextConfigs, newConfigs, reconfigurableConfigs());\n         if (clientAuthConfigOverride != null) {\n             nextConfigs.put(BrokerSecurityConfigs.SSL_CLIENT_AUTH_CONFIG, clientAuthConfigOverride);\n         }\n-        if (!sslEngineBuilder.shouldBeRebuilt(nextConfigs)) {\n-            return sslEngineBuilder;\n+        if (!sslEngineFactory.shouldBeRebuilt(nextConfigs)) {\n+            return sslEngineFactory;\n         }\n         try {\n-            SslEngineBuilder newSslEngineBuilder = new SslEngineBuilder(nextConfigs);\n-            if (sslEngineBuilder.keystore() == null) {\n-                if (newSslEngineBuilder.keystore() != null) {\n+            SslEngineFactory newSslEngineFactory = instantiateSslEngineFactory(nextConfigs);\n+            if (sslEngineFactory.keystore() == null) {\n+                if (newSslEngineFactory.keystore() != null) {\n                     throw new ConfigException(\"Cannot add SSL keystore to an existing listener for \" +\n                             \"which no keystore was configured.\");\n                 }\n             } else {\n-                if (newSslEngineBuilder.keystore() == null) {\n+                if (newSslEngineFactory.keystore() == null) {\n                     throw new ConfigException(\"Cannot remove the SSL keystore from an existing listener for \" +\n                             \"which a keystore was configured.\");\n                 }\n-                if (!CertificateEntries.create(sslEngineBuilder.keystore().load()).equals(\n-                        CertificateEntries.create(newSslEngineBuilder.keystore().load()))) {\n+                if (!CertificateEntries.create(sslEngineFactory.keystore()).equals(\n+                        CertificateEntries.create(newSslEngineFactory.keystore()))) {\n                     throw new ConfigException(\"Keystore DistinguishedName or SubjectAltNames do not match\");\n                 }\n             }\n-            if (sslEngineBuilder.truststore() == null && newSslEngineBuilder.truststore() != null) {\n+            if (sslEngineFactory.truststore() == null && newSslEngineFactory.truststore() != null) {\n                 throw new ConfigException(\"Cannot add SSL truststore to an existing listener for which no \" +\n                         \"truststore was configured.\");\n             }\n             if (keystoreVerifiableUsingTruststore) {\n-                if (sslEngineBuilder.truststore() != null || sslEngineBuilder.keystore() != null) {\n-                    SslEngineValidator.validate(sslEngineBuilder, newSslEngineBuilder);\n+                if (sslEngineFactory.truststore() != null || sslEngineFactory.keystore() != null) {\n+                    SslEngineValidator.validate(sslEngineFactory, newSslEngineFactory);\n                 }\n             }\n-            return newSslEngineBuilder;\n+            return newSslEngineFactory;\n         } catch (Exception e) {\n             log.debug(\"Validation of dynamic config update of SSLFactory failed.\", e);\n             throw new ConfigException(\"Validation of dynamic config update of SSLFactory failed: \" + e);\n         }\n     }\n \n     public SSLEngine createSslEngine(String peerHost, int peerPort) {\n-        if (sslEngineBuilder == null) {\n+        if (sslEngineFactory == null) {\n             throw new IllegalStateException(\"SslFactory has not been configured.\");\n         }\n-        return sslEngineBuilder.createSslEngine(mode, peerHost, peerPort, endpointIdentification);\n+        if (mode == Mode.SERVER) {\n+            return sslEngineFactory.createServerSslEngine(peerHost, peerPort);\n+        } else {\n+            return sslEngineFactory.createClientSslEngine(peerHost, peerPort, endpointIdentification);\n+        }\n     }\n \n-    @Deprecated\n-    public SSLContext sslContext() {\n-        return sslEngineBuilder.sslContext();\n+    public SslEngineFactory sslEngineFactory() {\n+        return sslEngineFactory;\n     }\n \n-    public SslEngineBuilder sslEngineBuilder() {\n-        return sslEngineBuilder;\n+    /**\n+     * Copy all entries from one map into another.\n+     *\n+     * @param destMap   The map to copy entries into.\n+     * @param srcMap    The map to copy entries from.\n+     */\n+    private static void copyAllConfigs(Map<String, Object> destMap,", "originalCommit": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwOTgyOA==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404109828", "bodyText": "Why have we removed this code?", "author": "rajinisivaram", "createdAt": "2020-04-06T13:55:36Z", "path": "clients/src/main/java/org/apache/kafka/common/security/ssl/SslFactory.java", "diffHunk": "@@ -318,8 +342,6 @@ void handshake(SslEngineValidator peerValidator) throws SSLException {\n             while (true) {\n                 switch (handshakeStatus) {\n                     case NEED_WRAP:\n-                        if (netBuffer.position() != 0) // Wait for peer to consume previously wrapped data\n-                            return;", "originalCommit": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4Mjg2OA==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404282868", "bodyText": "I didn't intend to. Let me check if it is because of pull from trunk.", "author": "maulin-vasavada", "createdAt": "2020-04-06T17:58:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwOTgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMyODc0OA==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404328748", "bodyText": "Okay, found it - looks like this was introduced as part of TLSv1.3 changes and when I picked up from trunk it didn't pick this up. Will fix it now.", "author": "maulin-vasavada", "createdAt": "2020-04-06T19:16:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwOTgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDExNDIxNw==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404114217", "bodyText": "We don't use star imports in Java classes", "author": "rajinisivaram", "createdAt": "2020-04-06T14:01:10Z", "path": "log4j-appender/src/main/java/org/apache/kafka/log4jappender/KafkaLog4jAppender.java", "diffHunk": "@@ -43,12 +43,8 @@\n import static org.apache.kafka.clients.CommonClientConfigs.SECURITY_PROTOCOL_CONFIG;\n import static org.apache.kafka.common.config.SaslConfigs.SASL_JAAS_CONFIG;\n import static org.apache.kafka.common.config.SaslConfigs.SASL_MECHANISM;\n-import static org.apache.kafka.common.config.SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG;\n-import static org.apache.kafka.common.config.SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG;\n-import static org.apache.kafka.common.config.SslConfigs.SSL_KEYSTORE_TYPE_CONFIG;\n-import static org.apache.kafka.common.config.SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG;\n-import static org.apache.kafka.common.config.SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG;\n import static org.apache.kafka.common.config.SaslConfigs.SASL_KERBEROS_SERVICE_NAME;\n+import static org.apache.kafka.common.config.SslConfigs.*;", "originalCommit": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NTA4NA==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404385084", "bodyText": "For other class configs, we set null as the default and just use the default class the config is not overridden. I think we should do the same here and in KafkaConfig where this config is defined.", "author": "rajinisivaram", "createdAt": "2020-04-06T21:00:24Z", "path": "clients/src/main/java/org/apache/kafka/common/config/SslConfigs.java", "diffHunk": "@@ -136,7 +140,8 @@ public static void addClientSslSupport(ConfigDef config) {\n                 .define(SslConfigs.SSL_KEYMANAGER_ALGORITHM_CONFIG, ConfigDef.Type.STRING, SslConfigs.DEFAULT_SSL_KEYMANGER_ALGORITHM, ConfigDef.Importance.LOW, SslConfigs.SSL_KEYMANAGER_ALGORITHM_DOC)\n                 .define(SslConfigs.SSL_TRUSTMANAGER_ALGORITHM_CONFIG, ConfigDef.Type.STRING, SslConfigs.DEFAULT_SSL_TRUSTMANAGER_ALGORITHM, ConfigDef.Importance.LOW, SslConfigs.SSL_TRUSTMANAGER_ALGORITHM_DOC)\n                 .define(SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG, ConfigDef.Type.STRING, SslConfigs.DEFAULT_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM, ConfigDef.Importance.LOW, SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_DOC)\n-                .define(SslConfigs.SSL_SECURE_RANDOM_IMPLEMENTATION_CONFIG, ConfigDef.Type.STRING, null, ConfigDef.Importance.LOW, SslConfigs.SSL_SECURE_RANDOM_IMPLEMENTATION_DOC);\n+                .define(SslConfigs.SSL_SECURE_RANDOM_IMPLEMENTATION_CONFIG, ConfigDef.Type.STRING, null, ConfigDef.Importance.LOW, SslConfigs.SSL_SECURE_RANDOM_IMPLEMENTATION_DOC)\n+                .define(SslConfigs.SSL_ENGINE_FACTORY_CLASS_CONFIG, ConfigDef.Type.CLASS, DEFAULT_SSL_ENGINE_FACTORY_CLASS, ConfigDef.Importance.LOW, SslConfigs.SSL_ENGINE_FACTORY_CLASS_DOC);", "originalCommit": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "35f77790963921929b3e2acc3b5a877af9cb846a", "url": "https://github.com/apache/kafka/commit/35f77790963921929b3e2acc3b5a877af9cb846a", "message": "Addressing most of the review comments so far except changing the default value for the ssl.engine.factory to be of Class type due to ~2000 test failures it results into", "committedDate": "2020-04-06T22:01:47Z", "type": "commit"}, {"oid": "bf6aea4b2d941ca5cb4050eba4e28ddc1aaf0240", "url": "https://github.com/apache/kafka/commit/bf6aea4b2d941ca5cb4050eba4e28ddc1aaf0240", "message": "Moving default for ssl.engine.factory to code", "committedDate": "2020-04-07T04:06:48Z", "type": "commit"}, {"oid": "abc889d82f3a2cee3a5596982a50adc1e753f75a", "url": "https://github.com/apache/kafka/commit/abc889d82f3a2cee3a5596982a50adc1e753f75a", "message": "Removing unused import in AclAuthorizer", "committedDate": "2020-04-07T04:09:40Z", "type": "commit"}, {"oid": "bf08ed8b8a508d28fbff97a74b5b6ac7e44b4a0d", "url": "https://github.com/apache/kafka/commit/bf08ed8b8a508d28fbff97a74b5b6ac7e44b4a0d", "message": "Adding tests for verifying custom ssl.engine.factory class", "committedDate": "2020-04-07T06:56:13Z", "type": "commit"}, {"oid": "cc498bb8bef9fe7857074a1f0258e3cb0b69fc83", "url": "https://github.com/apache/kafka/commit/cc498bb8bef9fe7857074a1f0258e3cb0b69fc83", "message": "Merge from trunk", "committedDate": "2020-04-07T07:53:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY3NDY1Ng==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404674656", "bodyText": "We could probably move this into TestSslUtils instead of duplicating in two tests.", "author": "rajinisivaram", "createdAt": "2020-04-07T09:39:17Z", "path": "clients/src/test/java/org/apache/kafka/common/security/ssl/SslFactoryTest.java", "diffHunk": "@@ -379,4 +431,49 @@ public void testCertificateEntriesValidation() throws Exception {\n     private TestSslUtils.SslConfigsBuilder sslConfigsBuilder(Mode mode) {\n         return new TestSslUtils.SslConfigsBuilder(mode).tlsProtocol(tlsProtocol);\n     }\n+\n+    public static final class TestSslEngineFactory implements SslEngineFactory {", "originalCommit": "cc498bb8bef9fe7857074a1f0258e3cb0b69fc83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAzNjkyMA==", "url": "https://github.com/apache/kafka/pull/8338#discussion_r405036920", "bodyText": "Done", "author": "maulin-vasavada", "createdAt": "2020-04-07T18:50:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY3NDY1Ng=="}], "type": "inlineReview"}, {"oid": "6e8dfd0438ac0cf0b655f665abb73938a5e8acfe", "url": "https://github.com/apache/kafka/commit/6e8dfd0438ac0cf0b655f665abb73938a5e8acfe", "message": "Moving TestSslEngineFactory to common TestSslUtils", "committedDate": "2020-04-07T18:49:22Z", "type": "commit"}, {"oid": "47dd951dfe7166a103c258958332238a5e7e0265", "url": "https://github.com/apache/kafka/commit/47dd951dfe7166a103c258958332238a5e7e0265", "message": "Removing unused imports from test class", "committedDate": "2020-04-07T19:07:39Z", "type": "commit"}, {"oid": "15e6ec5575bf5f55d1f81c2ec738f25282f153ad", "url": "https://github.com/apache/kafka/commit/15e6ec5575bf5f55d1f81c2ec738f25282f153ad", "message": "Fixing checkstyle in KafkaLog4JAppender", "committedDate": "2020-04-08T00:30:28Z", "type": "commit"}]}