{"pr_number": 9780, "pr_title": "KAFKA-10021: Changed Kafka backing stores to use shared admin client to get end offsets and create topics", "pr_createdAt": "2020-12-22T19:00:59Z", "pr_url": "https://github.com/apache/kafka/pull/9780", "timeline": [{"oid": "d0fa4da1ba5973ae82de0eb2f16c86cbb8dfbd0b", "url": "https://github.com/apache/kafka/commit/d0fa4da1ba5973ae82de0eb2f16c86cbb8dfbd0b", "message": "KAFKA-10021: Changed Kafka backing stores to use shared admin client to get end offsets and create topics\n\nThe existing `Kafka*BackingStore` classes used by Connect all use `KafkaBasedLog`, which needs to frequently get the end offsets for the internal topic to know whether they are caught up. `KafkaBasedLog` uses its consumer to get the end offsets and to consume the records from the topic.\n\nHowever, the Connect internal topics are often written very infrequently. This means that when the `KafkaBasedLog` used in the `Kafka*BackingStore` classes is already caught up and its last consumer poll is waiting for new records to appear, the call to the consumer to fetch end offsets will block until the consumer returns after a new record is written (unlikely) or the consumer\u2019s `fetch.max.wait.ms` setting (defaults to 500ms) ends and the consumer returns no more records. IOW, the call to `KafkaBasedLog.readToEnd()` may block for some period of time even though it\u2019s already caught up to the end.\n\nInstead, we want the `KafkaBasedLog.readToEnd()` to always return quickly when the log is already caught up. The best way to do this is to have the `KafkaBackingStore` use the admin client (rather than the consumer) to fetch end offsets for the internal topic. The consumer and the admin API both use the same `ListOffset` broker API, so the functionality is ultimately the same but we don't have to block for any ongoing consumer activity.\n\nEach Connect distributed runtime includes three instances of the `Kafka*BackingStore` classes, which means we have three instances of `KafkaBasedLog`. We don't want three instances of the admin client, and should have all three instances of the `KafkaBasedLog` share a single admin client instance. In fact, each `Kafka*BackingStore` instance currently creates, uses and closes an admin client instance when it checks and initializes that store's internal topic. If we change `Kafka*BackingStores` to share one admin client instance, we can change that initialization logic to also reuse the supplied admin client instance.\n\nThe final challenge is that `KafkaBasedLog` has been used by projects outside of Apache Kafka. While `KafkaBasedLog` is definitely not in the public API for Connect, we can make these changes in ways that are backward compatible: create new constructors and deprecate the old constructors. Connect can be changed to only use the new constructors, and this will give time for any downstream users to make changes.\n\nThese changes are implemented as follows:\n1. Add a `KafkaBasedLog` constructor to accept in its parameters a supplier from which it can get an admin instance, and deprecate the old constructor. We need a supplier rather than just passing an instance because `KafkaBasedLog` is instantiated before Connect starts up, so we need to create the admin instance only when needed. At the same time, we'll change the existing init function parameter from a no-arg function to accept an admin instance as an argument, allowing that init function to reuse the shared admin instance used by the `KafkaBasedLog`. Note: if no admin supplier is provided (in deprecated constructor that is no longer used in AK), the consumer is still used to get latest offsets.\n2. Add to the `Kafka*BackingStore` classes a new constructor with the same parameters but with an admin supplier, and deprecate the old constructor. When the classes instantiate its `KafkaBasedLog` instance, it would pass the admin supplier and pass an init function that takes an admin instance.\n3. Create a new `SharedTopicAdmin` that lazily creates the `TopicAdmin` (and underlying Admin client) when required, and closes the admin objects when the `SharedTopicAdmin` is closed.\n4. Modify the existing `TopicAdmin` (used only in Connect) to encapsulate the logic of fetching end offsets using the admin client, simplifying the logic in `KafkaBasedLog` mentioned in #1 above. Doing this also makes it easier to test that logic.\n5. Change `ConnectDistributed` to create a `SharedTopicAdmin` instance (that is `AutoCloseable`) before creating the `Kafka*BackingStore` instances, passing the `SharedTopicAdmin` (which is an admin supplier) to all three `Kafka*BackingStore objects`, and finally always closing the `SharedTopicAdmin` upon termination. (Shutdown of the worker occurs outside of the `ConnectDistributed` code, so modify `DistributedHerder` to take in its constructor additional `AutoCloseable` objects that should be closed when the herder is closed, and then modify `ConnectDistributed` to pass the `SharedTopicAdmin` as one of those `AutoCloseable` instances.)\n6. Change `MirrorMaker` similarly to `ConnectDistributed`.\n7. Change existing unit tests to no longer use deprecated constructors.\n8. Add unit tests for new functionality.", "committedDate": "2020-12-22T20:39:39Z", "type": "forcePushed"}, {"oid": "1f098220d5c31c5a65f5ef18961ecfade20b1f37", "url": "https://github.com/apache/kafka/commit/1f098220d5c31c5a65f5ef18961ecfade20b1f37", "message": "KAFKA-10021: Changed Kafka backing stores to use shared admin client to get end offsets and create topics\n\nThe existing `Kafka*BackingStore` classes used by Connect all use `KafkaBasedLog`, which needs to frequently get the end offsets for the internal topic to know whether they are caught up. `KafkaBasedLog` uses its consumer to get the end offsets and to consume the records from the topic.\n\nHowever, the Connect internal topics are often written very infrequently. This means that when the `KafkaBasedLog` used in the `Kafka*BackingStore` classes is already caught up and its last consumer poll is waiting for new records to appear, the call to the consumer to fetch end offsets will block until the consumer returns after a new record is written (unlikely) or the consumer\u2019s `fetch.max.wait.ms` setting (defaults to 500ms) ends and the consumer returns no more records. IOW, the call to `KafkaBasedLog.readToEnd()` may block for some period of time even though it\u2019s already caught up to the end.\n\nInstead, we want the `KafkaBasedLog.readToEnd()` to always return quickly when the log is already caught up. The best way to do this is to have the `KafkaBackingStore` use the admin client (rather than the consumer) to fetch end offsets for the internal topic. The consumer and the admin API both use the same `ListOffset` broker API, so the functionality is ultimately the same but we don't have to block for any ongoing consumer activity.\n\nEach Connect distributed runtime includes three instances of the `Kafka*BackingStore` classes, which means we have three instances of `KafkaBasedLog`. We don't want three instances of the admin client, and should have all three instances of the `KafkaBasedLog` share a single admin client instance. In fact, each `Kafka*BackingStore` instance currently creates, uses and closes an admin client instance when it checks and initializes that store's internal topic. If we change `Kafka*BackingStores` to share one admin client instance, we can change that initialization logic to also reuse the supplied admin client instance.\n\nThe final challenge is that `KafkaBasedLog` has been used by projects outside of Apache Kafka. While `KafkaBasedLog` is definitely not in the public API for Connect, we can make these changes in ways that are backward compatible: create new constructors and deprecate the old constructors. Connect can be changed to only use the new constructors, and this will give time for any downstream users to make changes.\n\nThese changes are implemented as follows:\n1. Add a `KafkaBasedLog` constructor to accept in its parameters a supplier from which it can get an admin instance, and deprecate the old constructor. We need a supplier rather than just passing an instance because `KafkaBasedLog` is instantiated before Connect starts up, so we need to create the admin instance only when needed. At the same time, we'll change the existing init function parameter from a no-arg function to accept an admin instance as an argument, allowing that init function to reuse the shared admin instance used by the `KafkaBasedLog`. Note: if no admin supplier is provided (in deprecated constructor that is no longer used in AK), the consumer is still used to get latest offsets.\n2. Add to the `Kafka*BackingStore` classes a new constructor with the same parameters but with an admin supplier, and deprecate the old constructor. When the classes instantiate its `KafkaBasedLog` instance, it would pass the admin supplier and pass an init function that takes an admin instance.\n3. Create a new `SharedTopicAdmin` that lazily creates the `TopicAdmin` (and underlying Admin client) when required, and closes the admin objects when the `SharedTopicAdmin` is closed.\n4. Modify the existing `TopicAdmin` (used only in Connect) to encapsulate the logic of fetching end offsets using the admin client, simplifying the logic in `KafkaBasedLog` mentioned in #1 above. Doing this also makes it easier to test that logic.\n5. Change `ConnectDistributed` to create a `SharedTopicAdmin` instance (that is `AutoCloseable`) before creating the `Kafka*BackingStore` instances, passing the `SharedTopicAdmin` (which is an admin supplier) to all three `Kafka*BackingStore objects`, and finally always closing the `SharedTopicAdmin` upon termination. (Shutdown of the worker occurs outside of the `ConnectDistributed` code, so modify `DistributedHerder` to take in its constructor additional `AutoCloseable` objects that should be closed when the herder is closed, and then modify `ConnectDistributed` to pass the `SharedTopicAdmin` as one of those `AutoCloseable` instances.)\n6. Change `MirrorMaker` similarly to `ConnectDistributed`.\n7. Change existing unit tests to no longer use deprecated constructors.\n8. Add unit tests for new functionality.", "committedDate": "2020-12-23T00:09:46Z", "type": "forcePushed"}, {"oid": "1916a9649ffd680c90f26b8b9839ef280983c8db", "url": "https://github.com/apache/kafka/commit/1916a9649ffd680c90f26b8b9839ef280983c8db", "message": "KAFKA-10021: Changed Kafka backing stores to use shared admin client to get end offsets and create topics\n\nThe existing `Kafka*BackingStore` classes used by Connect all use `KafkaBasedLog`, which needs to frequently get the end offsets for the internal topic to know whether they are caught up. `KafkaBasedLog` uses its consumer to get the end offsets and to consume the records from the topic.\n\nHowever, the Connect internal topics are often written very infrequently. This means that when the `KafkaBasedLog` used in the `Kafka*BackingStore` classes is already caught up and its last consumer poll is waiting for new records to appear, the call to the consumer to fetch end offsets will block until the consumer returns after a new record is written (unlikely) or the consumer\u2019s `fetch.max.wait.ms` setting (defaults to 500ms) ends and the consumer returns no more records. IOW, the call to `KafkaBasedLog.readToEnd()` may block for some period of time even though it\u2019s already caught up to the end.\n\nInstead, we want the `KafkaBasedLog.readToEnd()` to always return quickly when the log is already caught up. The best way to do this is to have the `KafkaBackingStore` use the admin client (rather than the consumer) to fetch end offsets for the internal topic. The consumer and the admin API both use the same `ListOffset` broker API, so the functionality is ultimately the same but we don't have to block for any ongoing consumer activity.\n\nEach Connect distributed runtime includes three instances of the `Kafka*BackingStore` classes, which means we have three instances of `KafkaBasedLog`. We don't want three instances of the admin client, and should have all three instances of the `KafkaBasedLog` share a single admin client instance. In fact, each `Kafka*BackingStore` instance currently creates, uses and closes an admin client instance when it checks and initializes that store's internal topic. If we change `Kafka*BackingStores` to share one admin client instance, we can change that initialization logic to also reuse the supplied admin client instance.\n\nThe final challenge is that `KafkaBasedLog` has been used by projects outside of Apache Kafka. While `KafkaBasedLog` is definitely not in the public API for Connect, we can make these changes in ways that are backward compatible: create new constructors and deprecate the old constructors. Connect can be changed to only use the new constructors, and this will give time for any downstream users to make changes.\n\nThese changes are implemented as follows:\n1. Add a `KafkaBasedLog` constructor to accept in its parameters a supplier from which it can get an admin instance, and deprecate the old constructor. We need a supplier rather than just passing an instance because `KafkaBasedLog` is instantiated before Connect starts up, so we need to create the admin instance only when needed. At the same time, we'll change the existing init function parameter from a no-arg function to accept an admin instance as an argument, allowing that init function to reuse the shared admin instance used by the `KafkaBasedLog`. Note: if no admin supplier is provided (in deprecated constructor that is no longer used in AK), the consumer is still used to get latest offsets.\n2. Add to the `Kafka*BackingStore` classes a new constructor with the same parameters but with an admin supplier, and deprecate the old constructor. When the classes instantiate its `KafkaBasedLog` instance, it would pass the admin supplier and pass an init function that takes an admin instance.\n3. Create a new `SharedTopicAdmin` that lazily creates the `TopicAdmin` (and underlying Admin client) when required, and closes the admin objects when the `SharedTopicAdmin` is closed.\n4. Modify the existing `TopicAdmin` (used only in Connect) to encapsulate the logic of fetching end offsets using the admin client, simplifying the logic in `KafkaBasedLog` mentioned in #1 above. Doing this also makes it easier to test that logic.\n5. Change `ConnectDistributed` to create a `SharedTopicAdmin` instance (that is `AutoCloseable`) before creating the `Kafka*BackingStore` instances, passing the `SharedTopicAdmin` (which is an admin supplier) to all three `Kafka*BackingStore objects`, and finally always closing the `SharedTopicAdmin` upon termination. (Shutdown of the worker occurs outside of the `ConnectDistributed` code, so modify `DistributedHerder` to take in its constructor additional `AutoCloseable` objects that should be closed when the herder is closed, and then modify `ConnectDistributed` to pass the `SharedTopicAdmin` as one of those `AutoCloseable` instances.)\n6. Change `MirrorMaker` similarly to `ConnectDistributed`.\n7. Change existing unit tests to no longer use deprecated constructors.\n8. Add unit tests for new functionality.", "committedDate": "2021-02-04T16:24:37Z", "type": "forcePushed"}, {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17", "url": "https://github.com/apache/kafka/commit/acbe90c6e6198de3626598f14c2b172c05106f17", "message": "KAFKA-10021: Changed Kafka backing stores to use shared admin client to get end offsets and create topics\n\nThe existing `Kafka*BackingStore` classes used by Connect all use `KafkaBasedLog`, which needs to frequently get the end offsets for the internal topic to know whether they are caught up. `KafkaBasedLog` uses its consumer to get the end offsets and to consume the records from the topic.\n\nHowever, the Connect internal topics are often written very infrequently. This means that when the `KafkaBasedLog` used in the `Kafka*BackingStore` classes is already caught up and its last consumer poll is waiting for new records to appear, the call to the consumer to fetch end offsets will block until the consumer returns after a new record is written (unlikely) or the consumer\u2019s `fetch.max.wait.ms` setting (defaults to 500ms) ends and the consumer returns no more records. IOW, the call to `KafkaBasedLog.readToEnd()` may block for some period of time even though it\u2019s already caught up to the end.\n\nInstead, we want the `KafkaBasedLog.readToEnd()` to always return quickly when the log is already caught up. The best way to do this is to have the `KafkaBackingStore` use the admin client (rather than the consumer) to fetch end offsets for the internal topic. The consumer and the admin API both use the same `ListOffset` broker API, so the functionality is ultimately the same but we don't have to block for any ongoing consumer activity.\n\nEach Connect distributed runtime includes three instances of the `Kafka*BackingStore` classes, which means we have three instances of `KafkaBasedLog`. We don't want three instances of the admin client, and should have all three instances of the `KafkaBasedLog` share a single admin client instance. In fact, each `Kafka*BackingStore` instance currently creates, uses and closes an admin client instance when it checks and initializes that store's internal topic. If we change `Kafka*BackingStores` to share one admin client instance, we can change that initialization logic to also reuse the supplied admin client instance.\n\nThe final challenge is that `KafkaBasedLog` has been used by projects outside of Apache Kafka. While `KafkaBasedLog` is definitely not in the public API for Connect, we can make these changes in ways that are backward compatible: create new constructors and deprecate the old constructors. Connect can be changed to only use the new constructors, and this will give time for any downstream users to make changes.\n\nThese changes are implemented as follows:\n1. Add a `KafkaBasedLog` constructor to accept in its parameters a supplier from which it can get an admin instance, and deprecate the old constructor. We need a supplier rather than just passing an instance because `KafkaBasedLog` is instantiated before Connect starts up, so we need to create the admin instance only when needed. At the same time, we'll change the existing init function parameter from a no-arg function to accept an admin instance as an argument, allowing that init function to reuse the shared admin instance used by the `KafkaBasedLog`. Note: if no admin supplier is provided (in deprecated constructor that is no longer used in AK), the consumer is still used to get latest offsets.\n2. Add to the `Kafka*BackingStore` classes a new constructor with the same parameters but with an admin supplier, and deprecate the old constructor. When the classes instantiate its `KafkaBasedLog` instance, it would pass the admin supplier and pass an init function that takes an admin instance.\n3. Create a new `SharedTopicAdmin` that lazily creates the `TopicAdmin` (and underlying Admin client) when required, and closes the admin objects when the `SharedTopicAdmin` is closed.\n4. Modify the existing `TopicAdmin` (used only in Connect) to encapsulate the logic of fetching end offsets using the admin client, simplifying the logic in `KafkaBasedLog` mentioned in #1 above. Doing this also makes it easier to test that logic.\n5. Change `ConnectDistributed` to create a `SharedTopicAdmin` instance (that is `AutoCloseable`) before creating the `Kafka*BackingStore` instances, passing the `SharedTopicAdmin` (which is an admin supplier) to all three `Kafka*BackingStore objects`, and finally always closing the `SharedTopicAdmin` upon termination. (Shutdown of the worker occurs outside of the `ConnectDistributed` code, so modify `DistributedHerder` to take in its constructor additional `AutoCloseable` objects that should be closed when the herder is closed, and then modify `ConnectDistributed` to pass the `SharedTopicAdmin` as one of those `AutoCloseable` instances.)\n6. Change `MirrorMaker` similarly to `ConnectDistributed`.\n7. Change existing unit tests to no longer use deprecated constructors.\n8. Add unit tests for new functionality.", "committedDate": "2021-02-04T17:45:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4MzkxMg==", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570583912", "bodyText": "I think it's better to avoid a variadic argument here.\nParameters tend to get added with new features in such constructors. And if a new parameter is required that is also a list, then we'll have a mix of list args with a variadic in the end.\nSince we transform to list I'd suggest using this type here and pass the single argument with Collections.singletonList in the caller.", "author": "kkonstantine", "createdAt": "2021-02-04T22:21:02Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java", "diffHunk": "@@ -185,16 +188,33 @@\n \n     private final DistributedConfig config;\n \n+    /**\n+     * Create a herder that will form a Connect cluster with other {@link DistributedHerder} instances (in this or other JVMs)\n+     * that have the same group ID.\n+     *\n+     * @param config             the configuration for the worker; may not be null\n+     * @param time               the clock to use; may not be null\n+     * @param worker             the {@link Worker} instance to use; may not be null\n+     * @param kafkaClusterId     the identifier of the Kafka cluster to use for internal topics; may not be null\n+     * @param statusBackingStore the backing store for statuses; may not be null\n+     * @param configBackingStore the backing store for connector configurations; may not be null\n+     * @param restUrl            the URL of this herder's REST API; may not be null\n+     * @param connectorClientConfigOverridePolicy the policy specifying the client configuration properties that may be overridden\n+     *                                            in connector configurations; may not be null\n+     * @param uponShutdown       any {@link AutoCloseable} objects that should be closed when this herder is {@link #stop() stopped},\n+     *                           after all services and resources owned by this herder are stopped\n+     */\n     public DistributedHerder(DistributedConfig config,\n                              Time time,\n                              Worker worker,\n                              String kafkaClusterId,\n                              StatusBackingStore statusBackingStore,\n                              ConfigBackingStore configBackingStore,\n                              String restUrl,\n-                             ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy) {\n+                             ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy,\n+                             AutoCloseable... uponShutdown) {", "originalCommit": "acbe90c6e6198de3626598f14c2b172c05106f17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY0ODU1Ng==", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570648556", "bodyText": "The reason I used a variadic array here was to avoid having to create a new connector when no AutoCloseable instances are supplied. If we use a List, then we can change the usage in Connect runtime and in MirrorMaker 2, but anywhere else will break without keeping the old signature. WDYT?", "author": "rhauch", "createdAt": "2021-02-05T00:56:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4MzkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDczMjU2NQ==", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570732565", "bodyText": "We can always keep a constructor with the old signature along with the new if we wanted not to break classes that use DistributedHerder. I'm fine with the change here as a short term workaround. I guess it saves us one constructor but we can use it only once.", "author": "kkonstantine", "createdAt": "2021-02-05T05:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4MzkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4NDAzNg==", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570584036", "bodyText": "see comment above", "author": "kkonstantine", "createdAt": "2021-02-04T22:21:16Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java", "diffHunk": "@@ -209,7 +229,8 @@ public DistributedHerder(DistributedConfig config,\n                       String restUrl,\n                       ConnectMetrics metrics,\n                       Time time,\n-                      ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy) {\n+                      ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy,\n+                      AutoCloseable... uponShutdown) {", "originalCommit": "acbe90c6e6198de3626598f14c2b172c05106f17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4NDEzMw==", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570584133", "bodyText": "nit: extra", "author": "kkonstantine", "createdAt": "2021-02-04T22:21:28Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java", "diffHunk": "@@ -676,6 +698,16 @@ public void halt() {\n         }\n     }\n \n+    @Override\n+    protected void stopServices() {\n+        try {\n+            super.stopServices();\n+        } finally {\n+            this.uponShutdown.stream().forEach(closeable -> Utils.closeQuietly(closeable, closeable != null ? closeable.toString() : \"<unknown>\"));\n+        }\n+", "originalCommit": "acbe90c6e6198de3626598f14c2b172c05106f17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4NDQyMQ==", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570584421", "bodyText": "I'd guess stream().forEach can be simplified with forEach only", "author": "kkonstantine", "createdAt": "2021-02-04T22:22:03Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java", "diffHunk": "@@ -676,6 +698,16 @@ public void halt() {\n         }\n     }\n \n+    @Override\n+    protected void stopServices() {\n+        try {\n+            super.stopServices();\n+        } finally {\n+            this.uponShutdown.stream().forEach(closeable -> Utils.closeQuietly(closeable, closeable != null ? closeable.toString() : \"<unknown>\"));", "originalCommit": "acbe90c6e6198de3626598f14c2b172c05106f17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4OTU3Mg==", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570589572", "bodyText": "see comment above. We'll avoid the array static init too. Tests here but still that's where array lists come handy", "author": "kkonstantine", "createdAt": "2021-02-04T22:32:17Z", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/distributed/DistributedHerderTest.java", "diffHunk": "@@ -207,14 +209,16 @@ public void setUp() throws Exception {\n         metrics = new MockConnectMetrics(time);\n         worker = PowerMock.createMock(Worker.class);\n         EasyMock.expect(worker.isSinkConnector(CONN1)).andStubReturn(Boolean.TRUE);\n+        AutoCloseable uponShutdown = () -> shutdownCalled.countDown();\n \n         // Default to the old protocol unless specified otherwise\n         connectProtocolVersion = CONNECT_PROTOCOL_V0;\n \n         herder = PowerMock.createPartialMock(DistributedHerder.class,\n                 new String[]{\"connectorTypeForClass\", \"updateDeletedConnectorStatus\", \"updateDeletedTaskStatus\", \"validateConnectorConfig\"},\n                 new DistributedConfig(HERDER_CONFIG), worker, WORKER_ID, KAFKA_CLUSTER_ID,\n-                statusBackingStore, configBackingStore, member, MEMBER_URL, metrics, time, noneConnectorClientConfigOverridePolicy);\n+                statusBackingStore, configBackingStore, member, MEMBER_URL, metrics, time, noneConnectorClientConfigOverridePolicy,\n+                new AutoCloseable[]{uponShutdown});", "originalCommit": "acbe90c6e6198de3626598f14c2b172c05106f17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5MDExNw==", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570590117", "bodyText": "should we call it EMPTY_CONFIG since it won't change?", "author": "kkonstantine", "createdAt": "2021-02-04T22:33:26Z", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/util/SharedTopicAdminTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.connect.util;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import org.apache.kafka.connect.errors.ConnectException;\n+import org.easymock.EasyMock;\n+import org.easymock.Mock;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.powermock.api.easymock.PowerMock;\n+import org.powermock.core.classloader.annotations.PowerMockIgnore;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest(KafkaBasedLog.class)\n+@PowerMockIgnore(\"javax.management.*\")\n+public class SharedTopicAdminTest {\n+\n+    private static final Map<String, Object> CONFIG = Collections.emptyMap();", "originalCommit": "acbe90c6e6198de3626598f14c2b172c05106f17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5MjEyNg==", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570592126", "bodyText": "Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that?\nReplay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.", "author": "kkonstantine", "createdAt": "2021-02-04T22:37:31Z", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/util/SharedTopicAdminTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.connect.util;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import org.apache.kafka.connect.errors.ConnectException;\n+import org.easymock.EasyMock;\n+import org.easymock.Mock;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.powermock.api.easymock.PowerMock;\n+import org.powermock.core.classloader.annotations.PowerMockIgnore;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest(KafkaBasedLog.class)\n+@PowerMockIgnore(\"javax.management.*\")\n+public class SharedTopicAdminTest {\n+\n+    private static final Map<String, Object> CONFIG = Collections.emptyMap();\n+\n+    @Mock private TopicAdmin mockTopicAdmin;\n+    private SharedTopicAdmin sharedAdmin;\n+    private int created = 0;", "originalCommit": "acbe90c6e6198de3626598f14c2b172c05106f17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY1NTAwOA==", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570655008", "bodyText": "Really I'm just using that to be able to test that the new topicAdmin() method is returning the correct instance, even after repeated calls. It was an easy way to verify that the TopicAdmin matches what the factory function returned.", "author": "rhauch", "createdAt": "2021-02-05T01:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5MjEyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDc0NzI1OA==", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570747258", "bodyText": "I know. It's just that we already use a mocking framework and we could use something like:\nEasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();\nif we also defined factory to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.", "author": "kkonstantine", "createdAt": "2021-02-05T06:28:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5MjEyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjI1NjM5Mg==", "url": "https://github.com/apache/kafka/pull/9780#discussion_r572256392", "bodyText": "I vaguely remember struggling with getting EasyMock to work properly when I originally created this PR, but I tried it again just to be sure.\nUnfortunately, the SharedTopicAdmin constructor takes a method reference, and apparently EasyMock provides no way to effectively mock the behavior of a method passed via a method reference. See this still-open EasyMock issue for details.\nSo, while I agree using mocks to verify the # of times the factor is invoked, because EasyMock can't really mock method references means we're stuck with the current code using the counter.", "author": "rhauch", "createdAt": "2021-02-08T18:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5MjEyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjQyMTc3MQ==", "url": "https://github.com/apache/kafka/pull/9780#discussion_r572421771", "bodyText": "Okay, Mockito FTW! I've rewritten the SharedTopicAdminTest class to use Mockito instead of PowerMock and EasyMock, and was able to use mocks to assert the correct number of times an admin instance was created and closed.", "author": "rhauch", "createdAt": "2021-02-08T22:27:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5MjEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5NTcxMA==", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570595710", "bodyText": "curious, what is the array symbolizing here now?\nWe used to have 1 value. Is this ISR nodes? Do we even need to add or remove any?", "author": "kkonstantine", "createdAt": "2021-02-04T22:44:55Z", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/util/TopicAdminTest.java", "diffHunk": "@@ -457,17 +465,273 @@ public void verifyingGettingTopicCleanupPolicies() {\n         }\n     }\n \n+    @Test\n+    public void endOffsetsShouldFailWithNonRetriableWhenAuthorizationFailureOccurs() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        Long offset = null; // response should use error\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithClusterAuthorizationException(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            ConnectException e = assertThrows(ConnectException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"Not authorized to get the end offsets\"));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldFailWithNonRetriableWhenVersionUnsupportedErrorOccurs() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        Long offset = null; // response should use error\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithUnsupportedVersion(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            ConnectException e = assertThrows(ConnectException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"is unsupported on brokers\"));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldFailWithRetriableWhenTimeoutErrorOccurs() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        Long offset = null; // response should use error\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithTimeout(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            RetriableException e = assertThrows(RetriableException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"Timed out while waiting\"));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldFailWithNonRetriableWhenUnknownErrorOccurs() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        Long offset = null; // response should use error\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithUnknownError(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            ConnectException e = assertThrows(ConnectException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"Error while getting end offsets for topic\"));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldReturnEmptyMapWhenPartitionsSetIsNull() {\n+        String topicName = \"myTopic\";\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            Map<TopicPartition, Long> offsets = admin.endOffsets(Collections.emptySet());\n+            assertTrue(offsets.isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldReturnOffsetsForOnePartition() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        long offset = 1000L;\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResult(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            Map<TopicPartition, Long> offsets = admin.endOffsets(tps);\n+            assertEquals(1, offsets.size());\n+            assertEquals(Long.valueOf(offset), offsets.get(tp1));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldReturnOffsetsForMultiplePartitions() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        TopicPartition tp2 = new TopicPartition(topicName, 1);\n+        Set<TopicPartition> tps = new HashSet<>(Arrays.asList(tp1, tp2));\n+        long offset1 = 1001;\n+        long offset2 = 1002;\n+        Cluster cluster = createCluster(1, topicName, 2);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResult(tp1, offset1, tp2, offset2));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            Map<TopicPartition, Long> offsets = admin.endOffsets(tps);\n+            assertEquals(2, offsets.size());\n+            assertEquals(Long.valueOf(offset1), offsets.get(tp1));\n+            assertEquals(Long.valueOf(offset2), offsets.get(tp2));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldFailWhenAnyTopicPartitionHasError() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        long offset = 1000;\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithClusterAuthorizationException(tp1, null));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            ConnectException e = assertThrows(ConnectException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"Not authorized to get the end offsets\"));\n+        }\n+    }\n+\n     private Cluster createCluster(int numNodes) {\n+        return createCluster(numNodes, \"unused\", 0);\n+    }\n+\n+    private Cluster createCluster(int numNodes, String topicName, int partitions) {\n+        Node[] nodeArray = new Node[numNodes];", "originalCommit": "acbe90c6e6198de3626598f14c2b172c05106f17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY1Mjc5MQ==", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570652791", "bodyText": "Yes, these are just the ISRs for the one partition that we set up the cluster with.\nThe utility method did allow multiple nodes, but we don't really use that much in this class. I think this changed because we now have to define the PartitionInfo instances rather than an empty map. Not sure why that's now different, but supplying the empty infos definitely caused problems in these new tests.", "author": "rhauch", "createdAt": "2021-02-05T01:09:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5NTcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDYwMTkyNg==", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570601926", "bodyText": "It's not immediately obvious to me what's the advantage compared to a synchronized topicAdmin or even get.\nI see that the value can go back to null. But we already have the guard with the closed to atomically decide whether this is closed or not. Lmk if I'm missing something, but I feel the points of indirection might be a few more than they have to be here (we have no gains in locking, since we'll need to atomically updateAndGet in every get and the advantage vs synchronized should be negligible here).", "author": "kkonstantine", "createdAt": "2021-02-04T22:57:35Z", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/SharedTopicAdmin.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.connect.util;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.function.UnaryOperator;\n+\n+import org.apache.kafka.clients.admin.AdminClientConfig;\n+import org.apache.kafka.connect.errors.ConnectException;\n+\n+/**\n+ * A holder of a {@link TopicAdmin} object that is lazily and atomically created when needed by multiple callers.\n+ * As soon as one of the getters is called, all getters will return the same shared {@link TopicAdmin}\n+ * instance until this SharedAdmin is closed via {@link #close()} or {@link #close(Duration)}.\n+ *\n+ * <p>The owner of this object is responsible for ensuring that either {@link #close()} or {@link #close(Duration)}\n+ * is called when the {@link TopicAdmin} instance is no longer needed. Consequently, once this\n+ * {@link SharedTopicAdmin} instance has been closed, the {@link #get()} and {@link #topicAdmin()} methods,\n+ * nor any previously returned {@link TopicAdmin} instances may be used.\n+ *\n+ * <p>This class is thread-safe. It also appears as immutable to callers that obtain the {@link TopicAdmin} object,\n+ * until this object is closed, at which point it cannot be used anymore\n+ */\n+public class SharedTopicAdmin implements AutoCloseable, Supplier<TopicAdmin> {\n+\n+    // Visible for testing\n+    static final Duration DEFAULT_CLOSE_DURATION = Duration.ofMillis(Long.MAX_VALUE);\n+\n+    private final Map<String, Object> adminProps;\n+    private final AtomicReference<TopicAdmin> admin = new AtomicReference<>();\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final Function<Map<String, Object>, TopicAdmin> factory;\n+\n+    public SharedTopicAdmin(Map<String, Object> adminProps) {\n+        this(adminProps, TopicAdmin::new);\n+    }\n+\n+    // Visible for testing\n+    SharedTopicAdmin(Map<String, Object> adminProps, Function<Map<String, Object>, TopicAdmin> factory) {\n+        this.adminProps = Objects.requireNonNull(adminProps);\n+        this.factory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Get the shared {@link TopicAdmin} instance.\n+     *\n+     * @return the shared instance; never null\n+     * @throws ConnectException if this object has already been closed\n+     */\n+    @Override\n+    public TopicAdmin get() {\n+        return topicAdmin();\n+    }\n+\n+    /**\n+     * Get the shared {@link TopicAdmin} instance.\n+     *\n+     * @return the shared instance; never null\n+     * @throws ConnectException if this object has already been closed\n+     */\n+    public TopicAdmin topicAdmin() {\n+        return admin.updateAndGet(this::createAdmin);", "originalCommit": "acbe90c6e6198de3626598f14c2b172c05106f17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY1NzAyOA==", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570657028", "bodyText": "I'm not sure there is much advantage either way, considering these methods are not called frequently and synchronized would indeed work. I personally like the simplicity of using AtomicReference, which to me seemed natural and straightforward, avoided having to synchronize the entire methods, and needed no if-checks in this method.", "author": "rhauch", "createdAt": "2021-02-05T01:22:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDYwMTkyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDcyODkwNg==", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570728906", "bodyText": "I'm happy to leave it as an example of the pattern that demonstrates how to apply updateAndGet.\nI just didn't feel that the two or three levels of indirection were worth to write the singleton pattern differently.", "author": "kkonstantine", "createdAt": "2021-02-05T05:27:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDYwMTkyNg=="}], "type": "inlineReview"}, {"oid": "ec727a5c8b5c801ab7cc8f43379da924ff9f912c", "url": "https://github.com/apache/kafka/commit/ec727a5c8b5c801ab7cc8f43379da924ff9f912c", "message": "KAFKA-10021: Changed Kafka backing stores to use shared admin client to get end offsets and create topics\n\nThe existing `Kafka*BackingStore` classes used by Connect all use `KafkaBasedLog`, which needs to frequently get the end offsets for the internal topic to know whether they are caught up. `KafkaBasedLog` uses its consumer to get the end offsets and to consume the records from the topic.\n\nHowever, the Connect internal topics are often written very infrequently. This means that when the `KafkaBasedLog` used in the `Kafka*BackingStore` classes is already caught up and its last consumer poll is waiting for new records to appear, the call to the consumer to fetch end offsets will block until the consumer returns after a new record is written (unlikely) or the consumer\u2019s `fetch.max.wait.ms` setting (defaults to 500ms) ends and the consumer returns no more records. IOW, the call to `KafkaBasedLog.readToEnd()` may block for some period of time even though it\u2019s already caught up to the end.\n\nInstead, we want the `KafkaBasedLog.readToEnd()` to always return quickly when the log is already caught up. The best way to do this is to have the `KafkaBackingStore` use the admin client (rather than the consumer) to fetch end offsets for the internal topic. The consumer and the admin API both use the same `ListOffset` broker API, so the functionality is ultimately the same but we don't have to block for any ongoing consumer activity.\n\nEach Connect distributed runtime includes three instances of the `Kafka*BackingStore` classes, which means we have three instances of `KafkaBasedLog`. We don't want three instances of the admin client, and should have all three instances of the `KafkaBasedLog` share a single admin client instance. In fact, each `Kafka*BackingStore` instance currently creates, uses and closes an admin client instance when it checks and initializes that store's internal topic. If we change `Kafka*BackingStores` to share one admin client instance, we can change that initialization logic to also reuse the supplied admin client instance.\n\nThe final challenge is that `KafkaBasedLog` has been used by projects outside of Apache Kafka. While `KafkaBasedLog` is definitely not in the public API for Connect, we can make these changes in ways that are backward compatible: create new constructors and deprecate the old constructors. Connect can be changed to only use the new constructors, and this will give time for any downstream users to make changes.\n\nThese changes are implemented as follows:\n1. Add a `KafkaBasedLog` constructor to accept in its parameters a supplier from which it can get an admin instance, and deprecate the old constructor. We need a supplier rather than just passing an instance because `KafkaBasedLog` is instantiated before Connect starts up, so we need to create the admin instance only when needed. At the same time, we'll change the existing init function parameter from a no-arg function to accept an admin instance as an argument, allowing that init function to reuse the shared admin instance used by the `KafkaBasedLog`. Note: if no admin supplier is provided (in deprecated constructor that is no longer used in AK), the consumer is still used to get latest offsets.\n2. Add to the `Kafka*BackingStore` classes a new constructor with the same parameters but with an admin supplier, and deprecate the old constructor. When the classes instantiate its `KafkaBasedLog` instance, it would pass the admin supplier and pass an init function that takes an admin instance.\n3. Create a new `SharedTopicAdmin` that lazily creates the `TopicAdmin` (and underlying Admin client) when required, and closes the admin objects when the `SharedTopicAdmin` is closed.\n4. Modify the existing `TopicAdmin` (used only in Connect) to encapsulate the logic of fetching end offsets using the admin client, simplifying the logic in `KafkaBasedLog` mentioned in #1 above. Doing this also makes it easier to test that logic.\n5. Change `ConnectDistributed` to create a `SharedTopicAdmin` instance (that is `AutoCloseable`) before creating the `Kafka*BackingStore` instances, passing the `SharedTopicAdmin` (which is an admin supplier) to all three `Kafka*BackingStore objects`, and finally always closing the `SharedTopicAdmin` upon termination. (Shutdown of the worker occurs outside of the `ConnectDistributed` code, so modify `DistributedHerder` to take in its constructor additional `AutoCloseable` objects that should be closed when the herder is closed, and then modify `ConnectDistributed` to pass the `SharedTopicAdmin` as one of those `AutoCloseable` instances.)\n6. Change `MirrorMaker` similarly to `ConnectDistributed`.\n7. Change existing unit tests to no longer use deprecated constructors.\n8. Add unit tests for new functionality.", "committedDate": "2021-02-08T17:55:41Z", "type": "commit"}, {"oid": "14546ef5bce131d9af87c5744842bb6a794a2181", "url": "https://github.com/apache/kafka/commit/14546ef5bce131d9af87c5744842bb6a794a2181", "message": "Incorporate suggestions from code review", "committedDate": "2021-02-08T17:55:44Z", "type": "commit"}, {"oid": "14546ef5bce131d9af87c5744842bb6a794a2181", "url": "https://github.com/apache/kafka/commit/14546ef5bce131d9af87c5744842bb6a794a2181", "message": "Incorporate suggestions from code review", "committedDate": "2021-02-08T17:55:44Z", "type": "forcePushed"}, {"oid": "86b2c92bea3e992447169f8e0277ffad71c24b95", "url": "https://github.com/apache/kafka/commit/86b2c92bea3e992447169f8e0277ffad71c24b95", "message": "Changed test case to use Mockito", "committedDate": "2021-02-08T22:26:06Z", "type": "commit"}, {"oid": "54a3f10bc7be899cb47c6500d51ff2cec3e1e572", "url": "https://github.com/apache/kafka/commit/54a3f10bc7be899cb47c6500d51ff2cec3e1e572", "message": "Correct unchecked conversion in new unit test", "committedDate": "2021-02-09T07:47:51Z", "type": "commit"}]}