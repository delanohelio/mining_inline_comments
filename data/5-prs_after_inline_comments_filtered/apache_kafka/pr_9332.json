{"pr_number": 9332, "pr_title": "KAFKA-10511; Ensure monotonic start epoch/offset updates in `MockLog`", "pr_createdAt": "2020-09-24T00:10:39Z", "pr_url": "https://github.com/apache/kafka/pull/9332", "timeline": [{"oid": "14e0cab5e335b2619d8f17c999aac6a1c648b465", "url": "https://github.com/apache/kafka/commit/14e0cab5e335b2619d8f17c999aac6a1c648b465", "message": "KAFKA-10511; Ensure monotonic start epoch/offset updates in `MockLog`", "committedDate": "2020-09-23T23:53:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA2MjM0OQ==", "url": "https://github.com/apache/kafka/pull/9332#discussion_r494062349", "bodyText": "So the idea is to wipe out the older epoch (as epoch - 1)'s end offset, and the search for (epoch - 1) would give (epoch - 2) end offset? In the case where we put leader change message in mock log, this should never happen right?", "author": "abbccdda", "createdAt": "2020-09-24T06:15:50Z", "path": "raft/src/test/java/org/apache/kafka/raft/MockLog.java", "diffHunk": "@@ -310,10 +310,10 @@ public LogFetchInfo read(long startOffset, Isolation isolation) {\n     }\n \n     @Override\n-    public void assignEpochStartOffset(int epoch, long startOffset) {\n-        if (startOffset != endOffset().offset)\n-            throw new IllegalArgumentException(\n-                \"Can only assign epoch for the end offset \" + endOffset().offset + \", but get offset \" + startOffset);\n+    public void initializeLeaderEpoch(int epoch) {\n+        long startOffset = endOffset().offset;\n+        epochStartOffsets.removeIf(epochStartOffset ->", "originalCommit": "14e0cab5e335b2619d8f17c999aac6a1c648b465", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5NDMyNw==", "url": "https://github.com/apache/kafka/pull/9332#discussion_r494494327", "bodyText": "There's no guarantee that the leader change message ever gets committed. It is even possible for the leadership to change multiple times before a leader change message can be committed. There is no correctness problem with the current implementation. I just wanted the behavior to be consistent with LeaderEpochFileCache.", "author": "hachikuji", "createdAt": "2020-09-24T17:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA2MjM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA2MjY3Ng==", "url": "https://github.com/apache/kafka/pull/9332#discussion_r494062676", "bodyText": "I thought this is a test for end offset?", "author": "abbccdda", "createdAt": "2020-09-24T06:16:46Z", "path": "raft/src/test/java/org/apache/kafka/raft/MockLogTest.java", "diffHunk": "@@ -370,6 +365,23 @@ public void testReadOutOfRangeOffset() {\n             Isolation.UNCOMMITTED));\n     }\n \n+    @Test\n+    public void testMonotonicEpochStartOffset() {\n+        appendBatch(5, 1);\n+        assertEquals(5L, log.endOffset().offset);\n+\n+        log.initializeLeaderEpoch(2);\n+        assertEquals(Optional.of(new OffsetAndEpoch(5L, 1)), log.endOffsetForEpoch(1));\n+        assertEquals(Optional.of(new OffsetAndEpoch(5L, 2)), log.endOffsetForEpoch(2));\n+\n+        // Initialize a new epoch at the same end offset. The epoch cache ensures\n+        // that the start offset of each retained epoch increases monotonically.", "originalCommit": "14e0cab5e335b2619d8f17c999aac6a1c648b465", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5NDc5Nw==", "url": "https://github.com/apache/kafka/pull/9332#discussion_r494494797", "bodyText": "The epoch cache tracks tuples of (epoch, start offset). The start offset of a new leader epoch is the current log end offset.", "author": "hachikuji", "createdAt": "2020-09-24T17:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA2MjY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA2MzQ4NA==", "url": "https://github.com/apache/kafka/pull/9332#discussion_r494063484", "bodyText": "So the reason that this is safe is because we no longer try assigning offset other than the end offset?", "author": "abbccdda", "createdAt": "2020-09-24T06:19:00Z", "path": "raft/src/test/java/org/apache/kafka/raft/RaftEventSimulationTest.java", "diffHunk": "@@ -712,11 +712,6 @@ void initializeElection(ElectionState election) {\n \n             nodes.values().forEach(state -> {\n                 state.store.writeElectionState(election);\n-                if (election.hasLeader()) {", "originalCommit": "14e0cab5e335b2619d8f17c999aac6a1c648b465", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5ODc0MQ==", "url": "https://github.com/apache/kafka/pull/9332#discussion_r494498741", "bodyText": "Oh, I think this was just unnecessary. The purpose of this logic is to initialize a certain election state prior to starting the simulation. But the code already initializes the epoch state on startup, so we didn't need this.", "author": "hachikuji", "createdAt": "2020-09-24T17:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA2MzQ4NA=="}], "type": "inlineReview"}]}