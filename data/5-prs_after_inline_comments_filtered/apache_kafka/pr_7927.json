{"pr_number": 7927, "pr_title": "KAFKA-9294: Add tests for Named parameter", "pr_createdAt": "2020-01-10T01:16:33Z", "pr_url": "https://github.com/apache/kafka/pull/7927", "timeline": [{"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da", "url": "https://github.com/apache/kafka/commit/0b54aaa0b587b31dacb84d171d6e472d9fa7a6da", "message": "KAFKA-9294: Add tests for Named parameter\n\nPart (2) -- stateful KStream operators", "committedDate": "2020-01-10T01:13:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTM2MA==", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035360", "bodyText": "renamed selector to keySelector", "author": "mjsax", "createdAt": "2020-01-10T01:17:08Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -875,192 +875,192 @@ void to(final TopicNameExtractor<K, V> topicExtractor,\n             final Produced<K, V> produced);\n \n     /**\n-     * Group the records by their current key into a {@link KGroupedStream} while preserving the original values\n+     * Group the records of this {@code KStream} on a new key that is selected using the provided {@link KeyValueMapper}\n      * and default serializers and deserializers.\n      * {@link KGroupedStream} can be further grouped with other streams to form a {@link CogroupedKStream}.\n      * Grouping a stream on the record key is required before an aggregation operator can be applied to the data\n      * (cf. {@link KGroupedStream}).\n-     * If a record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}.\n+     * The {@link KeyValueMapper} selects a new key (which may or may not be of the same type) while preserving the\n+     * original values.\n+     * If the new record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}\n      * <p>\n-     * If a key changing operator was used before this operation (e.g., {@link #selectKey(KeyValueMapper)},\n-     * {@link #map(KeyValueMapper)}, {@link #flatMap(KeyValueMapper)}, or\n-     * {@link #transform(TransformerSupplier, String...)}), and no data redistribution happened afterwards (e.g., via\n-     * {@link #through(String)}) an internal repartitioning topic may need to be created in Kafka if a later\n-     * operator depends on the newly selected key.\n+     * Because a new key is selected, an internal repartitioning topic may need to be created in Kafka if a\n+     * later operator depends on the newly selected key.\n      * This topic will be named \"${applicationId}-&lt;name&gt;-repartition\", where \"applicationId\" is user-specified in\n      * {@link StreamsConfig} via parameter {@link StreamsConfig#APPLICATION_ID_CONFIG APPLICATION_ID_CONFIG},\n      * \"&lt;name&gt;\" is an internally generated name, and \"-repartition\" is a fixed suffix.\n      * <p>\n      * You can retrieve all generated internal topic names via {@link Topology#describe()}.\n      * <p>\n-     * For this case, all data of this stream will be redistributed through the repartitioning topic by writing all\n-     * records to it, and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned\n-     * correctly on its key.\n-     * If the last key changing operator changed the key type, it is recommended to use\n-     * {@link #groupByKey(org.apache.kafka.streams.kstream.Grouped)} instead.\n+     * All data of this stream will be redistributed through the repartitioning topic by writing all records to it,\n+     * and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned on the new key.\n+     * <p>\n+     * This operation is equivalent to calling {@link #selectKey(KeyValueMapper)} followed by {@link #groupByKey()}.\n+     * If the key type is changed, it is recommended to use {@link #groupBy(KeyValueMapper, Grouped)} instead.\n      *\n+     * @param keySelector a {@link KeyValueMapper} that computes a new key for grouping\n+     * @param <KR>        the key type of the result {@link KGroupedStream}\n      * @return a {@link KGroupedStream} that contains the grouped records of the original {@code KStream}\n-     * @see #groupBy(KeyValueMapper)\n      */\n-    KGroupedStream<K, V> groupByKey();\n+    <KR> KGroupedStream<KR, V> groupBy(final KeyValueMapper<? super K, ? super V, KR> keySelector);", "originalCommit": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTM3OA==", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035378", "bodyText": "renamed selector to keySelector", "author": "mjsax", "createdAt": "2020-01-10T01:17:16Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -875,192 +875,192 @@ void to(final TopicNameExtractor<K, V> topicExtractor,\n             final Produced<K, V> produced);\n \n     /**\n-     * Group the records by their current key into a {@link KGroupedStream} while preserving the original values\n+     * Group the records of this {@code KStream} on a new key that is selected using the provided {@link KeyValueMapper}\n      * and default serializers and deserializers.\n      * {@link KGroupedStream} can be further grouped with other streams to form a {@link CogroupedKStream}.\n      * Grouping a stream on the record key is required before an aggregation operator can be applied to the data\n      * (cf. {@link KGroupedStream}).\n-     * If a record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}.\n+     * The {@link KeyValueMapper} selects a new key (which may or may not be of the same type) while preserving the\n+     * original values.\n+     * If the new record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}\n      * <p>\n-     * If a key changing operator was used before this operation (e.g., {@link #selectKey(KeyValueMapper)},\n-     * {@link #map(KeyValueMapper)}, {@link #flatMap(KeyValueMapper)}, or\n-     * {@link #transform(TransformerSupplier, String...)}), and no data redistribution happened afterwards (e.g., via\n-     * {@link #through(String)}) an internal repartitioning topic may need to be created in Kafka if a later\n-     * operator depends on the newly selected key.\n+     * Because a new key is selected, an internal repartitioning topic may need to be created in Kafka if a\n+     * later operator depends on the newly selected key.\n      * This topic will be named \"${applicationId}-&lt;name&gt;-repartition\", where \"applicationId\" is user-specified in\n      * {@link StreamsConfig} via parameter {@link StreamsConfig#APPLICATION_ID_CONFIG APPLICATION_ID_CONFIG},\n      * \"&lt;name&gt;\" is an internally generated name, and \"-repartition\" is a fixed suffix.\n      * <p>\n      * You can retrieve all generated internal topic names via {@link Topology#describe()}.\n      * <p>\n-     * For this case, all data of this stream will be redistributed through the repartitioning topic by writing all\n-     * records to it, and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned\n-     * correctly on its key.\n-     * If the last key changing operator changed the key type, it is recommended to use\n-     * {@link #groupByKey(org.apache.kafka.streams.kstream.Grouped)} instead.\n+     * All data of this stream will be redistributed through the repartitioning topic by writing all records to it,\n+     * and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned on the new key.\n+     * <p>\n+     * This operation is equivalent to calling {@link #selectKey(KeyValueMapper)} followed by {@link #groupByKey()}.\n+     * If the key type is changed, it is recommended to use {@link #groupBy(KeyValueMapper, Grouped)} instead.\n      *\n+     * @param keySelector a {@link KeyValueMapper} that computes a new key for grouping\n+     * @param <KR>        the key type of the result {@link KGroupedStream}\n      * @return a {@link KGroupedStream} that contains the grouped records of the original {@code KStream}\n-     * @see #groupBy(KeyValueMapper)\n      */\n-    KGroupedStream<K, V> groupByKey();\n+    <KR> KGroupedStream<KR, V> groupBy(final KeyValueMapper<? super K, ? super V, KR> keySelector);\n \n     /**\n-     * Group the records by their current key into a {@link KGroupedStream} while preserving the original values\n-     * and using the serializers as defined by {@link Serialized}.\n+     * Group the records of this {@code KStream} on a new key that is selected using the provided {@link KeyValueMapper}\n+     * and {@link Serde}s as specified by {@link Serialized}.\n      * {@link KGroupedStream} can be further grouped with other streams to form a {@link CogroupedKStream}.\n      * Grouping a stream on the record key is required before an aggregation operator can be applied to the data\n      * (cf. {@link KGroupedStream}).\n-     * If a record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}.\n+     * The {@link KeyValueMapper} selects a new key (which may or may not be of the same type) while preserving the\n+     * original values.\n+     * If the new record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}.\n      * <p>\n-     * If a key changing operator was used before this operation (e.g., {@link #selectKey(KeyValueMapper)},\n-     * {@link #map(KeyValueMapper)}, {@link #flatMap(KeyValueMapper)}, or\n-     * {@link #transform(TransformerSupplier, String...)}), and no data redistribution happened afterwards (e.g., via\n-     * {@link #through(String)}) an internal repartitioning topic may need to be created in Kafka\n-     * if a later operator depends on the newly selected key.\n-     * This topic will be named \"${applicationId}-&lt;name&gt;-repartition\", where \"applicationId\" is user-specified in\n+     * Because a new key is selected, an internal repartitioning topic may need to be created in Kafka if a\n+     * later operator depends on the newly selected key.\n+     * This topic will be as \"${applicationId}-&lt;name&gt;-repartition\", where \"applicationId\" is user-specified in\n      * {@link StreamsConfig} via parameter {@link StreamsConfig#APPLICATION_ID_CONFIG APPLICATION_ID_CONFIG},\n      * \"&lt;name&gt;\" is an internally generated name, and \"-repartition\" is a fixed suffix.\n      * <p>\n      * You can retrieve all generated internal topic names via {@link Topology#describe()}.\n      * <p>\n-     * For this case, all data of this stream will be redistributed through the repartitioning topic by writing all\n-     * records to it, and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned\n-     * correctly on its key.\n+     * All data of this stream will be redistributed through the repartitioning topic by writing all records to it,\n+     * and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned on the new key.\n+     * <p>\n+     * This operation is equivalent to calling {@link #selectKey(KeyValueMapper)} followed by {@link #groupByKey()}.\n      *\n+     * @param keySelector a {@link KeyValueMapper} that computes a new key for grouping\n+     * @param <KR>        the key type of the result {@link KGroupedStream}\n      * @return a {@link KGroupedStream} that contains the grouped records of the original {@code KStream}\n-     * @see #groupBy(KeyValueMapper)\n      *\n-     * @deprecated since 2.1. Use {@link org.apache.kafka.streams.kstream.KStream#groupByKey(Grouped)} instead\n+     * @deprecated since 2.1. Use {@link org.apache.kafka.streams.kstream.KStream#groupBy(KeyValueMapper, Grouped)} instead\n      */\n     @Deprecated\n-    KGroupedStream<K, V> groupByKey(final Serialized<K, V> serialized);\n+    <KR> KGroupedStream<KR, V> groupBy(final KeyValueMapper<? super K, ? super V, KR> keySelector,", "originalCommit": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTM5Mw==", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035393", "bodyText": "renamed selector to keySelector", "author": "mjsax", "createdAt": "2020-01-10T01:17:23Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -875,192 +875,192 @@ void to(final TopicNameExtractor<K, V> topicExtractor,\n             final Produced<K, V> produced);\n \n     /**\n-     * Group the records by their current key into a {@link KGroupedStream} while preserving the original values\n+     * Group the records of this {@code KStream} on a new key that is selected using the provided {@link KeyValueMapper}\n      * and default serializers and deserializers.\n      * {@link KGroupedStream} can be further grouped with other streams to form a {@link CogroupedKStream}.\n      * Grouping a stream on the record key is required before an aggregation operator can be applied to the data\n      * (cf. {@link KGroupedStream}).\n-     * If a record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}.\n+     * The {@link KeyValueMapper} selects a new key (which may or may not be of the same type) while preserving the\n+     * original values.\n+     * If the new record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}\n      * <p>\n-     * If a key changing operator was used before this operation (e.g., {@link #selectKey(KeyValueMapper)},\n-     * {@link #map(KeyValueMapper)}, {@link #flatMap(KeyValueMapper)}, or\n-     * {@link #transform(TransformerSupplier, String...)}), and no data redistribution happened afterwards (e.g., via\n-     * {@link #through(String)}) an internal repartitioning topic may need to be created in Kafka if a later\n-     * operator depends on the newly selected key.\n+     * Because a new key is selected, an internal repartitioning topic may need to be created in Kafka if a\n+     * later operator depends on the newly selected key.\n      * This topic will be named \"${applicationId}-&lt;name&gt;-repartition\", where \"applicationId\" is user-specified in\n      * {@link StreamsConfig} via parameter {@link StreamsConfig#APPLICATION_ID_CONFIG APPLICATION_ID_CONFIG},\n      * \"&lt;name&gt;\" is an internally generated name, and \"-repartition\" is a fixed suffix.\n      * <p>\n      * You can retrieve all generated internal topic names via {@link Topology#describe()}.\n      * <p>\n-     * For this case, all data of this stream will be redistributed through the repartitioning topic by writing all\n-     * records to it, and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned\n-     * correctly on its key.\n-     * If the last key changing operator changed the key type, it is recommended to use\n-     * {@link #groupByKey(org.apache.kafka.streams.kstream.Grouped)} instead.\n+     * All data of this stream will be redistributed through the repartitioning topic by writing all records to it,\n+     * and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned on the new key.\n+     * <p>\n+     * This operation is equivalent to calling {@link #selectKey(KeyValueMapper)} followed by {@link #groupByKey()}.\n+     * If the key type is changed, it is recommended to use {@link #groupBy(KeyValueMapper, Grouped)} instead.\n      *\n+     * @param keySelector a {@link KeyValueMapper} that computes a new key for grouping\n+     * @param <KR>        the key type of the result {@link KGroupedStream}\n      * @return a {@link KGroupedStream} that contains the grouped records of the original {@code KStream}\n-     * @see #groupBy(KeyValueMapper)\n      */\n-    KGroupedStream<K, V> groupByKey();\n+    <KR> KGroupedStream<KR, V> groupBy(final KeyValueMapper<? super K, ? super V, KR> keySelector);\n \n     /**\n-     * Group the records by their current key into a {@link KGroupedStream} while preserving the original values\n-     * and using the serializers as defined by {@link Serialized}.\n+     * Group the records of this {@code KStream} on a new key that is selected using the provided {@link KeyValueMapper}\n+     * and {@link Serde}s as specified by {@link Serialized}.\n      * {@link KGroupedStream} can be further grouped with other streams to form a {@link CogroupedKStream}.\n      * Grouping a stream on the record key is required before an aggregation operator can be applied to the data\n      * (cf. {@link KGroupedStream}).\n-     * If a record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}.\n+     * The {@link KeyValueMapper} selects a new key (which may or may not be of the same type) while preserving the\n+     * original values.\n+     * If the new record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}.\n      * <p>\n-     * If a key changing operator was used before this operation (e.g., {@link #selectKey(KeyValueMapper)},\n-     * {@link #map(KeyValueMapper)}, {@link #flatMap(KeyValueMapper)}, or\n-     * {@link #transform(TransformerSupplier, String...)}), and no data redistribution happened afterwards (e.g., via\n-     * {@link #through(String)}) an internal repartitioning topic may need to be created in Kafka\n-     * if a later operator depends on the newly selected key.\n-     * This topic will be named \"${applicationId}-&lt;name&gt;-repartition\", where \"applicationId\" is user-specified in\n+     * Because a new key is selected, an internal repartitioning topic may need to be created in Kafka if a\n+     * later operator depends on the newly selected key.\n+     * This topic will be as \"${applicationId}-&lt;name&gt;-repartition\", where \"applicationId\" is user-specified in\n      * {@link StreamsConfig} via parameter {@link StreamsConfig#APPLICATION_ID_CONFIG APPLICATION_ID_CONFIG},\n      * \"&lt;name&gt;\" is an internally generated name, and \"-repartition\" is a fixed suffix.\n      * <p>\n      * You can retrieve all generated internal topic names via {@link Topology#describe()}.\n      * <p>\n-     * For this case, all data of this stream will be redistributed through the repartitioning topic by writing all\n-     * records to it, and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned\n-     * correctly on its key.\n+     * All data of this stream will be redistributed through the repartitioning topic by writing all records to it,\n+     * and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned on the new key.\n+     * <p>\n+     * This operation is equivalent to calling {@link #selectKey(KeyValueMapper)} followed by {@link #groupByKey()}.\n      *\n+     * @param keySelector a {@link KeyValueMapper} that computes a new key for grouping\n+     * @param <KR>        the key type of the result {@link KGroupedStream}\n      * @return a {@link KGroupedStream} that contains the grouped records of the original {@code KStream}\n-     * @see #groupBy(KeyValueMapper)\n      *\n-     * @deprecated since 2.1. Use {@link org.apache.kafka.streams.kstream.KStream#groupByKey(Grouped)} instead\n+     * @deprecated since 2.1. Use {@link org.apache.kafka.streams.kstream.KStream#groupBy(KeyValueMapper, Grouped)} instead\n      */\n     @Deprecated\n-    KGroupedStream<K, V> groupByKey(final Serialized<K, V> serialized);\n+    <KR> KGroupedStream<KR, V> groupBy(final KeyValueMapper<? super K, ? super V, KR> keySelector,\n+                                       final Serialized<KR, V> serialized);\n \n     /**\n-     * Group the records by their current key into a {@link KGroupedStream} while preserving the original values\n-     * and using the serializers as defined by {@link Grouped}.\n+     * Group the records of this {@code KStream} on a new key that is selected using the provided {@link KeyValueMapper}\n+     * and {@link Serde}s as specified by {@link Grouped}.\n      * {@link KGroupedStream} can be further grouped with other streams to form a {@link CogroupedKStream}.\n      * Grouping a stream on the record key is required before an aggregation operator can be applied to the data\n      * (cf. {@link KGroupedStream}).\n-     * If a record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}.\n+     * The {@link KeyValueMapper} selects a new key (which may or may not be of the same type) while preserving the\n+     * original values.\n+     * If the new record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}.\n      * <p>\n-     * If a key changing operator was used before this operation (e.g., {@link #selectKey(KeyValueMapper)},\n-     * {@link #map(KeyValueMapper)}, {@link #flatMap(KeyValueMapper)}, or\n-     * {@link #transform(TransformerSupplier, String...)}), and no data redistribution happened afterwards (e.g., via\n-     * {@link #through(String)}) an internal repartitioning topic may need to be created in Kafka if a later operator\n-     * depends on the newly selected key.\n+     * Because a new key is selected, an internal repartitioning topic may need to be created in Kafka if a later\n+     * operator depends on the newly selected key.\n      * This topic will be named \"${applicationId}-&lt;name&gt;-repartition\", where \"applicationId\" is user-specified in\n      * {@link StreamsConfig} via parameter {@link StreamsConfig#APPLICATION_ID_CONFIG APPLICATION_ID_CONFIG},\n-     * &lt;name&gt; is either provided via {@link org.apache.kafka.streams.kstream.Grouped#as(String)} or an internally\n-     * generated name, and \"-repartition\" is a fixed suffix.\n+     * \"&lt;name&gt;\" is either provided via {@link org.apache.kafka.streams.kstream.Grouped#as(String)} or an\n+     * internally generated name.\n      * <p>\n      * You can retrieve all generated internal topic names via {@link Topology#describe()}.\n      * <p>\n-     * For this case, all data of this stream will be redistributed through the repartitioning topic by writing all\n-     * records to it, and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned\n-     * correctly on its key.\n+     * All data of this stream will be redistributed through the repartitioning topic by writing all records to it,\n+     * and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned on the new key.\n+     * <p>\n+     * This operation is equivalent to calling {@link #selectKey(KeyValueMapper)} followed by {@link #groupByKey()}.\n      *\n-     * @param  grouped  the {@link Grouped} instance used to specify {@link org.apache.kafka.common.serialization.Serdes}\n-     *                  and part of the name for a repartition topic if repartitioning is required.\n+     * @param keySelector a {@link KeyValueMapper} that computes a new key for grouping\n+     * @param grouped     the {@link Grouped} instance used to specify {@link org.apache.kafka.common.serialization.Serdes}\n+     *                    and part of the name for a repartition topic if repartitioning is required.\n+     * @param <KR>        the key type of the result {@link KGroupedStream}\n      * @return a {@link KGroupedStream} that contains the grouped records of the original {@code KStream}\n-     * @see #groupBy(KeyValueMapper)\n      */\n-    KGroupedStream<K, V> groupByKey(final Grouped<K, V> grouped);\n+    <KR> KGroupedStream<KR, V> groupBy(final KeyValueMapper<? super K, ? super V, KR> keySelector,", "originalCommit": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTYyMw==", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035623", "bodyText": "renamed globalKTable to globalTable\nrenamed keyValueMapper  to keySelector", "author": "mjsax", "createdAt": "2020-01-10T01:18:23Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -2144,8 +2144,8 @@ void to(final TopicNameExtractor<K, V> topicExtractor,\n      * {@link ValueJoiner}, one output for each input {@code KStream} record\n      * @see #leftJoin(GlobalKTable, KeyValueMapper, ValueJoiner)\n      */\n-    <GK, GV, RV> KStream<K, RV> join(final GlobalKTable<GK, GV> globalKTable,\n-                                     final KeyValueMapper<? super K, ? super V, ? extends GK> keyValueMapper,\n+    <GK, GV, RV> KStream<K, RV> join(final GlobalKTable<GK, GV> globalTable,\n+                                     final KeyValueMapper<? super K, ? super V, ? extends GK> keySelector,", "originalCommit": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTY0OA==", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035648", "bodyText": "renamed globalKTable to globalTable\nrenamed keyValueMapper  to keySelector", "author": "mjsax", "createdAt": "2020-01-10T01:18:31Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -2178,8 +2178,8 @@ void to(final TopicNameExtractor<K, V> topicExtractor,\n      * {@link ValueJoiner}, one output for each input {@code KStream} record\n      * @see #leftJoin(GlobalKTable, KeyValueMapper, ValueJoiner)\n      */\n-    <GK, GV, RV> KStream<K, RV> join(final GlobalKTable<GK, GV> globalKTable,\n-                                     final KeyValueMapper<? super K, ? super V, ? extends GK> keyValueMapper,\n+    <GK, GV, RV> KStream<K, RV> join(final GlobalKTable<GK, GV> globalTable,\n+                                     final KeyValueMapper<? super K, ? super V, ? extends GK> keySelector,", "originalCommit": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTY3NQ==", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035675", "bodyText": "renamed globalKTable to globalTable\nrenamed keyValueMapper  to keySelector", "author": "mjsax", "createdAt": "2020-01-10T01:18:36Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -2216,8 +2216,8 @@ void to(final TopicNameExtractor<K, V> topicExtractor,\n      * {@link ValueJoiner}, one output for each input {@code KStream} record\n      * @see #join(GlobalKTable, KeyValueMapper, ValueJoiner)\n      */\n-    <GK, GV, RV> KStream<K, RV> leftJoin(final GlobalKTable<GK, GV> globalKTable,\n-                                         final KeyValueMapper<? super K, ? super V, ? extends GK> keyValueMapper,\n+    <GK, GV, RV> KStream<K, RV> leftJoin(final GlobalKTable<GK, GV> globalTable,\n+                                         final KeyValueMapper<? super K, ? super V, ? extends GK> keySelector,", "originalCommit": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTY5MA==", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035690", "bodyText": "renamed globalKTable to globalTable\nrenamed keyValueMapper  to keySelector", "author": "mjsax", "createdAt": "2020-01-10T01:18:41Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -2254,8 +2254,8 @@ void to(final TopicNameExtractor<K, V> topicExtractor,\n      * {@link ValueJoiner}, one output for each input {@code KStream} record\n      * @see #join(GlobalKTable, KeyValueMapper, ValueJoiner)\n      */\n-    <GK, GV, RV> KStream<K, RV> leftJoin(final GlobalKTable<GK, GV> globalKTable,\n-                                         final KeyValueMapper<? super K, ? super V, ? extends GK> keyValueMapper,\n+    <GK, GV, RV> KStream<K, RV> leftJoin(final GlobalKTable<GK, GV> globalTable,\n+                                         final KeyValueMapper<? super K, ? super V, ? extends GK> keySelector,", "originalCommit": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTc3Nw==", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035777", "bodyText": "As in the interface; renamed parameter", "author": "mjsax", "createdAt": "2020-01-10T01:19:10Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -601,30 +601,30 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n     }\n \n     @Override\n-    public <KR> KGroupedStream<KR, V> groupBy(final KeyValueMapper<? super K, ? super V, KR> selector) {\n-        return groupBy(selector, Grouped.with(null, valSerde));\n+    public <KR> KGroupedStream<KR, V> groupBy(final KeyValueMapper<? super K, ? super V, KR> keySelector) {\n+        return groupBy(keySelector, Grouped.with(null, valSerde));", "originalCommit": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTg1Mw==", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035853", "bodyText": "It's called otherStream in the interface -- aligning both", "author": "mjsax", "createdAt": "2020-01-10T01:19:36Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -664,10 +668,10 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n     }\n \n     @Override\n-    public <VO, VR> KStream<K, VR> join(final KStream<K, VO> other,\n+    public <VO, VR> KStream<K, VR> join(final KStream<K, VO> otherStream,", "originalCommit": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTkyNw==", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035927", "bodyText": "It's called table in the interface -- aligning both", "author": "mjsax", "createdAt": "2020-01-10T01:19:57Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -857,55 +900,16 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n     }\n \n     @Override\n-    public <VO, VR> KStream<K, VR> leftJoin(final KStream<K, VO> other,\n-                                            final ValueJoiner<? super V, ? super VO, ? extends VR> joiner,\n-                                            final JoinWindows windows) {\n-        return leftJoin(other, joiner, windows, Joined.with(null, null, null));\n-    }\n-\n-    @Override\n-    @Deprecated\n-    public <VO, VR> KStream<K, VR> leftJoin(final KStream<K, VO> other,\n-                                            final ValueJoiner<? super V, ? super VO, ? extends VR> joiner,\n-                                            final JoinWindows windows,\n-                                            final Joined<K, V, VO> joined) {\n-        Objects.requireNonNull(joined, \"Joined can't be null\");\n-\n-        final JoinedInternal<K, V, VO> joinedInternal = new JoinedInternal<>(joined);\n-        final StreamJoined<K, V, VO> streamJoined = StreamJoined\n-            .with(\n-                joinedInternal.keySerde(),\n-                joinedInternal.valueSerde(),\n-                joinedInternal.otherValueSerde())\n-            .withName(joinedInternal.name());\n-\n-        return leftJoin(other, joiner, windows, streamJoined);\n-    }\n-\n-    @Override\n-    public <VO, VR> KStream<K, VR> leftJoin(final KStream<K, VO> other,\n-                                            final ValueJoiner<? super V, ? super VO, ? extends VR> joiner,\n-                                            final JoinWindows windows,\n-                                            final StreamJoined<K, V, VO> streamJoined) {\n-        return doJoin(\n-            other,\n-            joiner,\n-            windows,\n-            streamJoined,\n-            new KStreamImplJoin(builder, true, false));\n-    }\n-\n-    @Override\n-    public <VO, VR> KStream<K, VR> join(final KTable<K, VO> other,\n+    public <VO, VR> KStream<K, VR> join(final KTable<K, VO> table,", "originalCommit": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTk5NA==", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035994", "bodyText": "As in the interface; renamed parameter", "author": "mjsax", "createdAt": "2020-01-10T01:20:22Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -946,49 +950,49 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n                 joined.keySerde(),\n                 joined.valueSerde()\n             );\n-            return thisStreamRepartitioned.doStreamTableJoin(other, joiner, joined, true);\n+            return thisStreamRepartitioned.doStreamTableJoin(table, joiner, joined, true);\n         } else {\n-            return doStreamTableJoin(other, joiner, joined, true);\n+            return doStreamTableJoin(table, joiner, joined, true);\n         }\n     }\n \n     @Override\n     public <KG, VG, VR> KStream<K, VR> join(final GlobalKTable<KG, VG> globalTable,\n-                                            final KeyValueMapper<? super K, ? super V, ? extends KG> keyMapper,\n+                                            final KeyValueMapper<? super K, ? super V, ? extends KG> keySelector,", "originalCommit": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNjEwNQ==", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365036105", "bodyText": "As in the interface; renamed parameter\n(note, that the first parameter is already called globalTable)", "author": "mjsax", "createdAt": "2020-01-10T01:20:56Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -946,49 +950,49 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n                 joined.keySerde(),\n                 joined.valueSerde()\n             );\n-            return thisStreamRepartitioned.doStreamTableJoin(other, joiner, joined, true);\n+            return thisStreamRepartitioned.doStreamTableJoin(table, joiner, joined, true);\n         } else {\n-            return doStreamTableJoin(other, joiner, joined, true);\n+            return doStreamTableJoin(table, joiner, joined, true);\n         }\n     }\n \n     @Override\n     public <KG, VG, VR> KStream<K, VR> join(final GlobalKTable<KG, VG> globalTable,\n-                                            final KeyValueMapper<? super K, ? super V, ? extends KG> keyMapper,\n+                                            final KeyValueMapper<? super K, ? super V, ? extends KG> keySelector,\n                                             final ValueJoiner<? super V, ? super VG, ? extends VR> joiner) {\n-        return globalTableJoin(globalTable, keyMapper, joiner, false, NamedInternal.empty());\n+        return globalTableJoin(globalTable, keySelector, joiner, false, NamedInternal.empty());\n     }\n \n     @Override\n     public <KG, VG, VR> KStream<K, VR> join(final GlobalKTable<KG, VG> globalTable,\n-                                            final KeyValueMapper<? super K, ? super V, ? extends KG> keyMapper,\n+                                            final KeyValueMapper<? super K, ? super V, ? extends KG> keySelector,\n                                             final ValueJoiner<? super V, ? super VG, ? extends VR> joiner,\n                                             final Named named) {\n-        return globalTableJoin(globalTable, keyMapper, joiner, false, named);\n+        return globalTableJoin(globalTable, keySelector, joiner, false, named);\n     }\n \n     @Override\n     public <KG, VG, VR> KStream<K, VR> leftJoin(final GlobalKTable<KG, VG> globalTable,\n-                                                final KeyValueMapper<? super K, ? super V, ? extends KG> keyMapper,\n+                                                final KeyValueMapper<? super K, ? super V, ? extends KG> keySelector,\n                                                 final ValueJoiner<? super V, ? super VG, ? extends VR> joiner) {\n-        return globalTableJoin(globalTable, keyMapper, joiner, true, NamedInternal.empty());\n+        return globalTableJoin(globalTable, keySelector, joiner, true, NamedInternal.empty());\n     }\n \n     @Override\n     public <KG, VG, VR> KStream<K, VR> leftJoin(final GlobalKTable<KG, VG> globalTable,\n-                                                final KeyValueMapper<? super K, ? super V, ? extends KG> keyMapper,\n+                                                final KeyValueMapper<? super K, ? super V, ? extends KG> keySelector,\n                                                 final ValueJoiner<? super V, ? super VG, ? extends VR> joiner,\n                                                 final Named named) {\n-        return globalTableJoin(globalTable, keyMapper, joiner, true, named);\n+        return globalTableJoin(globalTable, keySelector, joiner, true, named);\n     }\n \n     private <KG, VG, VR> KStream<K, VR> globalTableJoin(final GlobalKTable<KG, VG> globalTable,\n-                                                        final KeyValueMapper<? super K, ? super V, ? extends KG> keyMapper,\n+                                                        final KeyValueMapper<? super K, ? super V, ? extends KG> keySelector,\n                                                         final ValueJoiner<? super V, ? super VG, ? extends VR> joiner,\n                                                         final boolean leftJoin,\n                                                         final Named named) {\n         Objects.requireNonNull(globalTable, \"globalTable can't be null\");\n-        Objects.requireNonNull(keyMapper, \"keyMapper can't be null\");\n+        Objects.requireNonNull(keySelector, \"keySelector can't be null\");", "originalCommit": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNjIxOQ==", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365036219", "bodyText": "Cannot use import as we cannot suppress deprecation warning on import (similar in the tests).", "author": "mjsax", "createdAt": "2020-01-10T01:21:30Z", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -79,11 +79,14 @@\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n \n public class KStreamImplTest {\n \n     private final Consumed<String, String> stringConsumed = Consumed.with(Serdes.String(), Serdes.String());\n+    @SuppressWarnings(\"deprecation\")\n+    private final org.apache.kafka.streams.kstream.Serialized<String, String> stringSerialized =\n+        org.apache.kafka.streams.kstream.Serialized.with(Serdes.String(), Serdes.String());", "originalCommit": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}