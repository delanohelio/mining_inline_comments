{"pr_number": 9114, "pr_title": "KAFKA-10162; Use Token Bucket algorithm for controller mutation quota (KIP-599, Part III)", "pr_createdAt": "2020-08-03T17:22:52Z", "pr_url": "https://github.com/apache/kafka/pull/9114", "timeline": [{"oid": "229eb8254113935865d4646605c5a02b965098c9", "url": "https://github.com/apache/kafka/commit/229eb8254113935865d4646605c5a02b965098c9", "message": "KAFKA-10162; Make the rate based quota behave more like a Token Bucket (KIP-599, Part III)", "committedDate": "2020-08-03T17:19:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyNDI4MQ==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r464724281", "bodyText": "Should burst be computed from #samples or #samples - 1 ?", "author": "junrao", "createdAt": "2020-08-04T00:04:37Z", "path": "clients/src/main/java/org/apache/kafka/common/metrics/stats/TokenBucket.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics.stats;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.MeasurableStat;\n+import org.apache.kafka.common.metrics.MetricConfig;\n+\n+public class TokenBucket implements MeasurableStat {\n+    private final TimeUnit unit;\n+    private double credits;\n+    private long lastUpdateMs;\n+\n+    public TokenBucket() {\n+        this(TimeUnit.SECONDS);\n+    }\n+\n+    public TokenBucket(TimeUnit unit) {\n+        this.unit = unit;\n+        this.credits = 0;\n+        this.lastUpdateMs = 0;\n+    }\n+\n+    @Override\n+    public double measure(final MetricConfig config, final long timeMs) {\n+        if (config.quota() == null)\n+            return Long.MAX_VALUE;\n+        final double quota = config.quota().bound();\n+        final double burst = (config.samples() - 1) * convert(config.timeWindowMs()) * quota;\n+        refill(quota, burst, timeMs);\n+        return this.credits;\n+    }\n+\n+    @Override\n+    public void record(final MetricConfig config, final double value, final long timeMs) {\n+        if (config.quota() == null)\n+            return;\n+        final double quota = config.quota().bound();\n+        final double burst = (config.samples() - 1) * convert(config.timeWindowMs()) * quota;", "originalCommit": "229eb8254113935865d4646605c5a02b965098c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgxMDQxMg==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r464810412", "bodyText": "If we want the burst to be more similar to original behavior, it seems like this should be #samples. With the current implementation, we can do 1 unit of work in the oldest window and then accept a burst right at the end of the last (not full yet) sample. Which means that the max burst size is almost at #samples * quota (if sample = 1 sec, quota is in units/second). Does this sound right to you?\nAlso, I think we should take into account config.timeWindowMs, because it could be something other than 1 second.", "author": "apovzner", "createdAt": "2020-08-04T05:37:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyNDI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzODQxMQ==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465038411", "bodyText": "That's a very good question. I use #samples - 1 here because we do so in Rate#windowSize to compute the total window so it is probably closer like this.\n@apovzner config.timeWindowMs is already in the formula or did I misunderstand your comment?", "author": "dajac", "createdAt": "2020-08-04T13:10:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyNDI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE2MjI3MA==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r466162270", "bodyText": "hm.. maybe I just did not notice config.timeWindowMs. All good now.", "author": "apovzner", "createdAt": "2020-08-06T05:53:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyNDI4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMTgwNA==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r464731804", "bodyText": "Should we start with 0 credit or the full burst credits? The benefit of the latter is that during initialization, the requests won't be throttled as much due to a cold start.", "author": "junrao", "createdAt": "2020-08-04T00:30:56Z", "path": "clients/src/main/java/org/apache/kafka/common/metrics/stats/TokenBucket.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics.stats;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.MeasurableStat;\n+import org.apache.kafka.common.metrics.MetricConfig;\n+\n+public class TokenBucket implements MeasurableStat {\n+    private final TimeUnit unit;\n+    private double credits;\n+    private long lastUpdateMs;\n+\n+    public TokenBucket() {\n+        this(TimeUnit.SECONDS);\n+    }\n+\n+    public TokenBucket(TimeUnit unit) {\n+        this.unit = unit;\n+        this.credits = 0;", "originalCommit": "229eb8254113935865d4646605c5a02b965098c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgxMTgzMA==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r464811830", "bodyText": "I also think it's better to start with burst size credits. We would normally create the sensor on the first byte/request/etc. and before that, the <user,client> is idle which means they were \"accumulating credits\".", "author": "apovzner", "createdAt": "2020-08-04T05:41:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA0MDY3Mg==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465040672", "bodyText": "The burst is not know when the TokenBucket is constructed as we must get the MetricConfig at least once to initialise it correctly. Note that, it will be initialised to the maximum burst when we refill the bucket when either measure or record is called for the first time. That works because lastUpdateMs is 0 so the delta between now and it will make the bucket full. So, the bucket actually stats from the maximum burst.", "author": "dajac", "createdAt": "2020-08-04T13:14:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE2MTcxOQ==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r466161719", "bodyText": "ah right, lastUpdateMs will make sure that bucket would be full on the first record().", "author": "apovzner", "createdAt": "2020-08-06T05:52:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMTgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgwNzQ2Nw==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r464807467", "bodyText": "we probably just want value < 0 check here, right? Otherwise the throttle time will be 0 anyways.", "author": "apovzner", "createdAt": "2020-08-04T05:26:47Z", "path": "clients/src/main/java/org/apache/kafka/common/metrics/Sensor.java", "diffHunk": "@@ -223,8 +229,14 @@ public void checkQuotas(long timeMs) {\n                 Quota quota = config.quota();\n                 if (quota != null) {\n                     double value = metric.measurableValue(timeMs);\n-                    if (!quota.acceptable(value)) {\n-                        throw new QuotaViolationException(metric, value, quota.bound());\n+                    if (metric.measurable() instanceof TokenBucket) {\n+                        if (value <= 0) {", "originalCommit": "229eb8254113935865d4646605c5a02b965098c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA0MDgxMw==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465040813", "bodyText": "Yes, that makes sense.", "author": "dajac", "createdAt": "2020-08-04T13:14:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgwNzQ2Nw=="}], "type": "inlineReview"}, {"oid": "73ab2a074b3063eb9b049dca0f2000090c045e3a", "url": "https://github.com/apache/kafka/commit/73ab2a074b3063eb9b049dca0f2000090c045e3a", "message": "refactor, add tests, address comments", "committedDate": "2020-08-04T13:06:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMxMDcxMA==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465310710", "bodyText": "Could we add a high level description of the class?", "author": "junrao", "createdAt": "2020-08-04T20:27:43Z", "path": "clients/src/main/java/org/apache/kafka/common/metrics/stats/TokenBucket.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics.stats;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.MeasurableStat;\n+import org.apache.kafka.common.metrics.MetricConfig;\n+\n+public class TokenBucket implements MeasurableStat {", "originalCommit": "73ab2a074b3063eb9b049dca0f2000090c045e3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4OTg5MQ==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465889891", "bodyText": "Sure.", "author": "dajac", "createdAt": "2020-08-05T17:31:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMxMDcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMxMjUxOQ==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465312519", "bodyText": "Rate actually allows the windowSize to be close to the full samples * perSampleWindow. The logic around config.samples() - 1 is just to make sure the windowSize contains at least that many full windows. So, to match that behavior, it seems that burst should use config.samples().", "author": "junrao", "createdAt": "2020-08-04T20:31:03Z", "path": "clients/src/main/java/org/apache/kafka/common/metrics/stats/TokenBucket.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics.stats;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.MeasurableStat;\n+import org.apache.kafka.common.metrics.MetricConfig;\n+\n+public class TokenBucket implements MeasurableStat {\n+    private final TimeUnit unit;\n+    private double tokens;\n+    private long lastUpdateMs;\n+\n+    public TokenBucket() {\n+        this(TimeUnit.SECONDS);\n+    }\n+\n+    public TokenBucket(TimeUnit unit) {\n+        this.unit = unit;\n+        this.tokens = 0;\n+        this.lastUpdateMs = 0;\n+    }\n+\n+    @Override\n+    public double measure(final MetricConfig config, final long timeMs) {\n+        if (config.quota() == null)\n+            return Long.MAX_VALUE;\n+        final double quota = config.quota().bound();\n+        final double burst = burst(config);\n+        refill(quota, burst, timeMs);\n+        return this.tokens;\n+    }\n+\n+    @Override\n+    public void record(final MetricConfig config, final double value, final long timeMs) {\n+        if (config.quota() == null)\n+            return;\n+        final double quota = config.quota().bound();\n+        final double burst = burst(config);\n+        refill(quota, burst, timeMs);\n+        this.tokens = Math.min(burst, this.tokens - value);\n+    }\n+\n+    private void refill(final double quota, final double burst, final long timeMs) {\n+        this.tokens = Math.min(burst, this.tokens + quota * convert(timeMs - lastUpdateMs));\n+        this.lastUpdateMs = timeMs;\n+    }\n+\n+    private double burst(final MetricConfig config) {\n+        return (config.samples() - 1) * convert(config.timeWindowMs()) * config.quota().bound();", "originalCommit": "73ab2a074b3063eb9b049dca0f2000090c045e3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4OTgyNA==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465889824", "bodyText": "Ack. I misunderstood it. config.samples() sounds good to me.", "author": "dajac", "createdAt": "2020-08-05T17:31:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMxMjUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMxNDMzMQ==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465314331", "bodyText": "This code is duplicated from Rate. Could we reuse it somehow?", "author": "junrao", "createdAt": "2020-08-04T20:34:38Z", "path": "clients/src/main/java/org/apache/kafka/common/metrics/stats/TokenBucket.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics.stats;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.MeasurableStat;\n+import org.apache.kafka.common.metrics.MetricConfig;\n+\n+public class TokenBucket implements MeasurableStat {\n+    private final TimeUnit unit;\n+    private double tokens;\n+    private long lastUpdateMs;\n+\n+    public TokenBucket() {\n+        this(TimeUnit.SECONDS);\n+    }\n+\n+    public TokenBucket(TimeUnit unit) {\n+        this.unit = unit;\n+        this.tokens = 0;\n+        this.lastUpdateMs = 0;\n+    }\n+\n+    @Override\n+    public double measure(final MetricConfig config, final long timeMs) {\n+        if (config.quota() == null)\n+            return Long.MAX_VALUE;\n+        final double quota = config.quota().bound();\n+        final double burst = burst(config);\n+        refill(quota, burst, timeMs);\n+        return this.tokens;\n+    }\n+\n+    @Override\n+    public void record(final MetricConfig config, final double value, final long timeMs) {\n+        if (config.quota() == null)\n+            return;\n+        final double quota = config.quota().bound();\n+        final double burst = burst(config);\n+        refill(quota, burst, timeMs);\n+        this.tokens = Math.min(burst, this.tokens - value);\n+    }\n+\n+    private void refill(final double quota, final double burst, final long timeMs) {\n+        this.tokens = Math.min(burst, this.tokens + quota * convert(timeMs - lastUpdateMs));\n+        this.lastUpdateMs = timeMs;\n+    }\n+\n+    private double burst(final MetricConfig config) {\n+        return (config.samples() - 1) * convert(config.timeWindowMs()) * config.quota().bound();\n+    }\n+\n+    private double convert(final long timeMs) {\n+        switch (unit) {", "originalCommit": "73ab2a074b3063eb9b049dca0f2000090c045e3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4OTQ0Nw==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465889447", "bodyText": "Sure, makes sense.", "author": "dajac", "createdAt": "2020-08-05T17:30:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMxNDMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2MzI2MQ==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465363261", "bodyText": "sensor.record() always calls checkQuotas(). Why do we need to call it explicitly here?", "author": "junrao", "createdAt": "2020-08-04T22:21:46Z", "path": "clients/src/test/java/org/apache/kafka/common/metrics/SensorTest.java", "diffHunk": "@@ -209,4 +212,95 @@ public void shouldReturnPresenceOfMetrics() {\n \n         assertThat(sensor.hasMetrics(), is(true));\n     }\n+\n+    @Test\n+    public void testStrictQuotaEnforcementWithRate() {\n+        final Time time = new MockTime(0, System.currentTimeMillis(), 0);\n+        final Metrics metrics = new Metrics(time);\n+        final Sensor sensor = metrics.sensor(\"sensor\", new MetricConfig()\n+            .quota(Quota.upperBound(2))\n+            .timeWindow(1, TimeUnit.SECONDS)\n+            .samples(11));\n+        final MetricName metricName = metrics.metricName(\"rate\", \"test-group\");\n+        assertTrue(sensor.add(metricName, new Rate()));\n+        final KafkaMetric rateMetric = metrics.metric(metricName);\n+\n+        // Recording a first value at T+0 to bring the avg rate to 3 which is already\n+        // above the quota.\n+        strictRecord(sensor, 30, time.milliseconds());\n+        assertEquals(3, rateMetric.measurableValue(time.milliseconds()), 0.1);\n+\n+        // Theoretically, we should wait 5s to bring back the avg rate to the define quota:\n+        // ((30 / 10) - 2) / 2 * 10 = 5s\n+        time.sleep(5000);\n+\n+        // But, recording a second value is rejected because the avg rate is still equal\n+        // to 3 after 5s.\n+        assertEquals(3, rateMetric.measurableValue(time.milliseconds()), 0.1);\n+        assertThrows(QuotaViolationException.class, () -> strictRecord(sensor, 30, time.milliseconds()));\n+\n+        metrics.close();\n+    }\n+\n+    @Test\n+    public void testStrictQuotaEnforcementWithTokenBucket() {\n+        final Time time = new MockTime(0, System.currentTimeMillis(), 0);\n+        final Metrics metrics = new Metrics(time);\n+        final Sensor sensor = metrics.sensor(\"sensor\", new MetricConfig()\n+            .quota(Quota.upperBound(2))\n+            .timeWindow(1, TimeUnit.SECONDS)\n+            .samples(11));\n+        final MetricName metricName = metrics.metricName(\"credits\", \"test-group\");\n+        assertTrue(sensor.add(metricName, new TokenBucket()));\n+        final KafkaMetric tkMetric = metrics.metric(metricName);\n+\n+        // Recording a first value at T+0 to bring the remaining credits below zero\n+        strictRecord(sensor, 30, time.milliseconds());\n+        assertEquals(-10, tkMetric.measurableValue(time.milliseconds()), 0.1);\n+\n+        // Theoretically, we should wait 5s to bring back the avg rate to the define quota:\n+        // 10 / 2 = 5s\n+        time.sleep(5000);\n+\n+        // Unlike the default rate based on a windowed sum, it works as expected.\n+        assertEquals(0, tkMetric.measurableValue(time.milliseconds()), 0.1);\n+        strictRecord(sensor, 30, time.milliseconds());\n+        assertEquals(-30, tkMetric.measurableValue(time.milliseconds()), 0.1);\n+\n+        metrics.close();\n+    }\n+\n+    private void strictRecord(Sensor sensor, double value, long timeMs) {\n+        synchronized (sensor) {\n+            sensor.checkQuotas(timeMs);", "originalCommit": "73ab2a074b3063eb9b049dca0f2000090c045e3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4NjkxOQ==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465886919", "bodyText": "In the above two tests, I simulate a \"strict quotas\" in the sense that recording is not allowed if the quota is already violated. Therefore, I check it before recording the value.", "author": "dajac", "createdAt": "2020-08-05T17:26:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2MzI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NDAyNQ==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465364025", "bodyText": "Here, we are just verifying there is no quota exception?", "author": "junrao", "createdAt": "2020-08-04T22:23:56Z", "path": "clients/src/test/java/org/apache/kafka/common/metrics/SensorTest.java", "diffHunk": "@@ -209,4 +212,95 @@ public void shouldReturnPresenceOfMetrics() {\n \n         assertThat(sensor.hasMetrics(), is(true));\n     }\n+\n+    @Test\n+    public void testStrictQuotaEnforcementWithRate() {\n+        final Time time = new MockTime(0, System.currentTimeMillis(), 0);\n+        final Metrics metrics = new Metrics(time);\n+        final Sensor sensor = metrics.sensor(\"sensor\", new MetricConfig()\n+            .quota(Quota.upperBound(2))\n+            .timeWindow(1, TimeUnit.SECONDS)\n+            .samples(11));\n+        final MetricName metricName = metrics.metricName(\"rate\", \"test-group\");\n+        assertTrue(sensor.add(metricName, new Rate()));\n+        final KafkaMetric rateMetric = metrics.metric(metricName);\n+\n+        // Recording a first value at T+0 to bring the avg rate to 3 which is already\n+        // above the quota.\n+        strictRecord(sensor, 30, time.milliseconds());\n+        assertEquals(3, rateMetric.measurableValue(time.milliseconds()), 0.1);\n+\n+        // Theoretically, we should wait 5s to bring back the avg rate to the define quota:\n+        // ((30 / 10) - 2) / 2 * 10 = 5s\n+        time.sleep(5000);\n+\n+        // But, recording a second value is rejected because the avg rate is still equal\n+        // to 3 after 5s.\n+        assertEquals(3, rateMetric.measurableValue(time.milliseconds()), 0.1);\n+        assertThrows(QuotaViolationException.class, () -> strictRecord(sensor, 30, time.milliseconds()));\n+\n+        metrics.close();\n+    }\n+\n+    @Test\n+    public void testStrictQuotaEnforcementWithTokenBucket() {\n+        final Time time = new MockTime(0, System.currentTimeMillis(), 0);\n+        final Metrics metrics = new Metrics(time);\n+        final Sensor sensor = metrics.sensor(\"sensor\", new MetricConfig()\n+            .quota(Quota.upperBound(2))\n+            .timeWindow(1, TimeUnit.SECONDS)\n+            .samples(11));\n+        final MetricName metricName = metrics.metricName(\"credits\", \"test-group\");\n+        assertTrue(sensor.add(metricName, new TokenBucket()));\n+        final KafkaMetric tkMetric = metrics.metric(metricName);\n+\n+        // Recording a first value at T+0 to bring the remaining credits below zero\n+        strictRecord(sensor, 30, time.milliseconds());\n+        assertEquals(-10, tkMetric.measurableValue(time.milliseconds()), 0.1);\n+\n+        // Theoretically, we should wait 5s to bring back the avg rate to the define quota:\n+        // 10 / 2 = 5s\n+        time.sleep(5000);\n+\n+        // Unlike the default rate based on a windowed sum, it works as expected.\n+        assertEquals(0, tkMetric.measurableValue(time.milliseconds()), 0.1);\n+        strictRecord(sensor, 30, time.milliseconds());\n+        assertEquals(-30, tkMetric.measurableValue(time.milliseconds()), 0.1);\n+\n+        metrics.close();\n+    }\n+\n+    private void strictRecord(Sensor sensor, double value, long timeMs) {\n+        synchronized (sensor) {\n+            sensor.checkQuotas(timeMs);\n+            sensor.record(value, timeMs, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testRecordAndCheckQuotaUseMetricConfigOfEachStat() {\n+        final Time time = new MockTime(0, System.currentTimeMillis(), 0);\n+        final Metrics metrics = new Metrics(time);\n+        final Sensor sensor = metrics.sensor(\"sensor\");\n+\n+        final MeasurableStat stat1 = Mockito.mock(MeasurableStat.class);\n+        final MetricName stat1Name = metrics.metricName(\"stat1\", \"test-group\");\n+        final MetricConfig stat1Config = new MetricConfig().quota(Quota.upperBound(5));\n+        sensor.add(stat1Name, stat1, stat1Config);\n+\n+        final MeasurableStat stat2 = Mockito.mock(MeasurableStat.class);\n+        final MetricName stat2Name = metrics.metricName(\"stat2\", \"test-group\");\n+        final MetricConfig stat2Config = new MetricConfig().quota(Quota.upperBound(10));\n+        sensor.add(stat2Name, stat2, stat2Config);\n+\n+        sensor.record(10, 1);\n+        Mockito.verify(stat1).record(stat1Config, 10, 1);\n+        Mockito.verify(stat2).record(stat2Config, 10, 1);\n+\n+        Mockito.when(stat1.measure(stat1Config, 2)).thenReturn(2.0);\n+        Mockito.when(stat2.measure(stat2Config, 2)).thenReturn(2.0);\n+        sensor.checkQuotas(2);", "originalCommit": "73ab2a074b3063eb9b049dca0f2000090c045e3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4ODgxNw==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465888817", "bodyText": "No. This test actually reproduce a bug that I have found. Basically, a stat can be added to the Sensor with a MetricsConfig but the Sensor was not using the provided one when recording a value but was using the one of the Sensor all the time. This test verifies that the correct config is used both for recording and measuring via calling checkQuota.", "author": "dajac", "createdAt": "2020-08-05T17:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NDAyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NTE5Mg==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465365192", "bodyText": "We are recording -60.", "author": "junrao", "createdAt": "2020-08-04T22:27:06Z", "path": "clients/src/test/java/org/apache/kafka/common/metrics/TokenBucketTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.stats.TokenBucket;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.common.utils.Time;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class TokenBucketTest {\n+    Time time;\n+\n+    @Before\n+    public void setup() {\n+        time = new MockTime(0, System.currentTimeMillis(), System.nanoTime());\n+    }\n+\n+    @Test\n+    public void testRecord() {\n+        // Rate  = 5 unit / sec\n+        // Burst = 2 * (11 - 1) = 20 units\n+        MetricConfig config = new MetricConfig()\n+            .quota(Quota.upperBound(5))\n+            .timeWindow(2, TimeUnit.SECONDS)\n+            .samples(11);\n+\n+        TokenBucket tk = new TokenBucket();\n+\n+        // Expect 100 credits at T\n+        assertEquals(100, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Record 60 at T, expect 13 credits\n+        tk.record(config, 60, time.milliseconds());\n+        assertEquals(40, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Advance by 2s, record 5, expect 45 credits\n+        time.sleep(2000);\n+        tk.record(config, 5, time.milliseconds());\n+        assertEquals(45, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Advance by 2s, record 60, expect -5 credits\n+        time.sleep(2000);\n+        tk.record(config, 60, time.milliseconds());\n+        assertEquals(-5, tk.measure(config, time.milliseconds()), 0.1);\n+    }\n+\n+    @Test\n+    public void testUnrecord() {\n+        // Rate  = 5 unit / sec\n+        // Burst = 2 * (11 - 1) = 20 units\n+        MetricConfig config = new MetricConfig()\n+            .quota(Quota.upperBound(5))\n+            .timeWindow(2, TimeUnit.SECONDS)\n+            .samples(11);\n+\n+        TokenBucket tk = new TokenBucket();\n+\n+        // Expect 100 credits at T\n+        assertEquals(100, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Record 60 at T, expect 100 credits", "originalCommit": "73ab2a074b3063eb9b049dca0f2000090c045e3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NTIxNw==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465365217", "bodyText": "We are recording -60.", "author": "junrao", "createdAt": "2020-08-04T22:27:12Z", "path": "clients/src/test/java/org/apache/kafka/common/metrics/TokenBucketTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.stats.TokenBucket;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.common.utils.Time;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class TokenBucketTest {\n+    Time time;\n+\n+    @Before\n+    public void setup() {\n+        time = new MockTime(0, System.currentTimeMillis(), System.nanoTime());\n+    }\n+\n+    @Test\n+    public void testRecord() {\n+        // Rate  = 5 unit / sec\n+        // Burst = 2 * (11 - 1) = 20 units\n+        MetricConfig config = new MetricConfig()\n+            .quota(Quota.upperBound(5))\n+            .timeWindow(2, TimeUnit.SECONDS)\n+            .samples(11);\n+\n+        TokenBucket tk = new TokenBucket();\n+\n+        // Expect 100 credits at T\n+        assertEquals(100, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Record 60 at T, expect 13 credits\n+        tk.record(config, 60, time.milliseconds());\n+        assertEquals(40, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Advance by 2s, record 5, expect 45 credits\n+        time.sleep(2000);\n+        tk.record(config, 5, time.milliseconds());\n+        assertEquals(45, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Advance by 2s, record 60, expect -5 credits\n+        time.sleep(2000);\n+        tk.record(config, 60, time.milliseconds());\n+        assertEquals(-5, tk.measure(config, time.milliseconds()), 0.1);\n+    }\n+\n+    @Test\n+    public void testUnrecord() {\n+        // Rate  = 5 unit / sec\n+        // Burst = 2 * (11 - 1) = 20 units\n+        MetricConfig config = new MetricConfig()\n+            .quota(Quota.upperBound(5))\n+            .timeWindow(2, TimeUnit.SECONDS)\n+            .samples(11);\n+\n+        TokenBucket tk = new TokenBucket();\n+\n+        // Expect 100 credits at T\n+        assertEquals(100, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Record 60 at T, expect 100 credits\n+        tk.record(config, -60, time.milliseconds());\n+        assertEquals(100, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Advance by 2s, record 60, expect 40 credits\n+        time.sleep(2000);\n+        tk.record(config, 60, time.milliseconds());\n+        assertEquals(40, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Advance by 2s, record 60, expect 100 credits", "originalCommit": "73ab2a074b3063eb9b049dca0f2000090c045e3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5a000782bb8e9e9c95b707b713dfb7c890eda2f1", "url": "https://github.com/apache/kafka/commit/5a000782bb8e9e9c95b707b713dfb7c890eda2f1", "message": "Address Jun's comments", "committedDate": "2020-08-05T17:55:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyMDczNg==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465920736", "bodyText": "Could we document how this quota behaves differently from existing quota?", "author": "junrao", "createdAt": "2020-08-05T18:27:17Z", "path": "clients/src/main/java/org/apache/kafka/common/metrics/stats/TokenBucket.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics.stats;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.MeasurableStat;\n+import org.apache.kafka.common.metrics.MetricConfig;\n+import org.apache.kafka.common.metrics.Quota;\n+\n+import static org.apache.kafka.common.metrics.internals.MetricsUtils.convert;\n+\n+/**\n+ * The {@link TokenBucket} is a {@link MeasurableStat} implementing a token bucket algorithm\n+ * that is usable within a {@link org.apache.kafka.common.metrics.Sensor}.\n+ *\n+ * The {@link Quota#bound()} defined the refill rate of the bucket while the maximum burst or\n+ * the maximum number of credits of the bucket is defined by\n+ * {@link MetricConfig#samples() * MetricConfig#timeWindowMs() * Quota#bound()}.\n+ *\n+ * The quota is considered as exhausted when the amount of remaining credits in the bucket", "originalCommit": "5a000782bb8e9e9c95b707b713dfb7c890eda2f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyMDkxOA==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465920918", "bodyText": "we have 10 samples now.", "author": "junrao", "createdAt": "2020-08-05T18:27:34Z", "path": "clients/src/test/java/org/apache/kafka/common/metrics/TokenBucketTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.stats.TokenBucket;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.common.utils.Time;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class TokenBucketTest {\n+    Time time;\n+\n+    @Before\n+    public void setup() {\n+        time = new MockTime(0, System.currentTimeMillis(), System.nanoTime());\n+    }\n+\n+    @Test\n+    public void testRecord() {\n+        // Rate  = 5 unit / sec\n+        // Burst = 2 * (11 - 1) = 20 units", "originalCommit": "5a000782bb8e9e9c95b707b713dfb7c890eda2f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyMTAwMQ==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465921001", "bodyText": "we have 10 samples now.", "author": "junrao", "createdAt": "2020-08-05T18:27:44Z", "path": "clients/src/test/java/org/apache/kafka/common/metrics/TokenBucketTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.stats.TokenBucket;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.common.utils.Time;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class TokenBucketTest {\n+    Time time;\n+\n+    @Before\n+    public void setup() {\n+        time = new MockTime(0, System.currentTimeMillis(), System.nanoTime());\n+    }\n+\n+    @Test\n+    public void testRecord() {\n+        // Rate  = 5 unit / sec\n+        // Burst = 2 * (11 - 1) = 20 units\n+        MetricConfig config = new MetricConfig()\n+            .quota(Quota.upperBound(5))\n+            .timeWindow(2, TimeUnit.SECONDS)\n+            .samples(10);\n+\n+        TokenBucket tk = new TokenBucket();\n+\n+        // Expect 100 credits at T\n+        assertEquals(100, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Record 60 at T, expect 13 credits\n+        tk.record(config, 60, time.milliseconds());\n+        assertEquals(40, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Advance by 2s, record 5, expect 45 credits\n+        time.sleep(2000);\n+        tk.record(config, 5, time.milliseconds());\n+        assertEquals(45, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Advance by 2s, record 60, expect -5 credits\n+        time.sleep(2000);\n+        tk.record(config, 60, time.milliseconds());\n+        assertEquals(-5, tk.measure(config, time.milliseconds()), 0.1);\n+    }\n+\n+    @Test\n+    public void testUnrecord() {\n+        // Rate  = 5 unit / sec\n+        // Burst = 2 * (11 - 1) = 20 units", "originalCommit": "5a000782bb8e9e9c95b707b713dfb7c890eda2f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyMTcxMA==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465921710", "bodyText": "Is the test based on 10 samples?", "author": "junrao", "createdAt": "2020-08-05T18:29:05Z", "path": "clients/src/test/java/org/apache/kafka/common/metrics/SensorTest.java", "diffHunk": "@@ -209,4 +212,95 @@ public void shouldReturnPresenceOfMetrics() {\n \n         assertThat(sensor.hasMetrics(), is(true));\n     }\n+\n+    @Test\n+    public void testStrictQuotaEnforcementWithRate() {\n+        final Time time = new MockTime(0, System.currentTimeMillis(), 0);\n+        final Metrics metrics = new Metrics(time);\n+        final Sensor sensor = metrics.sensor(\"sensor\", new MetricConfig()\n+            .quota(Quota.upperBound(2))\n+            .timeWindow(1, TimeUnit.SECONDS)\n+            .samples(11));", "originalCommit": "5a000782bb8e9e9c95b707b713dfb7c890eda2f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk2ODM2OQ==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465968369", "bodyText": "The config is correct. 11 samples. With the few samples in the test, the total window is actually 10s. This is why I use 10 in the formulas.", "author": "dajac", "createdAt": "2020-08-05T19:57:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyMTcxMA=="}], "type": "inlineReview"}, {"oid": "e1295d63a8600ca22cc598a3ae3d28bea41267f2", "url": "https://github.com/apache/kafka/commit/e1295d63a8600ca22cc598a3ae3d28bea41267f2", "message": "address Jun's comments", "committedDate": "2020-08-05T19:54:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4OTgwMA==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465989800", "bodyText": "\"this until it is\" doesn't quite parse.", "author": "junrao", "createdAt": "2020-08-05T20:38:48Z", "path": "clients/src/main/java/org/apache/kafka/common/metrics/stats/TokenBucket.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics.stats;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.MeasurableStat;\n+import org.apache.kafka.common.metrics.MetricConfig;\n+import org.apache.kafka.common.metrics.Quota;\n+\n+import static org.apache.kafka.common.metrics.internals.MetricsUtils.convert;\n+\n+/**\n+ * The {@link TokenBucket} is a {@link MeasurableStat} implementing a token bucket algorithm\n+ * that is usable within a {@link org.apache.kafka.common.metrics.Sensor}.\n+ *\n+ * The {@link Quota#bound()} defined the refill rate of the bucket while the maximum burst or\n+ * the maximum number of credits of the bucket is defined by\n+ * {@link MetricConfig#samples() * MetricConfig#timeWindowMs() * Quota#bound()}.\n+ *\n+ * The quota is considered as exhausted when the amount of remaining credits in the bucket\n+ * is below zero. The enforcement is done by the {@link org.apache.kafka.common.metrics.Sensor}.\n+ *\n+ * Token Bucket vs Rate based Quota:\n+ * The current sampled rate based quota does not cope well with bursty workloads. The issue is\n+ * that a unique and large sample can hold the average above the quota and this until it is", "originalCommit": "e1295d63a8600ca22cc598a3ae3d28bea41267f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NzYyNA==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465997624", "bodyText": "i have removed the \"and this\". Does it parse better?", "author": "dajac", "createdAt": "2020-08-05T20:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4OTgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5MDE3NQ==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465990175", "bodyText": "\"The throttle time \" : I guess this is the expected throttle time?", "author": "junrao", "createdAt": "2020-08-05T20:39:36Z", "path": "clients/src/main/java/org/apache/kafka/common/metrics/stats/TokenBucket.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics.stats;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.MeasurableStat;\n+import org.apache.kafka.common.metrics.MetricConfig;\n+import org.apache.kafka.common.metrics.Quota;\n+\n+import static org.apache.kafka.common.metrics.internals.MetricsUtils.convert;\n+\n+/**\n+ * The {@link TokenBucket} is a {@link MeasurableStat} implementing a token bucket algorithm\n+ * that is usable within a {@link org.apache.kafka.common.metrics.Sensor}.\n+ *\n+ * The {@link Quota#bound()} defined the refill rate of the bucket while the maximum burst or\n+ * the maximum number of credits of the bucket is defined by\n+ * {@link MetricConfig#samples() * MetricConfig#timeWindowMs() * Quota#bound()}.\n+ *\n+ * The quota is considered as exhausted when the amount of remaining credits in the bucket\n+ * is below zero. The enforcement is done by the {@link org.apache.kafka.common.metrics.Sensor}.\n+ *\n+ * Token Bucket vs Rate based Quota:\n+ * The current sampled rate based quota does not cope well with bursty workloads. The issue is\n+ * that a unique and large sample can hold the average above the quota and this until it is\n+ * discarded. Practically, when this happens, one must wait until the sample is expired to\n+ * bring the rate below the quota even though less time would be theoretically required. As an\n+ * examples, let's imagine that we have:\n+ * - Quota (Q)   = 5\n+ * - Samples (S) = 100\n+ * - Window (W)  = 1s\n+ * A burst of 560 brings the average rate (R) to 5.6 (560 / 100). The throttle time is computed as", "originalCommit": "e1295d63a8600ca22cc598a3ae3d28bea41267f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NzgxMA==", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465997810", "bodyText": "Yes, that is correct. I have added \"expected\" to be clearer.", "author": "dajac", "createdAt": "2020-08-05T20:54:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5MDE3NQ=="}], "type": "inlineReview"}, {"oid": "feb0dade0e9caf1794fb4f687e324bad7806d213", "url": "https://github.com/apache/kafka/commit/feb0dade0e9caf1794fb4f687e324bad7806d213", "message": "fixup", "committedDate": "2020-08-05T20:53:06Z", "type": "commit"}]}