{"pr_number": 8376, "pr_title": "KAFKA-9724 Newer clients not always sending fetch request to older brokers", "pr_createdAt": "2020-03-27T20:25:25Z", "pr_url": "https://github.com/apache/kafka/pull/8376", "timeline": [{"oid": "c7ba8d57f4f51f9eadfe80a253cf4ae048db1a8d", "url": "https://github.com/apache/kafka/commit/c7ba8d57f4f51f9eadfe80a253cf4ae048db1a8d", "message": "AWAITING_VALIDATION state causing clients to skip sending fetches to older broker", "committedDate": "2020-03-27T19:46:27Z", "type": "commit"}, {"oid": "4a461ec53379fd32dbb7142e7791bcdb51c53262", "url": "https://github.com/apache/kafka/commit/4a461ec53379fd32dbb7142e7791bcdb51c53262", "message": "Don't overwrite a partition's last seen epoch if it wasn't set already", "committedDate": "2020-04-07T03:20:30Z", "type": "commit"}, {"oid": "349d7e42bc6dcf7dc7bb193cb427a6ff19f8be66", "url": "https://github.com/apache/kafka/commit/349d7e42bc6dcf7dc7bb193cb427a6ff19f8be66", "message": "Actually implement the new logic", "committedDate": "2020-04-07T15:36:00Z", "type": "commit"}, {"oid": "8433abb86a448f0f365e0aa985a047d7af366ab0", "url": "https://github.com/apache/kafka/commit/8433abb86a448f0f365e0aa985a047d7af366ab0", "message": "Add some tests", "committedDate": "2020-04-07T15:36:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5NTUxMA==", "url": "https://github.com/apache/kafka/pull/8376#discussion_r404995510", "bodyText": "This seems unused?", "author": "hachikuji", "createdAt": "2020-04-07T17:43:12Z", "path": "clients/src/main/java/org/apache/kafka/clients/Metadata.java", "diffHunk": "@@ -178,11 +179,13 @@ public synchronized boolean updateLastSeenEpochIfNewer(TopicPartition topicParti\n      * @param topicPartition       topic+partition to update the epoch for\n      * @param epoch                the new epoch\n      * @param epochTest            a predicate to determine if the old epoch should be replaced\n+     * @param overwriteNullEpoch   if we should allow overwriting a missing epoch\n      * @return true if the epoch was updated, false otherwise\n      */\n     private synchronized boolean updateLastSeenEpoch(TopicPartition topicPartition,\n                                                      int epoch,\n-                                                     Predicate<Integer> epochTest) {\n+                                                     Predicate<Integer> epochTest,\n+                                                     boolean overwriteNullEpoch) {", "originalCommit": "4a461ec53379fd32dbb7142e7791bcdb51c53262", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA1MzQ4NA==", "url": "https://github.com/apache/kafka/pull/8376#discussion_r405053484", "bodyText": "Yea, sorry i mistakenly left out the actual changes in this commit. Will push with the tests shortly.", "author": "mumrah", "createdAt": "2020-04-07T19:19:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5NTUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5OTgyNg==", "url": "https://github.com/apache/kafka/pull/8376#discussion_r404999826", "bodyText": "I think we can simplify this a little bit. The common case is that we will have an active connection and api version information available. If we are not connected, could we just go through maybeValidatePositionForCurrentLeader. as before?", "author": "hachikuji", "createdAt": "2020-04-07T17:50:06Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/Fetcher.java", "diffHunk": "@@ -1096,9 +1096,26 @@ Node selectReadReplica(TopicPartition partition, Node leaderReplica, long curren\n     private Map<Node, FetchSessionHandler.FetchRequestData> prepareFetchRequests() {\n         Map<Node, FetchSessionHandler.Builder> fetchable = new LinkedHashMap<>();\n \n-        // Ensure the position has an up-to-date leader\n-        subscriptions.assignedPartitions().forEach(\n-            tp -> subscriptions.maybeValidatePositionForCurrentLeader(tp, metadata.currentLeader(tp)));\n+        // Ensure the position has an up-to-date leader, if the leader is set and it's ApiVersion is new enough\n+        subscriptions.assignedPartitions().forEach(tp -> {\n+            Metadata.LeaderAndEpoch leaderAndEpoch = metadata.currentLeader(tp);\n+            final boolean offsetForEpochAvailable;", "originalCommit": "4a461ec53379fd32dbb7142e7791bcdb51c53262", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "567dc2d0261820205061a47c26e1ee0892ebac88", "url": "https://github.com/apache/kafka/commit/567dc2d0261820205061a47c26e1ee0892ebac88", "message": "Simply logic for completing validation in prepareFetchRequests", "committedDate": "2020-04-07T18:29:31Z", "type": "commit"}, {"oid": "48605dc90f953f89def1c055272e4696dfbd4779", "url": "https://github.com/apache/kafka/commit/48605dc90f953f89def1c055272e4696dfbd4779", "message": "Feedback from PR", "committedDate": "2020-04-07T19:30:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExODA5Mw==", "url": "https://github.com/apache/kafka/pull/8376#discussion_r405118093", "bodyText": "I removed this since at this point the two callers have different needs for updating the epoch and adding a flag felt pretty kludgy", "author": "mumrah", "createdAt": "2020-04-07T21:16:24Z", "path": "clients/src/main/java/org/apache/kafka/clients/Metadata.java", "diffHunk": "@@ -172,29 +189,6 @@ public synchronized boolean updateLastSeenEpochIfNewer(TopicPartition topicParti\n         return Optional.ofNullable(lastSeenLeaderEpochs.get(topicPartition));\n     }\n \n-    /**\n-     * Conditionally update the leader epoch for a partition\n-     *\n-     * @param topicPartition       topic+partition to update the epoch for\n-     * @param epoch                the new epoch\n-     * @param epochTest            a predicate to determine if the old epoch should be replaced\n-     * @return true if the epoch was updated, false otherwise\n-     */\n-    private synchronized boolean updateLastSeenEpoch(TopicPartition topicPartition,", "originalCommit": "48605dc90f953f89def1c055272e4696dfbd4779", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExOTEwMg==", "url": "https://github.com/apache/kafka/pull/8376#discussion_r405119102", "bodyText": "After removing the updateLastSeenEpoch private method, there wasn't much point in this test. The epoch update is covered better in other tests anyways", "author": "mumrah", "createdAt": "2020-04-07T21:18:30Z", "path": "clients/src/test/java/org/apache/kafka/clients/MetadataTest.java", "diffHunk": "@@ -378,26 +382,6 @@ public void testRejectOldMetadata() {\n         }\n     }\n \n-    @Test\n-    public void testMaybeRequestUpdate() {", "originalCommit": "48605dc90f953f89def1c055272e4696dfbd4779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwMzUyMQ==", "url": "https://github.com/apache/kafka/pull/8376#discussion_r405703521", "bodyText": "Why would removal of a private method make this test less relevant? Which test case already covers this?", "author": "hachikuji", "createdAt": "2020-04-08T17:47:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExOTEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcxODMxNg==", "url": "https://github.com/apache/kafka/pull/8376#discussion_r405718316", "bodyText": "Removing the private updateLastSeenEpoch isn't really relevant actually, you're right. This test was simulating the epoch getting updated by something other than the metadata response. This is now covered by the new test cases in FetcherTest, but that's an indirect test.\nI'll revert this and update the test", "author": "mumrah", "createdAt": "2020-04-08T18:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExOTEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyMjkyNw==", "url": "https://github.com/apache/kafka/pull/8376#discussion_r426722927", "bodyText": "I ended up writing a new test testUpdateLastEpoch", "author": "mumrah", "createdAt": "2020-05-18T15:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExOTEwMg=="}], "type": "inlineReview"}, {"oid": "ce38b74de19dfa90e529d5b841c0e573a2958b34", "url": "https://github.com/apache/kafka/commit/ce38b74de19dfa90e529d5b841c0e573a2958b34", "message": "checkstyle", "committedDate": "2020-04-08T15:49:20Z", "type": "commit"}, {"oid": "45c20d8a53ef02b40b953d14c7f6f03e72c7fa05", "url": "https://github.com/apache/kafka/commit/45c20d8a53ef02b40b953d14c7f6f03e72c7fa05", "message": "Merge remote-tracking branch 'apache-github/trunk' into KAFKA-9724", "committedDate": "2020-04-08T15:49:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY5NDA2MA==", "url": "https://github.com/apache/kafka/pull/8376#discussion_r405694060", "bodyText": "It might be useful to mention here that this method is reserved for cases where the leader epoch is derived from some external source (such as committed offsets or fetched records). Maybe also document the returned value.", "author": "hachikuji", "createdAt": "2020-04-08T17:30:33Z", "path": "clients/src/main/java/org/apache/kafka/clients/Metadata.java", "diffHunk": "@@ -156,14 +155,31 @@ public synchronized int requestUpdateForNewTopics() {\n     }\n \n     /**\n-     * Request an update for the partition metadata iff the given leader epoch is newer than the last seen leader epoch\n+     * Request an update for the partition metadata iff we encounter a leader epoch that is newer than the last seen leader epoch", "originalCommit": "45c20d8a53ef02b40b953d14c7f6f03e72c7fa05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY5NTQyMw==", "url": "https://github.com/apache/kafka/pull/8376#discussion_r405695423", "bodyText": "nit: add partition to this message?", "author": "hachikuji", "createdAt": "2020-04-08T17:32:58Z", "path": "clients/src/main/java/org/apache/kafka/clients/Metadata.java", "diffHunk": "@@ -156,14 +155,31 @@ public synchronized int requestUpdateForNewTopics() {\n     }\n \n     /**\n-     * Request an update for the partition metadata iff the given leader epoch is newer than the last seen leader epoch\n+     * Request an update for the partition metadata iff we encounter a leader epoch that is newer than the last seen leader epoch\n      */\n     public synchronized boolean updateLastSeenEpochIfNewer(TopicPartition topicPartition, int leaderEpoch) {\n         Objects.requireNonNull(topicPartition, \"TopicPartition cannot be null\");\n         if (leaderEpoch < 0)\n             throw new IllegalArgumentException(\"Invalid leader epoch \" + leaderEpoch + \" (must be non-negative)\");\n \n-        boolean updated = updateLastSeenEpoch(topicPartition, leaderEpoch, oldEpoch -> leaderEpoch > oldEpoch);\n+        Integer oldEpoch = lastSeenLeaderEpochs.get(topicPartition);\n+        log.trace(\"Determining if we should replace existing epoch {} with new epoch {}\", oldEpoch, leaderEpoch);", "originalCommit": "45c20d8a53ef02b40b953d14c7f6f03e72c7fa05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY5NTk4NQ==", "url": "https://github.com/apache/kafka/pull/8376#discussion_r405695985", "bodyText": "nit: could we collapse this with else if", "author": "hachikuji", "createdAt": "2020-04-08T17:33:56Z", "path": "clients/src/main/java/org/apache/kafka/clients/Metadata.java", "diffHunk": "@@ -156,14 +155,31 @@ public synchronized int requestUpdateForNewTopics() {\n     }\n \n     /**\n-     * Request an update for the partition metadata iff the given leader epoch is newer than the last seen leader epoch\n+     * Request an update for the partition metadata iff we encounter a leader epoch that is newer than the last seen leader epoch\n      */\n     public synchronized boolean updateLastSeenEpochIfNewer(TopicPartition topicPartition, int leaderEpoch) {\n         Objects.requireNonNull(topicPartition, \"TopicPartition cannot be null\");\n         if (leaderEpoch < 0)\n             throw new IllegalArgumentException(\"Invalid leader epoch \" + leaderEpoch + \" (must be non-negative)\");\n \n-        boolean updated = updateLastSeenEpoch(topicPartition, leaderEpoch, oldEpoch -> leaderEpoch > oldEpoch);\n+        Integer oldEpoch = lastSeenLeaderEpochs.get(topicPartition);\n+        log.trace(\"Determining if we should replace existing epoch {} with new epoch {}\", oldEpoch, leaderEpoch);\n+\n+        final boolean updated;\n+        if (oldEpoch == null) {\n+            log.debug(\"Not replacing null epoch with new epoch {} for partition {}\", leaderEpoch, topicPartition);\n+            updated = false;\n+        } else {\n+            if (leaderEpoch > oldEpoch) {", "originalCommit": "45c20d8a53ef02b40b953d14c7f6f03e72c7fa05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwMDk4Nw==", "url": "https://github.com/apache/kafka/pull/8376#discussion_r405700987", "bodyText": "Would it make sense to push this check into maybeValidatePositionForCurrentLeader by passing through ApiVersions?  Otherwise, some of the checks here are redundant.", "author": "hachikuji", "createdAt": "2020-04-08T17:42:29Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/Fetcher.java", "diffHunk": "@@ -1098,8 +1098,20 @@ Node selectReadReplica(TopicPartition partition, Node leaderReplica, long curren\n         Map<Node, FetchSessionHandler.Builder> fetchable = new LinkedHashMap<>();\n \n         // Ensure the position has an up-to-date leader\n-        subscriptions.assignedPartitions().forEach(\n-            tp -> subscriptions.maybeValidatePositionForCurrentLeader(tp, metadata.currentLeader(tp)));\n+        subscriptions.assignedPartitions().forEach(tp -> {\n+            Metadata.LeaderAndEpoch leaderAndEpoch = metadata.currentLeader(tp);\n+            if (leaderAndEpoch.leader.isPresent()) {\n+                NodeApiVersions nodeApiVersions = apiVersions.get(leaderAndEpoch.leader.get().idString());", "originalCommit": "45c20d8a53ef02b40b953d14c7f6f03e72c7fa05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcxMTY5Ng==", "url": "https://github.com/apache/kafka/pull/8376#discussion_r405711696", "bodyText": "If we do this, do you think we should automatically call completeValidation from maybeValidatePositionForCurrentLeader (if the checks pass)", "author": "mumrah", "createdAt": "2020-04-08T18:00:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwMDk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzNTA5OA==", "url": "https://github.com/apache/kafka/pull/8376#discussion_r427535098", "bodyText": "Yes, that makes sense to me.", "author": "hachikuji", "createdAt": "2020-05-19T19:06:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwMDk4Nw=="}], "type": "inlineReview"}, {"oid": "c8d4a8c5e76d9788a6669a1095103ac0f0fdfe17", "url": "https://github.com/apache/kafka/commit/c8d4a8c5e76d9788a6669a1095103ac0f0fdfe17", "message": "Add unit test for epoch updates in MetadataTest", "committedDate": "2020-04-08T19:46:34Z", "type": "commit"}, {"oid": "7a1d6e699d3c01f8312151b637fa1d4a6dd1a6a7", "url": "https://github.com/apache/kafka/commit/7a1d6e699d3c01f8312151b637fa1d4a6dd1a6a7", "message": "Merge remote-tracking branch 'apache-github/trunk' into KAFKA-9724", "committedDate": "2020-05-18T15:32:52Z", "type": "commit"}, {"oid": "e05d8ad9e0ab0c1c7372c4f353fa41fdbafd1724", "url": "https://github.com/apache/kafka/commit/e05d8ad9e0ab0c1c7372c4f353fa41fdbafd1724", "message": "Update javadoc for updateLastSeenEpochIfNewer", "committedDate": "2020-05-18T15:50:13Z", "type": "commit"}, {"oid": "aa87a4bd9d37323dc1eafd83f7d23308ceaa14c7", "url": "https://github.com/apache/kafka/commit/aa87a4bd9d37323dc1eafd83f7d23308ceaa14c7", "message": "Push logic into maybeValidatePositionForCurrentLeader", "committedDate": "2020-05-22T15:43:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMyMzM5NQ==", "url": "https://github.com/apache/kafka/pull/8376#discussion_r429323395", "bodyText": "I wonder, do we really need this call here? If the leader is not present the epoch shouldn't be present either -- right? If that's the case, then the call to maybeValidatePosition will short circuit\n        private boolean maybeValidatePosition(Metadata.LeaderAndEpoch currentLeaderAndEpoch) {\n            if (this.fetchState.equals(FetchStates.AWAIT_RESET)) {\n                return false;\n            }\n\n            if (!currentLeaderAndEpoch.leader.isPresent() && !currentLeaderAndEpoch.epoch.isPresent()) {\n                return false;\n            }\n\n            if (position != null && !position.currentLeader.equals(currentLeaderAndEpoch)) {\n                FetchPosition newPosition = new FetchPosition(position.offset, position.offsetEpoch, currentLeaderAndEpoch);\n                validatePosition(newPosition);\n                preferredReadReplica = null;\n            }\n            return this.fetchState.equals(FetchStates.AWAIT_VALIDATION);\n        }", "author": "mumrah", "createdAt": "2020-05-22T15:46:30Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/SubscriptionState.java", "diffHunk": "@@ -422,8 +427,29 @@ public synchronized void position(TopicPartition tp, FetchPosition position) {\n         assignedState(tp).position(position);\n     }\n \n-    public synchronized boolean maybeValidatePositionForCurrentLeader(TopicPartition tp, Metadata.LeaderAndEpoch leaderAndEpoch) {\n-        return assignedState(tp).maybeValidatePosition(leaderAndEpoch);\n+    /**\n+     * Enter the offset validation state if the leader for this partition is known to support a usable version of the\n+     * OffsetsForLeaderEpoch API. If the leader node does not support the API, simply complete the offset validation.\n+     *\n+     * @param apiVersions\n+     * @param tp\n+     * @param leaderAndEpoch\n+     * @return true if we enter the offset validation state\n+     */\n+    public synchronized boolean maybeValidatePositionForCurrentLeader(ApiVersions apiVersions, TopicPartition tp,\n+                                                                      Metadata.LeaderAndEpoch leaderAndEpoch) {\n+        if (leaderAndEpoch.leader.isPresent()) {\n+            NodeApiVersions nodeApiVersions = apiVersions.get(leaderAndEpoch.leader.get().idString());\n+            if (nodeApiVersions == null || hasUsableOffsetForLeaderEpochVersion(nodeApiVersions)) {\n+                return assignedState(tp).maybeValidatePosition(leaderAndEpoch);\n+            } else {\n+                // If the broker does not support a newer version of OffsetsForLeaderEpoch, we skip validation\n+                completeValidation(tp);\n+                return false;\n+            }\n+        } else {\n+            return assignedState(tp).maybeValidatePosition(leaderAndEpoch);", "originalCommit": "aa87a4bd9d37323dc1eafd83f7d23308ceaa14c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMyNTA0OQ==", "url": "https://github.com/apache/kafka/pull/8376#discussion_r429325049", "bodyText": "Oh, actually looking at the javadoc for LeaderAndEpoch, I see\n\nIt is also possible that we know of the leader epoch, but not the leader when it is derived from an external source (e.g. a committed offset).\n\nAlso in Metadata, we do return a LeaderAndEpoch with the last-seen epoch, but no leader if the metadata is stale. So, I guess it makes sense to keep this call in maybeValidatePositionForCurrentLeader", "author": "mumrah", "createdAt": "2020-05-22T15:49:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMyMzM5NQ=="}], "type": "inlineReview"}, {"oid": "37bb3a5bb82f206f6df9e46f267f2143813c8980", "url": "https://github.com/apache/kafka/commit/37bb3a5bb82f206f6df9e46f267f2143813c8980", "message": "Checkstyle", "committedDate": "2020-05-26T14:50:08Z", "type": "commit"}]}