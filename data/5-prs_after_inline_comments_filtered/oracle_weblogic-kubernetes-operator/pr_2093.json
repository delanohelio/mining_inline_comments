{"pr_number": 2093, "pr_title": "OWLS-86407 - Fixed the logic to start clustered managed server pods when admin server pod not running", "pr_createdAt": "2020-12-09T16:56:38Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2093", "timeline": [{"oid": "a1f8aa8d34577cd254342137c23e707c08c5a7f2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a1f8aa8d34577cd254342137c23e707c08c5a7f2", "message": "OWLS-86407 - Fixed logic to start clustered managed server pods when admin server pod is not running", "committedDate": "2020-12-08T17:43:35Z", "type": "commit"}, {"oid": "848221cf90236ff3a50ada3e1be7b8b2f727c63c", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/848221cf90236ff3a50ada3e1be7b8b2f727c63c", "message": "minor change", "committedDate": "2020-12-08T21:04:30Z", "type": "commit"}, {"oid": "b1214a384ebe9d829456d17ffa4a675c19441fb5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b1214a384ebe9d829456d17ffa4a675c19441fb5", "message": "Add a unit test case for OWLS-86407", "committedDate": "2020-12-09T16:49:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcxNjk5MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2093#discussion_r539716990", "bodyText": "Please get in the habit of writing your unit tests before you make production code changes. It not only guides what you then implement, it also leads to writing better tests.\nStart with the name. It should explain what is going on, and this doesn't, as it is simply not the case that we always want to start a managed server pod when there is no admin server. The case, based on the JIRA, is that if we scale up a cluster, we will start a managed server even if the admin server is not running, and the test should reflect that. So maybe something like 'whileAdminServerStopped_canStartManagedServer' would be better.\nIn the body of the test the first call is to createDomainPresenceInfoWithServers(). It is really hard to tell what that is doing here. In the current test class, it was called exactly once: passing the name of the admin server, to indicate that was already running. Remember Robert Martin's admonition on names, I would probably create a new method that does what this call does, but is named createDomainPresenceInfoWithNoAdminServer. Perhaps we need, then, another call named createDomainPresenceInfoWithAdminServer to make it clearer. Since there are no invocations that actually pass in more servers, that should suffice.", "author": "russgold", "createdAt": "2020-12-09T23:10:31Z", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStepTest.java", "diffHunk": "@@ -249,6 +248,19 @@ public void whenConcurrencyLimitIs1_secondClusteredServerDoesNotStartIfFirstIsNo\n     assertThat(getStartedManagedServers(), hasSize(1));\n   }\n ", "originalCommit": "b1214a384ebe9d829456d17ffa4a675c19441fb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMwNDIxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2093#discussion_r540304214", "bodyText": "Changed the unit test method name and added new method createDomainPresenceInfoWithNoAdminServer as suggested.", "author": "ankedia", "createdAt": "2020-12-10T16:20:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcxNjk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc0Nzg0Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2093#discussion_r539747842", "bodyText": "This is really unclear. The old call seemed to indicate that we were getting the number of managed servers in the specified cluster. Why do we also pass in \"admin-server\"? The interface is problematic.", "author": "russgold", "createdAt": "2020-12-10T00:20:28Z", "path": "operator/src/test/java/oracle/kubernetes/operator/helpers/DomainPresenceInfoTest.java", "diffHunk": "@@ -128,9 +128,9 @@ public void countScheduledServers() {\n     addServer(\"MS5\", null);\n     addScheduledServer(\"MS6\", null);\n \n-    assertThat(info.getNumScheduledServers(\"cluster1\"), equalTo(2L));\n-    assertThat(info.getNumScheduledServers(\"cluster2\"), equalTo(2L));\n-    assertThat(info.getNumScheduledServers(null), equalTo(1L));\n+    assertThat(info.getNumScheduledManagedServers(\"cluster1\", \"admin-server\"), equalTo(2L));", "originalCommit": "b1214a384ebe9d829456d17ffa4a675c19441fb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMwODA5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2093#discussion_r540308097", "bodyText": "Previous call used to get both admin server (if scheduled) and managed servers that are scheduled. I was passing in the admin-server so that admin server can be filtered out from list and only scheduled managed servers are returned. My latest change adds a new method so original unit test stays the same.", "author": "ankedia", "createdAt": "2020-12-10T16:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc0Nzg0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3NzM5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2093#discussion_r540877397", "bodyText": "So the problem is that DomainPresenceInfo doesn't know which server is the admin server. I think we should address that, but not right now, perhaps, as I don't see an easy and obvious solution.", "author": "russgold", "createdAt": "2020-12-11T11:21:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc0Nzg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MTMzOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2093#discussion_r539751339", "bodyText": "This would be a good time to do some refactoring. The expression is not so easy to read and understand.\nI would start by extracting maxConcurrency == 0 into a method named 'ignoreConcurrencyLimits' and list that first in the expression, not last. Then you don't really need this.maxConcurrency > 0 as that is implied (unless there is some support for negative values).\nThe remaining part is still too complex and not obvious. So extract numStarted.get() into its own method, getNumServersStarted as there is no reason for all of the callers to know that there is an Atomic backing the value. Then can you explain what the rest of the logic is?", "author": "russgold", "createdAt": "2020-12-10T00:29:00Z", "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStep.java", "diffHunk": "@@ -168,21 +171,23 @@ public NextAction apply(Packet packet) {\n \n       if (startDetailsQueue.isEmpty()) {\n         return doNext(new ManagedServerUpAfterStep(getNext()), packet);\n-      } else if (hasServerAvailableToStart(packet.getSpi(DomainPresenceInfo.class))) {\n+      } else if (hasServerAvailableToStart(packet)) {\n         numStarted.getAndIncrement();\n         return doForkJoin(this, packet, Collections.singletonList(startDetailsQueue.poll()));\n       } else {\n         return doDelay(this, packet, SCHEDULING_DETECTION_DELAY, TimeUnit.MILLISECONDS);\n       }\n     }\n \n-    private boolean hasServerAvailableToStart(DomainPresenceInfo info) {\n-      return ((numStarted.get() < info.getNumScheduledServers(clusterName))\n-              && (canStartConcurrently(info.getNumReadyServers(clusterName))));\n+    private boolean hasServerAvailableToStart(Packet packet) {\n+      DomainPresenceInfo info = packet.getSpi(DomainPresenceInfo.class);\n+      String adminServerName = ((WlsDomainConfig) packet.get(DOMAIN_TOPOLOGY)).getAdminServerName();\n+      return ((numStarted.get() <= info.getNumScheduledManagedServers(clusterName, adminServerName)\n+              && (canStartConcurrently(info.getNumReadyManagedServers(clusterName, adminServerName)))));\n     }\n \n     private boolean canStartConcurrently(long numReady) {\n-      return ((this.maxConcurrency > 0) && (numStarted.get() < (this.maxConcurrency + numReady - 1)))\n+      return ((this.maxConcurrency > 0) && (numStarted.get() < (this.maxConcurrency + numReady)))", "originalCommit": "b1214a384ebe9d829456d17ffa4a675c19441fb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMxOTkwNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2093#discussion_r540319905", "bodyText": "Made the refactoring changes. The remaining logic is to check if the number of started servers is less than (maxConcurrency + ready managed servers for cluster \"clusterName\"). So if maxConcurrency is 1 and one server is started, it'll wait for that server to come to ready state before starting a new server. Please see #1855 (comment) for the pseudo code of this logic.", "author": "ankedia", "createdAt": "2020-12-10T16:38:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MTMzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3NjQ1MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2093#discussion_r540876451", "bodyText": "I looked at the comment. The pseudo code doesn't explain the logic, either.\nIt appears to me that the intent of numStarted < maxConcurrency + numReady is to look at the number of pods currently starting up (I think K8S calls that waiting) and compare that how many may be started at once. If so, the actual comparison should be:\n(numStarted - numReady) < maxConcurrency or\nnumWaiting < maxConcurrency.\nIf so, I would extract a numPodsWaiting method:\n// returns the number of pods currently starting up\nprivate int numWaiting(int numReady) {\n  return getNumStarted() - numReady;\n}\n\nand compare that to the maxConcurrency.", "author": "russgold", "createdAt": "2020-12-11T11:19:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MTMzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTAwMjIwMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2093#discussion_r541002200", "bodyText": "Yes, that's correct. I think k8s calls pods that are currently starting up as not ready or inactive. We can go with waiting if that clarifies the intention of code. I'll go ahead and push above change.", "author": "ankedia", "createdAt": "2020-12-11T14:52:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MTMzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTAwMzUzNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2093#discussion_r541003536", "bodyText": "\"not ready\" or \"inactive\" work, too, if that is the terminology. Let's just be consistent and use whatever the standard is.", "author": "russgold", "createdAt": "2020-12-11T14:54:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MTMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MTU4MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2093#discussion_r539751581", "bodyText": "good change. There was no need to expose the implementation as it had been.", "author": "russgold", "createdAt": "2020-12-10T00:29:37Z", "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStep.java", "diffHunk": "@@ -168,21 +171,23 @@ public NextAction apply(Packet packet) {\n \n       if (startDetailsQueue.isEmpty()) {\n         return doNext(new ManagedServerUpAfterStep(getNext()), packet);\n-      } else if (hasServerAvailableToStart(packet.getSpi(DomainPresenceInfo.class))) {\n+      } else if (hasServerAvailableToStart(packet)) {", "originalCommit": "b1214a384ebe9d829456d17ffa4a675c19441fb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d6821af45f0b617c6300edcf65d349fc7a568540", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d6821af45f0b617c6300edcf65d349fc7a568540", "message": "changes to address PR review comments.", "committedDate": "2020-12-10T16:16:04Z", "type": "commit"}, {"oid": "cffde403c130da401fac101e168dbd8207a7d6f7", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cffde403c130da401fac101e168dbd8207a7d6f7", "message": "PR review comments.", "committedDate": "2020-12-10T16:31:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMzODYyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2093#discussion_r540338629", "bodyText": "You should no longer need (this.maxConcurrency > 0) here, as you cannot reach this condition when it is 0.\nCan you explain the logic in the rest of the expression? Why can you start a new server when the number of servers started is less than the concurrency limit added to the number ready?", "author": "russgold", "createdAt": "2020-12-10T17:00:57Z", "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStep.java", "diffHunk": "@@ -182,13 +182,21 @@ public NextAction apply(Packet packet) {\n     private boolean hasServerAvailableToStart(Packet packet) {\n       DomainPresenceInfo info = packet.getSpi(DomainPresenceInfo.class);\n       String adminServerName = ((WlsDomainConfig) packet.get(DOMAIN_TOPOLOGY)).getAdminServerName();\n-      return ((numStarted.get() <= info.getNumScheduledManagedServers(clusterName, adminServerName)\n+      return ((getNumServersStarted() <= info.getNumScheduledManagedServers(clusterName, adminServerName)\n               && (canStartConcurrently(info.getNumReadyManagedServers(clusterName, adminServerName)))));\n     }\n \n     private boolean canStartConcurrently(long numReady) {\n-      return ((this.maxConcurrency > 0) && (numStarted.get() < (this.maxConcurrency + numReady)))\n-          || (this.maxConcurrency == 0);\n+      return (ignoreConcurrencyLimits() ||\n+              (this.maxConcurrency > 0) && (getNumServersStarted() < (this.maxConcurrency + numReady)));", "originalCommit": "cffde403c130da401fac101e168dbd8207a7d6f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM3Mjk1Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2093#discussion_r540372952", "bodyText": "ok, I'll make the change. As per OWLS-83431, we want to start one clustered server at a time and wait for it be scheduled before starting a new server in same cluster. So number of started servers in a cluster should be less than or equal to number of scheduled servers in that cluster. Initially when there are no servers scheduled, it'll start one server and wait for it be scheduled before starting second server. The scheduling happens very fast (few milli-seconds). Please see #1855 (comment) for more details.", "author": "ankedia", "createdAt": "2020-12-10T17:47:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMzODYyOQ=="}], "type": "inlineReview"}, {"oid": "94a59670a1640c927131559e62550e2991bfc26b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/94a59670a1640c927131559e62550e2991bfc26b", "message": "Remove redundant condition.", "committedDate": "2020-12-10T19:00:37Z", "type": "commit"}, {"oid": "6cc07198104c0563d8d622ce1de72128a09c62b4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6cc07198104c0563d8d622ce1de72128a09c62b4", "message": "Refactoring change as per the review comment.", "committedDate": "2020-12-11T15:15:30Z", "type": "commit"}, {"oid": "482dc9ac0f455251a19690afb9b18b74717d72d7", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/482dc9ac0f455251a19690afb9b18b74717d72d7", "message": "Chnaged method name to be consistent.", "committedDate": "2020-12-11T15:19:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTAyMTkzNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2093#discussion_r541021934", "bodyText": "Shouldn't the parentheses be around the expression on the right, not the entire condition? Does Intellij not highlight it for you?", "author": "russgold", "createdAt": "2020-12-11T15:20:07Z", "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStep.java", "diffHunk": "@@ -168,22 +171,35 @@ public NextAction apply(Packet packet) {\n \n       if (startDetailsQueue.isEmpty()) {\n         return doNext(new ManagedServerUpAfterStep(getNext()), packet);\n-      } else if (hasServerAvailableToStart(packet.getSpi(DomainPresenceInfo.class))) {\n+      } else if (hasServerAvailableToStart(packet)) {\n         numStarted.getAndIncrement();\n         return doForkJoin(this, packet, Collections.singletonList(startDetailsQueue.poll()));\n       } else {\n         return doDelay(this, packet, SCHEDULING_DETECTION_DELAY, TimeUnit.MILLISECONDS);\n       }\n     }\n \n-    private boolean hasServerAvailableToStart(DomainPresenceInfo info) {\n-      return ((numStarted.get() < info.getNumScheduledServers(clusterName))\n-              && (canStartConcurrently(info.getNumReadyServers(clusterName))));\n+    private boolean hasServerAvailableToStart(Packet packet) {\n+      DomainPresenceInfo info = packet.getSpi(DomainPresenceInfo.class);\n+      String adminServerName = ((WlsDomainConfig) packet.get(DOMAIN_TOPOLOGY)).getAdminServerName();\n+      return ((getNumServersStarted() <= info.getNumScheduledManagedServers(clusterName, adminServerName)\n+              && (canStartConcurrently(info.getNumReadyManagedServers(clusterName, adminServerName)))));\n     }\n \n     private boolean canStartConcurrently(long numReady) {\n-      return ((this.maxConcurrency > 0) && (numStarted.get() < (this.maxConcurrency + numReady - 1)))\n-          || (this.maxConcurrency == 0);\n+      return (ignoreConcurrencyLimits() || numPodsNotReady(numReady) < this.maxConcurrency);", "originalCommit": "6cc07198104c0563d8d622ce1de72128a09c62b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTAyODAwMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/2093#discussion_r541028003", "bodyText": "Huh. Apparently not.", "author": "russgold", "createdAt": "2020-12-11T15:28:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTAyMTkzNA=="}], "type": "inlineReview"}]}