{"pr_number": 1855, "pr_title": "Changes for OWLS-83431", "pr_createdAt": "2020-08-06T19:47:22Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855", "timeline": [{"oid": "4994a387983142a7ff2683faee3d28d91cf27a69", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4994a387983142a7ff2683faee3d28d91cf27a69", "message": "changes for OWLS-83431", "committedDate": "2020-08-05T16:42:41Z", "type": "commit"}, {"oid": "6dc9cdb338dd591cdae68e8037d67de050b9f6e6", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6dc9cdb338dd591cdae68e8037d67de050b9f6e6", "message": "changes for owls-83431", "committedDate": "2020-08-10T21:57:33Z", "type": "commit"}, {"oid": "619cc7da95e6fc8894291b212e93c6067d032ad6", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/619cc7da95e6fc8894291b212e93c6067d032ad6", "message": "Chnages to address PR review comments", "committedDate": "2020-08-11T14:02:01Z", "type": "commit"}, {"oid": "5b2266f0bb884a19d120fba13b109f7fc97db972", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5b2266f0bb884a19d120fba13b109f7fc97db972", "message": "changes to suppresserror from synchronous call", "committedDate": "2020-08-11T15:13:55Z", "type": "commit"}, {"oid": "beeb8e00547288ae23f5df1eb41222f080ccdee7", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/beeb8e00547288ae23f5df1eb41222f080ccdee7", "message": "cleanup changes based on PR comments", "committedDate": "2020-08-11T16:08:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzMzM1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469233353", "bodyText": "Missing Javadoc @param for clusterName", "author": "rjeberhard", "createdAt": "2020-08-12T12:48:32Z", "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/PodHelper.java", "diffHunk": "@@ -85,6 +86,59 @@ public static boolean isReady(V1Pod pod) {\n     return ready;\n   }\n \n+  /**\n+   * Get list of scheduled pods.\n+   * @param info Domain presence info\n+   * @return list containing scheduled pods", "originalCommit": "beeb8e00547288ae23f5df1eb41222f080ccdee7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1MDgxNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469250815", "bodyText": "Fixed.", "author": "ankedia", "createdAt": "2020-08-12T13:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzMzM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNDE2MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469234161", "bodyText": "I'll verify below, but it's surprising that you have a method to list scheduled pods. I would think that you would be interested in unscheduled pods.", "author": "rjeberhard", "createdAt": "2020-08-12T12:49:55Z", "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/PodHelper.java", "diffHunk": "@@ -85,6 +86,59 @@ public static boolean isReady(V1Pod pod) {\n     return ready;\n   }\n \n+  /**\n+   * Get list of scheduled pods.\n+   * @param info Domain presence info\n+   * @return list containing scheduled pods\n+   */\n+  public static List<String> getScheduledPods(DomainPresenceInfo info, String clusterName) {", "originalCommit": "beeb8e00547288ae23f5df1eb41222f080ccdee7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNDg4MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469234880", "bodyText": "Fix variable name", "author": "rjeberhard", "createdAt": "2020-08-12T12:51:04Z", "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/PodHelper.java", "diffHunk": "@@ -85,6 +86,59 @@ public static boolean isReady(V1Pod pod) {\n     return ready;\n   }\n \n+  /**\n+   * Get list of scheduled pods.\n+   * @param info Domain presence info\n+   * @return list containing scheduled pods\n+   */\n+  public static List<String> getScheduledPods(DomainPresenceInfo info, String clusterName) {\n+    // These are presently scheduled servers\n+    List<String> scheduledServers = new ArrayList<>();\n+    for (Map.Entry<String, ServerKubernetesObjects> entry : info.getServers().entrySet()) {\n+      V1Pod pod = entry.getValue().getPod().get();\n+      if (pod != null && !PodHelper.isDeleting(pod) && PodHelper.getScheduledStatus(pod)) {\n+        String wlsClusterName = pod.getMetadata().getLabels().get(CLUSTERNAME_LABEL);\n+        if ((wlsClusterName == null) || (wlsClusterName.contains(clusterName))) {\n+          scheduledServers.add(entry.getKey());\n+        }\n+      }\n+    }\n+    return scheduledServers;\n+  }\n+\n+  /**\n+   * Get list of ready pods.\n+   * @param info Domain presence info\n+   * @return list containing ready pods\n+   */\n+  public static List<String> getReadyPods(DomainPresenceInfo info, String clusterName) {\n+    // These are presently Ready servers\n+    List<String> readyServers = new ArrayList<>();\n+    for (Map.Entry<String, ServerKubernetesObjects> entry : info.getServers().entrySet()) {\n+      V1Pod pod = entry.getValue().getPod().get();\n+      if (pod != null && !PodHelper.isDeleting(pod) && PodHelper.getReadyStatus(pod)) {\n+        String wlsClusterName = pod.getMetadata().getLabels().get(CLUSTERNAME_LABEL);\n+        if ((wlsClusterName == null) || (wlsClusterName.contains(clusterName))) {\n+          readyServers.add(entry.getKey());\n+        }\n+      }\n+    }\n+    return readyServers;\n+  }\n+\n+  /**\n+   * get if pod is in scheduled state.\n+   * @param pod pod\n+   * @return true, if pod is scheduled\n+   */\n+  public static boolean getScheduledStatus(V1Pod pod) {\n+    V1PodSpec status = pod.getSpec();", "originalCommit": "beeb8e00547288ae23f5df1eb41222f080ccdee7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1MTAyNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469251026", "bodyText": "Fixed.", "author": "ankedia", "createdAt": "2020-08-12T13:16:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNDg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNzY0MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469237640", "bodyText": "What do you think about switching this to test PodHelper.unscheduledPodsExist() rather than comparing the count of scheduled pods to an expected number?", "author": "rjeberhard", "createdAt": "2020-08-12T12:55:43Z", "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStep.java", "diffHunk": "@@ -142,19 +154,53 @@ private boolean isServerInCluster(ServerStartupInfo ssi) {\n \n   static class StartManagedServersStep extends Step {\n     final Collection<StepAndPacket> startDetails;\n+    final Queue<StepAndPacket> startDetailsQueue = new ConcurrentLinkedQueue<>();\n+    final String clusterName;\n+    int numStarted = 0;\n+    int maxConcurrency = 0;\n \n-    StartManagedServersStep(Collection<StepAndPacket> startDetails, Step next) {\n+    StartManagedServersStep(String clusterName, Collection<StepAndPacket> startDetails, Step next) {\n       super(next);\n+      this.clusterName = clusterName;\n       this.startDetails = startDetails;\n+      startDetails.forEach(this::add);\n     }\n \n-    Collection<StepAndPacket> getStartDetails() {\n-      return startDetails;\n+    void add(StepAndPacket serverToStart) {\n+      startDetailsQueue.add(new StepAndPacket(serverToStart.step, serverToStart.packet));\n+      this.maxConcurrency = Optional.ofNullable(\n+              (Integer) serverToStart.packet.get(ProcessingConstants.MAX_CONCURRENCY)).orElse(0);\n     }\n \n     @Override\n     public NextAction apply(Packet packet) {\n-      return doForkJoin(new ManagedServerUpAfterStep(getNext()), packet, startDetails);\n+\n+      if (startDetailsQueue.isEmpty()) {\n+        return doNext(new ManagedServerUpAfterStep(getNext()), packet);\n+      } else if (isServiceOnlyOrShuttingDown()) {\n+        Collection<StepAndPacket> servers = Collections.singletonList(startDetailsQueue.poll());\n+        return doForkJoin(this, packet, servers);\n+      } else if (serverAvailableToStart(packet.getSpi(DomainPresenceInfo.class))) {\n+        this.numStarted++;\n+        return doForkJoin(this, packet, Collections.singletonList(startDetailsQueue.poll()));\n+      } else {\n+        return doDelay(this, packet, 100, TimeUnit.MILLISECONDS);\n+      }\n+    }\n+\n+    private boolean isServiceOnlyOrShuttingDown() {\n+      return Optional.ofNullable(startDetailsQueue.peek().step)\n+              .map(step -> step.getNext() instanceof ServerDownStep).orElse(false);\n+    }\n+\n+    private boolean serverAvailableToStart(DomainPresenceInfo info) {\n+      return ((this.numStarted < PodHelper.getScheduledPods(info, clusterName).size())", "originalCommit": "beeb8e00547288ae23f5df1eb41222f080ccdee7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI2NDk5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469264993", "bodyText": "I believe the reason I went with current count based approach is because we can only schedule/start n number pods in parallel based on value of maxConcurrency. Previously the code was creating maxConcurrency number of fibers and fibers used to wait until pod becomes ready. With current approach, I don't make the fibers wait until pod is ready but start servers (create fibers) only if all previous pods are scheduled and if it matches the criteria for maxConcurrency. I think it's possible to test  PodHelper.unscheduledPodsExist() but we need to check for number of ready pods before deciding to start a new server (start a new fiber). I can try the approach you suggested and test it out for different use-case scenarios.  Please let me know.", "author": "ankedia", "createdAt": "2020-08-12T13:37:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNzY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNzkwMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469237903", "bodyText": "What is the concurrency of this code? Will multiple threads ever be running here?", "author": "rjeberhard", "createdAt": "2020-08-12T12:56:08Z", "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStep.java", "diffHunk": "@@ -142,19 +154,53 @@ private boolean isServerInCluster(ServerStartupInfo ssi) {\n \n   static class StartManagedServersStep extends Step {\n     final Collection<StepAndPacket> startDetails;\n+    final Queue<StepAndPacket> startDetailsQueue = new ConcurrentLinkedQueue<>();\n+    final String clusterName;\n+    int numStarted = 0;\n+    int maxConcurrency = 0;\n \n-    StartManagedServersStep(Collection<StepAndPacket> startDetails, Step next) {\n+    StartManagedServersStep(String clusterName, Collection<StepAndPacket> startDetails, Step next) {\n       super(next);\n+      this.clusterName = clusterName;\n       this.startDetails = startDetails;\n+      startDetails.forEach(this::add);\n     }\n \n-    Collection<StepAndPacket> getStartDetails() {\n-      return startDetails;\n+    void add(StepAndPacket serverToStart) {\n+      startDetailsQueue.add(new StepAndPacket(serverToStart.step, serverToStart.packet));\n+      this.maxConcurrency = Optional.ofNullable(\n+              (Integer) serverToStart.packet.get(ProcessingConstants.MAX_CONCURRENCY)).orElse(0);\n     }\n \n     @Override\n     public NextAction apply(Packet packet) {\n-      return doForkJoin(new ManagedServerUpAfterStep(getNext()), packet, startDetails);\n+\n+      if (startDetailsQueue.isEmpty()) {\n+        return doNext(new ManagedServerUpAfterStep(getNext()), packet);\n+      } else if (isServiceOnlyOrShuttingDown()) {\n+        Collection<StepAndPacket> servers = Collections.singletonList(startDetailsQueue.poll());\n+        return doForkJoin(this, packet, servers);\n+      } else if (serverAvailableToStart(packet.getSpi(DomainPresenceInfo.class))) {\n+        this.numStarted++;", "originalCommit": "beeb8e00547288ae23f5df1eb41222f080ccdee7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI1MzIyOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469253228", "bodyText": "It's one thread per cluster and one thread for non-clustered servers. It'll be single threaded for one cluster and 2 threads for 2 cluster case. If domain also have non-clustered (standalone) servers, it'll create a separate fiber for those servers.", "author": "ankedia", "createdAt": "2020-08-12T13:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNzkwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI5ODUzOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469298539", "bodyText": "Let me be clearer in my question. Do I need to worry about the concurrency of updating the numStarted variable? I can't really tell from your answer.", "author": "rjeberhard", "createdAt": "2020-08-12T14:24:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNzkwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM2NTIzNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469365237", "bodyText": "Sorry for not being clear in my previous answer. In 2 cluster scenario, 2 threads could reading/updating in parallel but overall concurrency will be low. I have changed numStarted to AtomicInteger as we discussed and made numConcurrency  final by setting it in constructor. Please let me know if I missed anything. Thanks.", "author": "ankedia", "createdAt": "2020-08-12T15:53:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNzkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzODQxOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469238418", "bodyText": "Similarly, it seems like you ought to be checking for the number of unready pods.", "author": "rjeberhard", "createdAt": "2020-08-12T12:56:59Z", "path": "operator/src/main/java/oracle/kubernetes/operator/steps/ManagedServerUpIteratorStep.java", "diffHunk": "@@ -142,19 +154,53 @@ private boolean isServerInCluster(ServerStartupInfo ssi) {\n \n   static class StartManagedServersStep extends Step {\n     final Collection<StepAndPacket> startDetails;\n+    final Queue<StepAndPacket> startDetailsQueue = new ConcurrentLinkedQueue<>();\n+    final String clusterName;\n+    int numStarted = 0;\n+    int maxConcurrency = 0;\n \n-    StartManagedServersStep(Collection<StepAndPacket> startDetails, Step next) {\n+    StartManagedServersStep(String clusterName, Collection<StepAndPacket> startDetails, Step next) {\n       super(next);\n+      this.clusterName = clusterName;\n       this.startDetails = startDetails;\n+      startDetails.forEach(this::add);\n     }\n \n-    Collection<StepAndPacket> getStartDetails() {\n-      return startDetails;\n+    void add(StepAndPacket serverToStart) {\n+      startDetailsQueue.add(new StepAndPacket(serverToStart.step, serverToStart.packet));\n+      this.maxConcurrency = Optional.ofNullable(\n+              (Integer) serverToStart.packet.get(ProcessingConstants.MAX_CONCURRENCY)).orElse(0);\n     }\n \n     @Override\n     public NextAction apply(Packet packet) {\n-      return doForkJoin(new ManagedServerUpAfterStep(getNext()), packet, startDetails);\n+\n+      if (startDetailsQueue.isEmpty()) {\n+        return doNext(new ManagedServerUpAfterStep(getNext()), packet);\n+      } else if (isServiceOnlyOrShuttingDown()) {\n+        Collection<StepAndPacket> servers = Collections.singletonList(startDetailsQueue.poll());\n+        return doForkJoin(this, packet, servers);\n+      } else if (serverAvailableToStart(packet.getSpi(DomainPresenceInfo.class))) {\n+        this.numStarted++;\n+        return doForkJoin(this, packet, Collections.singletonList(startDetailsQueue.poll()));\n+      } else {\n+        return doDelay(this, packet, 100, TimeUnit.MILLISECONDS);\n+      }\n+    }\n+\n+    private boolean isServiceOnlyOrShuttingDown() {\n+      return Optional.ofNullable(startDetailsQueue.peek().step)\n+              .map(step -> step.getNext() instanceof ServerDownStep).orElse(false);\n+    }\n+\n+    private boolean serverAvailableToStart(DomainPresenceInfo info) {\n+      return ((this.numStarted < PodHelper.getScheduledPods(info, clusterName).size())\n+              && (canStartConcurrently(PodHelper.getReadyPods(info, clusterName).size())));\n+    }\n+\n+    private boolean canStartConcurrently(int numReady) {\n+      return ((this.maxConcurrency > 0) && (this.numStarted < (this.maxConcurrency + numReady - 1)))", "originalCommit": "beeb8e00547288ae23f5df1eb41222f080ccdee7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI3MDgzOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1855#discussion_r469270838", "bodyText": "Please see above comment about creating fibers based on value of maxConcurrency. I think we can't wait for all previous pods to be ready and need to check for number of ready pods in order to decide whether to create a new fiber/thread or not.", "author": "ankedia", "createdAt": "2020-08-12T13:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzODQxOA=="}], "type": "inlineReview"}, {"oid": "00edd0a490e6cdc7fe898f9fcb56c9f190ff45d5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/00edd0a490e6cdc7fe898f9fcb56c9f190ff45d5", "message": "changes to fix javadoc and variable name", "committedDate": "2020-08-12T13:14:59Z", "type": "commit"}, {"oid": "f4d2039135c2a9418483297e3b473479838ee663", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f4d2039135c2a9418483297e3b473479838ee663", "message": "changes for latest review comments", "committedDate": "2020-08-12T15:45:19Z", "type": "commit"}]}