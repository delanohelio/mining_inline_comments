{"pr_number": 1737, "pr_title": "JUnit5 JRF tests infra: DB startup and RCU schema creation", "pr_createdAt": "2020-06-15T22:01:10Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737", "timeline": [{"oid": "8431fe66701b16ef6990877a50dd08a732d36483", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8431fe66701b16ef6990877a50dd08a732d36483", "message": "first cut for junit5 JRF", "committedDate": "2020-06-08T18:31:15Z", "type": "commit"}, {"oid": "0dc8de3be05fb8e3f358dc5ac28dbba0302b93c7", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/0dc8de3be05fb8e3f358dc5ac28dbba0302b93c7", "message": "first working version", "committedDate": "2020-06-10T21:01:48Z", "type": "commit"}, {"oid": "3dde26beb1135bebe0382d97807349dcdc85dabf", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3dde26beb1135bebe0382d97807349dcdc85dabf", "message": "add the missing files", "committedDate": "2020-06-11T14:14:54Z", "type": "commit"}, {"oid": "ac18848d688a50219d80d758a6429fc93056c696", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ac18848d688a50219d80d758a6429fc93056c696", "message": "fix SSL connection closed issue and Kind image pull issue", "committedDate": "2020-06-11T21:09:22Z", "type": "commit"}, {"oid": "f8ad23e518f9460b24f32d6913b5ab571e27b879", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f8ad23e518f9460b24f32d6913b5ab571e27b879", "message": "increase retry time", "committedDate": "2020-06-12T02:14:27Z", "type": "commit"}, {"oid": "66151869f9ecec705fb35a2fd4a9f15bec75ed7a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/66151869f9ecec705fb35a2fd4a9f15bec75ed7a", "message": "ignore SSLProtocolException", "committedDate": "2020-06-12T16:02:22Z", "type": "commit"}, {"oid": "d1962c85a2e1b1a1ec6d5c6b6bb8e4b781e423bf", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d1962c85a2e1b1a1ec6d5c6b6bb8e4b781e423bf", "message": "minor change", "committedDate": "2020-06-12T18:02:25Z", "type": "commit"}, {"oid": "2d3cee06b6539bdef3ef6aea3aaa75227e4e741d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2d3cee06b6539bdef3ef6aea3aaa75227e4e741d", "message": "merge to the latest devlop branch", "committedDate": "2020-06-12T20:59:56Z", "type": "commit"}, {"oid": "b938abd359aa3d42b62dc71f546b2ec3285fc07e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b938abd359aa3d42b62dc71f546b2ec3285fc07e", "message": "cleanup the code", "committedDate": "2020-06-15T20:53:41Z", "type": "commit"}, {"oid": "553d1701be4ec7ef7870eaf9d823d7e8cfac065a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/553d1701be4ec7ef7870eaf9d823d7e8cfac065a", "message": "minor cleanup", "committedDate": "2020-06-15T21:42:44Z", "type": "commit"}, {"oid": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "message": "Merge remote-tracking branch 'origin/develop' into junit5-jrf1", "committedDate": "2020-06-15T21:47:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMTY1MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440501651", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Start DB service and create RCU schema\n          \n          \n            \n               * Start DB service and create RCU schema.", "author": "sankarpn", "createdAt": "2020-06-15T23:30:17Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "diffHunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DbUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Tests to create JRF domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItJrfDomainInPV implements LoggedTest {\n+\n+  private static String dbNamespace = null;\n+  private static String opNamespace = null;\n+  private static String jrfDomainNamespace = null;\n+\n+  private static final String RCUSCHEMAPREFIX = \"jrfdomainpv\";\n+  private static final String ORACLEDBURLPREFIX = \"oracledb.\";\n+  private static final String ORACLEDBSUFFIX = \".svc.cluster.local:1521/devpdb.k8s\";\n+\n+\n+  private static String dbUrl = null;\n+  private static int dbPort = getNextFreePort(30000, 32767);\n+\n+  private static String fmwImage = JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG;\n+  private static String dbImage = DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Start DB service and create RCU schema", "originalCommit": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNTg0Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441135843", "bodyText": "Fixed.", "author": "maggiehe00", "createdAt": "2020-06-16T20:54:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMTY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMjM3Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440502376", "bodyText": "use static imports for OCR_REGISTRY", "author": "sankarpn", "createdAt": "2020-06-15T23:32:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "diffHunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DbUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Tests to create JRF domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItJrfDomainInPV implements LoggedTest {\n+\n+  private static String dbNamespace = null;\n+  private static String opNamespace = null;\n+  private static String jrfDomainNamespace = null;\n+\n+  private static final String RCUSCHEMAPREFIX = \"jrfdomainpv\";\n+  private static final String ORACLEDBURLPREFIX = \"oracledb.\";\n+  private static final String ORACLEDBSUFFIX = \".svc.cluster.local:1521/devpdb.k8s\";\n+\n+\n+  private static String dbUrl = null;\n+  private static int dbPort = getNextFreePort(30000, 32767);\n+\n+  private static String fmwImage = JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG;\n+  private static String dbImage = DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Start DB service and create RCU schema\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull FMW image and Oracle DB image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(1) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    dbNamespace = namespaces.get(0);\n+    dbUrl = ORACLEDBURLPREFIX + dbNamespace + ORACLEDBSUFFIX;\n+\n+    /*\n+    TODO temporarily being commented out. Will be needed when JRF domain is added\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    opNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assign a unique namespace for JRF domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace is null\");\n+    jrfDomainNamespace = namespaces.get(2);\n+\n+    //TODO in the final version when JRF domain is added setupDBandRCUschema should be here\n+    //start DB and create RCU schema\n+    logger.info(\"Start DB and create RCU schema for namespace: {0} RCU prefix: {1} dbPort: {2} \"\n+        + \"dbUrl: {3} dbImage: {4} fmwImage: {5}\", dbNamespace, RCUSCHEMAPREFIX, dbPort, dbUrl, dbImage, fmwImage);\n+    assertDoesNotThrow(() -> DbUtils.setupDBandRCUschema(dbImage, fmwImage, RCUSCHEMAPREFIX, dbNamespace,\n+        dbPort, dbUrl), String.format(\"Failed to create RCU schema for prefix %s in the namespace %s with \"\n+        + \"dbPort %s and dbUrl %s\", RCUSCHEMAPREFIX, dbNamespace, dbPort, dbUrl));\n+\n+\n+    // install operator and verify its running in ready state\n+     installAndVerifyOperator(opNamespace, jrftDomainNamespace);\n+\n+     */\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    dbImage = (KIND_REPO != null\n+        ? KIND_REPO + DB_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)", "originalCommit": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNTk0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441135944", "bodyText": "Fixed.", "author": "maggiehe00", "createdAt": "2020-06-16T20:54:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMjM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMjQxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440502414", "bodyText": "same", "author": "sankarpn", "createdAt": "2020-06-15T23:32:49Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "diffHunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DbUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Tests to create JRF domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItJrfDomainInPV implements LoggedTest {\n+\n+  private static String dbNamespace = null;\n+  private static String opNamespace = null;\n+  private static String jrfDomainNamespace = null;\n+\n+  private static final String RCUSCHEMAPREFIX = \"jrfdomainpv\";\n+  private static final String ORACLEDBURLPREFIX = \"oracledb.\";\n+  private static final String ORACLEDBSUFFIX = \".svc.cluster.local:1521/devpdb.k8s\";\n+\n+\n+  private static String dbUrl = null;\n+  private static int dbPort = getNextFreePort(30000, 32767);\n+\n+  private static String fmwImage = JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG;\n+  private static String dbImage = DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Start DB service and create RCU schema\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull FMW image and Oracle DB image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(1) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    dbNamespace = namespaces.get(0);\n+    dbUrl = ORACLEDBURLPREFIX + dbNamespace + ORACLEDBSUFFIX;\n+\n+    /*\n+    TODO temporarily being commented out. Will be needed when JRF domain is added\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    opNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assign a unique namespace for JRF domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace is null\");\n+    jrfDomainNamespace = namespaces.get(2);\n+\n+    //TODO in the final version when JRF domain is added setupDBandRCUschema should be here\n+    //start DB and create RCU schema\n+    logger.info(\"Start DB and create RCU schema for namespace: {0} RCU prefix: {1} dbPort: {2} \"\n+        + \"dbUrl: {3} dbImage: {4} fmwImage: {5}\", dbNamespace, RCUSCHEMAPREFIX, dbPort, dbUrl, dbImage, fmwImage);\n+    assertDoesNotThrow(() -> DbUtils.setupDBandRCUschema(dbImage, fmwImage, RCUSCHEMAPREFIX, dbNamespace,\n+        dbPort, dbUrl), String.format(\"Failed to create RCU schema for prefix %s in the namespace %s with \"\n+        + \"dbPort %s and dbUrl %s\", RCUSCHEMAPREFIX, dbNamespace, dbPort, dbUrl));\n+\n+\n+    // install operator and verify its running in ready state\n+     installAndVerifyOperator(opNamespace, jrftDomainNamespace);\n+\n+     */\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    dbImage = (KIND_REPO != null\n+        ? KIND_REPO + DB_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)\n+        + \":\" + DB_IMAGE_TAG : DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG);\n+    fmwImage = (KIND_REPO != null\n+        ? KIND_REPO + JRF_BASE_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)", "originalCommit": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNjA0MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441136041", "bodyText": "Fixed", "author": "maggiehe00", "createdAt": "2020-06-16T20:54:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMjQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMjg4Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440502887", "bodyText": "does this work?", "author": "sankarpn", "createdAt": "2020-06-15T23:34:27Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -130,6 +130,10 @@\n     try {\n       Configuration.setDefaultApiClient(ClientBuilder.defaultClient());\n       apiClient = Configuration.getDefaultApiClient();\n+      // disable connection and read timeout to force the internal HTTP client\n+      // to keep a long running connection with the server to fix SSL connection closed issue\n+      apiClient.setConnectTimeout(0);\n+      apiClient.setReadTimeout(0);", "originalCommit": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNjkwOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441136908", "bodyText": "The result is positive but not consistent. Since now I ignore the SSLProtocolException I removed the above line.", "author": "maggiehe00", "createdAt": "2020-06-16T20:56:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMjg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMzI4MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440503281", "bodyText": "I believe this method is available in actions/impl/primitive/Kubernetes.java\nyou can use that instead of duplicating it here.", "author": "sankarpn", "createdAt": "2020-06-15T23:35:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -674,4 +676,24 @@ public static V1PersistentVolumeClaimList listPersistentVolumeClaims(String name\n \n     return v1PersistentVolumeClaimList;\n   }\n+\n+  /**\n+   * Copy a file to a pod in specified namespace.\n+   * @param namespace namespace in which the pod exists\n+   * @param pod name of pod where the file will be copied to\n+   * @param container name of the container inside of the pod\n+   * @param srcPath source location of the file\n+   * @param destPath destination location of the file\n+   * @throws ApiException if Kubernetes API client call fails\n+   * @throws IOException if copy fails\n+   */\n+  public static void copyFileToPod(String namespace,", "originalCommit": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk5NTk0MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440995940", "bodyText": "I only see copyDirectoryFromPod in in actions/impl/primitive/Kubernetes.java.", "author": "maggiehe00", "createdAt": "2020-06-16T16:45:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMzI4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNTA3MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440505071", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param rcuSchemaPrefix rcu SchemaPrefixe\n          \n          \n            \n               * @param rcuSchemaPrefix rcu SchemaPrefix", "author": "sankarpn", "createdAt": "2020-06-15T23:41:17Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe", "originalCommit": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNzAwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441137004", "bodyText": "Fixed.", "author": "maggiehe00", "createdAt": "2020-06-16T20:56:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNTA3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNTk0Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440505942", "bodyText": "do we need this check? Anyway its going to pull images since the kind clusters are thrown away after every test run.", "author": "sankarpn", "createdAt": "2020-06-15T23:44:13Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";", "originalCommit": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNzE0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441137146", "bodyText": "Fixed.", "author": "maggiehe00", "createdAt": "2020-06-16T20:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNTk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwODE0Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440508147", "bodyText": "You need to do a kind check here. Please refer to ItDomainInPV.java", "author": "sankarpn", "createdAt": "2020-06-15T23:52:02Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));", "originalCommit": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNzI2OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441137268", "bodyText": "Fixed.", "author": "maggiehe00", "createdAt": "2020-06-16T20:56:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwODE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwODQ3NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440508474", "bodyText": "You need to check if it exists before creating it and create only for non kind cluster", "author": "sankarpn", "createdAt": "2020-06-15T23:53:06Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);", "originalCommit": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNzMyNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441137325", "bodyText": "Fixed.", "author": "maggiehe00", "createdAt": "2020-06-16T20:57:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwODQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwOTExOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440509119", "bodyText": "creating services comes before deployment?", "author": "sankarpn", "createdAt": "2020-06-15T23:55:20Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+\n+    logger.info(\"Create deployment for Oracle DB in namespace {0}\",\n+        dbNamespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(oracleDbDepl),\n+        String.format(\"Create deployment failed with ApiException for Oracle DB in namespace %s\",\n+            dbNamespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for Oracle DB in namespace %s \",\n+        dbNamespace));\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));", "originalCommit": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk5OTY2OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440999668", "bodyText": "You are right. Creating a Service before its corresponding backend workloads (Deployments) is a best practice even though in this case it doesn't cause any issue. I'm going to change it.\nThanks for pointing out this, Sankar.", "author": "maggiehe00", "createdAt": "2020-06-16T16:51:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwOTExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxNDQwMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440514402", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (Kubernetes.getPodLog(podName,namespace,null).contains(matchStr)) {\n          \n          \n            \n                return Kubernetes.getPodLog(podName,namespace,null).contains(matchStr));", "author": "sankarpn", "createdAt": "2020-06-16T00:13:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+\n+    logger.info(\"Create deployment for Oracle DB in namespace {0}\",\n+        dbNamespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(oracleDbDepl),\n+        String.format(\"Create deployment failed with ApiException for Oracle DB in namespace %s\",\n+            dbNamespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for Oracle DB in namespace %s \",\n+        dbNamespace));\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));\n+\n+    // wait for the Oracle DB pod to be ready\n+    String dbPodName = assertDoesNotThrow(() -> getPodNameOfDb(dbNamespace),\n+        String.format(\"Get Oracle DB pod name failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    logger.info(\"Wait for the oracle Db pod: {0} ready in namespace {1}\", dbPodName, dbNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for Oracle DB to be ready in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                dbNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podIsReady(dbNamespace, \"app=database\", dbPodName),\n+            \"oracleDBService podReady failed with ApiException\"));\n+\n+    // check if DB is ready to be used by searching pod log\n+    logger.info(\"Check for DB pod {0} log contains ready message in namespace {1}\",\n+        dbPodName, dbNamespace);\n+    String msg = \"The database is ready for use\";\n+    checkDbReady(msg, dbPodName, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a RCU schema in the namespace.\n+   *\n+   * @param fmwBaseImageName the FMW image name\n+   * @param rcuPrefix prefix of RCU schema\n+   * @param imagePullPolicy image pull policy\n+   * @param dbUrl URL of DB\n+   * @param dbNamespace namespace of DB where RCU is\n+   * @throws ApiException when create RCU pod fails\n+   */\n+  public static void createRcuSchema(String fmwBaseImageName, String rcuPrefix, String imagePullPolicy,\n+      String dbUrl, String dbNamespace) throws ApiException {\n+\n+    logger.info(\"Create RCU pod for RCU prefix {0}\", rcuPrefix);\n+    assertDoesNotThrow(() -> createRcuPod(fmwBaseImageName, imagePullPolicy, dbUrl, dbNamespace),\n+        String.format(\"Creating RCU pod failed with ApiException for image: %s, rcuPrefix: %s, imagePullPolicy: %s, \"\n+                + \"dbUrl: %s in namespace: %s\", fmwBaseImageName, rcuPrefix, imagePullPolicy, dbUrl, dbNamespace));\n+\n+    assertTrue(assertDoesNotThrow(\n+        () -> createRcuRepository(dbNamespace, dbUrl, rcuPrefix),\n+        String.format(\"createRcuRepository failed for dbNamespace: %s, dbUrl: %s, rcuPrefix: %s\",\n+            dbNamespace, dbUrl, rcuPrefix)));\n+  }\n+\n+  /**\n+   * Create a RCU where createRepository script runs.\n+   *\n+   * @param fmwBaseImageName the FMW image name\n+   * @param imagePullPolicy image pull policy\n+   * @param dbUrl URL of DB\n+   * @param dbNamespace namespace of DB where RCU is\n+   * @throws ApiException when create RCU pod fails\n+   */\n+  public static V1Pod createRcuPod(String fmwBaseImageName, String imagePullPolicy, String dbUrl, String dbNamespace)\n+      throws ApiException {\n+\n+    ConditionFactory withStandardRetryPolicy = with().pollDelay(10, SECONDS)\n+        .and().with().pollInterval(2, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"ruc\", \"rcu\");\n+\n+    V1Pod podBody = new V1Pod()\n+        .apiVersion(\"v1\")\n+        .kind(\"Pod\")\n+        .metadata(new V1ObjectMeta()\n+            .name(RCUPODNAME)\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1PodSpec()\n+            .containers(Arrays.asList(\n+                new V1Container()\n+                    .name(\"rcu\")\n+                    .image(fmwBaseImageName)\n+                    .imagePullPolicy(imagePullPolicy)\n+                    .addArgsItem(\"sleep\")\n+                    .addArgsItem(\"infinity\")))\n+            .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))));\n+    V1Pod pvPod = Kubernetes.createPod(dbNamespace, podBody);\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for {0} to be ready in namespace {1}, \"\n+                + \"(elapsed time {2} , remaining time {3}\",\n+                RCUPODNAME,\n+                dbNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(podReady(RCUPODNAME, null, dbNamespace));\n+\n+    return pvPod;\n+  }\n+\n+  /**\n+   * Checks if a pod is ready in a given namespace.\n+   *\n+   * @param namespace in which to check if the pod is ready\n+   * @param labelSelector the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if the pod is in the ready condition, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static boolean isPodReady(String namespace, String labelSelector, String podName) throws ApiException {\n+    boolean status = false;\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    if (pod != null) {\n+\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+        if (status) {\n+          logger.info(\"Pod {0} is READY in namespace {1}\", podName, namespace);\n+        }\n+      }\n+    } else {\n+      logger.info(\"Pod {0} does not exist in namespace {1}\", podName, namespace);\n+    }\n+    return status;\n+  }\n+\n+  /**\n+   * Check if Pod is ready.\n+   *\n+   * @param namespace in which to check if the pod is ready\n+   * @param labelSelector the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if the pod is in the ready condition, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static Callable<Boolean> podIsReady(String namespace,\n+                                             String labelSelector,\n+                                             String podName) throws ApiException {\n+    return () -> isPodReady(namespace, labelSelector, podName);\n+  }\n+\n+  private static boolean createRcuRepository(String dbNamespace, String dbUrl,\n+                                         String rcuSchemaPrefix)\n+      throws ApiException, IOException {\n+\n+    // copy the script and helper files into the RCU pod\n+    Path createRepositoryScript = Paths.get(RESOURCE_DIR, \"bash-scripts\", CREATE_REPOSITORY_SCRIPT);\n+    Path passwordFile = Paths.get(RESOURCE_DIR, \"helper-files\", PASSWORD_FILE);\n+    Path podCreateRepositoryScript = Paths.get(\"/u01/oracle\", CREATE_REPOSITORY_SCRIPT);\n+    Path podPasswordFile = Paths.get(\"/u01/oracle\", PASSWORD_FILE);\n+\n+    logger.info(\"source file is: {0}, target file is: {1}\", createRepositoryScript, podCreateRepositoryScript);\n+    FileUtils.copyFileToPod(dbNamespace, RCUPODNAME, null, createRepositoryScript, podCreateRepositoryScript);\n+    logger.info(\"source file is: {0}, target file is: {1}\", passwordFile, podPasswordFile);\n+    FileUtils.copyFileToPod(dbNamespace, RCUPODNAME, null, passwordFile, podPasswordFile);\n+\n+    String createRepository = \"/u01/oracle/createRepository.sh\";\n+    logger.info(\"Running the createRepository command: {0},  dbUrl: {1}, rcuSchemaPrefix: {2}, RCU type: {3}, \"\n+        + \"SYSPASSWORD: {4} \", createRepository, dbUrl, rcuSchemaPrefix, RCUTYPE, SYSPASSWORD);\n+\n+    /* TODO The original code without encountering SSLProtocolException. Rollback to this oneWhen the bug is fixed.\n+    ExecResult execResult = assertDoesNotThrow(\n+        () -> execCommand(dbNamespace, RCUPODNAME,\n+            null, true, \"/bin/bash\", createRepository, dbUrl, rcuSchemaPrefix,\n+            RCUTYPE, SYSPASSWORD));\n+    logger.info(\"Inside RCU pod command createRepository return value: {0}\", execResult.exitValue());\n+    if (execResult.exitValue() != 0) {\n+      logger.info(\"Inside RCU pod command createRepository return error {0}\", execResult.stderr());\n+      return false;\n+    */\n+    try {\n+      execCommand(dbNamespace, RCUPODNAME,\n+          null, true, \"/bin/bash\", createRepository, dbUrl, rcuSchemaPrefix,\n+          RCUTYPE, SYSPASSWORD);\n+\n+    } catch (SSLProtocolException e) {\n+      /* TODO For Api 8.0.2 it looks that there is a bug on the web socket code or a timing bug\n+      where it doesn't properly handle closing a socket that has already been closed by the other\n+      side. Sometimes on remote Jenkins cluster 10 when RCU creation is completed java.net.ssl.SSLProtocolException\n+      is thrown. Ignore it for now */\n+      return true;\n+    } catch (InterruptedException e) {\n+      return false;\n+    } catch (ApiException e) {\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  private static String getPodNameOfDb(String dbNamespace) throws ApiException {\n+\n+    V1PodList  pod = null;\n+    pod = Kubernetes.listPods(dbNamespace, null);\n+\n+    //There is only one pod in the given DB namespace\n+    return pod.getItems().get(0).getMetadata().getName();\n+  }\n+\n+  private static boolean checkPodLogContains(String matchStr, String podName, String namespace)\n+      throws ApiException {\n+    if (Kubernetes.getPodLog(podName,namespace,null).contains(matchStr)) {", "originalCommit": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNzQzMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441137433", "bodyText": "Fixed.", "author": "maggiehe00", "createdAt": "2020-06-16T20:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxNDQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxNDU5Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440514592", "bodyText": "do a null check", "author": "sankarpn", "createdAt": "2020-06-16T00:14:25Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))))));\n+\n+    logger.info(\"Create deployment for Oracle DB in namespace {0}\",\n+        dbNamespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(oracleDbDepl),\n+        String.format(\"Create deployment failed with ApiException for Oracle DB in namespace %s\",\n+            dbNamespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for Oracle DB in namespace %s \",\n+        dbNamespace));\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));\n+\n+    // wait for the Oracle DB pod to be ready\n+    String dbPodName = assertDoesNotThrow(() -> getPodNameOfDb(dbNamespace),\n+        String.format(\"Get Oracle DB pod name failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    logger.info(\"Wait for the oracle Db pod: {0} ready in namespace {1}\", dbPodName, dbNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for Oracle DB to be ready in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                dbNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podIsReady(dbNamespace, \"app=database\", dbPodName),\n+            \"oracleDBService podReady failed with ApiException\"));\n+\n+    // check if DB is ready to be used by searching pod log\n+    logger.info(\"Check for DB pod {0} log contains ready message in namespace {1}\",\n+        dbPodName, dbNamespace);\n+    String msg = \"The database is ready for use\";\n+    checkDbReady(msg, dbPodName, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a RCU schema in the namespace.\n+   *\n+   * @param fmwBaseImageName the FMW image name\n+   * @param rcuPrefix prefix of RCU schema\n+   * @param imagePullPolicy image pull policy\n+   * @param dbUrl URL of DB\n+   * @param dbNamespace namespace of DB where RCU is\n+   * @throws ApiException when create RCU pod fails\n+   */\n+  public static void createRcuSchema(String fmwBaseImageName, String rcuPrefix, String imagePullPolicy,\n+      String dbUrl, String dbNamespace) throws ApiException {\n+\n+    logger.info(\"Create RCU pod for RCU prefix {0}\", rcuPrefix);\n+    assertDoesNotThrow(() -> createRcuPod(fmwBaseImageName, imagePullPolicy, dbUrl, dbNamespace),\n+        String.format(\"Creating RCU pod failed with ApiException for image: %s, rcuPrefix: %s, imagePullPolicy: %s, \"\n+                + \"dbUrl: %s in namespace: %s\", fmwBaseImageName, rcuPrefix, imagePullPolicy, dbUrl, dbNamespace));\n+\n+    assertTrue(assertDoesNotThrow(\n+        () -> createRcuRepository(dbNamespace, dbUrl, rcuPrefix),\n+        String.format(\"createRcuRepository failed for dbNamespace: %s, dbUrl: %s, rcuPrefix: %s\",\n+            dbNamespace, dbUrl, rcuPrefix)));\n+  }\n+\n+  /**\n+   * Create a RCU where createRepository script runs.\n+   *\n+   * @param fmwBaseImageName the FMW image name\n+   * @param imagePullPolicy image pull policy\n+   * @param dbUrl URL of DB\n+   * @param dbNamespace namespace of DB where RCU is\n+   * @throws ApiException when create RCU pod fails\n+   */\n+  public static V1Pod createRcuPod(String fmwBaseImageName, String imagePullPolicy, String dbUrl, String dbNamespace)\n+      throws ApiException {\n+\n+    ConditionFactory withStandardRetryPolicy = with().pollDelay(10, SECONDS)\n+        .and().with().pollInterval(2, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"ruc\", \"rcu\");\n+\n+    V1Pod podBody = new V1Pod()\n+        .apiVersion(\"v1\")\n+        .kind(\"Pod\")\n+        .metadata(new V1ObjectMeta()\n+            .name(RCUPODNAME)\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1PodSpec()\n+            .containers(Arrays.asList(\n+                new V1Container()\n+                    .name(\"rcu\")\n+                    .image(fmwBaseImageName)\n+                    .imagePullPolicy(imagePullPolicy)\n+                    .addArgsItem(\"sleep\")\n+                    .addArgsItem(\"infinity\")))\n+            .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))));\n+    V1Pod pvPod = Kubernetes.createPod(dbNamespace, podBody);\n+\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for {0} to be ready in namespace {1}, \"\n+                + \"(elapsed time {2} , remaining time {3}\",\n+                RCUPODNAME,\n+                dbNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(podReady(RCUPODNAME, null, dbNamespace));\n+\n+    return pvPod;\n+  }\n+\n+  /**\n+   * Checks if a pod is ready in a given namespace.\n+   *\n+   * @param namespace in which to check if the pod is ready\n+   * @param labelSelector the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if the pod is in the ready condition, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static boolean isPodReady(String namespace, String labelSelector, String podName) throws ApiException {\n+    boolean status = false;\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    if (pod != null) {\n+\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+        if (status) {\n+          logger.info(\"Pod {0} is READY in namespace {1}\", podName, namespace);\n+        }\n+      }\n+    } else {\n+      logger.info(\"Pod {0} does not exist in namespace {1}\", podName, namespace);\n+    }\n+    return status;\n+  }\n+\n+  /**\n+   * Check if Pod is ready.\n+   *\n+   * @param namespace in which to check if the pod is ready\n+   * @param labelSelector the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if the pod is in the ready condition, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static Callable<Boolean> podIsReady(String namespace,\n+                                             String labelSelector,\n+                                             String podName) throws ApiException {\n+    return () -> isPodReady(namespace, labelSelector, podName);\n+  }\n+\n+  private static boolean createRcuRepository(String dbNamespace, String dbUrl,\n+                                         String rcuSchemaPrefix)\n+      throws ApiException, IOException {\n+\n+    // copy the script and helper files into the RCU pod\n+    Path createRepositoryScript = Paths.get(RESOURCE_DIR, \"bash-scripts\", CREATE_REPOSITORY_SCRIPT);\n+    Path passwordFile = Paths.get(RESOURCE_DIR, \"helper-files\", PASSWORD_FILE);\n+    Path podCreateRepositoryScript = Paths.get(\"/u01/oracle\", CREATE_REPOSITORY_SCRIPT);\n+    Path podPasswordFile = Paths.get(\"/u01/oracle\", PASSWORD_FILE);\n+\n+    logger.info(\"source file is: {0}, target file is: {1}\", createRepositoryScript, podCreateRepositoryScript);\n+    FileUtils.copyFileToPod(dbNamespace, RCUPODNAME, null, createRepositoryScript, podCreateRepositoryScript);\n+    logger.info(\"source file is: {0}, target file is: {1}\", passwordFile, podPasswordFile);\n+    FileUtils.copyFileToPod(dbNamespace, RCUPODNAME, null, passwordFile, podPasswordFile);\n+\n+    String createRepository = \"/u01/oracle/createRepository.sh\";\n+    logger.info(\"Running the createRepository command: {0},  dbUrl: {1}, rcuSchemaPrefix: {2}, RCU type: {3}, \"\n+        + \"SYSPASSWORD: {4} \", createRepository, dbUrl, rcuSchemaPrefix, RCUTYPE, SYSPASSWORD);\n+\n+    /* TODO The original code without encountering SSLProtocolException. Rollback to this oneWhen the bug is fixed.\n+    ExecResult execResult = assertDoesNotThrow(\n+        () -> execCommand(dbNamespace, RCUPODNAME,\n+            null, true, \"/bin/bash\", createRepository, dbUrl, rcuSchemaPrefix,\n+            RCUTYPE, SYSPASSWORD));\n+    logger.info(\"Inside RCU pod command createRepository return value: {0}\", execResult.exitValue());\n+    if (execResult.exitValue() != 0) {\n+      logger.info(\"Inside RCU pod command createRepository return error {0}\", execResult.stderr());\n+      return false;\n+    */\n+    try {\n+      execCommand(dbNamespace, RCUPODNAME,\n+          null, true, \"/bin/bash\", createRepository, dbUrl, rcuSchemaPrefix,\n+          RCUTYPE, SYSPASSWORD);\n+\n+    } catch (SSLProtocolException e) {\n+      /* TODO For Api 8.0.2 it looks that there is a bug on the web socket code or a timing bug\n+      where it doesn't properly handle closing a socket that has already been closed by the other\n+      side. Sometimes on remote Jenkins cluster 10 when RCU creation is completed java.net.ssl.SSLProtocolException\n+      is thrown. Ignore it for now */\n+      return true;\n+    } catch (InterruptedException e) {\n+      return false;\n+    } catch (ApiException e) {\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  private static String getPodNameOfDb(String dbNamespace) throws ApiException {\n+\n+    V1PodList  pod = null;\n+    pod = Kubernetes.listPods(dbNamespace, null);\n+\n+    //There is only one pod in the given DB namespace\n+    return pod.getItems().get(0).getMetadata().getName();", "originalCommit": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNzUwNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441137505", "bodyText": "Fixed.", "author": "maggiehe00", "createdAt": "2020-06-16T20:57:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUxNDU5Mg=="}], "type": "inlineReview"}, {"oid": "3bc96a8cfe106880530cf0607d3e435b110fd127", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3bc96a8cfe106880530cf0607d3e435b110fd127", "message": "address the review comments", "committedDate": "2020-06-16T20:51:29Z", "type": "commit"}, {"oid": "d83a70dcd91fdfaafd8abe8b3adfa4b149718558", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d83a70dcd91fdfaafd8abe8b3adfa4b149718558", "message": "Merge remote-tracking branch 'origin/develop' into junit5-jrf1", "committedDate": "2020-06-17T15:22:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzNzk3NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441637974", "bodyText": "It comes to here when createService failed without throwing exception.", "author": "vanajamukkara", "createdAt": "2020-06-17T15:32:39Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,447 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefix\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl, boolean isUseSecret) throws ApiException {\n+\n+    // create pull secrets when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+          OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, dbPort, dbNamespace);\n+    startOracleDB(dbImage, dbPort, dbNamespace, isUseSecret);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace, isUseSecret);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, int dbPort, String dbNamespace, boolean isUseSecret)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));", "originalCommit": "d83a70dcd91fdfaafd8abe8b3adfa4b149718558", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0NzkwNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441747907", "bodyText": "fixed", "author": "maggiehe00", "createdAt": "2020-06-17T18:34:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzNzk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzODI4Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441638286", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));\n          \n          \n            \n                    \"Create service failed for oracleDBService in namespace %s \", dbNamespace));", "author": "vanajamukkara", "createdAt": "2020-06-17T15:33:09Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,447 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefix\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl, boolean isUseSecret) throws ApiException {\n+\n+    // create pull secrets when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+          OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, dbPort, dbNamespace);\n+    startOracleDB(dbImage, dbPort, dbNamespace, isUseSecret);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace, isUseSecret);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, int dbPort, String dbNamespace, boolean isUseSecret)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));", "originalCommit": "d83a70dcd91fdfaafd8abe8b3adfa4b149718558", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0ODA1Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441748052", "bodyText": "fixed", "author": "maggiehe00", "createdAt": "2020-06-17T18:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzODI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzOTcxMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441639710", "bodyText": "same as above", "author": "vanajamukkara", "createdAt": "2020-06-17T15:35:22Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,447 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefix\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl, boolean isUseSecret) throws ApiException {\n+\n+    // create pull secrets when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+          OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, dbPort, dbNamespace);\n+    startOracleDB(dbImage, dbPort, dbNamespace, isUseSecret);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, dbUrl, dbNamespace, isUseSecret);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, int dbPort, String dbNamespace, boolean isUseSecret)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Service for Oracle DB\n+    oracleDBService = new V1Service()\n+        .apiVersion(\"v1\")\n+        .kind(\"Service\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .name(\"tns\")\n+                    .port(1521)\n+                    .protocol(\"TCP\")\n+                    .targetPort(new IntOrString(1521))\n+                    .nodePort(dbPort)))\n+            .selector(labels)\n+            .sessionAffinity(\"None\")\n+            .type(\"LoadBalancer\"));\n+\n+    logger.info(\"Create service for Oracle DB service in namespace {0}\", dbNamespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(oracleDBService),\n+        String.format(\"Create service failed with ApiException for oracleDBService in namespace %s\",\n+            dbNamespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for oracleDBService in namespace %s \", dbNamespace));\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1))\n+                     .maxUnavailable(new IntOrString(1)))\n+                 .type(\"RollingUpdate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .addEnvItem(new V1EnvVar().name(\"DB_SID\").value(\"devcdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_PDB\").value(\"devpdb\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_DOMAIN\").value(\"k8s\"))\n+                            .addEnvItem(new V1EnvVar().name(\"DB_BUNDLE\").value(\"basic\"))\n+                            .image(dbBaseImageName)\n+                            .imagePullPolicy(\"IfNotPresent\")\n+                            .name(\"oracledb\")\n+                            .ports(Arrays.asList(\n+                                new V1ContainerPort()\n+                                .containerPort(1521)\n+                                .name(\"tns\")\n+                                .protocol(\"TCP\")\n+                                .hostPort(1521)))\n+                            .resources(new V1ResourceRequirements()\n+                                .limits(limits)\n+                                .requests(requests))\n+                            .terminationMessagePath(\"/dev/termination-log\")\n+                            .terminationMessagePolicy(\"File\")))\n+                    .dnsPolicy(\"ClusterFirst\")\n+                    .restartPolicy(\"Always\")\n+                    .schedulerName(\"default-scheduler\")\n+                    .terminationGracePeriodSeconds(30L)\n+                    .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(OCR_SECRET_NAME))\n+                        : null))));\n+\n+    logger.info(\"Create deployment for Oracle DB in namespace {0}\",\n+        dbNamespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(oracleDbDepl),\n+        String.format(\"Create deployment failed with ApiException for Oracle DB in namespace %s\",\n+            dbNamespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for Oracle DB in namespace %s \",", "originalCommit": "d83a70dcd91fdfaafd8abe8b3adfa4b149718558", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0ODEzMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441748130", "bodyText": "fixed", "author": "maggiehe00", "createdAt": "2020-06-17T18:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzOTcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3NjEzNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440476137", "bodyText": "Change the method name to reflect the JRF domain  e.g. testJrfDomainInPvusingWlst()", "author": "anpanigr", "createdAt": "2020-06-15T22:13:17Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItJrfDomainInPV.java", "diffHunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DbUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.DB_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.JRF_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * Tests to create JRF domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItJrfDomainInPV implements LoggedTest {\n+\n+  private static String dbNamespace = null;\n+  private static String opNamespace = null;\n+  private static String jrfDomainNamespace = null;\n+\n+  private static final String RCUSCHEMAPREFIX = \"jrfdomainpv\";\n+  private static final String ORACLEDBURLPREFIX = \"oracledb.\";\n+  private static final String ORACLEDBSUFFIX = \".svc.cluster.local:1521/devpdb.k8s\";\n+\n+\n+  private static String dbUrl = null;\n+  private static int dbPort = getNextFreePort(30000, 32767);\n+\n+  private static String fmwImage = JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG;\n+  private static String dbImage = DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+  /**\n+   * Start DB service and create RCU schema\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull FMW image and Oracle DB image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(1) List<String> namespaces) {\n+\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    dbNamespace = namespaces.get(0);\n+    dbUrl = ORACLEDBURLPREFIX + dbNamespace + ORACLEDBSUFFIX;\n+\n+    /*\n+    TODO temporarily being commented out. Will be needed when JRF domain is added\n+    logger.info(\"Assign a unique namespace for DB and RCU\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    opNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assign a unique namespace for JRF domain\");\n+    assertNotNull(namespaces.get(2), \"Namespace is null\");\n+    jrfDomainNamespace = namespaces.get(2);\n+\n+    //TODO in the final version when JRF domain is added setupDBandRCUschema should be here\n+    //start DB and create RCU schema\n+    logger.info(\"Start DB and create RCU schema for namespace: {0} RCU prefix: {1} dbPort: {2} \"\n+        + \"dbUrl: {3} dbImage: {4} fmwImage: {5}\", dbNamespace, RCUSCHEMAPREFIX, dbPort, dbUrl, dbImage, fmwImage);\n+    assertDoesNotThrow(() -> DbUtils.setupDBandRCUschema(dbImage, fmwImage, RCUSCHEMAPREFIX, dbNamespace,\n+        dbPort, dbUrl), String.format(\"Failed to create RCU schema for prefix %s in the namespace %s with \"\n+        + \"dbPort %s and dbUrl %s\", RCUSCHEMAPREFIX, dbNamespace, dbPort, dbUrl));\n+\n+\n+    // install operator and verify its running in ready state\n+     installAndVerifyOperator(opNamespace, jrftDomainNamespace);\n+\n+     */\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    dbImage = (KIND_REPO != null\n+        ? KIND_REPO + DB_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)\n+        + \":\" + DB_IMAGE_TAG : DB_IMAGE_NAME + \":\" + DB_IMAGE_TAG);\n+    fmwImage = (KIND_REPO != null\n+        ? KIND_REPO + JRF_BASE_IMAGE_NAME.substring(TestConstants.OCR_REGISTRY.length() + 1)\n+        + \":\" + JRF_BASE_IMAGE_TAG : JRF_BASE_IMAGE_NAME + \":\" + JRF_BASE_IMAGE_TAG);\n+    logger.info(\"For ItJrfDomainInPV using DB image: {0}, FMW image {1}\", dbImage, fmwImage);\n+\n+  }\n+\n+  /**\n+   * Create a JRF domain using WLST in a persistent volume.\n+   * Create a domain custom resource with domainHomeSourceType as PersistentVolume.\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful.\n+   */\n+  @Test\n+  @DisplayName(\"Create JRF domain in PV using WLST script\")\n+  public void testDomainInPvUsingWlst() {", "originalCommit": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0ODMyNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441748326", "bodyText": "fixed", "author": "maggiehe00", "createdAt": "2020-06-17T18:34:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3NjEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3Njc4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440476789", "bodyText": "Remove TODO comment, if resolved", "author": "anpanigr", "createdAt": "2020-06-15T22:14:51Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB\n+    logger.info(\"Configure V1Deployment in namespace {0} using image {1}\", dbNamespace,  dbBaseImageName);\n+    oracleDbDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"oracledb\")\n+            .namespace(dbNamespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+                 .rollingUpdate(new V1RollingUpdateDeployment()\n+                     .maxSurge(new IntOrString(1)) //TODO", "originalCommit": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0ODUyMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441748522", "bodyText": "fixed already", "author": "maggiehe00", "createdAt": "2020-06-17T18:35:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3Njc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3OTA1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r440479053", "bodyText": "Remove extra space between words", "author": "anpanigr", "createdAt": "2020-06-15T22:21:01Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DbUtils.java", "diffHunk": "@@ -0,0 +1,446 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.net.ssl.SSLProtocolException;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1RollingUpdateDeployment;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.getPod;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class to start DB service and RCU schema.\n+ */\n+public class DbUtils {\n+\n+  private static final String CREATE_REPOSITORY_SCRIPT = \"createRepository.sh\";\n+  private static final String PASSWORD_FILE = \"pwd.txt\";\n+  private static final String RCUTYPE = \"fmw\";\n+  private static final String RCUPODNAME = \"rcu\";\n+  private static final String SYSPASSWORD = \"Oradoc_db1\";\n+\n+  private static V1Service oracleDBService = null;\n+  private static V1Deployment oracleDbDepl = null;\n+\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(15, MINUTES).await();\n+  /**\n+   * Start Oracle DB instance, create rcu pod and load database schema in the specified namespace.\n+   *\n+   * @param dbImage image name of database\n+   * @param fmwImage image name of FMW\n+   * @param rcuSchemaPrefix rcu SchemaPrefixe\n+   * @param dbNamespace namespace where DB and RCU schema are going to start\n+   * @param dbPort NodePort of DB\n+   * @param dbUrl URL of DB\n+   * @throws Exception if any error occurs when setting up RCU database\n+   */\n+\n+  public static void setupDBandRCUschema(String dbImage, String fmwImage, String rcuSchemaPrefix, String dbNamespace,\n+      int dbPort, String dbUrl) throws ApiException {\n+\n+    CommonTestUtils.createDockerRegistrySecret(OCR_USERNAME, OCR_PASSWORD,\n+        OCR_EMAIL, OCR_REGISTRY, OCR_SECRET_NAME, dbNamespace);\n+\n+    //For Kind cluter\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (KIND_REPO != null) {\n+      imagePullPolicy = \"Always\";\n+    }\n+\n+    logger.info(\"Start Oracle DB with dbImage: {0}, imagePullPolicy: {1}, dbPort: {2}, \"\n+        + \"dbNamespace: {3}\", dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    startOracleDB(dbImage, imagePullPolicy, dbPort, dbNamespace);\n+    logger.info(\"Create RCU schema with fmwImage: {0}, rcuSchemaPrefix: {1}, imagePullPolicy: {2}, \"\n+        + \"dbUrl: {3}, dbNamespace: {4}\", fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+    createRcuSchema(fmwImage, rcuSchemaPrefix, imagePullPolicy, dbUrl, dbNamespace);\n+\n+  }\n+\n+  /**\n+   * Start Oracle DB pod and service in the specified namespace.\n+   *\n+   * @param dbBaseImageName full image name for DB deployment\n+   * @param imagePullPolicy policy for image pull\n+   * @param dbPort NodePort of DB\n+   * @param dbNamespace namespace where DB instance is going to start\n+   */\n+  public static void startOracleDB(String dbBaseImageName, String imagePullPolicy, int dbPort, String dbNamespace)\n+      throws ApiException {\n+\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"database\");\n+\n+    Map limits = new HashMap<String, String>();\n+    limits.put(\"cpu\", \"2\");\n+    limits.put(\"memory\", \"10Gi\");\n+    limits.put(\"ephemeral-storage\", \"8Gi\");\n+    Map requests = new HashMap<String, String>();\n+    requests.put(\"cpu\", \"500m\");\n+    requests.put(\"ephemeral-storage\", \"8Gi\");\n+\n+    //create V1Deployment  for Oracle DB", "originalCommit": "6f9a150a686116c93d2ae84f0c3d60ae100d6d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0ODc5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1737#discussion_r441748797", "bodyText": "fixed", "author": "maggiehe00", "createdAt": "2020-06-17T18:35:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ3OTA1Mw=="}], "type": "inlineReview"}, {"oid": "33bdbc27bd7eef51be1932b67d7e30adcde450ee", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/33bdbc27bd7eef51be1932b67d7e30adcde450ee", "message": "addressed more review comments", "committedDate": "2020-06-17T18:32:29Z", "type": "commit"}, {"oid": "85714fb69f3bf6a12106ce3f2ef5985884f3fe0b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/85714fb69f3bf6a12106ce3f2ef5985884f3fe0b", "message": "Merge remote-tracking branch 'origin/develop' into junit5-jrf1", "committedDate": "2020-06-19T18:41:38Z", "type": "commit"}]}