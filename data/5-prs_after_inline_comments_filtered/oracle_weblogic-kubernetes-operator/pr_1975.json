{"pr_number": 1975, "pr_title": "External JMS client with LoadBalancer Tunneling ", "pr_createdAt": "2020-10-09T19:27:13Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975", "timeline": [{"oid": "b3a813f423918a0e1f0ceab4199a419534a35013", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b3a813f423918a0e1f0ceab4199a419534a35013", "message": "Added test for external JMS client", "committedDate": "2020-10-09T19:11:05Z", "type": "commit"}, {"oid": "5ba11291c7708b7ba1b0be609dc025da99b435c7", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5ba11291c7708b7ba1b0be609dc025da99b435c7", "message": "separate methods for http and https tunneling", "committedDate": "2020-10-09T21:32:40Z", "type": "commit"}, {"oid": "79357a3365a5668dc3153f87ddbc15e320c8ebc2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/79357a3365a5668dc3153f87ddbc15e320c8ebc2", "message": "Modified the test method name", "committedDate": "2020-10-09T22:18:41Z", "type": "commit"}, {"oid": "f756b875291d9eb3ad82f7f49c78e0db7c17bc54", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f756b875291d9eb3ad82f7f49c78e0db7c17bc54", "message": "Added ssl debug", "committedDate": "2020-10-09T23:41:38Z", "type": "commit"}, {"oid": "be2469b8fe2f532a597462d93226abcc38404f4e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/be2469b8fe2f532a597462d93226abcc38404f4e", "message": "Modify keytool command line args", "committedDate": "2020-10-12T20:51:54Z", "type": "commit"}, {"oid": "170198ae6ba0c84f1b2a01be1be7f3e6106f2913", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/170198ae6ba0c84f1b2a01be1be7f3e6106f2913", "message": "Added SAN extension to the ssl cert", "committedDate": "2020-10-13T21:05:43Z", "type": "commit"}, {"oid": "7f066a4a965066cadf0aad34a6078cb9d57105a6", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7f066a4a965066cadf0aad34a6078cb9d57105a6", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into rmi-jms", "committedDate": "2020-10-13T23:11:45Z", "type": "commit"}, {"oid": "f5c231142f575d2c1beac0b65f023beec8ab409e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f5c231142f575d2c1beac0b65f023beec8ab409e", "message": "Resolved typo in openssl command", "committedDate": "2020-10-13T23:13:02Z", "type": "commit"}, {"oid": "45fa4ed459a6e26feea1651d1fdf56b9cfbcb3c3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/45fa4ed459a6e26feea1651d1fdf56b9cfbcb3c3", "message": "Modified K8S_NODEPORT_HOST to return IP Address", "committedDate": "2020-10-14T17:11:54Z", "type": "commit"}, {"oid": "3c14841754d4209a4971cd4b7fb6d0d463e76ae7", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3c14841754d4209a4971cd4b7fb6d0d463e76ae7", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into rmi-jms", "committedDate": "2020-10-15T14:14:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMzcwNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505713705", "bodyText": "make this method as private or provide javadoc", "author": "sankarpn", "createdAt": "2020-10-15T17:23:54Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,503 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+// import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  public void buildClient() {", "originalCommit": "45fa4ed459a6e26feea1651d1fdf56b9cfbcb3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc4NjE4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505786182", "bodyText": "modified the scope to private", "author": "anpanigr", "createdAt": "2020-10-15T19:25:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMzcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxNDI0NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505714245", "bodyText": "Do you want to use copyFileFromPod(...) instead of using kubectl cp?", "author": "sankarpn", "createdAt": "2020-10-15T17:24:54Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,503 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+// import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  public void buildClient() {\n+\n+    StringBuffer copyCmd = new StringBuffer(\"kubectl cp \");", "originalCommit": "45fa4ed459a6e26feea1651d1fdf56b9cfbcb3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc4NjY0Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505786647", "bodyText": "assertDoesNotThrow(() -> copyFileFromPod(domainNamespace,\nadminServerPodName, \"weblogic-server\",\n\"/u01/oracle/wlserver/server/lib/wlthint3client.jar\",\nPaths.get(RESULTS_ROOT, \"wlthint3client.jar\")));", "author": "anpanigr", "createdAt": "2020-10-15T19:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxNDI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyMDkxMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505720912", "bodyText": "Add some comments as to what these private methods does.", "author": "sankarpn", "createdAt": "2020-10-15T17:35:52Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,503 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+// import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  public void buildClient() {\n+\n+    StringBuffer copyCmd = new StringBuffer(\"kubectl cp \");\n+    copyCmd.append(domainNamespace + \"/\" + adminServerPodName);\n+    copyCmd.append(\":/u01/oracle/wlserver/server/lib/wlthint3client.jar \");\n+    copyCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    logger.info(\"kubectl copy command {0}\", copyCmd.toString());\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(copyCmd), true));\n+    logger.info(\"kubectl copy returned {0}\", result.toString());\n+\n+    StringBuffer javacCmd = new StringBuffer(\"javac -cp \");\n+    javacCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar \"));\n+    javacCmd.append(Paths.get(RESOURCE_DIR, \"tunneling\", \"JmsTestClient.java\"));\n+    javacCmd.append(Paths.get(\" -d \"));\n+    javacCmd.append(Paths.get(RESULTS_ROOT));\n+    logger.info(\"javac command {0}\", javacCmd.toString());\n+    result = assertDoesNotThrow(\n+        () -> exec(new String(javacCmd), true));\n+    logger.info(\"javac returned {0}\", result.toString());\n+    logger.info(\"javac returned EXIT value {0}\", result.exitValue());\n+    assertTrue(result.exitValue() == 0, \"Client compilation fails\");\n+  }\n+\n+  // Run external standalone JMS Client using wlthint3client.jar in classpath.\n+  // The client sends 300 messsage to a Uniform Distributed Queue.\n+  // Make sure that each destination get excatly 150 messages each.\n+  private static Callable<Boolean> runJmsClient(String javaCmd) {\n+    return (()  -> {\n+      ExecResult result = assertDoesNotThrow(() -> exec(new String(javaCmd), true));\n+      logger.info(\"java returned {0}\", result.toString());\n+      logger.info(\"java returned EXIT value {0}\", result.exitValue());\n+      return ((result.exitValue() == 0));\n+    });\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployIngress), true));\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployTlsIngress), true));\n+\n+    // uninstall Voyager\n+    if (voyagerHelmParams != null) {\n+      assertThat(uninstallVoyager(voyagerHelmParams))\n+          .as(\"Test uninstallVoyager returns true\")\n+          .withFailMessage(\"uninstallVoyager() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  private static void createCertKeyFiles(String cn) {", "originalCommit": "45fa4ed459a6e26feea1651d1fdf56b9cfbcb3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc4Njg4Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505786887", "bodyText": "modified the scope to private and added description", "author": "anpanigr", "createdAt": "2020-10-15T19:27:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyMDkxMg=="}], "type": "inlineReview"}, {"oid": "f8045c4976d3051296d2a807dd99d99d3b96b1cb", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f8045c4976d3051296d2a807dd99d99d3b96b1cb", "message": "Review comments (a) modified method scope to private (b) usage of utility method to copy files from Pod", "committedDate": "2020-10-15T19:24:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgwOTU4Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505809583", "bodyText": "add comments", "author": "vanajamukkara", "createdAt": "2020-10-15T20:10:17Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);", "originalCommit": "f8045c4976d3051296d2a807dd99d99d3b96b1cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyNzg4MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505927881", "bodyText": "The method definition createCertKeyFiles() has the description\n// Create display SSL certificate and key using openssl with SAN extension", "author": "anpanigr", "createdAt": "2020-10-15T23:54:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgwOTU4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzMDQ0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505930444", "bodyText": "The method definition createCertKeyFiles() has the comment", "author": "anpanigr", "createdAt": "2020-10-16T00:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgwOTU4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5NTQwNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r506695405", "bodyText": "Added comments inside the test method", "author": "anpanigr", "createdAt": "2020-10-16T20:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgwOTU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxOTUxOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505819519", "bodyText": "add at least single line comments for each segment of code in the test method", "author": "vanajamukkara", "createdAt": "2020-10-15T20:28:46Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {", "originalCommit": "f8045c4976d3051296d2a807dd99d99d3b96b1cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5NTU4Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r506695583", "bodyText": "Added comments as javadoc to the test method.", "author": "anpanigr", "createdAt": "2020-10-16T20:03:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxOTUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxOTcyMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505819723", "bodyText": "comments", "author": "vanajamukkara", "createdAt": "2020-10-15T20:29:03Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+", "originalCommit": "f8045c4976d3051296d2a807dd99d99d3b96b1cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5NTc1Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r506695757", "bodyText": "Added comments as javadoc to the test method.", "author": "anpanigr", "createdAt": "2020-10-16T20:04:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxOTcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMDEwMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505820100", "bodyText": "comments", "author": "vanajamukkara", "createdAt": "2020-10-15T20:29:25Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");", "originalCommit": "f8045c4976d3051296d2a807dd99d99d3b96b1cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5NTkwMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r506695901", "bodyText": "Added comments inside the test method", "author": "anpanigr", "createdAt": "2020-10-16T20:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMDEwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMDQ1NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505820455", "bodyText": "comments", "author": "vanajamukkara", "createdAt": "2020-10-15T20:29:51Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");", "originalCommit": "f8045c4976d3051296d2a807dd99d99d3b96b1cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyOTk4MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505929980", "bodyText": "// Generate java command to execute client with classpath", "author": "anpanigr", "createdAt": "2020-10-16T00:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMDQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMTM2Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505821363", "bodyText": "add comments on what the client does", "author": "vanajamukkara", "createdAt": "2020-10-15T20:30:59Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success", "originalCommit": "f8045c4976d3051296d2a807dd99d99d3b96b1cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyOTAzMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505929031", "bodyText": "See the comments in buildClient() method defintion", "author": "anpanigr", "createdAt": "2020-10-15T23:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMTM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMTcyMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505821721", "bodyText": "add comments in this test too", "author": "vanajamukkara", "createdAt": "2020-10-15T20:31:22Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {", "originalCommit": "f8045c4976d3051296d2a807dd99d99d3b96b1cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMjg2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505822860", "bodyText": "comments", "author": "vanajamukkara", "createdAt": "2020-10-15T20:32:45Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  private void buildClient() {\n+\n+    assertDoesNotThrow(() -> copyFileFromPod(domainNamespace, \n+             adminServerPodName, \"weblogic-server\",\n+             \"/u01/oracle/wlserver/server/lib/wlthint3client.jar\", \n+             Paths.get(RESULTS_ROOT, \"wlthint3client.jar\")));\n+    StringBuffer javacCmd = new StringBuffer(\"javac -cp \");\n+    javacCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar \"));\n+    javacCmd.append(Paths.get(RESOURCE_DIR, \"tunneling\", \"JmsTestClient.java\"));\n+    javacCmd.append(Paths.get(\" -d \"));\n+    javacCmd.append(Paths.get(RESULTS_ROOT));\n+    logger.info(\"javac command {0}\", javacCmd.toString());\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(javacCmd), true));\n+    logger.info(\"javac returned {0}\", result.toString());\n+    logger.info(\"javac returned EXIT value {0}\", result.exitValue());\n+    assertTrue(result.exitValue() == 0, \"Client compilation fails\");\n+  }\n+\n+  // Run external standalone JMS Client using wlthint3client.jar in classpath.\n+  // The client sends 300 messsage to a Uniform Distributed Queue.\n+  // Make sure that each destination get excatly 150 messages each.\n+  private static Callable<Boolean> runJmsClient(String javaCmd) {\n+    return (()  -> {\n+      ExecResult result = assertDoesNotThrow(() -> exec(new String(javaCmd), true));\n+      logger.info(\"java returned {0}\", result.toString());\n+      logger.info(\"java returned EXIT value {0}\", result.exitValue());\n+      return ((result.exitValue() == 0));\n+    });\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployIngress), true));\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployTlsIngress), true));\n+\n+    // uninstall Voyager\n+    if (voyagerHelmParams != null) {\n+      assertThat(uninstallVoyager(voyagerHelmParams))\n+          .as(\"Test uninstallVoyager returns true\")\n+          .withFailMessage(\"uninstallVoyager() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  // Create and display SSL certificate and key using openssl with SAN extension\n+  private static void createCertKeyFiles(String cn) {\n+\n+    Map<String, String> sanConfigTemplateMap  = new HashMap();\n+    sanConfigTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"san.config.template.txt\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        \"san.config.txt\", sanConfigTemplateMap));\n+    logger.info(\"Generated SAN config file {0}\", targetFile);\n+\n+    assertDoesNotThrow(() -> {", "originalCommit": "f8045c4976d3051296d2a807dd99d99d3b96b1cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMzAzNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505823034", "bodyText": "comments", "author": "vanajamukkara", "createdAt": "2020-10-15T20:33:00Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  private void buildClient() {\n+\n+    assertDoesNotThrow(() -> copyFileFromPod(domainNamespace, \n+             adminServerPodName, \"weblogic-server\",\n+             \"/u01/oracle/wlserver/server/lib/wlthint3client.jar\", \n+             Paths.get(RESULTS_ROOT, \"wlthint3client.jar\")));\n+    StringBuffer javacCmd = new StringBuffer(\"javac -cp \");\n+    javacCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar \"));\n+    javacCmd.append(Paths.get(RESOURCE_DIR, \"tunneling\", \"JmsTestClient.java\"));\n+    javacCmd.append(Paths.get(\" -d \"));\n+    javacCmd.append(Paths.get(RESULTS_ROOT));\n+    logger.info(\"javac command {0}\", javacCmd.toString());\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(javacCmd), true));\n+    logger.info(\"javac returned {0}\", result.toString());\n+    logger.info(\"javac returned EXIT value {0}\", result.exitValue());\n+    assertTrue(result.exitValue() == 0, \"Client compilation fails\");\n+  }\n+\n+  // Run external standalone JMS Client using wlthint3client.jar in classpath.\n+  // The client sends 300 messsage to a Uniform Distributed Queue.\n+  // Make sure that each destination get excatly 150 messages each.\n+  private static Callable<Boolean> runJmsClient(String javaCmd) {\n+    return (()  -> {\n+      ExecResult result = assertDoesNotThrow(() -> exec(new String(javaCmd), true));\n+      logger.info(\"java returned {0}\", result.toString());\n+      logger.info(\"java returned EXIT value {0}\", result.exitValue());\n+      return ((result.exitValue() == 0));\n+    });\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployIngress), true));\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployTlsIngress), true));\n+\n+    // uninstall Voyager\n+    if (voyagerHelmParams != null) {\n+      assertThat(uninstallVoyager(voyagerHelmParams))\n+          .as(\"Test uninstallVoyager returns true\")\n+          .withFailMessage(\"uninstallVoyager() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  // Create and display SSL certificate and key using openssl with SAN extension\n+  private static void createCertKeyFiles(String cn) {\n+\n+    Map<String, String> sanConfigTemplateMap  = new HashMap();\n+    sanConfigTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"san.config.template.txt\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        \"san.config.txt\", sanConfigTemplateMap));\n+    logger.info(\"Generated SAN config file {0}\", targetFile);\n+\n+    assertDoesNotThrow(() -> {\n+      tlsKeyFile = Paths.get(RESULTS_ROOT, domainNamespace + \"-tls.key\");\n+      tlsCertFile = Paths.get(RESULTS_ROOT, domainNamespace + \"-tls.cert\");\n+      String command = \"openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout \" + tlsKeyFile\n+          + \" -out \" + tlsCertFile + \" -subj \\\"/CN=\" + cn + \"\\\" -extensions san\"\n+          + \" -config \" + Paths.get(RESULTS_ROOT, \"san.config.txt\");\n+      logger.info(\"Executing command: {0}\", command);\n+      ExecResult result = ExecCommand.exec(command, true);\n+      logger.info(\"openssl command  returned {0}\", result.toString());\n+    });\n+\n+    assertDoesNotThrow(() -> {", "originalCommit": "f8045c4976d3051296d2a807dd99d99d3b96b1cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMDcxOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505830719", "bodyText": "log the error that it fails with", "author": "vanajamukkara", "createdAt": "2020-10-15T20:42:32Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  private void buildClient() {\n+\n+    assertDoesNotThrow(() -> copyFileFromPod(domainNamespace, \n+             adminServerPodName, \"weblogic-server\",\n+             \"/u01/oracle/wlserver/server/lib/wlthint3client.jar\", \n+             Paths.get(RESULTS_ROOT, \"wlthint3client.jar\")));\n+    StringBuffer javacCmd = new StringBuffer(\"javac -cp \");\n+    javacCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar \"));\n+    javacCmd.append(Paths.get(RESOURCE_DIR, \"tunneling\", \"JmsTestClient.java\"));\n+    javacCmd.append(Paths.get(\" -d \"));\n+    javacCmd.append(Paths.get(RESULTS_ROOT));\n+    logger.info(\"javac command {0}\", javacCmd.toString());\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(javacCmd), true));\n+    logger.info(\"javac returned {0}\", result.toString());\n+    logger.info(\"javac returned EXIT value {0}\", result.exitValue());\n+    assertTrue(result.exitValue() == 0, \"Client compilation fails\");", "originalCommit": "f8045c4976d3051296d2a807dd99d99d3b96b1cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzODA2Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505938063", "bodyText": "Modified the logic to put stderr and stdout from ExecResult class", "author": "anpanigr", "createdAt": "2020-10-16T00:33:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMDcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5Njc1MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r506696751", "bodyText": "Modified logic to use actions.impl.primitive.Command to execute bash command.", "author": "anpanigr", "createdAt": "2020-10-16T20:06:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMDcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMTYzOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505831638", "bodyText": "you don't have to check the result?", "author": "vanajamukkara", "createdAt": "2020-10-15T20:43:40Z", "path": "integration-tests/src/test/java/oracle/weblogic/kubernetes/ItExternalRmiTunneling.java", "diffHunk": "@@ -0,0 +1,502 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecCommand;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OCIR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallVoyager;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapFromFiles;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createOcirRepoSecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.generateFileFromTemplate;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyVoyager;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.copyFileFromPod;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The use case described in this class verifies that an external RMI client \n+ * can access the WebLogic cluster JNDI tree using the LoadBalancer tunneling \n+ * approach as described in following  WebLogic Kubernetes operator faq page\n+ * https://oracle.github.io/weblogic-kubernetes-operator/faq/external-clients/ \n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test external RMI access through LoadBalncer Tunneling\")\n+@IntegrationTest\n+class ItExternalRmiTunneling {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static String voyagerNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static HelmParams voyagerHelmParams = null;\n+  private static int replicaCount = 2;\n+  private static String clusterName = \"cluster-1\";\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static final String TUNNELING_MODEL_FILE = \"tunneling.model.yaml\";\n+  private static final String domainUid = \"mii-tunneling\";\n+\n+  private static LoggingFacade logger = null;\n+  private static Path tlsCertFile;\n+  private static Path tlsKeyFile;\n+  private static Path jksTrustFile;\n+  private static String tlsSecretName = domainUid + \"-voyager-tls-secret\";\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    logger.info(\"Assigning unique namespace for Voyager\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    voyagerNamespace = namespaces.get(2);\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    // this secret is used only for non-kind cluster\n+    createOcirRepoSecret(domainNamespace);\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, \n+            ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    createSecretWithUsernamePassword(encryptionSecretName, domainNamespace, \n+            \"weblogicenc\", \"weblogicenc\");\n+\n+    // Prepare the config map sparse model file from the template by replacing \n+    // Public Address of the custom channel with K8S_NODEPORT_HOST \n+    Map<String, String> configTemplateMap  = new HashMap();\n+    configTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"wdt-models\", \"tunneling.model.template.yaml\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        TUNNELING_MODEL_FILE, configTemplateMap));\n+    logger.info(\"Generated tunneling ConfigMap model file {0}\", targetFile);\n+\n+    String configMapName = \"jms-tunneling-configmap\";\n+    List<Path> configMapFiles = new ArrayList<>();\n+    configMapFiles.add(Paths.get(RESULTS_ROOT, TUNNELING_MODEL_FILE));\n+\n+    createConfigMapFromFiles(configMapName, configMapFiles, domainNamespace);\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        OCIR_SECRET_NAME, encryptionSecretName, replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    String cloudProvider = \"baremetal\";\n+    boolean enableValidatingWebhook = false;\n+    voyagerHelmParams = installAndVerifyVoyager(voyagerNamespace,\n+        cloudProvider, enableValidatingWebhook);\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+    logger.info(\"Check admin service and pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);\n+    // check managed server services and pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server services and pods are created in namespace {0}\",\n+          domainNamespace);\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+  }\n+\n+  @Order(1)\n+  @Test\n+  @DisplayName(\"Verify the RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+\n+    Path srcVoyagerHttpFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"voyager.tunneling.template.yaml\");\n+    Path targetVoyagerHttpFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpFile.toString(), \n+        \"voyager.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Http Tunneling file {0}\", targetVoyagerHttpFile);\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tunneling\", domainNamespace);\n+\n+    int httpTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tunneling\");\n+    assertTrue(httpTunnelingPort != -1,\n+        \"Could not get the HttpTunnelingPort service node port\");\n+    logger.info(\"HttpTunnelingPort for Voyager {0}\", httpTunnelingPort);\n+\n+    StringBuffer httpUrl = new StringBuffer(\"http://\");\n+    httpUrl.append(K8S_NODEPORT_HOST + \":\" + httpTunnelingPort);\n+\n+    StringBuffer javaCmd = new StringBuffer(\"java -cp \");\n+    javaCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javaCmd.append(\":\");\n+    javaCmd.append(Paths.get(RESULTS_ROOT));\n+    javaCmd.append(\" JmsTestClient \");\n+    javaCmd.append(httpUrl);\n+    logger.info(\"java command to be run {0}\", javaCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Http JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javaCmd)));\n+  }\n+\n+  @Order(2)\n+  @Test\n+  @DisplayName(\"Verify tls RMI access WLS through LoadBalancer tunneling port\")\n+  public void testExternalRmiAccessThruHttpsTunneling() {\n+\n+    buildClient();\n+\n+    // Prepare the voyager ingress file from the template file by replacing \n+    // domain namespace, domain UID, cluster service name and tls secret \n+    Map<String, String> templateMap  = new HashMap();\n+    templateMap.put(\"DOMAIN_NS\", domainNamespace);\n+    templateMap.put(\"DOMAIN_UID\", domainUid);\n+    templateMap.put(\"CLUSTER\", clusterName);\n+    templateMap.put(\"TLS_CERT\", tlsSecretName);\n+\n+    Path srcVoyagerHttpsFile  = Paths.get(RESOURCE_DIR,\n+        \"tunneling\", \"voyager.tls.tunneling.template.yaml\");\n+    Path targetVoyagerHttpsFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcVoyagerHttpsFile.toString(),\n+            \"voyager.tls.tunneling.yaml\", templateMap));\n+    logger.info(\"Generated Voyager Https Tunneling file {0}\", targetVoyagerHttpsFile);\n+\n+    createCertKeyFiles(K8S_NODEPORT_HOST);\n+    createSecretWithTLSCertKey(tlsSecretName);\n+    createJksStore();\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl apply -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(deployTlsIngress), true));\n+\n+    logger.info(\"kubectl apply returned {0}\", result.toString());\n+    checkServiceExists(\"voyager-voyager-tls-tunneling\", domainNamespace);\n+\n+    int httpsTunnelingPort =\n+        getServiceNodePort(domainNamespace, \"voyager-voyager-tls-tunneling\");\n+    assertTrue(httpsTunnelingPort != -1,\n+        \"Could not get the HttpsTunnelingPort service node port\");\n+    logger.info(\"HttpsTunnelingPort for Voyager {0}\", httpsTunnelingPort);\n+\n+    StringBuffer httpsUrl = new StringBuffer(\"https://\");\n+    httpsUrl.append(K8S_NODEPORT_HOST + \":\" + httpsTunnelingPort);\n+\n+    StringBuffer javasCmd = new StringBuffer(\"java -cp \");\n+    javasCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar\"));\n+    javasCmd.append(\":\");\n+    javasCmd.append(Paths.get(RESULTS_ROOT));\n+    // javasCmd.append(\" -Djavax.net.debug=all \");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStorePassword=password\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStoreType=jks\");\n+    javasCmd.append(\" -Djavax.net.ssl.trustStore=\");\n+    javasCmd.append(jksTrustFile);\n+    javasCmd.append(\" JmsTestClient \");\n+    javasCmd.append(httpsUrl);\n+    logger.info(\"java command to be run {0}\", javasCmd.toString());\n+\n+    // Note it takes a couples of iterations before the client success\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Wait for Https JMS Client to access WLS \"\n+                    + \"(elapsed time {0}ms, remaining time {1}ms)\",\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(runJmsClient(new String(javasCmd)));\n+  }\n+\n+  // Download the wlthint3client.jar from Adminserver pod to local filesystem.\n+  // Use wlthint3client.jar in classpath to build and run the standalone \n+  // JMS client that sends messages to a Uniform Distributed Queue using \n+  // load balancer http(s) url which maps to custom channel on cluster member\n+  // server on WebLogic cluster.\n+  private void buildClient() {\n+\n+    assertDoesNotThrow(() -> copyFileFromPod(domainNamespace, \n+             adminServerPodName, \"weblogic-server\",\n+             \"/u01/oracle/wlserver/server/lib/wlthint3client.jar\", \n+             Paths.get(RESULTS_ROOT, \"wlthint3client.jar\")));\n+    StringBuffer javacCmd = new StringBuffer(\"javac -cp \");\n+    javacCmd.append(Paths.get(RESULTS_ROOT, \"wlthint3client.jar \"));\n+    javacCmd.append(Paths.get(RESOURCE_DIR, \"tunneling\", \"JmsTestClient.java\"));\n+    javacCmd.append(Paths.get(\" -d \"));\n+    javacCmd.append(Paths.get(RESULTS_ROOT));\n+    logger.info(\"javac command {0}\", javacCmd.toString());\n+    ExecResult result = assertDoesNotThrow(\n+        () -> exec(new String(javacCmd), true));\n+    logger.info(\"javac returned {0}\", result.toString());\n+    logger.info(\"javac returned EXIT value {0}\", result.exitValue());\n+    assertTrue(result.exitValue() == 0, \"Client compilation fails\");\n+  }\n+\n+  // Run external standalone JMS Client using wlthint3client.jar in classpath.\n+  // The client sends 300 messsage to a Uniform Distributed Queue.\n+  // Make sure that each destination get excatly 150 messages each.\n+  private static Callable<Boolean> runJmsClient(String javaCmd) {\n+    return (()  -> {\n+      ExecResult result = assertDoesNotThrow(() -> exec(new String(javaCmd), true));\n+      logger.info(\"java returned {0}\", result.toString());\n+      logger.info(\"java returned EXIT value {0}\", result.exitValue());\n+      return ((result.exitValue() == 0));\n+    });\n+  }\n+\n+  @AfterAll\n+  void tearDown() {\n+\n+    StringBuffer deployIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployIngress), true));\n+\n+    StringBuffer deployTlsIngress = new StringBuffer(\"kubectl delete -f \");\n+    deployTlsIngress.append(Paths.get(RESULTS_ROOT, \"voyager.tls.tunneling.yaml\"));\n+    assertDoesNotThrow(() -> exec(new String(deployTlsIngress), true));\n+\n+    // uninstall Voyager\n+    if (voyagerHelmParams != null) {\n+      assertThat(uninstallVoyager(voyagerHelmParams))\n+          .as(\"Test uninstallVoyager returns true\")\n+          .withFailMessage(\"uninstallVoyager() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  // Create and display SSL certificate and key using openssl with SAN extension\n+  private static void createCertKeyFiles(String cn) {\n+\n+    Map<String, String> sanConfigTemplateMap  = new HashMap();\n+    sanConfigTemplateMap.put(\"INGRESS_HOST\", K8S_NODEPORT_HOST);\n+\n+    Path srcFile = Paths.get(RESOURCE_DIR, \n+        \"tunneling\", \"san.config.template.txt\");\n+    Path targetFile = assertDoesNotThrow(\n+        () -> generateFileFromTemplate(srcFile.toString(), \n+        \"san.config.txt\", sanConfigTemplateMap));\n+    logger.info(\"Generated SAN config file {0}\", targetFile);\n+\n+    assertDoesNotThrow(() -> {\n+      tlsKeyFile = Paths.get(RESULTS_ROOT, domainNamespace + \"-tls.key\");\n+      tlsCertFile = Paths.get(RESULTS_ROOT, domainNamespace + \"-tls.cert\");\n+      String command = \"openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout \" + tlsKeyFile\n+          + \" -out \" + tlsCertFile + \" -subj \\\"/CN=\" + cn + \"\\\" -extensions san\"\n+          + \" -config \" + Paths.get(RESULTS_ROOT, \"san.config.txt\");\n+      logger.info(\"Executing command: {0}\", command);\n+      ExecResult result = ExecCommand.exec(command, true);\n+      logger.info(\"openssl command  returned {0}\", result.toString());\n+    });\n+\n+    assertDoesNotThrow(() -> {\n+      String command2 = \"openssl x509 -in \" + tlsCertFile + \" -noout -text \";\n+      logger.info(\"Executing command: {0}\", command2);\n+      ExecResult result = ExecCommand.exec(command2, true);\n+      logger.info(\"openssl list command  returned {0}\", result.toString());\n+    });\n+  }\n+\n+  // Import the certificate into a JKS TrustStore to be used while running \n+  // external JMS client to send message to WebLogic.\n+  private void createJksStore() {\n+    assertDoesNotThrow(() -> {\n+      jksTrustFile = Paths.get(RESULTS_ROOT, domainNamespace + \"-trust.jks\");\n+      String command = \"keytool -import -file \" + tlsCertFile \n+             + \" --keystore \" + jksTrustFile \n+             + \" -storetype jks -storepass password -noprompt \";\n+      logger.info(\"Executing command: {0}\", command);\n+      ExecCommand.exec(command, true);\n+    });\n+\n+    assertDoesNotThrow(() -> {\n+      String command2 = \"keytool -list -keystore \" + jksTrustFile + \" -storepass password -noprompt\";\n+      logger.info(\"Executing command: {0}\", command2);\n+      ExecCommand.exec(command2, true);", "originalCommit": "f8045c4976d3051296d2a807dd99d99d3b96b1cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzMjcyOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505932728", "bodyText": "Modified the logic to check the ResultSet's exitcode", "author": "anpanigr", "createdAt": "2020-10-16T00:12:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5NjgyMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r506696821", "bodyText": "Modified logic to use actions.impl.primitive.Command to execute bash command.", "author": "anpanigr", "createdAt": "2020-10-16T20:06:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMTYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzNTA5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505835096", "bodyText": "add javadoc with purpose of this class", "author": "vanajamukkara", "createdAt": "2020-10-15T20:47:26Z", "path": "integration-tests/src/test/resources/tunneling/JmsTestClient.java", "diffHunk": "@@ -0,0 +1,122 @@\n+import java.util.Hashtable;\r\n+import javax.naming.Context;\r\n+import javax.naming.InitialContext;\r\n+import javax.naming.NamingException;\r\n+\r\n+import javax.jms.Destination;\r\n+import javax.jms.ConnectionFactory;\r\n+import javax.jms.Connection;\r\n+import javax.jms.Session;\r\n+import javax.jms.Message;\r\n+import javax.jms.DeliveryMode;\r\n+import javax.jms.TextMessage;\r\n+import javax.jms.MessageProducer;\r\n+import javax.jms.MessageConsumer;\r\n+import javax.jms.JMSException;\r\n+\r\n+import javax.jms.JMSContext;\r\n+import javax.jms.JMSConsumer;\r\n+import javax.jms.JMSProducer;\r\n+import javax.jms.JMSRuntimeException;\r\n+\r\n+public class JmsTestClient {\r\n+\r\n+  public  String username =\"weblogic\";\r\n+  public  String password =\"welcome1\";\r\n+\r\n+  public  String clusterurl =\"t3://localhost:7001\";\r\n+  public  String testQueue =\"jms/DistributedQueue\";\r\n+  public  String testcf =\"jms.ClusterConnectionFactory\";\r\n+\r\n+  public JmsTestClient(String[] args)\r", "originalCommit": "f8045c4976d3051296d2a807dd99d99d3b96b1cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzNjkzOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505936939", "bodyText": "/**\n\nThis JMS client that sends 300 messages to a Uniform Distributed Queue\nusing load balancer http(s) url which maps to custom channel on cluster\nmember server on WebLogic cluster.\nIt also verifies that the messages are load balanced across 2 member.\nThe test returns success(0) if it finds 150 messages on each member\nelse returns failure (-1)\nUsage java JmsTestClient http(s)://host:port\n*/", "author": "anpanigr", "createdAt": "2020-10-16T00:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzNTA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzNTk4MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505835980", "bodyText": "missing copyright", "author": "vanajamukkara", "createdAt": "2020-10-15T20:48:29Z", "path": "integration-tests/src/test/resources/tunneling/JmsTestClient.java", "diffHunk": "@@ -0,0 +1,122 @@\n+import java.util.Hashtable;\r", "originalCommit": "f8045c4976d3051296d2a807dd99d99d3b96b1cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzNTEzMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1975#discussion_r505935132", "bodyText": "// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.", "author": "anpanigr", "createdAt": "2020-10-16T00:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzNTk4MA=="}], "type": "inlineReview"}, {"oid": "356a793abc8543a40400c57f36c5958c8451501e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/356a793abc8543a40400c57f36c5958c8451501e", "message": "Addressed more review comments", "committedDate": "2020-10-16T01:08:27Z", "type": "commit"}, {"oid": "e3eef5318b5858f47a53f9536d6d9e1a9cf95fd6", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e3eef5318b5858f47a53f9536d6d9e1a9cf95fd6", "message": "Added more description and modified the assettion to check command line execution", "committedDate": "2020-10-16T17:24:41Z", "type": "commit"}, {"oid": "f88ad661614dbd83455d2474557002f6b93c1d78", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f88ad661614dbd83455d2474557002f6b93c1d78", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into rmi-jms", "committedDate": "2020-10-16T17:24:49Z", "type": "commit"}, {"oid": "fbe8ae1df6756adc977a5422ef6b04a81c3f4d0b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/fbe8ae1df6756adc977a5422ef6b04a81c3f4d0b", "message": "Merge confilct on TestConstants.java with develop branch", "committedDate": "2020-10-19T00:05:51Z", "type": "commit"}]}