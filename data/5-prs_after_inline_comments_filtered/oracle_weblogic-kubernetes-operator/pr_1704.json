{"pr_number": 1704, "pr_title": "Added infra support for monitoring exporter", "pr_createdAt": "2020-06-03T17:04:14Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704", "timeline": [{"oid": "4c0f0e35830cc64e1a4972185b0c09eba2133622", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4c0f0e35830cc64e1a4972185b0c09eba2133622", "message": "added prom support", "committedDate": "2020-05-27T17:07:38Z", "type": "commit"}, {"oid": "3a6d44b33048c9e8093ddfd5be6dc3e04d7fbdc3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3a6d44b33048c9e8093ddfd5be6dc3e04d7fbdc3", "message": "merge", "committedDate": "2020-05-27T17:13:03Z", "type": "commit"}, {"oid": "9733f9718e65f6587ff570e5dcab17022aefd94f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9733f9718e65f6587ff570e5dcab17022aefd94f", "message": "added support for coord, webhook", "committedDate": "2020-06-01T02:02:05Z", "type": "commit"}, {"oid": "83bce0092691778587c4c8f720b919d9b93f405b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/83bce0092691778587c4c8f720b919d9b93f405b", "message": "merge with develop", "committedDate": "2020-06-01T02:28:06Z", "type": "commit"}, {"oid": "8d21ca470d7aca52f0c1d8216f0e80c107c7b79f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8d21ca470d7aca52f0c1d8216f0e80c107c7b79f", "message": "fixed typos", "committedDate": "2020-06-01T02:36:11Z", "type": "commit"}, {"oid": "3619c1d635d83424b5ce0900baf62bd7411b7b57", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3619c1d635d83424b5ce0900baf62bd7411b7b57", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into promtest", "committedDate": "2020-06-01T15:39:18Z", "type": "commit"}, {"oid": "8b663d70caf24fedd788eba4c475f1f5089dfe80", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8b663d70caf24fedd788eba4c475f1f5089dfe80", "message": "added support to deploy archived file", "committedDate": "2020-06-02T17:38:28Z", "type": "commit"}, {"oid": "ec54129757cfa6aadb61140cc278f7621eebab8e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ec54129757cfa6aadb61140cc278f7621eebab8e", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into promtest", "committedDate": "2020-06-02T17:38:40Z", "type": "commit"}, {"oid": "953e86eefe00968e4cee5d52561f12e679324d71", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/953e86eefe00968e4cee5d52561f12e679324d71", "message": "fixed monexp app check", "committedDate": "2020-06-02T18:11:34Z", "type": "commit"}, {"oid": "f54e67f3dd40ef1940572b6e81ca203e7ef275a2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f54e67f3dd40ef1940572b6e81ca203e7ef275a2", "message": "fixed style", "committedDate": "2020-06-02T22:43:03Z", "type": "commit"}, {"oid": "274e36bb2af2eec639a0f90523faa9a5ad00c99b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/274e36bb2af2eec639a0f90523faa9a5ad00c99b", "message": "fixed style1", "committedDate": "2020-06-02T22:45:26Z", "type": "commit"}, {"oid": "fd2a7e3b627d8221cb39635fac9cfde87f45ef1c", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/fd2a7e3b627d8221cb39635fac9cfde87f45ef1c", "message": "fixed push image", "committedDate": "2020-06-03T02:11:01Z", "type": "commit"}, {"oid": "15f2f56078fe2583236ac6d90b23b9915e9e1060", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/15f2f56078fe2583236ac6d90b23b9915e9e1060", "message": "fixed style", "committedDate": "2020-06-03T15:10:37Z", "type": "commit"}, {"oid": "336fcf99713b9352a9cae4a7fcbccfcdf2087d17", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/336fcf99713b9352a9cae4a7fcbccfcdf2087d17", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into promtest", "committedDate": "2020-06-03T15:10:46Z", "type": "commit"}, {"oid": "a3d918be49df6f22c650ab52cc21f79be9b2fbe0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a3d918be49df6f22c650ab52cc21f79be9b2fbe0", "message": "fixed deployment delete", "committedDate": "2020-06-03T16:10:04Z", "type": "commit"}, {"oid": "8308ec0ed935b1bf89f3477a6b30ca29c7b2332a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8308ec0ed935b1bf89f3477a6b30ca29c7b2332a", "message": "cleanup", "committedDate": "2020-06-03T17:10:08Z", "type": "commit"}, {"oid": "f8828d6bc3e02d9e4e8b2c382a17db5fe842e7cb", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f8828d6bc3e02d9e4e8b2c382a17db5fe842e7cb", "message": "cleanup", "committedDate": "2020-06-03T17:13:25Z", "type": "commit"}, {"oid": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "message": "cleanup", "committedDate": "2020-06-03T17:22:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3Nzg1NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434777855", "bodyText": "an unnecessary line break", "author": "sankarpn", "createdAt": "2020-06-03T18:41:59Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -580,6 +589,48 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  /**\n+   * Archive an application from provided ear or war file that can be used by WebLogic Image Tool\n+   * to create an image with the application for a model-in-image use case.\n+   *\n+   * @param srcFile full path to ear or war application file to archive\n+   * @return true if the operation succeeds\n+   */\n+  public static boolean archiveApp(\n+      String srcFile) {", "originalCommit": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NjA4Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436046087", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-06-05T16:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3Nzg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3OTM0Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434779342", "bodyText": "add a import for java.nio.file.Files and java.nio.file.Paths", "author": "sankarpn", "createdAt": "2020-06-03T18:44:45Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -580,6 +589,48 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  /**\n+   * Archive an application from provided ear or war file that can be used by WebLogic Image Tool\n+   * to create an image with the application for a model-in-image use case.\n+   *\n+   * @param srcFile full path to ear or war application file to archive\n+   * @return true if the operation succeeds\n+   */\n+  public static boolean archiveApp(\n+      String srcFile) {\n+\n+    String appName = srcFile.substring(srcFile.lastIndexOf(\"/\") + 1, srcFile.lastIndexOf(\".\"));\n+    String fileExtension = srcFile.substring(srcFile.lastIndexOf(\".\") + 1, srcFile.length());\n+    try {\n+      String appDir = ARCHIVE_DIR + \"/wlsdeploy/applications\";\n+      cleanupDirectory(appDir);\n+      checkDirectory(appDir);\n+      logger.info(\"copy {0]} to {1} \", srcFile, appDir);\n+      java.nio.file.Files.copy(java.nio.file.Paths.get(srcFile), java.nio.file.Paths.get(appDir,", "originalCommit": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NTk4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436045989", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-06-05T16:57:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3OTM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDE3MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434780170", "bodyText": "same as above comment.", "author": "sankarpn", "createdAt": "2020-06-03T18:46:12Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -580,6 +589,48 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  /**\n+   * Archive an application from provided ear or war file that can be used by WebLogic Image Tool\n+   * to create an image with the application for a model-in-image use case.\n+   *\n+   * @param srcFile full path to ear or war application file to archive\n+   * @return true if the operation succeeds\n+   */\n+  public static boolean archiveApp(\n+      String srcFile) {\n+\n+    String appName = srcFile.substring(srcFile.lastIndexOf(\"/\") + 1, srcFile.lastIndexOf(\".\"));\n+    String fileExtension = srcFile.substring(srcFile.lastIndexOf(\".\") + 1, srcFile.length());\n+    try {\n+      String appDir = ARCHIVE_DIR + \"/wlsdeploy/applications\";\n+      cleanupDirectory(appDir);\n+      checkDirectory(appDir);\n+      logger.info(\"copy {0]} to {1} \", srcFile, appDir);\n+      java.nio.file.Files.copy(java.nio.file.Paths.get(srcFile), java.nio.file.Paths.get(appDir,\n+          appName + \".\"\n+              + fileExtension),\n+          java.nio.file.StandardCopyOption.REPLACE_EXISTING);", "originalCommit": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NTkzMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436045932", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-06-05T16:56:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDE3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDkyMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434780920", "bodyText": "remove unused imports", "author": "sankarpn", "createdAt": "2020-06-03T18:47:37Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;", "originalCommit": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NTgxMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436045813", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-06-05T16:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MjU1Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434782552", "bodyText": "Missing javadoc", "author": "sankarpn", "createdAt": "2020-06-03T18:50:35Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test", "originalCommit": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NTczMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436045730", "bodyText": "added", "author": "marinakog", "createdAt": "2020-06-05T16:56:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MjU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MjgyNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434782824", "bodyText": "is this needed?", "author": "sankarpn", "createdAt": "2020-06-03T18:51:03Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)", "originalCommit": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NTYzMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436045632", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-06-05T16:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MjgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MzM2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r434783364", "bodyText": "Does this need any update?", "author": "sankarpn", "createdAt": "2020-06-03T18:52:02Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.", "originalCommit": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NTU3Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436045573", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-06-05T16:56:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MzM2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMDc5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435330795", "bodyText": "This is stale. The PR has been merged.", "author": "sankarpn", "createdAt": "2020-06-04T15:05:27Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");\n+    createPvAndPvc(\"alertmanager\");\n+    createPvAndPvc(\"grafana\");\n+\n+    logger.info(\"create a staging location for monitoring creation scripts\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"ItMonitoringExporter\", \"promCreateTempValueFile\");\n+    FileUtils.deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+\n+    logger.info(\"copy the promvalue.yaml to staging location\");\n+    Path srcPromFile = Paths.get(RESOURCE_DIR, \"exporter\", \"promvalues.yaml\");\n+    Path targetPromFile = Paths.get(fileTemp.toString(), \"promvalues.yaml\");\n+    Files.copy(srcPromFile, targetPromFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain1;cluster-1\",\n+        \"regex: \" + domain1Namespace\n+        + \";\"\n+        + domain1Uid\n+        + \";cluster-1\");\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain2;cluster-1\",\n+        \"regex: \" + domain2Namespace\n+            + \";\"\n+            + domain2Uid\n+            + \";cluster-1\");\n+    int nodeportalertmanserver = getNextFreePort(30400, 30600);\n+    nodeportserver = getNextFreePort(32400, 32600);\n+\n+    promHelmParams = installAndVerifyPrometheus(\"prometheus\",\n+         monitoringNS,\n+        targetPromFile.toString(),\n+         PROMETHEUS_CHART_VERSION,\n+         nodeportserver,\n+         nodeportalertmanserver);\n+    logger.info(\"Prometheus is running\");\n+\n+    int nodeportgrafana = getNextFreePort(31000, 31200);\n+    grafanaHelmParams = installAndVerifyGrafana(\"grafana\",\n+        monitoringNS,\n+        monitoringExporterEndToEndDir + \"/grafana/values.yaml\",\n+        GRAFANA_CHART_VERSION,\n+        nodeportgrafana);\n+    logger.info(\"Grafana is running\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterEndToEndDir + \"/webhook\",\n+        \"webhook\",\n+        webhookNS,\n+        \"app=webhook\", REPO_SECRET_NAME), \"Failed to start webhook\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterSrcDir + \"/config_coordinator\",\n+        \"coordinator\",\n+        domain1Namespace,\n+        \"app=coordinator\", \"coordsecret\"), \"Failed to start coordinator\");\n+\n+    //verify access to Monitoring Exporter\n+    verifyMonExpAppAccessThroughNginx();\n+    //verify metrics via prometheus\n+    String testappPrometheusSearchKey =\n+        \"weblogic_servlet_invocation_total_count%7Bapp%3D%22wlsexporter%22%7D%5B15s%5D\";\n+    checkMetricsViaPrometheus(testappPrometheusSearchKey, \"wlsexporter\");\n+  }\n+\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged", "originalCommit": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NTQ5NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436045494", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-06-05T16:56:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMDc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMTI4NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435331285", "bodyText": "shutdown the domain before deleting CRD", "author": "sankarpn", "createdAt": "2020-06-04T15:06:09Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");\n+    createPvAndPvc(\"alertmanager\");\n+    createPvAndPvc(\"grafana\");\n+\n+    logger.info(\"create a staging location for monitoring creation scripts\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"ItMonitoringExporter\", \"promCreateTempValueFile\");\n+    FileUtils.deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+\n+    logger.info(\"copy the promvalue.yaml to staging location\");\n+    Path srcPromFile = Paths.get(RESOURCE_DIR, \"exporter\", \"promvalues.yaml\");\n+    Path targetPromFile = Paths.get(fileTemp.toString(), \"promvalues.yaml\");\n+    Files.copy(srcPromFile, targetPromFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain1;cluster-1\",\n+        \"regex: \" + domain1Namespace\n+        + \";\"\n+        + domain1Uid\n+        + \";cluster-1\");\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain2;cluster-1\",\n+        \"regex: \" + domain2Namespace\n+            + \";\"\n+            + domain2Uid\n+            + \";cluster-1\");\n+    int nodeportalertmanserver = getNextFreePort(30400, 30600);\n+    nodeportserver = getNextFreePort(32400, 32600);\n+\n+    promHelmParams = installAndVerifyPrometheus(\"prometheus\",\n+         monitoringNS,\n+        targetPromFile.toString(),\n+         PROMETHEUS_CHART_VERSION,\n+         nodeportserver,\n+         nodeportalertmanserver);\n+    logger.info(\"Prometheus is running\");\n+\n+    int nodeportgrafana = getNextFreePort(31000, 31200);\n+    grafanaHelmParams = installAndVerifyGrafana(\"grafana\",\n+        monitoringNS,\n+        monitoringExporterEndToEndDir + \"/grafana/values.yaml\",\n+        GRAFANA_CHART_VERSION,\n+        nodeportgrafana);\n+    logger.info(\"Grafana is running\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterEndToEndDir + \"/webhook\",\n+        \"webhook\",\n+        webhookNS,\n+        \"app=webhook\", REPO_SECRET_NAME), \"Failed to start webhook\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterSrcDir + \"/config_coordinator\",\n+        \"coordinator\",\n+        domain1Namespace,\n+        \"app=coordinator\", \"coordsecret\"), \"Failed to start coordinator\");\n+\n+    //verify access to Monitoring Exporter\n+    verifyMonExpAppAccessThroughNginx();\n+    //verify metrics via prometheus\n+    String testappPrometheusSearchKey =\n+        \"weblogic_servlet_invocation_total_count%7Bapp%3D%22wlsexporter%22%7D%5B15s%5D\";\n+    checkMetricsViaPrometheus(testappPrometheusSearchKey, \"wlsexporter\");\n+  }\n+\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged\n+   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domain1Namespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domain1Uid, domain1Namespace),", "originalCommit": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NTQxMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436045413", "bodyText": "done", "author": "marinakog", "createdAt": "2020-06-05T16:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMTI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4ODUyMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435388522", "bodyText": "This can be moved to a utils class.", "author": "vanajamukkara", "createdAt": "2020-06-04T16:25:35Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");\n+    createPvAndPvc(\"alertmanager\");\n+    createPvAndPvc(\"grafana\");\n+\n+    logger.info(\"create a staging location for monitoring creation scripts\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"ItMonitoringExporter\", \"promCreateTempValueFile\");\n+    FileUtils.deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+\n+    logger.info(\"copy the promvalue.yaml to staging location\");\n+    Path srcPromFile = Paths.get(RESOURCE_DIR, \"exporter\", \"promvalues.yaml\");\n+    Path targetPromFile = Paths.get(fileTemp.toString(), \"promvalues.yaml\");\n+    Files.copy(srcPromFile, targetPromFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain1;cluster-1\",\n+        \"regex: \" + domain1Namespace\n+        + \";\"\n+        + domain1Uid\n+        + \";cluster-1\");\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain2;cluster-1\",\n+        \"regex: \" + domain2Namespace\n+            + \";\"\n+            + domain2Uid\n+            + \";cluster-1\");\n+    int nodeportalertmanserver = getNextFreePort(30400, 30600);\n+    nodeportserver = getNextFreePort(32400, 32600);\n+\n+    promHelmParams = installAndVerifyPrometheus(\"prometheus\",\n+         monitoringNS,\n+        targetPromFile.toString(),\n+         PROMETHEUS_CHART_VERSION,\n+         nodeportserver,\n+         nodeportalertmanserver);\n+    logger.info(\"Prometheus is running\");\n+\n+    int nodeportgrafana = getNextFreePort(31000, 31200);\n+    grafanaHelmParams = installAndVerifyGrafana(\"grafana\",\n+        monitoringNS,\n+        monitoringExporterEndToEndDir + \"/grafana/values.yaml\",\n+        GRAFANA_CHART_VERSION,\n+        nodeportgrafana);\n+    logger.info(\"Grafana is running\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterEndToEndDir + \"/webhook\",\n+        \"webhook\",\n+        webhookNS,\n+        \"app=webhook\", REPO_SECRET_NAME), \"Failed to start webhook\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterSrcDir + \"/config_coordinator\",\n+        \"coordinator\",\n+        domain1Namespace,\n+        \"app=coordinator\", \"coordsecret\"), \"Failed to start coordinator\");\n+\n+    //verify access to Monitoring Exporter\n+    verifyMonExpAppAccessThroughNginx();\n+    //verify metrics via prometheus\n+    String testappPrometheusSearchKey =\n+        \"weblogic_servlet_invocation_total_count%7Bapp%3D%22wlsexporter%22%7D%5B15s%5D\";\n+    checkMetricsViaPrometheus(testappPrometheusSearchKey, \"wlsexporter\");\n+  }\n+\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged\n+   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domain1Namespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domain1Uid, domain1Namespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+    Prometheus.uninstall(promHelmParams);\n+    logger.info(\"Prometheus is uninstalled\");\n+\n+    Grafana.uninstall(grafanaHelmParams);\n+    logger.info(\"Grafana is uninstalled\");\n+\n+    deletePersistentVolumeClaim(\"pvc-alertmanager\",monitoringNS);\n+    deletePersistentVolume(\"pv-testalertmanager\");\n+    deletePersistentVolumeClaim(\"pvc-prometheus\",monitoringNS);\n+    deletePersistentVolume(\"pv-testprometheus\");\n+    deletePersistentVolumeClaim(\"pvc-grafana\",monitoringNS);\n+    deletePersistentVolume(\"pv-testgrafana\");\n+    deleteNamespace(monitoringNS);\n+    uninstallDeploymentService(webhookDepl, webhookService);\n+    uninstallDeploymentService(coordinatorDepl, coordinatorService);\n+    uninstallMonitoringExporter();\n+\n+    // uninstall NGINX release\n+    if (nginxHelmParams != null) {\n+      assertThat(uninstallNginx(nginxHelmParams))\n+          .as(\"Test uninstallNginx returns true\")\n+          .withFailMessage(\"uninstallNginx() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   * @param nameSuffix unique nameSuffix for pv and pvc to create\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPvAndPvc(String nameSuffix) throws IOException {\n+    logger.info(\"creating persistent volume and persistent volume claim\");\n+    // create persistent volume and persistent volume claims\n+    Path pvHostPath = assertDoesNotThrow(\n+        () -> createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), \"monexp\" + \"-persistentVolume\")),\n+            \"createDirectories failed with IOException\");\n+    logger.info(\"Creating PV directory {0}\", pvHostPath);\n+    assertDoesNotThrow(() -> deleteDirectory(pvHostPath.toFile()), \"deleteDirectory failed with IOException\");\n+    assertDoesNotThrow(() -> createDirectories(pvHostPath), \"createDirectories failed with IOException\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Retain\")\n+            .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(pvHostPath.toString())))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pv-test\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeName(\"pv-test\" + nameSuffix)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pvc-\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+    createPVPVCAndVerify(v1pv,v1pvc, \"weblogic.domainUid=\" + domain1Uid, monitoringNS);\n+  }\n+\n+  /**", "originalCommit": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NTMzMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436045333", "bodyText": "I use util class but generated pv and pvc are custom objects for grafana, prom, they are different from domain pv/pvc, so I create these objects in the test class but use util method createPVPVCAndVerify from commontestutils to generate them, please let me know", "author": "marinakog", "createdAt": "2020-06-05T16:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4ODUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MTg5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436791895", "bodyText": "My comment was for method replaceStringInFile()", "author": "vanajamukkara", "createdAt": "2020-06-08T15:23:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4ODUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgwMjc0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436802748", "bodyText": "sorry for misunderstanding, moved it to test utils", "author": "marinakog", "createdAt": "2020-06-08T15:38:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4ODUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5MDI4OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435390288", "bodyText": "pod name starts with podName", "author": "vanajamukkara", "createdAt": "2020-06-04T16:28:17Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");\n+    createPvAndPvc(\"alertmanager\");\n+    createPvAndPvc(\"grafana\");\n+\n+    logger.info(\"create a staging location for monitoring creation scripts\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"ItMonitoringExporter\", \"promCreateTempValueFile\");\n+    FileUtils.deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+\n+    logger.info(\"copy the promvalue.yaml to staging location\");\n+    Path srcPromFile = Paths.get(RESOURCE_DIR, \"exporter\", \"promvalues.yaml\");\n+    Path targetPromFile = Paths.get(fileTemp.toString(), \"promvalues.yaml\");\n+    Files.copy(srcPromFile, targetPromFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain1;cluster-1\",\n+        \"regex: \" + domain1Namespace\n+        + \";\"\n+        + domain1Uid\n+        + \";cluster-1\");\n+    replaceStringInFile(targetPromFile.toString(),\n+        \"regex: default;domain2;cluster-1\",\n+        \"regex: \" + domain2Namespace\n+            + \";\"\n+            + domain2Uid\n+            + \";cluster-1\");\n+    int nodeportalertmanserver = getNextFreePort(30400, 30600);\n+    nodeportserver = getNextFreePort(32400, 32600);\n+\n+    promHelmParams = installAndVerifyPrometheus(\"prometheus\",\n+         monitoringNS,\n+        targetPromFile.toString(),\n+         PROMETHEUS_CHART_VERSION,\n+         nodeportserver,\n+         nodeportalertmanserver);\n+    logger.info(\"Prometheus is running\");\n+\n+    int nodeportgrafana = getNextFreePort(31000, 31200);\n+    grafanaHelmParams = installAndVerifyGrafana(\"grafana\",\n+        monitoringNS,\n+        monitoringExporterEndToEndDir + \"/grafana/values.yaml\",\n+        GRAFANA_CHART_VERSION,\n+        nodeportgrafana);\n+    logger.info(\"Grafana is running\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterEndToEndDir + \"/webhook\",\n+        \"webhook\",\n+        webhookNS,\n+        \"app=webhook\", REPO_SECRET_NAME), \"Failed to start webhook\");\n+    assertTrue(installAndVerifyPodFromCustomImage(monitoringExporterSrcDir + \"/config_coordinator\",\n+        \"coordinator\",\n+        domain1Namespace,\n+        \"app=coordinator\", \"coordsecret\"), \"Failed to start coordinator\");\n+\n+    //verify access to Monitoring Exporter\n+    verifyMonExpAppAccessThroughNginx();\n+    //verify metrics via prometheus\n+    String testappPrometheusSearchKey =\n+        \"weblogic_servlet_invocation_total_count%7Bapp%3D%22wlsexporter%22%7D%5B15s%5D\";\n+    checkMetricsViaPrometheus(testappPrometheusSearchKey, \"wlsexporter\");\n+  }\n+\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged\n+   * The cleanup framework does not uninstall NGINX release. Do it here for now.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domain1Namespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domain1Uid, domain1Namespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domain1Uid + \" from \" + domain1Namespace);\n+    Prometheus.uninstall(promHelmParams);\n+    logger.info(\"Prometheus is uninstalled\");\n+\n+    Grafana.uninstall(grafanaHelmParams);\n+    logger.info(\"Grafana is uninstalled\");\n+\n+    deletePersistentVolumeClaim(\"pvc-alertmanager\",monitoringNS);\n+    deletePersistentVolume(\"pv-testalertmanager\");\n+    deletePersistentVolumeClaim(\"pvc-prometheus\",monitoringNS);\n+    deletePersistentVolume(\"pv-testprometheus\");\n+    deletePersistentVolumeClaim(\"pvc-grafana\",monitoringNS);\n+    deletePersistentVolume(\"pv-testgrafana\");\n+    deleteNamespace(monitoringNS);\n+    uninstallDeploymentService(webhookDepl, webhookService);\n+    uninstallDeploymentService(coordinatorDepl, coordinatorService);\n+    uninstallMonitoringExporter();\n+\n+    // uninstall NGINX release\n+    if (nginxHelmParams != null) {\n+      assertThat(uninstallNginx(nginxHelmParams))\n+          .as(\"Test uninstallNginx returns true\")\n+          .withFailMessage(\"uninstallNginx() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  /**\n+   * Create a persistent volume and persistent volume claim.\n+   * @param nameSuffix unique nameSuffix for pv and pvc to create\n+   * @throws IOException when creating pv path fails\n+   */\n+  private void createPvAndPvc(String nameSuffix) throws IOException {\n+    logger.info(\"creating persistent volume and persistent volume claim\");\n+    // create persistent volume and persistent volume claims\n+    Path pvHostPath = assertDoesNotThrow(\n+        () -> createDirectories(get(PV_ROOT, this.getClass().getSimpleName(), \"monexp\" + \"-persistentVolume\")),\n+            \"createDirectories failed with IOException\");\n+    logger.info(\"Creating PV directory {0}\", pvHostPath);\n+    assertDoesNotThrow(() -> deleteDirectory(pvHostPath.toFile()), \"deleteDirectory failed with IOException\");\n+    assertDoesNotThrow(() -> createDirectories(pvHostPath), \"createDirectories failed with IOException\");\n+\n+    V1PersistentVolume v1pv = new V1PersistentVolume()\n+        .spec(new V1PersistentVolumeSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeMode(\"Filesystem\")\n+            .putCapacityItem(\"storage\", Quantity.fromString(\"10Gi\"))\n+            .persistentVolumeReclaimPolicy(\"Retain\")\n+            .accessModes(Arrays.asList(\"ReadWriteMany\"))\n+            .hostPath(new V1HostPathVolumeSource()\n+                .path(pvHostPath.toString())))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pv-test\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+\n+\n+    V1PersistentVolumeClaim v1pvc = new V1PersistentVolumeClaim()\n+        .spec(new V1PersistentVolumeClaimSpec()\n+            .addAccessModesItem(\"ReadWriteMany\")\n+            .storageClassName(nameSuffix)\n+            .volumeName(\"pv-test\" + nameSuffix)\n+            .resources(new V1ResourceRequirements()\n+                .putRequestsItem(\"storage\", Quantity.fromString(\"10Gi\"))))\n+        .metadata(new V1ObjectMeta()\n+            .name(\"pvc-\" + nameSuffix)\n+            .namespace(monitoringNS)\n+            .putLabelsItem(\"weblogic.domainUid\", domain1Uid));\n+    createPVPVCAndVerify(v1pv,v1pvc, \"weblogic.domainUid=\" + domain1Uid, monitoringNS);\n+  }\n+\n+  /**\n+   * A utility method to sed files.\n+   *\n+   * @throws IOException when copying files from source location to staging area fails\n+   */\n+  private static void replaceStringInFile(String filePath, String oldValue, String newValue)\n+      throws IOException {\n+    Path src = Paths.get(filePath);\n+    logger.info(\"Copying {0}\", src.toString());\n+    Charset charset = StandardCharsets.UTF_8;\n+    String content = new String(Files.readAllBytes(src), charset);\n+    content = content.replaceAll(oldValue, newValue);\n+    logger.info(\"to {0}\", src.toString());\n+    Files.write(src, content.getBytes(charset));\n+  }\n+\n+  /**\n+   * Create, install  Webhook or Coordinator and wait up to five minutes until the pod is ready.\n+   *\n+   * @param dockerFileDir directory where dockerfile is located\n+   * @param baseImageName base image name\n+   * @param namespace namespace\n+   * @return status of installation\n+   */\n+  public static boolean installAndVerifyPodFromCustomImage(String dockerFileDir,\n+                                                String baseImageName,\n+                                                String namespace,\n+                                                String labelSelector,\n+                                                String secretName) throws ApiException {\n+    //build webhook image\n+    String imagePullPolicy = \"IfNotPresent\";\n+    if (!REPO_NAME.isEmpty()) {\n+      imagePullPolicy = \"Always\";\n+    }\n+    String image = createPushImage(dockerFileDir,baseImageName, namespace, secretName);\n+    logger.info(\"Installing {0} in namespace {1}\", baseImageName, namespace);\n+    if (baseImageName.equalsIgnoreCase((\"webhook\"))) {\n+      createWebHook(image, imagePullPolicy, namespace, REPO_SECRET_NAME);\n+    } else if (baseImageName.contains(\"coordinator\")) {\n+      createCoordinator(image, imagePullPolicy, namespace, \"coordsecret\");\n+    } else {\n+      throw new ApiException(\"Custom image creation for \" + baseImageName + \"is not supported\");\n+    }\n+    // wait for the pod to be ready\n+    logger.info(\"Wait for the {0} pod is ready in namespace {1}\", baseImageName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for {0} to be running in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                baseImageName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podIsReady(namespace, labelSelector, baseImageName),\n+            baseImageName + \" podIsReady failed with ApiException\"));\n+    return true;\n+  }\n+\n+  /**\n+   * Create Webhook deployment and service.\n+   *\n+   * @param image full image name for deployment\n+   * @param imagePullPolicy policy for image\n+   * @param namespace webhook namespace\n+   * @param secretName webhook image secret name\n+   */\n+  private static void createWebHook(String image,\n+                                    String imagePullPolicy,\n+                                    String namespace,\n+                                    String secretName) throws ApiException {\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"webhook\");\n+\n+    webhookDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"webhook\")\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .image(image)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"webhook\")))\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(secretName))))));\n+\n+    logger.info(\"Create deployment for webhook in namespace {0}\",\n+        namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(webhookDepl),\n+        String.format(\"Create deployment failed with ApiException for webhook in namespace %s\",\n+            namespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for webhook in namespace %s \",\n+        namespace));\n+\n+    webhookService = new V1Service()\n+        .metadata(new V1ObjectMeta()\n+            .name(\"webhook\")\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .port(8080)\n+                    .protocol(\"TCP\")))\n+            .selector(labels));\n+\n+    logger.info(\"Create service for webhook in namespace {0}\",\n+        namespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(webhookService),\n+        String.format(\"Create service failed with ApiException for webhook in namespace %s\",\n+            namespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create service failed with ApiException for webhook in namespace %s \",\n+        namespace));\n+    // wait for the webhook pod to be ready\n+    logger.info(\"Wait for the webhook pod is ready in namespace {0}\", namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for webhook to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podIsReady(namespace, \"app=webhook\", \"webhook\"),\n+            \"webhook podIsReady failed with ApiException\"));\n+  }\n+\n+  /**\n+   * Uninstall provided deployment and service.\n+   */\n+  private static void uninstallDeploymentService(V1Deployment deployment, V1Service service) {\n+    String namespace = null;\n+    String serviceName = null;\n+    String deploymentName = null;\n+    try {\n+      if (service != null) {\n+        serviceName = service.getMetadata().getName();\n+        namespace = service.getMetadata().getNamespace();\n+        Kubernetes.deleteService(serviceName, namespace);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete service {0} in namespace {1} \",\n+          serviceName, namespace);\n+    }\n+    try {\n+      if (deployment != null) {\n+        deploymentName = deployment.getMetadata().getName();\n+        namespace = deployment.getMetadata().getNamespace();\n+        Kubernetes.deleteDeployment(namespace, deploymentName);\n+      }\n+    } catch (Exception ex) {\n+      logger.warning(ex.getMessage());\n+      logger.warning(\"Failed to delete deployment {0} in namespace {1}\",\n+          deploymentName, namespace);\n+    }\n+    if (namespace != null) {\n+      deleteNamespace(namespace);\n+    }\n+  }\n+\n+  /**\n+   * Create Coordinator deployment and service.\n+   *\n+   * @param image full image name for deployment\n+   * @param imagePullPolicy policy for image\n+   * @param namespace coordinator namespace\n+   * @param secretName coordinator secret name\n+   */\n+  private static void createCoordinator(String image,\n+                                        String imagePullPolicy,\n+                                        String namespace,\n+                                        String secretName) throws ApiException {\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", \"coordinator\");\n+    coordinatorDepl = new V1Deployment()\n+        .apiVersion(\"apps/v1\")\n+        .kind(\"Deployment\")\n+        .metadata(new V1ObjectMeta()\n+            .name(\"coordinator\")\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1DeploymentSpec()\n+            .replicas(1)\n+            .selector(new V1LabelSelector()\n+                .matchLabels(labels))\n+            .strategy(new V1DeploymentStrategy()\n+            .type(\"Recreate\"))\n+            .template(new V1PodTemplateSpec()\n+                .metadata(new V1ObjectMeta()\n+                    .labels(labels))\n+                .spec(new V1PodSpec()\n+                    .containers(Arrays.asList(\n+                        new V1Container()\n+                            .image(image)\n+                            .imagePullPolicy(imagePullPolicy)\n+                            .name(\"coordinator\")\n+                    .ports(Arrays.asList(\n+                        new V1ContainerPort()\n+                        .containerPort(8999)))))\n+                    .imagePullSecrets(Arrays.asList(\n+                        new V1LocalObjectReference()\n+                            .name(secretName))))));\n+\n+    logger.info(\"Create deployment for coordinator in namespace {0}\",\n+        namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(coordinatorDepl),\n+        String.format(\"Create deployment failed with ApiException for coordinator in namespace %s\",\n+            namespace));\n+    assertTrue(deploymentCreated, String.format(\n+        \"Create deployment failed with ApiException for coordinator in namespace %s \",\n+        namespace));\n+\n+    coordinatorService = new V1Service()\n+        .metadata(new V1ObjectMeta()\n+            .name(\"coordinator\")\n+            .namespace(namespace)\n+            .labels(labels))\n+        .spec(new V1ServiceSpec()\n+            .ports(Arrays.asList(\n+                new V1ServicePort()\n+                    .port(8999)\n+                    .targetPort(new IntOrString(8999))))\n+            .type(\"NodePort\")\n+            .selector(labels));\n+\n+    logger.info(\"Create service for coordinator in namespace {0}\",\n+        namespace);\n+    boolean success = assertDoesNotThrow(() -> Kubernetes.createService(coordinatorService),\n+        String.format(\"Create service failed with ApiException for coordinator in namespace %s\",\n+            namespace));\n+    assertTrue(success, \"Coordinator service creation failed\");\n+  }\n+\n+  /**\n+   * Checks if the pod is running in a given namespace.\n+   * The method assumes the pod name to starts with podName", "originalCommit": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NDI1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436044253", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-06-05T16:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5MDI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5NzU5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435397595", "bodyText": "TestActions class should not contain the implementation, it should call impl class.", "author": "vanajamukkara", "createdAt": "2020-06-04T16:39:56Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -580,6 +589,48 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  /**\n+   * Archive an application from provided ear or war file that can be used by WebLogic Image Tool\n+   * to create an image with the application for a model-in-image use case.\n+   *\n+   * @param srcFile full path to ear or war application file to archive\n+   * @return true if the operation succeeds\n+   */\n+  public static boolean archiveApp(", "originalCommit": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NDE5MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436044191", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-06-05T16:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5NzU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5ODgwMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435398801", "bodyText": "isPrometheusReady()", "author": "vanajamukkara", "createdAt": "2020-06-04T16:41:47Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -450,6 +452,27 @@ public static boolean podStateNotChanged(String podName,\n   }\n \n   /**\n+   * Check if Prometheus is running.\n+   *\n+   * @param namespace in which is prometheus is running\n+   * @return true if running false otherwise\n+   */\n+  public static Callable<Boolean> prometheusIsReady(String namespace) {", "originalCommit": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NDEyOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436044128", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-06-05T16:53:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5ODgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5ODkwMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435398902", "bodyText": "isGrafanaReady()", "author": "vanajamukkara", "createdAt": "2020-06-04T16:41:58Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -450,6 +452,27 @@ public static boolean podStateNotChanged(String podName,\n   }\n \n   /**\n+   * Check if Prometheus is running.\n+   *\n+   * @param namespace in which is prometheus is running\n+   * @return true if running false otherwise\n+   */\n+  public static Callable<Boolean> prometheusIsReady(String namespace) {\n+\n+    return Prometheus.isReady(namespace);\n+  }\n+\n+  /**\n+   * Check if Grafana is running.\n+   *\n+   * @param namespace in which is grafana is running\n+   * @return true if running false otherwise\n+   */\n+  public static Callable<Boolean> grafanaIsReady(String namespace) {", "originalCommit": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0NDA2NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436044065", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-06-05T16:53:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5ODkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3Mjg5NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r435472894", "bodyText": "Can we make the method createPvAndPvc() as action method in TestAction class.  I see similar local methods in ItDomainInPV class", "author": "anpanigr", "createdAt": "2020-06-04T18:41:00Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMonitoringExporter.java", "diffHunk": "@@ -0,0 +1,1007 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1DeploymentStrategy;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.Grafana;\n+import oracle.weblogic.kubernetes.actions.impl.Namespace;\n+import oracle.weblogic.kubernetes.actions.impl.Prometheus;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.CommandParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Docker;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.nio.file.Files.createDirectories;\n+import static java.nio.file.Paths.get;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.GRAFANA_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MANAGED_SERVER_NAME_BASE;\n+import static oracle.weblogic.kubernetes.TestConstants.MONITORING_EXPORTER_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PROMETHEUS_CHART_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MONITORING_EXPORTER_DOWNLOAD_URL;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+//import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deletePersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.createNamespace;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes.deleteNamespace;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.listPods;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createIngressForDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createMiiImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createPVPVCAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyGrafana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyNginx;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyPrometheus;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the model in image domain with multiple clusters can be scaled up and down.\n+ * Also verify the sample application can be accessed via NGINX ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify WebLogic Metric is processed as expected by MonitoringExporter via Prometheus and Grafana\")\n+@IntegrationTest\n+class ItMonitoringExporter implements LoggedTest {\n+\n+\n+  // domain constants\n+  private static final int NUMBER_OF_CLUSTERS = 2;\n+  private static final String CLUSTER_NAME_PREFIX = \"cluster-\";\n+  private static final int MANAGED_SERVER_PORT = 8001;\n+  private static final int replicaCount = 2;\n+\n+  private static String domain1Namespace = null;\n+  private static String domain2Namespace = null;\n+  private static String domain1Uid = \"monexp-domain1\";\n+  private static String domain2Uid = \"monexp-domain2\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static int nodeportshttp = 0;\n+  private static List<String> ingressHostList = null;\n+\n+  private String curlCmd = null;\n+  private static String monitoringNS = null;\n+  private static String webhookNS = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  HelmParams promHelmParams = null;\n+  HelmParams grafanaHelmParams = null;\n+  private static String monitoringExporterEndToEndDir = null;\n+  private static String monitoringExporterSrcDir = null;\n+  private static String monitoringExporterAppDir = null;\n+  private static V1Service webhookService = null;\n+  private static V1Deployment webhookDepl = null;\n+  private static V1Service coordinatorService = null;\n+  private static V1Deployment coordinatorDepl = null;\n+  // constants for creating domain image using model in image\n+  private static final String MONEXP_MODEL_FILE = \"model.monexp.yaml\";\n+  private static final String MONEXP_IMAGE_NAME = \"mii-image\";\n+\n+  // constants for web service\n+  private static final String MONEXP_APP_NAME = \"monexp-app\";\n+  private static final String MONEXP_APP_WAR_NAME = \"monexp-war\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domain1Uid + \"-admin-server\";\n+  private static String managedServerPrefix = domain1Uid + \"-managed-server\";\n+  private static int managedServerPort = 8001;\n+  private static int nodeportserver;\n+\n+  /**\n+   * Install operator and NGINX. Create model in image domain with multiple clusters.\n+   * Create ingress for the domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(6) List<String> namespaces) {\n+\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    final String opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain1\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domain1Namespace = namespaces.get(1);\n+\n+    logger.info(\"Get a unique namespace for WebLogic domain2\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    domain2Namespace = namespaces.get(2);\n+\n+    // get a unique monitoring namespace\n+    logger.info(\"Get a unique namespace for monitoring\");\n+    assertNotNull(namespaces.get(3), \"Namespace list is null\");\n+    monitoringNS = namespaces.get(3);\n+\n+    // get a unique webhook namespace\n+    logger.info(\"Get a unique namespace for webhook\");\n+    assertNotNull(namespaces.get(4), \"Namespace list is null\");\n+    webhookNS = namespaces.get(4);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(5), \"Namespace list is null\");\n+    final String nginxNamespace = namespaces.get(5);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domain1Namespace,domain2Namespace);\n+\n+    //install monitoring exporter\n+    installMonitoringExporter();\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String imageName = createAndVerifyDomainImage();\n+\n+    // create and verify one cluster domain\n+    logger.info(\"Create domain and verify that it's running\");\n+    createAndVerifyDomain(imageName, domain1Uid);\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    int nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    nginxHelmParams = installAndVerifyNginx(nginxNamespace, nodeportshttp, nodeportshttps);\n+    // create ingress for the domain\n+    logger.info(\"Creating ingress for domain {0} in namespace {1}\", domain1Uid, domain1Namespace);\n+    Map<String, Integer> clusterNameMsPortMap = new HashMap<>();\n+    clusterNameMsPortMap.put(clusterName, managedServerPort);\n+    ingressHostList =\n+        createIngressForDomainAndVerify(domain1Uid, domain1Namespace, clusterNameMsPortMap);\n+\n+  }\n+\n+  @Test\n+  @DisplayName(\"Install Prometheus, Grafana , Webhook, Coordinator and verify WebLogic metrics\")\n+  public void testCheckMetrics() throws Exception {\n+\n+    createPvAndPvc(\"prometheus\");", "originalCommit": "6c0069fcdd5dd1b5c17bc523c57b421ab4210cd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzMzQyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436133429", "bodyText": "we have test in commontestutils, it takes v1pv and pvc params, the pv and pvc created in this test are specific to prom and grafana, so I think it is ok to keep in test class, please let me know", "author": "marinakog", "createdAt": "2020-06-05T19:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3Mjg5NA=="}], "type": "inlineReview"}, {"oid": "af1b8a8538a46bca0eae23e250fc85439b71e0d6", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/af1b8a8538a46bca0eae23e250fc85439b71e0d6", "message": "addressed comments from review", "committedDate": "2020-06-04T23:18:31Z", "type": "commit"}, {"oid": "9a2a8c241214d86f1ff46ba85e3b4a146272a595", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9a2a8c241214d86f1ff46ba85e3b4a146272a595", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into promtest", "committedDate": "2020-06-04T23:18:39Z", "type": "commit"}, {"oid": "5633729bddf3c70f1ed36f67cd176dbbf3a2f82e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5633729bddf3c70f1ed36f67cd176dbbf3a2f82e", "message": "checkstyle", "committedDate": "2020-06-05T00:01:54Z", "type": "commit"}, {"oid": "c154d759b9e59d3c5589e99da7d3673ddb6b7aa4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c154d759b9e59d3c5589e99da7d3673ddb6b7aa4", "message": "fixed logic", "committedDate": "2020-06-05T06:29:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzNDAzNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436034034", "bodyText": "can you replace the above 2 methods with this? You can use this method in Grafana,Prometheus\n/**\n*\n\nChecks if a pod is ready in a given namespace.\n\n@param namespace in which to check if the pod is ready\n@param labels map of labels as key value pairs\n@param podName name of the pod to check for\n@return true if the pod is in the ready condition, false otherwise\n@throws ApiException if Kubernetes client API call fails\n*/\npublic static boolean isPodReady(String namespace, Map<String, String> labels, String podName) throws ApiException {\nboolean status = false;\nString labelSelector = null;\n\nif (labels != null && !labels.isEmpty()) {\n  labelSelector = labels.entrySet()\n      .stream()\n      .map(e -> e.getKey() + \"=\" + e.getValue())\n      .collect(Collectors.joining(\",\"));\n}\n\nV1Pod pod = getPod(namespace, labelSelector, podName);\nif (pod != null) {\n\n  // get the podCondition with the 'Ready' type field\n  V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n      .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n      .findAny()\n      .orElse(null);\n\n  if (v1PodReadyCondition != null) {\n    status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n    if (status) {\n      logger.info(\"Pod {0} is READY in namespace {1}\", podName, namespace);\n    }\n  }\n} else {\n  logger.info(\"Pod {0} does not exist in namespace {1}\", podName, namespace);\n}\nreturn status;\n\n}", "author": "sankarpn", "createdAt": "2020-06-05T16:33:24Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -595,6 +595,77 @@ public static boolean isPodRestarted(\n     return false;\n   }\n \n+  /**\n+   * Checks if the promethues pods are running in a given namespace.\n+   * The method assumes the prometheus pods name to starts with prometheus-server, alertmanager\n+   * and decorated with label prometheus\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pods are exist and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean arePrometheusPodsReady(String namespace) throws ApiException {\n+    boolean status = false;\n+\n+    V1Pod pod = getPod(namespace, \"component=alertmanager\", \"prometheus-alertmanager\");\n+    if (pod != null) {\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+      }\n+    } else {\n+      logger.info(\"Prometheus-alertmanager pods don't exist\");\n+    }\n+\n+    pod = getPod(namespace, \"component=server\", \"prometheus-server\");\n+    if (pod != null) {\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+      }\n+    } else {\n+      logger.info(\"Prometheus-server pods don't exist\");\n+    }\n+    return status;\n+  }\n+\n+  /**\n+   * Checks if the grafana pod is running in a given namespace.\n+   * The method assumes the grafana pod name to starts with grafana\n+   * and decorated with label grafana\n+   * @param namespace in which to check for the pod existence\n+   * @return true if pods are exist and running otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean isGrafanaPodReady(String namespace) throws ApiException {\n+    boolean status = false;\n+\n+    V1Pod pod = getPod(namespace, \"app.kubernetes.io/name=grafana\", \"grafana\");\n+    if (pod != null) {\n+      // get the podCondition with the 'Ready' type field\n+      V1PodCondition v1PodReadyCondition = pod.getStatus().getConditions().stream()\n+          .filter(v1PodCondition -> \"Ready\".equals(v1PodCondition.getType()))\n+          .findAny()\n+          .orElse(null);\n+\n+      if (v1PodReadyCondition != null) {\n+        status = v1PodReadyCondition.getStatus().equalsIgnoreCase(\"true\");\n+      }\n+    } else {\n+      logger.info(\"Grafana pod doesn't exist\");\n+    }\n+    return status;\n+  }\n+", "originalCommit": "5633729bddf3c70f1ed36f67cd176dbbf3a2f82e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzMjM0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436132344", "bodyText": "done", "author": "marinakog", "createdAt": "2020-06-05T19:52:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzNDAzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNzc1Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436137757", "bodyText": "it may not work, since the other method can accept a null for domainUid and that can cause ambiguity as to which overridden method should be called.\nWe may have to fix this later. so don't worry about it for now.", "author": "sankarpn", "createdAt": "2020-06-05T20:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzNDAzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NDg0OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436144849", "bodyText": "so I added this for isReadyNginx,     String labelSelector = null;\nreturn isPodReady(namespace, labelSelector, \"nginx-ingress-controller\");, so it works. Also both check for null, and execute same code for that", "author": "marinakog", "createdAt": "2020-06-05T20:18:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzNDAzNA=="}], "type": "inlineReview"}, {"oid": "05b7044280e0dca89df35a1e7ebd4d7b4da1f3e2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/05b7044280e0dca89df35a1e7ebd4d7b4da1f3e2", "message": "modified isPodReady", "committedDate": "2020-06-05T19:48:41Z", "type": "commit"}, {"oid": "eb12375980da4a7c2fd2639ebcb4bd78d2e8ac58", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/eb12375980da4a7c2fd2639ebcb4bd78d2e8ac58", "message": "merge", "committedDate": "2020-06-05T19:50:51Z", "type": "commit"}, {"oid": "cf6004aba59b0987486d4f5cb8bc0edea3e4820d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cf6004aba59b0987486d4f5cb8bc0edea3e4820d", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into promtest", "committedDate": "2020-06-08T15:31:13Z", "type": "commit"}, {"oid": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f53a37a1d6397f70bfaca98042e1b37b0e8d2c64", "message": "moved replaceString to testutils", "committedDate": "2020-06-08T15:34:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgxODU2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436818560", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * install helm chart.\n          \n          \n            \n               * Install Prometheus.", "author": "sankarpn", "createdAt": "2020-06-08T16:00:59Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Prometheus.java", "diffHunk": "@@ -0,0 +1,29 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Helm;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+\n+public class Prometheus {\n+  /**\n+   * install helm chart.", "originalCommit": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MDk5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436880996", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-06-08T17:39:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgxODU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgxODkwNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436818906", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Uninstall a helm release.\n          \n          \n            \n               * Uninstall a Prometheus release.", "author": "sankarpn", "createdAt": "2020-06-08T16:01:30Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Prometheus.java", "diffHunk": "@@ -0,0 +1,29 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Helm;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+\n+public class Prometheus {\n+  /**\n+   * install helm chart.\n+   * @param params the helm parameters like namespace, release name, repo url or chart dir,\n+   *               chart name and chart values to override\n+   * @return true on success, false otherwise\n+   */\n+  public static boolean install(PrometheusParams params) {\n+    return Helm.install(params.getHelmParams(), params.getValues());\n+  }\n+\n+  /**\n+   * Uninstall a helm release.", "originalCommit": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTA4OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436881088", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-06-08T17:39:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgxODkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyMDM4Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436820387", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @throws ApiException when delete fails\n          \n          \n            \n               * @throws ApiException when create fails", "author": "sankarpn", "createdAt": "2020-06-08T16:03:37Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -283,9 +283,34 @@ private static void initializeGenericKubernetesApiClients() {\n   }\n \n   // ------------------------  deployments -----------------------------------\n-  public static boolean createDeployment(String deploymentYaml) {\n-    // do something with the command!!!\n-    return true;\n+\n+  /**\n+   * Create a deployment.\n+   *\n+   * @param deployment V1Deployment object containing deployment configuration data\n+   * @return true if creation was successful\n+   * @throws ApiException when delete fails", "originalCommit": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTE4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436881182", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-06-08T17:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyMDM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyMTE3Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436821177", "bodyText": "we don't need this message logged, it will be too much verbose messages when this gets called repeatedly", "author": "sankarpn", "createdAt": "2020-06-08T16:04:49Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -448,6 +473,7 @@ public static boolean deletePod(String name, String namespace) {\n   public static V1Pod getPod(String namespace, String labelSelector, String podName) throws ApiException {\n     V1PodList pods = listPods(namespace, labelSelector);\n     for (var pod : pods.getItems()) {\n+      logger.info(\"Check for pod {0}\", pod.getMetadata().getName());", "originalCommit": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTI0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436881244", "bodyText": "removed", "author": "marinakog", "createdAt": "2020-06-08T17:40:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyMTE3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyMTc2Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436821766", "bodyText": "remove empty line", "author": "sankarpn", "createdAt": "2020-06-08T16:05:41Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -450,6 +452,27 @@ public static boolean podStateNotChanged(String podName,\n   }\n \n   /**\n+   * Check if Prometheus is running.\n+   *\n+   * @param namespace in which is prometheus is running\n+   * @return true if running false otherwise\n+   */\n+  public static Callable<Boolean> isPrometheusReady(String namespace) {\n+", "originalCommit": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTM4MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436881381", "bodyText": "fixed", "author": "marinakog", "createdAt": "2020-06-08T17:40:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyMTc2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyNTk1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436825953", "bodyText": "Please replace the StringBuilder with this.\nlabelSelector = labels.entrySet() .stream() .map(e -> e.getKey() + \"=\" + e.getValue()) .collect(Collectors.joining(\",\"));", "author": "sankarpn", "createdAt": "2020-06-08T16:11:46Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -122,29 +123,33 @@ public static boolean isPodRunning(String namespace, String domainUid, String po\n   }\n \n   /**\n-   * Checks if a pod is ready in a given namespace.\n-   *\n-   * @param namespace in which to check if the pod is ready\n-   * @param domainUid the label the pod is decorated with\n-   * @param podName name of the pod to check for\n-   * @return true if the pod is in the ready condition, false otherwise\n-   * @throws ApiException if Kubernetes client API call fails\n+\n+   Checks if a pod is ready in a given namespace.\n+   @param namespace in which to check if the pod is ready\n+   @param labels map of labels as key value pairs\n+   @param podName name of the pod to check for\n+   @return true if the pod is in the ready condition, false otherwise\n+   @throws ApiException if Kubernetes client API call fails\n    */\n-  public static boolean isPodReady(String namespace, String domainUid, String podName) throws ApiException {\n+  public static boolean isPodReady(String namespace, Map<String, String> labels, String podName) throws ApiException {\n     boolean status = false;\n     String labelSelector = null;\n-    if (domainUid != null) {\n-      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    if (labels != null && !labels.isEmpty()) {\n+      StringBuilder str = new StringBuilder();\n+      for (Map.Entry<String, String> entry : labels.entrySet()) {\n+        str.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\",\");\n+      }\n+      //concat last ','\n+      labelSelector = str.toString().substring(0, str.toString().length() - 1);", "originalCommit": "f53a37a1d6397f70bfaca98042e1b37b0e8d2c64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTUwNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1704#discussion_r436881505", "bodyText": "replaced", "author": "marinakog", "createdAt": "2020-06-08T17:40:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyNTk1Mw=="}], "type": "inlineReview"}, {"oid": "3b4c1de8795dd86e2deae8bfcc8ecd8715f26efa", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3b4c1de8795dd86e2deae8bfcc8ecd8715f26efa", "message": "fixed comments, changed map processing", "committedDate": "2020-06-08T17:38:39Z", "type": "commit"}, {"oid": "42801409d9da53d46169e82743d2dc9a6acf0abc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/42801409d9da53d46169e82743d2dc9a6acf0abc", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into promtest", "committedDate": "2020-06-09T15:16:02Z", "type": "commit"}, {"oid": "128ce9fd695305f280a85dc93002ad908c5e0b30", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/128ce9fd695305f280a85dc93002ad908c5e0b30", "message": "deleted unused vars, split methods", "committedDate": "2020-06-09T15:48:11Z", "type": "commit"}, {"oid": "1871c2db1014d65e8f410d3087a41cb1bb650c89", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1871c2db1014d65e8f410d3087a41cb1bb650c89", "message": "replaced with descriptive var name, fixed processing of multiple webapps files", "committedDate": "2020-06-09T17:22:44Z", "type": "commit"}, {"oid": "6c43e2ac0d51de5091fc767e606b3ea388a4f254", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6c43e2ac0d51de5091fc767e606b3ea388a4f254", "message": "style", "committedDate": "2020-06-09T17:42:56Z", "type": "commit"}, {"oid": "a15a27cbbd0a157aeb79fd9efe20015ef86d22b9", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a15a27cbbd0a157aeb79fd9efe20015ef86d22b9", "message": "typo", "committedDate": "2020-06-09T21:14:18Z", "type": "commit"}, {"oid": "a7e47e3c85a81341963e7c6f4b024609f5e1b1f0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a7e47e3c85a81341963e7c6f4b024609f5e1b1f0", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into promtest", "committedDate": "2020-06-09T21:37:17Z", "type": "commit"}]}