{"pr_number": 1782, "pr_title": "Converted ItCoherenceTest to use Junit5 jenkins-ignore", "pr_createdAt": "2020-07-02T03:25:20Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782", "timeline": [{"oid": "95f40f814ea7ae5f00f4e572a4b89c94dd144457", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/95f40f814ea7ae5f00f4e572a4b89c94dd144457", "message": "Converted ItCoherenceTest to use Junit5 jenkins-ignore", "committedDate": "2020-07-01T20:57:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNTIzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449115235", "bodyText": "fix cache spelling", "author": "bhavaniravichandran", "createdAt": "2020-07-02T15:55:53Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),", "originalCommit": "95f40f814ea7ae5f00f4e572a4b89c94dd144457", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcyMjI4Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449722286", "bodyText": "fixed", "author": "hzhao-github", "createdAt": "2020-07-04T00:10:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNTIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNTQ4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449115484", "bodyText": "fix cache spelling", "author": "bhavaniravichandran", "createdAt": "2020-07-02T15:56:14Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the catche\")", "originalCommit": "95f40f814ea7ae5f00f4e572a4b89c94dd144457", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcyMjI5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449722293", "bodyText": "fixed", "author": "hzhao-github", "createdAt": "2020-07-04T00:10:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNTQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNTk1NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449115955", "bodyText": "rollingRestartDomainAndVerify", "author": "bhavaniravichandran", "createdAt": "2020-07-02T15:56:57Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the catche\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    roolingRestartDomainAndVerify();", "originalCommit": "95f40f814ea7ae5f00f4e572a4b89c94dd144457", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcyMjMxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449722314", "bodyText": "fixed", "author": "hzhao-github", "createdAt": "2020-07-04T00:10:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNTk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMjMyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449132329", "bodyText": "Check if you can use buildApplication in BuildApplication.java to build your app?", "author": "bhavaniravichandran", "createdAt": "2020-07-02T16:23:33Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the catche\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    roolingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_VALIDATE, execResult2.stdout());\n+\n+    logger.info(\"SUCCESS --- testRollingRestart\");\n+  }\n+\n+  private void copyCohProxyClientAppToPods() {", "originalCommit": "95f40f814ea7ae5f00f4e572a4b89c94dd144457", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcyMzc5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449723795", "bodyText": "I actually looked at this method when coding. My understanding is buildApplication is just zip the app. What we need here is 1) create a .gar file, 2) create WDT archive, seems not meet the requirement.", "author": "hzhao-github", "createdAt": "2020-07-04T00:32:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMjMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMzNjc2OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r450336768", "bodyText": "Not true. buildApplication copies your app dir (zips it) into a pod with weblogic install, builds the app and then copies it out of the pod. Please check again. Both Sankar and I use this to build apps.", "author": "bhavaniravichandran", "createdAt": "2020-07-06T16:22:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMjMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQwOTA1Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r450409052", "bodyText": "my mistake. I am going to try to use buildApplication in BuildApplication.java", "author": "hzhao-github", "createdAt": "2020-07-06T18:36:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMjMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3NjAzNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r451176037", "bodyText": "currently, what the test is doing is that app and script are copied to, build and run in MS pods directly\nusing buildApplication method, the test needs to copy app and script to a temp pod and build the app there, and then m=need to copy app and script to MS pods and run it there in MS pods\n\nTo keep it simple, decided to do what the test is doing now. So no changes here", "author": "hzhao-github", "createdAt": "2020-07-07T22:19:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMjMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA1MTg4Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453051887", "bodyText": "I still think we should reuse existing code, but since there seem to be some issues right now using it, I guess it is fine.", "author": "bhavaniravichandran", "createdAt": "2020-07-10T20:00:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMjMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMjcyMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449132721", "bodyText": "not sure what this comment means.", "author": "bhavaniravichandran", "createdAt": "2020-07-02T16:24:17Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the catche\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    roolingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_VALIDATE, execResult2.stdout());\n+\n+    logger.info(\"SUCCESS --- testRollingRestart\");\n+  }\n+\n+  private void copyCohProxyClientAppToPods() {\n+    List<String> dirsToMake = new ArrayList<String>();\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/java/cohapp\");\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/resources\");\n+\n+    // copy the shell script file and all Coherence app files over to the managed server pods\n+    for (int i = 1; i < replicaCount; i++) {\n+      String serverName = managedServerPrefix + i;\n+      assertDoesNotThrow(\n+          () -> FileUtils.makeDirectories(domainNamespace, serverName,\n+              null, true, dirsToMake),\n+          String.format(\"Failed to create dir %s in pod %s in namespace %s \",\n+              dirsToMake.toString(), serverName, domainNamespace));\n+      logger.info(\"Failed to create dir {0} in Pod {1} in namespace {2} \",\n+          dirsToMake.toString(), serverName, domainNamespace);\n+\n+      assertDoesNotThrow(\n+          () -> FileUtils.copyFolderToPod(domainNamespace, serverName,\n+              containerName, Paths.get(APP_LOC_ON_HOST), Paths.get(APP_LOC_IN_POD)),\n+          String.format(\"Failed to copy file %s to pod %s in namespace %s and located at %s \",\n+              APP_LOC_ON_HOST, serverName, domainNamespace, APP_LOC_IN_POD));\n+      logger.info(\"File {0} copied to {1} to Pod {2} in namespace {3} \",\n+          APP_LOC_ON_HOST, APP_LOC_IN_POD, serverName, domainNamespace);\n+    }\n+  }\n+\n+  private ExecResult runCoherenceProxyClient(String serverName, String cacheOp\n+  ) throws IOException, ApiException, InterruptedException {\n+\n+    // build the proxy client in the pod and run the proxy test.\n+    final String coherenceScriptPathInPod = APP_LOC_IN_POD + \"/\" + PROXY_CLIENT_SCRIPT;\n+\n+    String serverPodIP = assertDoesNotThrow(\n+        () -> getPodIP(domainNamespace, \"\", serverName),\n+        String.format(\"Get pod IP address failed with ApiException for %s in namespace %s\",\n+            serverName, domainNamespace));\n+    logger.info(\"Admin Pod IP {0} \", serverPodIP);\n+\n+\n+    StringBuffer coherenceProxyClientCmd = new StringBuffer(\"chmod +x -R \");\n+    coherenceProxyClientCmd\n+        .append(APP_LOC_IN_POD)\n+        .append(\" && sh \")\n+        .append(coherenceScriptPathInPod)\n+        .append(\" \")\n+        .append(APP_LOC_IN_POD)\n+        .append(\" \")\n+        .append(cacheOp)\n+        .append(\" \")\n+        .append(serverPodIP)\n+        .append(\" \")\n+        .append(PROXY_PORT);\n+\n+    logger.info(\"Command to exec script file: \" + coherenceProxyClientCmd);\n+\n+    ExecResult execResult =\n+        execCommand(domainNamespace, serverName, containerName, true,\n+            \"/bin/sh\", \"-c\", coherenceProxyClientCmd.toString());\n+\n+    logger.info(\"\\n Coherence proxy client returns \\n \" + execResult.stdout());\n+\n+    return execResult;\n+  }\n+\n+  private static String createAndVerifyDomainImage() {\n+    // create image with model files\n+    logger.info(\"Create image with model file and verify\");\n+    // build the model file list", "originalCommit": "95f40f814ea7ae5f00f4e572a4b89c94dd144457", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcyMjM3MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449722371", "bodyText": "removed", "author": "hzhao-github", "createdAt": "2020-07-04T00:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMjcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNTI5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449135295", "bodyText": "Not necessary. PodReady checks both.", "author": "bhavaniravichandran", "createdAt": "2020-07-02T16:28:41Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the catche\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    roolingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_VALIDATE, execResult2.stdout());\n+\n+    logger.info(\"SUCCESS --- testRollingRestart\");\n+  }\n+\n+  private void copyCohProxyClientAppToPods() {\n+    List<String> dirsToMake = new ArrayList<String>();\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/java/cohapp\");\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/resources\");\n+\n+    // copy the shell script file and all Coherence app files over to the managed server pods\n+    for (int i = 1; i < replicaCount; i++) {\n+      String serverName = managedServerPrefix + i;\n+      assertDoesNotThrow(\n+          () -> FileUtils.makeDirectories(domainNamespace, serverName,\n+              null, true, dirsToMake),\n+          String.format(\"Failed to create dir %s in pod %s in namespace %s \",\n+              dirsToMake.toString(), serverName, domainNamespace));\n+      logger.info(\"Failed to create dir {0} in Pod {1} in namespace {2} \",\n+          dirsToMake.toString(), serverName, domainNamespace);\n+\n+      assertDoesNotThrow(\n+          () -> FileUtils.copyFolderToPod(domainNamespace, serverName,\n+              containerName, Paths.get(APP_LOC_ON_HOST), Paths.get(APP_LOC_IN_POD)),\n+          String.format(\"Failed to copy file %s to pod %s in namespace %s and located at %s \",\n+              APP_LOC_ON_HOST, serverName, domainNamespace, APP_LOC_IN_POD));\n+      logger.info(\"File {0} copied to {1} to Pod {2} in namespace {3} \",\n+          APP_LOC_ON_HOST, APP_LOC_IN_POD, serverName, domainNamespace);\n+    }\n+  }\n+\n+  private ExecResult runCoherenceProxyClient(String serverName, String cacheOp\n+  ) throws IOException, ApiException, InterruptedException {\n+\n+    // build the proxy client in the pod and run the proxy test.\n+    final String coherenceScriptPathInPod = APP_LOC_IN_POD + \"/\" + PROXY_CLIENT_SCRIPT;\n+\n+    String serverPodIP = assertDoesNotThrow(\n+        () -> getPodIP(domainNamespace, \"\", serverName),\n+        String.format(\"Get pod IP address failed with ApiException for %s in namespace %s\",\n+            serverName, domainNamespace));\n+    logger.info(\"Admin Pod IP {0} \", serverPodIP);\n+\n+\n+    StringBuffer coherenceProxyClientCmd = new StringBuffer(\"chmod +x -R \");\n+    coherenceProxyClientCmd\n+        .append(APP_LOC_IN_POD)\n+        .append(\" && sh \")\n+        .append(coherenceScriptPathInPod)\n+        .append(\" \")\n+        .append(APP_LOC_IN_POD)\n+        .append(\" \")\n+        .append(cacheOp)\n+        .append(\" \")\n+        .append(serverPodIP)\n+        .append(\" \")\n+        .append(PROXY_PORT);\n+\n+    logger.info(\"Command to exec script file: \" + coherenceProxyClientCmd);\n+\n+    ExecResult execResult =\n+        execCommand(domainNamespace, serverName, containerName, true,\n+            \"/bin/sh\", \"-c\", coherenceProxyClientCmd.toString());\n+\n+    logger.info(\"\\n Coherence proxy client returns \\n \" + execResult.stdout());\n+\n+    return execResult;\n+  }\n+\n+  private static String createAndVerifyDomainImage() {\n+    // create image with model files\n+    logger.info(\"Create image with model file and verify\");\n+    // build the model file list\n+    String miiImage = createImageAndVerify(\n+        COHERENCE_IMAGE_NAME, COHERENCE_MODEL_FILE,\n+            PROXY_SERVER_APP_NAME, COHERENCE_MODEL_PROP, domainUid);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Create docker registry secret in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+        String.format(\"create Docker Registry Secret failed for %s\", REPO_SECRET_NAME));\n+\n+    return miiImage;\n+  }\n+\n+  private static void createAndVerifyDomain(String miiImage) {\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(adminSecretName, domainNamespace,\n+        \"weblogic\", \"welcome1\"),\n+        String.format(\"create secret for admin credentials failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(encryptionSecretName, domainNamespace,\n+        \"weblogicenc\", \"weblogicenc\"),\n+        String.format(\"create encryption secret failed for %s\", encryptionSecretName));\n+\n+    // create domain and verify\n+    logger.info(\"Create model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainCrAndVerify(adminSecretName, miiImage);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);", "originalCommit": "95f40f814ea7ae5f00f4e572a4b89c94dd144457", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcyMjQ0Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449722443", "bodyText": "removed", "author": "hzhao-github", "createdAt": "2020-07-04T00:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNTI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNTcyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449135729", "bodyText": "Check service check before pod ready check.", "author": "bhavaniravichandran", "createdAt": "2020-07-02T16:29:25Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the catche\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    roolingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_VALIDATE, execResult2.stdout());\n+\n+    logger.info(\"SUCCESS --- testRollingRestart\");\n+  }\n+\n+  private void copyCohProxyClientAppToPods() {\n+    List<String> dirsToMake = new ArrayList<String>();\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/java/cohapp\");\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/resources\");\n+\n+    // copy the shell script file and all Coherence app files over to the managed server pods\n+    for (int i = 1; i < replicaCount; i++) {\n+      String serverName = managedServerPrefix + i;\n+      assertDoesNotThrow(\n+          () -> FileUtils.makeDirectories(domainNamespace, serverName,\n+              null, true, dirsToMake),\n+          String.format(\"Failed to create dir %s in pod %s in namespace %s \",\n+              dirsToMake.toString(), serverName, domainNamespace));\n+      logger.info(\"Failed to create dir {0} in Pod {1} in namespace {2} \",\n+          dirsToMake.toString(), serverName, domainNamespace);\n+\n+      assertDoesNotThrow(\n+          () -> FileUtils.copyFolderToPod(domainNamespace, serverName,\n+              containerName, Paths.get(APP_LOC_ON_HOST), Paths.get(APP_LOC_IN_POD)),\n+          String.format(\"Failed to copy file %s to pod %s in namespace %s and located at %s \",\n+              APP_LOC_ON_HOST, serverName, domainNamespace, APP_LOC_IN_POD));\n+      logger.info(\"File {0} copied to {1} to Pod {2} in namespace {3} \",\n+          APP_LOC_ON_HOST, APP_LOC_IN_POD, serverName, domainNamespace);\n+    }\n+  }\n+\n+  private ExecResult runCoherenceProxyClient(String serverName, String cacheOp\n+  ) throws IOException, ApiException, InterruptedException {\n+\n+    // build the proxy client in the pod and run the proxy test.\n+    final String coherenceScriptPathInPod = APP_LOC_IN_POD + \"/\" + PROXY_CLIENT_SCRIPT;\n+\n+    String serverPodIP = assertDoesNotThrow(\n+        () -> getPodIP(domainNamespace, \"\", serverName),\n+        String.format(\"Get pod IP address failed with ApiException for %s in namespace %s\",\n+            serverName, domainNamespace));\n+    logger.info(\"Admin Pod IP {0} \", serverPodIP);\n+\n+\n+    StringBuffer coherenceProxyClientCmd = new StringBuffer(\"chmod +x -R \");\n+    coherenceProxyClientCmd\n+        .append(APP_LOC_IN_POD)\n+        .append(\" && sh \")\n+        .append(coherenceScriptPathInPod)\n+        .append(\" \")\n+        .append(APP_LOC_IN_POD)\n+        .append(\" \")\n+        .append(cacheOp)\n+        .append(\" \")\n+        .append(serverPodIP)\n+        .append(\" \")\n+        .append(PROXY_PORT);\n+\n+    logger.info(\"Command to exec script file: \" + coherenceProxyClientCmd);\n+\n+    ExecResult execResult =\n+        execCommand(domainNamespace, serverName, containerName, true,\n+            \"/bin/sh\", \"-c\", coherenceProxyClientCmd.toString());\n+\n+    logger.info(\"\\n Coherence proxy client returns \\n \" + execResult.stdout());\n+\n+    return execResult;\n+  }\n+\n+  private static String createAndVerifyDomainImage() {\n+    // create image with model files\n+    logger.info(\"Create image with model file and verify\");\n+    // build the model file list\n+    String miiImage = createImageAndVerify(\n+        COHERENCE_IMAGE_NAME, COHERENCE_MODEL_FILE,\n+            PROXY_SERVER_APP_NAME, COHERENCE_MODEL_PROP, domainUid);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Create docker registry secret in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+        String.format(\"create Docker Registry Secret failed for %s\", REPO_SECRET_NAME));\n+\n+    return miiImage;\n+  }\n+\n+  private static void createAndVerifyDomain(String miiImage) {\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(adminSecretName, domainNamespace,\n+        \"weblogic\", \"welcome1\"),\n+        String.format(\"create secret for admin credentials failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(encryptionSecretName, domainNamespace,\n+        \"weblogicenc\", \"weblogicenc\"),\n+        String.format(\"create encryption secret failed for %s\", encryptionSecretName));\n+\n+    // create domain and verify\n+    logger.info(\"Create model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainCrAndVerify(adminSecretName, miiImage);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin server pod is ready\n+    logger.info(\"Checking that admin server pod {0} is ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin service exists in the domain namespace\n+    logger.info(\"Checking that admin service {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);", "originalCommit": "95f40f814ea7ae5f00f4e572a4b89c94dd144457", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcyNDM3OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449724379", "bodyText": "changed", "author": "hzhao-github", "createdAt": "2020-07-04T00:42:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNTcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNjAwNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449136005", "bodyText": "not needed - same comment as earlier", "author": "bhavaniravichandran", "createdAt": "2020-07-02T16:29:54Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the catche\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    roolingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_VALIDATE, execResult2.stdout());\n+\n+    logger.info(\"SUCCESS --- testRollingRestart\");\n+  }\n+\n+  private void copyCohProxyClientAppToPods() {\n+    List<String> dirsToMake = new ArrayList<String>();\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/java/cohapp\");\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/resources\");\n+\n+    // copy the shell script file and all Coherence app files over to the managed server pods\n+    for (int i = 1; i < replicaCount; i++) {\n+      String serverName = managedServerPrefix + i;\n+      assertDoesNotThrow(\n+          () -> FileUtils.makeDirectories(domainNamespace, serverName,\n+              null, true, dirsToMake),\n+          String.format(\"Failed to create dir %s in pod %s in namespace %s \",\n+              dirsToMake.toString(), serverName, domainNamespace));\n+      logger.info(\"Failed to create dir {0} in Pod {1} in namespace {2} \",\n+          dirsToMake.toString(), serverName, domainNamespace);\n+\n+      assertDoesNotThrow(\n+          () -> FileUtils.copyFolderToPod(domainNamespace, serverName,\n+              containerName, Paths.get(APP_LOC_ON_HOST), Paths.get(APP_LOC_IN_POD)),\n+          String.format(\"Failed to copy file %s to pod %s in namespace %s and located at %s \",\n+              APP_LOC_ON_HOST, serverName, domainNamespace, APP_LOC_IN_POD));\n+      logger.info(\"File {0} copied to {1} to Pod {2} in namespace {3} \",\n+          APP_LOC_ON_HOST, APP_LOC_IN_POD, serverName, domainNamespace);\n+    }\n+  }\n+\n+  private ExecResult runCoherenceProxyClient(String serverName, String cacheOp\n+  ) throws IOException, ApiException, InterruptedException {\n+\n+    // build the proxy client in the pod and run the proxy test.\n+    final String coherenceScriptPathInPod = APP_LOC_IN_POD + \"/\" + PROXY_CLIENT_SCRIPT;\n+\n+    String serverPodIP = assertDoesNotThrow(\n+        () -> getPodIP(domainNamespace, \"\", serverName),\n+        String.format(\"Get pod IP address failed with ApiException for %s in namespace %s\",\n+            serverName, domainNamespace));\n+    logger.info(\"Admin Pod IP {0} \", serverPodIP);\n+\n+\n+    StringBuffer coherenceProxyClientCmd = new StringBuffer(\"chmod +x -R \");\n+    coherenceProxyClientCmd\n+        .append(APP_LOC_IN_POD)\n+        .append(\" && sh \")\n+        .append(coherenceScriptPathInPod)\n+        .append(\" \")\n+        .append(APP_LOC_IN_POD)\n+        .append(\" \")\n+        .append(cacheOp)\n+        .append(\" \")\n+        .append(serverPodIP)\n+        .append(\" \")\n+        .append(PROXY_PORT);\n+\n+    logger.info(\"Command to exec script file: \" + coherenceProxyClientCmd);\n+\n+    ExecResult execResult =\n+        execCommand(domainNamespace, serverName, containerName, true,\n+            \"/bin/sh\", \"-c\", coherenceProxyClientCmd.toString());\n+\n+    logger.info(\"\\n Coherence proxy client returns \\n \" + execResult.stdout());\n+\n+    return execResult;\n+  }\n+\n+  private static String createAndVerifyDomainImage() {\n+    // create image with model files\n+    logger.info(\"Create image with model file and verify\");\n+    // build the model file list\n+    String miiImage = createImageAndVerify(\n+        COHERENCE_IMAGE_NAME, COHERENCE_MODEL_FILE,\n+            PROXY_SERVER_APP_NAME, COHERENCE_MODEL_PROP, domainUid);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Create docker registry secret in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+        String.format(\"create Docker Registry Secret failed for %s\", REPO_SECRET_NAME));\n+\n+    return miiImage;\n+  }\n+\n+  private static void createAndVerifyDomain(String miiImage) {\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(adminSecretName, domainNamespace,\n+        \"weblogic\", \"welcome1\"),\n+        String.format(\"create secret for admin credentials failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(encryptionSecretName, domainNamespace,\n+        \"weblogicenc\", \"weblogicenc\"),\n+        String.format(\"create encryption secret failed for %s\", encryptionSecretName));\n+\n+    // create domain and verify\n+    logger.info(\"Create model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainCrAndVerify(adminSecretName, miiImage);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin server pod is ready\n+    logger.info(\"Checking that admin server pod {0} is ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin service exists in the domain namespace\n+    logger.info(\"Checking that admin service {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodExists(managedServerPodName, domainUid, domainNamespace);", "originalCommit": "95f40f814ea7ae5f00f4e572a4b89c94dd144457", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcyMjQ2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449722464", "bodyText": "removed", "author": "hzhao-github", "createdAt": "2020-07-04T00:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNjAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNjE3OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449136178", "bodyText": "move this before pod ready check.", "author": "bhavaniravichandran", "createdAt": "2020-07-02T16:30:11Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the catche\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    roolingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_VALIDATE, execResult2.stdout());\n+\n+    logger.info(\"SUCCESS --- testRollingRestart\");\n+  }\n+\n+  private void copyCohProxyClientAppToPods() {\n+    List<String> dirsToMake = new ArrayList<String>();\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/java/cohapp\");\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/resources\");\n+\n+    // copy the shell script file and all Coherence app files over to the managed server pods\n+    for (int i = 1; i < replicaCount; i++) {\n+      String serverName = managedServerPrefix + i;\n+      assertDoesNotThrow(\n+          () -> FileUtils.makeDirectories(domainNamespace, serverName,\n+              null, true, dirsToMake),\n+          String.format(\"Failed to create dir %s in pod %s in namespace %s \",\n+              dirsToMake.toString(), serverName, domainNamespace));\n+      logger.info(\"Failed to create dir {0} in Pod {1} in namespace {2} \",\n+          dirsToMake.toString(), serverName, domainNamespace);\n+\n+      assertDoesNotThrow(\n+          () -> FileUtils.copyFolderToPod(domainNamespace, serverName,\n+              containerName, Paths.get(APP_LOC_ON_HOST), Paths.get(APP_LOC_IN_POD)),\n+          String.format(\"Failed to copy file %s to pod %s in namespace %s and located at %s \",\n+              APP_LOC_ON_HOST, serverName, domainNamespace, APP_LOC_IN_POD));\n+      logger.info(\"File {0} copied to {1} to Pod {2} in namespace {3} \",\n+          APP_LOC_ON_HOST, APP_LOC_IN_POD, serverName, domainNamespace);\n+    }\n+  }\n+\n+  private ExecResult runCoherenceProxyClient(String serverName, String cacheOp\n+  ) throws IOException, ApiException, InterruptedException {\n+\n+    // build the proxy client in the pod and run the proxy test.\n+    final String coherenceScriptPathInPod = APP_LOC_IN_POD + \"/\" + PROXY_CLIENT_SCRIPT;\n+\n+    String serverPodIP = assertDoesNotThrow(\n+        () -> getPodIP(domainNamespace, \"\", serverName),\n+        String.format(\"Get pod IP address failed with ApiException for %s in namespace %s\",\n+            serverName, domainNamespace));\n+    logger.info(\"Admin Pod IP {0} \", serverPodIP);\n+\n+\n+    StringBuffer coherenceProxyClientCmd = new StringBuffer(\"chmod +x -R \");\n+    coherenceProxyClientCmd\n+        .append(APP_LOC_IN_POD)\n+        .append(\" && sh \")\n+        .append(coherenceScriptPathInPod)\n+        .append(\" \")\n+        .append(APP_LOC_IN_POD)\n+        .append(\" \")\n+        .append(cacheOp)\n+        .append(\" \")\n+        .append(serverPodIP)\n+        .append(\" \")\n+        .append(PROXY_PORT);\n+\n+    logger.info(\"Command to exec script file: \" + coherenceProxyClientCmd);\n+\n+    ExecResult execResult =\n+        execCommand(domainNamespace, serverName, containerName, true,\n+            \"/bin/sh\", \"-c\", coherenceProxyClientCmd.toString());\n+\n+    logger.info(\"\\n Coherence proxy client returns \\n \" + execResult.stdout());\n+\n+    return execResult;\n+  }\n+\n+  private static String createAndVerifyDomainImage() {\n+    // create image with model files\n+    logger.info(\"Create image with model file and verify\");\n+    // build the model file list\n+    String miiImage = createImageAndVerify(\n+        COHERENCE_IMAGE_NAME, COHERENCE_MODEL_FILE,\n+            PROXY_SERVER_APP_NAME, COHERENCE_MODEL_PROP, domainUid);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Create docker registry secret in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+        String.format(\"create Docker Registry Secret failed for %s\", REPO_SECRET_NAME));\n+\n+    return miiImage;\n+  }\n+\n+  private static void createAndVerifyDomain(String miiImage) {\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(adminSecretName, domainNamespace,\n+        \"weblogic\", \"welcome1\"),\n+        String.format(\"create secret for admin credentials failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(encryptionSecretName, domainNamespace,\n+        \"weblogicenc\", \"weblogicenc\"),\n+        String.format(\"create encryption secret failed for %s\", encryptionSecretName));\n+\n+    // create domain and verify\n+    logger.info(\"Create model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainCrAndVerify(adminSecretName, miiImage);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin server pod is ready\n+    logger.info(\"Checking that admin server pod {0} is ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin service exists in the domain namespace\n+    logger.info(\"Checking that admin service {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodExists(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server pod is ready\n+      logger.info(\"Checking that managed server pod {0} is ready in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReady(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server service exists in the domain namespace\n+      logger.info(\"Checking that managed server service {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkServiceExists(managedServerPodName, domainNamespace);", "originalCommit": "95f40f814ea7ae5f00f4e572a4b89c94dd144457", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcyMjUyMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449722523", "bodyText": "changed", "author": "hzhao-github", "createdAt": "2020-07-04T00:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNjE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNjc4MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449136781", "bodyText": "spelling - rolling", "author": "bhavaniravichandran", "createdAt": "2020-07-02T16:31:11Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,403 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests implements LoggedTest {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the catche\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the catche\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    roolingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_VALIDATE, execResult2.stdout());\n+\n+    logger.info(\"SUCCESS --- testRollingRestart\");\n+  }\n+\n+  private void copyCohProxyClientAppToPods() {\n+    List<String> dirsToMake = new ArrayList<String>();\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/java/cohapp\");\n+    dirsToMake.add(APP_LOC_IN_POD + \"/src/main/resources\");\n+\n+    // copy the shell script file and all Coherence app files over to the managed server pods\n+    for (int i = 1; i < replicaCount; i++) {\n+      String serverName = managedServerPrefix + i;\n+      assertDoesNotThrow(\n+          () -> FileUtils.makeDirectories(domainNamespace, serverName,\n+              null, true, dirsToMake),\n+          String.format(\"Failed to create dir %s in pod %s in namespace %s \",\n+              dirsToMake.toString(), serverName, domainNamespace));\n+      logger.info(\"Failed to create dir {0} in Pod {1} in namespace {2} \",\n+          dirsToMake.toString(), serverName, domainNamespace);\n+\n+      assertDoesNotThrow(\n+          () -> FileUtils.copyFolderToPod(domainNamespace, serverName,\n+              containerName, Paths.get(APP_LOC_ON_HOST), Paths.get(APP_LOC_IN_POD)),\n+          String.format(\"Failed to copy file %s to pod %s in namespace %s and located at %s \",\n+              APP_LOC_ON_HOST, serverName, domainNamespace, APP_LOC_IN_POD));\n+      logger.info(\"File {0} copied to {1} to Pod {2} in namespace {3} \",\n+          APP_LOC_ON_HOST, APP_LOC_IN_POD, serverName, domainNamespace);\n+    }\n+  }\n+\n+  private ExecResult runCoherenceProxyClient(String serverName, String cacheOp\n+  ) throws IOException, ApiException, InterruptedException {\n+\n+    // build the proxy client in the pod and run the proxy test.\n+    final String coherenceScriptPathInPod = APP_LOC_IN_POD + \"/\" + PROXY_CLIENT_SCRIPT;\n+\n+    String serverPodIP = assertDoesNotThrow(\n+        () -> getPodIP(domainNamespace, \"\", serverName),\n+        String.format(\"Get pod IP address failed with ApiException for %s in namespace %s\",\n+            serverName, domainNamespace));\n+    logger.info(\"Admin Pod IP {0} \", serverPodIP);\n+\n+\n+    StringBuffer coherenceProxyClientCmd = new StringBuffer(\"chmod +x -R \");\n+    coherenceProxyClientCmd\n+        .append(APP_LOC_IN_POD)\n+        .append(\" && sh \")\n+        .append(coherenceScriptPathInPod)\n+        .append(\" \")\n+        .append(APP_LOC_IN_POD)\n+        .append(\" \")\n+        .append(cacheOp)\n+        .append(\" \")\n+        .append(serverPodIP)\n+        .append(\" \")\n+        .append(PROXY_PORT);\n+\n+    logger.info(\"Command to exec script file: \" + coherenceProxyClientCmd);\n+\n+    ExecResult execResult =\n+        execCommand(domainNamespace, serverName, containerName, true,\n+            \"/bin/sh\", \"-c\", coherenceProxyClientCmd.toString());\n+\n+    logger.info(\"\\n Coherence proxy client returns \\n \" + execResult.stdout());\n+\n+    return execResult;\n+  }\n+\n+  private static String createAndVerifyDomainImage() {\n+    // create image with model files\n+    logger.info(\"Create image with model file and verify\");\n+    // build the model file list\n+    String miiImage = createImageAndVerify(\n+        COHERENCE_IMAGE_NAME, COHERENCE_MODEL_FILE,\n+            PROXY_SERVER_APP_NAME, COHERENCE_MODEL_PROP, domainUid);\n+\n+    // docker login and push image to docker registry if necessary\n+    dockerLoginAndPushImageToRegistry(miiImage);\n+\n+    // create docker registry secret to pull the image from registry\n+    logger.info(\"Create docker registry secret in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+        String.format(\"create Docker Registry Secret failed for %s\", REPO_SECRET_NAME));\n+\n+    return miiImage;\n+  }\n+\n+  private static void createAndVerifyDomain(String miiImage) {\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(adminSecretName, domainNamespace,\n+        \"weblogic\", \"welcome1\"),\n+        String.format(\"create secret for admin credentials failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createSecretWithUsernamePassword(encryptionSecretName, domainNamespace,\n+        \"weblogicenc\", \"weblogicenc\"),\n+        String.format(\"create encryption secret failed for %s\", encryptionSecretName));\n+\n+    // create domain and verify\n+    logger.info(\"Create model in image domain {0} in namespace {1} using docker image {2}\",\n+        domainUid, domainNamespace, miiImage);\n+    createDomainCrAndVerify(adminSecretName, miiImage);\n+\n+    // check that admin server pod exists in the domain namespace\n+    logger.info(\"Checking that admin server pod {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin server pod is ready\n+    logger.info(\"Checking that admin server pod {0} is ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check that admin service exists in the domain namespace\n+    logger.info(\"Checking that admin service {0} exists in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check for managed server pods existence in the domain namespace\n+    for (int i = 1; i <= replicaCount; i++) {\n+      String managedServerPodName = managedServerPrefix + i;\n+\n+      // check that the managed server pod exists\n+      logger.info(\"Checking that managed server pod {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodExists(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server pod is ready\n+      logger.info(\"Checking that managed server pod {0} is ready in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkPodReady(managedServerPodName, domainUid, domainNamespace);\n+\n+      // check that the managed server service exists in the domain namespace\n+      logger.info(\"Checking that managed server service {0} exists in namespace {1}\",\n+          managedServerPodName, domainNamespace);\n+      checkServiceExists(managedServerPodName, domainNamespace);\n+    }\n+  }\n+\n+  private static void createDomainCrAndVerify(String adminSecretName, String miiImage) {\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"Image\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\"))\n+                .introspectorJobActiveDeadlineSeconds(300L)));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    boolean domCreated = assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+    assertTrue(domCreated, String.format(\"Create domain custom resource failed with ApiException \"\n+        + \"for %s in namespace %s\", domainUid, domainNamespace));\n+  }\n+\n+  private void roolingRestartDomainAndVerify() {", "originalCommit": "95f40f814ea7ae5f00f4e572a4b89c94dd144457", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcyMjUzMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449722530", "bodyText": "fixed", "author": "hzhao-github", "createdAt": "2020-07-04T00:13:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNjc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MDQxMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449140411", "bodyText": "I think you can use buildApplication() in BuildApplication.java for this.", "author": "bhavaniravichandran", "createdAt": "2020-07-02T16:37:22Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/AppBuilder.java", "diffHunk": "@@ -97,6 +97,39 @@ public boolean build() {\n     return jarBuilt && zipBuilt;\n   }\n \n+  /**\n+   * Build an application archive using a pre-populated AppParams instance.\n+   * @return true if the command succeeds\n+   */\n+  public boolean buildCoherence() {", "originalCommit": "95f40f814ea7ae5f00f4e572a4b89c94dd144457", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcyMzgzMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449723832", "bodyText": "same comment above", "author": "hzhao-github", "createdAt": "2020-07-04T00:32:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MDQxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMzNjk3OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r450336979", "bodyText": "please revisit", "author": "bhavaniravichandran", "createdAt": "2020-07-06T16:23:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MDQxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQwOTcxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r450409714", "bodyText": "This method is used to build archive for coherence-proxy-server. After discussing with Bhavani, we both agree to keep it as it is", "author": "hzhao-github", "createdAt": "2020-07-06T18:37:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MDQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MTExMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449141112", "bodyText": "Can you check if the existing method to build the archive be used?", "author": "bhavaniravichandran", "createdAt": "2020-07-02T16:38:45Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/AppBuilder.java", "diffHunk": "@@ -146,6 +179,32 @@ public boolean buildZipArchive(\n         .execute();\n   }\n \n+  /**\n+   * Build a zip archive that includes coh-proxy-server.gar in the srcDir.\n+   *\n+   * @param zipPath zip file path for the resulting archive\n+   * @param srcDir source directory\n+   */\n+  public boolean buildCoherenceZipArchive(String zipPath, String srcDir) {", "originalCommit": "95f40f814ea7ae5f00f4e572a4b89c94dd144457", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcyMzg3OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449723878", "bodyText": "I did. existing method create a .ear/war fiule and then zip. what we need for this test is .gar and then zip", "author": "hzhao-github", "createdAt": "2020-07-04T00:34:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MTExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQwOTc5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r450409793", "bodyText": "This method is used to build archive for coherence-proxy-server. After discussing with Bhavani, we both agree to keep it as it is", "author": "hzhao-github", "createdAt": "2020-07-06T18:37:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MTExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MTcxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449141714", "bodyText": "remove the 2 lines above", "author": "bhavaniravichandran", "createdAt": "2020-07-02T16:39:49Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/FileUtils.java", "diffHunk": "@@ -23,7 +25,10 @@\n import oracle.weblogic.kubernetes.logging.LoggingFactory;\n \n import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n import static org.apache.commons.io.FileUtils.cleanDirectory;\n+//import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+//import static org.junit.jupiter.api.Assertions.fail;", "originalCommit": "95f40f814ea7ae5f00f4e572a4b89c94dd144457", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcyMzk0NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r449723945", "bodyText": "thx. removed", "author": "hzhao-github", "createdAt": "2020-07-04T00:35:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MTcxNA=="}], "type": "inlineReview"}, {"oid": "2880b87e7420122d5662c18cab5690a56ae6872d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2880b87e7420122d5662c18cab5690a56ae6872d", "message": "Changes based on comments Junit5 jenkins-ignore", "committedDate": "2020-07-04T06:39:14Z", "type": "commit"}, {"oid": "2539acbc21521bea4aa9824a4796408869603c77", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2539acbc21521bea4aa9824a4796408869603c77", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-coh-tests", "committedDate": "2020-07-06T18:38:41Z", "type": "commit"}, {"oid": "8e352b64730c1a27c57b1b5e4bee218678be1666", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8e352b64730c1a27c57b1b5e4bee218678be1666", "message": "Added copyright Junit5 jenkins-ignore", "committedDate": "2020-07-07T22:10:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MTk1Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r451241956", "bodyText": "Do you need a new line in each log message.  Same comment on previous log statements.", "author": "anpanigr", "createdAt": "2020-07-08T02:11:19Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,394 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the cache\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    rollingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",", "originalCommit": "8e352b64730c1a27c57b1b5e4bee218678be1666", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcxMzEwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r451713104", "bodyText": "newline signs removed", "author": "hzhao-github", "createdAt": "2020-07-08T17:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MTk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MjU3Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r451242573", "bodyText": "The Namespace is already created by infra, here we are assigning a  namespace.  So better we should comment \" Assigning a unique namespace for Operator  ( Domain ) \"", "author": "anpanigr", "createdAt": "2020-07-08T02:13:44Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,394 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");", "originalCommit": "8e352b64730c1a27c57b1b5e4bee218678be1666", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcxNDI4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r451714289", "bodyText": "changed", "author": "hzhao-github", "createdAt": "2020-07-08T17:35:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MjU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MjgzNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r451242837", "bodyText": "Modify the test name to  \"testCohernceServerRollingRestart\"", "author": "anpanigr", "createdAt": "2020-07-08T02:14:51Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,394 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {", "originalCommit": "8e352b64730c1a27c57b1b5e4bee218678be1666", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcxNDY1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r451714653", "bodyText": "changed", "author": "hzhao-github", "createdAt": "2020-07-08T17:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MjgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MzUzOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r451243538", "bodyText": "Extra \"---\"  Change the  statement logger.info(\"Coherence Server restated in rolling fashion\")", "author": "anpanigr", "createdAt": "2020-07-08T02:17:32Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,394 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the cache\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    rollingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_VALIDATE, execResult2.stdout());\n+\n+    logger.info(\"SUCCESS --- testRollingRestart\");", "originalCommit": "8e352b64730c1a27c57b1b5e4bee218678be1666", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcxNjA2MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r451716061", "bodyText": "changed to:\nlogger.info(\"SUCCESS --- Coherence Server restarted in rolling fashion\");", "author": "hzhao-github", "createdAt": "2020-07-08T17:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MzUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0NTI4NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r451245285", "bodyText": "Remove the comment  regarding 'MBean unit test ...\"", "author": "anpanigr", "createdAt": "2020-07-08T02:24:41Z", "path": "new-integration-tests/src/test/resources/apps/coherence-proxy-client/src/main/java/cohapp/CacheClient.java", "diffHunk": "@@ -0,0 +1,401 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package cohapp;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import com.tangosol.net.CacheFactory;\n+import com.tangosol.net.ConfigurableCacheFactory;\n+import com.tangosol.net.NamedCache;\n+\n+\n+/**", "originalCommit": "8e352b64730c1a27c57b1b5e4bee218678be1666", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcxODkzNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r451718937", "bodyText": "removed", "author": "hzhao-github", "createdAt": "2020-07-08T17:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0NTI4NQ=="}], "type": "inlineReview"}, {"oid": "a272fa7d48d4f80a6cedc297a27c52403ea4d8ee", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a272fa7d48d4f80a6cedc297a27c52403ea4d8ee", "message": "Changes based on comments Junit5 jenkins-ignore", "committedDate": "2020-07-08T18:38:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NTI5MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453075291", "bodyText": "The test uses DomainHomeInImage Model with WDT, but the description say  \"create and verify WebLogic domain image using model in image with model files\"", "author": "anpanigr", "createdAt": "2020-07-10T21:01:15Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,395 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domainNamespace\n+    logger.info(\"Assigning a unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCohernceServerRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files", "originalCommit": "a272fa7d48d4f80a6cedc297a27c52403ea4d8ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4MzIyOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453083228", "bodyText": "changed", "author": "hzhao-github", "createdAt": "2020-07-10T21:22:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NTI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NjAxNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453076017", "bodyText": "Remove extra \"---\" No need to add the word \"SUCCESS\" in log message", "author": "anpanigr", "createdAt": "2020-07-10T21:02:55Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,395 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domainNamespace\n+    logger.info(\"Assigning a unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCohernceServerRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the cache\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",\n+        OP_CACHE_LOAD, execResult1.stdout());\n+\n+    // patch domain to rolling restart it by change restartVersion\n+    rollingRestartDomainAndVerify();\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to verify the cache contents\n+    final ExecResult execResult2 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_VALIDATE),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to validate the cache\"),\n+        () -> assertTrue(execResult2.stdout().contains(successMarker), \"Failed to validate the cache\")\n+    );\n+\n+    logger.info(\"Coherence proxy client {0} returns {1}\",\n+        OP_CACHE_VALIDATE, execResult2.stdout());\n+\n+    logger.info(\"SUCCESS --- Coherence Server restarted in rolling fashion\");", "originalCommit": "a272fa7d48d4f80a6cedc297a27c52403ea4d8ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4MzUzNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453083534", "bodyText": "removed", "author": "hzhao-github", "createdAt": "2020-07-10T21:23:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NjAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NjY0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453076648", "bodyText": "Remove \\n from the logger info", "author": "anpanigr", "createdAt": "2020-07-10T21:04:43Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/FileUtils.java", "diffHunk": "@@ -132,6 +135,73 @@ public static void copyFileToPod(String namespace,\n     Kubernetes.copyFileToPod(namespace, pod, container, srcPath, destPath);\n   }\n \n+  /**\n+   * Copy a directory to a pod in specified namespace.\n+   * @param namespace namespace in which the pod exists\n+   * @param pod name of pod where the file will be copied to\n+   * @param container name of the container inside of the pod\n+   * @param srcPath source location of the directory\n+   * @param destPath destination location of the directory\n+   * @throws ApiException if Kubernetes API client call fails\n+   * @throws IOException if copy fails\n+   */\n+  public static void copyFolderToPod(String namespace,\n+                                     String pod,\n+                                     String container,\n+                                     Path srcPath,\n+                                     Path destPath) throws ApiException, IOException {\n+\n+    Stream<Path> walk = Files.walk(srcPath);\n+    // find only regular files\n+    List<String> result = walk.filter(Files::isRegularFile)\n+        .map(x -> x.toString()).collect(Collectors.toList());\n+\n+    result.forEach(fileOnHost -> {\n+      // resolve the given path against this path.\n+      Path fileInPod = destPath.resolve(srcPath.relativize(Paths.get(fileOnHost)));\n+      getLogger().info(\"Copying {0} to {1} \", fileOnHost, fileInPod);\n+\n+      try {\n+        // copy each file to the pod.\n+        Kubernetes.copyFileToPod(namespace, pod, container, Paths.get(fileOnHost), fileInPod);\n+        getLogger().info(\"File {0} copied to {1} in Pod {2} in namespace {3} \",\n+            fileOnHost, fileInPod, pod, namespace);\n+      } catch (Exception ex) {\n+        throw new RuntimeException(ex);\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Create a directory in a pod in specified namespace.\n+   * @param namespace The Kubernetes namespace that the pod is in\n+   * @param pod The name of the Kubernetes pod where the command is expected to run\n+   * @param container The container in the Pod where the command is to be run. If no\n+   *                         container name is provided than the first container in the Pod is used.\n+   * @param redirectToStdout copy process output to stdout\n+   * @param directoryToCreate namespace in which the pod exists\n+   */\n+  public static void makeDirectories(String namespace,\n+                                     String pod,\n+                                     String container,\n+                                     boolean redirectToStdout,\n+                                     List<String> directoryToCreate\n+  ) throws IOException, ApiException, InterruptedException  {\n+    //Create directories.\n+    directoryToCreate.forEach(newDir -> {\n+      String mkCmd = \"mkdir -p \" + newDir;\n+      getLogger().info(\"Newdir to make {0} \", mkCmd);\n+\n+      try {\n+        ExecResult execResult = execCommand(namespace,\n+            pod, container, redirectToStdout,\"/bin/sh\", \"-c\", mkCmd);\n+        getLogger().info(\"\\n directory created \\n \" + execResult.stdout());", "originalCommit": "a272fa7d48d4f80a6cedc297a27c52403ea4d8ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4NDA3Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453084077", "bodyText": "removed", "author": "hzhao-github", "createdAt": "2020-07-10T21:25:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NjY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3Njg0Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453076847", "bodyText": "Remove \\n from logger.info()", "author": "anpanigr", "createdAt": "2020-07-10T21:05:13Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,395 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domainNamespace\n+    logger.info(\"Assigning a unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCohernceServerRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();\n+\n+    // create and verify a WebLogic domain with a Coherence cluster\n+    createAndVerifyDomain(miiImage);\n+\n+    // build the Coherence proxy client program in the server pods\n+    // which load and verify the cache\n+    copyCohProxyClientAppToPods();\n+\n+    // run the Coherence proxy client to load the cache\n+    String serverName = managedServerPrefix + \"1\";\n+    final ExecResult execResult1 = assertDoesNotThrow(\n+        () -> runCoherenceProxyClient(serverName, OP_CACHE_LOAD),\n+        String.format(\"Failed to call Coherence proxy client in pod %s, namespace %s\",\n+            serverName, domainNamespace));\n+\n+    assertAll(\"Check that the cache loaded successfully\",\n+        () -> assertTrue(execResult1.exitValue() == 0, \"Failed to load the cache\"),\n+        () -> assertTrue(execResult1.stdout().contains(successMarker), \"Failed to load the cache\")\n+    );\n+\n+    logger.info(\"\\n Coherence proxy client {0} returns {1} \\n \",", "originalCommit": "a272fa7d48d4f80a6cedc297a27c52403ea4d8ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4NDM1NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453084354", "bodyText": "removed", "author": "hzhao-github", "createdAt": "2020-07-10T21:25:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3Njg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3Nzc1Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453077752", "bodyText": "change the variable name to domImage to reflect the DomainHomeInImage configuration", "author": "anpanigr", "createdAt": "2020-07-10T21:07:36Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItCoherenceTests.java", "diffHunk": "@@ -0,0 +1,395 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.APP_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodIP;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainResourceWithNewRestartVersion;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.verifyRollingRestartOccurred;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createImageAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.dockerLoginAndPushImageToRegistry;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// Test to create a WebLogic domain with Coherence, build the Coherence proxy client program\n+// which load and verify the cache.\n+@DisplayName(\"Test to create a WebLogic domain with Coherence and verify the use of Coherence cache service\")\n+@IntegrationTest\n+class ItCoherenceTests {\n+\n+  // constants for Coherence\n+  private static final String PROXY_CLIENT_APP_NAME = \"coherence-proxy-client\";\n+  private static final String PROXY_SERVER_APP_NAME = \"coherence-proxy-server\";\n+  private static final String APP_LOC_ON_HOST = APP_DIR + \"/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String APP_LOC_IN_POD = \"/u01/oracle/apps/\" + PROXY_CLIENT_APP_NAME;\n+  private static final String PROXY_CLIENT_SCRIPT = \"buildRunProxyClient.sh\";\n+  private static final String OP_CACHE_LOAD = \"load\";\n+  private static final String OP_CACHE_VALIDATE = \"validate\";\n+  private static final String PROXY_PORT = \"9000\";\n+\n+  // constants for creating domain image using model in image\n+  private static final String COHERENCE_MODEL_FILE = \"coherence-wdt-config.yaml\";\n+  private static final String COHERENCE_MODEL_PROP = \"coherence-wdt-config.properties\";\n+  private static final String COHERENCE_IMAGE_NAME = \"coherence-image\";\n+\n+  private static String domainUid = \"coh-domain1\";\n+  private static String clusterName = \"cluster-1\";\n+  private static String adminServerPodName = domainUid + \"-admin-server\";\n+  private static String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static String containerName = \"weblogic-server\";\n+  private static int replicaCount = 2;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static Map<String, Object> secretNameMap;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domainNamespace\n+    logger.info(\"Assigning a unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+  }\n+\n+  /**\n+   * Create a WebLogic domain with a Coherence cluster and deploying it using WDT\n+   * Test rolling restart of Coherence managed servers and verify\n+   * that data are not lost during a domain restart.\n+   */\n+  @Test\n+  @DisplayName(\"Create domain with a Coherence cluster using WDT and test rolling restart\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCohernceServerRollingRestart() {\n+    final String successMarker = \"CACHE-SUCCESS\";\n+\n+    // create and verify WebLogic domain image using model in image with model files\n+    String miiImage = createAndVerifyDomainImage();", "originalCommit": "a272fa7d48d4f80a6cedc297a27c52403ea4d8ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4NDk0NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453084945", "bodyText": "changed", "author": "hzhao-github", "createdAt": "2020-07-10T21:27:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3Nzc1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3ODUwMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453078501", "bodyText": "Why model-in-image here", "author": "anpanigr", "createdAt": "2020-07-10T21:09:42Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -781,6 +781,21 @@ public static boolean buildAppArchive(AppParams params) {\n             .build();\n   }\n \n+  /**\n+   * Create an application archive that can be used by WebLogic Image Tool\n+   * to create an image with coh-proxy-server.gar for testing Coherence use case\n+   * using   model-in-image.", "originalCommit": "a272fa7d48d4f80a6cedc297a27c52403ea4d8ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4NzE5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1782#discussion_r453087193", "bodyText": "removed \"using   model-in-image.\"", "author": "hzhao-github", "createdAt": "2020-07-10T21:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3ODUwMQ=="}], "type": "inlineReview"}, {"oid": "3ea239b7a64b5520b093528338f15d88e2e7e803", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3ea239b7a64b5520b093528338f15d88e2e7e803", "message": "Seveal changes on comments jenkins-ignore", "committedDate": "2020-07-10T22:03:27Z", "type": "commit"}]}