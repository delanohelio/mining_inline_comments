{"pr_number": 1724, "pr_title": "Scale a cluster using WLDF Policy", "pr_createdAt": "2020-06-11T00:02:37Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724", "timeline": [{"oid": "4675c57dfab387b60443bc0e9a448de984492c71", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4675c57dfab387b60443bc0e9a448de984492c71", "message": "initial commit", "committedDate": "2020-06-07T06:15:59Z", "type": "commit"}, {"oid": "744d58b94548909c4d8e28dfd69cfecd4d632aa6", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/744d58b94548909c4d8e28dfd69cfecd4d632aa6", "message": "get the latest develop branch", "committedDate": "2020-06-07T06:23:13Z", "type": "commit"}, {"oid": "fd0a1a739d22b0b86d2f53a408f2420b1dabb206", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/fd0a1a739d22b0b86d2f53a408f2420b1dabb206", "message": "scale cluster with WLDF", "committedDate": "2020-06-09T21:56:51Z", "type": "commit"}, {"oid": "eca477f4f74377b410323253e0118e6deaee1eb7", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/eca477f4f74377b410323253e0118e6deaee1eb7", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into xc-wldfscale", "committedDate": "2020-06-09T21:57:10Z", "type": "commit"}, {"oid": "dc2f167c6ad4df375cc034c1391591925979d706", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/dc2f167c6ad4df375cc034c1391591925979d706", "message": "refactor the code", "committedDate": "2020-06-10T22:40:08Z", "type": "commit"}, {"oid": "bbd627871d9abd9212f3dd56a2b5677f69c7e945", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/bbd627871d9abd9212f3dd56a2b5677f69c7e945", "message": "add more logging information", "committedDate": "2020-06-10T23:54:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3MzQwMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724#discussion_r438473403", "bodyText": "Missing javadoc for the usecase detail", "author": "anpanigr", "createdAt": "2020-06-11T00:10:20Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItScaleMiiDomainNginx.java", "diffHunk": "@@ -196,19 +214,58 @@ public void testScaleClustersWithRestApi() {\n     }\n   }\n \n+  @Test", "originalCommit": "bbd627871d9abd9212f3dd56a2b5677f69c7e945", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3OTA1NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724#discussion_r438479054", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-06-11T00:31:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3MzQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3MzYwNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724#discussion_r438473607", "bodyText": "Remove TODO comment", "author": "anpanigr", "createdAt": "2020-06-11T00:11:06Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItScaleMiiDomainNginx.java", "diffHunk": "@@ -196,19 +214,58 @@ public void testScaleClustersWithRestApi() {\n     }\n   }\n \n+  @Test\n+  @DisplayName(\"Verify scale each cluster of the domain by using WLDF policy\")\n+  public void testScaleClustersWithWLDF() {\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+\n+      String clusterName = CLUSTER_NAME_PREFIX + i;\n+      curlCmd = generateCurlCmd(clusterName, SAMPLE_APP_CONTEXT_ROOT);\n+\n+      // scale up the cluster by 1 server\n+      logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} from {3} servers to {4} servers.\",\n+          clusterName, domainUid, domainNamespace, replicaCount, replicaCount + 1);\n+      List<String> managedServersBeforeScale = listManagedServersBeforeScale(clusterName, replicaCount);\n+      scaleClusterAndVerifyWithWLDF(clusterName, replicaCount, replicaCount + 1,\n+          managedServersBeforeScale, \"scaleUp\");\n+\n+      // scale down the cluster by 1 server\n+      logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} from {3} servers to {4} servers.\",\n+          clusterName, domainUid, domainNamespace, replicaCount + 1, replicaCount);\n+      managedServersBeforeScale = listManagedServersBeforeScale(clusterName, replicaCount + 1);\n+      scaleClusterAndVerifyWithWLDF(clusterName, replicaCount + 1, replicaCount,\n+          managedServersBeforeScale, \"scaleDown\");\n+    }\n+  }\n+\n   /**", "originalCommit": "bbd627871d9abd9212f3dd56a2b5677f69c7e945", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3NjAwMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724#discussion_r438476001", "bodyText": "The TODO comment is added by Mark's request.", "author": "xiancao", "createdAt": "2020-06-11T00:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3MzYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3Njc0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724#discussion_r438476744", "bodyText": "Refering to  \"TODO: remove this after Sankar's PR is merged \"   Sankar PR is merged long time back.", "author": "anpanigr", "createdAt": "2020-06-11T00:22:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3MzYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3NzE4Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724#discussion_r438477186", "bodyText": "Sankar's PR did not remove NGINX.", "author": "xiancao", "createdAt": "2020-06-11T00:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3MzYwNw=="}], "type": "inlineReview"}, {"oid": "c8964ae81065659444c8671f0adef9c2af09986c", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c8964ae81065659444c8671f0adef9c2af09986c", "message": "add copyright", "committedDate": "2020-06-11T00:30:24Z", "type": "commit"}, {"oid": "95a0f7fa6a1905fc7ed0539c52bcfe0a40990d37", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/95a0f7fa6a1905fc7ed0539c52bcfe0a40990d37", "message": "get the latest develop", "committedDate": "2020-06-11T17:01:52Z", "type": "commit"}, {"oid": "06b6fc6c6497c7a0680da21e7372c3f2ea579ccc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/06b6fc6c6497c7a0680da21e7372c3f2ea579ccc", "message": "resolve merge conflicts", "committedDate": "2020-06-11T18:31:55Z", "type": "commit"}, {"oid": "ebc9ac7d3af6647d9a9b1e6d3bfcf4e21caed56f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ebc9ac7d3af6647d9a9b1e6d3bfcf4e21caed56f", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into xc-wldfscale", "committedDate": "2020-06-12T16:48:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MTI0MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724#discussion_r439581240", "bodyText": "Does this work to use 0 for the nodePort? My expectation is that Kubernetes will fill in the port on the NodePort-type Service. But the introspector won't know what port will be filled in...  Or, asked another way, this might work for HTTP, but won't work for T3.", "author": "rjeberhard", "createdAt": "2020-06-12T18:32:17Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItScaleMiiDomainNginx.java", "diffHunk": "@@ -275,7 +340,11 @@ private static void createMiiDomainWithMultiClusters() {\n                     .name(\"USER_MEM_ARGS\")\n                     .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n             .adminServer(new AdminServer()\n-                .serverStartState(\"RUNNING\"))\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))", "originalCommit": "06b6fc6c6497c7a0680da21e7372c3f2ea579ccc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4OTM5MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724#discussion_r439589390", "bodyText": "This is not for t3. It is not used in the test. It is just for debugging purpose for me to connect to the admin console. I can remove this channel.", "author": "xiancao", "createdAt": "2020-06-12T18:50:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MTI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MjY2OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724#discussion_r439582669", "bodyText": "This feels like it is working around a bug. Why do we have to copy a script to the admin pod?", "author": "rjeberhard", "createdAt": "2020-06-12T18:35:31Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Domain.java", "diffHunk": "@@ -292,4 +324,231 @@ public static boolean scaleClusterWithRestApi(String domainUid,\n \n     return Command.withParams(params).execute();\n   }\n+\n+  /**\n+   * Scale the cluster of the domain in the specified namespace with WLDF.\n+   *\n+   * @param clusterName name of the WebLogic cluster to be scaled in the domain\n+   * @param domainUid domainUid of the domain to be scaled\n+   * @param domainNamespace domain namespace in which the domain exists\n+   * @param domainHomeLocation domain home location of the domain\n+   * @param scalingAction scaling action, accepted value: scaleUp or scaleDown\n+   * @param scalingSize number of servers to be scaled up or down\n+   * @param opNamespace namespace of WebLogic operator\n+   * @param opServiceAccount service account of operator\n+   * @param myWebAppName web app name deployed to the domain used in the WLDF policy expression\n+   * @param curlCommand curl command to call the web app used in the WLDF policy expression\n+   * @return true if scaling the cluster succeeds, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   * @throws IOException if an I/O error occurs\n+   * @throws InterruptedException if any thread has interrupted the current thread\n+   */\n+  public static boolean scaleClusterWithWLDF(String clusterName,\n+                                             String domainUid,\n+                                             String domainNamespace,\n+                                             String domainHomeLocation,\n+                                             String scalingAction,\n+                                             int scalingSize,\n+                                             String opNamespace,\n+                                             String opServiceAccount,\n+                                             String myWebAppName,\n+                                             String curlCommand)\n+      throws ApiException, IOException, InterruptedException {\n+\n+    // create RBAC API objects for WLDF script\n+    logger.info(\"Creating RBAC API objects for WLDF script\");\n+    if (!createRbacApiObjectsForWLDFScript(domainNamespace, opNamespace)) {\n+      return false;\n+    }\n+\n+    // copy scalingAction.sh to Admin Server pod\n+    // NOTE: you must copy scalingAction.sh to $DOMAIN_HOME/bin/scripts on admin server pod\n+    String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+    V1Pod adminPod = Kubernetes.getPod(domainNamespace, null, adminServerPodName);\n+    if (adminPod == null) {\n+      logger.info(\"The admin pod {0} does not exist in namespace {1}!\", adminServerPodName, domainNamespace);\n+      return false;\n+    }\n+\n+    // create $DOMAIN_HOME/bin/scripts directory on admin server pod\n+    logger.info(\"Creating directory {0}/bin/scripts on admin server pod\", domainHomeLocation);\n+    ExecResult result = exec(adminPod, null, true,\n+        \"/bin/sh\", \"-c\", \"mkdir -p \" + domainHomeLocation + \"/bin/scripts\");\n+    if (result.exitValue() != 0) {\n+      return false;\n+    }\n+\n+    logger.info(\"Copying scalingAction.sh to admin server pod\");\n+    try {\n+      copyFileToPod(domainNamespace, adminServerPodName, null,", "originalCommit": "06b6fc6c6497c7a0680da21e7372c3f2ea579ccc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4OTc0Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724#discussion_r439589742", "bodyText": "From the doc: https://oracle.github.io/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle/scaling/#using-a-wldf-policy-rule-and-script-action-to-call-the-operators-rest-scale-api\nThis is required to copy scalingAction.sh to admin server pod.", "author": "xiancao", "createdAt": "2020-06-12T18:51:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MjY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MzE4OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724#discussion_r439583188", "bodyText": "I don't understand the flow here. Why are we exec'ing a scaling action and then also calling a wldf script? I don't understand the use case being tested.", "author": "rjeberhard", "createdAt": "2020-06-12T18:36:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Domain.java", "diffHunk": "@@ -292,4 +324,231 @@ public static boolean scaleClusterWithRestApi(String domainUid,\n \n     return Command.withParams(params).execute();\n   }\n+\n+  /**\n+   * Scale the cluster of the domain in the specified namespace with WLDF.\n+   *\n+   * @param clusterName name of the WebLogic cluster to be scaled in the domain\n+   * @param domainUid domainUid of the domain to be scaled\n+   * @param domainNamespace domain namespace in which the domain exists\n+   * @param domainHomeLocation domain home location of the domain\n+   * @param scalingAction scaling action, accepted value: scaleUp or scaleDown\n+   * @param scalingSize number of servers to be scaled up or down\n+   * @param opNamespace namespace of WebLogic operator\n+   * @param opServiceAccount service account of operator\n+   * @param myWebAppName web app name deployed to the domain used in the WLDF policy expression\n+   * @param curlCommand curl command to call the web app used in the WLDF policy expression\n+   * @return true if scaling the cluster succeeds, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   * @throws IOException if an I/O error occurs\n+   * @throws InterruptedException if any thread has interrupted the current thread\n+   */\n+  public static boolean scaleClusterWithWLDF(String clusterName,\n+                                             String domainUid,\n+                                             String domainNamespace,\n+                                             String domainHomeLocation,\n+                                             String scalingAction,\n+                                             int scalingSize,\n+                                             String opNamespace,\n+                                             String opServiceAccount,\n+                                             String myWebAppName,\n+                                             String curlCommand)\n+      throws ApiException, IOException, InterruptedException {\n+\n+    // create RBAC API objects for WLDF script\n+    logger.info(\"Creating RBAC API objects for WLDF script\");\n+    if (!createRbacApiObjectsForWLDFScript(domainNamespace, opNamespace)) {\n+      return false;\n+    }\n+\n+    // copy scalingAction.sh to Admin Server pod\n+    // NOTE: you must copy scalingAction.sh to $DOMAIN_HOME/bin/scripts on admin server pod\n+    String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+    V1Pod adminPod = Kubernetes.getPod(domainNamespace, null, adminServerPodName);\n+    if (adminPod == null) {\n+      logger.info(\"The admin pod {0} does not exist in namespace {1}!\", adminServerPodName, domainNamespace);\n+      return false;\n+    }\n+\n+    // create $DOMAIN_HOME/bin/scripts directory on admin server pod\n+    logger.info(\"Creating directory {0}/bin/scripts on admin server pod\", domainHomeLocation);\n+    ExecResult result = exec(adminPod, null, true,\n+        \"/bin/sh\", \"-c\", \"mkdir -p \" + domainHomeLocation + \"/bin/scripts\");\n+    if (result.exitValue() != 0) {\n+      return false;\n+    }\n+\n+    logger.info(\"Copying scalingAction.sh to admin server pod\");\n+    try {\n+      copyFileToPod(domainNamespace, adminServerPodName, null,\n+          Paths.get(PROJECT_ROOT + \"/../src/scripts/scaling/scalingAction.sh\"),\n+          Paths.get(domainHomeLocation + \"/bin/scripts/scalingAction.sh\"));\n+    } catch (ApiException apex) {\n+      logger.severe(\"Got ApiException while copying file to admin pod {0}\", apex.getResponseBody());\n+      return false;\n+    } catch (IOException ioex) {\n+      logger.severe(\"Got IOException while copying file to admin pod {0}\", ioex.getStackTrace());\n+      return false;\n+    }\n+\n+    logger.info(\"Adding execute mode for scalingAction.sh\");\n+    result = exec(adminPod, null, true,\n+        \"/bin/sh\", \"-c\", \"chmod +x \" + domainHomeLocation + \"/bin/scripts/scalingAction.sh\");\n+    if (result.exitValue() != 0) {\n+      return false;\n+    }\n+\n+    // copy wldf.py and callpyscript.sh to Admin Server pod\n+    logger.info(\"Copying wldf.py and callpyscript.sh to admin server pod\");", "originalCommit": "06b6fc6c6497c7a0680da21e7372c3f2ea579ccc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU5MjA3MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724#discussion_r439592071", "bodyText": "We need to create WLDF policy rule and action through wlst. wldf.py is to create the WLDF Policy rule and set the script action to call scalingAction.sh.", "author": "xiancao", "createdAt": "2020-06-12T18:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MzE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NDcxMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724#discussion_r439664713", "bodyText": "why do we need to generate zip for each app if multiple app names are provided? it will zip all of them into one zip file with name of first provided app name dir.", "author": "marinakog", "createdAt": "2020-06-12T22:21:10Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -628,29 +631,41 @@ public static String createMiiImageAndVerify(String miiImageNameBase,\n \n       if (archiveAppsList.size() != 0 && archiveAppsList.get(0) != null) {\n         assertTrue(archiveApp(defaultAppParams()\n-                .srcDirList(archiveAppsList)));\n+            .srcDirList(archiveAppsList)));\n         //archive provided ear or war file\n         String appName = archiveAppsList.get(0).substring(archiveAppsList.get(0).lastIndexOf(\"/\") + 1,\n-                appSrcDirList.get(0).lastIndexOf(\".\"));\n+            appSrcDirList.get(0).lastIndexOf(\".\"));\n \n         // build the archive list\n         String zipAppFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName);\n         archiveList.add(zipAppFile);\n \n       }\n+\n       if (buildAppDirList.size() != 0 && buildAppDirList.get(0) != null) {\n         // build an application archive using what is in resources/apps/APP_NAME\n-        assertTrue(buildAppArchive(defaultAppParams()\n-                        .srcDirList(buildAppDirList)),\n-                String.format(\"Failed to create app archive for %s\", buildAppDirList.get(0)));\n-\n-        // build the archive list\n-        String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, buildAppDirList.get(0));\n-        archiveList.add(zipFile);\n+        String zipFile = \"\";\n+        if (oneArchiveContainsMultiApps) {\n+          assertTrue(buildAppArchive(defaultAppParams()\n+                  .srcDirList(buildAppDirList)),\n+              String.format(\"Failed to create app archive for %s\", buildAppDirList.get(0)));\n+          zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, buildAppDirList.get(0));\n+          // build the archive list\n+          archiveList.add(zipFile);\n+        } else {\n+          for (String appName : buildAppDirList) {\n+            assertTrue(buildAppArchive(defaultAppParams()\n+                    .srcDirList(Collections.singletonList(appName))\n+                    .appName(appName)),\n+                String.format(\"Failed to create app archive for %s\", appName));\n+            zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName);\n+            // build the archive list\n+            archiveList.add(zipFile);\n+          }\n+        }\n       }", "originalCommit": "ebc9ac7d3af6647d9a9b1e6d3bfcf4e21caed56f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NzE5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724#discussion_r439667196", "bodyText": "I need each app has one ear file. In the current logic in develop branch, it will build the multiple apps in one ear file. It will not work for me.", "author": "xiancao", "createdAt": "2020-06-12T22:31:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NDcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk4NzEyNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724#discussion_r440987124", "bodyText": "do we still need this?", "author": "sankarpn", "createdAt": "2020-06-16T16:32:35Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -130,6 +130,11 @@\n     try {\n       Configuration.setDefaultApiClient(ClientBuilder.defaultClient());\n       apiClient = Configuration.getDefaultApiClient();\n+      // disable connection and read write timeout to force the internal HTTP client\n+      // to keep a long running connection with the server to fix SSL connection closed issue\n+      apiClient.setConnectTimeout(0);\n+      apiClient.setReadTimeout(0);\n+      apiClient.setWriteTimeout(0);", "originalCommit": "ebc9ac7d3af6647d9a9b1e6d3bfcf4e21caed56f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxMTA4MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724#discussion_r441011081", "bodyText": "we don't have solution yet.", "author": "xiancao", "createdAt": "2020-06-16T17:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk4NzEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk5MjU1NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724#discussion_r440992555", "bodyText": "Why not use the WLSTUtils.executeWLSTScript(...)?\nYou don't need to use a intermediate script like callpyscript.sh if you use above", "author": "sankarpn", "createdAt": "2020-06-16T16:40:23Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Domain.java", "diffHunk": "@@ -292,4 +324,231 @@ public static boolean scaleClusterWithRestApi(String domainUid,\n \n     return Command.withParams(params).execute();\n   }\n+\n+  /**\n+   * Scale the cluster of the domain in the specified namespace with WLDF.\n+   *\n+   * @param clusterName name of the WebLogic cluster to be scaled in the domain\n+   * @param domainUid domainUid of the domain to be scaled\n+   * @param domainNamespace domain namespace in which the domain exists\n+   * @param domainHomeLocation domain home location of the domain\n+   * @param scalingAction scaling action, accepted value: scaleUp or scaleDown\n+   * @param scalingSize number of servers to be scaled up or down\n+   * @param opNamespace namespace of WebLogic operator\n+   * @param opServiceAccount service account of operator\n+   * @param myWebAppName web app name deployed to the domain used in the WLDF policy expression\n+   * @param curlCommand curl command to call the web app used in the WLDF policy expression\n+   * @return true if scaling the cluster succeeds, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   * @throws IOException if an I/O error occurs\n+   * @throws InterruptedException if any thread has interrupted the current thread\n+   */\n+  public static boolean scaleClusterWithWLDF(String clusterName,\n+                                             String domainUid,\n+                                             String domainNamespace,\n+                                             String domainHomeLocation,\n+                                             String scalingAction,\n+                                             int scalingSize,\n+                                             String opNamespace,\n+                                             String opServiceAccount,\n+                                             String myWebAppName,\n+                                             String curlCommand)\n+      throws ApiException, IOException, InterruptedException {\n+\n+    // create RBAC API objects for WLDF script\n+    logger.info(\"Creating RBAC API objects for WLDF script\");\n+    if (!createRbacApiObjectsForWLDFScript(domainNamespace, opNamespace)) {\n+      return false;\n+    }\n+\n+    // copy scalingAction.sh to Admin Server pod\n+    // NOTE: you must copy scalingAction.sh to $DOMAIN_HOME/bin/scripts on admin server pod\n+    String adminServerPodName = domainUid + \"-\" + ADMIN_SERVER_NAME_BASE;\n+    V1Pod adminPod = Kubernetes.getPod(domainNamespace, null, adminServerPodName);\n+    if (adminPod == null) {\n+      logger.info(\"The admin pod {0} does not exist in namespace {1}!\", adminServerPodName, domainNamespace);\n+      return false;\n+    }\n+\n+    // create $DOMAIN_HOME/bin/scripts directory on admin server pod\n+    logger.info(\"Creating directory {0}/bin/scripts on admin server pod\", domainHomeLocation);\n+    ExecResult result = exec(adminPod, null, true,\n+        \"/bin/sh\", \"-c\", \"mkdir -p \" + domainHomeLocation + \"/bin/scripts\");\n+    if (result.exitValue() != 0) {\n+      return false;\n+    }\n+\n+    logger.info(\"Copying scalingAction.sh to admin server pod\");\n+    try {\n+      copyFileToPod(domainNamespace, adminServerPodName, null,\n+          Paths.get(PROJECT_ROOT + \"/../src/scripts/scaling/scalingAction.sh\"),\n+          Paths.get(domainHomeLocation + \"/bin/scripts/scalingAction.sh\"));\n+    } catch (ApiException apex) {\n+      logger.severe(\"Got ApiException while copying file to admin pod {0}\", apex.getResponseBody());\n+      return false;\n+    } catch (IOException ioex) {\n+      logger.severe(\"Got IOException while copying file to admin pod {0}\", ioex.getStackTrace());\n+      return false;\n+    }\n+\n+    logger.info(\"Adding execute mode for scalingAction.sh\");\n+    result = exec(adminPod, null, true,\n+        \"/bin/sh\", \"-c\", \"chmod +x \" + domainHomeLocation + \"/bin/scripts/scalingAction.sh\");\n+    if (result.exitValue() != 0) {\n+      return false;\n+    }\n+\n+    // copy wldf.py and callpyscript.sh to Admin Server pod\n+    logger.info(\"Copying wldf.py and callpyscript.sh to admin server pod\");\n+    try {\n+      copyFileToPod(domainNamespace, adminServerPodName, null,\n+          Paths.get(RESOURCE_DIR, \"python-scripts\", \"wldf.py\"),\n+          Paths.get(\"/u01/oracle/wldf.py\"));\n+\n+      copyFileToPod(domainNamespace, adminServerPodName, null,\n+          Paths.get(RESOURCE_DIR, \"bash-scripts\", \"callpyscript.sh\"),\n+          Paths.get(\"/u01/oracle/callpyscript.sh\"));\n+    } catch (ApiException apex) {\n+      logger.severe(\"Got ApiException while copying file to admin pod {0}\", apex.getResponseBody());\n+      return false;\n+    } catch (IOException ioex) {\n+      logger.severe(\"Got IOException while copying file to admin pod {0}\", ioex.getStackTrace());\n+      return false;\n+    }\n+\n+    logger.info(\"Adding execute mode for callpyscript.sh\");\n+    result = exec(adminPod, null, true,\n+        \"/bin/sh\", \"-c\", \"chmod +x /u01/oracle/callpyscript.sh\");", "originalCommit": "ebc9ac7d3af6647d9a9b1e6d3bfcf4e21caed56f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyMzAzMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1724#discussion_r441023032", "bodyText": "in wild.py, we need to get something environment variables like KUBERNETES_SERVICE_HOST, INTERNAL_OPERATOR_CERT from the admin pod. I tried to use  WLSTUtils.executeWLSTScript(...) but I can not get those environment variables.", "author": "xiancao", "createdAt": "2020-06-16T17:31:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk5MjU1NQ=="}], "type": "inlineReview"}, {"oid": "a45a84059b5517acc3cf62c7e6a3a4b146957457", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a45a84059b5517acc3cf62c7e6a3a4b146957457", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into xc-wldfscale", "committedDate": "2020-06-16T17:26:55Z", "type": "commit"}, {"oid": "469658f0a1f444d06f7d5157be01470d0a71b426", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/469658f0a1f444d06f7d5157be01470d0a71b426", "message": "resolve merge conflicts", "committedDate": "2020-06-17T16:01:06Z", "type": "commit"}, {"oid": "b1ab3a71e497b2299f0a3892e9e67310d9c73566", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b1ab3a71e497b2299f0a3892e9e67310d9c73566", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into xc-wldfscale", "committedDate": "2020-06-18T16:39:29Z", "type": "commit"}, {"oid": "c0dfbe9b7ab8eb8e9397e269ae8765f1dc28ee3e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c0dfbe9b7ab8eb8e9397e269ae8765f1dc28ee3e", "message": "get the latest develop", "committedDate": "2020-06-18T17:05:48Z", "type": "commit"}]}