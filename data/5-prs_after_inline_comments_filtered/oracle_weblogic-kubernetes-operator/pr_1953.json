{"pr_number": 1953, "pr_title": "Unit test and fix detection of stranded namespaces", "pr_createdAt": "2020-09-25T21:24:22Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1953", "timeline": [{"oid": "d5c523dd20040bb0252369ab152f500ca6eff5a6", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d5c523dd20040bb0252369ab152f500ca6eff5a6", "message": "Unit test and fix detection of stranded namespaces", "committedDate": "2020-09-25T21:19:14Z", "type": "commit"}, {"oid": "325f284608a60b662a74508a0437ea28ab8bb871", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/325f284608a60b662a74508a0437ea28ab8bb871", "message": "Some code simplification", "committedDate": "2020-09-27T01:36:06Z", "type": "commit"}, {"oid": "1e05cb6019c8c5a1a3e0b9b1e0525179c265846e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1e05cb6019c8c5a1a3e0b9b1e0525179c265846e", "message": "put some code back where it started from", "committedDate": "2020-09-27T02:00:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk2MjU2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1953#discussion_r495962560", "bodyText": "This is substantially less efficient than the old code as the number of namespaces increases. Why the change? Here's what was done before:\n            namespacesToStartNow = namespacesToStartNow.stream().filter(\n                    Pattern.compile(regexp).asPredicate()).collect(Collectors.toSet());\n\nThe new version compiles the regular expression for every namespace tested.", "author": "rjeberhard", "createdAt": "2020-09-28T14:01:17Z", "path": "operator/src/main/java/oracle/kubernetes/operator/Main.java", "diffHunk": "@@ -447,94 +421,237 @@ ServiceWatcher getServiceWatcher(String namespace) {\n     return serviceWatchers.get(namespace);\n   }\n \n-  enum DomainNamespaceSelectionStrategy {\n-    List {\n-      @Override\n-      public Collection<String> getDomainNamespaces() {\n-        return NamespaceHelper.parseNamespaceList(getNamespaceList());\n+  /**\n+   * Returns true if the operator is configured to use a single dedicated namespace for both itself any any domains.\n+   */\n+  public static boolean isDedicated() {\n+    return Namespaces.SelectionStrategy.Dedicated.equals(Namespaces.getSelectionStrategy());\n+  }\n+\n+  public static class Namespaces {\n+    public static final String SELECTION_STRATEGY_KEY = \"domainNamespaceSelectionStrategy\";\n+    /** The key in a Packet of the collection of existing namespaces that are designated as domain namespaces. */\n+    static final String ALL_DOMAIN_NAMESPACES = \"ALL_DOMAIN_NAMESPACES\";\n+\n+    SelectionStrategy selectionStrategy = getSelectionStrategy();\n+    private Collection<String> configuredDomainNamespaces = selectionStrategy.getConfiguredDomainNamespaces();\n+    boolean isFullRecheck;\n+\n+    public Namespaces(boolean isFullRecheck) {\n+      this.isFullRecheck = isFullRecheck;\n+    }\n+\n+    public enum SelectionStrategy {\n+      List {\n+        @Override\n+        public boolean isSelected(@Nonnull String namespaceName) {\n+          return getConfiguredDomainNamespaces().contains(namespaceName);\n+        }\n+\n+        @Override\n+        public Collection<String> getConfiguredDomainNamespaces() {\n+          return NamespaceHelper.parseNamespaceList(getNamespaceList());\n+        }\n+\n+        private String getNamespaceList() {\n+          return Optional.ofNullable(HelmAccess.getHelmSpecifiedNamespaceList()).orElse(getInternalNamespaceList());\n+        }\n+\n+        private String getInternalNamespaceList() {\n+          return Optional.ofNullable(getConfiguredNamespaceList()).orElse(getOperatorNamespace());\n+        }\n+\n+        private String getConfiguredNamespaceList() {\n+          return Optional.ofNullable(tuningAndConfig().get(\"domainNamespaces\"))\n+                .orElse(tuningAndConfig().get(\"targetNamespaces\"));\n+        }\n+      },\n+      LabelSelector {\n+        @Override\n+        public String[] getLabelSelectors() {\n+          return new String[] {tuningAndConfig().get(\"domainNamespaceLabelSelector\")};\n+        }\n+\n+        @Override\n+        public boolean isSelected(@Nonnull String namespaceName) {\n+          return true;  // filtering is done by Kubernetes list call\n+        }\n+      },\n+      RegExp {\n+        @Override\n+        public boolean isSelected(@Nonnull String namespaceName) {\n+          try {\n+            return Pattern.compile(getRegExp()).matcher(namespaceName).find();\n+          } catch (PatternSyntaxException e) {\n+            LOGGER.severe(MessageKeys.EXCEPTION, e);\n+            return false;\n+          }\n+        }\n+\n+        private String getRegExp() {\n+          return tuningAndConfig().get(\"domainNamespaceRegExp\");\n+        }\n+      },\n+      Dedicated {\n+        @Override\n+        public boolean isSelected(@Nonnull String namespaceName) {\n+          return namespaceName.equals(getOperatorNamespace());\n+        }\n+\n+        @Override\n+        public Collection<String> getConfiguredDomainNamespaces() {\n+          return Collections.singleton(getOperatorNamespace());\n+        }\n+      };\n+\n+      static final String[] NO_SELECTORS = new String[0];\n+\n+      public abstract boolean isSelected(@Nonnull String namespaceName);\n+\n+      public String[] getLabelSelectors() {\n+        return NO_SELECTORS;\n       }\n \n-      private String getNamespaceList() {\n-        return Optional.ofNullable(HelmAccess.getHelmSpecifiedNamespaceList()).orElse(getInternalNamespaceList());\n+      public Collection<String> getConfiguredDomainNamespaces() {\n+        return null;\n       }\n+    }\n \n-      private String getInternalNamespaceList() {\n-        return Optional.ofNullable(getConfiguredNamespaceList()).orElse(getOperatorNamespace());\n+    static @Nonnull Collection<String> getAllDomainNamespaces(Packet packet) {\n+      return Optional.ofNullable(getFoundDomainNamespaces(packet)).orElse(Collections.emptyList());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static Collection<String> getFoundDomainNamespaces(Packet packet) {\n+      if (!packet.containsKey(ALL_DOMAIN_NAMESPACES)) {\n+        packet.put(ALL_DOMAIN_NAMESPACES, new HashSet<>());\n       }\n+      return (Collection<String>) packet.get(ALL_DOMAIN_NAMESPACES);\n+    }\n \n-      private String getConfiguredNamespaceList() {\n-        return Optional.ofNullable(tuningAndConfig().get(\"domainNamespaces\"))\n-              .orElse(tuningAndConfig().get(\"targetNamespaces\"));\n+    /**\n+     * Gets the configured domain namespace selection strategy.\n+     * @return Selection strategy\n+     */\n+    public static SelectionStrategy getSelectionStrategy() {\n+      SelectionStrategy strategy =\n+          Optional.ofNullable(tuningAndConfig().get(SELECTION_STRATEGY_KEY))\n+                .map(SelectionStrategy::valueOf)\n+                .orElse(SelectionStrategy.List);\n+\n+      if (SelectionStrategy.List.equals(strategy) && isDeprecatedDedicated()) {\n+        return SelectionStrategy.Dedicated;\n       }\n-    },\n-    LabelSelector {\n-      @Override\n-      public boolean isRequireList() {\n-        return true;\n+      return strategy;\n+    }\n+\n+    // Returns true if the deprecated way to specify the dedicated namespace strategy is being used.\n+    // This value will only be used if the 'list' namespace strategy is specified or defaulted.\n+    private static boolean isDeprecatedDedicated() {\n+      return \"true\".equalsIgnoreCase(Optional.ofNullable(tuningAndConfig().get(\"dedicated\")).orElse(\"false\"));\n+    }\n+\n+    @Nonnull Collection<String> getConfiguredDomainNamespaces() {\n+      return Optional.ofNullable(configuredDomainNamespaces).orElse(Collections.emptyList());\n+    }\n+\n+\n+    /**\n+     * Reads the existing namespaces from Kubernetes and performs appropriate processing on those\n+     * identified as domain namespaces.\n+      */\n+    Step readExistingNamespaces() {\n+      return new CallBuilder()\n+            .withLabelSelectors(selectionStrategy.getLabelSelectors())\n+            .listNamespaceAsync(new NamespaceListStep());\n+    }\n+\n+    private class NamespaceListStep extends DefaultResponseStep<V1NamespaceList> {\n+\n+      NamespaceListStep() {\n+        super(new NamespaceListAfterStep());\n       }\n \n+      // If unable to list the namespaces, we may still be able to start them if we are using\n+      // a strategy that specifies them explicitly.\n       @Override\n-      public String getLabelSelector() {\n-        return tuningAndConfig().get(\"domainNamespaceLabelSelector\");\n+      protected NextAction onFailureNoRetry(Packet packet, CallResponse<V1NamespaceList> callResponse) {\n+        return getConfiguredDomainNamespaces() != null && isNotAuthorizedOrForbidden(callResponse)\n+                ? doNext(startNamespaces(Namespaces.this, getConfiguredDomainNamespaces()), packet) :\n+                super.onFailureNoRetry(packet, callResponse);\n       }\n-    },\n-    RegExp {\n-      @Override\n-      public boolean isRequireList() {\n-        return true;\n+\n+      private Collection<String> getConfiguredDomainNamespaces() {\n+        return selectionStrategy.getConfiguredDomainNamespaces();\n       }\n \n       @Override\n-      public String getRegExp() {\n-        return tuningAndConfig().get(\"domainNamespaceRegExp\");\n+      public NextAction onSuccess(Packet packet, CallResponse<V1NamespaceList> callResponse) {\n+        final String intialResourceVersion = getResourceVersion(callResponse.getResult());\n+        final Set<String> namespacesToStartNow = getNamespacesToStart(getNames(callResponse.getResult()));\n+        getFoundDomainNamespaces(packet).addAll(namespacesToStartNow);\n+\n+        return doContinueListOrNext(callResponse, packet, createNextSteps(intialResourceVersion, namespacesToStartNow));\n       }\n-    },\n-    Dedicated {\n-      @Override\n-      public Collection<String> getDomainNamespaces() {\n-        return Collections.singleton(getOperatorNamespace());\n+\n+      private Step createNextSteps(String intialResourceVersion, Set<String> namespacesToStartNow) {\n+        List<Step> nextSteps = new ArrayList<>();\n+        if (!namespacesToStartNow.isEmpty()) {\n+          nextSteps.add(startNamespaces(Namespaces.this, namespacesToStartNow));\n+          if (getConfiguredDomainNamespaces() == null) {\n+            nextSteps.add(new InitializeNamespacesSecurityStep(namespacesToStartNow, null));\n+          }\n+        }\n+        nextSteps.add(new CreateNamespaceWatcherStep(selectionStrategy, intialResourceVersion));\n+        nextSteps.add(getNext());\n+        return Step.chain(nextSteps.toArray(new Step[0]));\n       }\n-    };\n \n-    public boolean isRequireList() {\n-      return false;\n-    }\n+      private Set<String> getNamespacesToStart(List<String> namespaceNames) {\n+        return namespaceNames.stream().filter(selectionStrategy::isSelected).collect(Collectors.toSet());", "originalCommit": "1e05cb6019c8c5a1a3e0b9b1e0525179c265846e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5ODY0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1953#discussion_r496698648", "bodyText": "It was done for code simplification. I agree that it is less efficient; the real question should be, I think, whether there is a noticeable performance degradation. Do you have a way to test that?", "author": "russgold", "createdAt": "2020-09-29T13:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk2MjU2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcwMTQ5MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1953#discussion_r496701490", "bodyText": "I can cache the result, which should achieve roughly the same performance while adding only a small bit of extra code.", "author": "russgold", "createdAt": "2020-09-29T13:08:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk2MjU2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxMTIyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1953#discussion_r496711229", "bodyText": "With the caching, the performance should actually be a bit better, as it should not need to recompile the pattern unless it is changed. I'm still not persuaded that it matters.", "author": "russgold", "createdAt": "2020-09-29T13:21:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk2MjU2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjczNTQ5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1953#discussion_r496735495", "bodyText": "You could create a test that compiles a slightly more complicated regular expression and measure the time.  The difference in code complexity seems fairly small though between having a method that checks if a namespace matches or returning a predicate function that does the same.", "author": "rjeberhard", "createdAt": "2020-09-29T13:52:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk2MjU2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwOTQ1OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1953#discussion_r496809459", "bodyText": "The approach I have taken avoids the need for other code to test the strategy; it makes the same call in all cases, and the logic is in the enum. At any rate, the new implementation should be even faster than the original.", "author": "russgold", "createdAt": "2020-09-29T15:23:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk2MjU2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgyMTAxMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1953#discussion_r496821013", "bodyText": "Let's add a test to demonstrate that the new implementation is still faster as the number of namespaces increases.", "author": "rjeberhard", "createdAt": "2020-09-29T15:34:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk2MjU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxMzkyMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1953#discussion_r496213922", "bodyText": "what is the difference between this test and the whenNamespacesListedInOneChunk...()?", "author": "alai8", "createdAt": "2020-09-28T20:30:20Z", "path": "operator/src/test/java/oracle/kubernetes/operator/MainTest.java", "diffHunk": "@@ -196,6 +206,62 @@ private V1ObjectMeta createMetadata(DateTime creationTimestamp) {\n         .resourceVersion(\"1\");\n   }\n \n+  @Test\n+  public void whenConfiguredDomainNamespaceMissing_logWarning() {\n+    loggerControl.withLogLevel(Level.WARNING).collectLogMessages(logRecords, MessageKeys.NAMESPACE_IS_MISSING);\n+\n+    defineSelectionStrategy(Main.Namespaces.SelectionStrategy.List);\n+    String namespaceString = \"NS1,NS\" + LAST_NAMESPACE_NUM;\n+    HelmAccessStub.defineVariable(HelmAccess.OPERATOR_DOMAIN_NAMESPACES, namespaceString);\n+    createNamespaces(LAST_NAMESPACE_NUM - 1);\n+\n+    testSupport.runSteps(new Main.Namespaces(false).readExistingNamespaces());\n+\n+    assertThat(logRecords, containsWarning(MessageKeys.NAMESPACE_IS_MISSING));\n+  }\n+\n+  @Test\n+  public void whenNamespacesListedInOneChunk_dontDeclarePresentNamespacesAsMissing() {\n+    loggerControl.withLogLevel(Level.WARNING).collectLogMessages(logRecords, MessageKeys.NAMESPACE_IS_MISSING);\n+\n+    defineSelectionStrategy(Main.Namespaces.SelectionStrategy.List);\n+    String namespaceString = \"NS1,NS\" + LAST_NAMESPACE_NUM;\n+    HelmAccessStub.defineVariable(HelmAccess.OPERATOR_DOMAIN_NAMESPACES, namespaceString);\n+    createNamespaces(LAST_NAMESPACE_NUM);\n+\n+    testSupport.runSteps(new Main.Namespaces(false).readExistingNamespaces());\n+  }\n+\n+  // todo add unit tests for namespace shutdown. Must manipulate the namespaceStopping map. Can that be abstracted?\n+\n+  private void defineSelectionStrategy(SelectionStrategy selectionStrategy) {\n+    TuningParameters.getInstance().put(Main.Namespaces.SELECTION_STRATEGY_KEY, selectionStrategy.toString());\n+  }\n+\n+  @Test\n+  public void whenNamespacesListedInMultipleChunks_dontDeclarePresentNamespacesAsMissing() {", "originalCommit": "1e05cb6019c8c5a1a3e0b9b1e0525179c265846e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcwMjI4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1953#discussion_r496702282", "bodyText": "The difference is the number of namespaces. A chunk, by default, is 50 items. I have made this explicit using a constant.\nIn the old code, the detection of whether a namespace was stranded was being done on each chunk, meaning that any namespace not in the current chunk was incorrectly reported as stranded. The new code does the check after all namespaces have been located.", "author": "russgold", "createdAt": "2020-09-29T13:09:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxMzkyMg=="}], "type": "inlineReview"}, {"oid": "8b71528c628116b14953cdf8cc73efd284986f28", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8b71528c628116b14953cdf8cc73efd284986f28", "message": "Correct method name", "committedDate": "2020-09-29T09:53:49Z", "type": "commit"}, {"oid": "e459d4983887bee380ace50844dae2e3ccb4a739", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e459d4983887bee380ace50844dae2e3ccb4a739", "message": "Cache compiled pattern, use explicit constant for call limit.", "committedDate": "2020-09-29T13:22:34Z", "type": "commit"}]}