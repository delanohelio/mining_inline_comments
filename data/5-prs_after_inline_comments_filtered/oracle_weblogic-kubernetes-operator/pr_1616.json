{"pr_number": 1616, "pr_title": "Mii app patching test", "pr_createdAt": "2020-05-03T20:21:06Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616", "timeline": [{"oid": "51824d6a6dd3a0e43a5344885606e5956b44843b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/51824d6a6dd3a0e43a5344885606e5956b44843b", "message": "Initial changes to test application update", "committedDate": "2020-04-16T13:23:48Z", "type": "commit"}, {"oid": "c9dc18a32a815da9588a2f2f1705b47fabc96bcd", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c9dc18a32a815da9588a2f2f1705b47fabc96bcd", "message": "Add app assertions", "committedDate": "2020-04-16T13:28:12Z", "type": "commit"}, {"oid": "af2e168a0f5b2a7fad2f6df328cc815cd8badcfe", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/af2e168a0f5b2a7fad2f6df328cc815cd8badcfe", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test", "committedDate": "2020-04-17T15:13:41Z", "type": "commit"}, {"oid": "351bc8a1172bc7be3d41eeb24eb3d34ed2691519", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/351bc8a1172bc7be3d41eeb24eb3d34ed2691519", "message": "Save the current change", "committedDate": "2020-04-17T17:57:04Z", "type": "commit"}, {"oid": "9b50a627b242a87880a04a6f414caf3f59218b89", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9b50a627b242a87880a04a6f414caf3f59218b89", "message": "Update ItMiiDomain test", "committedDate": "2020-04-20T00:08:47Z", "type": "commit"}, {"oid": "c40df289fa37a0c16c336bbed026378fda407abb", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c40df289fa37a0c16c336bbed026378fda407abb", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test", "committedDate": "2020-04-20T18:07:52Z", "type": "commit"}, {"oid": "36f7b34daabe18d019ae4029af489b5086d2f351", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/36f7b34daabe18d019ae4029af489b5086d2f351", "message": "More changes", "committedDate": "2020-04-21T13:26:10Z", "type": "commit"}, {"oid": "8a1164effc5061aec4367b63e0bf4ea92f7e1453", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8a1164effc5061aec4367b63e0bf4ea92f7e1453", "message": "verify an app from a server pod", "committedDate": "2020-04-21T20:39:43Z", "type": "commit"}, {"oid": "888b1f371bd46698390739ba6e6357b70b3002ff", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/888b1f371bd46698390739ba6e6357b70b3002ff", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Command.java\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/CommandParams.java", "committedDate": "2020-04-21T20:45:10Z", "type": "commit"}, {"oid": "75d6028c66cba27976c044efa25ef3a0c8faad1d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/75d6028c66cba27976c044efa25ef3a0c8faad1d", "message": "add code to patch the domain with a new image and verify", "committedDate": "2020-04-22T17:07:23Z", "type": "commit"}, {"oid": "b2b169f89526f38c2deaf40a426bf67e2bb198de", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b2b169f89526f38c2deaf40a426bf67e2bb198de", "message": "Revert unintended changes", "committedDate": "2020-04-22T17:14:26Z", "type": "commit"}, {"oid": "c99fae4e407ba673db7d05d1c2afd2baf0fe2299", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c99fae4e407ba673db7d05d1c2afd2baf0fe2299", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItWitValidation.java", "committedDate": "2020-04-22T17:52:28Z", "type": "commit"}, {"oid": "e76239b16e4ffbf7dbbce9ab4cdd7b6fc0b5adf6", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e76239b16e4ffbf7dbbce9ab4cdd7b6fc0b5adf6", "message": "Fix merge issues", "committedDate": "2020-04-22T18:33:01Z", "type": "commit"}, {"oid": "dd2745f0a5fbb7ccd60004f10d66d7592cd97152", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/dd2745f0a5fbb7ccd60004f10d66d7592cd97152", "message": "more cleanup", "committedDate": "2020-04-22T19:53:36Z", "type": "commit"}, {"oid": "fa28b4c77f3d8c9a5694a49dd877693fb5e5740d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/fa28b4c77f3d8c9a5694a49dd877693fb5e5740d", "message": "Initial change for test number 6", "committedDate": "2020-04-22T20:38:59Z", "type": "commit"}, {"oid": "32d0238959c9528f1f83a486594c12f9ef96113c", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/32d0238959c9528f1f83a486594c12f9ef96113c", "message": "Fix ExecCommand to allow both redirect and saveResults enabled the same time", "committedDate": "2020-04-22T23:31:31Z", "type": "commit"}, {"oid": "92ac716d86b1e08e42b052d9152c2f13d625a2a4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/92ac716d86b1e08e42b052d9152c2f13d625a2a4", "message": "Initial change for adding another app", "committedDate": "2020-04-23T14:30:22Z", "type": "commit"}, {"oid": "f3c9709577ac9da1d3a15dad2340c9e3493b65e7", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f3c9709577ac9da1d3a15dad2340c9e3493b65e7", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItWitValidation.java", "committedDate": "2020-04-23T17:57:59Z", "type": "commit"}, {"oid": "d41efedb81bf0d4cd2137cf846a266da65dbfa95", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d41efedb81bf0d4cd2137cf846a266da65dbfa95", "message": "More impl for the second test case", "committedDate": "2020-04-23T21:12:40Z", "type": "commit"}, {"oid": "754bf4497d8fd23bc3b9771cb8aa0d0cef7ab3cf", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/754bf4497d8fd23bc3b9771cb8aa0d0cef7ab3cf", "message": "Add model file for the second app", "committedDate": "2020-04-23T21:40:32Z", "type": "commit"}, {"oid": "c5532b3d39e36c8062d588ced8abc7d5795da0e1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c5532b3d39e36c8062d588ced8abc7d5795da0e1", "message": "Minor cleanup", "committedDate": "2020-04-23T21:42:50Z", "type": "commit"}, {"oid": "be44a53d60cfe75b6ff342288af3c4e1ce399811", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/be44a53d60cfe75b6ff342288af3c4e1ce399811", "message": "Clean up comments", "committedDate": "2020-04-24T01:30:23Z", "type": "commit"}, {"oid": "0794ce024084b386c79c0548a480bc1b2ea5cc7e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/0794ce024084b386c79c0548a480bc1b2ea5cc7e", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test", "committedDate": "2020-04-24T01:33:42Z", "type": "commit"}, {"oid": "6f586f78d2bbae877c30eb8038216779af76294f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6f586f78d2bbae877c30eb8038216779af76294f", "message": "Minor fix", "committedDate": "2020-04-24T01:46:52Z", "type": "commit"}, {"oid": "4d0b7bd398fdd7bf26902a85745bc510b6103378", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4d0b7bd398fdd7bf26902a85745bc510b6103378", "message": "Move delete images to the end of AfterAll", "committedDate": "2020-04-24T02:08:48Z", "type": "commit"}, {"oid": "3e714627616e7b5a40c04aa9aefd3b553dc22a89", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3e714627616e7b5a40c04aa9aefd3b553dc22a89", "message": "Update command to check response", "committedDate": "2020-04-24T15:59:30Z", "type": "commit"}, {"oid": "7cecb83fd842eb352317582c61a084fd64cd114a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7cecb83fd842eb352317582c61a084fd64cd114a", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "committedDate": "2020-04-24T17:32:01Z", "type": "commit"}, {"oid": "937c92372d9348213abd44909be4d72b1f2f223d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/937c92372d9348213abd44909be4d72b1f2f223d", "message": "Fix a merge error", "committedDate": "2020-04-24T18:06:42Z", "type": "commit"}, {"oid": "5bc4f4f82d81369273d5d5d59108d39c4396984d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5bc4f4f82d81369273d5d5d59108d39c4396984d", "message": "Fix exec command", "committedDate": "2020-04-24T18:29:38Z", "type": "commit"}, {"oid": "d3e17ca1bfcde308bae1a128edd5135af2aaa9f3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d3e17ca1bfcde308bae1a128edd5135af2aaa9f3", "message": "Add code for remote repo stuff for the new tests", "committedDate": "2020-04-24T18:59:22Z", "type": "commit"}, {"oid": "45c965af628f3056b9858b1d392cce7fe58d1ff8", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/45c965af628f3056b9858b1d392cce7fe58d1ff8", "message": "Minor fixes", "committedDate": "2020-04-24T19:01:44Z", "type": "commit"}, {"oid": "cdc828239fa53cdb58e43ae2ce387319c37af5aa", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cdc828239fa53cdb58e43ae2ce387319c37af5aa", "message": "Cleanup", "committedDate": "2020-04-24T19:08:54Z", "type": "commit"}, {"oid": "2c729d7d8d1999cc5fef03fba0a3f3e0d564736d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2c729d7d8d1999cc5fef03fba0a3f3e0d564736d", "message": "Fix image name", "committedDate": "2020-04-24T19:15:05Z", "type": "commit"}, {"oid": "e5c5d46c0553584003cf170380d4173db6cb7447", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e5c5d46c0553584003cf170380d4173db6cb7447", "message": "Add an app file", "committedDate": "2020-04-24T20:08:33Z", "type": "commit"}, {"oid": "4094e4efc3e2b34370d2c937f6bf00fdd01dabb4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4094e4efc3e2b34370d2c937f6bf00fdd01dabb4", "message": "Make sure the thread joins before we save the stdout", "committedDate": "2020-04-24T20:34:57Z", "type": "commit"}, {"oid": "c243b49296820acca34af5192841491c0ac30802", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c243b49296820acca34af5192841491c0ac30802", "message": "Remove ItWitValidation class becuase the test in it has been copied to ItMiiDomain class", "committedDate": "2020-04-24T20:47:19Z", "type": "commit"}, {"oid": "3e2b97eb4dbeafbb4a14a737302c9b9efab4e5a5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3e2b97eb4dbeafbb4a14a737302c9b9efab4e5a5", "message": "Revert \"Remove ItWitValidation class becuase the test in it has been copied to ItMiiDomain class\"\n\nThis reverts commit c243b49296820acca34af5192841491c0ac30802.", "committedDate": "2020-04-24T21:25:09Z", "type": "commit"}, {"oid": "0591fbf66b92ce9dc993214815878aedadf4732c", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/0591fbf66b92ce9dc993214815878aedadf4732c", "message": "Debugging", "committedDate": "2020-04-25T02:43:11Z", "type": "commit"}, {"oid": "e8f50c7bca30d768a00eaf0473714504de12baf3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e8f50c7bca30d768a00eaf0473714504de12baf3", "message": "Fix pushed image name", "committedDate": "2020-04-25T03:10:34Z", "type": "commit"}, {"oid": "713a3bb6b43b97481990a100e073095a9e5a4a88", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/713a3bb6b43b97481990a100e073095a9e5a4a88", "message": "Turn off debugging", "committedDate": "2020-04-25T14:28:00Z", "type": "commit"}, {"oid": "5c6c391aac1b0baace56f358d44295b25c07f17d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5c6c391aac1b0baace56f358d44295b25c07f17d", "message": "Testing", "committedDate": "2020-04-25T20:51:39Z", "type": "commit"}, {"oid": "818af8094c15a8e85bd5a170ca078d3fc21dafad", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/818af8094c15a8e85bd5a170ca078d3fc21dafad", "message": "Change single check of expected condition to quick retry", "committedDate": "2020-04-27T15:56:25Z", "type": "commit"}, {"oid": "a2fb039a8730392531560b536b9880eaaf5c71b3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a2fb039a8730392531560b536b9880eaaf5c71b3", "message": "Check app on all managed servers", "committedDate": "2020-04-27T18:56:50Z", "type": "commit"}, {"oid": "9b9f6aa2b92e156fea3d3787071e2253d83e9963", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9b9f6aa2b92e156fea3d3787071e2253d83e9963", "message": "Check each pod to verify if the image has been patched", "committedDate": "2020-04-27T21:11:34Z", "type": "commit"}, {"oid": "9a9b2e4585474ab19a8e9d75104fcc6c453c562d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9a9b2e4585474ab19a8e9d75104fcc6c453c562d", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test", "committedDate": "2020-04-27T21:12:43Z", "type": "commit"}, {"oid": "1b3af6f97ce4eddf8ceb4b039b6b40013641599b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1b3af6f97ce4eddf8ceb4b039b6b40013641599b", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/ExecCommand.java", "committedDate": "2020-04-27T22:20:44Z", "type": "commit"}, {"oid": "5ca8fc5246cbcb851b6809c751d4ca343d12883f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5ca8fc5246cbcb851b6809c751d4ca343d12883f", "message": "Fine tuning", "committedDate": "2020-04-28T02:00:36Z", "type": "commit"}, {"oid": "c68d8ea12418fcff6bb73e67a2bb4f994da9c035", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c68d8ea12418fcff6bb73e67a2bb4f994da9c035", "message": "clean up", "committedDate": "2020-04-28T15:25:06Z", "type": "commit"}, {"oid": "6fde567ab1dec7596fb572438b788da77c03f722", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6fde567ab1dec7596fb572438b788da77c03f722", "message": "More cleanup", "committedDate": "2020-04-28T17:59:49Z", "type": "commit"}, {"oid": "e15b34b65cc85710bba70d3fefc221f8332ebcdb", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e15b34b65cc85710bba70d3fefc221f8332ebcdb", "message": "Continue work in progress", "committedDate": "2020-04-28T18:54:53Z", "type": "commit"}, {"oid": "b8a267c36e2d09af33d923af4515d60f83516b46", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b8a267c36e2d09af33d923af4515d60f83516b46", "message": "Add app continuous availability check and enable it with a system property", "committedDate": "2020-04-30T21:17:14Z", "type": "commit"}, {"oid": "497ad2759d14b73a6d20d02a8e4ac1a4ad5a819e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/497ad2759d14b73a6d20d02a8e4ac1a4ad5a819e", "message": "Clean up", "committedDate": "2020-04-30T21:33:21Z", "type": "commit"}, {"oid": "32cab300710b9395956599c77913dc16dd09aeb7", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/32cab300710b9395956599c77913dc16dd09aeb7", "message": "More javadoc", "committedDate": "2020-05-01T14:56:25Z", "type": "commit"}, {"oid": "1461b964db954c6ac3587d347a1c87aafb2fbcbe", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1461b964db954c6ac3587d347a1c87aafb2fbcbe", "message": "Merge branch 'develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "committedDate": "2020-05-01T18:25:04Z", "type": "commit"}, {"oid": "9570c024c5659630e84f9ce6e869df5f5c27d86f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9570c024c5659630e84f9ce6e869df5f5c27d86f", "message": "javadoc and cleanup", "committedDate": "2020-05-01T19:51:59Z", "type": "commit"}, {"oid": "87451a8c0fb4cad7b2d02260402fa3c90d63abff", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/87451a8c0fb4cad7b2d02260402fa3c90d63abff", "message": "Adjust timeout values", "committedDate": "2020-05-01T20:51:45Z", "type": "commit"}, {"oid": "41f6edeeab8d98af50141205f891f4701dcd9c6e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/41f6edeeab8d98af50141205f891f4701dcd9c6e", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "committedDate": "2020-05-01T21:21:20Z", "type": "commit"}, {"oid": "31cc7fd29c031fdd1a87d4b46b00a5e043b3969a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/31cc7fd29c031fdd1a87d4b46b00a5e043b3969a", "message": "Fine tuning", "committedDate": "2020-05-01T21:44:23Z", "type": "commit"}, {"oid": "5206a8905a457d4a46b284b7e4d78bff37bb3670", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5206a8905a457d4a46b284b7e4d78bff37bb3670", "message": "Minor fix", "committedDate": "2020-05-02T03:29:01Z", "type": "commit"}, {"oid": "ab8ecdfb3362fbd2a507f24da924cd6a3acfe172", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ab8ecdfb3362fbd2a507f24da924cd6a3acfe172", "message": "Use kubectl exec command for checking app continuous availability", "committedDate": "2020-05-02T07:16:06Z", "type": "commit"}, {"oid": "191ea28a650f06521ec87580354839569f556bd0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/191ea28a650f06521ec87580354839569f556bd0", "message": "clean up javadoc", "committedDate": "2020-05-02T07:34:34Z", "type": "commit"}, {"oid": "d15f52a885515e5dd87b5ae2dd078305cf071875", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d15f52a885515e5dd87b5ae2dd078305cf071875", "message": "Cleanup", "committedDate": "2020-05-03T14:30:44Z", "type": "commit"}, {"oid": "91718268821b8ff6526d906096e25bbec183499e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/91718268821b8ff6526d906096e25bbec183499e", "message": "Minor update", "committedDate": "2020-05-04T20:20:48Z", "type": "commit"}, {"oid": "89a9123951329addafd819650ad3cd20c511f0fd", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/89a9123951329addafd819650ad3cd20c511f0fd", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "committedDate": "2020-05-05T20:05:28Z", "type": "commit"}, {"oid": "bb8af2660c72e38eb737d7b335c30d5bbcbac1b1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/bb8af2660c72e38eb737d7b335c30d5bbcbac1b1", "message": "Minor update of log messages", "committedDate": "2020-05-05T20:34:40Z", "type": "commit"}, {"oid": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f1c30255fa251e2db6646acc4c8af541102ca1f2", "message": "More cleanup of log messages and comments", "committedDate": "2020-05-05T21:12:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM3MDQzNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420370434", "bodyText": "i'm not completely sure about this -- do we not trust WebLogic to start the app on all the managed servers? could we not just hit the WebLogic Server REST API to check the application status?", "author": "markxnelson", "createdAt": "2020-05-05T19:59:27Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -324,7 +342,19 @@ public void testCreateMiiDomain() {\n           managedServerPrefix + i, domainNamespace);\n       checkServiceCreated(managedServerPrefix + i, domainNamespace);\n     }\n-\n+    \n+    // check and wait for the app to be accessible in all server pods\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkAppRunning(", "originalCommit": "91718268821b8ff6526d906096e25bbec183499e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAxMzI2Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421013263", "bodyText": "We don't want to rely on a load balancer here, and the managed servers don't have a NodePort.", "author": "doxiao", "createdAt": "2020-05-06T18:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM3MDQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTExMzMyMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421113321", "bodyText": "I'm confused now too.  We discussed this in the test meeting today.  I thought I heard something different.  That is, the use case is not a redeploy, but instead just a cluster rolling.  Since the application is available on all cluster members, then the application would be continually available through a load balancer.  This isn't the same thing as the \"continuous availability\" option of course, but the application should be available through the load balancer all of the time because there will always be at least one cluster member ready.  This check looks like something different.", "author": "rjeberhard", "createdAt": "2020-05-06T21:50:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM3MDQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE3MTkyNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421171924", "bodyText": "This test class contains 5 test cases in this PR. We are at the end of the first end-to-end test case testCreateMiiDomain, which does not do any patching/rolling-restart. The checkAppRunning method here just checks and waits util the application is accessible on all server pods as a sanity check of a stable domain/cluster. It fails if the app is not available on all servers within the given period of time. The check is performed by running curl command inside each pod.", "author": "doxiao", "createdAt": "2020-05-07T00:37:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM3MDQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE3MzA5OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421173099", "bodyText": "The #4 and #5 test cases added in this PR, namely testPatchAppV2 and testAddSecondApp, are the use cases where we patch the domain resource with a new image that contains a newer version of an existing app, and adds a new app,  respectively. Only in testPatchAppV2, we check the application \"continuous\" availability. We achieve this by starting a thread to collect the availability data of the app (V1 or V2)while the main thread does the patching operation and regular verification. At the end when the V2 app becomes available on all servers, we use the collected data to determine if there are app outage during the period of time when the patching and rolling-restart are in progress.", "author": "doxiao", "createdAt": "2020-05-07T00:41:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM3MDQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MzgyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420483829", "bodyText": "don't use the term \"continuous availability\" unless that is what you really mean - hint: it is not", "author": "markxnelson", "createdAt": "2020-05-06T00:24:53Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -504,12 +534,204 @@ public void testCreateMiiDomainSameDomainUidDiffNS() {\n     }\n   }\n \n+  @Test\n+  @Order(4)\n+  @DisplayName(\"Update the sample-app application to version 2\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testPatchAppV2() {\n+    \n+    // app in the new image contains what is in the original app dir sample-app, \n+    // plus the replacements or/and additions in the second app dir sample-app-2.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+    \n+    // The verification of app's continuous availability during patching is turned off", "originalCommit": "89a9123951329addafd819650ad3cd20c511f0fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAyNTA3NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421025074", "bodyText": "My understanding is that the application should stay up when the domain is patched because the restart of the next pod will not begin before the current pod completes its restart. But I guess there is no way we can guarantee continuous availability.\nModified the comment.", "author": "doxiao", "createdAt": "2020-05-06T19:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MzgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NDExOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420484118", "bodyText": "i am not sure how i feel about running a background thread in a test, especially one that is going to be run my maven...", "author": "markxnelson", "createdAt": "2020-05-06T00:25:58Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -504,12 +534,204 @@ public void testCreateMiiDomainSameDomainUidDiffNS() {\n     }\n   }\n \n+  @Test\n+  @Order(4)\n+  @DisplayName(\"Update the sample-app application to version 2\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testPatchAppV2() {\n+    \n+    // app in the new image contains what is in the original app dir sample-app, \n+    // plus the replacements or/and additions in the second app dir sample-app-2.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+    \n+    // The verification of app's continuous availability during patching is turned off\n+    // because it fails intermittently right now. It can be enabled using the following system property.\n+    // We'll remove the property and enable it all the time once the product problem (tracked\n+    // by owls-81575) is fixed.\n+    final String enableAppAvailbilityCheck = \n+        System.getProperty(\"weblogic.operator.enableAppAvailabilityCheck\", \"false\");\n+    Thread accountingThread = null;", "originalCommit": "89a9123951329addafd819650ad3cd20c511f0fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAxMDI1NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421010255", "bodyText": "I need a way to continue collecting data while the main thread does the patching and regular verification. Suggestions are welcome.", "author": "doxiao", "createdAt": "2020-05-06T18:40:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NDExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYwMDMwMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r424600300", "bodyText": "Normally, threads in a maven build or tests is frowned upon.  But for monitoring external processes, there isn't a better alternative.  With the try/finally, I think this exception should be okay.", "author": "ddsharpe", "createdAt": "2020-05-13T17:13:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NDExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYxMzk3OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r424613978", "bodyText": "ok i reviewed this with derek and ryan, and i am ok with this", "author": "markxnelson", "createdAt": "2020-05-13T17:36:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NDExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NDYzOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420484638", "bodyText": "Check that the new app ...", "author": "markxnelson", "createdAt": "2020-05-06T00:28:12Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -504,12 +534,201 @@ public void testCreateMiiDomainSameDomainUidDiffNS() {\n     }\n   }\n \n+  @Test\n+  @Order(4)\n+  @DisplayName(\"Update the sample-app application to version 2\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testPatchAppV2() {\n+    \n+    // app in the new image contains what is in the original app dir sample-app, \n+    // plus the replacements or/and additions in the second app dir sample-app-2.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+    \n+    // The verification of app's continuous availability during patching is turned off\n+    // because it fails intermittently right now. It can be enabled using the following system property.\n+    // We'll remove the property and enable it all the time once the product problem (tracked\n+    // by owls-81575) is fixed.\n+    final String enableAppAvailbilityCheck = \n+        System.getProperty(\"weblogic.operator.enableAppAvailabilityCheck\", \"false\");\n+    Thread accountingThread = null;\n+    List<Integer> appAvailability = new ArrayList<Integer>();\n+    \n+    if (enableAppAvailbilityCheck.equalsIgnoreCase(\"true\")) {\n+      // start a new thread to collect the availability data of the app while the\n+      // main thread performs patching operation, and checking of the results.\n+      accountingThread =\n+          new Thread(\n+              () -> {\n+                collectAppAvaiability(\n+                    domainNamespace,\n+                    appAvailability,\n+                    managedServerPrefix,\n+                    replicaCount,\n+                    \"8001\",\n+                    \"sample-war/index.jsp\");\n+              });\n+      accountingThread.start();\n+    }\n+   \n+    try {\n+      logger.info(\"Check and make sure that V1 app is still running\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        quickCheckAppRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V1 + i);\n+      }\n+ \n+      logger.info(\"Check and make sure that the version 2 app is NOT running\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        quickCheckAppNotRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V2 + i);   \n+      }\n+ \n+      logger.info(\"Create a new image with app V2\");\n+      miiImagePatchAppV2 = updateImageWithAppV2Patch(\n+          String.format(\"%s-%s\", MII_IMAGE_NAME, \"test-patch-app-v2\"),\n+          Arrays.asList(appDir1, appDir2));\n+\n+      // push the image to OCIR to make the test work in multi node cluster\n+      pushImageIfNeeded(miiImagePatchAppV2);\n+\n+      // patch the domain resource with the new image and verify that the domain resource is patched, \n+      // and all server pods are patched as well.\n+      logger.info(\"Patch domain resource with the new image, and verify the results\");\n+      patchAndVerify(\n+          domainUid,\n+          domainNamespace,\n+          adminServerPodName,\n+          managedServerPrefix,\n+          replicaCount,\n+          miiImagePatchAppV2);\n+\n+      logger.info(\"Check and wait for the V2 app to be ready\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        checkAppRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V2 + i);\n+      } \n+    } finally {\n+    \n+      if (accountingThread != null) {\n+        try {\n+          accountingThread.join();\n+        } catch (InterruptedException ie) {\n+          // do nothing\n+        }\n+ \n+        // check the app availability data that we have collected, and see if\n+        // the app has been available all the time since the beginning of this test method\n+        logger.info(\"Verify that the app was available in the duration when app was being patched\"); \n+        assertTrue(appAlwaysAvailable(appAvailability),\n+            \"App does not always avaiable when the domain is being patched with a newer version of the app\");\n+      }\n+    }\n+    \n+    logger.info(\"The cluster has been rolling restarted, and the version 2 app has been deployed correctly\");\n+  }\n+\n+  @Test\n+  @Order(5)\n+  @DisplayName(\"Update the domain with another application\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddSecondApp() {\n+    \n+    // the existing app is the combination of what are in appDir1 and appDir2 as in test case number 4,\n+    // the second app is in appDir3.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String appDir3 = \"sample-app-3\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    logger.info(\"Check V2 app is still running after the previous test\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      quickCheckAppRunning(\n+          domainNamespace,\n+          managedServerPrefix + i,\n+          \"8001\",\n+          \"sample-war/index.jsp\",\n+          APP_RESPONSE_V2 + i);\n+    }\n+\n+    logger.info(\"Check and make sure that the new app is NOT already running\");", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NDc3Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420484773", "bodyText": "application", "author": "markxnelson", "createdAt": "2020-05-06T00:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NDYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NDc1MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420484751", "bodyText": "application", "author": "markxnelson", "createdAt": "2020-05-06T00:28:32Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -504,12 +534,201 @@ public void testCreateMiiDomainSameDomainUidDiffNS() {\n     }\n   }\n \n+  @Test\n+  @Order(4)\n+  @DisplayName(\"Update the sample-app application to version 2\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testPatchAppV2() {\n+    \n+    // app in the new image contains what is in the original app dir sample-app, \n+    // plus the replacements or/and additions in the second app dir sample-app-2.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+    \n+    // The verification of app's continuous availability during patching is turned off\n+    // because it fails intermittently right now. It can be enabled using the following system property.\n+    // We'll remove the property and enable it all the time once the product problem (tracked\n+    // by owls-81575) is fixed.\n+    final String enableAppAvailbilityCheck = \n+        System.getProperty(\"weblogic.operator.enableAppAvailabilityCheck\", \"false\");\n+    Thread accountingThread = null;\n+    List<Integer> appAvailability = new ArrayList<Integer>();\n+    \n+    if (enableAppAvailbilityCheck.equalsIgnoreCase(\"true\")) {\n+      // start a new thread to collect the availability data of the app while the\n+      // main thread performs patching operation, and checking of the results.\n+      accountingThread =\n+          new Thread(\n+              () -> {\n+                collectAppAvaiability(\n+                    domainNamespace,\n+                    appAvailability,\n+                    managedServerPrefix,\n+                    replicaCount,\n+                    \"8001\",\n+                    \"sample-war/index.jsp\");\n+              });\n+      accountingThread.start();\n+    }\n+   \n+    try {\n+      logger.info(\"Check and make sure that V1 app is still running\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        quickCheckAppRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V1 + i);\n+      }\n+ \n+      logger.info(\"Check and make sure that the version 2 app is NOT running\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        quickCheckAppNotRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V2 + i);   \n+      }\n+ \n+      logger.info(\"Create a new image with app V2\");\n+      miiImagePatchAppV2 = updateImageWithAppV2Patch(\n+          String.format(\"%s-%s\", MII_IMAGE_NAME, \"test-patch-app-v2\"),\n+          Arrays.asList(appDir1, appDir2));\n+\n+      // push the image to OCIR to make the test work in multi node cluster\n+      pushImageIfNeeded(miiImagePatchAppV2);\n+\n+      // patch the domain resource with the new image and verify that the domain resource is patched, \n+      // and all server pods are patched as well.\n+      logger.info(\"Patch domain resource with the new image, and verify the results\");\n+      patchAndVerify(\n+          domainUid,\n+          domainNamespace,\n+          adminServerPodName,\n+          managedServerPrefix,\n+          replicaCount,\n+          miiImagePatchAppV2);\n+\n+      logger.info(\"Check and wait for the V2 app to be ready\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        checkAppRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V2 + i);\n+      } \n+    } finally {\n+    \n+      if (accountingThread != null) {\n+        try {\n+          accountingThread.join();\n+        } catch (InterruptedException ie) {\n+          // do nothing\n+        }\n+ \n+        // check the app availability data that we have collected, and see if\n+        // the app has been available all the time since the beginning of this test method\n+        logger.info(\"Verify that the app was available in the duration when app was being patched\"); \n+        assertTrue(appAlwaysAvailable(appAvailability),\n+            \"App does not always avaiable when the domain is being patched with a newer version of the app\");\n+      }\n+    }\n+    \n+    logger.info(\"The cluster has been rolling restarted, and the version 2 app has been deployed correctly\");\n+  }\n+\n+  @Test\n+  @Order(5)\n+  @DisplayName(\"Update the domain with another application\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddSecondApp() {\n+    \n+    // the existing app is the combination of what are in appDir1 and appDir2 as in test case number 4,\n+    // the second app is in appDir3.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String appDir3 = \"sample-app-3\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    logger.info(\"Check V2 app is still running after the previous test\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      quickCheckAppRunning(\n+          domainNamespace,\n+          managedServerPrefix + i,\n+          \"8001\",\n+          \"sample-war/index.jsp\",\n+          APP_RESPONSE_V2 + i);\n+    }\n+\n+    logger.info(\"Check and make sure that the new app is NOT already running\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      quickCheckAppNotRunning(\n+          domainNamespace,\n+          managedServerPrefix + i,\n+          \"8001\",\n+          \"sample-war-3/index.jsp\",\n+          APP_RESPONSE_V3 + i);\n+    }\n+   \n+    logger.info(\"Create a new image that contains the additional app\");", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAxNTUxNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421015517", "bodyText": "fixed", "author": "doxiao", "createdAt": "2020-05-06T18:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NDc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NDc5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420484793", "bodyText": "application", "author": "markxnelson", "createdAt": "2020-05-06T00:28:44Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -504,12 +534,201 @@ public void testCreateMiiDomainSameDomainUidDiffNS() {\n     }\n   }\n \n+  @Test\n+  @Order(4)\n+  @DisplayName(\"Update the sample-app application to version 2\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testPatchAppV2() {\n+    \n+    // app in the new image contains what is in the original app dir sample-app, \n+    // plus the replacements or/and additions in the second app dir sample-app-2.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+    \n+    // The verification of app's continuous availability during patching is turned off\n+    // because it fails intermittently right now. It can be enabled using the following system property.\n+    // We'll remove the property and enable it all the time once the product problem (tracked\n+    // by owls-81575) is fixed.\n+    final String enableAppAvailbilityCheck = \n+        System.getProperty(\"weblogic.operator.enableAppAvailabilityCheck\", \"false\");\n+    Thread accountingThread = null;\n+    List<Integer> appAvailability = new ArrayList<Integer>();\n+    \n+    if (enableAppAvailbilityCheck.equalsIgnoreCase(\"true\")) {\n+      // start a new thread to collect the availability data of the app while the\n+      // main thread performs patching operation, and checking of the results.\n+      accountingThread =\n+          new Thread(\n+              () -> {\n+                collectAppAvaiability(\n+                    domainNamespace,\n+                    appAvailability,\n+                    managedServerPrefix,\n+                    replicaCount,\n+                    \"8001\",\n+                    \"sample-war/index.jsp\");\n+              });\n+      accountingThread.start();\n+    }\n+   \n+    try {\n+      logger.info(\"Check and make sure that V1 app is still running\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        quickCheckAppRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V1 + i);\n+      }\n+ \n+      logger.info(\"Check and make sure that the version 2 app is NOT running\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        quickCheckAppNotRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V2 + i);   \n+      }\n+ \n+      logger.info(\"Create a new image with app V2\");\n+      miiImagePatchAppV2 = updateImageWithAppV2Patch(\n+          String.format(\"%s-%s\", MII_IMAGE_NAME, \"test-patch-app-v2\"),\n+          Arrays.asList(appDir1, appDir2));\n+\n+      // push the image to OCIR to make the test work in multi node cluster\n+      pushImageIfNeeded(miiImagePatchAppV2);\n+\n+      // patch the domain resource with the new image and verify that the domain resource is patched, \n+      // and all server pods are patched as well.\n+      logger.info(\"Patch domain resource with the new image, and verify the results\");\n+      patchAndVerify(\n+          domainUid,\n+          domainNamespace,\n+          adminServerPodName,\n+          managedServerPrefix,\n+          replicaCount,\n+          miiImagePatchAppV2);\n+\n+      logger.info(\"Check and wait for the V2 app to be ready\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        checkAppRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V2 + i);\n+      } \n+    } finally {\n+    \n+      if (accountingThread != null) {\n+        try {\n+          accountingThread.join();\n+        } catch (InterruptedException ie) {\n+          // do nothing\n+        }\n+ \n+        // check the app availability data that we have collected, and see if\n+        // the app has been available all the time since the beginning of this test method\n+        logger.info(\"Verify that the app was available in the duration when app was being patched\"); \n+        assertTrue(appAlwaysAvailable(appAvailability),\n+            \"App does not always avaiable when the domain is being patched with a newer version of the app\");\n+      }\n+    }\n+    \n+    logger.info(\"The cluster has been rolling restarted, and the version 2 app has been deployed correctly\");\n+  }\n+\n+  @Test\n+  @Order(5)\n+  @DisplayName(\"Update the domain with another application\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddSecondApp() {\n+    \n+    // the existing app is the combination of what are in appDir1 and appDir2 as in test case number 4,\n+    // the second app is in appDir3.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String appDir3 = \"sample-app-3\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    logger.info(\"Check V2 app is still running after the previous test\");", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NTAxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420485014", "bodyText": "i didn't see you check that anything was restarted", "author": "markxnelson", "createdAt": "2020-05-06T00:29:31Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -504,12 +534,201 @@ public void testCreateMiiDomainSameDomainUidDiffNS() {\n     }\n   }\n \n+  @Test\n+  @Order(4)\n+  @DisplayName(\"Update the sample-app application to version 2\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testPatchAppV2() {\n+    \n+    // app in the new image contains what is in the original app dir sample-app, \n+    // plus the replacements or/and additions in the second app dir sample-app-2.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+    \n+    // The verification of app's continuous availability during patching is turned off\n+    // because it fails intermittently right now. It can be enabled using the following system property.\n+    // We'll remove the property and enable it all the time once the product problem (tracked\n+    // by owls-81575) is fixed.\n+    final String enableAppAvailbilityCheck = \n+        System.getProperty(\"weblogic.operator.enableAppAvailabilityCheck\", \"false\");\n+    Thread accountingThread = null;\n+    List<Integer> appAvailability = new ArrayList<Integer>();\n+    \n+    if (enableAppAvailbilityCheck.equalsIgnoreCase(\"true\")) {\n+      // start a new thread to collect the availability data of the app while the\n+      // main thread performs patching operation, and checking of the results.\n+      accountingThread =\n+          new Thread(\n+              () -> {\n+                collectAppAvaiability(\n+                    domainNamespace,\n+                    appAvailability,\n+                    managedServerPrefix,\n+                    replicaCount,\n+                    \"8001\",\n+                    \"sample-war/index.jsp\");\n+              });\n+      accountingThread.start();\n+    }\n+   \n+    try {\n+      logger.info(\"Check and make sure that V1 app is still running\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        quickCheckAppRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V1 + i);\n+      }\n+ \n+      logger.info(\"Check and make sure that the version 2 app is NOT running\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        quickCheckAppNotRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V2 + i);   \n+      }\n+ \n+      logger.info(\"Create a new image with app V2\");\n+      miiImagePatchAppV2 = updateImageWithAppV2Patch(\n+          String.format(\"%s-%s\", MII_IMAGE_NAME, \"test-patch-app-v2\"),\n+          Arrays.asList(appDir1, appDir2));\n+\n+      // push the image to OCIR to make the test work in multi node cluster\n+      pushImageIfNeeded(miiImagePatchAppV2);\n+\n+      // patch the domain resource with the new image and verify that the domain resource is patched, \n+      // and all server pods are patched as well.\n+      logger.info(\"Patch domain resource with the new image, and verify the results\");\n+      patchAndVerify(\n+          domainUid,\n+          domainNamespace,\n+          adminServerPodName,\n+          managedServerPrefix,\n+          replicaCount,\n+          miiImagePatchAppV2);\n+\n+      logger.info(\"Check and wait for the V2 app to be ready\");\n+      for (int i = 1; i <= replicaCount; i++) {\n+        checkAppRunning(\n+            domainNamespace,\n+            managedServerPrefix + i,\n+            \"8001\",\n+            \"sample-war/index.jsp\",\n+            APP_RESPONSE_V2 + i);\n+      } \n+    } finally {\n+    \n+      if (accountingThread != null) {\n+        try {\n+          accountingThread.join();\n+        } catch (InterruptedException ie) {\n+          // do nothing\n+        }\n+ \n+        // check the app availability data that we have collected, and see if\n+        // the app has been available all the time since the beginning of this test method\n+        logger.info(\"Verify that the app was available in the duration when app was being patched\"); \n+        assertTrue(appAlwaysAvailable(appAvailability),\n+            \"App does not always avaiable when the domain is being patched with a newer version of the app\");\n+      }\n+    }\n+    \n+    logger.info(\"The cluster has been rolling restarted, and the version 2 app has been deployed correctly\");\n+  }\n+\n+  @Test\n+  @Order(5)\n+  @DisplayName(\"Update the domain with another application\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddSecondApp() {\n+    \n+    // the existing app is the combination of what are in appDir1 and appDir2 as in test case number 4,\n+    // the second app is in appDir3.\n+    final String appDir1 = \"sample-app\";\n+    final String appDir2 = \"sample-app-2\";\n+    final String appDir3 = \"sample-app-3\";\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    logger.info(\"Check V2 app is still running after the previous test\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      quickCheckAppRunning(\n+          domainNamespace,\n+          managedServerPrefix + i,\n+          \"8001\",\n+          \"sample-war/index.jsp\",\n+          APP_RESPONSE_V2 + i);\n+    }\n+\n+    logger.info(\"Check and make sure that the new app is NOT already running\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      quickCheckAppNotRunning(\n+          domainNamespace,\n+          managedServerPrefix + i,\n+          \"8001\",\n+          \"sample-war-3/index.jsp\",\n+          APP_RESPONSE_V3 + i);\n+    }\n+   \n+    logger.info(\"Create a new image that contains the additional app\");\n+    miiImageAddSecondApp = updateImageWithSampleApp3(\n+        String.format(\"%s-%s\", MII_IMAGE_NAME, \"test-add-second-app\"),\n+        Arrays.asList(appDir1, appDir2),\n+        Collections.singletonList(appDir3),\n+        \"model2-wls.yaml\");\n+    \n+    // push the image to OCIR to make the test work in multi node cluster\n+    pushImageIfNeeded(miiImageAddSecondApp);\n+   \n+    // patch the domain resource with the new image and verify that the domain resource is patched, \n+    // and all server pods are patched as well.\n+    logger.info(\"Patch the domain with the new image, and verify the result\"); \n+    patchAndVerify(\n+        domainUid,\n+        domainNamespace,\n+        adminServerPodName,\n+        managedServerPrefix,\n+        replicaCount,\n+        miiImageAddSecondApp);\n+    \n+    logger.info(\"Check and wait for the new app to become ready\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkAppRunning(\n+          domainNamespace,\n+          managedServerPrefix + i,\n+          \"8001\",\n+          \"sample-war-3/index.jsp\",\n+          APP_RESPONSE_V3 + i);\n+    }\n+ \n+    logger.info(\"Check and wait for the original app V2 to become ready\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkAppRunning(\n+          domainNamespace,\n+          managedServerPrefix + i,\n+          \"8001\",\n+          \"sample-war/index.jsp\",\n+          APP_RESPONSE_V2 + i);\n+    }\n+\n+    logger.info(\"The cluster has been rolling restarted, and the two applications are both running correctly\");", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NTM1Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420485356", "bodyText": "this feels like the wrong way to assure what you want to happen, especially as the test could fail before you get to here", "author": "markxnelson", "createdAt": "2020-05-06T00:30:39Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -526,14 +745,38 @@ void tearDown() {\n             \"deleteDomainCustomResource failed with ApiException\");\n     logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace1);\n \n-    // delete the domain image created for the test\n+    // delete the domain images created in the test class\n     if (miiImage != null) {\n       deleteImage(miiImage);\n     }\n+    if (miiImagePatchAppV2 != null) {\n+      deleteImage(miiImagePatchAppV2);\n+    }\n+    if (miiImageAddSecondApp != null) {\n+      deleteImage(miiImageAddSecondApp);\n+    }\n \n+    // clean up the download directory so that we always get the latest", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NTQ5Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420485492", "bodyText": "include some details, at least the repo name", "author": "markxnelson", "createdAt": "2020-05-06T00:31:07Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -526,14 +745,38 @@ void tearDown() {\n             \"deleteDomainCustomResource failed with ApiException\");\n     logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace1);\n \n-    // delete the domain image created for the test\n+    // delete the domain images created in the test class\n     if (miiImage != null) {\n       deleteImage(miiImage);\n     }\n+    if (miiImagePatchAppV2 != null) {\n+      deleteImage(miiImagePatchAppV2);\n+    }\n+    if (miiImageAddSecondApp != null) {\n+      deleteImage(miiImageAddSecondApp);\n+    }\n \n+    // clean up the download directory so that we always get the latest\n+    // versions of the tools in every run of the test class.\n+    try {\n+      cleanupDirectory(DOWNLOAD_DIR);\n+    } catch (IOException | RuntimeException e) {    \n+      logger.severe(\"Failed to cleanup the download directory \" + DOWNLOAD_DIR + \" ready\", e);    \n+    }\n   }\n \n-  private String createImageAndVerify() {\n+  private void pushImageIfNeeded(String image) {\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NTYwOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420485609", "bodyText": "how do you know it is ocir? \"registry\" would be a more accurate choice", "author": "markxnelson", "createdAt": "2020-05-06T00:31:32Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -526,14 +745,38 @@ void tearDown() {\n             \"deleteDomainCustomResource failed with ApiException\");\n     logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace1);\n \n-    // delete the domain image created for the test\n+    // delete the domain images created in the test class\n     if (miiImage != null) {\n       deleteImage(miiImage);\n     }\n+    if (miiImagePatchAppV2 != null) {\n+      deleteImage(miiImagePatchAppV2);\n+    }\n+    if (miiImageAddSecondApp != null) {\n+      deleteImage(miiImageAddSecondApp);\n+    }\n \n+    // clean up the download directory so that we always get the latest\n+    // versions of the tools in every run of the test class.\n+    try {\n+      cleanupDirectory(DOWNLOAD_DIR);\n+    } catch (IOException | RuntimeException e) {    \n+      logger.severe(\"Failed to cleanup the download directory \" + DOWNLOAD_DIR + \" ready\", e);    \n+    }\n   }\n \n-  private String createImageAndVerify() {\n+  private void pushImageIfNeeded(String image) {\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", image);", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NTkxOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420485918", "bodyText": "this seems to be repeated - make it a static or a const or something?", "author": "markxnelson", "createdAt": "2020-05-06T00:32:43Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -543,23 +786,152 @@ private String createImageAndVerify() {\n     final String image = imageName + \":\" + imageTag;\n \n     // build the model file list\n-    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+    final List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n \n     // build an application archive using what is in resources/apps/APP_NAME\n     assertTrue(buildAppArchive(defaultAppParams()\n-        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+        .srcDirList(Collections.singletonList(APP_NAME))), \n+        String.format(\"Failed to create app archive for %s\", APP_NAME));\n \n     // build the archive list\n-    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n-    final List<String> archiveList = Collections.singletonList(zipFile);\n+    List<String> archiveList = \n+        Collections.singletonList(String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+\n+    createImageAndVerify(imageName, imageTag, modelList, archiveList);\n+\n+    return image;\n+  }\n+  \n+  private String updateImageWithAppV2Patch(\n+      String imageName,\n+      List<String> appDirList\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjA2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420486060", "bodyText": "there was no logging at all in this method", "author": "markxnelson", "createdAt": "2020-05-06T00:33:20Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -543,23 +786,152 @@ private String createImageAndVerify() {\n     final String image = imageName + \":\" + imageTag;\n \n     // build the model file list\n-    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+    final List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n \n     // build an application archive using what is in resources/apps/APP_NAME\n     assertTrue(buildAppArchive(defaultAppParams()\n-        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+        .srcDirList(Collections.singletonList(APP_NAME))), \n+        String.format(\"Failed to create app archive for %s\", APP_NAME));\n \n     // build the archive list\n-    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n-    final List<String> archiveList = Collections.singletonList(zipFile);\n+    List<String> archiveList = \n+        Collections.singletonList(String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+\n+    createImageAndVerify(imageName, imageTag, modelList, archiveList);\n+\n+    return image;\n+  }\n+  \n+  private String updateImageWithAppV2Patch(\n+      String imageName,\n+      List<String> appDirList\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n+   \n+    // build an application archive\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList)),\n+        String.format(\"Failed to create app archive for %s\",\n+            APP_NAME));\n+\n+    // build the archive list\n+    List<String> archiveList = \n+        Collections.singletonList(\n+            String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAxMDUxNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421010516", "bodyText": "added", "author": "doxiao", "createdAt": "2020-05-06T18:40:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjE2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420486164", "bodyText": "seems like a lot of duplicate code here - refactor", "author": "markxnelson", "createdAt": "2020-05-06T00:33:44Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -543,23 +786,152 @@ private String createImageAndVerify() {\n     final String image = imageName + \":\" + imageTag;\n \n     // build the model file list\n-    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+    final List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n \n     // build an application archive using what is in resources/apps/APP_NAME\n     assertTrue(buildAppArchive(defaultAppParams()\n-        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+        .srcDirList(Collections.singletonList(APP_NAME))), \n+        String.format(\"Failed to create app archive for %s\", APP_NAME));\n \n     // build the archive list\n-    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n-    final List<String> archiveList = Collections.singletonList(zipFile);\n+    List<String> archiveList = \n+        Collections.singletonList(String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+\n+    createImageAndVerify(imageName, imageTag, modelList, archiveList);\n+\n+    return image;\n+  }\n+  \n+  private String updateImageWithAppV2Patch(\n+      String imageName,\n+      List<String> appDirList\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n+   \n+    // build an application archive\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList)),\n+        String.format(\"Failed to create app archive for %s\",\n+            APP_NAME));\n+\n+    // build the archive list\n+    List<String> archiveList = \n+        Collections.singletonList(\n+            String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }\n+\n+  private String updateImageWithSampleApp3(", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAxMDY2Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421010662", "bodyText": "done", "author": "doxiao", "createdAt": "2020-05-06T18:41:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjIxMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420486213", "bodyText": "spelling", "author": "markxnelson", "createdAt": "2020-05-06T00:33:56Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -543,23 +786,152 @@ private String createImageAndVerify() {\n     final String image = imageName + \":\" + imageTag;\n \n     // build the model file list\n-    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+    final List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n \n     // build an application archive using what is in resources/apps/APP_NAME\n     assertTrue(buildAppArchive(defaultAppParams()\n-        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+        .srcDirList(Collections.singletonList(APP_NAME))), \n+        String.format(\"Failed to create app archive for %s\", APP_NAME));\n \n     // build the archive list\n-    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n-    final List<String> archiveList = Collections.singletonList(zipFile);\n+    List<String> archiveList = \n+        Collections.singletonList(String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+\n+    createImageAndVerify(imageName, imageTag, modelList, archiveList);\n+\n+    return image;\n+  }\n+  \n+  private String updateImageWithAppV2Patch(\n+      String imageName,\n+      List<String> appDirList\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n+   \n+    // build an application archive\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList)),\n+        String.format(\"Failed to create app archive for %s\",\n+            APP_NAME));\n+\n+    // build the archive list\n+    List<String> archiveList = \n+        Collections.singletonList(\n+            String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }\n+\n+  private String updateImageWithSampleApp3(\n+      String imageName,\n+      List<String> appDirList1,\n+      List<String> appDirList2,\n+      String modelFile\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + modelFile);\n+ \n+    String appName1 = appDirList1.get(0);\n+    String appName2 = appDirList2.get(0);\n+    \n+    // build an application archive that contains the existing app\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList1)\n+                .appName(appName1)),\n+        String.format(\"Failed to create app archive for %s\",\n+            appName1));\n+    \n+    logger.info(\"Successfully created app zip file: \" + appName1);\n+     \n+    // build an application archive that contains the new app\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList2)\n+                .appName(appName2)),\n+        String.format(\"Failed to create app archive for %s\",\n+            appName2));\n+    \n+    logger.info(\"Successfully cteated app zip file: \" + appName2); \n+    \n+    // build the archive list with two zip files\n+    List<String> archiveList = Arrays.asList(\n+        String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName1),\n+        String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName2));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new image.\n+   * Here is an example of the JSON patch string that is constructed in this method.\n+   * [\n+   *   {\"op\": \"replace\", \"path\": \"/spec/image\", \"value\": \"mii-image:v2\" }\n+   * ]\n+   * \n+   * @param domainUid unique identifier of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param image name of the new image\n+   */\n+  private void patchDomainResourceIamge(", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjQxMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420486410", "bodyText": "you are really using the resource's metadata.name right? not domainUid -- even though they might happen to be the same", "author": "markxnelson", "createdAt": "2020-05-06T00:34:39Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -543,23 +786,152 @@ private String createImageAndVerify() {\n     final String image = imageName + \":\" + imageTag;\n \n     // build the model file list\n-    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+    final List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n \n     // build an application archive using what is in resources/apps/APP_NAME\n     assertTrue(buildAppArchive(defaultAppParams()\n-        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+        .srcDirList(Collections.singletonList(APP_NAME))), \n+        String.format(\"Failed to create app archive for %s\", APP_NAME));\n \n     // build the archive list\n-    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n-    final List<String> archiveList = Collections.singletonList(zipFile);\n+    List<String> archiveList = \n+        Collections.singletonList(String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+\n+    createImageAndVerify(imageName, imageTag, modelList, archiveList);\n+\n+    return image;\n+  }\n+  \n+  private String updateImageWithAppV2Patch(\n+      String imageName,\n+      List<String> appDirList\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n+   \n+    // build an application archive\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList)),\n+        String.format(\"Failed to create app archive for %s\",\n+            APP_NAME));\n+\n+    // build the archive list\n+    List<String> archiveList = \n+        Collections.singletonList(\n+            String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }\n+\n+  private String updateImageWithSampleApp3(\n+      String imageName,\n+      List<String> appDirList1,\n+      List<String> appDirList2,\n+      String modelFile\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + modelFile);\n+ \n+    String appName1 = appDirList1.get(0);\n+    String appName2 = appDirList2.get(0);\n+    \n+    // build an application archive that contains the existing app\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList1)\n+                .appName(appName1)),\n+        String.format(\"Failed to create app archive for %s\",\n+            appName1));\n+    \n+    logger.info(\"Successfully created app zip file: \" + appName1);\n+     \n+    // build an application archive that contains the new app\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList2)\n+                .appName(appName2)),\n+        String.format(\"Failed to create app archive for %s\",\n+            appName2));\n+    \n+    logger.info(\"Successfully cteated app zip file: \" + appName2); \n+    \n+    // build the archive list with two zip files\n+    List<String> archiveList = Arrays.asList(\n+        String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName1),\n+        String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName2));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new image.\n+   * Here is an example of the JSON patch string that is constructed in this method.\n+   * [\n+   *   {\"op\": \"replace\", \"path\": \"/spec/image\", \"value\": \"mii-image:v2\" }\n+   * ]\n+   * \n+   * @param domainUid unique identifier of the domain resource", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjUwMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420486501", "bodyText": "which domain resource?", "author": "markxnelson", "createdAt": "2020-05-06T00:34:55Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -543,23 +786,152 @@ private String createImageAndVerify() {\n     final String image = imageName + \":\" + imageTag;\n \n     // build the model file list\n-    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+    final List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n \n     // build an application archive using what is in resources/apps/APP_NAME\n     assertTrue(buildAppArchive(defaultAppParams()\n-        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+        .srcDirList(Collections.singletonList(APP_NAME))), \n+        String.format(\"Failed to create app archive for %s\", APP_NAME));\n \n     // build the archive list\n-    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n-    final List<String> archiveList = Collections.singletonList(zipFile);\n+    List<String> archiveList = \n+        Collections.singletonList(String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+\n+    createImageAndVerify(imageName, imageTag, modelList, archiveList);\n+\n+    return image;\n+  }\n+  \n+  private String updateImageWithAppV2Patch(\n+      String imageName,\n+      List<String> appDirList\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n+   \n+    // build an application archive\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList)),\n+        String.format(\"Failed to create app archive for %s\",\n+            APP_NAME));\n+\n+    // build the archive list\n+    List<String> archiveList = \n+        Collections.singletonList(\n+            String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }\n+\n+  private String updateImageWithSampleApp3(\n+      String imageName,\n+      List<String> appDirList1,\n+      List<String> appDirList2,\n+      String modelFile\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + modelFile);\n+ \n+    String appName1 = appDirList1.get(0);\n+    String appName2 = appDirList2.get(0);\n+    \n+    // build an application archive that contains the existing app\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList1)\n+                .appName(appName1)),\n+        String.format(\"Failed to create app archive for %s\",\n+            appName1));\n+    \n+    logger.info(\"Successfully created app zip file: \" + appName1);\n+     \n+    // build an application archive that contains the new app\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList2)\n+                .appName(appName2)),\n+        String.format(\"Failed to create app archive for %s\",\n+            appName2));\n+    \n+    logger.info(\"Successfully cteated app zip file: \" + appName2); \n+    \n+    // build the archive list with two zip files\n+    List<String> archiveList = Arrays.asList(\n+        String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName1),\n+        String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName2));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new image.\n+   * Here is an example of the JSON patch string that is constructed in this method.\n+   * [\n+   *   {\"op\": \"replace\", \"path\": \"/spec/image\", \"value\": \"mii-image:v2\" }\n+   * ]\n+   * \n+   * @param domainUid unique identifier of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param image name of the new image\n+   */\n+  private void patchDomainResourceIamge(\n+      String domainUid,\n+      String namespace,\n+      String image\n+  ) {\n+    String patch = \n+        String.format(\"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/image\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            image);\n+    logger.info(\"About to patch the domain resource with:\\n\" + patch);", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjU2Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420486567", "bodyText": "spelling?\nwhich domain resource? which image?\nmake the log messages more informative", "author": "markxnelson", "createdAt": "2020-05-06T00:35:16Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -543,23 +786,152 @@ private String createImageAndVerify() {\n     final String image = imageName + \":\" + imageTag;\n \n     // build the model file list\n-    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+    final List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n \n     // build an application archive using what is in resources/apps/APP_NAME\n     assertTrue(buildAppArchive(defaultAppParams()\n-        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+        .srcDirList(Collections.singletonList(APP_NAME))), \n+        String.format(\"Failed to create app archive for %s\", APP_NAME));\n \n     // build the archive list\n-    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n-    final List<String> archiveList = Collections.singletonList(zipFile);\n+    List<String> archiveList = \n+        Collections.singletonList(String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+\n+    createImageAndVerify(imageName, imageTag, modelList, archiveList);\n+\n+    return image;\n+  }\n+  \n+  private String updateImageWithAppV2Patch(\n+      String imageName,\n+      List<String> appDirList\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = \n+        Collections.singletonList(String.format(\"%s/%s\", MODEL_DIR, WDT_MODEL_FILE));\n+   \n+    // build an application archive\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList)),\n+        String.format(\"Failed to create app archive for %s\",\n+            APP_NAME));\n+\n+    // build the archive list\n+    List<String> archiveList = \n+        Collections.singletonList(\n+            String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }\n+\n+  private String updateImageWithSampleApp3(\n+      String imageName,\n+      List<String> appDirList1,\n+      List<String> appDirList2,\n+      String modelFile\n+  ) {\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageNameReal = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? imageName : REPO_NAME + imageName;\n+    String image = String.format(\"%s:%s\",  imageNameReal, imageTag);\n+    \n+    // build the model file list\n+    List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + modelFile);\n+ \n+    String appName1 = appDirList1.get(0);\n+    String appName2 = appDirList2.get(0);\n+    \n+    // build an application archive that contains the existing app\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList1)\n+                .appName(appName1)),\n+        String.format(\"Failed to create app archive for %s\",\n+            appName1));\n+    \n+    logger.info(\"Successfully created app zip file: \" + appName1);\n+     \n+    // build an application archive that contains the new app\n+    assertTrue(\n+        buildAppArchive(\n+            defaultAppParams()\n+                .srcDirList(appDirList2)\n+                .appName(appName2)),\n+        String.format(\"Failed to create app archive for %s\",\n+            appName2));\n+    \n+    logger.info(\"Successfully cteated app zip file: \" + appName2); \n+    \n+    // build the archive list with two zip files\n+    List<String> archiveList = Arrays.asList(\n+        String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName1),\n+        String.format(\"%s/%s.zip\", ARCHIVE_DIR, appName2));\n+    \n+    createImageAndVerify(imageNameReal, imageTag, modelList, archiveList);\n+    \n+    return image;\n+  }\n+\n+  /**\n+   * Patch the domain resource with a new image.\n+   * Here is an example of the JSON patch string that is constructed in this method.\n+   * [\n+   *   {\"op\": \"replace\", \"path\": \"/spec/image\", \"value\": \"mii-image:v2\" }\n+   * ]\n+   * \n+   * @param domainUid unique identifier of the domain resource\n+   * @param namespace Kubernetes namespace that the domain is hosted\n+   * @param image name of the new image\n+   */\n+  private void patchDomainResourceIamge(\n+      String domainUid,\n+      String namespace,\n+      String image\n+  ) {\n+    String patch = \n+        String.format(\"[\\n  {\\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/spec/image\\\", \\\"value\\\": \\\"%s\\\"}\\n]\\n\",\n+            image);\n+    logger.info(\"About to patch the domain resource with:\\n\" + patch);\n+\n+    assertTrue(patchDomainCustomResource(\n+            domainUid,\n+            namespace,\n+            new V1Patch(patch),\n+            V1Patch.PATCH_FORMAT_JSON_PATCH),\n+        \"Failed to patch the domain resource with a  a different image.\");", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjY4MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420486681", "bodyText": "no logging?", "author": "markxnelson", "createdAt": "2020-05-06T00:35:38Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -693,6 +1063,38 @@ private void checkPodCreated(String podName, String domainUid, String domNamespa\n \n   }\n \n+  private void patchAndVerify(\n+      final String domainUid,\n+      final String namespace,\n+      final String adminServerPodName,\n+      final String managedServerPrefix,\n+      final int replicaCount,\n+      final String image\n+  ) {", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAxMDc0NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421010745", "bodyText": "added", "author": "doxiao", "createdAt": "2020-05-06T18:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4Njg5MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420486891", "bodyText": "should be checking the return values, or catching exceptions, or something here...", "author": "markxnelson", "createdAt": "2020-05-06T00:36:35Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -693,6 +1063,38 @@ private void checkPodCreated(String podName, String domainUid, String domNamespa\n \n   }\n \n+  private void patchAndVerify(\n+      final String domainUid,\n+      final String namespace,\n+      final String adminServerPodName,\n+      final String managedServerPrefix,\n+      final int replicaCount,\n+      final String image\n+  ) {\n+    // modify the domain resource to use the new image\n+    patchDomainResourceIamge(domainUid, namespace, image);", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzA4NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420487085", "bodyText": "duplicate code - refactor", "author": "markxnelson", "createdAt": "2020-05-06T00:37:23Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAxMDgzNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421010836", "bodyText": "done", "author": "doxiao", "createdAt": "2020-05-06T18:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzE0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420487148", "bodyText": "duplication", "author": "markxnelson", "createdAt": "2020-05-06T00:37:37Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAxMTA0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421011046", "bodyText": "refactored the code a little", "author": "doxiao", "createdAt": "2020-05-06T18:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzMwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420487304", "bodyText": "initialize?", "author": "markxnelson", "createdAt": "2020-05-06T00:38:16Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is not running inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is not running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appNotAccessibleInPod(\n+                namespace, \n+                podName,\n+                internalPort, \n+                appPath, \n+                expectedStr));\n+  }\n+   \n+  private void checkDomainPatched(\n+      String domainUid,\n+      String namespace,\n+      String image \n+  ) {\n+   \n+    // check if the domain resource has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceImagePatched(domainUid, namespace, image),\n+            String.format(\n+               \"Domain %s is not patched in namespace %s with image %s\", domainUid, namespace, image)));\n+\n+  }\n+  \n+  private void checkPodImagePatched(\n+      String domainUid,\n+      String namespace,\n+      String podName,\n+      String image\n+  ) {\n+   \n+    // check if the server pod has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podImagePatched(domainUid, namespace, podName, image),\n+            String.format(\n+               \"Pod %s is not patched with image %s in namespace %s.\",\n+               podName,\n+               image,\n+               namespace)));\n+  }\n+  \n+  private static void collectAppAvaiability(\n+      String namespace,\n+      List<Integer> appAvailability,\n+      String managedServerPrefix,\n+      int replicaCount,\n+      String internalPort,\n+      String appPath\n+  ) {\n+    boolean v2AppAvailable;", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzQzNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420487434", "bodyText": "surely you're not pinging it  - fix this doc", "author": "markxnelson", "createdAt": "2020-05-06T00:38:47Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is not running inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is not running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appNotAccessibleInPod(\n+                namespace, \n+                podName,\n+                internalPort, \n+                appPath, \n+                expectedStr));\n+  }\n+   \n+  private void checkDomainPatched(\n+      String domainUid,\n+      String namespace,\n+      String image \n+  ) {\n+   \n+    // check if the domain resource has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceImagePatched(domainUid, namespace, image),\n+            String.format(\n+               \"Domain %s is not patched in namespace %s with image %s\", domainUid, namespace, image)));\n+\n+  }\n+  \n+  private void checkPodImagePatched(\n+      String domainUid,\n+      String namespace,\n+      String podName,\n+      String image\n+  ) {\n+   \n+    // check if the server pod has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podImagePatched(domainUid, namespace, podName, image),\n+            String.format(\n+               \"Pod %s is not patched with image %s in namespace %s.\",\n+               podName,\n+               image,\n+               namespace)));\n+  }\n+  \n+  private static void collectAppAvaiability(\n+      String namespace,\n+      List<Integer> appAvailability,\n+      String managedServerPrefix,\n+      int replicaCount,\n+      String internalPort,\n+      String appPath\n+  ) {\n+    boolean v2AppAvailable;\n+ \n+    // ping the app periodically to check its availability across the duration", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzU0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420487546", "bodyText": "it's - possessive", "author": "markxnelson", "createdAt": "2020-05-06T00:39:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzYwMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420487603", "bodyText": "application", "author": "markxnelson", "createdAt": "2020-05-06T00:39:16Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is not running inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is not running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appNotAccessibleInPod(\n+                namespace, \n+                podName,\n+                internalPort, \n+                appPath, \n+                expectedStr));\n+  }\n+   \n+  private void checkDomainPatched(\n+      String domainUid,\n+      String namespace,\n+      String image \n+  ) {\n+   \n+    // check if the domain resource has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceImagePatched(domainUid, namespace, image),\n+            String.format(\n+               \"Domain %s is not patched in namespace %s with image %s\", domainUid, namespace, image)));\n+\n+  }\n+  \n+  private void checkPodImagePatched(\n+      String domainUid,\n+      String namespace,\n+      String podName,\n+      String image\n+  ) {\n+   \n+    // check if the server pod has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podImagePatched(domainUid, namespace, podName, image),\n+            String.format(\n+               \"Pod %s is not patched with image %s in namespace %s.\",\n+               podName,\n+               image,\n+               namespace)));\n+  }\n+  \n+  private static void collectAppAvaiability(\n+      String namespace,\n+      List<Integer> appAvailability,\n+      String managedServerPrefix,\n+      int replicaCount,\n+      String internalPort,\n+      String appPath\n+  ) {\n+    boolean v2AppAvailable;\n+ \n+    // ping the app periodically to check its availability across the duration\n+    // of patching the domain with newer version of the app.", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzY5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420487697", "bodyText": "fix the problem then - don't work around it", "author": "markxnelson", "createdAt": "2020-05-06T00:39:34Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is not running inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is not running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appNotAccessibleInPod(\n+                namespace, \n+                podName,\n+                internalPort, \n+                appPath, \n+                expectedStr));\n+  }\n+   \n+  private void checkDomainPatched(\n+      String domainUid,\n+      String namespace,\n+      String image \n+  ) {\n+   \n+    // check if the domain resource has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceImagePatched(domainUid, namespace, image),\n+            String.format(\n+               \"Domain %s is not patched in namespace %s with image %s\", domainUid, namespace, image)));\n+\n+  }\n+  \n+  private void checkPodImagePatched(\n+      String domainUid,\n+      String namespace,\n+      String podName,\n+      String image\n+  ) {\n+   \n+    // check if the server pod has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podImagePatched(domainUid, namespace, podName, image),\n+            String.format(\n+               \"Pod %s is not patched with image %s in namespace %s.\",\n+               podName,\n+               image,\n+               namespace)));\n+  }\n+  \n+  private static void collectAppAvaiability(\n+      String namespace,\n+      List<Integer> appAvailability,\n+      String managedServerPrefix,\n+      int replicaCount,\n+      String internalPort,\n+      String appPath\n+  ) {\n+    boolean v2AppAvailable;\n+ \n+    // ping the app periodically to check its availability across the duration\n+    // of patching the domain with newer version of the app.\n+    // Note: we use the \"kubectl exec\" command in this method only. This is to avoid", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAxMTQ0Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421011447", "bodyText": "Lenny is  working on this issue.", "author": "doxiao", "createdAt": "2020-05-06T18:42:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NzY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4Nzk0OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420487949", "bodyText": "do while hides important information - use while instead, it is much clearer", "author": "markxnelson", "createdAt": "2020-05-06T00:40:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is not running inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is not running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appNotAccessibleInPod(\n+                namespace, \n+                podName,\n+                internalPort, \n+                appPath, \n+                expectedStr));\n+  }\n+   \n+  private void checkDomainPatched(\n+      String domainUid,\n+      String namespace,\n+      String image \n+  ) {\n+   \n+    // check if the domain resource has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceImagePatched(domainUid, namespace, image),\n+            String.format(\n+               \"Domain %s is not patched in namespace %s with image %s\", domainUid, namespace, image)));\n+\n+  }\n+  \n+  private void checkPodImagePatched(\n+      String domainUid,\n+      String namespace,\n+      String podName,\n+      String image\n+  ) {\n+   \n+    // check if the server pod has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podImagePatched(domainUid, namespace, podName, image),\n+            String.format(\n+               \"Pod %s is not patched with image %s in namespace %s.\",\n+               podName,\n+               image,\n+               namespace)));\n+  }\n+  \n+  private static void collectAppAvaiability(\n+      String namespace,\n+      List<Integer> appAvailability,\n+      String managedServerPrefix,\n+      int replicaCount,\n+      String internalPort,\n+      String appPath\n+  ) {\n+    boolean v2AppAvailable;\n+ \n+    // ping the app periodically to check its availability across the duration\n+    // of patching the domain with newer version of the app.\n+    // Note: we use the \"kubectl exec\" command in this method only. This is to avoid\n+    // problems when two threads accessing the same pod at the same time via Kubernetes\n+    // Java client.\n+    do {", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODA2OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420488068", "bodyText": "same", "author": "markxnelson", "createdAt": "2020-05-06T00:41:11Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is not running inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is not running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appNotAccessibleInPod(\n+                namespace, \n+                podName,\n+                internalPort, \n+                appPath, \n+                expectedStr));\n+  }\n+   \n+  private void checkDomainPatched(\n+      String domainUid,\n+      String namespace,\n+      String image \n+  ) {\n+   \n+    // check if the domain resource has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceImagePatched(domainUid, namespace, image),\n+            String.format(\n+               \"Domain %s is not patched in namespace %s with image %s\", domainUid, namespace, image)));\n+\n+  }\n+  \n+  private void checkPodImagePatched(\n+      String domainUid,\n+      String namespace,\n+      String podName,\n+      String image\n+  ) {\n+   \n+    // check if the server pod has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podImagePatched(domainUid, namespace, podName, image),\n+            String.format(\n+               \"Pod %s is not patched with image %s in namespace %s.\",\n+               podName,\n+               image,\n+               namespace)));\n+  }\n+  \n+  private static void collectAppAvaiability(\n+      String namespace,\n+      List<Integer> appAvailability,\n+      String managedServerPrefix,\n+      int replicaCount,\n+      String internalPort,\n+      String appPath\n+  ) {\n+    boolean v2AppAvailable;\n+ \n+    // ping the app periodically to check its availability across the duration\n+    // of patching the domain with newer version of the app.\n+    // Note: we use the \"kubectl exec\" command in this method only. This is to avoid\n+    // problems when two threads accessing the same pod at the same time via Kubernetes\n+    // Java client.\n+    do {\n+      v2AppAvailable = true;\n+      for (int i = 1; i <= replicaCount; i++) {\n+        v2AppAvailable = v2AppAvailable && appAccessibleInPodKubectl(\n+                            namespace,\n+                            managedServerPrefix + i, \n+                            internalPort, \n+                            appPath, \n+                            APP_RESPONSE_V2 + i);\n+      }\n+\n+      int count = 0;\n+      for (int i = 1; i <= replicaCount; i++) {\n+        if (appAccessibleInPodKubectl(\n+            namespace,\n+            managedServerPrefix + i, \n+            internalPort, \n+            appPath, \n+            \"Hello World\")) {  \n+          count++;\n+        }\n+      }\n+      appAvailability.add(count);\n+      \n+      // the following log messages are temporarily here for debugging purposes.\n+      // This part of the code is disabled by default right now, and can be enabled by\n+      // -Dweblogic.operator.enableAppAvailabilityCheck=true.\n+      // TODO remove these log messages when this verification is fully enabled.\n+      if (count == 0) {\n+        logger.info(\"XXXXXXXXXXX: app not available XXXXXXXX\");\n       } else {\n-        fail(\"Ready command failed with exit status code: \" + execResult.exitValue());\n+        logger.info(\"YYYYYYYYYYY: app available YYYYYYYY count = \" + count);   \n+      }\n+      try {\n+        TimeUnit.MILLISECONDS.sleep(200);\n+      } catch (InterruptedException ie) {\n+        // do nothing\n+      }\n+    } while (!v2AppAvailable);\n+  }\n+  \n+  private static boolean appAlwaysAvailable(List<Integer> appAvailability) {\n+    for (Integer count: appAvailability) {\n+      if (count == 0) {\n+        logger.warning(\"App was not continuously available during patching.\");", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODE3NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420488174", "bodyText": "running or ready? they are two different things", "author": "markxnelson", "createdAt": "2020-05-06T00:41:31Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is not running inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is not running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appNotAccessibleInPod(\n+                namespace, \n+                podName,\n+                internalPort, \n+                appPath, \n+                expectedStr));\n+  }\n+   \n+  private void checkDomainPatched(\n+      String domainUid,\n+      String namespace,\n+      String image \n+  ) {\n+   \n+    // check if the domain resource has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceImagePatched(domainUid, namespace, image),\n+            String.format(\n+               \"Domain %s is not patched in namespace %s with image %s\", domainUid, namespace, image)));\n+\n+  }\n+  \n+  private void checkPodImagePatched(\n+      String domainUid,\n+      String namespace,\n+      String podName,\n+      String image\n+  ) {\n+   \n+    // check if the server pod has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podImagePatched(domainUid, namespace, podName, image),\n+            String.format(\n+               \"Pod %s is not patched with image %s in namespace %s.\",\n+               podName,\n+               image,\n+               namespace)));\n+  }\n+  \n+  private static void collectAppAvaiability(\n+      String namespace,\n+      List<Integer> appAvailability,\n+      String managedServerPrefix,\n+      int replicaCount,\n+      String internalPort,\n+      String appPath\n+  ) {\n+    boolean v2AppAvailable;\n+ \n+    // ping the app periodically to check its availability across the duration\n+    // of patching the domain with newer version of the app.\n+    // Note: we use the \"kubectl exec\" command in this method only. This is to avoid\n+    // problems when two threads accessing the same pod at the same time via Kubernetes\n+    // Java client.\n+    do {\n+      v2AppAvailable = true;\n+      for (int i = 1; i <= replicaCount; i++) {\n+        v2AppAvailable = v2AppAvailable && appAccessibleInPodKubectl(\n+                            namespace,\n+                            managedServerPrefix + i, \n+                            internalPort, \n+                            appPath, \n+                            APP_RESPONSE_V2 + i);\n+      }\n+\n+      int count = 0;\n+      for (int i = 1; i <= replicaCount; i++) {\n+        if (appAccessibleInPodKubectl(\n+            namespace,\n+            managedServerPrefix + i, \n+            internalPort, \n+            appPath, \n+            \"Hello World\")) {  \n+          count++;\n+        }\n+      }\n+      appAvailability.add(count);\n+      \n+      // the following log messages are temporarily here for debugging purposes.\n+      // This part of the code is disabled by default right now, and can be enabled by\n+      // -Dweblogic.operator.enableAppAvailabilityCheck=true.\n+      // TODO remove these log messages when this verification is fully enabled.\n+      if (count == 0) {\n+        logger.info(\"XXXXXXXXXXX: app not available XXXXXXXX\");\n       } else {\n-        fail(\"Ready command failed with exit status code: \" + execResult.exitValue());\n+        logger.info(\"YYYYYYYYYYY: app available YYYYYYYY count = \" + count);   \n+      }\n+      try {\n+        TimeUnit.MILLISECONDS.sleep(200);\n+      } catch (InterruptedException ie) {\n+        // do nothing\n+      }\n+    } while (!v2AppAvailable);\n+  }\n+  \n+  private static boolean appAlwaysAvailable(List<Integer> appAvailability) {\n+    for (Integer count: appAvailability) {\n+      if (count == 0) {\n+        logger.warning(\"App was not continuously available during patching.\");\n+        return false;\n       }\n-    } else {\n-      fail(\"Did not find pod \" + podName + \" in namespace \" + namespace);\n     }\n+    return true;\n   }\n \n+  private void checkServerReadyStatusByExec(String podName, String namespace) {\n+    ExecResult execResult = assertDoesNotThrow(\n+        () -> execCommand(namespace, podName, null, true, READ_STATE_COMMAND));\n+    if (execResult.exitValue() == 0) {\n+      logger.info(\"execResult: \" + execResult);\n+      assertEquals(\"RUNNING\", execResult.stdout(),\n+          \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAxMjEwNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421012107", "bodyText": "This checks the WebLogic server state from the node manager.", "author": "doxiao", "createdAt": "2020-05-06T18:43:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODMxMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420488312", "bodyText": "what is \"ready command\"?  do you mean readiness probe?", "author": "markxnelson", "createdAt": "2020-05-06T00:41:56Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -719,27 +1121,210 @@ private void checkServiceCreated(String serviceName, String domNamespace) {\n                 condition.getRemainingTimeInMS()))\n         .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n             String.format(\n-                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+                \"Service %s is not ready in namespace %s\", serviceName, domNamespace)));\n \n   }\n \n-  private void checkServerReadyStatusByExec(String podName, String namespace) {\n-    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n-        .getPod(namespace, null, podName));\n-\n-    if (pod != null) {\n-      ExecResult execResult = assertDoesNotThrow(\n-          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n-      if (execResult.exitValue() == 0) {\n-        logger.info(\"execResult: \" + execResult);\n-        assertEquals(\"RUNNING\", execResult.stdout(),\n-            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+  private void checkAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for application {0} to be ready on {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace, \n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is accessible inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appAccessibleInPod(\n+                namespace,\n+                podName, \n+                internalPort, \n+                appPath, \n+                expectedStr));\n+\n+  }\n+  \n+  private void quickCheckAppNotRunning(\n+      String namespace,\n+      String podName,\n+      String internalPort,\n+      String appPath,\n+      String expectedStr\n+  ) {\n+   \n+    // check if the app is not running inside of a server pod\n+    withQuickRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Checking if application {0} is not running on pod {1} in namespace {2} \"\n+            + \"(elapsed time {3}ms, remaining time {4}ms)\",\n+            appPath,\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(() -> appNotAccessibleInPod(\n+                namespace, \n+                podName,\n+                internalPort, \n+                appPath, \n+                expectedStr));\n+  }\n+   \n+  private void checkDomainPatched(\n+      String domainUid,\n+      String namespace,\n+      String image \n+  ) {\n+   \n+    // check if the domain resource has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            domainUid,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> domainResourceImagePatched(domainUid, namespace, image),\n+            String.format(\n+               \"Domain %s is not patched in namespace %s with image %s\", domainUid, namespace, image)));\n+\n+  }\n+  \n+  private void checkPodImagePatched(\n+      String domainUid,\n+      String namespace,\n+      String podName,\n+      String image\n+  ) {\n+   \n+    // check if the server pod has been patched with the given image\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be patched in namespace {1} \"\n+            + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+            podName,\n+            namespace,\n+            condition.getElapsedTimeInMS(),\n+            condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podImagePatched(domainUid, namespace, podName, image),\n+            String.format(\n+               \"Pod %s is not patched with image %s in namespace %s.\",\n+               podName,\n+               image,\n+               namespace)));\n+  }\n+  \n+  private static void collectAppAvaiability(\n+      String namespace,\n+      List<Integer> appAvailability,\n+      String managedServerPrefix,\n+      int replicaCount,\n+      String internalPort,\n+      String appPath\n+  ) {\n+    boolean v2AppAvailable;\n+ \n+    // ping the app periodically to check its availability across the duration\n+    // of patching the domain with newer version of the app.\n+    // Note: we use the \"kubectl exec\" command in this method only. This is to avoid\n+    // problems when two threads accessing the same pod at the same time via Kubernetes\n+    // Java client.\n+    do {\n+      v2AppAvailable = true;\n+      for (int i = 1; i <= replicaCount; i++) {\n+        v2AppAvailable = v2AppAvailable && appAccessibleInPodKubectl(\n+                            namespace,\n+                            managedServerPrefix + i, \n+                            internalPort, \n+                            appPath, \n+                            APP_RESPONSE_V2 + i);\n+      }\n+\n+      int count = 0;\n+      for (int i = 1; i <= replicaCount; i++) {\n+        if (appAccessibleInPodKubectl(\n+            namespace,\n+            managedServerPrefix + i, \n+            internalPort, \n+            appPath, \n+            \"Hello World\")) {  \n+          count++;\n+        }\n+      }\n+      appAvailability.add(count);\n+      \n+      // the following log messages are temporarily here for debugging purposes.\n+      // This part of the code is disabled by default right now, and can be enabled by\n+      // -Dweblogic.operator.enableAppAvailabilityCheck=true.\n+      // TODO remove these log messages when this verification is fully enabled.\n+      if (count == 0) {\n+        logger.info(\"XXXXXXXXXXX: app not available XXXXXXXX\");\n       } else {\n-        fail(\"Ready command failed with exit status code: \" + execResult.exitValue());\n+        logger.info(\"YYYYYYYYYYY: app available YYYYYYYY count = \" + count);   \n+      }\n+      try {\n+        TimeUnit.MILLISECONDS.sleep(200);\n+      } catch (InterruptedException ie) {\n+        // do nothing\n+      }\n+    } while (!v2AppAvailable);\n+  }\n+  \n+  private static boolean appAlwaysAvailable(List<Integer> appAvailability) {\n+    for (Integer count: appAvailability) {\n+      if (count == 0) {\n+        logger.warning(\"App was not continuously available during patching.\");\n+        return false;\n       }\n-    } else {\n-      fail(\"Did not find pod \" + podName + \" in namespace \" + namespace);\n     }\n+    return true;\n   }\n \n+  private void checkServerReadyStatusByExec(String podName, String namespace) {\n+    ExecResult execResult = assertDoesNotThrow(\n+        () -> execCommand(namespace, podName, null, true, READ_STATE_COMMAND));\n+    if (execResult.exitValue() == 0) {\n+      logger.info(\"execResult: \" + execResult);\n+      assertEquals(\"RUNNING\", execResult.stdout(),\n+          \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+    } else {\n+      fail(\"Ready command failed with exit status code: \" + execResult.exitValue());", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODQxNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420488415", "bodyText": "what pod? do you mean the namespace to create the utility pod in?", "author": "markxnelson", "createdAt": "2020-05-06T00:42:25Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -540,7 +540,8 @@ public static JsonObject createDockerConfigJson(String username, String password\n   /**\n    * Execute a command in a container.\n    *\n-   * @param pod The pod where the command is to be run\n+   * @param namespace The Kubernertes namespace that the pod is in", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMDk2Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421000962", "bodyText": "This is any Kubernetes pod that you would like to run a command using Kubernetes exec Java client API. In the test cases that we have, it is one of the WebLogic server pods.", "author": "doxiao", "createdAt": "2020-05-06T18:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODQxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwNzA0OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r426207049", "bodyText": "still has a spelling mistake", "author": "markxnelson", "createdAt": "2020-05-17T01:36:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODUxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420488514", "bodyText": "this implies the pod already exists, is that what you intended?", "author": "markxnelson", "createdAt": "2020-05-06T00:42:52Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -540,7 +540,8 @@ public static JsonObject createDockerConfigJson(String username, String password\n   /**\n    * Execute a command in a container.\n    *\n-   * @param pod The pod where the command is to be run\n+   * @param namespace The Kubernertes namespace that the pod is in\n+   * @param podName The name of the pod where the command is to be run", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODU4OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420488588", "bodyText": "magic value (null)", "author": "markxnelson", "createdAt": "2020-05-06T00:43:13Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -550,9 +551,19 @@ public static JsonObject createDockerConfigJson(String username, String password\n    * @throws ApiException if Kubernetes client API call fails\n    * @throws InterruptedException if any thread has interrupted the current thread\n    */\n-  public static ExecResult execCommand(V1Pod pod, String containerName, boolean redirectToStdout,\n-      String... command)\n-      throws IOException, ApiException, InterruptedException {\n+  public static ExecResult execCommand(\n+      String namespace,\n+      String podName,\n+      String containerName,\n+      boolean redirectToStdout,\n+      String... command\n+  ) throws IOException, ApiException, InterruptedException {\n+    final V1Pod pod = oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n+        .getPod(namespace, null, podName);", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMjM1NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421002354", "bodyText": "The null here means no label selector of the query. I added a command above the call.", "author": "doxiao", "createdAt": "2020-05-06T18:27:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODU4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODcyMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420488721", "bodyText": "space before and after colon", "author": "markxnelson", "createdAt": "2020-05-06T00:43:45Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/AppBuilder.java", "diffHunk": "@@ -52,22 +55,29 @@ private AppBuilder params(AppParams params) {\n   public boolean build() {\n     // prepare the archive directory and copy over the app src\n     try {\n-      cleanupDirectory(ARCHIVE_DIR);\n+      cleanupDirectory(ARCHIVE_SRC_DIR);\n       checkDirectory(ARCHIVE_SRC_DIR);\n-      copyFolder(\n-          APP_DIR + \"/\" + params.srcDir(), \n-          ARCHIVE_SRC_DIR);\n-    } catch (IOException ioe) {    \n-      logger.warning(\"Failed to get the directory \" + ARCHIVE_DIR + \" ready\");\n+      for (String item: params.srcDirList()) {", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMjUyNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421002526", "bodyText": "fixed", "author": "doxiao", "createdAt": "2020-05-06T18:27:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODgzNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420488837", "bodyText": "i don't think you can catch a runtime exception?", "author": "markxnelson", "createdAt": "2020-05-06T00:44:06Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/AppBuilder.java", "diffHunk": "@@ -52,22 +55,29 @@ private AppBuilder params(AppParams params) {\n   public boolean build() {\n     // prepare the archive directory and copy over the app src\n     try {\n-      cleanupDirectory(ARCHIVE_DIR);\n+      cleanupDirectory(ARCHIVE_SRC_DIR);\n       checkDirectory(ARCHIVE_SRC_DIR);\n-      copyFolder(\n-          APP_DIR + \"/\" + params.srcDir(), \n-          ARCHIVE_SRC_DIR);\n-    } catch (IOException ioe) {    \n-      logger.warning(\"Failed to get the directory \" + ARCHIVE_DIR + \" ready\");\n+      for (String item: params.srcDirList()) {\n+        copyFolder(\n+            APP_DIR + \"/\" + item, \n+            ARCHIVE_SRC_DIR);\n+      }\n+    } catch (IOException | RuntimeException e) {    ", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjA5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421086096", "bodyText": "fixed.", "author": "doxiao", "createdAt": "2020-05-06T20:55:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4ODk4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420488984", "bodyText": "are -> is", "author": "markxnelson", "createdAt": "2020-05-06T00:44:32Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/AppParams.java", "diffHunk": "@@ -3,30 +3,46 @@\n \n package oracle.weblogic.kubernetes.actions.impl;\n \n+import java.util.List;\n+\n /**\n  * Contains the parameters for creating an application archive.\n  */\n \n public class AppParams {\n \n-  // Location of the source code. \n-  // This is the name of the directory under resources/apps for an application\n-  private String srcDir;\n+  // A list of directories under resources/apps that are part of the application.\n+  // Note: the order of the directory names are significant. Files are copied into", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4OTAyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420489029", "bodyText": "what if it is a war?", "author": "markxnelson", "createdAt": "2020-05-06T00:44:46Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/AppParams.java", "diffHunk": "@@ -3,30 +3,46 @@\n \n package oracle.weblogic.kubernetes.actions.impl;\n \n+import java.util.List;\n+\n /**\n  * Contains the parameters for creating an application archive.\n  */\n \n public class AppParams {\n \n-  // Location of the source code. \n-  // This is the name of the directory under resources/apps for an application\n-  private String srcDir;\n+  // A list of directories under resources/apps that are part of the application.\n+  // Note: the order of the directory names are significant. Files are copied into\n+  // the staging directory in this order. \n+  private List<String> srcDirList;\n+  \n+  // The name of the final ear file.", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4OTE2Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420489166", "bodyText": "spelling", "author": "markxnelson", "createdAt": "2020-05-06T00:45:17Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Command.java", "diffHunk": "@@ -66,4 +69,38 @@ public boolean execute() {\n       return false;\n     }\n   }\n+  \n+  /**\n+   * Execute a command and verify the response.\n+   *\n+   * @params expectedResponse the expected response to verify", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4OTMwNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420489307", "bodyText": "this seems a bit weak", "author": "markxnelson", "createdAt": "2020-05-06T00:45:53Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Command.java", "diffHunk": "@@ -66,4 +69,38 @@ public boolean execute() {\n       return false;\n     }\n   }\n+  \n+  /**\n+   * Execute a command and verify the response.\n+   *\n+   * @params expectedResponse the expected response to verify\n+   * @return true if the execution succeeded and response contains the expected value\n+   */\n+  public boolean executeAndVerify(String expectedResponse) {\n+    if (params.verbose()) {\n+      logger.info(\"Executing command {0}\", params.command());\n+    }\n+    try {\n+      ExecResult result = ExecCommand.exec(", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4OTUxOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420489518", "bodyText": "this sounds like a problem", "author": "markxnelson", "createdAt": "2020-05-06T00:46:44Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1915,7 +1915,9 @@ public static ExecResult exec(V1Pod pod, String containerName, boolean redirectT\n \n       // wait for reading thread to finish any last remaining output\n       if (out != null) {\n-        out.join();\n+        // need to time out here, otherwise the command can take almost one minute to return.", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMzg4OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421003888", "bodyText": "Lenny has looked into this. I would not be surprised if we hit an issue in Kubernetes here.", "author": "doxiao", "createdAt": "2020-05-06T18:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4OTUxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgzODk0Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r425838943", "bodyText": "This is related to a Kubernetes Java client issue tracked by  kubernetes-client/java#933. The problem was fixed about two weeks ago, but is yet to be included in a release.", "author": "doxiao", "createdAt": "2020-05-15T14:26:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4OTUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5MDE5OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420490199", "bodyText": "i am not understand why we want to check inside the pod, rather than from outside... maybe i am  missing something", "author": "markxnelson", "createdAt": "2020-05-06T00:49:32Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -186,6 +223,68 @@ public static boolean dockerImageExists(String imageName, String imageTag) {\n     return WitAssertion.doesImageExist(imageName, imageTag);\n   }\n \n+  /**\n+   * Check if an application is accessible inside a WebLogic server pod using", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNjMwNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421006306", "bodyText": "The goal is to make sure that all pods are patched correctly. There is probably a better approach but this is what I came up with. Note that we don't want to rely on a LB and managed servers don't have a NodePort.", "author": "doxiao", "createdAt": "2020-05-06T18:33:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5MDE5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMjM2MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420502361", "bodyText": "is supposed to use -> is expected to be using", "author": "markxnelson", "createdAt": "2020-05-06T01:39:44Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Domain.java", "diffHunk": "@@ -77,6 +77,35 @@ public static boolean doesCrdExist() throws ApiException {\n     };\n   }\n \n+  /**\n+   * Check if the domain resource has been patched with a new image.\n+   *\n+   * @param domainUID identifier of the domain resource\n+   * @param namespace Kubernetes namespace in which the domain exists\n+   * @param image name of the image that the pod is supposed to use", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMjk0OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420502949", "bodyText": "we should probably make the container an optional param, pods can have more than one container, and probably will in some tests, e.g. when we have a fluentd sidecar.  if the pod has only one container, it is obvious which one to use.", "author": "markxnelson", "createdAt": "2020-05-06T01:42:28Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -146,6 +147,41 @@ public static boolean isPodTerminating(String namespace, String domainUid, Strin\n     return status;\n   }\n \n+  /**\n+   * Checks if a WebLogic server pod has been patched with an expected image.\n+   *\n+   * @param namespace Kubernetes namespace in which the pod is running\n+   * @param domainUid label that the pod is decorated with\n+   * @param podName name of the WebLogic server pod\n+   * @param image name of the image to check for\n+   * @return true if pod's image has been patched\n+   * @throws ApiException when there is an error in querying the Kubernetes cluster\n+   */\n+  public static boolean podImagePatched(", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNjc5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421006793", "bodyText": "Good point. I added the containerName.", "author": "doxiao", "createdAt": "2020-05-06T18:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMjk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMzE0MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420503141", "bodyText": "spelling", "author": "markxnelson", "createdAt": "2020-05-06T01:43:21Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -146,6 +147,41 @@ public static boolean isPodTerminating(String namespace, String domainUid, Strin\n     return status;\n   }\n \n+  /**\n+   * Checks if a WebLogic server pod has been patched with an expected image.\n+   *\n+   * @param namespace Kubernetes namespace in which the pod is running\n+   * @param domainUid label that the pod is decorated with\n+   * @param podName name of the WebLogic server pod\n+   * @param image name of the image to check for\n+   * @return true if pod's image has been patched\n+   * @throws ApiException when there is an error in querying the Kubernetes cluster\n+   */\n+  public static boolean podImagePatched(\n+      String namespace,\n+      String domainUid,\n+      String podName,\n+      String image\n+  ) throws ApiException {\n+    boolean podPatched = false;\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    if (pod != null && pod.getSpec() != null) {\n+      List<V1Container> containers = pod.getSpec().getContainers();\n+      for (V1Container container : containers) {\n+        // look for the weblogic server container", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAxNTU4MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421015580", "bodyText": "fixed", "author": "doxiao", "createdAt": "2020-05-06T18:49:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMzE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMzI1NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420503254", "bodyText": "do we need a null check on containers?", "author": "markxnelson", "createdAt": "2020-05-06T01:43:48Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -146,6 +147,41 @@ public static boolean isPodTerminating(String namespace, String domainUid, Strin\n     return status;\n   }\n \n+  /**\n+   * Checks if a WebLogic server pod has been patched with an expected image.\n+   *\n+   * @param namespace Kubernetes namespace in which the pod is running\n+   * @param domainUid label that the pod is decorated with\n+   * @param podName name of the WebLogic server pod\n+   * @param image name of the image to check for\n+   * @return true if pod's image has been patched\n+   * @throws ApiException when there is an error in querying the Kubernetes cluster\n+   */\n+  public static boolean podImagePatched(\n+      String namespace,\n+      String domainUid,\n+      String podName,\n+      String image\n+  ) throws ApiException {\n+    boolean podPatched = false;\n+    String labelSelector = null;\n+    if (domainUid != null) {\n+      labelSelector = String.format(\"weblogic.domainUID in (%s)\", domainUid);\n+    }\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    if (pod != null && pod.getSpec() != null) {\n+      List<V1Container> containers = pod.getSpec().getContainers();", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNzM3Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421007377", "bodyText": "As far as I can tell, if there is no container, we'll get an empty list.", "author": "doxiao", "createdAt": "2020-05-06T18:35:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMzI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMzM3Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420503372", "bodyText": "space after colon, not before", "author": "markxnelson", "createdAt": "2020-05-06T01:44:16Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -198,10 +234,11 @@ public static V1Pod getPod(String namespace, String labelSelector, String podNam\n         );\n     for (V1Pod item : v1PodList.getItems()) {\n       if (item.getMetadata().getName().startsWith(podName.trim())) {\n-        logger.info(\"Pod Name: \" + item.getMetadata().getName());\n-        logger.info(\"Pod Namespace: \" + item.getMetadata().getNamespace());\n-        logger.info(\"Pod UID: \" + item.getMetadata().getUid());\n-        logger.info(\"Pod Status: \" + item.getStatus().getPhase());\n+        logger.fine(String.format(\"Pod Name :%s, Pod Namespace :%s, Pod UID :%s, Pod Status :%s\",", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAxNTY3MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421015670", "bodyText": "fixed", "author": "doxiao", "createdAt": "2020-05-06T18:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMzM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMzQ1OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420503459", "bodyText": "directory", "author": "markxnelson", "createdAt": "2020-05-06T01:44:37Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/FileUtils.java", "diffHunk": "@@ -31,7 +35,7 @@ public static void checkDirectory(String dir) {\n     File file = new File(dir);\n     if (!(file.exists() && file.isDirectory())) {\n       file.mkdirs();\n-      logger.info(\"Made a new dir \" + dir);\n+      logger.fine(\"Made a new dir {0}.\", dir);", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAxNTc2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421015764", "bodyText": "fixed", "author": "doxiao", "createdAt": "2020-05-06T18:49:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMzQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMzUxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r420503514", "bodyText": "to where?", "author": "markxnelson", "createdAt": "2020-05-06T01:44:50Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/FileUtils.java", "diffHunk": "@@ -98,6 +102,7 @@ public static void copyFolder(String srcDir, String destDir) throws IOException\n         try {\n           copy(source, destPath.resolve(srcPath.relativize(source)));\n         } catch (IOException e) {\n+          logger.severe(String.format(\"Failed to copy file %s\", source), e);", "originalCommit": "f1c30255fa251e2db6646acc4c8af541102ca1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAxNTg0NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r421015845", "bodyText": "fixed", "author": "doxiao", "createdAt": "2020-05-06T18:49:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMzUxNA=="}], "type": "inlineReview"}, {"oid": "d735a7e0e268ec0ecfabf6c4e6e0a889e50b8757", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d735a7e0e268ec0ecfabf6c4e6e0a889e50b8757", "message": "Address review comments", "committedDate": "2020-05-06T18:17:39Z", "type": "commit"}, {"oid": "072aa1f16708bf5c6b7b8cf7d980b5cfce9c7760", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/072aa1f16708bf5c6b7b8cf7d980b5cfce9c7760", "message": "Address one more comment", "committedDate": "2020-05-06T19:21:56Z", "type": "commit"}, {"oid": "3003cd59b6cd0a216ea31f5ddf8775368dbd2be6", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3003cd59b6cd0a216ea31f5ddf8775368dbd2be6", "message": "Minor fix", "committedDate": "2020-05-06T20:41:24Z", "type": "commit"}, {"oid": "d67a4a9473bde201f727a873158bbea6a3ddda6b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d67a4a9473bde201f727a873158bbea6a3ddda6b", "message": "More logging", "committedDate": "2020-05-06T22:03:48Z", "type": "commit"}, {"oid": "745f8831775d3549bc842e5599bf5a9829106026", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/745f8831775d3549bc842e5599bf5a9829106026", "message": "Minor comment update", "committedDate": "2020-05-08T16:46:37Z", "type": "commit"}, {"oid": "b5c3a0d0c4df62015eaeca7df87106a9c18a051d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b5c3a0d0c4df62015eaeca7df87106a9c18a051d", "message": "Make log messages more informative", "committedDate": "2020-05-08T17:57:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMxODAyNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r422318027", "bodyText": "I think we want to clean up the directory once before all tests run. This can be moved to ImageBuilders.beforeAll()?", "author": "vanajamukkara", "createdAt": "2020-05-08T19:03:53Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -136,7 +155,20 @@ public static void initAll(@Namespaces(3) List<String> namespaces) {\n     // create standard, reusable retry/backoff policy\n     withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n         .and().with().pollInterval(10, SECONDS)\n-        .atMost(5, MINUTES).await();\n+        .atMost(6, MINUTES).await();\n+\n+    // create a reusable quick retry policy\n+    withQuickRetryPolicy = with().pollDelay(0, SECONDS)\n+        .and().with().pollInterval(4, SECONDS)\n+        .atMost(10, SECONDS).await();\n+\n+    // clean up the download directory so that we always get the latest\n+    // versions of the tools in every run of the test class.\n+    try {\n+      cleanupDirectory(DOWNLOAD_DIR);", "originalCommit": "b5c3a0d0c4df62015eaeca7df87106a9c18a051d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM4MDkxMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r422380910", "bodyText": "Moved. Thanks.", "author": "doxiao", "createdAt": "2020-05-08T21:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMxODAyNw=="}], "type": "inlineReview"}, {"oid": "ea8c9552404cb16479feabe225717430958e2f0a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ea8c9552404cb16479feabe225717430958e2f0a", "message": "Address a new review comment", "committedDate": "2020-05-08T21:18:14Z", "type": "commit"}, {"oid": "a8bded1674fb806172e05fea998111132570e6d5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a8bded1674fb806172e05fea998111132570e6d5", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "committedDate": "2020-05-08T21:49:30Z", "type": "commit"}, {"oid": "0e3f2412b84b59e609631183d56e7add5b966bef", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/0e3f2412b84b59e609631183d56e7add5b966bef", "message": "Fix a minor merge error", "committedDate": "2020-05-08T22:01:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI5MTUxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r423291514", "bodyText": "action methods in TestActions.java should be calling other impl methods, no actual implementation should be here I think ..This may be moved to Kubernetes.java prim?", "author": "vanajamukkara", "createdAt": "2020-05-11T20:13:20Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -588,9 +589,21 @@ public static JsonObject createDockerConfigJson(String username, String password\n    * @throws ApiException if Kubernetes client API call fails\n    * @throws InterruptedException if any thread has interrupted the current thread\n    */\n-  public static ExecResult execCommand(V1Pod pod, String containerName, boolean redirectToStdout,\n-      String... command)\n-      throws IOException, ApiException, InterruptedException {\n+  public static ExecResult execCommand(\n+      String namespace,\n+      String podName,\n+      String containerName,\n+      boolean redirectToStdout,\n+      String... command\n+  ) throws IOException, ApiException, InterruptedException {\n+    // get the pod given the namespace and name of the pod\n+    // no label selector is needed (thus null below)\n+    final V1Pod pod = oracle.weblogic.kubernetes.assertions.impl.Kubernetes", "originalCommit": "0e3f2412b84b59e609631183d56e7add5b966bef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM4Njc2OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r423386769", "bodyText": "Moved the method to actions impl.", "author": "doxiao", "createdAt": "2020-05-12T00:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI5MTUxNA=="}], "type": "inlineReview"}, {"oid": "8a146531f22e0d9b6d8f92f7d40c04a262d810d6", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8a146531f22e0d9b6d8f92f7d40c04a262d810d6", "message": "Address more review comments", "committedDate": "2020-05-11T23:57:38Z", "type": "commit"}, {"oid": "24f2579dd20243a773b3b44107772629f34a5de9", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/24f2579dd20243a773b3b44107772629f34a5de9", "message": "Update javadoc", "committedDate": "2020-05-12T00:07:42Z", "type": "commit"}, {"oid": "34d51a17b29308277775f55c8b625e111fbe813f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/34d51a17b29308277775f55c8b625e111fbe813f", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Domain.java", "committedDate": "2020-05-12T15:40:03Z", "type": "commit"}, {"oid": "c352f594a296e8685d9ac8aff883e216ec096101", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c352f594a296e8685d9ac8aff883e216ec096101", "message": "Fix merge issues", "committedDate": "2020-05-12T15:51:15Z", "type": "commit"}, {"oid": "6b2d51d4107d0e54366635b411646fdcd9e04d64", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6b2d51d4107d0e54366635b411646fdcd9e04d64", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/extensions/ImageBuilders.java", "committedDate": "2020-05-12T18:55:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxNzM0OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r424017349", "bodyText": "This is what is breaking your test. You need to add REPO_NAME all of the time.", "author": "rjeberhard", "createdAt": "2020-05-12T20:35:46Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -494,6 +738,189 @@ void tearDown() {\n     assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace1),\n             \"deleteDomainCustomResource failed with ApiException\");\n     logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace1);\n+\n+    // delete the domain images created in the test class\n+    if (miiImagePatchAppV2 != null) {\n+      deleteImage(miiImagePatchAppV2);\n+    }\n+    if (miiImageAddSecondApp != null) {\n+      deleteImage(miiImageAddSecondApp);\n+    }\n+  }\n+\n+  private void pushImageIfNeeded(String image) {\n+    // push the image to a registry to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login to registry {0}\", REPO_REGISTRY);\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to registry {1}\", image, REPO_REGISTRY);\n+      assertTrue(dockerPush(image), String.format(\"docker push failed for image %s\", image));\n+    }\n+  }\n+\n+  private String createUniqueImageTag() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    return dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+  }\n+\n+  private String createImageName(String baseImageName) {\n+    // Add repository name in image name for Jenkins runs\n+    return REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? baseImageName : REPO_NAME + baseImageName;", "originalCommit": "6b2d51d4107d0e54366635b411646fdcd9e04d64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxNzY1OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r424017658", "bodyText": "REPO_NAME will be empty when no push is required.  It is no longer tied to whether or not REPO_USERNAME is set.", "author": "rjeberhard", "createdAt": "2020-05-12T20:36:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxNzM0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAzNzIxNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r424037216", "bodyText": "fixed.", "author": "doxiao", "createdAt": "2020-05-12T21:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxNzM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxNzkzNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r424017936", "bodyText": "This is broken too.", "author": "rjeberhard", "createdAt": "2020-05-12T20:36:54Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -494,6 +738,189 @@ void tearDown() {\n     assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace1),\n             \"deleteDomainCustomResource failed with ApiException\");\n     logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace1);\n+\n+    // delete the domain images created in the test class\n+    if (miiImagePatchAppV2 != null) {\n+      deleteImage(miiImagePatchAppV2);\n+    }\n+    if (miiImageAddSecondApp != null) {\n+      deleteImage(miiImageAddSecondApp);\n+    }\n+  }\n+\n+  private void pushImageIfNeeded(String image) {\n+    // push the image to a registry to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {", "originalCommit": "6b2d51d4107d0e54366635b411646fdcd9e04d64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxODM0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r424018348", "bodyText": "You should login if REPO_USERNAME is set (to a non-dummy value), but you should push if REPO_NAME is non-empty. (Look at the code in other tests)", "author": "rjeberhard", "createdAt": "2020-05-12T20:37:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxNzkzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAzNzI0NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r424037245", "bodyText": "fixed.", "author": "doxiao", "createdAt": "2020-05-12T21:13:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAxNzkzNg=="}], "type": "inlineReview"}, {"oid": "3b4da2f19a4e6235f141dd77f3268f2a1d5c5f50", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3b4da2f19a4e6235f141dd77f3268f2a1d5c5f50", "message": "Update the push image code to check REPO_NAME", "committedDate": "2020-05-12T21:08:54Z", "type": "commit"}, {"oid": "294decc6e04c463406ddafbdb92ea0f3561ef917", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/294decc6e04c463406ddafbdb92ea0f3561ef917", "message": "remove double adding REMO_NAME", "committedDate": "2020-05-12T21:51:36Z", "type": "commit"}, {"oid": "70fbeb1b8ef8598db5aa0d36ed05c651864c24b5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/70fbeb1b8ef8598db5aa0d36ed05c651864c24b5", "message": "Change baseImageName to image Name", "committedDate": "2020-05-12T22:02:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4NTY4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r424585689", "bodyText": "I think the new tests in this PR should be added in a new or other existing It class where the domain creation/existence is a prerequisite, then you don't need to order the tests. Here it is assumed that the domain is up and running by ordering the tests where it should have been verified in beforeEach method. This is a late comment in this PR. If everyone agrees, changes can be made in another PR.", "author": "vanajamukkara", "createdAt": "2020-05-13T16:49:46Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiDomain.java", "diffHunk": "@@ -473,12 +525,204 @@ public void testCreateMiiDomainSameDomainUidDiffNS() {\n     }\n   }\n \n+  @Test\n+  @Order(4)\n+  @DisplayName(\"Update the sample-app application to version 2\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testPatchAppV2() {", "originalCommit": "70fbeb1b8ef8598db5aa0d36ed05c651864c24b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwNDk2Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r424704966", "bodyText": "Thanks, and yes, I would prefer address this comment in a different PR.\nI still need to understand how to maintain expected order among different test methods without using @order annotation, or between different test classes.", "author": "doxiao", "createdAt": "2020-05-13T20:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4NTY4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc2MDM4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1616#discussion_r424760384", "bodyText": "In order for the patching test cases to be fully independent, we need to do three things:\n\nMove those test methods into a different test class;\nCreate a new initial domain in the BeforeAll handler of the new class; instead of using the domain that is created in the first end-to-end test case;\nAt the end of each test case,  rollback what we have done in the method so that the domain goes back to the initial state, to make the state predictable for the next test case.\n\nBoth 2) and 3) will increase the total time of the test suite run, which is what the current approach tries to avoid.", "author": "doxiao", "createdAt": "2020-05-13T22:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4NTY4OQ=="}], "type": "inlineReview"}, {"oid": "034a9b740bcb9cca6fab6ede2ecb1f609c225d1a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/034a9b740bcb9cca6fab6ede2ecb1f609c225d1a", "message": "Merge remote-tracking branch 'origin/develop' into mii-app-patching-test\n\nConflicts:\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/TestConstants.java\n\tnew-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "committedDate": "2020-05-14T15:51:24Z", "type": "commit"}, {"oid": "d37858e2048e93323bdd4904f6ac6e25eda7dd78", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d37858e2048e93323bdd4904f6ac6e25eda7dd78", "message": "Fix a typo", "committedDate": "2020-05-17T13:31:13Z", "type": "commit"}]}