{"pr_number": 1632, "pr_title": "Scaledomain mii new it", "pr_createdAt": "2020-05-07T22:08:03Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632", "timeline": [{"oid": "c0b211e7d11b55a7648455eb686ccc22e6f7cfd3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c0b211e7d11b55a7648455eb686ccc22e6f7cfd3", "message": "init commit", "committedDate": "2020-04-30T19:23:02Z", "type": "commit"}, {"oid": "798190a169b2642a7e6956a1b7a32f7c4d18cadf", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/798190a169b2642a7e6956a1b7a32f7c4d18cadf", "message": "use kubernetes API call to create ingress", "committedDate": "2020-05-01T00:41:12Z", "type": "commit"}, {"oid": "a4b6be698ed3b1a4375a6929c4f54c1ee6534b29", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a4b6be698ed3b1a4375a6929c4f54c1ee6534b29", "message": "add more debug info for Jenkins run", "committedDate": "2020-05-01T02:42:22Z", "type": "commit"}, {"oid": "e3cfb8afecdafe4c195118d86de5864f0da29423", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e3cfb8afecdafe4c195118d86de5864f0da29423", "message": "add more debug info for Jenkins run", "committedDate": "2020-05-01T03:29:28Z", "type": "commit"}, {"oid": "7519ca6318020e4eeb38f78ffd2b8d4251699f1d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7519ca6318020e4eeb38f78ffd2b8d4251699f1d", "message": "add more debug info for Jenkins run", "committedDate": "2020-05-01T04:37:27Z", "type": "commit"}, {"oid": "f37427de2d32e226281b523390ebb00868899a9a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f37427de2d32e226281b523390ebb00868899a9a", "message": "remove debug info for Jenkins run", "committedDate": "2020-05-01T04:51:05Z", "type": "commit"}, {"oid": "da9beaf5c9521389e5a7a6dcbf7f53966fceb3a8", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/da9beaf5c9521389e5a7a6dcbf7f53966fceb3a8", "message": "remove unused imports", "committedDate": "2020-05-01T04:54:16Z", "type": "commit"}, {"oid": "b3e427413bd0728b09fe2c9b5b2842fc18b601f7", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b3e427413bd0728b09fe2c9b5b2842fc18b601f7", "message": "get the latest from develop", "committedDate": "2020-05-01T19:48:23Z", "type": "commit"}, {"oid": "368bcaac348b6480b459c6f551b4402e194f4ac7", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/368bcaac348b6480b459c6f551b4402e194f4ac7", "message": "get Sankar's cleanup", "committedDate": "2020-05-01T23:13:28Z", "type": "commit"}, {"oid": "7b0d9509c3b703f372e6a5f144b9c165f37ccda1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7b0d9509c3b703f372e6a5f144b9c165f37ccda1", "message": "uninstall nginx release for now", "committedDate": "2020-05-02T00:42:48Z", "type": "commit"}, {"oid": "a26c9c9234718a80290ec90b096ec7f431ab0ee3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a26c9c9234718a80290ec90b096ec7f431ab0ee3", "message": "cleanup", "committedDate": "2020-05-02T05:58:58Z", "type": "commit"}, {"oid": "c6f852bd850a0aebad562c74fa48926f1990f2e7", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c6f852bd850a0aebad562c74fa48926f1990f2e7", "message": "more cleanup", "committedDate": "2020-05-02T12:50:46Z", "type": "commit"}, {"oid": "ff1e03c6f071ae1cafc8be81d1c541f869a1cc61", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ff1e03c6f071ae1cafc8be81d1c541f869a1cc61", "message": "cleanup", "committedDate": "2020-05-02T16:31:26Z", "type": "commit"}, {"oid": "5a4081a631da47b1284071854dd3be78d59bc803", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5a4081a631da47b1284071854dd3be78d59bc803", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into nginx-mii-new-it", "committedDate": "2020-05-04T16:43:15Z", "type": "commit"}, {"oid": "49296720511157a50acf208989f17ff93bf72e7a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/49296720511157a50acf208989f17ff93bf72e7a", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into nginx-mii-new-it", "committedDate": "2020-05-04T23:16:37Z", "type": "commit"}, {"oid": "a98473022acae51989e3359fb3825f92518e2103", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a98473022acae51989e3359fb3825f92518e2103", "message": "change DynamicClusterSize in sample wdt model file", "committedDate": "2020-05-05T01:51:39Z", "type": "commit"}, {"oid": "f50a12f69873649ac2ea50d54fbb00672a7b99f9", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f50a12f69873649ac2ea50d54fbb00672a7b99f9", "message": "Merge branch 'develop' into nginx-mii-new-it", "committedDate": "2020-05-05T18:50:53Z", "type": "commit"}, {"oid": "486b8376d245f54aa72cbf060ef52f01b4ccde15", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/486b8376d245f54aa72cbf060ef52f01b4ccde15", "message": "get the latest develop", "committedDate": "2020-05-05T19:23:50Z", "type": "commit"}, {"oid": "cc20393a31e9d2d59f2f4c62b6a7d5968d337d6a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cc20393a31e9d2d59f2f4c62b6a7d5968d337d6a", "message": "Merge branch 'nginx-mii-new-it' of https://github.com/oracle/weblogic-kubernetes-operator into nginx-mii-new-it", "committedDate": "2020-05-05T19:24:11Z", "type": "commit"}, {"oid": "f5f282cd562de543c51e96ea752d103e2ead5f1a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f5f282cd562de543c51e96ea752d103e2ead5f1a", "message": "resolve merge conflicts", "committedDate": "2020-05-05T20:03:25Z", "type": "commit"}, {"oid": "cddf64607dee4a8bab0d4197ecd16eacccd846bb", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cddf64607dee4a8bab0d4197ecd16eacccd846bb", "message": "get the latest from develop and nginx-mii-new-it, add scale domain method", "committedDate": "2020-05-06T00:33:49Z", "type": "commit"}, {"oid": "500776983799240851f663a5f4f685969c7e76be", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/500776983799240851f663a5f4f685969c7e76be", "message": "fix with Mark's comments", "committedDate": "2020-05-06T05:07:14Z", "type": "commit"}, {"oid": "e5fe4ceb771e163191cf61faa674998a9748afde", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e5fe4ceb771e163191cf61faa674998a9748afde", "message": "get the latest from develop and origin/nginx-mii-new-it", "committedDate": "2020-05-06T16:10:54Z", "type": "commit"}, {"oid": "047bc90d6b9ab3a6df97ee390725b618199458d1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/047bc90d6b9ab3a6df97ee390725b618199458d1", "message": "scale domain with multiple clusters", "committedDate": "2020-05-07T02:24:44Z", "type": "commit"}, {"oid": "4bdc4117e01b75f1befb8102d912a174b22dcb6b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4bdc4117e01b75f1befb8102d912a174b22dcb6b", "message": "get the latest from develop", "committedDate": "2020-05-07T04:44:49Z", "type": "commit"}, {"oid": "96da16fa25b8e5e1e7f9bf2fbc8b80deb07bf637", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/96da16fa25b8e5e1e7f9bf2fbc8b80deb07bf637", "message": "cleanup", "committedDate": "2020-05-07T05:12:58Z", "type": "commit"}, {"oid": "eb9867384276e24de921de2f6674e19713e55dfe", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/eb9867384276e24de921de2f6674e19713e55dfe", "message": "change number of clusters in domain to 2", "committedDate": "2020-05-07T17:37:58Z", "type": "commit"}, {"oid": "b8c11221b4e017f1c53a90eeecc7dd3e23f6c3fa", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b8c11221b4e017f1c53a90eeecc7dd3e23f6c3fa", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into scaledomain-mii-new-it", "committedDate": "2020-05-07T17:38:59Z", "type": "commit"}, {"oid": "f7c3802d0955106ff2465c332f0a1ae63afe0c57", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f7c3802d0955106ff2465c332f0a1ae63afe0c57", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into scaledomain-mii-new-it", "committedDate": "2020-05-07T19:31:47Z", "type": "commit"}, {"oid": "6f0ab77ab1515a1aae20fefe1c2272b9fe55c5cb", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6f0ab77ab1515a1aae20fefe1c2272b9fe55c5cb", "message": "cleanup", "committedDate": "2020-05-07T22:03:44Z", "type": "commit"}, {"oid": "8fd7ae1262d33d59bd584f51db15d4430a0fd2b4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8fd7ae1262d33d59bd584f51db15d4430a0fd2b4", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into scaledomain-mii-new-it", "committedDate": "2020-05-07T22:04:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgyNTI1Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r421825256", "bodyText": "IMO this kind of randomness belongs more in a stress test than in most QA tests....  Is this randomness deliberate? It means repeatability between test runs is gone - requiring a change to the test source code to make it repeatable when debugging.", "author": "tbarnes-us", "createdAt": "2020-05-07T22:13:53Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -290,76 +303,115 @@ public void testCreateMiiDomain() {\n         adminServerPodName, domainNamespace);\n     checkPodCreated(adminServerPodName);\n \n-    // check managed server pods exists\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodCreated(managedServerPrefix + i);\n-    }\n-\n     // check admin server pod is ready\n     logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkPodReady(adminServerPodName);\n \n-    // check managed server pods are ready\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodReady(managedServerPrefix + i);\n-    }\n-\n+    // check admin service is created\n     logger.info(\"Check admin service {0} is created in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkServiceCreated(adminServerPodName);\n \n-    // check managed server services created\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkServiceCreated(managedServerPrefix + i);\n+    // check the readiness for the managed servers in each cluster\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName =\n+            domainUid + \"-\" + CLUSTER_NAME_PREFIX + i + managedServerNameBase + j;\n+\n+        // check managed server pod is created\n+        logger.info(\"Check for managed server pod {0} is created in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodCreated(managedServerPodName);\n+\n+        // check managed server pod is ready\n+        logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodReady(managedServerPodName);\n+\n+        // check managed server service is created\n+        logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkServiceCreated(managedServerPodName);\n+      }\n     }\n   }\n \n   @Test\n   @Order(2)\n-  @DisplayName(\"Create an ingress for a WebLogic domain in the specified domain namespace\")\n+  @DisplayName(\"Create an ingress for each cluster of the WebLogic domain in the specified domain namespace\")\n   public void testCreateIngress() {\n \n-    // create an ingress in domain namespace\n-    assertThat(assertDoesNotThrow(() -> createIngress(domainNamespace, domainUid, clusterName, managedServerPort)))\n-            .as(\"createIngress succeeds\")\n-            .withFailMessage(String.format(\"failed to create an ingress for domain %s in namespace %s\",\n-                domainUid, domainNamespace))\n-            .isTrue();\n-\n-    // check the ingress is created\n-    String ingressName = domainUid + \"-nginx\";\n-    assertThat(assertDoesNotThrow(() -> getIngressList(domainNamespace)))\n-        .as(String.format(\"found the ingress %s in namespace %s\", ingressName, domainNamespace))\n-        .withFailMessage(String.format(\"can not find ingress %s in namespace %s\", ingressName, domainNamespace))\n-        .contains(ingressName);\n-\n-    logger.info(\"ingress is created in namespace {0}\", domainNamespace);\n+    // create an ingress for each cluster of the domain in the domain namespace\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+\n+      String clusterName = CLUSTER_NAME_PREFIX + i;\n+      String ingressName = domainUid + \"-\" + clusterName + \"-nginx\";\n+\n+      logger.info(\"Creating ingress {0} for cluster {1} of domain {2} in namespace {3}\",\n+          ingressName, clusterName, domainUid, domainNamespace);\n+      assertThat(createIngress(ingressName, domainNamespace, domainUid, clusterName,\n+          MANAGED_SERVER_PORT, domainUid + \".\" + clusterName + \".test\"))\n+          .as(\"Test createIngress succeeds\")\n+          .withFailMessage(String.format(\"failed to create an ingress for cluster %s of domain %s in namespace %s\",\n+              clusterName, domainUid, domainNamespace))\n+          .isTrue();\n+\n+      // check the ingress is created\n+      assertThat(assertDoesNotThrow(() -> getIngressList(domainNamespace)))\n+          .as(String.format(\"Test the ingress %s is created in namespace %s\", ingressName, domainNamespace))\n+          .withFailMessage(String.format(\"can not find ingress %s in namespace %s\", ingressName, domainNamespace))\n+          .contains(ingressName);\n+\n+      logger.info(\"ingress {0} for cluster {1} of domain {2} is created in namespace {3}\",\n+          ingressName, clusterName, domainUid, domainNamespace);\n+    }\n   }\n \n   @Test\n   @Order(3)\n-  @DisplayName(\"Verify the application can be accessed through the ingress controller\")\n+  @DisplayName(\"Verify the application can be accessed through the ingress controller for each cluster in the domain\")\n   public void testSampleAppThroughIngressController() {\n \n-    List<String> managedServerNames = new ArrayList<>();\n-    for (int i = 1; i <= replicaCount; i++) {\n-      managedServerNames.add(managedServerNameBase + i);\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+      String clusterName = CLUSTER_NAME_PREFIX + i;\n+\n+      expectedServerNamesInAppResponse.clear();\n+      for (int j = 1; j <= replicaCount; j++) {\n+        expectedServerNamesInAppResponse.add(clusterName + managedServerNameBase + j);\n+      }\n+\n+      // check that NGINX can access the sample apps from all managed servers in the cluster of the domain\n+      curlCmd = getCurlCmd(clusterName);\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"verify NGINX can access the sample app from all managed servers in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n+          .isTrue();\n     }\n+  }\n \n-    // check that NGINX can access the sample apps from all managed servers in the domain\n-    String curlCmd = String.format(\"curl --silent --noproxy '*' -H 'host: %s' http://%s:%s/sample-war/index.jsp\",\n-        domainUid + \".test\", K8S_NODEPORT_HOST, nodeportshttp);\n-    assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, managedServerNames, 50))\n-        .as(\"NGINX can access the sample app from all managed servers in the domain\")\n-        .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n-        .isTrue();\n+  @Test\n+  @Order(4)\n+  @DisplayName(\"Verify scale domain with domainUid with multiple clusters in domainNamespace\")\n+  public void testScaleDomainWithMultiClusters() {\n+\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+      String clusterName = CLUSTER_NAME_PREFIX + i;\n+\n+      // set the expected server name list which should return by the app response before scale\n+      expectedServerNamesInAppResponse.clear();\n+      for (int j = 1; j <= replicaCount; j++) {\n+        expectedServerNamesInAppResponse.add(clusterName + managedServerNameBase + j);\n+      }\n+      logger.info(\"expected server name list which should be in the sample app response: {0} before scale\",\n+          expectedServerNamesInAppResponse);\n+\n+      // get a random integer between [0 - 5]\n+      int numberOfServers = new Random().nextInt(6);\n+      logger.info(\"scaling the cluster {0} of domain {1} in namespace {2} to {3} servers\",\n+          clusterName, domainUid, domainNamespace, numberOfServers);", "originalCommit": "8fd7ae1262d33d59bd584f51db15d4430a0fd2b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgyNjEyMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r421826123", "bodyText": "Also, 5 servers seems like a lot on the surface for this kind of test - it potentially slows the test down forever more, particularly on systems that might not have enough CPU/memory to handle that many servers quickly.", "author": "tbarnes-us", "createdAt": "2020-05-07T22:15:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgyNTI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkzMDY0NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r421930645", "bodyText": "You are right. Changed the logic a little bit.", "author": "xiancao", "createdAt": "2020-05-08T04:27:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgyNTI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEzMzU3Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422133576", "bodyText": "LGTM", "author": "tbarnes-us", "createdAt": "2020-05-08T13:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgyNTI1Ng=="}], "type": "inlineReview"}, {"oid": "65a92ef8f1d35219d1364e47f8563ebd342a2d1d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/65a92ef8f1d35219d1364e47f8563ebd342a2d1d", "message": "fix with Tom's comments", "committedDate": "2020-05-08T03:23:48Z", "type": "commit"}, {"oid": "b41741b757bc12c2ed4fae3edaa5bef47d2c019a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b41741b757bc12c2ed4fae3edaa5bef47d2c019a", "message": "get the latest develop", "committedDate": "2020-05-08T03:25:52Z", "type": "commit"}, {"oid": "ae35744a863fab02f14e859110aeb3e4bddd4db8", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ae35744a863fab02f14e859110aeb3e4bddd4db8", "message": "clean javadoc", "committedDate": "2020-05-08T04:20:37Z", "type": "commit"}, {"oid": "00c706e910866be14ae1901555db748a6c955fb2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/00c706e910866be14ae1901555db748a6c955fb2", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into scaledomain-mii-new-it", "committedDate": "2020-05-08T15:42:11Z", "type": "commit"}, {"oid": "35c875933e97df8c643dbc6d314d70f8b61430ee", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/35c875933e97df8c643dbc6d314d70f8b61430ee", "message": "javadoc cleanup", "committedDate": "2020-05-08T16:28:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIyMzk4OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422223988", "bodyText": "can we change this file name to something that tells which test is using it ?", "author": "sankarpn", "createdAt": "2020-05-08T15:56:17Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -107,28 +109,30 @@\n class ItSimpleNginxValidation implements LoggedTest {\n \n   // mii constants\n-  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String WDT_MODEL_FILE = \"model2-wls.yaml\";", "originalCommit": "ae35744a863fab02f14e859110aeb3e4bddd4db8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyODI1Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422428252", "bodyText": "that's a great idea!", "author": "markxnelson", "createdAt": "2020-05-09T00:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIyMzk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5ODI5OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422498299", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T13:50:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIyMzk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMyNzE3NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422327174", "bodyText": "Creating Ingress {0} for cluster {1} succeeded.", "author": "sankarpn", "createdAt": "2020-05-08T19:22:33Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -293,76 +304,110 @@ public void testCreateMiiDomain() {\n         adminServerPodName, domainNamespace);\n     checkPodCreated(adminServerPodName);\n \n-    // check managed server pods exists\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodCreated(managedServerPrefix + i);\n-    }\n-\n     // check admin server pod is ready\n     logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkPodReady(adminServerPodName);\n \n-    // check managed server pods are ready\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodReady(managedServerPrefix + i);\n-    }\n-\n+    // check admin service is created\n     logger.info(\"Check admin service {0} is created in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkServiceCreated(adminServerPodName);\n \n-    // check managed server services created\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkServiceCreated(managedServerPrefix + i);\n+    // check the readiness for the managed servers in each cluster\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName =\n+            domainUid + \"-\" + CLUSTER_NAME_PREFIX + i + managedServerNameBase + j;\n+\n+        // check managed server pod is created\n+        logger.info(\"Check for managed server pod {0} is created in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodCreated(managedServerPodName);\n+\n+        // check managed server pod is ready\n+        logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodReady(managedServerPodName);\n+\n+        // check managed server service is created\n+        logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkServiceCreated(managedServerPodName);\n+      }\n     }\n   }\n \n   @Test\n   @Order(2)\n-  @DisplayName(\"Create an ingress for a WebLogic domain in the specified domain namespace\")\n+  @DisplayName(\"Create an ingress for each cluster of the WebLogic domain in the specified domain namespace\")\n   public void testCreateIngress() {\n \n-    // create an ingress in domain namespace\n-    assertThat(assertDoesNotThrow(() -> createIngress(domainNamespace, domainUid, clusterName, managedServerPort)))\n-            .as(\"createIngress succeeds\")\n-            .withFailMessage(String.format(\"failed to create an ingress for domain %s in namespace %s\",\n-                domainUid, domainNamespace))\n-            .isTrue();\n-\n-    // check the ingress is created\n-    String ingressName = domainUid + \"-nginx\";\n-    assertThat(assertDoesNotThrow(() -> getIngressList(domainNamespace)))\n-        .as(String.format(\"found the ingress %s in namespace %s\", ingressName, domainNamespace))\n-        .withFailMessage(String.format(\"can not find ingress %s in namespace %s\", ingressName, domainNamespace))\n-        .contains(ingressName);\n-\n-    logger.info(\"ingress is created in namespace {0}\", domainNamespace);\n+    // create an ingress for each cluster of the domain in the domain namespace\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+\n+      String clusterName = CLUSTER_NAME_PREFIX + i;\n+      String ingressName = domainUid + \"-\" + clusterName + \"-nginx\";\n+\n+      logger.info(\"Creating ingress {0} for cluster {1} of domain {2} in namespace {3}\",\n+          ingressName, clusterName, domainUid, domainNamespace);\n+      assertThat(createIngress(ingressName, domainNamespace, domainUid, clusterName,\n+          MANAGED_SERVER_PORT, domainUid + \".\" + clusterName + \".test\"))\n+          .as(\"Test createIngress succeeds\")", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0NTY3MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422445671", "bodyText": "Descriptable.as() java doc is here: https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/Descriptable.html#as-java.lang.String-java.lang.Object...-\nThe msg in as() sets the description of the assertion that is going to be called after.\nIt is not the message printed if the assertion passes.\nIf the assertion fails, in your case, we will get the message something like:\n[Creating Ingress  for cluster  succeeded] {failed to create an ingress for cluster  of domain <domain_name> in namespace }\nIt will be confusing.\nHow about change to:\nChecking that ingress {0} for cluster {1} was created successfully.", "author": "xiancao", "createdAt": "2020-05-09T02:59:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMyNzE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMzMDI1NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422330255", "bodyText": "Ingress found in namespace....", "author": "sankarpn", "createdAt": "2020-05-08T19:28:57Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -293,76 +304,110 @@ public void testCreateMiiDomain() {\n         adminServerPodName, domainNamespace);\n     checkPodCreated(adminServerPodName);\n \n-    // check managed server pods exists\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodCreated(managedServerPrefix + i);\n-    }\n-\n     // check admin server pod is ready\n     logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkPodReady(adminServerPodName);\n \n-    // check managed server pods are ready\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodReady(managedServerPrefix + i);\n-    }\n-\n+    // check admin service is created\n     logger.info(\"Check admin service {0} is created in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkServiceCreated(adminServerPodName);\n \n-    // check managed server services created\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkServiceCreated(managedServerPrefix + i);\n+    // check the readiness for the managed servers in each cluster\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName =\n+            domainUid + \"-\" + CLUSTER_NAME_PREFIX + i + managedServerNameBase + j;\n+\n+        // check managed server pod is created\n+        logger.info(\"Check for managed server pod {0} is created in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodCreated(managedServerPodName);\n+\n+        // check managed server pod is ready\n+        logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodReady(managedServerPodName);\n+\n+        // check managed server service is created\n+        logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkServiceCreated(managedServerPodName);\n+      }\n     }\n   }\n \n   @Test\n   @Order(2)\n-  @DisplayName(\"Create an ingress for a WebLogic domain in the specified domain namespace\")\n+  @DisplayName(\"Create an ingress for each cluster of the WebLogic domain in the specified domain namespace\")\n   public void testCreateIngress() {\n \n-    // create an ingress in domain namespace\n-    assertThat(assertDoesNotThrow(() -> createIngress(domainNamespace, domainUid, clusterName, managedServerPort)))\n-            .as(\"createIngress succeeds\")\n-            .withFailMessage(String.format(\"failed to create an ingress for domain %s in namespace %s\",\n-                domainUid, domainNamespace))\n-            .isTrue();\n-\n-    // check the ingress is created\n-    String ingressName = domainUid + \"-nginx\";\n-    assertThat(assertDoesNotThrow(() -> getIngressList(domainNamespace)))\n-        .as(String.format(\"found the ingress %s in namespace %s\", ingressName, domainNamespace))\n-        .withFailMessage(String.format(\"can not find ingress %s in namespace %s\", ingressName, domainNamespace))\n-        .contains(ingressName);\n-\n-    logger.info(\"ingress is created in namespace {0}\", domainNamespace);\n+    // create an ingress for each cluster of the domain in the domain namespace\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+\n+      String clusterName = CLUSTER_NAME_PREFIX + i;\n+      String ingressName = domainUid + \"-\" + clusterName + \"-nginx\";\n+\n+      logger.info(\"Creating ingress {0} for cluster {1} of domain {2} in namespace {3}\",\n+          ingressName, clusterName, domainUid, domainNamespace);\n+      assertThat(createIngress(ingressName, domainNamespace, domainUid, clusterName,\n+          MANAGED_SERVER_PORT, domainUid + \".\" + clusterName + \".test\"))\n+          .as(\"Test createIngress succeeds\")\n+          .withFailMessage(String.format(\"failed to create an ingress for cluster %s of domain %s in namespace %s\",\n+              clusterName, domainUid, domainNamespace))\n+          .isTrue();\n+\n+      // check the ingress is created\n+      assertThat(assertDoesNotThrow(() -> getIngressList(domainNamespace)))\n+          .as(String.format(\"Test the ingress %s is created in namespace %s\", ingressName, domainNamespace))", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMjU1NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422502554", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:32:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMzMDI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM1NTE4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422355182", "bodyText": "Does this need to be a separate test? All it does is to create ingress resource / controller. Is it testing any operator code?", "author": "sankarpn", "createdAt": "2020-05-08T20:23:54Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -293,76 +304,110 @@ public void testCreateMiiDomain() {\n         adminServerPodName, domainNamespace);\n     checkPodCreated(adminServerPodName);\n \n-    // check managed server pods exists\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodCreated(managedServerPrefix + i);\n-    }\n-\n     // check admin server pod is ready\n     logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkPodReady(adminServerPodName);\n \n-    // check managed server pods are ready\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodReady(managedServerPrefix + i);\n-    }\n-\n+    // check admin service is created\n     logger.info(\"Check admin service {0} is created in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkServiceCreated(adminServerPodName);\n \n-    // check managed server services created\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkServiceCreated(managedServerPrefix + i);\n+    // check the readiness for the managed servers in each cluster\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName =\n+            domainUid + \"-\" + CLUSTER_NAME_PREFIX + i + managedServerNameBase + j;\n+\n+        // check managed server pod is created\n+        logger.info(\"Check for managed server pod {0} is created in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodCreated(managedServerPodName);\n+\n+        // check managed server pod is ready\n+        logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodReady(managedServerPodName);\n+\n+        // check managed server service is created\n+        logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkServiceCreated(managedServerPodName);\n+      }\n     }\n   }\n \n   @Test\n   @Order(2)\n-  @DisplayName(\"Create an ingress for a WebLogic domain in the specified domain namespace\")\n+  @DisplayName(\"Create an ingress for each cluster of the WebLogic domain in the specified domain namespace\")\n   public void testCreateIngress() {\n \n-    // create an ingress in domain namespace\n-    assertThat(assertDoesNotThrow(() -> createIngress(domainNamespace, domainUid, clusterName, managedServerPort)))\n-            .as(\"createIngress succeeds\")\n-            .withFailMessage(String.format(\"failed to create an ingress for domain %s in namespace %s\",\n-                domainUid, domainNamespace))\n-            .isTrue();\n-\n-    // check the ingress is created\n-    String ingressName = domainUid + \"-nginx\";\n-    assertThat(assertDoesNotThrow(() -> getIngressList(domainNamespace)))\n-        .as(String.format(\"found the ingress %s in namespace %s\", ingressName, domainNamespace))\n-        .withFailMessage(String.format(\"can not find ingress %s in namespace %s\", ingressName, domainNamespace))\n-        .contains(ingressName);\n-\n-    logger.info(\"ingress is created in namespace {0}\", domainNamespace);\n+    // create an ingress for each cluster of the domain in the domain namespace", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMjgwNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422502806", "bodyText": "The test is about Nginx validation. I think this is a valid test.", "author": "xiancao", "createdAt": "2020-05-09T14:34:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM1NTE4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM1NjM5MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422356390", "bodyText": "is the test name testAppAccessThroughIngressController may be more appropriate?", "author": "sankarpn", "createdAt": "2020-05-08T20:26:14Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -293,76 +304,110 @@ public void testCreateMiiDomain() {\n         adminServerPodName, domainNamespace);\n     checkPodCreated(adminServerPodName);\n \n-    // check managed server pods exists\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodCreated(managedServerPrefix + i);\n-    }\n-\n     // check admin server pod is ready\n     logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkPodReady(adminServerPodName);\n \n-    // check managed server pods are ready\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodReady(managedServerPrefix + i);\n-    }\n-\n+    // check admin service is created\n     logger.info(\"Check admin service {0} is created in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkServiceCreated(adminServerPodName);\n \n-    // check managed server services created\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkServiceCreated(managedServerPrefix + i);\n+    // check the readiness for the managed servers in each cluster\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName =\n+            domainUid + \"-\" + CLUSTER_NAME_PREFIX + i + managedServerNameBase + j;\n+\n+        // check managed server pod is created\n+        logger.info(\"Check for managed server pod {0} is created in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodCreated(managedServerPodName);\n+\n+        // check managed server pod is ready\n+        logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodReady(managedServerPodName);\n+\n+        // check managed server service is created\n+        logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkServiceCreated(managedServerPodName);\n+      }\n     }\n   }\n \n   @Test\n   @Order(2)\n-  @DisplayName(\"Create an ingress for a WebLogic domain in the specified domain namespace\")\n+  @DisplayName(\"Create an ingress for each cluster of the WebLogic domain in the specified domain namespace\")\n   public void testCreateIngress() {\n \n-    // create an ingress in domain namespace\n-    assertThat(assertDoesNotThrow(() -> createIngress(domainNamespace, domainUid, clusterName, managedServerPort)))\n-            .as(\"createIngress succeeds\")\n-            .withFailMessage(String.format(\"failed to create an ingress for domain %s in namespace %s\",\n-                domainUid, domainNamespace))\n-            .isTrue();\n-\n-    // check the ingress is created\n-    String ingressName = domainUid + \"-nginx\";\n-    assertThat(assertDoesNotThrow(() -> getIngressList(domainNamespace)))\n-        .as(String.format(\"found the ingress %s in namespace %s\", ingressName, domainNamespace))\n-        .withFailMessage(String.format(\"can not find ingress %s in namespace %s\", ingressName, domainNamespace))\n-        .contains(ingressName);\n-\n-    logger.info(\"ingress is created in namespace {0}\", domainNamespace);\n+    // create an ingress for each cluster of the domain in the domain namespace\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+\n+      String clusterName = CLUSTER_NAME_PREFIX + i;\n+      String ingressName = domainUid + \"-\" + clusterName + \"-nginx\";\n+\n+      logger.info(\"Creating ingress {0} for cluster {1} of domain {2} in namespace {3}\",\n+          ingressName, clusterName, domainUid, domainNamespace);\n+      assertThat(createIngress(ingressName, domainNamespace, domainUid, clusterName,\n+          MANAGED_SERVER_PORT, domainUid + \".\" + clusterName + \".test\"))\n+          .as(\"Test createIngress succeeds\")\n+          .withFailMessage(String.format(\"failed to create an ingress for cluster %s of domain %s in namespace %s\",\n+              clusterName, domainUid, domainNamespace))\n+          .isTrue();\n+\n+      // check the ingress is created\n+      assertThat(assertDoesNotThrow(() -> getIngressList(domainNamespace)))\n+          .as(String.format(\"Test the ingress %s is created in namespace %s\", ingressName, domainNamespace))\n+          .withFailMessage(String.format(\"can not find ingress %s in namespace %s\", ingressName, domainNamespace))\n+          .contains(ingressName);\n+\n+      logger.info(\"ingress {0} for cluster {1} of domain {2} is created in namespace {3}\",\n+          ingressName, clusterName, domainUid, domainNamespace);\n+    }\n   }\n \n   @Test\n   @Order(3)\n-  @DisplayName(\"Verify the application can be accessed through the ingress controller\")\n+  @DisplayName(\"Verify the application can be accessed through the ingress controller for each cluster in the domain\")\n   public void testSampleAppThroughIngressController() {\n \n-    List<String> managedServerNames = new ArrayList<>();\n-    for (int i = 1; i <= replicaCount; i++) {\n-      managedServerNames.add(managedServerNameBase + i);\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMjgyMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422502823", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:34:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM1NjM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM3MjU5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422372597", "bodyText": "we should log exception messages, otherwise we don't know what went wrong.", "author": "sankarpn", "createdAt": "2020-05-08T21:01:55Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/TestUtils.java", "diffHunk": "@@ -58,6 +59,10 @@ public static boolean callWebAppAndCheckForServerNameInResponse(\n           });\n         } catch (Exception e) {\n           logger.info(\"Got exception while running command: \" + curlCmd);\n+          if (result != null) {", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMjg0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422502846", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:34:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM3MjU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjc0MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422426741", "bodyText": "Scaling cluster {0} in domain {1} using patch string {2}...", "author": "sankarpn", "createdAt": "2020-05-09T00:12:12Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Domain.java", "diffHunk": "@@ -77,4 +82,48 @@ public static boolean patchDomainCustomResource(String domainUid, String namespa\n       String patchFormat) {\n     return Kubernetes.patchDomainCustomResource(domainUid, namespace, patch, patchFormat);\n   }\n+\n+  /**\n+   * Scale the cluster of the domain in the specified namespace.\n+   *\n+   * @param domainUid domainUid of the domain to be scaled\n+   * @param namespace namespace in which the domain resides\n+   * @param clusterName name of the WebLogic cluster to be scaled in the domain\n+   * @param numOfServers number of servers to be scaled to\n+   * @return true if success, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static boolean scaleDomain(String domainUid, String namespace, String clusterName, int numOfServers)\n+      throws ApiException {\n+\n+    // get the domain cluster list\n+    oracle.weblogic.domain.Domain domain = getDomainCustomResource(domainUid, namespace);\n+    List<Cluster> clusters = domain.getSpec().getClusters();\n+\n+    // get the index of the cluster with clusterName in the cluster list\n+    int index = 0;\n+    for (int i = 0; i < clusters.size(); i++) {\n+      if (clusters.get(i).getClusterName().equals(clusterName)) {\n+        index = i;\n+        break;\n+      }\n+    }\n+\n+    // construct the patch string for scaling the cluster in the domain\n+    StringBuffer patchStr = new StringBuffer(\"[{\")\n+        .append(\"\\\"op\\\": \\\"replace\\\", \")\n+        .append(\"\\\"path\\\": \\\"/spec/clusters/\")\n+        .append(index)\n+        .append(\"/replicas\\\", \")\n+        .append(\"\\\"value\\\": \")\n+        .append(numOfServers)\n+        .append(\"}]\");\n+\n+    logger.info(\"Scale domain patch String: {0}\", patchStr.toString());", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIyNDcyMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423224720", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-11T18:09:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzE5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422427193", "bodyText": "Should be logged as a severe message", "author": "sankarpn", "createdAt": "2020-05-09T00:14:21Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Nginx.java", "diffHunk": "@@ -116,8 +118,8 @@ public static boolean createIngress(String domainNamespace,\n     try {\n       Kubernetes.createIngress(domainNamespace, ingress);\n     } catch (ApiException apex) {\n-      logger.warning(apex.getResponseBody());\n-      throw apex;\n+      logger.info(\"got ApiException while calling createIngress: {0}\", apex.getResponseBody());", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMjg4Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422502886", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:35:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzkzNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422427937", "bodyText": "method name message does not match. if the method simply checks if a pod exists or not why is it waiting here ?", "author": "sankarpn", "createdAt": "2020-05-09T00:18:24Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzI0NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503245", "bodyText": "changed the method name to checkPodDeleted(String podName)", "author": "xiancao", "createdAt": "2020-05-09T14:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTk4Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422425983", "bodyText": "check that", "author": "markxnelson", "createdAt": "2020-05-09T00:08:43Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -293,76 +304,110 @@ public void testCreateMiiDomain() {\n         adminServerPodName, domainNamespace);\n     checkPodCreated(adminServerPodName);\n \n-    // check managed server pods exists\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodCreated(managedServerPrefix + i);\n-    }\n-\n     // check admin server pod is ready\n     logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkPodReady(adminServerPodName);\n \n-    // check managed server pods are ready\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodReady(managedServerPrefix + i);\n-    }\n-\n+    // check admin service is created\n     logger.info(\"Check admin service {0} is created in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkServiceCreated(adminServerPodName);\n \n-    // check managed server services created\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkServiceCreated(managedServerPrefix + i);\n+    // check the readiness for the managed servers in each cluster\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName =\n+            domainUid + \"-\" + CLUSTER_NAME_PREFIX + i + managedServerNameBase + j;\n+\n+        // check managed server pod is created\n+        logger.info(\"Check for managed server pod {0} is created in namespace {1}\",", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0ODYwMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422448603", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T03:42:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNTk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjM0Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422426347", "bodyText": "was", "author": "markxnelson", "createdAt": "2020-05-09T00:10:21Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -293,76 +304,110 @@ public void testCreateMiiDomain() {\n         adminServerPodName, domainNamespace);\n     checkPodCreated(adminServerPodName);\n \n-    // check managed server pods exists\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodCreated(managedServerPrefix + i);\n-    }\n-\n     // check admin server pod is ready\n     logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkPodReady(adminServerPodName);\n \n-    // check managed server pods are ready\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodReady(managedServerPrefix + i);\n-    }\n-\n+    // check admin service is created\n     logger.info(\"Check admin service {0} is created in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkServiceCreated(adminServerPodName);\n \n-    // check managed server services created\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkServiceCreated(managedServerPrefix + i);\n+    // check the readiness for the managed servers in each cluster\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName =\n+            domainUid + \"-\" + CLUSTER_NAME_PREFIX + i + managedServerNameBase + j;\n+\n+        // check managed server pod is created\n+        logger.info(\"Check for managed server pod {0} is created in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodCreated(managedServerPodName);\n+\n+        // check managed server pod is ready\n+        logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodReady(managedServerPodName);\n+\n+        // check managed server service is created\n+        logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkServiceCreated(managedServerPodName);\n+      }\n     }\n   }\n \n   @Test\n   @Order(2)\n-  @DisplayName(\"Create an ingress for a WebLogic domain in the specified domain namespace\")\n+  @DisplayName(\"Create an ingress for each cluster of the WebLogic domain in the specified domain namespace\")\n   public void testCreateIngress() {\n \n-    // create an ingress in domain namespace\n-    assertThat(assertDoesNotThrow(() -> createIngress(domainNamespace, domainUid, clusterName, managedServerPort)))\n-            .as(\"createIngress succeeds\")\n-            .withFailMessage(String.format(\"failed to create an ingress for domain %s in namespace %s\",\n-                domainUid, domainNamespace))\n-            .isTrue();\n-\n-    // check the ingress is created\n-    String ingressName = domainUid + \"-nginx\";\n-    assertThat(assertDoesNotThrow(() -> getIngressList(domainNamespace)))\n-        .as(String.format(\"found the ingress %s in namespace %s\", ingressName, domainNamespace))\n-        .withFailMessage(String.format(\"can not find ingress %s in namespace %s\", ingressName, domainNamespace))\n-        .contains(ingressName);\n-\n-    logger.info(\"ingress is created in namespace {0}\", domainNamespace);\n+    // create an ingress for each cluster of the domain in the domain namespace\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+\n+      String clusterName = CLUSTER_NAME_PREFIX + i;\n+      String ingressName = domainUid + \"-\" + clusterName + \"-nginx\";\n+\n+      logger.info(\"Creating ingress {0} for cluster {1} of domain {2} in namespace {3}\",\n+          ingressName, clusterName, domainUid, domainNamespace);\n+      assertThat(createIngress(ingressName, domainNamespace, domainUid, clusterName,\n+          MANAGED_SERVER_PORT, domainUid + \".\" + clusterName + \".test\"))\n+          .as(\"Test createIngress succeeds\")\n+          .withFailMessage(String.format(\"failed to create an ingress for cluster %s of domain %s in namespace %s\",\n+              clusterName, domainUid, domainNamespace))\n+          .isTrue();\n+\n+      // check the ingress is created", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzI3MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503270", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjM3MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422426371", "bodyText": "was", "author": "markxnelson", "createdAt": "2020-05-09T00:10:28Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -293,76 +304,110 @@ public void testCreateMiiDomain() {\n         adminServerPodName, domainNamespace);\n     checkPodCreated(adminServerPodName);\n \n-    // check managed server pods exists\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodCreated(managedServerPrefix + i);\n-    }\n-\n     // check admin server pod is ready\n     logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkPodReady(adminServerPodName);\n \n-    // check managed server pods are ready\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodReady(managedServerPrefix + i);\n-    }\n-\n+    // check admin service is created\n     logger.info(\"Check admin service {0} is created in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkServiceCreated(adminServerPodName);\n \n-    // check managed server services created\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkServiceCreated(managedServerPrefix + i);\n+    // check the readiness for the managed servers in each cluster\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName =\n+            domainUid + \"-\" + CLUSTER_NAME_PREFIX + i + managedServerNameBase + j;\n+\n+        // check managed server pod is created\n+        logger.info(\"Check for managed server pod {0} is created in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodCreated(managedServerPodName);\n+\n+        // check managed server pod is ready\n+        logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodReady(managedServerPodName);\n+\n+        // check managed server service is created\n+        logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkServiceCreated(managedServerPodName);\n+      }\n     }\n   }\n \n   @Test\n   @Order(2)\n-  @DisplayName(\"Create an ingress for a WebLogic domain in the specified domain namespace\")\n+  @DisplayName(\"Create an ingress for each cluster of the WebLogic domain in the specified domain namespace\")\n   public void testCreateIngress() {\n \n-    // create an ingress in domain namespace\n-    assertThat(assertDoesNotThrow(() -> createIngress(domainNamespace, domainUid, clusterName, managedServerPort)))\n-            .as(\"createIngress succeeds\")\n-            .withFailMessage(String.format(\"failed to create an ingress for domain %s in namespace %s\",\n-                domainUid, domainNamespace))\n-            .isTrue();\n-\n-    // check the ingress is created\n-    String ingressName = domainUid + \"-nginx\";\n-    assertThat(assertDoesNotThrow(() -> getIngressList(domainNamespace)))\n-        .as(String.format(\"found the ingress %s in namespace %s\", ingressName, domainNamespace))\n-        .withFailMessage(String.format(\"can not find ingress %s in namespace %s\", ingressName, domainNamespace))\n-        .contains(ingressName);\n-\n-    logger.info(\"ingress is created in namespace {0}\", domainNamespace);\n+    // create an ingress for each cluster of the domain in the domain namespace\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+\n+      String clusterName = CLUSTER_NAME_PREFIX + i;\n+      String ingressName = domainUid + \"-\" + clusterName + \"-nginx\";\n+\n+      logger.info(\"Creating ingress {0} for cluster {1} of domain {2} in namespace {3}\",\n+          ingressName, clusterName, domainUid, domainNamespace);\n+      assertThat(createIngress(ingressName, domainNamespace, domainUid, clusterName,\n+          MANAGED_SERVER_PORT, domainUid + \".\" + clusterName + \".test\"))\n+          .as(\"Test createIngress succeeds\")\n+          .withFailMessage(String.format(\"failed to create an ingress for cluster %s of domain %s in namespace %s\",\n+              clusterName, domainUid, domainNamespace))\n+          .isTrue();\n+\n+      // check the ingress is created\n+      assertThat(assertDoesNotThrow(() -> getIngressList(domainNamespace)))\n+          .as(String.format(\"Test the ingress %s is created in namespace %s\", ingressName, domainNamespace))", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzI4MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503281", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:39:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjM5OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422426398", "bodyText": "was", "author": "markxnelson", "createdAt": "2020-05-09T00:10:37Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -293,76 +304,110 @@ public void testCreateMiiDomain() {\n         adminServerPodName, domainNamespace);\n     checkPodCreated(adminServerPodName);\n \n-    // check managed server pods exists\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodCreated(managedServerPrefix + i);\n-    }\n-\n     // check admin server pod is ready\n     logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkPodReady(adminServerPodName);\n \n-    // check managed server pods are ready\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodReady(managedServerPrefix + i);\n-    }\n-\n+    // check admin service is created\n     logger.info(\"Check admin service {0} is created in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkServiceCreated(adminServerPodName);\n \n-    // check managed server services created\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkServiceCreated(managedServerPrefix + i);\n+    // check the readiness for the managed servers in each cluster\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName =\n+            domainUid + \"-\" + CLUSTER_NAME_PREFIX + i + managedServerNameBase + j;\n+\n+        // check managed server pod is created\n+        logger.info(\"Check for managed server pod {0} is created in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodCreated(managedServerPodName);\n+\n+        // check managed server pod is ready\n+        logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodReady(managedServerPodName);\n+\n+        // check managed server service is created\n+        logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkServiceCreated(managedServerPodName);\n+      }\n     }\n   }\n \n   @Test\n   @Order(2)\n-  @DisplayName(\"Create an ingress for a WebLogic domain in the specified domain namespace\")\n+  @DisplayName(\"Create an ingress for each cluster of the WebLogic domain in the specified domain namespace\")\n   public void testCreateIngress() {\n \n-    // create an ingress in domain namespace\n-    assertThat(assertDoesNotThrow(() -> createIngress(domainNamespace, domainUid, clusterName, managedServerPort)))\n-            .as(\"createIngress succeeds\")\n-            .withFailMessage(String.format(\"failed to create an ingress for domain %s in namespace %s\",\n-                domainUid, domainNamespace))\n-            .isTrue();\n-\n-    // check the ingress is created\n-    String ingressName = domainUid + \"-nginx\";\n-    assertThat(assertDoesNotThrow(() -> getIngressList(domainNamespace)))\n-        .as(String.format(\"found the ingress %s in namespace %s\", ingressName, domainNamespace))\n-        .withFailMessage(String.format(\"can not find ingress %s in namespace %s\", ingressName, domainNamespace))\n-        .contains(ingressName);\n-\n-    logger.info(\"ingress is created in namespace {0}\", domainNamespace);\n+    // create an ingress for each cluster of the domain in the domain namespace\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+\n+      String clusterName = CLUSTER_NAME_PREFIX + i;\n+      String ingressName = domainUid + \"-\" + clusterName + \"-nginx\";\n+\n+      logger.info(\"Creating ingress {0} for cluster {1} of domain {2} in namespace {3}\",\n+          ingressName, clusterName, domainUid, domainNamespace);\n+      assertThat(createIngress(ingressName, domainNamespace, domainUid, clusterName,\n+          MANAGED_SERVER_PORT, domainUid + \".\" + clusterName + \".test\"))\n+          .as(\"Test createIngress succeeds\")\n+          .withFailMessage(String.format(\"failed to create an ingress for cluster %s of domain %s in namespace %s\",\n+              clusterName, domainUid, domainNamespace))\n+          .isTrue();\n+\n+      // check the ingress is created\n+      assertThat(assertDoesNotThrow(() -> getIngressList(domainNamespace)))\n+          .as(String.format(\"Test the ingress %s is created in namespace %s\", ingressName, domainNamespace))\n+          .withFailMessage(String.format(\"can not find ingress %s in namespace %s\", ingressName, domainNamespace))\n+          .contains(ingressName);\n+\n+      logger.info(\"ingress {0} for cluster {1} of domain {2} is created in namespace {3}\",", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzI5OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503298", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:39:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjYzOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422426638", "bodyText": "method name does not seem to match what the method actually does", "author": "markxnelson", "createdAt": "2020-05-09T00:11:48Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0ODU3OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422448579", "bodyText": "changed it to checkPodDeleted(String podName)", "author": "xiancao", "createdAt": "2020-05-09T03:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNjYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzEzMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422427130", "bodyText": "check that ... was created ...", "author": "markxnelson", "createdAt": "2020-05-09T00:14:04Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled\n+   * @param domainNamespace the domain namespace the domain resides\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param replicasBeforeScale the replicas of the WebLogic cluster before the scale\n+   * @param numberOfServers the number of servers to be scaled to\n+   * @return the replicas of the WebLogic cluster after the scale\n+   */\n+  private int scaleAndVerifyDomain(String domainUid,\n+                                   String domainNamespace,\n+                                   String clusterName,\n+                                   int replicasBeforeScale,\n+                                   int numberOfServers) {\n+\n+    String manageServerPodNamePrefix = domainUid + \"-\" + clusterName + \"-managed-server\";\n+\n+    // scale the cluster in the domain\n+    assertThat(assertDoesNotThrow(() -> scaleDomain(domainUid, domainNamespace, clusterName, numberOfServers)))\n+        .as(String.format(\"Verify scale the cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .withFailMessage(String.format(\"can not scale cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .isTrue();\n+\n+    // generate a curl command to ping the sample app through the ingress controller\n+    curlCmd = generateCurlCmd(clusterName);\n+\n+    // generate the expected server list which should be in the sample app response string\n+    List<String> expectedServerNamesInAppResponse =\n+        generateExpectedServerNamesInAppResponse(clusterName, replicasBeforeScale);\n+    logger.info(\"expected server name list which should be in the sample app response: {0} before scale\",\n+        expectedServerNamesInAppResponse);\n+\n+    if (replicasBeforeScale <= numberOfServers) {\n+\n+      // check that NGINX can access the sample apps from the original managed servers in the domain\n+      logger.info(\"Check that NGINX can access the sample app from the original managed servers in the domain \"\n+                  + \"while the domain is scaling up.\");\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"Verify NGINX can access the sample app from the original managed servers in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n+          .isTrue();\n+\n+      // check new managed server pods are created and wait for them to be ready\n+      for (int i = replicasBeforeScale + 1; i <= numberOfServers; i++) {\n+        String manageServerPodName = manageServerPodNamePrefix + i;\n+\n+        // check new managed server pods are created\n+        logger.info(\"Check for the new managed server pod {0} is created in namespace {1}\",", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzMyNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503327", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:39:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzE0Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422427147", "bodyText": "same", "author": "markxnelson", "createdAt": "2020-05-09T00:14:09Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled\n+   * @param domainNamespace the domain namespace the domain resides\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param replicasBeforeScale the replicas of the WebLogic cluster before the scale\n+   * @param numberOfServers the number of servers to be scaled to\n+   * @return the replicas of the WebLogic cluster after the scale\n+   */\n+  private int scaleAndVerifyDomain(String domainUid,\n+                                   String domainNamespace,\n+                                   String clusterName,\n+                                   int replicasBeforeScale,\n+                                   int numberOfServers) {\n+\n+    String manageServerPodNamePrefix = domainUid + \"-\" + clusterName + \"-managed-server\";\n+\n+    // scale the cluster in the domain\n+    assertThat(assertDoesNotThrow(() -> scaleDomain(domainUid, domainNamespace, clusterName, numberOfServers)))\n+        .as(String.format(\"Verify scale the cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .withFailMessage(String.format(\"can not scale cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .isTrue();\n+\n+    // generate a curl command to ping the sample app through the ingress controller\n+    curlCmd = generateCurlCmd(clusterName);\n+\n+    // generate the expected server list which should be in the sample app response string\n+    List<String> expectedServerNamesInAppResponse =\n+        generateExpectedServerNamesInAppResponse(clusterName, replicasBeforeScale);\n+    logger.info(\"expected server name list which should be in the sample app response: {0} before scale\",\n+        expectedServerNamesInAppResponse);\n+\n+    if (replicasBeforeScale <= numberOfServers) {\n+\n+      // check that NGINX can access the sample apps from the original managed servers in the domain\n+      logger.info(\"Check that NGINX can access the sample app from the original managed servers in the domain \"\n+                  + \"while the domain is scaling up.\");\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"Verify NGINX can access the sample app from the original managed servers in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n+          .isTrue();\n+\n+      // check new managed server pods are created and wait for them to be ready\n+      for (int i = replicasBeforeScale + 1; i <= numberOfServers; i++) {\n+        String manageServerPodName = manageServerPodNamePrefix + i;\n+\n+        // check new managed server pods are created\n+        logger.info(\"Check for the new managed server pod {0} is created in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkPodCreated(manageServerPodName);\n+\n+        // check new managed server pods are ready\n+        logger.info(\"Wait for the new managed server pod {0} to be ready in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkPodReady(manageServerPodName);\n+\n+        // check new managed server services are created\n+        logger.info(\"Check for the new managed server service {0} is created in namespace {1}\",", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzMzMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503331", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:39:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzIwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422427204", "bodyText": "was removed from", "author": "markxnelson", "createdAt": "2020-05-09T00:14:27Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled\n+   * @param domainNamespace the domain namespace the domain resides\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param replicasBeforeScale the replicas of the WebLogic cluster before the scale\n+   * @param numberOfServers the number of servers to be scaled to\n+   * @return the replicas of the WebLogic cluster after the scale\n+   */\n+  private int scaleAndVerifyDomain(String domainUid,\n+                                   String domainNamespace,\n+                                   String clusterName,\n+                                   int replicasBeforeScale,\n+                                   int numberOfServers) {\n+\n+    String manageServerPodNamePrefix = domainUid + \"-\" + clusterName + \"-managed-server\";\n+\n+    // scale the cluster in the domain\n+    assertThat(assertDoesNotThrow(() -> scaleDomain(domainUid, domainNamespace, clusterName, numberOfServers)))\n+        .as(String.format(\"Verify scale the cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .withFailMessage(String.format(\"can not scale cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .isTrue();\n+\n+    // generate a curl command to ping the sample app through the ingress controller\n+    curlCmd = generateCurlCmd(clusterName);\n+\n+    // generate the expected server list which should be in the sample app response string\n+    List<String> expectedServerNamesInAppResponse =\n+        generateExpectedServerNamesInAppResponse(clusterName, replicasBeforeScale);\n+    logger.info(\"expected server name list which should be in the sample app response: {0} before scale\",\n+        expectedServerNamesInAppResponse);\n+\n+    if (replicasBeforeScale <= numberOfServers) {\n+\n+      // check that NGINX can access the sample apps from the original managed servers in the domain\n+      logger.info(\"Check that NGINX can access the sample app from the original managed servers in the domain \"\n+                  + \"while the domain is scaling up.\");\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"Verify NGINX can access the sample app from the original managed servers in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n+          .isTrue();\n+\n+      // check new managed server pods are created and wait for them to be ready\n+      for (int i = replicasBeforeScale + 1; i <= numberOfServers; i++) {\n+        String manageServerPodName = manageServerPodNamePrefix + i;\n+\n+        // check new managed server pods are created\n+        logger.info(\"Check for the new managed server pod {0} is created in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkPodCreated(manageServerPodName);\n+\n+        // check new managed server pods are ready\n+        logger.info(\"Wait for the new managed server pod {0} to be ready in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkPodReady(manageServerPodName);\n+\n+        // check new managed server services are created\n+        logger.info(\"Check for the new managed server service {0} is created in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkServiceCreated(manageServerPodName);\n+\n+        // add the new managed server to the list\n+        expectedServerNamesInAppResponse.add(clusterName + \"-managed-server\" + i);\n+\n+      }\n+\n+      // check that NGINX can access the sample apps from new and original managed servers\n+      logger.info(\"Check that NGINX can access the sample app from the new and original managed servers \"\n+          + \"in the domain after the domain is scaled up.\");\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"Check NGINX can access the sample app from all managed servers in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n+          .isTrue();\n+    } else {\n+      // scale down\n+      // wait and check the pods are removed\n+      for (int i = replicasBeforeScale; i > numberOfServers; i--) {\n+        logger.info(\"Check managed server pod {0} is removed in namespace {1}\",", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzM0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503348", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzMwOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422427309", "bodyText": "you are not pinging it", "author": "markxnelson", "createdAt": "2020-05-09T00:14:57Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled\n+   * @param domainNamespace the domain namespace the domain resides\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param replicasBeforeScale the replicas of the WebLogic cluster before the scale\n+   * @param numberOfServers the number of servers to be scaled to\n+   * @return the replicas of the WebLogic cluster after the scale\n+   */\n+  private int scaleAndVerifyDomain(String domainUid,\n+                                   String domainNamespace,\n+                                   String clusterName,\n+                                   int replicasBeforeScale,\n+                                   int numberOfServers) {\n+\n+    String manageServerPodNamePrefix = domainUid + \"-\" + clusterName + \"-managed-server\";\n+\n+    // scale the cluster in the domain\n+    assertThat(assertDoesNotThrow(() -> scaleDomain(domainUid, domainNamespace, clusterName, numberOfServers)))\n+        .as(String.format(\"Verify scale the cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .withFailMessage(String.format(\"can not scale cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .isTrue();\n+\n+    // generate a curl command to ping the sample app through the ingress controller\n+    curlCmd = generateCurlCmd(clusterName);\n+\n+    // generate the expected server list which should be in the sample app response string\n+    List<String> expectedServerNamesInAppResponse =\n+        generateExpectedServerNamesInAppResponse(clusterName, replicasBeforeScale);\n+    logger.info(\"expected server name list which should be in the sample app response: {0} before scale\",\n+        expectedServerNamesInAppResponse);\n+\n+    if (replicasBeforeScale <= numberOfServers) {\n+\n+      // check that NGINX can access the sample apps from the original managed servers in the domain\n+      logger.info(\"Check that NGINX can access the sample app from the original managed servers in the domain \"\n+                  + \"while the domain is scaling up.\");\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"Verify NGINX can access the sample app from the original managed servers in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n+          .isTrue();\n+\n+      // check new managed server pods are created and wait for them to be ready\n+      for (int i = replicasBeforeScale + 1; i <= numberOfServers; i++) {\n+        String manageServerPodName = manageServerPodNamePrefix + i;\n+\n+        // check new managed server pods are created\n+        logger.info(\"Check for the new managed server pod {0} is created in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkPodCreated(manageServerPodName);\n+\n+        // check new managed server pods are ready\n+        logger.info(\"Wait for the new managed server pod {0} to be ready in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkPodReady(manageServerPodName);\n+\n+        // check new managed server services are created\n+        logger.info(\"Check for the new managed server service {0} is created in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkServiceCreated(manageServerPodName);\n+\n+        // add the new managed server to the list\n+        expectedServerNamesInAppResponse.add(clusterName + \"-managed-server\" + i);\n+\n+      }\n+\n+      // check that NGINX can access the sample apps from new and original managed servers\n+      logger.info(\"Check that NGINX can access the sample app from the new and original managed servers \"\n+          + \"in the domain after the domain is scaled up.\");\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"Check NGINX can access the sample app from all managed servers in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n+          .isTrue();\n+    } else {\n+      // scale down\n+      // wait and check the pods are removed\n+      for (int i = replicasBeforeScale; i > numberOfServers; i--) {\n+        logger.info(\"Check managed server pod {0} is removed in namespace {1}\",\n+            manageServerPodNamePrefix + i, domainNamespace);\n+        checkPodDoesNotExist(manageServerPodNamePrefix + i);\n+        expectedServerNamesInAppResponse.remove(clusterName + \"-managed-server\" + i);\n+      }\n+\n+      // check that NGINX can access the remaining managed server in the domain\n+      logger.info(\"Check that NGINX can access the sample app from the remaining managed servers in the domain \"\n+          + \"after the domain is scaled down.\");\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"Check NGINX can access the sample app from the remaining managed server in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from the remaining managed server\")\n+          .isTrue();\n+    }\n+\n+    return numberOfServers;\n+  }\n+\n+  /**\n+   * Generate the curl command to ping the sample app from the ingress controller.", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzM3MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503370", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzMwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzUyMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422427520", "bodyText": "this implies the full list is in one response - in that what you meant? don't you mean the list that you expect to see after looking at a (large) number of responses", "author": "markxnelson", "createdAt": "2020-05-09T00:16:06Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled\n+   * @param domainNamespace the domain namespace the domain resides\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param replicasBeforeScale the replicas of the WebLogic cluster before the scale\n+   * @param numberOfServers the number of servers to be scaled to\n+   * @return the replicas of the WebLogic cluster after the scale\n+   */\n+  private int scaleAndVerifyDomain(String domainUid,\n+                                   String domainNamespace,\n+                                   String clusterName,\n+                                   int replicasBeforeScale,\n+                                   int numberOfServers) {\n+\n+    String manageServerPodNamePrefix = domainUid + \"-\" + clusterName + \"-managed-server\";\n+\n+    // scale the cluster in the domain\n+    assertThat(assertDoesNotThrow(() -> scaleDomain(domainUid, domainNamespace, clusterName, numberOfServers)))\n+        .as(String.format(\"Verify scale the cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .withFailMessage(String.format(\"can not scale cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .isTrue();\n+\n+    // generate a curl command to ping the sample app through the ingress controller\n+    curlCmd = generateCurlCmd(clusterName);\n+\n+    // generate the expected server list which should be in the sample app response string\n+    List<String> expectedServerNamesInAppResponse =\n+        generateExpectedServerNamesInAppResponse(clusterName, replicasBeforeScale);\n+    logger.info(\"expected server name list which should be in the sample app response: {0} before scale\",\n+        expectedServerNamesInAppResponse);\n+\n+    if (replicasBeforeScale <= numberOfServers) {\n+\n+      // check that NGINX can access the sample apps from the original managed servers in the domain\n+      logger.info(\"Check that NGINX can access the sample app from the original managed servers in the domain \"\n+                  + \"while the domain is scaling up.\");\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"Verify NGINX can access the sample app from the original managed servers in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n+          .isTrue();\n+\n+      // check new managed server pods are created and wait for them to be ready\n+      for (int i = replicasBeforeScale + 1; i <= numberOfServers; i++) {\n+        String manageServerPodName = manageServerPodNamePrefix + i;\n+\n+        // check new managed server pods are created\n+        logger.info(\"Check for the new managed server pod {0} is created in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkPodCreated(manageServerPodName);\n+\n+        // check new managed server pods are ready\n+        logger.info(\"Wait for the new managed server pod {0} to be ready in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkPodReady(manageServerPodName);\n+\n+        // check new managed server services are created\n+        logger.info(\"Check for the new managed server service {0} is created in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkServiceCreated(manageServerPodName);\n+\n+        // add the new managed server to the list\n+        expectedServerNamesInAppResponse.add(clusterName + \"-managed-server\" + i);\n+\n+      }\n+\n+      // check that NGINX can access the sample apps from new and original managed servers\n+      logger.info(\"Check that NGINX can access the sample app from the new and original managed servers \"\n+          + \"in the domain after the domain is scaled up.\");\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"Check NGINX can access the sample app from all managed servers in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n+          .isTrue();\n+    } else {\n+      // scale down\n+      // wait and check the pods are removed\n+      for (int i = replicasBeforeScale; i > numberOfServers; i--) {\n+        logger.info(\"Check managed server pod {0} is removed in namespace {1}\",\n+            manageServerPodNamePrefix + i, domainNamespace);\n+        checkPodDoesNotExist(manageServerPodNamePrefix + i);\n+        expectedServerNamesInAppResponse.remove(clusterName + \"-managed-server\" + i);\n+      }\n+\n+      // check that NGINX can access the remaining managed server in the domain\n+      logger.info(\"Check that NGINX can access the sample app from the remaining managed servers in the domain \"\n+          + \"after the domain is scaled down.\");\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"Check NGINX can access the sample app from the remaining managed server in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from the remaining managed server\")\n+          .isTrue();\n+    }\n+\n+    return numberOfServers;\n+  }\n+\n+  /**\n+   * Generate the curl command to ping the sample app from the ingress controller.\n+   *\n+   * @param clusterName WebLogic cluster name which is the backend of the ingress\n+   * @return curl command string\n+   */\n+  private String generateCurlCmd(String clusterName) {\n+    String curlCmd =\n+        String.format(\"curl --silent --show-error --noproxy '*' -H 'host: %s' http://%s:%s/sample-war/index.jsp\",\n+        domainUid + \".\" + clusterName + \".test\", K8S_NODEPORT_HOST, nodeportshttp);\n+    return curlCmd;\n+  }\n+\n+  /**\n+   * Generate an expected server name list which should be returned in the sample app response.", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzM5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503396", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:40:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzY2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422427664", "bodyText": "ingress names -> ingresses", "author": "markxnelson", "createdAt": "2020-05-09T00:16:54Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -239,6 +243,17 @@ public static boolean uninstallNginx(HelmParams params) {\n     return Nginx.uninstall(params);\n   }\n \n+  /**\n+   * Get a list of ingress names in the specified namespace.", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzQyNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503427", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:40:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzY5Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422427692", "bodyText": "listIngresses", "author": "markxnelson", "createdAt": "2020-05-09T00:17:05Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -239,6 +243,17 @@ public static boolean uninstallNginx(HelmParams params) {\n     return Nginx.uninstall(params);\n   }\n \n+  /**\n+   * Get a list of ingress names in the specified namespace.\n+   *\n+   * @param namespace in which to list all the ingresses\n+   * @return list of ingress names in the specified namespace\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static List<String> getIngressList(String namespace) throws ApiException {", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzQzOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503438", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:40:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzgxMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422427813", "bodyText": "what is success? you submitted the async request?   it worked? something else?", "author": "markxnelson", "createdAt": "2020-05-09T00:17:41Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Domain.java", "diffHunk": "@@ -77,4 +82,48 @@ public static boolean patchDomainCustomResource(String domainUid, String namespa\n       String patchFormat) {\n     return Kubernetes.patchDomainCustomResource(domainUid, namespace, patch, patchFormat);\n   }\n+\n+  /**\n+   * Scale the cluster of the domain in the specified namespace.\n+   *\n+   * @param domainUid domainUid of the domain to be scaled\n+   * @param namespace namespace in which the domain resides\n+   * @param clusterName name of the WebLogic cluster to be scaled in the domain\n+   * @param numOfServers number of servers to be scaled to\n+   * @return true if success, false otherwise", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzQ2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503460", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:40:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzgxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzg1Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422427857", "bodyText": "null check", "author": "markxnelson", "createdAt": "2020-05-09T00:17:54Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Domain.java", "diffHunk": "@@ -77,4 +82,48 @@ public static boolean patchDomainCustomResource(String domainUid, String namespa\n       String patchFormat) {\n     return Kubernetes.patchDomainCustomResource(domainUid, namespace, patch, patchFormat);\n   }\n+\n+  /**\n+   * Scale the cluster of the domain in the specified namespace.\n+   *\n+   * @param domainUid domainUid of the domain to be scaled\n+   * @param namespace namespace in which the domain resides\n+   * @param clusterName name of the WebLogic cluster to be scaled in the domain\n+   * @param numOfServers number of servers to be scaled to\n+   * @return true if success, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static boolean scaleDomain(String domainUid, String namespace, String clusterName, int numOfServers)\n+      throws ApiException {\n+\n+    // get the domain cluster list\n+    oracle.weblogic.domain.Domain domain = getDomainCustomResource(domainUid, namespace);\n+    List<Cluster> clusters = domain.getSpec().getClusters();", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzQ4NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503485", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:40:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzkyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422427929", "bodyText": "string, no cap", "author": "markxnelson", "createdAt": "2020-05-09T00:18:22Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Domain.java", "diffHunk": "@@ -77,4 +82,48 @@ public static boolean patchDomainCustomResource(String domainUid, String namespa\n       String patchFormat) {\n     return Kubernetes.patchDomainCustomResource(domainUid, namespace, patch, patchFormat);\n   }\n+\n+  /**\n+   * Scale the cluster of the domain in the specified namespace.\n+   *\n+   * @param domainUid domainUid of the domain to be scaled\n+   * @param namespace namespace in which the domain resides\n+   * @param clusterName name of the WebLogic cluster to be scaled in the domain\n+   * @param numOfServers number of servers to be scaled to\n+   * @return true if success, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static boolean scaleDomain(String domainUid, String namespace, String clusterName, int numOfServers)\n+      throws ApiException {\n+\n+    // get the domain cluster list\n+    oracle.weblogic.domain.Domain domain = getDomainCustomResource(domainUid, namespace);\n+    List<Cluster> clusters = domain.getSpec().getClusters();\n+\n+    // get the index of the cluster with clusterName in the cluster list\n+    int index = 0;\n+    for (int i = 0; i < clusters.size(); i++) {\n+      if (clusters.get(i).getClusterName().equals(clusterName)) {\n+        index = i;\n+        break;\n+      }\n+    }\n+\n+    // construct the patch string for scaling the cluster in the domain\n+    StringBuffer patchStr = new StringBuffer(\"[{\")\n+        .append(\"\\\"op\\\": \\\"replace\\\", \")\n+        .append(\"\\\"path\\\": \\\"/spec/clusters/\")\n+        .append(index)\n+        .append(\"/replicas\\\", \")\n+        .append(\"\\\"value\\\": \")\n+        .append(numOfServers)\n+        .append(\"}]\");\n+\n+    logger.info(\"Scale domain patch String: {0}\", patchStr.toString());", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzUwOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503508", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyODA5OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422428098", "bodyText": "get rid of the extra space after \\n to avoid confusion", "author": "markxnelson", "createdAt": "2020-05-09T00:19:07Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/TestUtils.java", "diffHunk": "@@ -58,6 +59,10 @@ public static boolean callWebAppAndCheckForServerNameInResponse(\n           });\n         } catch (Exception e) {\n           logger.info(\"Got exception while running command: \" + curlCmd);\n+          if (result != null) {\n+            logger.info(\"result.stdout: \\n {0}\", result.stdout());", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzUyNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503526", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:41:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyODA5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyODgxOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422428818", "bodyText": "Scale the WebLogic cluster to specified number of servers and verify the sample app can be accessed through NGINX.", "author": "sankarpn", "createdAt": "2020-05-09T00:23:00Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzU0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503544", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyODgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyOTA5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422429097", "bodyText": "is the domain cluster will be scaled or domain?", "author": "sankarpn", "createdAt": "2020-05-09T00:24:18Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MzIxMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422453212", "bodyText": "cluster", "author": "xiancao", "createdAt": "2020-05-09T04:56:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyOTA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcxMzQxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422713414", "bodyText": "then the param domainUid description needs to be changed.", "author": "sankarpn", "createdAt": "2020-05-10T23:04:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyOTA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIzMTkxMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423231911", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-11T18:22:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyOTA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyOTE5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422429195", "bodyText": "the namespace in which the domain exists", "author": "sankarpn", "createdAt": "2020-05-09T00:24:46Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled\n+   * @param domainNamespace the domain namespace the domain resides", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzU1OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503559", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyOTE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyOTQ2Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422429467", "bodyText": "This should be logged", "author": "sankarpn", "createdAt": "2020-05-09T00:26:13Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled\n+   * @param domainNamespace the domain namespace the domain resides\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param replicasBeforeScale the replicas of the WebLogic cluster before the scale\n+   * @param numberOfServers the number of servers to be scaled to\n+   * @return the replicas of the WebLogic cluster after the scale\n+   */\n+  private int scaleAndVerifyDomain(String domainUid,\n+                                   String domainNamespace,\n+                                   String clusterName,\n+                                   int replicasBeforeScale,\n+                                   int numberOfServers) {\n+\n+    String manageServerPodNamePrefix = domainUid + \"-\" + clusterName + \"-managed-server\";\n+\n+    // scale the cluster in the domain", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzU2OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503568", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:41:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyOTQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyOTUxNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422429515", "bodyText": "the method name should be scaleCluster?", "author": "sankarpn", "createdAt": "2020-05-09T00:26:31Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled\n+   * @param domainNamespace the domain namespace the domain resides\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param replicasBeforeScale the replicas of the WebLogic cluster before the scale\n+   * @param numberOfServers the number of servers to be scaled to\n+   * @return the replicas of the WebLogic cluster after the scale\n+   */\n+  private int scaleAndVerifyDomain(String domainUid,\n+                                   String domainNamespace,\n+                                   String clusterName,\n+                                   int replicasBeforeScale,\n+                                   int numberOfServers) {\n+\n+    String manageServerPodNamePrefix = domainUid + \"-\" + clusterName + \"-managed-server\";\n+\n+    // scale the cluster in the domain\n+    assertThat(assertDoesNotThrow(() -> scaleDomain(domainUid, domainNamespace, clusterName, numberOfServers)))", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwMzU4Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422503583", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:41:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyOTUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMDEwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422430104", "bodyText": "this message will be printed on a successful scale? If yes then it needs to say \"cluster %s of domain %s in namespace %s scaled to %s(replicasBeforeScale+numberOfServers)\"", "author": "sankarpn", "createdAt": "2020-05-09T00:29:34Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled\n+   * @param domainNamespace the domain namespace the domain resides\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param replicasBeforeScale the replicas of the WebLogic cluster before the scale\n+   * @param numberOfServers the number of servers to be scaled to\n+   * @return the replicas of the WebLogic cluster after the scale\n+   */\n+  private int scaleAndVerifyDomain(String domainUid,\n+                                   String domainNamespace,\n+                                   String clusterName,\n+                                   int replicasBeforeScale,\n+                                   int numberOfServers) {\n+\n+    String manageServerPodNamePrefix = domainUid + \"-\" + clusterName + \"-managed-server\";\n+\n+    // scale the cluster in the domain\n+    assertThat(assertDoesNotThrow(() -> scaleDomain(domainUid, domainNamespace, clusterName, numberOfServers)))\n+        .as(String.format(\"Verify scale the cluster %s of domain %s in namespace %s\",", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1NTgxMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422455812", "bodyText": "no, this message is describing what the assertion does, not a message for a successful run.", "author": "xiancao", "createdAt": "2020-05-09T05:41:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMDEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMDE5Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422430192", "bodyText": "Scaling of cluster failed....", "author": "sankarpn", "createdAt": "2020-05-09T00:30:01Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled\n+   * @param domainNamespace the domain namespace the domain resides\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param replicasBeforeScale the replicas of the WebLogic cluster before the scale\n+   * @param numberOfServers the number of servers to be scaled to\n+   * @return the replicas of the WebLogic cluster after the scale\n+   */\n+  private int scaleAndVerifyDomain(String domainUid,\n+                                   String domainNamespace,\n+                                   String clusterName,\n+                                   int replicasBeforeScale,\n+                                   int numberOfServers) {\n+\n+    String manageServerPodNamePrefix = domainUid + \"-\" + clusterName + \"-managed-server\";\n+\n+    // scale the cluster in the domain\n+    assertThat(assertDoesNotThrow(() -> scaleDomain(domainUid, domainNamespace, clusterName, numberOfServers)))\n+        .as(String.format(\"Verify scale the cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .withFailMessage(String.format(\"can not scale cluster %s of domain %s in namespace %s\",", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwNDAwMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422504003", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMDE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMDQ2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422430464", "bodyText": "Checking....", "author": "sankarpn", "createdAt": "2020-05-09T00:31:32Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled\n+   * @param domainNamespace the domain namespace the domain resides\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param replicasBeforeScale the replicas of the WebLogic cluster before the scale\n+   * @param numberOfServers the number of servers to be scaled to\n+   * @return the replicas of the WebLogic cluster after the scale\n+   */\n+  private int scaleAndVerifyDomain(String domainUid,\n+                                   String domainNamespace,\n+                                   String clusterName,\n+                                   int replicasBeforeScale,\n+                                   int numberOfServers) {\n+\n+    String manageServerPodNamePrefix = domainUid + \"-\" + clusterName + \"-managed-server\";\n+\n+    // scale the cluster in the domain\n+    assertThat(assertDoesNotThrow(() -> scaleDomain(domainUid, domainNamespace, clusterName, numberOfServers)))\n+        .as(String.format(\"Verify scale the cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .withFailMessage(String.format(\"can not scale cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .isTrue();\n+\n+    // generate a curl command to ping the sample app through the ingress controller\n+    curlCmd = generateCurlCmd(clusterName);\n+\n+    // generate the expected server list which should be in the sample app response string\n+    List<String> expectedServerNamesInAppResponse =\n+        generateExpectedServerNamesInAppResponse(clusterName, replicasBeforeScale);\n+    logger.info(\"expected server name list which should be in the sample app response: {0} before scale\",\n+        expectedServerNamesInAppResponse);\n+\n+    if (replicasBeforeScale <= numberOfServers) {\n+\n+      // check that NGINX can access the sample apps from the original managed servers in the domain\n+      logger.info(\"Check that NGINX can access the sample app from the original managed servers in the domain \"", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwNDAyMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422504023", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMDQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMDc1Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422430756", "bodyText": "Verify\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      .as(\"Verify NGINX can access the sample app from the original managed servers in the domain\")\n          \n          \n            \n                      .as(\"NGINX can access the sample app from the original managed servers in the domain\")", "author": "sankarpn", "createdAt": "2020-05-09T00:33:16Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled\n+   * @param domainNamespace the domain namespace the domain resides\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param replicasBeforeScale the replicas of the WebLogic cluster before the scale\n+   * @param numberOfServers the number of servers to be scaled to\n+   * @return the replicas of the WebLogic cluster after the scale\n+   */\n+  private int scaleAndVerifyDomain(String domainUid,\n+                                   String domainNamespace,\n+                                   String clusterName,\n+                                   int replicasBeforeScale,\n+                                   int numberOfServers) {\n+\n+    String manageServerPodNamePrefix = domainUid + \"-\" + clusterName + \"-managed-server\";\n+\n+    // scale the cluster in the domain\n+    assertThat(assertDoesNotThrow(() -> scaleDomain(domainUid, domainNamespace, clusterName, numberOfServers)))\n+        .as(String.format(\"Verify scale the cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .withFailMessage(String.format(\"can not scale cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .isTrue();\n+\n+    // generate a curl command to ping the sample app through the ingress controller\n+    curlCmd = generateCurlCmd(clusterName);\n+\n+    // generate the expected server list which should be in the sample app response string\n+    List<String> expectedServerNamesInAppResponse =\n+        generateExpectedServerNamesInAppResponse(clusterName, replicasBeforeScale);\n+    logger.info(\"expected server name list which should be in the sample app response: {0} before scale\",\n+        expectedServerNamesInAppResponse);\n+\n+    if (replicasBeforeScale <= numberOfServers) {\n+\n+      // check that NGINX can access the sample apps from the original managed servers in the domain\n+      logger.info(\"Check that NGINX can access the sample app from the original managed servers in the domain \"\n+                  + \"while the domain is scaling up.\");\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"Verify NGINX can access the sample app from the original managed servers in the domain\")", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1NjQ2Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422456467", "bodyText": ".as() message is not for a successful assertion.", "author": "xiancao", "createdAt": "2020-05-09T05:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMDc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMTAyMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422431020", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"Check for the new managed server pod {0} is created in namespace {1}\",\n          \n          \n            \n                    logger.info(\"Checking whether the new managed server pod {0} is created in namespace {1}\",", "author": "sankarpn", "createdAt": "2020-05-09T00:34:58Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled\n+   * @param domainNamespace the domain namespace the domain resides\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param replicasBeforeScale the replicas of the WebLogic cluster before the scale\n+   * @param numberOfServers the number of servers to be scaled to\n+   * @return the replicas of the WebLogic cluster after the scale\n+   */\n+  private int scaleAndVerifyDomain(String domainUid,\n+                                   String domainNamespace,\n+                                   String clusterName,\n+                                   int replicasBeforeScale,\n+                                   int numberOfServers) {\n+\n+    String manageServerPodNamePrefix = domainUid + \"-\" + clusterName + \"-managed-server\";\n+\n+    // scale the cluster in the domain\n+    assertThat(assertDoesNotThrow(() -> scaleDomain(domainUid, domainNamespace, clusterName, numberOfServers)))\n+        .as(String.format(\"Verify scale the cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .withFailMessage(String.format(\"can not scale cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .isTrue();\n+\n+    // generate a curl command to ping the sample app through the ingress controller\n+    curlCmd = generateCurlCmd(clusterName);\n+\n+    // generate the expected server list which should be in the sample app response string\n+    List<String> expectedServerNamesInAppResponse =\n+        generateExpectedServerNamesInAppResponse(clusterName, replicasBeforeScale);\n+    logger.info(\"expected server name list which should be in the sample app response: {0} before scale\",\n+        expectedServerNamesInAppResponse);\n+\n+    if (replicasBeforeScale <= numberOfServers) {\n+\n+      // check that NGINX can access the sample apps from the original managed servers in the domain\n+      logger.info(\"Check that NGINX can access the sample app from the original managed servers in the domain \"\n+                  + \"while the domain is scaling up.\");\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"Verify NGINX can access the sample app from the original managed servers in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n+          .isTrue();\n+\n+      // check new managed server pods are created and wait for them to be ready\n+      for (int i = replicasBeforeScale + 1; i <= numberOfServers; i++) {\n+        String manageServerPodName = manageServerPodNamePrefix + i;\n+\n+        // check new managed server pods are created\n+        logger.info(\"Check for the new managed server pod {0} is created in namespace {1}\",", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwNDA1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422504053", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:46:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMTAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMTE5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422431197", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"Wait for the new managed server pod {0} to be ready in namespace {1}\",\n          \n          \n            \n                    logger.info(\"Checking whether the new managed server pod {0} is ready in namespace {1}\",", "author": "sankarpn", "createdAt": "2020-05-09T00:36:02Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled\n+   * @param domainNamespace the domain namespace the domain resides\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param replicasBeforeScale the replicas of the WebLogic cluster before the scale\n+   * @param numberOfServers the number of servers to be scaled to\n+   * @return the replicas of the WebLogic cluster after the scale\n+   */\n+  private int scaleAndVerifyDomain(String domainUid,\n+                                   String domainNamespace,\n+                                   String clusterName,\n+                                   int replicasBeforeScale,\n+                                   int numberOfServers) {\n+\n+    String manageServerPodNamePrefix = domainUid + \"-\" + clusterName + \"-managed-server\";\n+\n+    // scale the cluster in the domain\n+    assertThat(assertDoesNotThrow(() -> scaleDomain(domainUid, domainNamespace, clusterName, numberOfServers)))\n+        .as(String.format(\"Verify scale the cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .withFailMessage(String.format(\"can not scale cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .isTrue();\n+\n+    // generate a curl command to ping the sample app through the ingress controller\n+    curlCmd = generateCurlCmd(clusterName);\n+\n+    // generate the expected server list which should be in the sample app response string\n+    List<String> expectedServerNamesInAppResponse =\n+        generateExpectedServerNamesInAppResponse(clusterName, replicasBeforeScale);\n+    logger.info(\"expected server name list which should be in the sample app response: {0} before scale\",\n+        expectedServerNamesInAppResponse);\n+\n+    if (replicasBeforeScale <= numberOfServers) {\n+\n+      // check that NGINX can access the sample apps from the original managed servers in the domain\n+      logger.info(\"Check that NGINX can access the sample app from the original managed servers in the domain \"\n+                  + \"while the domain is scaling up.\");\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"Verify NGINX can access the sample app from the original managed servers in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n+          .isTrue();\n+\n+      // check new managed server pods are created and wait for them to be ready\n+      for (int i = replicasBeforeScale + 1; i <= numberOfServers; i++) {\n+        String manageServerPodName = manageServerPodNamePrefix + i;\n+\n+        // check new managed server pods are created\n+        logger.info(\"Check for the new managed server pod {0} is created in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkPodCreated(manageServerPodName);\n+\n+        // check new managed server pods are ready\n+        logger.info(\"Wait for the new managed server pod {0} to be ready in namespace {1}\",", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwNDA2Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422504063", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:46:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMTE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMTI2Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422431266", "bodyText": "same as above comment", "author": "sankarpn", "createdAt": "2020-05-09T00:36:25Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled\n+   * @param domainNamespace the domain namespace the domain resides\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param replicasBeforeScale the replicas of the WebLogic cluster before the scale\n+   * @param numberOfServers the number of servers to be scaled to\n+   * @return the replicas of the WebLogic cluster after the scale\n+   */\n+  private int scaleAndVerifyDomain(String domainUid,\n+                                   String domainNamespace,\n+                                   String clusterName,\n+                                   int replicasBeforeScale,\n+                                   int numberOfServers) {\n+\n+    String manageServerPodNamePrefix = domainUid + \"-\" + clusterName + \"-managed-server\";\n+\n+    // scale the cluster in the domain\n+    assertThat(assertDoesNotThrow(() -> scaleDomain(domainUid, domainNamespace, clusterName, numberOfServers)))\n+        .as(String.format(\"Verify scale the cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .withFailMessage(String.format(\"can not scale cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .isTrue();\n+\n+    // generate a curl command to ping the sample app through the ingress controller\n+    curlCmd = generateCurlCmd(clusterName);\n+\n+    // generate the expected server list which should be in the sample app response string\n+    List<String> expectedServerNamesInAppResponse =\n+        generateExpectedServerNamesInAppResponse(clusterName, replicasBeforeScale);\n+    logger.info(\"expected server name list which should be in the sample app response: {0} before scale\",\n+        expectedServerNamesInAppResponse);\n+\n+    if (replicasBeforeScale <= numberOfServers) {\n+\n+      // check that NGINX can access the sample apps from the original managed servers in the domain\n+      logger.info(\"Check that NGINX can access the sample app from the original managed servers in the domain \"\n+                  + \"while the domain is scaling up.\");\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"Verify NGINX can access the sample app from the original managed servers in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n+          .isTrue();\n+\n+      // check new managed server pods are created and wait for them to be ready\n+      for (int i = replicasBeforeScale + 1; i <= numberOfServers; i++) {\n+        String manageServerPodName = manageServerPodNamePrefix + i;\n+\n+        // check new managed server pods are created\n+        logger.info(\"Check for the new managed server pod {0} is created in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkPodCreated(manageServerPodName);\n+\n+        // check new managed server pods are ready\n+        logger.info(\"Wait for the new managed server pod {0} to be ready in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkPodReady(manageServerPodName);\n+\n+        // check new managed server services are created\n+        logger.info(\"Check for the new managed server service {0} is created in namespace {1}\",", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwNDA4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422504082", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMTI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMTM4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422431382", "bodyText": "please see my similar comment above", "author": "sankarpn", "createdAt": "2020-05-09T00:37:07Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled\n+   * @param domainNamespace the domain namespace the domain resides\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param replicasBeforeScale the replicas of the WebLogic cluster before the scale\n+   * @param numberOfServers the number of servers to be scaled to\n+   * @return the replicas of the WebLogic cluster after the scale\n+   */\n+  private int scaleAndVerifyDomain(String domainUid,\n+                                   String domainNamespace,\n+                                   String clusterName,\n+                                   int replicasBeforeScale,\n+                                   int numberOfServers) {\n+\n+    String manageServerPodNamePrefix = domainUid + \"-\" + clusterName + \"-managed-server\";\n+\n+    // scale the cluster in the domain\n+    assertThat(assertDoesNotThrow(() -> scaleDomain(domainUid, domainNamespace, clusterName, numberOfServers)))\n+        .as(String.format(\"Verify scale the cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .withFailMessage(String.format(\"can not scale cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .isTrue();\n+\n+    // generate a curl command to ping the sample app through the ingress controller\n+    curlCmd = generateCurlCmd(clusterName);\n+\n+    // generate the expected server list which should be in the sample app response string\n+    List<String> expectedServerNamesInAppResponse =\n+        generateExpectedServerNamesInAppResponse(clusterName, replicasBeforeScale);\n+    logger.info(\"expected server name list which should be in the sample app response: {0} before scale\",\n+        expectedServerNamesInAppResponse);\n+\n+    if (replicasBeforeScale <= numberOfServers) {\n+\n+      // check that NGINX can access the sample apps from the original managed servers in the domain\n+      logger.info(\"Check that NGINX can access the sample app from the original managed servers in the domain \"\n+                  + \"while the domain is scaling up.\");\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"Verify NGINX can access the sample app from the original managed servers in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n+          .isTrue();\n+\n+      // check new managed server pods are created and wait for them to be ready\n+      for (int i = replicasBeforeScale + 1; i <= numberOfServers; i++) {\n+        String manageServerPodName = manageServerPodNamePrefix + i;\n+\n+        // check new managed server pods are created\n+        logger.info(\"Check for the new managed server pod {0} is created in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkPodCreated(manageServerPodName);\n+\n+        // check new managed server pods are ready\n+        logger.info(\"Wait for the new managed server pod {0} to be ready in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkPodReady(manageServerPodName);\n+\n+        // check new managed server services are created\n+        logger.info(\"Check for the new managed server service {0} is created in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkServiceCreated(manageServerPodName);\n+\n+        // add the new managed server to the list\n+        expectedServerNamesInAppResponse.add(clusterName + \"-managed-server\" + i);\n+\n+      }\n+\n+      // check that NGINX can access the sample apps from new and original managed servers\n+      logger.info(\"Check that NGINX can access the sample app from the new and original managed servers \"", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwNDA5MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422504090", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-09T14:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMTM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMTQ4Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422431486", "bodyText": "this need to be fixed as well.", "author": "sankarpn", "createdAt": "2020-05-09T00:37:43Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled\n+   * @param domainNamespace the domain namespace the domain resides\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param replicasBeforeScale the replicas of the WebLogic cluster before the scale\n+   * @param numberOfServers the number of servers to be scaled to\n+   * @return the replicas of the WebLogic cluster after the scale\n+   */\n+  private int scaleAndVerifyDomain(String domainUid,\n+                                   String domainNamespace,\n+                                   String clusterName,\n+                                   int replicasBeforeScale,\n+                                   int numberOfServers) {\n+\n+    String manageServerPodNamePrefix = domainUid + \"-\" + clusterName + \"-managed-server\";\n+\n+    // scale the cluster in the domain\n+    assertThat(assertDoesNotThrow(() -> scaleDomain(domainUid, domainNamespace, clusterName, numberOfServers)))\n+        .as(String.format(\"Verify scale the cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .withFailMessage(String.format(\"can not scale cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .isTrue();\n+\n+    // generate a curl command to ping the sample app through the ingress controller\n+    curlCmd = generateCurlCmd(clusterName);\n+\n+    // generate the expected server list which should be in the sample app response string\n+    List<String> expectedServerNamesInAppResponse =\n+        generateExpectedServerNamesInAppResponse(clusterName, replicasBeforeScale);\n+    logger.info(\"expected server name list which should be in the sample app response: {0} before scale\",\n+        expectedServerNamesInAppResponse);\n+\n+    if (replicasBeforeScale <= numberOfServers) {\n+\n+      // check that NGINX can access the sample apps from the original managed servers in the domain\n+      logger.info(\"Check that NGINX can access the sample app from the original managed servers in the domain \"\n+                  + \"while the domain is scaling up.\");\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"Verify NGINX can access the sample app from the original managed servers in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n+          .isTrue();\n+\n+      // check new managed server pods are created and wait for them to be ready\n+      for (int i = replicasBeforeScale + 1; i <= numberOfServers; i++) {\n+        String manageServerPodName = manageServerPodNamePrefix + i;\n+\n+        // check new managed server pods are created\n+        logger.info(\"Check for the new managed server pod {0} is created in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkPodCreated(manageServerPodName);\n+\n+        // check new managed server pods are ready\n+        logger.info(\"Wait for the new managed server pod {0} to be ready in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkPodReady(manageServerPodName);\n+\n+        // check new managed server services are created\n+        logger.info(\"Check for the new managed server service {0} is created in namespace {1}\",\n+            manageServerPodName, domainNamespace);\n+        checkServiceCreated(manageServerPodName);\n+\n+        // add the new managed server to the list\n+        expectedServerNamesInAppResponse.add(clusterName + \"-managed-server\" + i);\n+\n+      }\n+\n+      // check that NGINX can access the sample apps from new and original managed servers\n+      logger.info(\"Check that NGINX can access the sample app from the new and original managed servers \"\n+          + \"in the domain after the domain is scaled up.\");\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"Check NGINX can access the sample app from all managed servers in the domain\")", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1NjgzOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422456839", "bodyText": ".as() message is not for a successful assertion.", "author": "xiancao", "createdAt": "2020-05-09T05:57:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMTQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMTkzMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422431932", "bodyText": "what will happen if replicasBeforeScale and numberOfServers are same?", "author": "sankarpn", "createdAt": "2020-05-09T00:40:07Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -628,4 +673,149 @@ private void checkServiceCreated(String serviceName) {\n \n   }\n \n+  /**\n+   * Check pod does not exist.\n+   *\n+   * @param podName pod name to check\n+   */\n+  private void checkPodDoesNotExist(String podName) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be removed in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podDoesNotExist(podName, null, domainNamespace),\n+            String.format(\"Pod %s still exists in namespace %s\", podName, domainNamespace)));\n+  }\n+\n+  /** Scale the WebLogic cluster of the domain to numberOfServers in the specified domain namespace.\n+   *  Verify the pods are created or deleted depending on the numberOfServers. Also verify\n+   *  NGINX can access the sample apps to all the servers after the scale operation.\n+   *\n+   * @param domainUid the domain with domainUid which will be scaled\n+   * @param domainNamespace the domain namespace the domain resides\n+   * @param clusterName the WebLogic cluster name in the domain to be scaled\n+   * @param replicasBeforeScale the replicas of the WebLogic cluster before the scale\n+   * @param numberOfServers the number of servers to be scaled to\n+   * @return the replicas of the WebLogic cluster after the scale\n+   */\n+  private int scaleAndVerifyDomain(String domainUid,\n+                                   String domainNamespace,\n+                                   String clusterName,\n+                                   int replicasBeforeScale,\n+                                   int numberOfServers) {\n+\n+    String manageServerPodNamePrefix = domainUid + \"-\" + clusterName + \"-managed-server\";\n+\n+    // scale the cluster in the domain\n+    assertThat(assertDoesNotThrow(() -> scaleDomain(domainUid, domainNamespace, clusterName, numberOfServers)))\n+        .as(String.format(\"Verify scale the cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .withFailMessage(String.format(\"can not scale cluster %s of domain %s in namespace %s\",\n+            clusterName, domainUid, domainNamespace))\n+        .isTrue();\n+\n+    // generate a curl command to ping the sample app through the ingress controller\n+    curlCmd = generateCurlCmd(clusterName);\n+\n+    // generate the expected server list which should be in the sample app response string\n+    List<String> expectedServerNamesInAppResponse =\n+        generateExpectedServerNamesInAppResponse(clusterName, replicasBeforeScale);\n+    logger.info(\"expected server name list which should be in the sample app response: {0} before scale\",\n+        expectedServerNamesInAppResponse);\n+\n+    if (replicasBeforeScale <= numberOfServers) {\n+\n+      // check that NGINX can access the sample apps from the original managed servers in the domain\n+      logger.info(\"Check that NGINX can access the sample app from the original managed servers in the domain \"\n+                  + \"while the domain is scaling up.\");\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, expectedServerNamesInAppResponse, 50))\n+          .as(\"Verify NGINX can access the sample app from the original managed servers in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n+          .isTrue();\n+\n+      // check new managed server pods are created and wait for them to be ready\n+      for (int i = replicasBeforeScale + 1; i <= numberOfServers; i++) {\n+        String manageServerPodName = manageServerPodNamePrefix + i;", "originalCommit": "35c875933e97df8c643dbc6d314d70f8b61430ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1Njk0MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422456940", "bodyText": "numberOfServers will be the the server number after the scale. Changed the name to replicasAfterScale.", "author": "xiancao", "createdAt": "2020-05-09T05:58:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMTkzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcxNTQ1Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422715457", "bodyText": "no, my question is if replicasBeforeScale == replicasAfterScale\nthen\nString manageServerPodName = manageServerPodNamePrefix + i;\nwon't exist isn't?", "author": "sankarpn", "createdAt": "2020-05-10T23:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMTkzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzEzOTc4Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423139786", "bodyText": "if replicasBeforeScale == replicasAfterScale, it will not go through this for loop.", "author": "xiancao", "createdAt": "2020-05-11T15:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMTkzMg=="}], "type": "inlineReview"}, {"oid": "ee084123713f868a5debbcf0d0c9e31b0569593f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ee084123713f868a5debbcf0d0c9e31b0569593f", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into scaledomain-mii-new-it", "committedDate": "2020-05-09T02:43:28Z", "type": "commit"}, {"oid": "c1451fa04dcceb8a5403026bd9bc53f47167d5d2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c1451fa04dcceb8a5403026bd9bc53f47167d5d2", "message": "fix after Mark and Sankar's comments", "committedDate": "2020-05-09T15:01:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjMyNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422702324", "bodyText": "can you move this method to domain actions section", "author": "vanajamukkara", "createdAt": "2020-05-10T21:23:07Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -68,15 +68,17 @@ public static boolean upgradeOperator(OperatorParams params) {\n   }\n \n   /**\n-   * Makes a REST call to the Operator to scale the domain.\n+   * Scale the cluster of the domain in the specified namespace .\n    *\n-   * @param domainUid domainUid of the domain\n-   * @param clusterName cluster in the domain to scale\n-   * @param numOfServers number of servers to scale upto.\n+   * @param domainUid domainUid of the domain to be scaled\n+   * @param clusterName cluster in the domain to be scaled\n+   * @param numOfServers number of servers to be scaled to.\n    * @return true on success, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n    */\n-  public static boolean scaleDomain(String domainUid, String clusterName, int numOfServers) {\n-    return Operator.scaleDomain(domainUid, clusterName, numOfServers);\n+  public static boolean scaleCluster(String domainUid, String namespace, String clusterName, int numOfServers)", "originalCommit": "c1451fa04dcceb8a5403026bd9bc53f47167d5d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwNDk4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423204984", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-11T17:34:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjMyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMzQ4Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r422703483", "bodyText": "In case of scale up, verify the state of the existing servers has not changed.", "author": "vanajamukkara", "createdAt": "2020-05-10T21:33:29Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -288,81 +299,114 @@ public void testCreateMiiDomain() {\n                 condition.getRemainingTimeInMS()))\n         .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n \n-    // check admin server pod exist\n-    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+    // check admin server pod was created\n+    logger.info(\"Checking that admin server pod {0} was created in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkPodCreated(adminServerPodName);\n \n-    // check managed server pods exists\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodCreated(managedServerPrefix + i);\n-    }\n-\n     // check admin server pod is ready\n-    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+    logger.info(\"Checking that admin server pod {0} is ready in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkPodReady(adminServerPodName);\n \n-    // check managed server pods are ready\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkPodReady(managedServerPrefix + i);\n-    }\n-\n-    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+    // check admin service is created\n+    logger.info(\"Checking that admin service {0} was created in namespace {1}\",\n         adminServerPodName, domainNamespace);\n     checkServiceCreated(adminServerPodName);\n \n-    // check managed server services created\n-    for (int i = 1; i <= replicaCount; i++) {\n-      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n-          managedServerPrefix + i, domainNamespace);\n-      checkServiceCreated(managedServerPrefix + i);\n+    // check the readiness for the managed servers in each cluster\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+      for (int j = 1; j <= replicaCount; j++) {\n+        String managedServerPodName =\n+            domainUid + \"-\" + CLUSTER_NAME_PREFIX + i + managedServerNameBase + j;\n+\n+        // check managed server pod was created\n+        logger.info(\"Checking that managed server pod {0} was created in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodCreated(managedServerPodName);\n+\n+        // check managed server pod is ready\n+        logger.info(\"Checking that managed server pod {0} is ready in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkPodReady(managedServerPodName);\n+\n+        // check managed server service was created\n+        logger.info(\"Checking that managed server service {0} was created in namespace {1}\",\n+            managedServerPodName, domainNamespace);\n+        checkServiceCreated(managedServerPodName);\n+      }\n     }\n   }\n \n   @Test\n   @Order(2)\n-  @DisplayName(\"Create an ingress for a WebLogic domain in the specified domain namespace\")\n+  @DisplayName(\"Create an ingress for each cluster of the WebLogic domain in the specified domain namespace\")\n   public void testCreateIngress() {\n \n-    // create an ingress in domain namespace\n-    assertThat(assertDoesNotThrow(() -> createIngress(domainNamespace, domainUid, clusterName, managedServerPort)))\n-            .as(\"createIngress succeeds\")\n-            .withFailMessage(String.format(\"failed to create an ingress for domain %s in namespace %s\",\n-                domainUid, domainNamespace))\n-            .isTrue();\n-\n-    // check the ingress is created\n-    String ingressName = domainUid + \"-nginx\";\n-    assertThat(assertDoesNotThrow(() -> getIngressList(domainNamespace)))\n-        .as(String.format(\"found the ingress %s in namespace %s\", ingressName, domainNamespace))\n-        .withFailMessage(String.format(\"can not find ingress %s in namespace %s\", ingressName, domainNamespace))\n-        .contains(ingressName);\n-\n-    logger.info(\"ingress is created in namespace {0}\", domainNamespace);\n+    // create an ingress for each cluster of the domain in the domain namespace\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+\n+      String clusterName = CLUSTER_NAME_PREFIX + i;\n+      String ingressName = domainUid + \"-\" + clusterName + \"-nginx\";\n+\n+      logger.info(\"Creating ingress {0} for cluster {1} of domain {2} in namespace {3}\",\n+          ingressName, clusterName, domainUid, domainNamespace);\n+      assertThat(createIngress(ingressName, domainNamespace, domainUid, clusterName,\n+          MANAGED_SERVER_PORT, domainUid + \".\" + clusterName + \".test\"))\n+          .as(\"Test ingress creation succeeds\", ingressName)\n+          .withFailMessage(\"Ingress creation failed for cluster {0} of domain {1} in namespace {2}\",\n+              clusterName, domainUid, domainNamespace)\n+          .isTrue();\n+\n+      // check that the ingress was found in the domain namespace\n+      assertThat(assertDoesNotThrow(() -> listIngresses(domainNamespace)))\n+          .as(\"Test ingress {0} was found in namespace {1}\", ingressName, domainNamespace)\n+          .withFailMessage(\"Ingress {0} was not found in namespace {1}\", ingressName, domainNamespace)\n+          .contains(ingressName);\n+\n+      logger.info(\"Ingress {0} for cluster {1} of domain {2} was found in namespace {3}\",\n+          ingressName, clusterName, domainUid, domainNamespace);\n+    }\n   }\n \n   @Test\n   @Order(3)\n-  @DisplayName(\"Verify the application can be accessed through the ingress controller\")\n-  public void testSampleAppThroughIngressController() {\n+  @DisplayName(\"Verify the application can be accessed through the ingress controller for each cluster in the domain\")\n+  public void testAppAccessThroughIngressController() {\n \n-    List<String> managedServerNames = new ArrayList<>();\n-    for (int i = 1; i <= replicaCount; i++) {\n-      managedServerNames.add(managedServerNameBase + i);\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+      String clusterName = CLUSTER_NAME_PREFIX + i;\n+\n+      List<String> managedServerListBeforeScale =\n+          listManagedServersBeforeScale(clusterName, replicaCount);\n+\n+      // check that NGINX can access the sample apps from all managed servers in the cluster of the domain\n+      curlCmd = generateCurlCmd(clusterName);\n+      assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, managedServerListBeforeScale, 50))\n+          .as(\"Verify NGINX can access the sample app from all managed servers in the domain\")\n+          .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n+          .isTrue();\n     }\n+  }\n \n-    // check that NGINX can access the sample apps from all managed servers in the domain\n-    String curlCmd = String.format(\"curl --silent --noproxy '*' -H 'host: %s' http://%s:%s/sample-war/index.jsp\",\n-        domainUid + \".test\", K8S_NODEPORT_HOST, nodeportshttp);\n-    assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, managedServerNames, 50))\n-        .as(\"NGINX can access the sample app from all managed servers in the domain\")\n-        .withFailMessage(\"NGINX can not access the sample app from one or more of the managed servers\")\n-        .isTrue();\n+  @Test\n+  @Order(4)\n+  @DisplayName(\"Verify scale each cluster of the domain in domain namespace\")\n+  public void testScaleClusters() {\n+\n+    for (int i = 1; i <= NUMBER_OF_CLUSTERS; i++) {\n+\n+      String clusterName = CLUSTER_NAME_PREFIX + i;\n+      int numberOfServers = 2 * i - 1;\n+\n+      // scale cluster-1 to 1 server and cluster-2 to 3 servers\n+      logger.info(\"Scaling cluster {0} of domain {1} in namespace {2} to {3} servers.\",\n+          clusterName, domainUid, domainNamespace, numberOfServers);\n+      scaleAndVerifyCluster(domainUid, domainNamespace, clusterName, replicaCount, numberOfServers);", "originalCommit": "c1451fa04dcceb8a5403026bd9bc53f47167d5d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwNTA1NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423205054", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-11T17:34:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMzQ4Mw=="}], "type": "inlineReview"}, {"oid": "35f38129ebb00a474a98bfd8a513354b86890878", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/35f38129ebb00a474a98bfd8a513354b86890878", "message": "fix with Vanaja's comments", "committedDate": "2020-05-11T17:32:47Z", "type": "commit"}, {"oid": "2fb1b958529a4b781acbcab00f99fc3b5c7d99e9", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2fb1b958529a4b781acbcab00f99fc3b5c7d99e9", "message": "fix with Sankar's comments", "committedDate": "2020-05-11T18:19:21Z", "type": "commit"}, {"oid": "4d5ee88f3365fbdf60ece0c1efdbc1130fec19c1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4d5ee88f3365fbdf60ece0c1efdbc1130fec19c1", "message": "add assertion for pod state during scale", "committedDate": "2020-05-12T01:23:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQyNDA0OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423424049", "bodyText": "This is copied from Pani's junit5-cm branch.", "author": "xiancao", "createdAt": "2020-05-12T02:19:36Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -594,6 +597,24 @@ public static ExecResult execCommand(V1Pod pod, String containerName, boolean re\n     return Exec.exec(pod, containerName, redirectToStdout, command);\n   }\n \n+\n+  // ----------------------   pod  ---------------------------------\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   *\n+   * @param namespace namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod\n+   * @return creationTimestamp from metadata section of the Pod\n+   * @throws ApiException if Kubernetes client API call fails\n+   **/\n+  public static String getPodCreationTimestamp(String namespace, String labelSelector, String podName)\n+      throws ApiException {\n+    return Pod.getPodCreationTimestamp(namespace, labelSelector, podName);\n+  }\n+", "originalCommit": "4d5ee88f3365fbdf60ece0c1efdbc1130fec19c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQyNDMzOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423424338", "bodyText": "This file is copied from Pani's junit5-cm branch.", "author": "xiancao", "createdAt": "2020-05-12T02:20:42Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,75 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.", "originalCommit": "4d5ee88f3365fbdf60ece0c1efdbc1130fec19c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQyNDcyMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423424721", "bodyText": "This method is copied from Pani's junit5-cm branch.", "author": "xiancao", "createdAt": "2020-05-12T02:22:18Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -432,6 +434,48 @@ public static boolean deletePod(String name, String namespace) {\n     return true;\n   }\n \n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   *\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod to return\n+   * @return V1Pod object if found otherwise null\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) throws ApiException {", "originalCommit": "4d5ee88f3365fbdf60ece0c1efdbc1130fec19c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQyNDgwOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423424809", "bodyText": "This method is copied from Pani's junit5-cm branch.", "author": "xiancao", "createdAt": "2020-05-12T02:22:42Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -432,6 +434,48 @@ public static boolean deletePod(String name, String namespace) {\n     return true;\n   }\n \n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   *\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod to return\n+   * @return V1Pod object if found otherwise null\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) throws ApiException {\n+    V1PodList pods = listPods(namespace, labelSelector);\n+    for (var pod : pods.getItems()) {\n+      if (podName.equals(pod.getMetadata().getName())) {\n+        return pod;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   *\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName  name of the pod\n+   * @return creationTimestamp from metadata section of the Pod\n+   * @throws ApiException if Kubernetes client API call fail\n+   */\n+  public static String getPodCreationTimestamp(String namespace, String labelSelector, String podName)", "originalCommit": "4d5ee88f3365fbdf60ece0c1efdbc1130fec19c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc1NjM2OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423756368", "bodyText": "remove the commented out code", "author": "sankarpn", "createdAt": "2020-05-12T13:59:29Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -432,6 +434,48 @@ public static boolean deletePod(String name, String namespace) {\n     return true;\n   }\n \n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   *\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod to return\n+   * @return V1Pod object if found otherwise null\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) throws ApiException {\n+    V1PodList pods = listPods(namespace, labelSelector);\n+    for (var pod : pods.getItems()) {\n+      if (podName.equals(pod.getMetadata().getName())) {\n+        return pod;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   *\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName  name of the pod\n+   * @return creationTimestamp from metadata section of the Pod\n+   * @throws ApiException if Kubernetes client API call fail\n+   */\n+  public static String getPodCreationTimestamp(String namespace, String labelSelector, String podName)\n+      throws ApiException {\n+    DateTimeFormatter dtf = DateTimeFormat.forPattern(\"HHmmss\");\n+    // DateTimeFormatter dtf = DateTimeFormat.forPattern(\"YYYYMMDDHHmmss\");", "originalCommit": "4d5ee88f3365fbdf60ece0c1efdbc1130fec19c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1MjgwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423852804", "bodyText": "I will remove it in my next PR", "author": "xiancao", "createdAt": "2020-05-12T16:03:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc1NjM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc1NjQ0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423756446", "bodyText": "remove the commented out code", "author": "sankarpn", "createdAt": "2020-05-12T13:59:35Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -432,6 +434,48 @@ public static boolean deletePod(String name, String namespace) {\n     return true;\n   }\n \n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   *\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod to return\n+   * @return V1Pod object if found otherwise null\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) throws ApiException {\n+    V1PodList pods = listPods(namespace, labelSelector);\n+    for (var pod : pods.getItems()) {\n+      if (podName.equals(pod.getMetadata().getName())) {\n+        return pod;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   *\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName  name of the pod\n+   * @return creationTimestamp from metadata section of the Pod\n+   * @throws ApiException if Kubernetes client API call fail\n+   */\n+  public static String getPodCreationTimestamp(String namespace, String labelSelector, String podName)\n+      throws ApiException {\n+    DateTimeFormatter dtf = DateTimeFormat.forPattern(\"HHmmss\");\n+    // DateTimeFormatter dtf = DateTimeFormat.forPattern(\"YYYYMMDDHHmmss\");\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    if (pod != null) {\n+      // return pod.getMetadata().getCreationTimestamp().toString();", "originalCommit": "4d5ee88f3365fbdf60ece0c1efdbc1130fec19c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1MzI1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423853253", "bodyText": "I will remove it in my next PR.", "author": "xiancao", "createdAt": "2020-05-12T16:04:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc1NjQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc1NzAxMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423757010", "bodyText": "we don't need the method name prefix since method name will be logged by default in the message", "author": "sankarpn", "createdAt": "2020-05-12T14:00:15Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -432,6 +434,48 @@ public static boolean deletePod(String name, String namespace) {\n     return true;\n   }\n \n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   *\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod to return\n+   * @return V1Pod object if found otherwise null\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) throws ApiException {\n+    V1PodList pods = listPods(namespace, labelSelector);\n+    for (var pod : pods.getItems()) {\n+      if (podName.equals(pod.getMetadata().getName())) {\n+        return pod;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   *\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName  name of the pod\n+   * @return creationTimestamp from metadata section of the Pod\n+   * @throws ApiException if Kubernetes client API call fail\n+   */\n+  public static String getPodCreationTimestamp(String namespace, String labelSelector, String podName)\n+      throws ApiException {\n+    DateTimeFormatter dtf = DateTimeFormat.forPattern(\"HHmmss\");\n+    // DateTimeFormatter dtf = DateTimeFormat.forPattern(\"YYYYMMDDHHmmss\");\n+    V1Pod pod = getPod(namespace, labelSelector, podName);\n+    if (pod != null) {\n+      // return pod.getMetadata().getCreationTimestamp().toString();\n+      return dtf.print(pod.getMetadata().getCreationTimestamp());\n+    } else {\n+      logger.info(\"getPodCreationTimestamp(): Pod doesn't exist\");", "originalCommit": "4d5ee88f3365fbdf60ece0c1efdbc1130fec19c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1MzU1OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423853558", "bodyText": "I will fix it in my next PR.", "author": "xiancao", "createdAt": "2020-05-12T16:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc1NzAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc2MjcyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423762729", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Verify the original managed server pod state is not changed during scaling the cluster.\n          \n          \n            \n               * Verify the original managed server pod state is not changed after scaling.", "author": "sankarpn", "createdAt": "2020-05-12T14:07:46Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Domain.java", "diffHunk": "@@ -85,4 +93,64 @@ public static boolean adminNodePortAccessible(String domainUid, String namespace\n     return true;\n   }\n \n+  /**\n+   * Verify the original managed server pod state is not changed during scaling the cluster.", "originalCommit": "4d5ee88f3365fbdf60ece0c1efdbc1130fec19c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1MzczNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423853737", "bodyText": "I will fix it in my next PR.", "author": "xiancao", "createdAt": "2020-05-12T16:04:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc2MjcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc2MzU2MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423763561", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @return true if the managed server pod state is not change during scaling the cluster, false otherwise\n          \n          \n            \n               * @return true if the managed server pod state is not changed after cluster scaling, false otherwise", "author": "sankarpn", "createdAt": "2020-05-12T14:08:52Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Domain.java", "diffHunk": "@@ -85,4 +93,64 @@ public static boolean adminNodePortAccessible(String domainUid, String namespace\n     return true;\n   }\n \n+  /**\n+   * Verify the original managed server pod state is not changed during scaling the cluster.\n+   * @param podName the name of the managed server pod to check\n+   * @param domainUid the domain uid of the domain in which the managed server pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   * @param podCreationTimestampBeforeScale the managed server pod creation time stamp before the scale\n+   * @return true if the managed server pod state is not change during scaling the cluster, false otherwise", "originalCommit": "4d5ee88f3365fbdf60ece0c1efdbc1130fec19c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1MzgxNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423853815", "bodyText": "I will fix it in my next PR.", "author": "xiancao", "createdAt": "2020-05-12T16:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc2MzU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc2NTE0Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423765143", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                String podCreationTimeStampDuringScale;\n          \n          \n            \n                String podCreationTimeStampAfterScale;", "author": "sankarpn", "createdAt": "2020-05-12T14:10:50Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Domain.java", "diffHunk": "@@ -85,4 +93,64 @@ public static boolean adminNodePortAccessible(String domainUid, String namespace\n     return true;\n   }\n \n+  /**\n+   * Verify the original managed server pod state is not changed during scaling the cluster.\n+   * @param podName the name of the managed server pod to check\n+   * @param domainUid the domain uid of the domain in which the managed server pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   * @param podCreationTimestampBeforeScale the managed server pod creation time stamp before the scale\n+   * @return true if the managed server pod state is not change during scaling the cluster, false otherwise\n+   */\n+  public static boolean podStateNotChangedDuringScalingCluster(String podName,\n+                                                               String domainUid,\n+                                                               String domainNamespace,\n+                                                               String podCreationTimestampBeforeScale) {\n+\n+    // check that the original managed server pod still exists\n+    logger.info(\"Checking that the managed server pod {0} still exists in namespace {1}\",\n+        podName, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> doesPodExist(domainNamespace, domainUid, podName),\n+        String.format(\"podExists failed with ApiException for pod %s in namespace %s\",\n+            podName, domainNamespace)),\n+        String.format(\"pod %s does not exist in namespace %s\", podName, domainNamespace));\n+\n+    // check that the original managed server pod is in ready state\n+    logger.info(\"Checking that the managed server pod {0} is in ready state in namespace {1}\",\n+        podName, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> isPodReady(domainNamespace, domainUid, podName),\n+        String.format(\n+            \"isPodReady failed with ApiException for pod %s in namespace %s\", podName, domainNamespace)),\n+        String.format(\"pod %s is not ready in namespace %s\", podName, domainNamespace));\n+\n+    // check that the original managed server service still exists\n+    logger.info(\"Checking that the managed server service {0} still exists in namespace {1}\",\n+        podName, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> doesServiceExist(podName, null, domainNamespace),\n+        String.format(\"doesServiceExist failed with ApiException for pod %s in namespace %s\",\n+            podName, domainNamespace)),\n+        String.format(\"service %s does not exist in namespace %s\", podName, domainNamespace));\n+\n+    // check the pod timestamp of pod is the same as before\n+    logger.info(\"Checking that the managed server pod creation timestamp is not changed\");\n+    String podCreationTimeStampDuringScale;", "originalCommit": "4d5ee88f3365fbdf60ece0c1efdbc1130fec19c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1MzkxNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423853915", "bodyText": "I will fix it in my next PR.", "author": "xiancao", "createdAt": "2020-05-12T16:05:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc2NTE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc2NTY1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423765653", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (Long.parseLong(podCreationTimestampBeforeScale) != Long.parseLong(podCreationTimeStampDuringScale)) {\n          \n          \n            \n                if (Long.parseLong(podCreationTimestampBeforeScale) != Long.parseLong(podCreationTimeStampAfterScale)) {", "author": "sankarpn", "createdAt": "2020-05-12T14:11:29Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Domain.java", "diffHunk": "@@ -85,4 +93,64 @@ public static boolean adminNodePortAccessible(String domainUid, String namespace\n     return true;\n   }\n \n+  /**\n+   * Verify the original managed server pod state is not changed during scaling the cluster.\n+   * @param podName the name of the managed server pod to check\n+   * @param domainUid the domain uid of the domain in which the managed server pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   * @param podCreationTimestampBeforeScale the managed server pod creation time stamp before the scale\n+   * @return true if the managed server pod state is not change during scaling the cluster, false otherwise\n+   */\n+  public static boolean podStateNotChangedDuringScalingCluster(String podName,\n+                                                               String domainUid,\n+                                                               String domainNamespace,\n+                                                               String podCreationTimestampBeforeScale) {\n+\n+    // check that the original managed server pod still exists\n+    logger.info(\"Checking that the managed server pod {0} still exists in namespace {1}\",\n+        podName, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> doesPodExist(domainNamespace, domainUid, podName),\n+        String.format(\"podExists failed with ApiException for pod %s in namespace %s\",\n+            podName, domainNamespace)),\n+        String.format(\"pod %s does not exist in namespace %s\", podName, domainNamespace));\n+\n+    // check that the original managed server pod is in ready state\n+    logger.info(\"Checking that the managed server pod {0} is in ready state in namespace {1}\",\n+        podName, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> isPodReady(domainNamespace, domainUid, podName),\n+        String.format(\n+            \"isPodReady failed with ApiException for pod %s in namespace %s\", podName, domainNamespace)),\n+        String.format(\"pod %s is not ready in namespace %s\", podName, domainNamespace));\n+\n+    // check that the original managed server service still exists\n+    logger.info(\"Checking that the managed server service {0} still exists in namespace {1}\",\n+        podName, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> doesServiceExist(podName, null, domainNamespace),\n+        String.format(\"doesServiceExist failed with ApiException for pod %s in namespace %s\",\n+            podName, domainNamespace)),\n+        String.format(\"service %s does not exist in namespace %s\", podName, domainNamespace));\n+\n+    // check the pod timestamp of pod is the same as before\n+    logger.info(\"Checking that the managed server pod creation timestamp is not changed\");\n+    String podCreationTimeStampDuringScale;\n+    DateTimeFormatter dtf = DateTimeFormat.forPattern(\"HHmmss\");\n+    V1Pod pod =\n+        assertDoesNotThrow(() -> getPod(domainNamespace, \"\", podName),\n+            String.format(\"getPod failed with ApiException for pod %s in namespace %s\",\n+                podName, domainNamespace));\n+    if (pod != null && pod.getMetadata() != null) {\n+      podCreationTimeStampDuringScale = dtf.print(pod.getMetadata().getCreationTimestamp());\n+    } else {\n+      logger.info(\"Pod doesn't exist or pod metadata is null\");\n+      return false;\n+    }\n+\n+    if (Long.parseLong(podCreationTimestampBeforeScale) != Long.parseLong(podCreationTimeStampDuringScale)) {", "originalCommit": "4d5ee88f3365fbdf60ece0c1efdbc1130fec19c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1NDAxOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423854019", "bodyText": "I will fix it in my next PR.", "author": "xiancao", "createdAt": "2020-05-12T16:05:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc2NTY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc2NTg4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423765882", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      podName, podCreationTimestampBeforeScale, podCreationTimeStampDuringScale);\n          \n          \n            \n                      podName, podCreationTimestampBeforeScale, podCreationTimeStampAfterScale);", "author": "sankarpn", "createdAt": "2020-05-12T14:11:47Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Domain.java", "diffHunk": "@@ -85,4 +93,64 @@ public static boolean adminNodePortAccessible(String domainUid, String namespace\n     return true;\n   }\n \n+  /**\n+   * Verify the original managed server pod state is not changed during scaling the cluster.\n+   * @param podName the name of the managed server pod to check\n+   * @param domainUid the domain uid of the domain in which the managed server pod exists\n+   * @param domainNamespace the domain namespace in which the domain exists\n+   * @param podCreationTimestampBeforeScale the managed server pod creation time stamp before the scale\n+   * @return true if the managed server pod state is not change during scaling the cluster, false otherwise\n+   */\n+  public static boolean podStateNotChangedDuringScalingCluster(String podName,\n+                                                               String domainUid,\n+                                                               String domainNamespace,\n+                                                               String podCreationTimestampBeforeScale) {\n+\n+    // check that the original managed server pod still exists\n+    logger.info(\"Checking that the managed server pod {0} still exists in namespace {1}\",\n+        podName, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> doesPodExist(domainNamespace, domainUid, podName),\n+        String.format(\"podExists failed with ApiException for pod %s in namespace %s\",\n+            podName, domainNamespace)),\n+        String.format(\"pod %s does not exist in namespace %s\", podName, domainNamespace));\n+\n+    // check that the original managed server pod is in ready state\n+    logger.info(\"Checking that the managed server pod {0} is in ready state in namespace {1}\",\n+        podName, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> isPodReady(domainNamespace, domainUid, podName),\n+        String.format(\n+            \"isPodReady failed with ApiException for pod %s in namespace %s\", podName, domainNamespace)),\n+        String.format(\"pod %s is not ready in namespace %s\", podName, domainNamespace));\n+\n+    // check that the original managed server service still exists\n+    logger.info(\"Checking that the managed server service {0} still exists in namespace {1}\",\n+        podName, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> doesServiceExist(podName, null, domainNamespace),\n+        String.format(\"doesServiceExist failed with ApiException for pod %s in namespace %s\",\n+            podName, domainNamespace)),\n+        String.format(\"service %s does not exist in namespace %s\", podName, domainNamespace));\n+\n+    // check the pod timestamp of pod is the same as before\n+    logger.info(\"Checking that the managed server pod creation timestamp is not changed\");\n+    String podCreationTimeStampDuringScale;\n+    DateTimeFormatter dtf = DateTimeFormat.forPattern(\"HHmmss\");\n+    V1Pod pod =\n+        assertDoesNotThrow(() -> getPod(domainNamespace, \"\", podName),\n+            String.format(\"getPod failed with ApiException for pod %s in namespace %s\",\n+                podName, domainNamespace));\n+    if (pod != null && pod.getMetadata() != null) {\n+      podCreationTimeStampDuringScale = dtf.print(pod.getMetadata().getCreationTimestamp());\n+    } else {\n+      logger.info(\"Pod doesn't exist or pod metadata is null\");\n+      return false;\n+    }\n+\n+    if (Long.parseLong(podCreationTimestampBeforeScale) != Long.parseLong(podCreationTimeStampDuringScale)) {\n+      logger.info(\"The creation timestamp of managed server pod {0} is changed from {1} to {2}\",\n+          podName, podCreationTimestampBeforeScale, podCreationTimeStampDuringScale);", "originalCommit": "4d5ee88f3365fbdf60ece0c1efdbc1130fec19c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1NDEyNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1632#discussion_r423854127", "bodyText": "I will fix it in my next PR.", "author": "xiancao", "createdAt": "2020-05-12T16:05:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc2NTg4Mg=="}], "type": "inlineReview"}]}