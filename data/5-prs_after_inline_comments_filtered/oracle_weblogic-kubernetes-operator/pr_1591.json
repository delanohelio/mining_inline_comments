{"pr_number": 1591, "pr_title": "MII ConfigMap Override Usecase in Junit5  ( Ready for Review ) ", "pr_createdAt": "2020-04-24T15:32:08Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591", "timeline": [{"oid": "8656ce5464be05bcd9cefd6a4c7e3787bc1dea41", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8656ce5464be05bcd9cefd6a4c7e3787bc1dea41", "message": "Initial cut for ConfigMap test", "committedDate": "2020-04-22T16:59:31Z", "type": "commit"}, {"oid": "01d320e51e040e5f4a463b21ab88de0617f87ca1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/01d320e51e040e5f4a463b21ab88de0617f87ca1", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm", "committedDate": "2020-04-22T17:00:17Z", "type": "commit"}, {"oid": "5da3bbed7ffa0e2f39816bd476c89aa83a6d509b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5da3bbed7ffa0e2f39816bd476c89aa83a6d509b", "message": "Sync up develop branch", "committedDate": "2020-04-23T14:30:34Z", "type": "commit"}, {"oid": "76aa1ec1c06157b82f46e6927cf0e68ed9de70b2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/76aa1ec1c06157b82f46e6927cf0e68ed9de70b2", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm", "committedDate": "2020-04-23T14:30:40Z", "type": "commit"}, {"oid": "b86874f327e757ee7a6899eed5cd27d36528358c", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b86874f327e757ee7a6899eed5cd27d36528358c", "message": "e2e usease with DataSource verification", "committedDate": "2020-04-24T03:31:28Z", "type": "commit"}, {"oid": "a77be5cb2b80eb04d0676959e4dfe51ae96be7a1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a77be5cb2b80eb04d0676959e4dfe51ae96be7a1", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm", "committedDate": "2020-04-24T14:19:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2OTI1OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414669258", "bodyText": "@IntegrationTEST annotation is missing.", "author": "sankarpn", "createdAt": "2020-04-24T15:34:36Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,587 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+class ItMiiConfigMap implements LoggedTest {", "originalCommit": "b86874f327e757ee7a6899eed5cd27d36528358c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg3NzQwMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414877400", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-04-24T21:36:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2OTI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2OTg4Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414669887", "bodyText": "Use \"@namespaces(1) List namespaces\" in method to get the namespaces for the test. Do not create namespaces in test.", "author": "sankarpn", "createdAt": "2020-04-24T15:35:31Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,587 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  private String domainUid = \"domain1\";\n+  private String repoSecretName = \"reposecret\";\n+  private String miiImage = null;\n+  private String repoRegistry = \"dummy\";\n+  private String repoUserName = \"dummy\";\n+  private String repoPassword = \"dummy\";\n+  private String repoEmail = \"dummy\";\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {", "originalCommit": "b86874f327e757ee7a6899eed5cd27d36528358c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg3NzQ3Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414877472", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-04-24T21:36:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2OTg4Nw=="}], "type": "inlineReview"}, {"oid": "32c8d28c09f372b6b1ad6bdbc8f6e6c706987183", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/32c8d28c09f372b6b1ad6bdbc8f6e6c706987183", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm", "committedDate": "2020-04-24T16:07:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwMzYzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414703635", "bodyText": "General comment:\nQuite a few of the methods in this code look like boilerplate that could be made common to many tests: check*, tear*, and much of init*.", "author": "tbarnes-us", "createdAt": "2020-04-24T16:25:32Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,587 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)", "originalCommit": "b86874f327e757ee7a6899eed5cd27d36528358c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyMzgxNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414823816", "bodyText": "no need to do this, since the extension will do this for you", "author": "markxnelson", "createdAt": "2020-04-24T19:50:44Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,587 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  private String domainUid = \"domain1\";\n+  private String repoSecretName = \"reposecret\";\n+  private String miiImage = null;\n+  private String repoRegistry = \"dummy\";\n+  private String repoUserName = \"dummy\";\n+  private String repoPassword = \"dummy\";\n+  private String repoEmail = \"dummy\";\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    helmList(opHelmParams);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+   *  Once the WebLogic domain is up, verify the DataSource configuration \n+   *  using the RestAPI call thru adminserver public NodePort\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigMapDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null && System.getenv(\"REPO_EMAIL\") != null) {\n+      repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      repoUserName = System.getenv(\"REPO_USERNAME\");\n+      repoPassword = System.getenv(\"REPO_PASSWORD\");\n+      repoEmail = System.getenv(\"REPO_EMAIL\");\n+\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(repoRegistry, repoUserName, repoPassword), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // create docker registry secret in the domain namespace to pull the image from OCIR\n+    JsonObject dockerConfigJsonObject = getDockerConfigJson(\n+        repoUserName, repoPassword, repoEmail, repoRegistry);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(repoSecretName)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", repoSecretName));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", repoSecretName));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()\n+        .withData(data)\n+        .withMetadata(meta)\n+        .build();\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // add domain CR with a predefined configmap in configuration/model section\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(repoSecretName))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .configMap(configMapName)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null; \n+    try {\n+      String hostname = null;\n+      if (System.getenv(\"K8S_NODEPORT_HOST\") == null) {\n+        hostname = InetAddress.getLocalHost().getHostName();\n+      } else {\n+        hostname = System.getenv(\"K8S_NODEPORT_HOST\");\n+      }\n+         \n+      checkJdbc =  new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + hostname + \":30711\")\n+             .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+             .append(\" -o /dev/null\")\n+             .append(\" -w %{http_code});\")\n+             .append(\"echo ${status}\");      \n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc),true);\n+    } catch (java.net.UnknownHostException uhe) {\n+      logger.info(\"UnknownHostException is received {0}\", uhe);\n+      fail(\"Got UnknownHostException\");\n+    } catch (Exception ex) {\n+      logger.info(\"Unexpected exception  {0}\", ex);\n+      fail(\"Got unexpected exception\");\n+    }\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\",result.stdout(),\"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {", "originalCommit": "b86874f327e757ee7a6899eed5cd27d36528358c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA2OTI2MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415069261", "bodyText": "I will update once the extension is available in the develop branch. As per my discussion with @sankarpn his PR is not merged into develop", "author": "anpanigr", "createdAt": "2020-04-25T14:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyMzgxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMyNTM4OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r422325388", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-05-08T19:19:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyMzgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNDIwMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414824203", "bodyText": "remove commented out code please", "author": "markxnelson", "createdAt": "2020-04-24T19:51:25Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,669 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDeleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podTerminating;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";", "originalCommit": "b86874f327e757ee7a6899eed5cd27d36528358c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA2OTMyMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415069321", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-04-25T14:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNDIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNTA2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414825064", "bodyText": "just check the uptime, as per ryan and dongbo's comments in standup", "author": "markxnelson", "createdAt": "2020-04-24T19:52:55Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,669 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDeleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podTerminating;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  private String domainUid = \"domain1\";\n+  private String repoSecretName = \"reposecret\";\n+  private String miiImage = null;\n+  private String repoRegistry = \"dummy\";\n+  private String repoUserName = \"dummy\";\n+  private String repoPassword = \"dummy\";\n+  private String repoEmail = \"dummy\";\n+  private V1Patch patch = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    helmList(opHelmParams);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomainWithConfigMapOverride() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null && System.getenv(\"REPO_EMAIL\") != null) {\n+      repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      repoUserName = System.getenv(\"REPO_USERNAME\");\n+      repoPassword = System.getenv(\"REPO_PASSWORD\");\n+      repoEmail = System.getenv(\"REPO_EMAIL\");\n+\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(repoRegistry, repoUserName, repoPassword), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // create docker registry secret in the domain namespace to pull the image from OCIR\n+    JsonObject dockerConfigJsonObject = getDockerConfigJson(\n+        repoUserName, repoPassword, repoEmail, repoRegistry);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(repoSecretName)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", repoSecretName));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", repoSecretName));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // add domain CR \n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(repoSecretName))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managedserver pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    StringBuffer patchStr  = null;\n+\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()\n+        .withData(data)\n+        .withMetadata(meta)\n+        .build();\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    patchStr  = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+            .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+            .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+            .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() -> \n+        patchDomainCustomResource(domainUid,domainNamespace,patch,\"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr  = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+            .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+            .append(\" \\\"value\\\": \\\"2\\\"\")\n+            .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() -> \n+        patchDomainCustomResource(domainUid,domainNamespace,patch,\"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 60 secs for Introspector to kick off\");\n+    try { \n+      Thread.sleep(60000);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodDeleted(adminServerPodName);", "originalCommit": "b86874f327e757ee7a6899eed5cd27d36528358c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3MDAwNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415070005", "bodyText": "yes. In my latest commit, I added a new action method to get PodCreationTime.  Now the test compares the timestamp before and after rolling re-start to make sure the pod has been re-started by introspector", "author": "anpanigr", "createdAt": "2020-04-25T14:07:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNTA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNTM3OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414825378", "bodyText": "don't need this - the extension will do it", "author": "markxnelson", "createdAt": "2020-04-24T19:53:23Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,669 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDeleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podTerminating;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  private String domainUid = \"domain1\";\n+  private String repoSecretName = \"reposecret\";\n+  private String miiImage = null;\n+  private String repoRegistry = \"dummy\";\n+  private String repoUserName = \"dummy\";\n+  private String repoPassword = \"dummy\";\n+  private String repoEmail = \"dummy\";\n+  private V1Patch patch = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    helmList(opHelmParams);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomainWithConfigMapOverride() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null && System.getenv(\"REPO_EMAIL\") != null) {\n+      repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      repoUserName = System.getenv(\"REPO_USERNAME\");\n+      repoPassword = System.getenv(\"REPO_PASSWORD\");\n+      repoEmail = System.getenv(\"REPO_EMAIL\");\n+\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(repoRegistry, repoUserName, repoPassword), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // create docker registry secret in the domain namespace to pull the image from OCIR\n+    JsonObject dockerConfigJsonObject = getDockerConfigJson(\n+        repoUserName, repoPassword, repoEmail, repoRegistry);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(repoSecretName)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", repoSecretName));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", repoSecretName));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // add domain CR \n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(repoSecretName))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managedserver pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    StringBuffer patchStr  = null;\n+\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()\n+        .withData(data)\n+        .withMetadata(meta)\n+        .build();\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    patchStr  = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+            .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+            .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+            .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() -> \n+        patchDomainCustomResource(domainUid,domainNamespace,patch,\"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr  = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+            .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+            .append(\" \\\"value\\\": \\\"2\\\"\")\n+            .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() -> \n+        patchDomainCustomResource(domainUid,domainNamespace,patch,\"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 60 secs for Introspector to kick off\");\n+    try { \n+      Thread.sleep(60000);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodDeleted(adminServerPodName);\n+    checkPodCreated(adminServerPodName);\n+    checkPodRunning(adminServerPodName);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server pods re-started sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in namespace {1}\",\n+                        managedServerPrefix + i, domainNamespace);\n+      checkPodDeleted(managedServerPrefix + i);\n+      checkPodRunning(managedServerPrefix + i);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null; \n+    try {\n+      String hostname = null;\n+      if (System.getenv(\"K8S_NODEPORT_HOST\") == null) {\n+        hostname = InetAddress.getLocalHost().getHostName();\n+      } else {\n+        hostname = System.getenv(\"K8S_NODEPORT_HOST\");\n+      }\n+      checkJdbc =  new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + hostname + \":30711\")\n+             .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+             .append(\" -o /dev/null\")\n+             .append(\" -w %{http_code});\")\n+             .append(\"echo ${status}\");      \n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc),true);\n+    } catch (java.net.UnknownHostException uhe) {\n+      logger.info(\"UnknownHostException is received {0}\", uhe);\n+      fail(\"Got UnknownHostException\");\n+    } catch (Exception ex) {\n+      logger.info(\"Unexpected exception  {0}\", ex);\n+      fail(\"Got unexpected exception\");\n+    }\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\",result.stdout(),\"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {", "originalCommit": "b86874f327e757ee7a6899eed5cd27d36528358c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkzMTc5MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414931791", "bodyText": "Small clarification -\nAfterEach is needed if multiple tests are in a class and it needs to reset things for the next test.\nIf only one test is in the class, its not needed. Extension will cleanup everything after the last test is done.", "author": "sankarpn", "createdAt": "2020-04-25T00:22:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNTM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkxMDMyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r423910329", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-05-12T17:31:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNTM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNTQ5MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414825490", "bodyText": "don't need this - extension will do it", "author": "markxnelson", "createdAt": "2020-04-24T19:53:36Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,669 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDeleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podTerminating;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  private String domainUid = \"domain1\";\n+  private String repoSecretName = \"reposecret\";\n+  private String miiImage = null;\n+  private String repoRegistry = \"dummy\";\n+  private String repoUserName = \"dummy\";\n+  private String repoPassword = \"dummy\";\n+  private String repoEmail = \"dummy\";\n+  private V1Patch patch = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    helmList(opHelmParams);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomainWithConfigMapOverride() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null && System.getenv(\"REPO_EMAIL\") != null) {\n+      repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      repoUserName = System.getenv(\"REPO_USERNAME\");\n+      repoPassword = System.getenv(\"REPO_PASSWORD\");\n+      repoEmail = System.getenv(\"REPO_EMAIL\");\n+\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(repoRegistry, repoUserName, repoPassword), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // create docker registry secret in the domain namespace to pull the image from OCIR\n+    JsonObject dockerConfigJsonObject = getDockerConfigJson(\n+        repoUserName, repoPassword, repoEmail, repoRegistry);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(repoSecretName)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", repoSecretName));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", repoSecretName));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // add domain CR \n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(repoSecretName))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managedserver pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    StringBuffer patchStr  = null;\n+\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()\n+        .withData(data)\n+        .withMetadata(meta)\n+        .build();\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    patchStr  = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+            .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+            .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+            .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() -> \n+        patchDomainCustomResource(domainUid,domainNamespace,patch,\"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr  = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+            .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+            .append(\" \\\"value\\\": \\\"2\\\"\")\n+            .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() -> \n+        patchDomainCustomResource(domainUid,domainNamespace,patch,\"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 60 secs for Introspector to kick off\");\n+    try { \n+      Thread.sleep(60000);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodDeleted(adminServerPodName);\n+    checkPodCreated(adminServerPodName);\n+    checkPodRunning(adminServerPodName);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server pods re-started sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in namespace {1}\",\n+                        managedServerPrefix + i, domainNamespace);\n+      checkPodDeleted(managedServerPrefix + i);\n+      checkPodRunning(managedServerPrefix + i);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null; \n+    try {\n+      String hostname = null;\n+      if (System.getenv(\"K8S_NODEPORT_HOST\") == null) {\n+        hostname = InetAddress.getLocalHost().getHostName();\n+      } else {\n+        hostname = System.getenv(\"K8S_NODEPORT_HOST\");\n+      }\n+      checkJdbc =  new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + hostname + \":30711\")\n+             .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+             .append(\" -o /dev/null\")\n+             .append(\" -w %{http_code});\")\n+             .append(\"echo ${status}\");      \n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc),true);\n+    } catch (java.net.UnknownHostException uhe) {\n+      logger.info(\"UnknownHostException is received {0}\", uhe);\n+      fail(\"Got UnknownHostException\");\n+    } catch (Exception ex) {\n+      logger.info(\"Unexpected exception  {0}\", ex);\n+      fail(\"Got unexpected exception\");\n+    }\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\",result.stdout(),\"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {", "originalCommit": "b86874f327e757ee7a6899eed5cd27d36528358c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA2OTQ0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415069446", "bodyText": "I will update once the extension is available in the develop branch. As per my discussion with @sankarpn his PR is not merged into develop", "author": "anpanigr", "createdAt": "2020-04-25T14:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNTQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMyNTU1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r422325553", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-05-08T19:19:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNTQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNjA3Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414826077", "bodyText": "are these all common with the other file? consider refactoring", "author": "markxnelson", "createdAt": "2020-04-24T19:54:42Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,669 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createUniqueNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.helmList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.dockerImageExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDeleted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podTerminating;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // operator constants\n+  private static final String OPERATOR_RELEASE_NAME = \"weblogic-operator\";\n+  private static final String OPERATOR_CHART_DIR =\n+      \"../kubernetes/charts/weblogic-operator\";\n+  private static final String OPERATOR_IMAGE =\n+      \"oracle/weblogic-kubernetes-operator:3.0.0\";\n+  //\"phx.ocir.io/weblogick8s/weblogic-kubernetes-operator:develop\";\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  private String domainUid = \"domain1\";\n+  private String repoSecretName = \"reposecret\";\n+  private String miiImage = null;\n+  private String repoRegistry = \"dummy\";\n+  private String repoUserName = \"dummy\";\n+  private String repoPassword = \"dummy\";\n+  private String repoEmail = \"dummy\";\n+  private V1Patch patch = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   */\n+  @BeforeAll\n+  public static void initAll() {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    opNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", opNamespace);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    domainNamespace = assertDoesNotThrow(() -> createUniqueNamespace(),\n+        \"Failed to create unique namespace due to ApiException\");\n+    logger.info(\"Created a new namespace called {0}\", domainNamespace);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(OPERATOR_IMAGE)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases\n+    logger.info(\"List helm releases in namespace {0}\", opNamespace);\n+    helmList(opHelmParams);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomainWithConfigMapOverride() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (System.getenv(\"REPO_REGISTRY\") != null && System.getenv(\"REPO_USERNAME\") != null\n+        && System.getenv(\"REPO_PASSWORD\") != null && System.getenv(\"REPO_EMAIL\") != null) {\n+      repoRegistry = System.getenv(\"REPO_REGISTRY\");\n+      repoUserName = System.getenv(\"REPO_USERNAME\");\n+      repoPassword = System.getenv(\"REPO_PASSWORD\");\n+      repoEmail = System.getenv(\"REPO_EMAIL\");\n+\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(repoRegistry, repoUserName, repoPassword), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // create docker registry secret in the domain namespace to pull the image from OCIR\n+    JsonObject dockerConfigJsonObject = getDockerConfigJson(\n+        repoUserName, repoPassword, repoEmail, repoRegistry);\n+    String dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(repoSecretName)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", repoSecretName));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", repoSecretName));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // add domain CR \n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(repoSecretName))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managedserver pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    StringBuffer patchStr  = null;\n+\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()\n+        .withData(data)\n+        .withMetadata(meta)\n+        .build();\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    patchStr  = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+            .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+            .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+            .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() -> \n+        patchDomainCustomResource(domainUid,domainNamespace,patch,\"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr  = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+            .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+            .append(\" \\\"value\\\": \\\"2\\\"\")\n+            .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() -> \n+        patchDomainCustomResource(domainUid,domainNamespace,patch,\"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 60 secs for Introspector to kick off\");\n+    try { \n+      Thread.sleep(60000);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodDeleted(adminServerPodName);\n+    checkPodCreated(adminServerPodName);\n+    checkPodRunning(adminServerPodName);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server pods re-started sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in namespace {1}\",\n+                        managedServerPrefix + i, domainNamespace);\n+      checkPodDeleted(managedServerPrefix + i);\n+      checkPodRunning(managedServerPrefix + i);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null; \n+    try {\n+      String hostname = null;\n+      if (System.getenv(\"K8S_NODEPORT_HOST\") == null) {\n+        hostname = InetAddress.getLocalHost().getHostName();\n+      } else {\n+        hostname = System.getenv(\"K8S_NODEPORT_HOST\");\n+      }\n+      checkJdbc =  new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + hostname + \":30711\")\n+             .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+             .append(\" -o /dev/null\")\n+             .append(\" -w %{http_code});\")\n+             .append(\"echo ${status}\");      \n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc),true);\n+    } catch (java.net.UnknownHostException uhe) {\n+      logger.info(\"UnknownHostException is received {0}\", uhe);\n+      fail(\"Got UnknownHostException\");\n+    } catch (Exception ex) {\n+      logger.info(\"Unexpected exception  {0}\", ex);\n+      fail(\"Got unexpected exception\");\n+    }\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\",result.stdout(),\"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+  }\n+\n+  @AfterEach\n+  public void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  /**\n+   * Uninstall Operator, delete service account, domain namespace and\n+   * operator namespace.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+    // uninstall operator release\n+    logger.info(\"Uninstall Operator in namespace {0}\", opNamespace);\n+    if (opHelmParams != null) {\n+      uninstallOperator(opHelmParams);\n+    }\n+    // Delete service account from unique opNamespace\n+    logger.info(\"Delete service account in namespace {0}\", opNamespace);\n+    if (serviceAccount != null) {\n+      assertDoesNotThrow(() -> deleteServiceAccount(serviceAccount.getMetadata().getName(),\n+              serviceAccount.getMetadata().getNamespace()),\n+              \"deleteServiceAccount failed with ApiException\");\n+    }\n+    // Delete domain namespaces\n+    logger.info(\"Deleting domain namespace {0}\", domainNamespace);\n+    if (domainNamespace != null) {\n+      assertDoesNotThrow(() -> deleteNamespace(domainNamespace),\n+          \"deleteNamespace failed with ApiException\");\n+      logger.info(\"Deleted namespace: \" + domainNamespace);\n+    }\n+\n+    // Delete opNamespace\n+    logger.info(\"Deleting Operator namespace {0}\", opNamespace);\n+    if (opNamespace != null) {\n+      assertDoesNotThrow(() -> deleteNamespace(opNamespace),\n+          \"deleteNamespace failed with ApiException\");\n+      logger.info(\"Deleted namespace: \" + opNamespace);\n+    }\n+\n+  }\n+\n+  private String createImageAndVerify() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    assertTrue(buildAppArchive(defaultAppParams()\n+        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    final List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap<>();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0}:{1} using model directory {2}\",\n+        MII_IMAGE_NAME, imageTag, MODEL_DIR);\n+    boolean result = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(MII_IMAGE_NAME)\n+            .modelImageTag(imageTag)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertTrue(result, String.format(\"Failed to create the image %s using WebLogic Image Tool\", MII_IMAGE_NAME));\n+\n+    // check image exists\n+    assertTrue(dockerImageExists(MII_IMAGE_NAME, imageTag),\n+        String.format(\"Image %s doesn't exist\", MII_IMAGE_NAME + \":\" + imageTag));\n+\n+    return MII_IMAGE_NAME + \":\" + imageTag;\n+  }\n+\n+\n+  private void checkPodCreated(String podName) {", "originalCommit": "b86874f327e757ee7a6899eed5cd27d36528358c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNjE5OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414826198", "bodyText": "plural", "author": "markxnelson", "createdAt": "2020-04-24T19:54:55Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -359,6 +360,16 @@ public static boolean deleteConfigMap(String name, String namespace) {\n     return ConfigMap.delete(name, namespace);\n   }\n \n+  /**\n+  * List Kubernetes Config Map in a namespace.", "originalCommit": "b86874f327e757ee7a6899eed5cd27d36528358c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg3OTQ0OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414879449", "bodyText": "List Kubernetes Config Map(s) in a namespace.\n@param namespace name of namespace\n@return List of Config Map(s) in a namespace", "author": "anpanigr", "createdAt": "2020-04-24T21:41:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNjE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNjQwNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414826406", "bodyText": "\"has been\" not \"is\"", "author": "markxnelson", "createdAt": "2020-04-24T19:55:21Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -66,6 +65,20 @@\n     };\n   }\n \n+  /**\n+   * Check if a Kubernetes pod is deleted in the given namespace.", "originalCommit": "b86874f327e757ee7a6899eed5cd27d36528358c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA2OTUwOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415069508", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-04-25T14:05:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNjQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNjQ5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414826493", "bodyText": "wasPodDeleted", "author": "markxnelson", "createdAt": "2020-04-24T19:55:32Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -66,6 +65,20 @@\n     };\n   }\n \n+  /**\n+   * Check if a Kubernetes pod is deleted in the given namespace.\n+   *\n+   * @param podName   name of the pod to check for\n+   * @param domainUid UID of WebLogic domain in which the pod exists\n+   * @param namespace in which the pod does not exist\n+   * @return true if the pod does not exist in the namespace otherwise false\n+   */\n+  public static Callable<Boolean> podDeleted(String podName, String domainUid, String namespace) throws ApiException {\n+    return () -> {\n+      return Kubernetes.doesPodDeleted(namespace, domainUid, podName);", "originalCommit": "b86874f327e757ee7a6899eed5cd27d36528358c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA2OTU2OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415069569", "bodyText": "modified the method name", "author": "anpanigr", "createdAt": "2020-04-25T14:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNjQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNzAzMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414827030", "bodyText": "wasPodDeleted is a better name, but this method does not actually test that a pod was deleted, it just just checks that the pod does not exist", "author": "markxnelson", "createdAt": "2020-04-24T19:56:28Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -64,6 +64,29 @@ public static boolean doesPodExist(String namespace, String domainUid, String po\n     return podExist;\n   }\n \n+  /**\n+   * Checks if a pod does not exist in a given namespace in any state.\n+   * @param namespace in which to check for the pod existence\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod does not exists otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean doesPodDeleted(String namespace, String domainUid, String podName) throws ApiException {", "originalCommit": "b86874f327e757ee7a6899eed5cd27d36528358c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5MzQ4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r414893484", "bodyText": "How about changing the method name to doesPodNotExist() in contrast to existing method doesPodExist()", "author": "anpanigr", "createdAt": "2020-04-24T22:16:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNzAzMA=="}], "type": "inlineReview"}, {"oid": "d98c87dd9be96a47c742c9e75dd05d4e46f20607", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d98c87dd9be96a47c742c9e75dd05d4e46f20607", "message": "addressed review comments. added new api to check the pod creation time stamp", "committedDate": "2020-04-25T13:49:31Z", "type": "commit"}, {"oid": "9219701f1b9950ac059774f9a65288b9f9071c2a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9219701f1b9950ac059774f9a65288b9f9071c2a", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm", "committedDate": "2020-04-25T13:49:51Z", "type": "commit"}, {"oid": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/80644934ba8a1b23761d3afc6a9f0ed3290db067", "message": "Modify the logic to check the pod creation time", "committedDate": "2020-04-25T19:26:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1ODM1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415158353", "bodyText": "labelSelector in the format \"weblogic.domainUID in (%s)\" , can be null", "author": "sankarpn", "createdAt": "2020-04-25T22:32:30Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -42,6 +45,40 @@\n // directly call the methods in the impl classes\n public class TestActions {\n \n+  // ----------------------   pod  ---------------------------------\n+  \n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return creationTimestamp from metadata section of the Pod\n+   */\n+  public static String getPodCreationTime(String namespace, String labelSelector, String podName) {\n+    return Pod.getPodCreationTime(namespace,labelSelector,podName);\n+  }\n+ \n+  /**\n+   * Get the Pod object with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2Nzk0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415367946", "bodyText": "Modified the signature to take (Map<String, String> label ) as labelSector Parameter", "author": "anpanigr", "createdAt": "2020-04-26T18:14:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1ODM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1ODM4Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415158387", "bodyText": "labelSelector in the format \"weblogic.domainUID in (%s)\", can be null", "author": "sankarpn", "createdAt": "2020-04-25T22:32:45Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -42,6 +45,40 @@\n // directly call the methods in the impl classes\n public class TestActions {\n \n+  // ----------------------   pod  ---------------------------------\n+  \n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2Nzk4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415367984", "bodyText": "Modified the signature to take (Map<String, String> label ) as labelSector Parameter", "author": "anpanigr", "createdAt": "2020-04-26T18:14:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1ODM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1ODUwMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415158501", "bodyText": "white space between podName,namespace", "author": "sankarpn", "createdAt": "2020-04-25T22:33:28Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -42,6 +45,40 @@\n // directly call the methods in the impl classes\n public class TestActions {\n \n+  // ----------------------   pod  ---------------------------------\n+  \n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return creationTimestamp from metadata section of the Pod\n+   */\n+  public static String getPodCreationTime(String namespace, String labelSelector, String podName) {\n+    return Pod.getPodCreationTime(namespace,labelSelector,podName);\n+  }\n+ \n+  /**\n+   * Get the Pod object with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return V1Pod pod object\n+   **/\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) {\n+    return Pod.getPod(namespace,labelSelector,podName);\n+  }\n+\n+  /**\n+   * Get a pod's log.\n+   * @param podName name of the Pod\n+   * @param namespace name of the Namespace\n+   * @return log as a String\n+   **/\n+  public static String getPodLog(String podName, String namespace) {\n+    return Pod.getPodLog(podName,namespace);", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2ODg5MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415368890", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-04-26T18:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1ODUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1ODU4NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415158585", "bodyText": "Namespace -> namespace", "author": "sankarpn", "createdAt": "2020-04-25T22:33:53Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -42,6 +45,40 @@\n // directly call the methods in the impl classes\n public class TestActions {\n \n+  // ----------------------   pod  ---------------------------------\n+  \n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return creationTimestamp from metadata section of the Pod\n+   */\n+  public static String getPodCreationTime(String namespace, String labelSelector, String podName) {\n+    return Pod.getPodCreationTime(namespace,labelSelector,podName);\n+  }\n+ \n+  /**\n+   * Get the Pod object with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return V1Pod pod object\n+   **/\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) {\n+    return Pod.getPod(namespace,labelSelector,podName);\n+  }\n+\n+  /**\n+   * Get a pod's log.\n+   * @param podName name of the Pod\n+   * @param namespace name of the Namespace", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2OTQ5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415369495", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-04-26T18:22:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1ODU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1ODYyMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415158622", "bodyText": "Pod -> pod", "author": "sankarpn", "createdAt": "2020-04-25T22:34:08Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -42,6 +45,40 @@\n // directly call the methods in the impl classes\n public class TestActions {\n \n+  // ----------------------   pod  ---------------------------------\n+  \n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return creationTimestamp from metadata section of the Pod\n+   */\n+  public static String getPodCreationTime(String namespace, String labelSelector, String podName) {\n+    return Pod.getPodCreationTime(namespace,labelSelector,podName);\n+  }\n+ \n+  /**\n+   * Get the Pod object with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return V1Pod pod object\n+   **/\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) {\n+    return Pod.getPod(namespace,labelSelector,podName);\n+  }\n+\n+  /**\n+   * Get a pod's log.\n+   * @param podName name of the Pod", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2OTU2Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415369567", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-04-26T18:22:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1ODYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1OTE2Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415159166", "bodyText": "Config Maps", "author": "sankarpn", "createdAt": "2020-04-25T22:37:34Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -377,6 +414,16 @@ public static boolean deleteConfigMap(String name, String namespace) {\n     return ConfigMap.delete(name, namespace);\n   }\n \n+  /**\n+  * List Kubernetes Config Map(s) in a namespace.", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2OTgzMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415369833", "bodyText": "Changed to ConfigMaps", "author": "anpanigr", "createdAt": "2020-04-26T18:24:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1OTE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1OTQzOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415159438", "bodyText": "Map -> Maps", "author": "sankarpn", "createdAt": "2020-04-25T22:39:20Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/ConfigMap.java", "diffHunk": "@@ -15,20 +16,35 @@\n    * @param configMap V1ConfigMap object containing config map configuration data\n    * @return true on success\n    * @throws ApiException if Kubernetes client API call fails\n-   */\n+  */\n   public static boolean create(V1ConfigMap configMap) throws ApiException {\n     return Kubernetes.createConfigMap(configMap);\n   }\n \n   /**\n-   /**\n    * Delete Kubernetes Config Map.\n    *\n    * @param name name of the Config Map\n    * @param namespace name of namespace\n    * @return true if successful, false otherwise\n-   */\n+  */\n   public static boolean delete(String name, String namespace) {\n     return Kubernetes.deleteConfigMap(name, namespace);\n   }\n+\n+  /**\n+   * List Kubernetes Config Map in a namesapce.", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM3MDA5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415370095", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-04-26T18:25:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE1OTQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MDA5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415160095", "bodyText": "follow consistent casing, List -> list", "author": "sankarpn", "createdAt": "2020-04-25T22:43:24Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/ConfigMap.java", "diffHunk": "@@ -15,20 +16,35 @@\n    * @param configMap V1ConfigMap object containing config map configuration data\n    * @return true on success\n    * @throws ApiException if Kubernetes client API call fails\n-   */\n+  */\n   public static boolean create(V1ConfigMap configMap) throws ApiException {\n     return Kubernetes.createConfigMap(configMap);\n   }\n \n   /**\n-   /**\n    * Delete Kubernetes Config Map.\n    *\n    * @param name name of the Config Map\n    * @param namespace name of namespace\n    * @return true if successful, false otherwise\n-   */\n+  */\n   public static boolean delete(String name, String namespace) {\n     return Kubernetes.deleteConfigMap(name, namespace);\n   }\n+\n+  /**\n+   * List Kubernetes Config Map in a namesapce.\n+   *\n+   * @param namespace name of namespace\n+   * @return List of Config Maps in a namespace", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM3MDQyNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415370427", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-04-26T18:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MDA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MDk1MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415160950", "bodyText": "Don't catch the exception here. Just return whatever Kubernetes.listConfigMaps(namespace) returns. The test needs to deal with the exception.", "author": "sankarpn", "createdAt": "2020-04-25T22:48:55Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/ConfigMap.java", "diffHunk": "@@ -15,20 +16,35 @@\n    * @param configMap V1ConfigMap object containing config map configuration data\n    * @return true on success\n    * @throws ApiException if Kubernetes client API call fails\n-   */\n+  */\n   public static boolean create(V1ConfigMap configMap) throws ApiException {\n     return Kubernetes.createConfigMap(configMap);\n   }\n \n   /**\n-   /**\n    * Delete Kubernetes Config Map.\n    *\n    * @param name name of the Config Map\n    * @param namespace name of namespace\n    * @return true if successful, false otherwise\n-   */\n+  */\n   public static boolean delete(String name, String namespace) {\n     return Kubernetes.deleteConfigMap(name, namespace);\n   }\n+\n+  /**\n+   * List Kubernetes Config Map in a namesapce.\n+   *\n+   * @param namespace name of namespace\n+   * @return List of Config Maps in a namespace\n+  */\n+  public static V1ConfigMapList list(String namespace) {\n+    V1ConfigMapList retConfigMapList = null;\n+    try {\n+      retConfigMapList = Kubernetes.listConfigMaps(namespace);\n+    } catch (ApiException api) {", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM3MjQ4Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415372483", "bodyText": "Done.  Modified the impl/Kubernetes.java accordingly", "author": "anpanigr", "createdAt": "2020-04-26T18:37:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MDk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTExNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415161114", "bodyText": "can you add some info here , Javadoc.", "author": "sankarpn", "createdAt": "2020-04-25T22:50:03Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM3MzQzNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415373437", "bodyText": "All the methods have Javadoc.", "author": "anpanigr", "createdAt": "2020-04-26T18:42:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTExNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzczOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420513739", "bodyText": "the class does not", "author": "markxnelson", "createdAt": "2020-05-06T02:29:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTI5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415161296", "bodyText": "Pod -> pod", "author": "sankarpn", "createdAt": "2020-04-25T22:51:04Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM4NjA0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415386044", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-04-26T19:47:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTQyMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415161421", "bodyText": "Pod(s) -> pods", "author": "sankarpn", "createdAt": "2020-04-25T22:51:37Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.\n+   *\n+   * @param name name of the pod\n+   * @param namespace name of namespace\n+   * @return true if successful, false otherwise\n+  */\n+  public static boolean deletePod(String name, String namespace) {\n+    return Kubernetes.deletePod(name, namespace);\n+  }\n+\n+  /**\n+   * List Kubernetes Pod(s) in a namesapce.", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM3NDU4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415374582", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-04-26T18:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTU3OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415161579", "bodyText": "do not catch the exception here.", "author": "sankarpn", "createdAt": "2020-04-25T22:52:46Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.\n+   *\n+   * @param name name of the pod\n+   * @param namespace name of namespace\n+   * @return true if successful, false otherwise\n+  */\n+  public static boolean deletePod(String name, String namespace) {\n+    return Kubernetes.deletePod(name, namespace);\n+  }\n+\n+  /**\n+   * List Kubernetes Pod(s) in a namesapce.\n+   *\n+   * @param namespace name of namespace\n+   * @param labelSelectors with which pods are decorated\n+   * @return V1PodList list of pods\n+  */\n+  public static V1PodList listPods(String namespace, String labelSelectors) {\n+    V1PodList retPodList = null;\n+    try {\n+      retPodList = Kubernetes.listPods(namespace,labelSelectors);\n+    } catch (ApiException api) {", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM4NTkzMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415385930", "bodyText": "Removed all the API exception catch in Pod.java", "author": "anpanigr", "createdAt": "2020-04-26T19:47:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTcwMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415161703", "bodyText": "do not catch the exception here.", "author": "sankarpn", "createdAt": "2020-04-25T22:53:28Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.\n+   *\n+   * @param name name of the pod\n+   * @param namespace name of namespace\n+   * @return true if successful, false otherwise\n+  */\n+  public static boolean deletePod(String name, String namespace) {\n+    return Kubernetes.deletePod(name, namespace);\n+  }\n+\n+  /**\n+   * List Kubernetes Pod(s) in a namesapce.\n+   *\n+   * @param namespace name of namespace\n+   * @param labelSelectors with which pods are decorated\n+   * @return V1PodList list of pods\n+  */\n+  public static V1PodList listPods(String namespace, String labelSelectors) {\n+    V1PodList retPodList = null;\n+    try {\n+      retPodList = Kubernetes.listPods(namespace,labelSelectors);\n+    } catch (ApiException api) {\n+      return null;\n+    }\n+    return retPodList;\n+  }\n+\n+  /**\n+   * Get a pod's log.\n+   *  \n+   * @param podName name of the Pod\n+   * @param namespace name of the Namespace\n+   * @return log as a String\n+  */\n+  public static String getPodLog(String podName, String namespace) {\n+    try {\n+      return Kubernetes.getPodLog(podName,namespace);\n+    } catch (ApiException api) {", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM4NTk0NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415385945", "bodyText": "Removed all the API exception catch in Pod.java", "author": "anpanigr", "createdAt": "2020-04-26T19:47:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTcwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTc1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415161753", "bodyText": "Pod -> pod", "author": "sankarpn", "createdAt": "2020-04-25T22:53:45Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.\n+   *\n+   * @param name name of the pod\n+   * @param namespace name of namespace\n+   * @return true if successful, false otherwise\n+  */\n+  public static boolean deletePod(String name, String namespace) {\n+    return Kubernetes.deletePod(name, namespace);\n+  }\n+\n+  /**\n+   * List Kubernetes Pod(s) in a namesapce.\n+   *\n+   * @param namespace name of namespace\n+   * @param labelSelectors with which pods are decorated\n+   * @return V1PodList list of pods\n+  */\n+  public static V1PodList listPods(String namespace, String labelSelectors) {\n+    V1PodList retPodList = null;\n+    try {\n+      retPodList = Kubernetes.listPods(namespace,labelSelectors);\n+    } catch (ApiException api) {\n+      return null;\n+    }\n+    return retPodList;\n+  }\n+\n+  /**\n+   * Get a pod's log.\n+   *  \n+   * @param podName name of the Pod", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM4NTEwNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415385105", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-04-26T19:43:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTg1Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415161856", "bodyText": "labelSelector in the format \"weblogic.domainUID in (%s)\", can be null", "author": "sankarpn", "createdAt": "2020-04-25T22:54:24Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.\n+   *\n+   * @param name name of the pod\n+   * @param namespace name of namespace\n+   * @return true if successful, false otherwise\n+  */\n+  public static boolean deletePod(String name, String namespace) {\n+    return Kubernetes.deletePod(name, namespace);\n+  }\n+\n+  /**\n+   * List Kubernetes Pod(s) in a namesapce.\n+   *\n+   * @param namespace name of namespace\n+   * @param labelSelectors with which pods are decorated\n+   * @return V1PodList list of pods\n+  */\n+  public static V1PodList listPods(String namespace, String labelSelectors) {\n+    V1PodList retPodList = null;\n+    try {\n+      retPodList = Kubernetes.listPods(namespace,labelSelectors);\n+    } catch (ApiException api) {\n+      return null;\n+    }\n+    return retPodList;\n+  }\n+\n+  /**\n+   * Get a pod's log.\n+   *  \n+   * @param podName name of the Pod\n+   * @param namespace name of the Namespace\n+   * @return log as a String\n+  */\n+  public static String getPodLog(String podName, String namespace) {\n+    try {\n+      return Kubernetes.getPodLog(podName,namespace);\n+    } catch (ApiException api) {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM4NTIxMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415385211", "bodyText": "yes, labelSelector can be a null String", "author": "anpanigr", "createdAt": "2020-04-26T19:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MTg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MjA0MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415162040", "bodyText": "do not catch the exception here.", "author": "sankarpn", "createdAt": "2020-04-25T22:55:49Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.\n+   *\n+   * @param name name of the pod\n+   * @param namespace name of namespace\n+   * @return true if successful, false otherwise\n+  */\n+  public static boolean deletePod(String name, String namespace) {\n+    return Kubernetes.deletePod(name, namespace);\n+  }\n+\n+  /**\n+   * List Kubernetes Pod(s) in a namesapce.\n+   *\n+   * @param namespace name of namespace\n+   * @param labelSelectors with which pods are decorated\n+   * @return V1PodList list of pods\n+  */\n+  public static V1PodList listPods(String namespace, String labelSelectors) {\n+    V1PodList retPodList = null;\n+    try {\n+      retPodList = Kubernetes.listPods(namespace,labelSelectors);\n+    } catch (ApiException api) {\n+      return null;\n+    }\n+    return retPodList;\n+  }\n+\n+  /**\n+   * Get a pod's log.\n+   *  \n+   * @param podName name of the Pod\n+   * @param namespace name of the Namespace\n+   * @return log as a String\n+  */\n+  public static String getPodLog(String podName, String namespace) {\n+    try {\n+      return Kubernetes.getPodLog(podName,namespace);\n+    } catch (ApiException api) {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return creationTimestamp from metadata section of the Pod\n+   */\n+  public static String getPodCreationTime(String namespace, String labelSelector, String podName) {\n+    try {\n+      return Kubernetes.getPodCreationTime(namespace,labelSelector,podName);", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM4NTk4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415385989", "bodyText": "Removed all the API exception catch in Pod.java", "author": "anpanigr", "createdAt": "2020-04-26T19:47:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MjA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MjA2Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415162063", "bodyText": "do not catch the exception here.", "author": "sankarpn", "createdAt": "2020-04-25T22:55:55Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.\n+   *\n+   * @param name name of the pod\n+   * @param namespace name of namespace\n+   * @return true if successful, false otherwise\n+  */\n+  public static boolean deletePod(String name, String namespace) {\n+    return Kubernetes.deletePod(name, namespace);\n+  }\n+\n+  /**\n+   * List Kubernetes Pod(s) in a namesapce.\n+   *\n+   * @param namespace name of namespace\n+   * @param labelSelectors with which pods are decorated\n+   * @return V1PodList list of pods\n+  */\n+  public static V1PodList listPods(String namespace, String labelSelectors) {\n+    V1PodList retPodList = null;\n+    try {\n+      retPodList = Kubernetes.listPods(namespace,labelSelectors);\n+    } catch (ApiException api) {\n+      return null;\n+    }\n+    return retPodList;\n+  }\n+\n+  /**\n+   * Get a pod's log.\n+   *  \n+   * @param podName name of the Pod\n+   * @param namespace name of the Namespace\n+   * @return log as a String\n+  */\n+  public static String getPodLog(String podName, String namespace) {\n+    try {\n+      return Kubernetes.getPodLog(podName,namespace);\n+    } catch (ApiException api) {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return creationTimestamp from metadata section of the Pod\n+   */\n+  public static String getPodCreationTime(String namespace, String labelSelector, String podName) {\n+    try {\n+      return Kubernetes.getPodCreationTime(namespace,labelSelector,podName);\n+    } catch (ApiException api) {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Get the Pod object with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod \n+   * @return V1Pod pod object\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) {\n+    try {\n+      V1PodList pods = Kubernetes.listPods(namespace, labelSelector);\n+      for (var pod : pods.getItems()) {\n+        if (podName.equals(pod.getMetadata().getName())) {\n+          return pod;\n+        }\n+      }\n+    } catch (ApiException api) {", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM4NTk5OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415385999", "bodyText": "Removed all the API exception catch in Pod.java", "author": "anpanigr", "createdAt": "2020-04-26T19:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MjA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MjIxMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415162210", "bodyText": "labelSelector in the format \"weblogic.domainUID in (%s)\", can be null", "author": "sankarpn", "createdAt": "2020-04-25T22:56:32Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -257,6 +259,46 @@ public static V1DeploymentList listDeployments(String namespace) {\n   }\n \n   // --------------------------- pods -----------------------------------------\n+  \n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM4NTI1NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415385254", "bodyText": "Modified the signature to take (Map<String, String> label ) as labelSector Parameter", "author": "anpanigr", "createdAt": "2020-04-26T19:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MjIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MjM3NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415162374", "bodyText": "labelSelector in the format \"weblogic.domainUID in (%s)\", can be null", "author": "sankarpn", "createdAt": "2020-04-25T22:57:53Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -257,6 +259,46 @@ public static V1DeploymentList listDeployments(String namespace) {\n   }\n \n   // --------------------------- pods -----------------------------------------\n+  \n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName name of the pod to return\n+   * @return V1Pod object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) throws ApiException {\n+    V1PodList pods = listPods(namespace, labelSelector);\n+    for (var pod : pods.getItems()) {\n+      if (podName.equals(pod.getMetadata().getName())) {\n+        return pod;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"", "originalCommit": "80644934ba8a1b23761d3afc6a9f0ed3290db067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM4NTI5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415385297", "bodyText": "Modified the signature to take (Map<String, String> label ) as labelSector Parameter", "author": "anpanigr", "createdAt": "2020-04-26T19:43:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2MjM3NA=="}], "type": "inlineReview"}, {"oid": "c2ee098d18c9d11c8c1e10443864e364c168c01e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c2ee098d18c9d11c8c1e10443864e364c168c01e", "message": "Resolved more PR review comments", "committedDate": "2020-04-26T19:51:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3NDk4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415474982", "bodyText": "fix javadoc", "author": "vanajamukkara", "createdAt": "2020-04-27T02:53:45Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,603 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism", "originalCommit": "c2ee098d18c9d11c8c1e10443864e364c168c01e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg4NjE4MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415886181", "bodyText": "Now the second sentence reads as follows ...\n@param namespaces list of namespaces created by the IntegrationTestWatcher\nby the JUnit engine parameter resolution mechanism", "author": "anpanigr", "createdAt": "2020-04-27T14:57:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3NDk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg5MTM4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415891389", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-04-27T15:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3NDk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3NzA2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415477064", "bodyText": "no need to use builder, you can do\nV1ObjectMeta meta = new V1ObjectMeta()\n  .labels(labels)\n  .name(configMapName)\n  .namespace(domainNamespace);", "author": "vanajamukkara", "createdAt": "2020-04-27T03:00:47Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,603 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+   *  Once the WebLogic domain is up, verify the DataSource configuration \n+   *  using the RestAPI call thru adminserver public NodePort\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()", "originalCommit": "c2ee098d18c9d11c8c1e10443864e364c168c01e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg5MjE2Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415892167", "bodyText": "Modified the method.", "author": "anpanigr", "createdAt": "2020-04-27T15:04:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3NzA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3NzUyMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415477522", "bodyText": "same here, no need for builder", "author": "vanajamukkara", "createdAt": "2020-04-27T03:02:11Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,603 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+   *  Once the WebLogic domain is up, verify the DataSource configuration \n+   *  using the RestAPI call thru adminserver public NodePort\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()", "originalCommit": "c2ee098d18c9d11c8c1e10443864e364c168c01e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg5MjM5MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415892391", "bodyText": "Modified the method", "author": "anpanigr", "createdAt": "2020-04-27T15:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3NzUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3NzcwNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415477705", "bodyText": "set '0'", "author": "vanajamukkara", "createdAt": "2020-04-27T03:02:56Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,603 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+   *  Once the WebLogic domain is up, verify the DataSource configuration \n+   *  using the RestAPI call thru adminserver public NodePort\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()\n+        .withData(data)\n+        .withMetadata(meta)\n+        .build();\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // Create the domain custom resource with a predefined configmap \n+    // in configuration/model section\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))", "originalCommit": "c2ee098d18c9d11c8c1e10443864e364c168c01e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3OTUwNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415479506", "bodyText": "using hard coded node port does not work if the port is already in use.", "author": "vanajamukkara", "createdAt": "2020-04-27T03:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3NzcwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwNjE4OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r417006188", "bodyText": "Added a method getAdminServiceNodePort() to get the Admin Service NodePort.  Now the test set ZERO as node port value while creating the domain resource.", "author": "anpanigr", "createdAt": "2020-04-29T00:34:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3NzcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3Nzg2Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415477867", "bodyText": "typo resource", "author": "vanajamukkara", "createdAt": "2020-04-27T03:03:25Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,603 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+   *  Once the WebLogic domain is up, verify the DataSource configuration \n+   *  using the RestAPI call thru adminserver public NodePort\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()\n+        .withData(data)\n+        .withMetadata(meta)\n+        .build();\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // Create the domain custom resource with a predefined configmap \n+    // in configuration/model section\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .configMap(configMapName)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUID {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);", "originalCommit": "c2ee098d18c9d11c8c1e10443864e364c168c01e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg5MzA4MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415893081", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-04-27T15:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3Nzg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ4MDU4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415480584", "bodyText": "Add this to TestConstants.java and use K8S_NODEPORT_HOST in place of host name\n  public static final String K8S_NODEPORT_HOST = Optional.ofNullable(System.getenv(\"K8S_NODEPORT_HOST\"))\n      .orElse(InetAddress.getLocalHost().getHostName());", "author": "vanajamukkara", "createdAt": "2020-04-27T03:13:11Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,603 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+   *  Once the WebLogic domain is up, verify the DataSource configuration \n+   *  using the RestAPI call thru adminserver public NodePort\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // Create a ConfigMap with a sparse jdbc model file\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData  = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\",cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMetaBuilder()\n+        .withLabels(labels)\n+        .withName(configMapName)\n+        .withNamespace(domainNamespace)\n+        .build();\n+    V1ConfigMap configMap = new V1ConfigMapBuilder()\n+        .withData(data)\n+        .withMetadata(meta)\n+        .build();\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // Create the domain custom resource with a predefined configmap \n+    // in configuration/model section\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(30711))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .configMap(configMapName)\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUID {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is running\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodRunning(adminServerPodName);\n+\n+    // check managed server pods are running\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodRunning(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null; \n+    try {", "originalCommit": "c2ee098d18c9d11c8c1e10443864e364c168c01e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwNjYwMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r417006602", "bodyText": "Added following varaible to TestConstants.java\npublic static final String K8S_NODEPORT_HOST = System.getenv().getOrDefault(\"K8S_NODEPORT_HOST\",\nSystem.getenv(\"HOST\"));", "author": "anpanigr", "createdAt": "2020-04-29T00:36:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ4MDU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ4MTkyMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415481923", "bodyText": "fix javadoc", "author": "vanajamukkara", "createdAt": "2020-04-27T03:17:59Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,603 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**", "originalCommit": "c2ee098d18c9d11c8c1e10443864e364c168c01e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg5MTYzMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415891630", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-04-27T15:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ4MTkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ4MjQ0NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415482445", "bodyText": "change test method name to testCreateMiiDomainWithConfigMap", "author": "vanajamukkara", "createdAt": "2020-04-27T03:19:42Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,603 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    String operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   *  Deploy a WebLogic domain with a defined configmap \n+   *  in configuration/model section of the domain resource.\n+   *  The configmap has a sparse wdt model file that define a JDBC \n+   *  datasource targeted to the cluster\n+   *  Once the WebLogic domain is up, verify the DataSource configuration \n+   *  using the RestAPI call thru adminserver public NodePort\n+  */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {", "originalCommit": "c2ee098d18c9d11c8c1e10443864e364c168c01e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg4NzI0MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415887240", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-04-27T14:58:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ4MjQ0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg5MTc0NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415891745", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-04-27T15:04:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ4MjQ0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ4NTgzNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r415485836", "bodyText": "Same review comments as the above test, have not reviewed this test yet..", "author": "vanajamukkara", "createdAt": "2020-04-27T03:32:04Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapBuilder;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1ObjectMetaBuilder;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.wasPodDeleted;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {", "originalCommit": "c2ee098d18c9d11c8c1e10443864e364c168c01e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwNzcwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r417007704", "bodyText": "Resolved all issues similar to ItMiiConfigMap.java", "author": "anpanigr", "createdAt": "2020-04-29T00:40:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ4NTgzNg=="}], "type": "inlineReview"}, {"oid": "77c8bc0e0cec78d0ae266c6ccc8cfcbc76f050fa", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/77c8bc0e0cec78d0ae266c6ccc8cfcbc76f050fa", "message": "Resolution to more review comments", "committedDate": "2020-04-27T15:15:47Z", "type": "commit"}, {"oid": "119ce1ff79210ab5ed00673b535f9905fe6552df", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/119ce1ff79210ab5ed00673b535f9905fe6552df", "message": "Added support to get K8s Service Object", "committedDate": "2020-04-27T23:45:46Z", "type": "commit"}, {"oid": "8b29862650ccb0fbfedcd068d5ae327f1247b13b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8b29862650ccb0fbfedcd068d5ae327f1247b13b", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm", "committedDate": "2020-04-27T23:45:57Z", "type": "commit"}, {"oid": "c2f71763bc83235b773f4954bf004c2ca7365075", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c2f71763bc83235b773f4954bf004c2ca7365075", "message": "Modified the getService() logic", "committedDate": "2020-04-28T02:27:28Z", "type": "commit"}, {"oid": "fdc0f5938843fe5d86793512b020a9df6ea40930", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/fdc0f5938843fe5d86793512b020a9df6ea40930", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm", "committedDate": "2020-04-28T15:49:40Z", "type": "commit"}, {"oid": "068ed5936bd1546c52428032f1b5f4d53452a30b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/068ed5936bd1546c52428032f1b5f4d53452a30b", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm", "committedDate": "2020-04-28T15:54:31Z", "type": "commit"}, {"oid": "45d24d6dc3397ec40ba5de363a06d929d8b66e52", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/45d24d6dc3397ec40ba5de363a06d929d8b66e52", "message": "Added support for getAdminNodePort and K8S_NODEPORT_HOST", "committedDate": "2020-04-29T00:25:02Z", "type": "commit"}, {"oid": "05a190cd33ce3a292be74ae9478bdb6be10a3e42", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/05a190cd33ce3a292be74ae9478bdb6be10a3e42", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm", "committedDate": "2020-04-29T00:25:13Z", "type": "commit"}, {"oid": "5325aa4567f379a0ccb384cd0c25dd4e9a44d508", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5325aa4567f379a0ccb384cd0c25dd4e9a44d508", "message": "Code format using intelij", "committedDate": "2020-04-29T23:55:36Z", "type": "commit"}, {"oid": "203a79a89e14b4e07a97c546e94d4db5b434500f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/203a79a89e14b4e07a97c546e94d4db5b434500f", "message": "Sync up develop branch", "committedDate": "2020-05-01T23:55:26Z", "type": "commit"}, {"oid": "84a42c35d64b9477e9d4d17ec12be742def63bb0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/84a42c35d64b9477e9d4d17ec12be742def63bb0", "message": "Syncup develop branch", "committedDate": "2020-05-04T15:03:42Z", "type": "commit"}, {"oid": "60faefa0a4d2f589f7a1573b7ab7c4a65e5d234b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/60faefa0a4d2f589f7a1573b7ab7c4a65e5d234b", "message": "Uddate to javadoc", "committedDate": "2020-05-05T16:21:59Z", "type": "commit"}, {"oid": "3d897a07beb2df97f491e21d7023b22980df588d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3d897a07beb2df97f491e21d7023b22980df588d", "message": "Sync up develop branch", "committedDate": "2020-05-05T17:12:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MDg4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420290889", "bodyText": "Sankar's changes are in, so we should remove this.", "author": "rjeberhard", "createdAt": "2020-05-05T17:41:45Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource\n+   * The ConfigMap has a sparse wdt model file that define a JDBC DataSource \n+   * targeted to the cluster\n+   * Once the WebLogic domain is up, verify the DataSource configuration\n+   * using the RestAPI call thru adminserver's  public NodePort\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigMapDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount, configMapName);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    try {\n+      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null \")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0MDMyNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420540327", "bodyText": "@rjeberhard the tearDown method here is cleaning the images used by the tests. We are not deleting any images in the cleanup cycle, so this is needed here.", "author": "sankarpn", "createdAt": "2020-05-06T04:35:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MDg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTcxMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420291713", "bodyText": "409 means \"conflict\".  A change has been made since the last time you read the resource.  It's an optimistic locking  failure.", "author": "rjeberhard", "createdAt": "2020-05-05T17:43:05Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource\n+   * The ConfigMap has a sparse wdt model file that define a JDBC DataSource \n+   * targeted to the cluster\n+   * Once the WebLogic domain is up, verify the DataSource configuration\n+   * using the RestAPI call thru adminserver's  public NodePort\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigMapDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount, configMapName);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    try {\n+      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null \")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  private String createImageAndVerify() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageName = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? MII_IMAGE_NAME : REPO_NAME + MII_IMAGE_NAME;\n+    final String image = imageName + \":\" + imageTag;\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    assertTrue(buildAppArchive(defaultAppParams()\n+        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    final List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap<>();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0} using model directory {1}\", image, MODEL_DIR);\n+    boolean result = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(imageTag)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertTrue(result, String.format(\"Failed to create the image %s using WebLogic Image Tool\", image));\n+\n+    /* Check image exists using docker images | grep image tag.\n+     * Tag name is unique as it contains date and timestamp.\n+     * This is a workaround for the issue on Jenkins machine\n+     * as docker images imagename:imagetag is not working and\n+     * the test fails even though the image exists.\n+     */\n+    assertTrue(doesImageExist(imageTag),\n+        String.format(\"Image %s doesn't exist\", image));\n+\n+    return image;\n+  }\n+\n+  private void createRepoSecret(String domNamespace) throws ApiException {\n+    V1Secret repoSecret = new V1Secret()\n+            .metadata(new V1ObjectMeta()\n+                    .name(REPO_SECRET_NAME)\n+                    .namespace(domNamespace))\n+            .type(\"kubernetes.io/dockerconfigjson\")\n+            .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = false;\n+    try {\n+      secretCreated = createSecret(repoSecret);\n+    } catch (ApiException e) {\n+      logger.info(\"Exception when calling CoreV1Api#createNamespacedSecret\");\n+      logger.info(\"Status code: \" + e.getCode());\n+      logger.info(\"Reason: \" + e.getResponseBody());\n+      logger.info(\"Response headers: \" + e.getResponseHeaders());\n+      //409 means that the secret already exists - it is not an error, so can proceed", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NTk0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420475944", "bodyText": "we already have a method to check if a pod exist doesPodExist() , why not use that and negate the results?", "author": "sankarpn", "createdAt": "2020-05-05T23:57:07Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -64,6 +64,29 @@ public static boolean doesPodExist(String namespace, String domainUid, String po\n     return podExist;\n   }\n \n+  /**\n+   * Checks if a pod does not exist in a given namespace in any state.\n+   * @param namespace in which to check for the pod existence\n+   * @param domainUid the label the pod is decorated with\n+   * @param podName name of the pod to check for\n+   * @return true if pod does not exists otherwise false\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static boolean doesPodNotExist(String namespace, String domainUid, String podName) throws ApiException {", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg2NDMxMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420864310", "bodyText": "I removed the method in my latest commit", "author": "anpanigr", "createdAt": "2020-05-06T15:03:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NTk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NzExMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420477110", "bodyText": "Can we not use this method for any server to get the service node port?", "author": "sankarpn", "createdAt": "2020-05-06T00:01:11Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1406,8 +1446,87 @@ public static V1ServiceList listServices(String namespace) {\n     }\n   }\n \n-  // --------------------------- jobs ---------------------------\n+  /**\n+   * Get V1Service object for the given service name, label and namespace.\n+   *\n+   * @param serviceName name of the service to look for\n+   * @param label  key value pair with which the service is decorated with\n+   * @param namespace namespace in which to check for the service\n+   * @return V1Service object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Service getService(\n+      String serviceName, Map<String, String> label, String namespace)\n+      throws ApiException {\n+    String labelSelector = null;\n+    if (label != null) {\n+      String key = label.keySet().iterator().next().toString();\n+      String value = label.get(key).toString();\n+      labelSelector = String.format(\"%s in (%s)\", key, value);\n+      logger.info(labelSelector);\n+    }\n+    V1ServiceList v1ServiceList\n+        = coreV1Api.listServiceForAllNamespaces(\n+        Boolean.FALSE, // allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+        null, // continue to query when there is more results to return.\n+        null, // selector to restrict the list of returned objects by their fields\n+        labelSelector, // selector to restrict the list of returned objects by their labels.\n+        null, // maximum number of responses to return for a list call.\n+        Boolean.FALSE.toString(), // pretty print output.\n+        null, // shows changes that occur after that particular version of a resource.\n+        null, // Timeout for the list/watch call.\n+        Boolean.FALSE // Watch for changes to the described resources.\n+    );\n+    for (V1Service service : v1ServiceList.getItems()) {\n+      if (service.getMetadata().getName().equals(serviceName.trim())\n+          && service.getMetadata().getNamespace().equals(namespace.trim())) {\n+        logger.info(\"Service Name : \" + service.getMetadata().getName());\n+        logger.info(\"Service Namespace : \" + service.getMetadata().getNamespace());\n+        Map<String, String> labels = service.getMetadata().getLabels();\n+        if (labels != null) {\n+          for (Map.Entry<String, String> entry : labels.entrySet()) {\n+            logger.log(Level.INFO, \"Label Key: {0} Label Value: {1}\",\n+                new Object[]{entry.getKey(), entry.getValue()});\n+          }\n+        }\n+        return service;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Returns NodePort of a admin server service.\n+   *\n+   * @param serviceName name of admin server service\n+   * @param label key value pair with which the service is decorated with\n+   * @param namespace namespace in which to check for the service\n+   * @return AdminNodePort of the Kubernetes service if exits else -1\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static int getAdminServiceNodePort(", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg3MTAxNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420871017", "bodyText": "It can be made generic, but in the case of WebLogic operator, only admin server service has the node port with a name \"default\".  This method is looking at the node port named as \"default\"", "author": "anpanigr", "createdAt": "2020-05-06T15:12:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NzExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3Nzc5Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420477792", "bodyText": "exits -> exists", "author": "sankarpn", "createdAt": "2020-05-06T00:03:35Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1406,8 +1446,87 @@ public static V1ServiceList listServices(String namespace) {\n     }\n   }\n \n-  // --------------------------- jobs ---------------------------\n+  /**\n+   * Get V1Service object for the given service name, label and namespace.\n+   *\n+   * @param serviceName name of the service to look for\n+   * @param label  key value pair with which the service is decorated with\n+   * @param namespace namespace in which to check for the service\n+   * @return V1Service object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Service getService(\n+      String serviceName, Map<String, String> label, String namespace)\n+      throws ApiException {\n+    String labelSelector = null;\n+    if (label != null) {\n+      String key = label.keySet().iterator().next().toString();\n+      String value = label.get(key).toString();\n+      labelSelector = String.format(\"%s in (%s)\", key, value);\n+      logger.info(labelSelector);\n+    }\n+    V1ServiceList v1ServiceList\n+        = coreV1Api.listServiceForAllNamespaces(\n+        Boolean.FALSE, // allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+        null, // continue to query when there is more results to return.\n+        null, // selector to restrict the list of returned objects by their fields\n+        labelSelector, // selector to restrict the list of returned objects by their labels.\n+        null, // maximum number of responses to return for a list call.\n+        Boolean.FALSE.toString(), // pretty print output.\n+        null, // shows changes that occur after that particular version of a resource.\n+        null, // Timeout for the list/watch call.\n+        Boolean.FALSE // Watch for changes to the described resources.\n+    );\n+    for (V1Service service : v1ServiceList.getItems()) {\n+      if (service.getMetadata().getName().equals(serviceName.trim())\n+          && service.getMetadata().getNamespace().equals(namespace.trim())) {\n+        logger.info(\"Service Name : \" + service.getMetadata().getName());\n+        logger.info(\"Service Namespace : \" + service.getMetadata().getNamespace());\n+        Map<String, String> labels = service.getMetadata().getLabels();\n+        if (labels != null) {\n+          for (Map.Entry<String, String> entry : labels.entrySet()) {\n+            logger.log(Level.INFO, \"Label Key: {0} Label Value: {1}\",\n+                new Object[]{entry.getKey(), entry.getValue()});\n+          }\n+        }\n+        return service;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Returns NodePort of a admin server service.\n+   *\n+   * @param serviceName name of admin server service\n+   * @param label key value pair with which the service is decorated with\n+   * @param namespace namespace in which to check for the service\n+   * @return AdminNodePort of the Kubernetes service if exits else -1", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg3MTY0Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420871647", "bodyText": "modified", "author": "anpanigr", "createdAt": "2020-05-06T15:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3Nzc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3ODQ4Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420478486", "bodyText": "check for empty port list too.", "author": "sankarpn", "createdAt": "2020-05-06T00:05:56Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1406,8 +1446,87 @@ public static V1ServiceList listServices(String namespace) {\n     }\n   }\n \n-  // --------------------------- jobs ---------------------------\n+  /**\n+   * Get V1Service object for the given service name, label and namespace.\n+   *\n+   * @param serviceName name of the service to look for\n+   * @param label  key value pair with which the service is decorated with\n+   * @param namespace namespace in which to check for the service\n+   * @return V1Service object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Service getService(\n+      String serviceName, Map<String, String> label, String namespace)\n+      throws ApiException {\n+    String labelSelector = null;\n+    if (label != null) {\n+      String key = label.keySet().iterator().next().toString();\n+      String value = label.get(key).toString();\n+      labelSelector = String.format(\"%s in (%s)\", key, value);\n+      logger.info(labelSelector);\n+    }\n+    V1ServiceList v1ServiceList\n+        = coreV1Api.listServiceForAllNamespaces(\n+        Boolean.FALSE, // allowWatchBookmarks requests watch events with type \"BOOKMARK\".\n+        null, // continue to query when there is more results to return.\n+        null, // selector to restrict the list of returned objects by their fields\n+        labelSelector, // selector to restrict the list of returned objects by their labels.\n+        null, // maximum number of responses to return for a list call.\n+        Boolean.FALSE.toString(), // pretty print output.\n+        null, // shows changes that occur after that particular version of a resource.\n+        null, // Timeout for the list/watch call.\n+        Boolean.FALSE // Watch for changes to the described resources.\n+    );\n+    for (V1Service service : v1ServiceList.getItems()) {\n+      if (service.getMetadata().getName().equals(serviceName.trim())\n+          && service.getMetadata().getNamespace().equals(namespace.trim())) {\n+        logger.info(\"Service Name : \" + service.getMetadata().getName());\n+        logger.info(\"Service Namespace : \" + service.getMetadata().getNamespace());\n+        Map<String, String> labels = service.getMetadata().getLabels();\n+        if (labels != null) {\n+          for (Map.Entry<String, String> entry : labels.entrySet()) {\n+            logger.log(Level.INFO, \"Label Key: {0} Label Value: {1}\",\n+                new Object[]{entry.getKey(), entry.getValue()});\n+          }\n+        }\n+        return service;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Returns NodePort of a admin server service.\n+   *\n+   * @param serviceName name of admin server service\n+   * @param label key value pair with which the service is decorated with\n+   * @param namespace namespace in which to check for the service\n+   * @return AdminNodePort of the Kubernetes service if exits else -1\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static int getAdminServiceNodePort(\n+      String serviceName,\n+      Map<String, String> label,\n+      String namespace) throws ApiException {\n \n+    V1Service service = getService(serviceName, label, namespace);\n+    if (service == null) {", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg3NTIzOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420875239", "bodyText": "Added an extra check for Null PortList\nList portList = v1ServiceSpec.getPorts();\nif (portList == null) {\nlogger.info(\"Got NULL portList for service ${0} in namespace ${1}\", serviceName, namespace);\nreturn -1;\n}", "author": "anpanigr", "createdAt": "2020-05-06T15:17:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3ODQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MDgyMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420480820", "bodyText": "there is a name spaced list method for service. So you don't need to iterate through the service object to match the  namespace.\ncoreV1Api.listNamespacedService(......)", "author": "sankarpn", "createdAt": "2020-05-06T00:14:16Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1406,8 +1446,87 @@ public static V1ServiceList listServices(String namespace) {\n     }\n   }\n \n-  // --------------------------- jobs ---------------------------\n+  /**\n+   * Get V1Service object for the given service name, label and namespace.\n+   *\n+   * @param serviceName name of the service to look for\n+   * @param label  key value pair with which the service is decorated with\n+   * @param namespace namespace in which to check for the service\n+   * @return V1Service object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Service getService(\n+      String serviceName, Map<String, String> label, String namespace)\n+      throws ApiException {\n+    String labelSelector = null;\n+    if (label != null) {\n+      String key = label.keySet().iterator().next().toString();\n+      String value = label.get(key).toString();\n+      labelSelector = String.format(\"%s in (%s)\", key, value);\n+      logger.info(labelSelector);\n+    }\n+    V1ServiceList v1ServiceList", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg5MDM2OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420890369", "bodyText": "Anyhow I have to loop thru all the service(s)  in a  namesapce even if i use coreV1Api.listNamespacedService(...)", "author": "anpanigr", "createdAt": "2020-05-06T15:37:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MDgyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxMjI0OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420912249", "bodyText": "Yes , but one less check for namespace", "author": "sankarpn", "createdAt": "2020-05-06T16:07:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MDgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MjUwNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420482505", "bodyText": "why are you throwing a null here instead of the original ApiException ?", "author": "sankarpn", "createdAt": "2020-05-06T00:20:10Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -454,7 +494,7 @@ public static V1PodList listPods(String namespace, String labelSelectors) throws\n           );\n     } catch (ApiException apex) {\n       logger.severe(apex.getResponseBody());\n-      throw apex;\n+      throw null;", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxNDMzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420514335", "bodyText": "what does it even mean to throw a null :)", "author": "markxnelson", "createdAt": "2020-05-06T02:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MjUwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxNDM5NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420514394", "bodyText": "does it mean you didn't throw at all?", "author": "markxnelson", "createdAt": "2020-05-06T02:32:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MjUwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxNDQ1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420514453", "bodyText": "if two nulls are thrown in an empty wood, and noone was there to see it.....", "author": "markxnelson", "createdAt": "2020-05-06T02:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MjUwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5ODk0Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420998943", "bodyText": "revert the logic to throw ApiException\n} catch (ApiException apex) {\nlogger.severe(apex.getResponseBody());\nthrow apex;\n}", "author": "anpanigr", "createdAt": "2020-05-06T18:21:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MjUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4Mjk5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420482993", "bodyText": "Get the creationTimestamp of a pod", "author": "sankarpn", "createdAt": "2020-05-06T00:21:54Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -428,15 +430,53 @@ public static boolean deletePod(String name, String namespace) {\n     return true;\n   }\n \n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   *\n+   * @param namespace     in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName       name of the pod to return\n+   * @return V1Pod object if found otherwise null\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) {\n+    V1PodList pods = listPods(namespace, labelSelector);\n+    for (var pod : pods.getItems()) {\n+      if (podName.equals(pod.getMetadata().getName())) {\n+        return pod;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MzQ2OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420483469", "bodyText": "Are there any reason you are returning a String instead of DateTime ?", "author": "sankarpn", "createdAt": "2020-05-06T00:23:36Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -428,15 +430,53 @@ public static boolean deletePod(String name, String namespace) {\n     return true;\n   }\n \n+  /**\n+   * Returns the V1Pod object given the following parameters.\n+   *\n+   * @param namespace     in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName       name of the pod to return\n+   * @return V1Pod object if found otherwise null\n+   */\n+  public static V1Pod getPod(String namespace, String labelSelector, String podName) {\n+    V1PodList pods = listPods(namespace, labelSelector);\n+    for (var pod : pods.getItems()) {\n+      if (podName.equals(pod.getMetadata().getName())) {\n+        return pod;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   *\n+   * @param namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"\n+   * @param podName  name of the pod\n+   * @return creationTimestamp from metadata section of the Pod\n+   */\n+  public static String getPodCreationTimestamp(String namespace, String labelSelector, String podName) {", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5NTg1NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420995854", "bodyText": "It is easy to compare the timestamp after I convert it to Long", "author": "anpanigr", "createdAt": "2020-05-06T18:16:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MzQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDYxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420510614", "bodyText": "operator - no capital", "author": "markxnelson", "createdAt": "2020-05-06T02:16:16Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAxNzQxOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421017419", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-05-06T18:52:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDc4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420510784", "bodyText": "start sentence with capital", "author": "markxnelson", "createdAt": "2020-05-06T02:16:59Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDg0Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420510842", "bodyText": "actually this sentence makes no sense", "author": "markxnelson", "createdAt": "2020-05-06T02:17:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMzk0Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421033943", "bodyText": "Reformatted the sentences\n\nDeploy a WebLogic domain with a defined ConfigMap in configuration/model section of the domain resource.\nThe ConfigMap has a sparse WDT model file that defines a JDBC DataSource targeted to the cluster.\nOnce the WebLogic domain is up, verify the DataSource configuration using the RestAPI call using adminserver's public NodePort", "author": "anpanigr", "createdAt": "2020-05-06T19:20:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDg2Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420510867", "bodyText": "WDT", "author": "markxnelson", "createdAt": "2020-05-06T02:17:20Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource\n+   * The ConfigMap has a sparse wdt model file that define a JDBC DataSource ", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzNTE3Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421035177", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-05-06T19:22:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDk0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420510946", "bodyText": "remove extraneous space", "author": "markxnelson", "createdAt": "2020-05-06T02:17:42Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource\n+   * The ConfigMap has a sparse wdt model file that define a JDBC DataSource \n+   * targeted to the cluster\n+   * Once the WebLogic domain is up, verify the DataSource configuration\n+   * using the RestAPI call thru adminserver's  public NodePort", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzOTM0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421039344", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-05-06T19:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTA1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511053", "bodyText": "OCIR -> registry\nyou don't know it is OCIR", "author": "markxnelson", "createdAt": "2020-05-06T02:18:04Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource\n+   * The ConfigMap has a sparse wdt model file that define a JDBC DataSource \n+   * targeted to the cluster\n+   * Once the WebLogic domain is up, verify the DataSource configuration\n+   * using the RestAPI call thru adminserver's  public NodePort\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigMapDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0Mjc5MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421042790", "bodyText": "These are boilerplate code from the e2e usecase MiiDomain.java.  I am changing into the registry", "author": "anpanigr", "createdAt": "2020-05-06T19:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTA3MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511071", "bodyText": "ditto", "author": "markxnelson", "createdAt": "2020-05-06T02:18:10Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource\n+   * The ConfigMap has a sparse wdt model file that define a JDBC DataSource \n+   * targeted to the cluster\n+   * Once the WebLogic domain is up, verify the DataSource configuration\n+   * using the RestAPI call thru adminserver's  public NodePort\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigMapDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0NTAzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421045035", "bodyText": "modified OCIR to registry", "author": "anpanigr", "createdAt": "2020-05-06T19:40:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTA3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTI3Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511277", "bodyText": "pick a spelling and be consistent - curl, CURL, Curl ...", "author": "markxnelson", "createdAt": "2020-05-06T02:19:04Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource\n+   * The ConfigMap has a sparse wdt model file that define a JDBC DataSource \n+   * targeted to the cluster\n+   * Once the WebLogic domain is up, verify the DataSource configuration\n+   * using the RestAPI call thru adminserver's  public NodePort\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigMapDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount, configMapName);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    try {\n+      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null \")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"CURL command {0}\", new String(checkJdbc));", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0NjQ4Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421046486", "bodyText": "made the all strings representation to \"curl\"", "author": "anpanigr", "createdAt": "2020-05-06T19:42:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTM1OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511359", "bodyText": "same here - Datasource, DataSource", "author": "markxnelson", "createdAt": "2020-05-06T02:19:27Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Deploy a WebLogic domain with a defined ConfigMap.\n+   * in configuration/model section of the domain resource\n+   * The ConfigMap has a sparse wdt model file that define a JDBC DataSource \n+   * targeted to the cluster\n+   * Once the WebLogic domain is up, verify the DataSource configuration\n+   * using the RestAPI call thru adminserver's  public NodePort\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with a configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigMapDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount, configMapName);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    try {\n+      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null \")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Datasource configuration not found\");", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0ODI0OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421048249", "bodyText": "made the all strings representation to DataSource", "author": "anpanigr", "createdAt": "2020-05-06T19:46:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTYzMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511633", "bodyText": "missing asterisk\noperator - no capital", "author": "markxnelson", "createdAt": "2020-05-06T02:20:41Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0OTY5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421049693", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-05-06T19:48:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTcwMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511702", "bodyText": "you are not creating it, it already exists", "author": "markxnelson", "createdAt": "2020-05-06T02:20:58Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0MTE2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420541160", "bodyText": "can be changed to \"Assigning....\"", "author": "sankarpn", "createdAt": "2020-05-06T04:39:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTcwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2NDM3MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421064371", "bodyText": "logger.info(\"Assigning unique namespace for Operator\");\nlogger.info(\"Assigning unique namespace for Domain\");", "author": "anpanigr", "createdAt": "2020-05-06T20:14:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTcwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTgyMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511822", "bodyText": "insert a blank line here", "author": "markxnelson", "createdAt": "2020-05-06T02:21:31Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2NzE5OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421067199", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-05-06T20:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTg1OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511858", "bodyText": "no cap", "author": "markxnelson", "createdAt": "2020-05-06T02:21:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2NDYzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421064635", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-05-06T20:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTkxNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511916", "bodyText": "no cap", "author": "markxnelson", "createdAt": "2020-05-06T02:21:52Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2NzMyMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421067323", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-05-06T20:20:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTk5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420511996", "bodyText": "cap", "author": "markxnelson", "createdAt": "2020-05-06T02:22:12Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2OTUwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421069504", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-05-06T20:24:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMTk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjA2OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420512069", "bodyText": "restart does not have a hyphen", "author": "markxnelson", "createdAt": "2020-05-06T02:22:32Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+\n+  /**\n+   * Start a WebLogic domain with out any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse JDBC model file\n+   * Patch the domain resource with the ConfigMap which is targeted to cluster\n+   * Update the Restart Version of the domain resource\n+   * Verify rolling re-start of domain by comparing PodCreationTimestamp", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA3MDYxNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421070616", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-05-06T20:26:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjE2OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420512168", "bodyText": "you don't know if it is OCIR", "author": "markxnelson", "createdAt": "2020-05-06T02:22:54Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+\n+  /**\n+   * Start a WebLogic domain with out any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse JDBC model file\n+   * Patch the domain resource with the ConfigMap which is targeted to cluster\n+   * Update the Restart Version of the domain resource\n+   * Verify rolling re-start of domain by comparing PodCreationTimestamp\n+   * before rolling re-start and after rolling re-start\n+   * Verify the DataSource configuration using the RestAPI call to admin server\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with no configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigOverrideDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2OTYxNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421069617", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-05-06T20:24:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjI2OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420512269", "bodyText": "spelling curl, datasource, as before", "author": "markxnelson", "createdAt": "2020-05-06T02:23:22Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+\n+  /**\n+   * Start a WebLogic domain with out any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse JDBC model file\n+   * Patch the domain resource with the ConfigMap which is targeted to cluster\n+   * Update the Restart Version of the domain resource\n+   * Verify rolling re-start of domain by comparing PodCreationTimestamp\n+   * before rolling re-start and after rolling re-start\n+   * Verify the DataSource configuration using the RestAPI call to admin server\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with no configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigOverrideDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    String adminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for Introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods re-started sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String newAdminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(newAdminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"NewAdminPodCreationTime {0} \", newAdminPodCreationTime);\n+    if (Long.parseLong(newAdminPodCreationTime) == Long.parseLong(adminPodCreationTime)) {\n+      logger.info(\"NewAdminPodCreationTime {0} BeforeAdminPodCreationTime ${1}\",\n+          newAdminPodCreationTime, adminPodCreationTime);\n+      fail(\"New pod creation time must be later than the original timestamp\");\n+    }\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"CURL command {0}\", new String(checkJdbc));", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA3MDg4Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421070883", "bodyText": "done, everything curl", "author": "anpanigr", "createdAt": "2020-05-06T20:26:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjQyNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420512426", "bodyText": "i see this enough, that maybe it could be refactored", "author": "markxnelson", "createdAt": "2020-05-06T02:23:48Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+\n+  /**\n+   * Start a WebLogic domain with out any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse JDBC model file\n+   * Patch the domain resource with the ConfigMap which is targeted to cluster\n+   * Update the Restart Version of the domain resource\n+   * Verify rolling re-start of domain by comparing PodCreationTimestamp\n+   * before rolling re-start and after rolling re-start\n+   * Verify the DataSource configuration using the RestAPI call to admin server\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with no configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigOverrideDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    String adminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for Introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods re-started sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String newAdminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(newAdminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"NewAdminPodCreationTime {0} \", newAdminPodCreationTime);\n+    if (Long.parseLong(newAdminPodCreationTime) == Long.parseLong(adminPodCreationTime)) {\n+      logger.info(\"NewAdminPodCreationTime {0} BeforeAdminPodCreationTime ${1}\",\n+          newAdminPodCreationTime, adminPodCreationTime);\n+      fail(\"New pod creation time must be later than the original timestamp\");\n+    }\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  private String createImageAndVerify() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA3MTQ3OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421071478", "bodyText": "Boilerplate code from MiiDomain.java. May we should move to a common utility class.", "author": "anpanigr", "createdAt": "2020-05-06T20:27:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjc4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420512789", "bodyText": "no it doesn't - see comment in other class", "author": "markxnelson", "createdAt": "2020-05-06T02:25:18Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+\n+  /**\n+   * Start a WebLogic domain with out any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse JDBC model file\n+   * Patch the domain resource with the ConfigMap which is targeted to cluster\n+   * Update the Restart Version of the domain resource\n+   * Verify rolling re-start of domain by comparing PodCreationTimestamp\n+   * before rolling re-start and after rolling re-start\n+   * Verify the DataSource configuration using the RestAPI call to admin server\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with no configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigOverrideDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    String adminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for Introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods re-started sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String newAdminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(newAdminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"NewAdminPodCreationTime {0} \", newAdminPodCreationTime);\n+    if (Long.parseLong(newAdminPodCreationTime) == Long.parseLong(adminPodCreationTime)) {\n+      logger.info(\"NewAdminPodCreationTime {0} BeforeAdminPodCreationTime ${1}\",\n+          newAdminPodCreationTime, adminPodCreationTime);\n+      fail(\"New pod creation time must be later than the original timestamp\");\n+    }\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  private String createImageAndVerify() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageName = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? MII_IMAGE_NAME : REPO_NAME + MII_IMAGE_NAME;\n+    final String image = imageName + \":\" + imageTag;\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    assertTrue(buildAppArchive(defaultAppParams()\n+        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    final List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap<>();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0} using model directory {1}\", image, MODEL_DIR);\n+    boolean result = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(imageTag)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertTrue(result, String.format(\"Failed to create the image %s using WebLogic Image Tool\", image));\n+\n+    /* Check image exists using docker images | grep image tag.\n+     * Tag name is unique as it contains date and timestamp.\n+     * This is a workaround for the issue on Jenkins machine\n+     * as docker images imagename:imagetag is not working and\n+     * the test fails even though the image exists.\n+     */\n+    assertTrue(doesImageExist(imageTag),\n+        String.format(\"Image %s doesn't exist\", image));\n+\n+    return image;\n+  }\n+\n+  private void createRepoSecret(String domNamespace) throws ApiException {\n+    V1Secret repoSecret = new V1Secret()\n+            .metadata(new V1ObjectMeta()\n+                    .name(REPO_SECRET_NAME)\n+                    .namespace(domNamespace))\n+            .type(\"kubernetes.io/dockerconfigjson\")\n+            .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = false;\n+    try {\n+      secretCreated = createSecret(repoSecret);\n+    } catch (ApiException e) {\n+      logger.info(\"Exception when calling CoreV1Api#createNamespacedSecret\");\n+      logger.info(\"Status code: \" + e.getCode());\n+      logger.info(\"Reason: \" + e.getResponseBody());\n+      logger.info(\"Response headers: \" + e.getResponseHeaders());\n+      //409 means that the secret already exists - it is not an error, so can proceed", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjg2Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420512867", "bodyText": "seems to be a lot of duplicated code in this class....", "author": "markxnelson", "createdAt": "2020-05-06T02:25:38Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+\n+  /**\n+   * Start a WebLogic domain with out any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse JDBC model file\n+   * Patch the domain resource with the ConfigMap which is targeted to cluster\n+   * Update the Restart Version of the domain resource\n+   * Verify rolling re-start of domain by comparing PodCreationTimestamp\n+   * before rolling re-start and after rolling re-start\n+   * Verify the DataSource configuration using the RestAPI call to admin server\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with no configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigOverrideDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    String adminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for Introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods re-started sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String newAdminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(newAdminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"NewAdminPodCreationTime {0} \", newAdminPodCreationTime);\n+    if (Long.parseLong(newAdminPodCreationTime) == Long.parseLong(adminPodCreationTime)) {\n+      logger.info(\"NewAdminPodCreationTime {0} BeforeAdminPodCreationTime ${1}\",\n+          newAdminPodCreationTime, adminPodCreationTime);\n+      fail(\"New pod creation time must be later than the original timestamp\");\n+    }\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkJdbc = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkJdbc.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/wls/latest/datasources/id/TestDataSource/\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"CURL command {0}\", new String(checkJdbc));\n+      result = exec(new String(checkJdbc), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"Curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Datasource configuration not found\");\n+    logger.info(\"Found the DataSource configuration \");\n+\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  private String createImageAndVerify() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageName = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? MII_IMAGE_NAME : REPO_NAME + MII_IMAGE_NAME;\n+    final String image = imageName + \":\" + imageTag;\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    assertTrue(buildAppArchive(defaultAppParams()\n+        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    final List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap<>();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0} using model directory {1}\", image, MODEL_DIR);\n+    boolean result = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(imageTag)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertTrue(result, String.format(\"Failed to create the image %s using WebLogic Image Tool\", image));\n+\n+    /* Check image exists using docker images | grep image tag.\n+     * Tag name is unique as it contains date and timestamp.\n+     * This is a workaround for the issue on Jenkins machine\n+     * as docker images imagename:imagetag is not working and\n+     * the test fails even though the image exists.\n+     */\n+    assertTrue(doesImageExist(imageTag),\n+        String.format(\"Image %s doesn't exist\", image));\n+\n+    return image;\n+  }\n+\n+  private void createRepoSecret(String domNamespace) throws ApiException {\n+    V1Secret repoSecret = new V1Secret()\n+            .metadata(new V1ObjectMeta()\n+                    .name(REPO_SECRET_NAME)\n+                    .namespace(domNamespace))\n+            .type(\"kubernetes.io/dockerconfigjson\")\n+            .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = false;\n+    try {\n+      secretCreated = createSecret(repoSecret);\n+    } catch (ApiException e) {\n+      logger.info(\"Exception when calling CoreV1Api#createNamespacedSecret\");\n+      logger.info(\"Status code: \" + e.getCode());\n+      logger.info(\"Reason: \" + e.getResponseBody());\n+      logger.info(\"Response headers: \" + e.getResponseHeaders());\n+      //409 means that the secret already exists - it is not an error, so can proceed\n+      if (e.getCode() != 409) {\n+        throw e;\n+      } else {\n+        secretCreated = true;\n+      }\n+\n+    }\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s in namespace %s\",\n+            REPO_SECRET_NAME, domNamespace));\n+  }\n+\n+  private void createDomainSecret(String secretName, String username, String password, String domNamespace)\n+          throws ApiException {\n+    Map<String, String> secretMap = new HashMap();\n+    secretMap.put(\"username\", username);\n+    secretMap.put(\"password\", password);\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+            .metadata(new V1ObjectMeta()\n+                    .name(secretName)\n+                    .namespace(domNamespace))\n+            .stringData(secretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s in namespace %s\", secretName, domNamespace));\n+\n+  }\n+\n+  private void createDomainResource(String domainUid, String domNamespace, \n+          String adminSecretName, String repoSecretName, \n+          String encryptionSecretName, int replicaCount) {\n+    // create the domain CR\n+    Domain domain = new Domain()\n+            .apiVersion(API_VERSION)\n+            .kind(\"Domain\")\n+            .metadata(new V1ObjectMeta()\n+                    .name(domainUid)\n+                    .namespace(domNamespace))\n+            .spec(new DomainSpec()\n+                    .domainUid(domainUid)\n+                    .domainHomeSourceType(\"FromModel\")\n+                    .image(miiImage)\n+                    .addImagePullSecretsItem(new V1LocalObjectReference()\n+                            .name(repoSecretName))\n+                    .webLogicCredentialsSecret(new V1SecretReference()\n+                            .name(adminSecretName)\n+                            .namespace(domNamespace))\n+                    .includeServerOutInPodLog(true)\n+                    .serverStartPolicy(\"IF_NEEDED\")\n+                    .serverPod(new ServerPod()\n+                            .addEnvItem(new V1EnvVar()\n+                                    .name(\"JAVA_OPTIONS\")\n+                                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                            .addEnvItem(new V1EnvVar()\n+                                    .name(\"USER_MEM_ARGS\")\n+                                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+                    .adminServer(new AdminServer()\n+                            .serverStartState(\"RUNNING\")\n+                            .adminService(new AdminService()\n+                                    .addChannelsItem(new Channel()\n+                                            .channelName(\"default\")\n+                                            .nodePort(0))))\n+                    .addClustersItem(new Cluster()\n+                            .clusterName(\"cluster-1\")\n+                            .replicas(replicaCount)\n+                            .serverStartState(\"RUNNING\"))\n+                    .configuration(new Configuration()\n+                            .model(new Model()\n+                                    .domainType(\"WLS\")\n+                                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+            domainUid, domNamespace);\n+    boolean domCreated = assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+            String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+                    domainUid, domNamespace));\n+    assertTrue(domCreated, String.format(\"Create domain custom resource failed with ApiException \"\n+                    + \"for %s in namespace %s\", domainUid, domNamespace));\n+  }\n+\n+  private void checkPodCreated(String podName, String domainUid, String domNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podExists(podName, domainUid, domNamespace),\n+            String.format(\"podExists failed with ApiException for %s in namespace in %s\",\n+                podName, domNamespace)));\n+\n+  }\n+\n+  private void checkPodReady(String podName, String domainUid, String domNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                podName,\n+                domNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> podReady(podName, domainUid, domNamespace),\n+            String.format(\n+                \"pod %s is not ready in namespace %s\", podName, domNamespace)));\n+\n+  }\n+\n+  private void checkServiceCreated(String serviceName, String domNamespace) {\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for service {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                serviceName,\n+                domNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> serviceExists(serviceName, null, domNamespace),\n+            String.format(\n+                \"Service %s is not ready in namespace %s\", serviceName, domainNamespace)));\n+\n+  }\n+\n+  private void checkServerReadyStatusByExec(String podName, String namespace) {\n+    final V1Pod pod = assertDoesNotThrow(() -> oracle.weblogic.kubernetes.assertions.impl.Kubernetes\n+        .getPod(namespace, null, podName));\n+\n+    if (pod != null) {\n+      ExecResult execResult = assertDoesNotThrow(\n+          () -> execCommand(pod, null, true, READ_STATE_COMMAND));\n+      if (execResult.exitValue() == 0) {\n+        logger.info(\"execResult: \" + execResult);\n+        assertEquals(\"RUNNING\", execResult.stdout(),\n+            \"Expected \" + podName + \", in namespace \" + namespace + \", to be in RUNNING ready status\");\n+      } else {\n+        fail(\"Ready command failed with exit status code: \" + execResult.exitValue());\n+      }\n+    } else {\n+      fail(\"Did not find pod \" + podName + \" in namespace \" + namespace);", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzA2Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420513067", "bodyText": "please read this https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests", "author": "markxnelson", "createdAt": "2020-05-06T02:26:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA3NjI3Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421076277", "bodyText": "A lot of code can be moved to a common utility class.  In this class, we have only one test method rests are common utility methods.", "author": "anpanigr", "createdAt": "2020-05-06T20:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMjg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzQ3Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420513476", "bodyText": "remove extraneous space", "author": "markxnelson", "createdAt": "2020-05-06T02:28:21Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -405,6 +408,36 @@ public static boolean deleteService(String name, String namespace) {\n     return Service.delete(name, namespace);\n   }\n \n+  /**\n+   * Returns the V1Service object given the following parameters.\n+   *\n+   * @param serviceName name of the Service to return\n+   * @param label  a Map of key value pairs the service is decorated with", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA3ODI4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421078284", "bodyText": "removed the  extraneous space", "author": "anpanigr", "createdAt": "2020-05-06T20:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzYwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420513604", "bodyText": "could use a link to the k8s doc here to explain this format", "author": "markxnelson", "createdAt": "2020-05-06T02:29:00Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -551,11 +588,48 @@ public static JsonObject createDockerConfigJson(String username, String password\n    * @throws InterruptedException if any thread has interrupted the current thread\n    */\n   public static ExecResult execCommand(V1Pod pod, String containerName, boolean redirectToStdout,\n-      String... command)\n+                                       String... command)\n       throws IOException, ApiException, InterruptedException {\n     return Exec.exec(pod, containerName, redirectToStdout, command);\n   }\n \n+  // ----------------------   pod  ---------------------------------\n+\n+  /**\n+   * Get the creationTimestamp for a given pod with following parameters.\n+   *\n+   * @param namespace namespace in which to check for the pod existence\n+   * @param labelSelector in the format \"weblogic.domainUID in (%s)\"", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUzNDMyMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420534323", "bodyText": "https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/", "author": "sankarpn", "createdAt": "2020-05-06T04:07:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMzg5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420513893", "bodyText": "... which match the given labelSelector", "author": "markxnelson", "createdAt": "2020-05-06T02:30:06Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.\n+   *\n+   * @param name name of the pod\n+   * @param namespace name of namespace\n+   * @return true if successful, false otherwise\n+   */\n+  public static boolean deletePod(String name, String namespace) {\n+    return Kubernetes.deletePod(name, namespace);\n+  }\n+\n+  /**\n+   * List Kubernetes pods in a namespace.", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxNDEwNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420514107", "bodyText": "this assumes a pod only has one container\nthere are likely going to be cases where we want to get the log from a specific container.\nconsider introducing an optional container parameter.\nif the pod only has one container, default to that one.", "author": "markxnelson", "createdAt": "2020-05-06T02:31:04Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+public class Pod {\n+\n+  /**\n+   * Delete Kubernetes Pod.\n+   *\n+   * @param name name of the pod\n+   * @param namespace name of namespace\n+   * @return true if successful, false otherwise\n+   */\n+  public static boolean deletePod(String name, String namespace) {\n+    return Kubernetes.deletePod(name, namespace);\n+  }\n+\n+  /**\n+   * List Kubernetes pods in a namespace.\n+   *\n+   * @param namespace name of namespace\n+   * @param labelSelectors with which pods are decorated\n+   * @return V1PodList list of pods\n+   */\n+  public static V1PodList listPods(String namespace, String labelSelectors) {\n+    return Kubernetes.listPods(namespace, labelSelectors);\n+  }\n+\n+  /**\n+   * Get a pod's log.\n+   *\n+   * @param podName name of the pod\n+   * @param namespace name of the namespace\n+   * @return log as a String\n+   */\n+  public static String getPodLog(String podName, String namespace) {", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5NTc3Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421095776", "bodyText": "Good suggestion. In WKO all the WebLogic pod has a single container. This method can be used to verify id the pod log has any exception. We can open a JIRA to enhance this utility. In this PR I just made the method publically available through TestAction.", "author": "anpanigr", "createdAt": "2020-05-06T21:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxNDEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUzNDgzOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420534839", "bodyText": "lets change this to logger.info(\"Assigning unique namespace for operator\");", "author": "sankarpn", "createdAt": "2020-05-06T04:09:53Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA3OTA2Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421079062", "bodyText": "Modified logger info message accordingly", "author": "anpanigr", "createdAt": "2020-05-06T20:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUzNDgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUzNDg4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420534882", "bodyText": "same here", "author": "sankarpn", "createdAt": "2020-05-06T04:10:03Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA3OTE2MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421079161", "bodyText": "Modified logger info message accordingly", "author": "anpanigr", "createdAt": "2020-05-06T20:42:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUzNDg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUzNTQwNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420535406", "bodyText": "now it should be operatorIsReady", "author": "sankarpn", "createdAt": "2020-05-06T04:12:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMap.java", "diffHunk": "@@ -0,0 +1,610 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMap implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTExNzQxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421117414", "bodyText": "Done after syncing to latest develop branch.", "author": "anpanigr", "createdAt": "2020-05-06T21:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUzNTQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0MDg0Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420540842", "bodyText": "can we add this to TestConstants.java ?", "author": "sankarpn", "createdAt": "2020-05-06T04:38:13Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjgyOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421086828", "bodyText": "Added two constants to TestConstants.java\n// domain constants\npublic static final String DOMAIN_VERSION = \"v7\";\npublic static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;", "author": "anpanigr", "createdAt": "2020-05-06T20:56:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0MDg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0MDkzMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420540933", "bodyText": "same as above comment", "author": "sankarpn", "createdAt": "2020-05-06T04:38:36Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4Njc3MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421086770", "bodyText": "Added two constants to  TestConstants.java\n// domain constants\npublic static final String DOMAIN_VERSION = \"v7\";\npublic static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;", "author": "anpanigr", "createdAt": "2020-05-06T20:56:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0MDkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0MjE4Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420542186", "bodyText": "can you add some comments on why we are checking the creation time stamp for the pod ?", "author": "sankarpn", "createdAt": "2020-05-06T04:43:53Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+\n+  /**\n+   * Start a WebLogic domain with out any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse JDBC model file\n+   * Patch the domain resource with the ConfigMap which is targeted to cluster\n+   * Update the Restart Version of the domain resource\n+   * Verify rolling re-start of domain by comparing PodCreationTimestamp\n+   * before rolling re-start and after rolling re-start\n+   * Verify the DataSource configuration using the RestAPI call to admin server\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with no configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigOverrideDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    String adminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjE5OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421086199", "bodyText": "It is described in the javadoc section of the TestMethod as follows  ...\nVerify rolling restart of the domain by comparing PodCreationTimestamp before rolling restart and after rolling restart", "author": "anpanigr", "createdAt": "2020-05-06T20:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0MjE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0NDI0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420544244", "bodyText": "We may have to add a new assertion methods to verify the creation time stamp is different for all pods which are restarted.  Lets create a JIRA for that task.", "author": "sankarpn", "createdAt": "2020-05-06T04:52:59Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -0,0 +1,679 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsRunning;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiConfigMapOverride implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkJdbc = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsRunning(opNamespace));\n+\n+  }\n+\n+\n+  /**\n+   * Start a WebLogic domain with out any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse JDBC model file\n+   * Patch the domain resource with the ConfigMap which is targeted to cluster\n+   * Update the Restart Version of the domain resource\n+   * Verify rolling re-start of domain by comparing PodCreationTimestamp\n+   * before rolling re-start and after rolling re-start\n+   * Verify the DataSource configuration using the RestAPI call to admin server\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain with no configmap\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiConfigOverrideDomain() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.jdbc.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dsconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.jdbc.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, \n+              REPO_SECRET_NAME, encryptionSecretName, \n+              replicaCount);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    String adminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"ConfigMap Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"RestartVersion Patch String: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for Introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods re-started sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String newAdminPodCreationTime = getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName);\n+    assertNotNull(newAdminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"NewAdminPodCreationTime {0} \", newAdminPodCreationTime);\n+    if (Long.parseLong(newAdminPodCreationTime) == Long.parseLong(adminPodCreationTime)) {\n+      logger.info(\"NewAdminPodCreationTime {0} BeforeAdminPodCreationTime ${1}\",\n+          newAdminPodCreationTime, adminPodCreationTime);\n+      fail(\"New pod creation time must be later than the original timestamp\");\n+    }", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4MTMyMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r421081321", "bodyText": "Yes, it is a good idea to have a new Assertion to check the podCreationTimestamp is unique when the domain is (rolling) restarted.", "author": "anpanigr", "createdAt": "2020-05-06T20:46:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0NDI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxNDMwMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r420914302", "bodyText": "the .toString() conversion is redundant for the above 2 lines, its already a String", "author": "sankarpn", "createdAt": "2020-05-06T16:10:55Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Kubernetes.java", "diffHunk": "@@ -1406,8 +1446,87 @@ public static V1ServiceList listServices(String namespace) {\n     }\n   }\n \n-  // --------------------------- jobs ---------------------------\n+  /**\n+   * Get V1Service object for the given service name, label and namespace.\n+   *\n+   * @param serviceName name of the service to look for\n+   * @param label  key value pair with which the service is decorated with\n+   * @param namespace namespace in which to check for the service\n+   * @return V1Service object if found otherwise null\n+   * @throws ApiException when there is error in querying the cluster\n+   */\n+  public static V1Service getService(\n+      String serviceName, Map<String, String> label, String namespace)\n+      throws ApiException {\n+    String labelSelector = null;\n+    if (label != null) {\n+      String key = label.keySet().iterator().next().toString();\n+      String value = label.get(key).toString();", "originalCommit": "3d897a07beb2df97f491e21d7023b22980df588d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cddad0e65d6ad15550f6296a84e63995fe5ab274", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cddad0e65d6ad15550f6296a84e63995fe5ab274", "message": "Resolution to review comments", "committedDate": "2020-05-06T21:28:33Z", "type": "commit"}, {"oid": "c90e0f51989d875abaf04e23a641121a02ca6260", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c90e0f51989d875abaf04e23a641121a02ca6260", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm", "committedDate": "2020-05-06T21:28:44Z", "type": "commit"}, {"oid": "9c1aa5c88249939ed8b7fd203e24216eb56a6b0f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9c1aa5c88249939ed8b7fd203e24216eb56a6b0f", "message": "Added Usecases to add new Dynamic Cluster", "committedDate": "2020-05-06T23:09:40Z", "type": "commit"}, {"oid": "80422299b80e788dd44c9ec5ab147eeacdd5ee72", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/80422299b80e788dd44c9ec5ab147eeacdd5ee72", "message": "Merge conflict", "committedDate": "2020-05-06T23:12:34Z", "type": "commit"}, {"oid": "64bc66ed172ee682da68cae20e6620929d6b234f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/64bc66ed172ee682da68cae20e6620929d6b234f", "message": "Separate the AddCluster UseCase", "committedDate": "2020-05-07T17:08:45Z", "type": "commit"}, {"oid": "6bf9f6959a67b568254d8040c5f3b7bcf58855ef", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6bf9f6959a67b568254d8040c5f3b7bcf58855ef", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm", "committedDate": "2020-05-07T21:19:39Z", "type": "commit"}, {"oid": "dfd8357fa3f4320d2855e0f8d977aa905396052c", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/dfd8357fa3f4320d2855e0f8d977aa905396052c", "message": "Add new AddClusters usecase", "committedDate": "2020-05-08T15:15:38Z", "type": "commit"}, {"oid": "1531bd1a764814d6f95e81a06228dd92946e157d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1531bd1a764814d6f95e81a06228dd92946e157d", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm", "committedDate": "2020-05-08T15:40:16Z", "type": "commit"}, {"oid": "b7b28ee59fdfc590640a1f053ad1711dbb591e81", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b7b28ee59fdfc590640a1f053ad1711dbb591e81", "message": "Modified the test method name", "committedDate": "2020-05-08T19:37:26Z", "type": "commit"}, {"oid": "531ff5b17226b182c872131bc077226e17f4bf16", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/531ff5b17226b182c872131bc077226e17f4bf16", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm", "committedDate": "2020-05-08T21:41:14Z", "type": "commit"}, {"oid": "9e0e8466aed39e6c746804d80530f704b250cfcc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9e0e8466aed39e6c746804d80530f704b250cfcc", "message": "Added assetion to compare the PodCreationStartTime and add new usecases for adding new cluster with default replica count", "committedDate": "2020-05-12T13:31:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2NzkwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r423867904", "bodyText": "More documentation please", "author": "sankarpn", "createdAt": "2020-05-12T16:25:07Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,1085 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully", "originalCommit": "9e0e8466aed39e6c746804d80530f704b250cfcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkyNzg2OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r423927869", "bodyText": "Updated the  @DisplayName annotation for each test method", "author": "anpanigr", "createdAt": "2020-05-12T17:59:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2NzkwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2ODI0Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r423868242", "bodyText": "same comment as above", "author": "sankarpn", "createdAt": "2020-05-12T16:25:35Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,1085 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")", "originalCommit": "9e0e8466aed39e6c746804d80530f704b250cfcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkyNzk5OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r423927998", "bodyText": "Updated the @DisplayName annotation for each test method", "author": "anpanigr", "createdAt": "2020-05-12T17:59:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2ODI0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2OTk1MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r423869950", "bodyText": "We should use descriptive names for model files.", "author": "sankarpn", "createdAt": "2020-05-12T16:27:54Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,1085 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";", "originalCommit": "9e0e8466aed39e6c746804d80530f704b250cfcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg3MDk1NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r423870954", "bodyText": "can we change the domain name to someother name? all tests are using domain1", "author": "sankarpn", "createdAt": "2020-05-12T16:29:21Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,1085 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";", "originalCommit": "9e0e8466aed39e6c746804d80530f704b250cfcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg3ODczMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r423878731", "bodyText": "The assertion to check for a rolling restart in a cluster is under testing. I will replace this code with assertion in my PR.", "author": "sankarpn", "createdAt": "2020-05-12T16:41:07Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,1085 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+        REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to registry to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to registry\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName, \"weblogic\",\n+        \"welcome1\", domainNamespace),\n+        String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+        \"weblogicenc\", domainNamespace),\n+        String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    // no uppercase for the configmap name\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",", "originalCommit": "9e0e8466aed39e6c746804d80530f704b250cfcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkyODE4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r423928184", "bodyText": "thanks", "author": "anpanigr", "createdAt": "2020-05-12T17:59:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg3ODczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MzgyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r423883829", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private void checkPodNotCreated(String podName, String domainUid, String domNamespace) {\n          \n          \n            \n              private void checkPodDoesNotExist(String podName, String domainUid, String domNamespace) {", "author": "sankarpn", "createdAt": "2020-05-12T16:49:06Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,1085 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+// Test to create model in image domain and verify the domain started successfully\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to create model in image domain and start the domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+        REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to registry to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to registry\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName, \"weblogic\",\n+        \"welcome1\", domainNamespace),\n+        String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+        \"weblogicenc\", domainNamespace),\n+        String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    // no uppercase for the configmap name\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods restarted sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // The ServerNamePrefix for the new dynamic cluster is dynamic-server\n+    // Make sure the managed server from the new cluster is running\n+\n+    String newServerPodName = domainUid + \"-dynamic-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isPodRestarted  =\n+        assertDoesNotThrow(() -> isPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime),\n+            String.format(\"Check if the admin Pod is restarted\"));\n+    assertTrue(isPodRestarted, \"Admin pod has not been restarted as expected\");\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkCluster = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkCluster.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/tenant-monitoring/servers/dynamic-server1\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"curl command {0}\", new String(checkCluster));\n+      result = exec(new String(checkCluster), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Server configuration not found\");\n+    logger.info(\"Found the Server configuration \");\n+\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a configured cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Update the restart version of the domain resource to 3\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a configured cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiConfiguredCluster() {\n+    // This test use the running mii domain created by previous test\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.config.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    // no uppercase for the configmap name\n+    String configMapName = \"configclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.config.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"3\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods restarted sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // The ServerNamePrefix for the new configured cluster is config-server\n+    // Make sure the managed server from the new cluster is running\n+\n+    String newServerPodName = domainUid + \"-config-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isPodRestarted  =\n+        assertDoesNotThrow(() -> isPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime),\n+            String.format(\"Check if the admin pod is restarted\"));\n+    assertTrue(isPodRestarted, \"Admin pod has not been restarted as expected\");\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkCluster = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkCluster.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/tenant-monitoring/servers/config-server1\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"curl command {0}\", new String(checkCluster));\n+      result = exec(new String(checkCluster), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Server configuration not found\");\n+    logger.info(\"Found the Server configuration \");\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a configured cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Update the restart version of the domain resource to 3\n+   * Update the spec level replica count to zero(default) value\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are not in running state.\n+   */\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"Add a configured cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiClusteriWithNoReplica() {\n+    // This test use the running mii domain created by previous test\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.config.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    // no uppercase for the configmap name\n+    String configMapName = \"noreplicaconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.config.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 0\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"4\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods restarted sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // The ServerNamePrefix for the new configured cluster is config-server\n+    // Make sure the managed server from the new cluster is not running\n+\n+    String newServerPodName = domainUid + \"-config-server1\";\n+    checkPodNotCreated(newServerPodName, domainUid, domainNamespace);\n+\n+    boolean isPodRestarted  =\n+        assertDoesNotThrow(() -> isPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime),\n+            String.format(\"Check if the admin pod is restarted\"));\n+    assertTrue(isPodRestarted, \"Admin pod has not been restarted as expected\");\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkCluster = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkCluster.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/tenant-monitoring/servers/config-server1\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"curl command {0}\", new String(checkCluster));\n+      result = exec(new String(checkCluster), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Server configuration not found\");\n+    logger.info(\"Found the Server configuration \");\n+\n+  }\n+\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't cleanup the images.\n+  @AfterAll\n+  void tearDown() {\n+\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);\n+    assertDoesNotThrow(() -> deleteDomainCustomResource(domainUid, domainNamespace),\n+        \"deleteDomainCustomResource failed with ApiException\");\n+    logger.info(\"Deleted Domain Custom Resource \" + domainUid + \" from \" + domainNamespace);\n+\n+    // delete the domain image created for the test\n+    if (miiImage != null) {\n+      deleteImage(miiImage);\n+    }\n+\n+  }\n+\n+  private String createImageAndVerify() {\n+    // create unique image name with date\n+    DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    Date date = new Date();\n+    final String imageTag = dateFormat.format(date) + \"-\" + System.currentTimeMillis();\n+    // Add repository name in image name for Jenkins runs\n+    final String imageName = REPO_USERNAME.equals(REPO_DUMMY_VALUE) ? MII_IMAGE_NAME : REPO_NAME + MII_IMAGE_NAME;\n+    final String image = imageName + \":\" + imageTag;\n+\n+    // build the model file list\n+    final List<String> modelList = Collections.singletonList(MODEL_DIR + \"/\" + WDT_MODEL_FILE);\n+\n+    // build an application archive using what is in resources/apps/APP_NAME\n+    assertTrue(buildAppArchive(defaultAppParams()\n+        .srcDir(APP_NAME)), String.format(\"Failed to create app archive for %s\", APP_NAME));\n+\n+    // build the archive list\n+    String zipFile = String.format(\"%s/%s.zip\", ARCHIVE_DIR, APP_NAME);\n+    final List<String> archiveList = Collections.singletonList(zipFile);\n+\n+    // Set additional environment variables for WIT\n+    checkDirectory(WIT_BUILD_DIR);\n+    Map<String, String> env = new HashMap<>();\n+    env.put(\"WLSIMG_BLDDIR\", WIT_BUILD_DIR);\n+\n+    // build an image using WebLogic Image Tool\n+    logger.info(\"Create image {0} using model directory {1}\", image, MODEL_DIR);\n+    boolean result = createMiiImage(\n+        defaultWitParams()\n+            .modelImageName(imageName)\n+            .modelImageTag(imageTag)\n+            .modelFiles(modelList)\n+            .modelArchiveFiles(archiveList)\n+            .wdtVersion(WDT_VERSION)\n+            .env(env)\n+            .redirect(true));\n+\n+    assertTrue(result, String.format(\"Failed to create the image %s using WebLogic Image Tool\", image));\n+\n+    /* Check image exists using docker images | grep image tag.\n+     * Tag name is unique as it contains date and timestamp.\n+     * This is a workaround for the issue on Jenkins machine\n+     * as docker images imagename:imagetag is not working and\n+     * the test fails even though the image exists.\n+     */\n+    assertTrue(doesImageExist(imageTag),\n+        String.format(\"Image %s doesn't exist\", image));\n+\n+    return image;\n+  }\n+\n+  private void createRepoSecret(String domNamespace) throws ApiException {\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(domNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = false;\n+    try {\n+      secretCreated = createSecret(repoSecret);\n+    } catch (ApiException e) {\n+      logger.info(\"Exception when calling CoreV1Api#createNamespacedSecret\");\n+      logger.info(\"Status code: \" + e.getCode());\n+      logger.info(\"Reason: \" + e.getResponseBody());\n+      logger.info(\"Response headers: \" + e.getResponseHeaders());\n+      //409 means that the secret already exists - it is not an error, so can proceed\n+      if (e.getCode() != 409) {\n+        throw e;\n+      } else {\n+        secretCreated = true;\n+      }\n+\n+    }\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s in namespace %s\",\n+        REPO_SECRET_NAME, domNamespace));\n+  }\n+\n+  private void createDomainSecret(String secretName, String username, String password, String domNamespace)\n+      throws ApiException {\n+    Map<String, String> secretMap = new HashMap();\n+    secretMap.put(\"username\", username);\n+    secretMap.put(\"password\", password);\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(secretName)\n+            .namespace(domNamespace))\n+        .stringData(secretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s in namespace %s\", secretName, domNamespace));\n+\n+  }\n+\n+  private void createDomainResource(String domainUid, String domNamespace,\n+                                    String adminSecretName, String repoSecretName,\n+                                    String encryptionSecretName, int replicaCount) {\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(repoSecretName))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"default\")\n+                        .nodePort(0))))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domNamespace);\n+    boolean domCreated = assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domNamespace));\n+    assertTrue(domCreated, String.format(\"Create domain custom resource failed with ApiException \"\n+        + \"for %s in namespace %s\", domainUid, domNamespace));\n+  }\n+\n+  private void checkPodNotCreated(String podName, String domainUid, String domNamespace) {", "originalCommit": "9e0e8466aed39e6c746804d80530f704b250cfcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "25df1a402f99dff4936c6cbe52dfbbd7f56a3180", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/25df1a402f99dff4936c6cbe52dfbbd7f56a3180", "message": "Modified @DisplayName annotation", "committedDate": "2020-05-12T17:57:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyMTA3NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424021075", "bodyText": "This is the pattern that changed.  Now, instead of the test for REPO_USERNAME guarding the docker login and docker push, it just guards the docker login. The docker push needs to happen if REPO_NAME is not-empty.", "author": "rjeberhard", "createdAt": "2020-05-12T20:42:57Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,1084 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"domain1\";\n+  private String miiImage = null;\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  /**\n+   * Install operator.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assigning unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+        REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    Map<String, Object> secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install operator\n+    logger.info(\"Installing operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching operator release name in operator namespace\n+    logger.info(\"Checking operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // create image with model files\n+    miiImage = createImageAndVerify();\n+\n+    // push the image to registry to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {", "originalCommit": "25df1a402f99dff4936c6cbe52dfbbd7f56a3180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "115abf36729391a48cef17ccb3dc52ac31da6fcb", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/115abf36729391a48cef17ccb3dc52ac31da6fcb", "message": "Sync up develop branch", "committedDate": "2020-05-13T01:36:07Z", "type": "commit"}, {"oid": "a2ed6cf30fbeadf43e77dc896ddd9f57f4a9fd43", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a2ed6cf30fbeadf43e77dc896ddd9f57f4a9fd43", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into junit5-cm", "committedDate": "2020-05-13T01:36:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ5Njk2MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424496961", "bodyText": "make this a ToDo comment", "author": "vanajamukkara", "createdAt": "2020-05-13T14:47:01Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,998 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"miiaddcluster\";\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods restarted sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    // The ServerNamePrefix for the new dynamic cluster is dynamic-server\n+    // Make sure the managed server from the new cluster is running\n+    //\n+    String newServerPodName = domainUid + \"-dynamic-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isPodRestarted  =\n+        assertDoesNotThrow(() -> isPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime),\n+            String.format(\"Check if the admin pod is restarted\"));\n+    assertTrue(isPodRestarted, \"Admin pod has not been restarted as expected\");\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkCluster = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+      checkCluster.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/tenant-monitoring/servers/dynamic-server1\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+      logger.info(\"curl command {0}\", new String(checkCluster));\n+      result = exec(new String(checkCluster), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Server configuration not found\");\n+    logger.info(\"Found the server configuration \");\n+\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined configmap.\n+   * Create a configmap with a sparse model file to add a configured cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Update the restart version of the domain resource to 3\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Add a configured cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiConfiguredCluster() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+ \n+    // This test uses the WebLogic domain created by previous test\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.config.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"configclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.config.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"3\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion ", "originalCommit": "a2ed6cf30fbeadf43e77dc896ddd9f57f4a9fd43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYzOTk0Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424639943", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-05-13T18:19:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ5Njk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxMzgzNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424513836", "bodyText": "why hard sleep of 2 minutes?", "author": "vanajamukkara", "createdAt": "2020-05-13T15:08:25Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,998 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"miiaddcluster\";\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);", "originalCommit": "a2ed6cf30fbeadf43e77dc896ddd9f57f4a9fd43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYzOTcwNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424639705", "bodyText": "When I will use the new Assertion to check the rolling restart, this hardcoded sleep can be avoided.", "author": "anpanigr", "createdAt": "2020-05-13T18:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxMzgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3OTE0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424679144", "bodyText": "checkPodCreated() and checkPodReady() method wait/check for 5 minutes. Isn't that enough irrespective of the new assertion? If that 5 minutes if not enough, that needs to be increased rather than hard sleep of 2 minutes.", "author": "vanajamukkara", "createdAt": "2020-05-13T19:27:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxMzgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxODg3NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424718874", "bodyText": "If I call checkPodCreated() and checkPodReady()  immediately before the Introspector kick-off, these methods will return success which is not the expected behavior.  I want the pod to re-started thru Introspector and then check if the pod is created or not", "author": "anpanigr", "createdAt": "2020-05-13T20:42:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxMzgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxNDk3Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424514977", "bodyText": "this code is duplicated in all test methods, can be refactored..next PR is fine for this change", "author": "vanajamukkara", "createdAt": "2020-05-13T15:09:57Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,998 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"miiaddcluster\";\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods restarted sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    // The ServerNamePrefix for the new dynamic cluster is dynamic-server\n+    // Make sure the managed server from the new cluster is running\n+    //\n+    String newServerPodName = domainUid + \"-dynamic-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isPodRestarted  =\n+        assertDoesNotThrow(() -> isPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime),\n+            String.format(\"Check if the admin pod is restarted\"));\n+    assertTrue(isPodRestarted, \"Admin pod has not been restarted as expected\");\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    try {\n+      checkCluster = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");", "originalCommit": "a2ed6cf30fbeadf43e77dc896ddd9f57f4a9fd43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYzOTMwMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424639301", "bodyText": "Skipping to next round, when I will  use new Assertion to check the rolling restart", "author": "anpanigr", "createdAt": "2020-05-13T18:18:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxNDk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2NDc5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424564797", "bodyText": "This is what I think you should do for these tests,\n\ncreate the domain resource in beforeAll method\nverify the domain and cluster(if any existing) is running in beforeEach method\nTests should be just adding new cluster/patch/verify rolling restart etc.. no need for ordering, tests can run in an order...lot of code can be moved to beforeAll and beforeEach methods.", "author": "vanajamukkara", "createdAt": "2020-05-13T16:17:34Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,998 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private String domainUid = \"miiaddcluster\";\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+  }\n+\n+  /**\n+   * Start a WebLogic domain without any pre-defined ConfigMap.\n+   * Create a ConfigMap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the ConfigMap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from the newly added cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {", "originalCommit": "a2ed6cf30fbeadf43e77dc896ddd9f57f4a9fd43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYzNjM4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424636382", "bodyText": "done in the latest commit. Added @beforeeach method and moved the CRD creation code into @BeforeAll method", "author": "anpanigr", "createdAt": "2020-05-13T18:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2NDc5Nw=="}], "type": "inlineReview"}, {"oid": "5668feebdef576cd7e4f4f751114fe1e5176e313", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5668feebdef576cd7e4f4f751114fe1e5176e313", "message": "Resolved more review comments", "committedDate": "2020-05-13T18:02:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NjMyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424676329", "bodyText": "move BeforeAll method to the beginning", "author": "vanajamukkara", "createdAt": "2020-05-13T19:22:17Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,933 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach", "originalCommit": "5668feebdef576cd7e4f4f751114fe1e5176e313", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3Njk3OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424676979", "bodyText": "do you still need the order? I don't think so, remove it.", "author": "vanajamukkara", "createdAt": "2020-05-13T19:23:25Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,933 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)", "originalCommit": "5668feebdef576cd7e4f4f751114fe1e5176e313", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NzE3NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424677175", "bodyText": "This test uses the WebLogic domain created in beforeAll method", "author": "vanajamukkara", "createdAt": "2020-05-13T19:23:49Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,933 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created beforeEach method", "originalCommit": "5668feebdef576cd7e4f4f751114fe1e5176e313", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3OTkyMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1591#discussion_r424679923", "bodyText": "same comment as above", "author": "vanajamukkara", "createdAt": "2020-05-13T19:28:51Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiAddCluster.java", "diffHunk": "@@ -0,0 +1,933 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getAdminServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodCreationTimestamp;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isPodRestarted;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Test to add a cluster to model in image domain\")\n+@IntegrationTest\n+class ItMiiAddCluster implements LoggedTest {\n+\n+  private static final String READ_STATE_COMMAND = \"/weblogic-operator/scripts/readState.sh\";\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 2;\n+  private static String domainUid = \"miiaddcluster\";\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify all k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check admin server status by calling read state command\");\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+  }\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Create a service account for the unique opNamespace\n+    logger.info(\"Creating service account\");\n+    String serviceAccountName = opNamespace + \"-sa\";\n+    assertDoesNotThrow(() -> createServiceAccount(new V1ServiceAccount()\n+        .metadata(\n+            new V1ObjectMeta()\n+                .namespace(opNamespace)\n+                .name(serviceAccountName))));\n+    logger.info(\"Created service account: {0}\", serviceAccountName);\n+\n+    // get Operator image name\n+    operatorImage = getOperatorImageName();\n+    assertFalse(operatorImage.isEmpty(), \"Operator image name can not be empty\");\n+    logger.info(\"Operator image name {0}\", operatorImage);\n+\n+    // Create docker registry secret in the operator namespace to pull the image from repository\n+    logger.info(\"Creating docker registry secret in namespace {0}\", opNamespace);\n+    JsonObject dockerConfigJsonObject = createDockerConfigJson(\n+        REPO_USERNAME, REPO_PASSWORD, REPO_EMAIL, REPO_REGISTRY);\n+    dockerConfigJson = dockerConfigJsonObject.toString();\n+\n+    // Create the V1Secret configuration\n+    logger.info(\"Creating repo secret {0}\", REPO_SECRET_NAME);\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(opNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s in namespace\",\n+                  REPO_SECRET_NAME, opNamespace));\n+\n+    // map with secret\n+    secretNameMap = new HashMap<String, Object>();\n+    secretNameMap.put(\"name\", REPO_SECRET_NAME);\n+    // helm install parameters\n+    opHelmParams = new HelmParams()\n+        .releaseName(OPERATOR_RELEASE_NAME)\n+        .namespace(opNamespace)\n+        .chartDir(OPERATOR_CHART_DIR);\n+\n+    // Operator chart values to override\n+    OperatorParams opParams =\n+        new OperatorParams()\n+            .helmParams(opHelmParams)\n+            .image(operatorImage)\n+            .imagePullSecrets(secretNameMap)\n+            .domainNamespaces(Arrays.asList(domainNamespace))\n+            .serviceAccount(serviceAccountName);\n+\n+    // install Operator\n+    logger.info(\"Installing Operator in namespace {0}\", opNamespace);\n+    assertTrue(installOperator(opParams),\n+        String.format(\"Operator install failed in namespace %s\", opNamespace));\n+    logger.info(\"Operator installed in namespace {0}\", opNamespace);\n+\n+    // list helm releases matching Operator release name in operator namespace\n+    logger.info(\"Checking Operator release {0} status in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+    assertTrue(isHelmReleaseDeployed(OPERATOR_RELEASE_NAME, opNamespace),\n+        String.format(\"Operator release %s is not in deployed status in namespace %s\",\n+            OPERATOR_RELEASE_NAME, opNamespace));\n+    logger.info(\"Operator release {0} status is deployed in namespace {1}\",\n+        OPERATOR_RELEASE_NAME, opNamespace);\n+\n+    // check operator is running\n+    logger.info(\"Check Operator pod is running in namespace {0}\", opNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for operator to be running in namespace {0} \"\n+                    + \"(elapsed time {1}ms, remaining time {2}ms)\",\n+                opNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(operatorIsReady(opNamespace));\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createRepoSecret(domainNamespace),\n+            String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+    // create the domain CR with no configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a dynamic cluster.\n+   * Patch the domain resource with the configmap.\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Update the restart version of the domain resource to 2\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Add a dynamic cluster to model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testAddMiiDynamicCluster() {\n+\n+    // This test uses the WebLogic domain created beforeEach method\n+    // beforeEach method make sure the server pods are running\n+\n+    Map<String, String> labels = new HashMap<>();\n+    labels.put(\"weblogic.domainUid\", domainUid);\n+    String dsModelFile = MODEL_DIR + \"/model.dynamic.cluster.yaml\";\n+    Map<String, String> data = new HashMap<>();\n+    String configMapName = \"dynamicclusterconfigmap\";\n+    String cmData = null;\n+    cmData = assertDoesNotThrow(() -> Files.readString(Paths.get(dsModelFile)),\n+        String.format(\"readString operation failed for %s\", dsModelFile));\n+    assertNotNull(cmData, String.format(\"readString() operation failed while creating ConfigMap %s\", configMapName));\n+    data.put(\"model.dynamic.cluster.yaml\", cmData);\n+\n+    V1ObjectMeta meta = new V1ObjectMeta()\n+        .labels(labels)\n+        .name(configMapName)\n+        .namespace(domainNamespace);\n+    V1ConfigMap configMap = new V1ConfigMap()\n+        .data(data)\n+        .metadata(meta);\n+\n+    boolean cmCreated = assertDoesNotThrow(() -> createConfigMap(configMap),\n+        String.format(\"createConfigMap failed for %s\", configMapName));\n+    assertTrue(cmCreated, String.format(\"createConfigMap failed while creating ConfigMap %s\", configMapName));\n+     \n+    String adminPodCreationTime =\n+        assertDoesNotThrow(() -> getPodCreationTimestamp(domainNamespace, \"\", adminServerPodName),\n+            String.format(\"Can not find PodCreationTime for pod %s\", adminServerPodName));\n+    assertNotNull(adminPodCreationTime, \"adminPodCreationTime returns NULL\");\n+    logger.info(\"AdminPodCreationTime {0} \", adminPodCreationTime);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/configuration/model/configMap\\\",\")\n+        .append(\" \\\"value\\\":  \\\"\" + configMapName + \"\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Configmap patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean cmPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(configMap)  failed \");\n+    assertTrue(cmPatched, \"patchDomainCustomResource(configMap) failed\");\n+    \n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/replicas\\\",\")\n+        .append(\" \\\"value\\\": 1\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Replicas patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean repilcaPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(repilcaPatched, \"patchDomainCustomResource(repilcas) failed\");\n+\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\" \\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/restartVersion\\\",\")\n+        .append(\" \\\"value\\\": \\\"2\\\"\")\n+        .append(\" }]\");\n+    logger.log(Level.INFO, \"Restart version patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean rvPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restartVersion)  failed \");\n+    assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n+    logger.info(\"Snooze for 2 minutes for introspector to kick off\");\n+    try {\n+      TimeUnit.MINUTES.sleep(2);\n+    } catch (java.lang.InterruptedException ie) {\n+      logger.info(\"Got InterruptedException during Thread.sleep\");\n+      fail(\"Got InterruptedException during Thread.sleep\");\n+    }\n+    // Verify a rolling restart is triggered in a sequential fashion \n+    // admin-server --> managed-server1 --> managed-server2 \n+    // ToDo need a better Assertion to verify rolling restart\n+    logger.info(\"Check admin server pod {0} to be restarted in ns {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName, domainUid, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(adminServerPodName, domainNamespace);\n+    checkServerReadyStatusByExec(adminServerPodName, domainNamespace);\n+\n+    // check managed server pods restarted sequentially\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be restarted in ns {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i, domainNamespace);\n+    }\n+    // The ServerNamePrefix for the new dynamic cluster is dynamic-server\n+    // Make sure the managed server from the new cluster is running\n+    //\n+    String newServerPodName = domainUid + \"-dynamic-server1\";\n+    checkPodCreated(newServerPodName, domainUid, domainNamespace);\n+    checkPodReady(newServerPodName, domainUid, domainNamespace);\n+    checkServiceCreated(newServerPodName, domainNamespace);\n+\n+    boolean isPodRestarted  =\n+        assertDoesNotThrow(() -> isPodRestarted(adminServerPodName, domainUid, domainNamespace, adminPodCreationTime),\n+            String.format(\"Check if the admin pod is restarted\"));\n+    assertTrue(isPodRestarted, \"Admin pod has not been restarted as expected\");\n+\n+    oracle.weblogic.kubernetes.utils.ExecResult result = null;\n+    int adminServiceNodePort = getAdminServiceNodePort(adminServerPodName + \"-external\", null, domainNamespace);\n+    checkCluster = new StringBuffer(\"status=$(curl --user weblogic:welcome1 \");\n+    checkCluster.append(\"http://\" + K8S_NODEPORT_HOST + \":\" + adminServiceNodePort)\n+          .append(\"/management/tenant-monitoring/servers/dynamic-server1\")\n+          .append(\" --silent --show-error \")\n+          .append(\" -o /dev/null\")\n+          .append(\" -w %{http_code});\")\n+          .append(\"echo ${status}\");\n+    logger.info(\"curl command {0}\", new String(checkCluster));\n+    try {\n+      result = exec(new String(checkCluster), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Caught unexpected exception {0}\", ex);\n+      fail(\"Got unexpected exception\" + ex);\n+    }\n+\n+    logger.info(\"curl command returns {0}\", result.toString());\n+    assertEquals(\"200\", result.stdout(), \"Server configuration not found\");\n+    logger.info(\"Found the server configuration \");\n+\n+  }\n+\n+  /**\n+   * Create a configmap with a sparse model file to add a configured cluster.\n+   * Patch the domain resource with the configmap.\n+   * Update the restart version of the domain resource to 3\n+   * Patch the domain resource with the spec/replicas set to 1\n+   * Verify rolling restart of the domain by comparing PodCreationTimestamp before and after rolling restart.\n+   * Verify servers from new cluster are in running state.\n+   */\n+  @Test\n+  @Order(2)", "originalCommit": "5668feebdef576cd7e4f4f751114fe1e5176e313", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cd75d203a0c0188e7a45559f2abeb954c8755b1e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cd75d203a0c0188e7a45559f2abeb954c8755b1e", "message": "Remove the AddCluster usecase to another PR", "committedDate": "2020-05-14T01:36:44Z", "type": "commit"}]}