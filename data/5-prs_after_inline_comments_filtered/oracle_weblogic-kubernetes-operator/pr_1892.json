{"pr_number": 1892, "pr_title": "Changes for OWLS-83136 - Limit concurrent pod shutdowns during a cluster shrink", "pr_createdAt": "2020-08-31T21:26:50Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892", "timeline": [{"oid": "5fd47bf11596a912b6042c3623bab896f4ec611d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5fd47bf11596a912b6042c3623bab896f4ec611d", "message": "changes for OWLS-83136 - Limit concurrent pod shutdowns during a cluster shrink", "committedDate": "2020-08-31T19:31:12Z", "type": "commit"}, {"oid": "91b582068e2de94e6e94339685d1ab22de42e066", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/91b582068e2de94e6e94339685d1ab22de42e066", "message": "Minor code cleanup for OWLS-83136", "committedDate": "2020-08-31T21:15:23Z", "type": "commit"}, {"oid": "e948c9293da8abf7d360af3a2cab3ae620d5f24a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e948c9293da8abf7d360af3a2cab3ae620d5f24a", "message": "minor change to avoid duplicate step", "committedDate": "2020-08-31T21:23:12Z", "type": "commit"}, {"oid": "e7aea375215f94b3773d094e16342c360eaba040", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e7aea375215f94b3773d094e16342c360eaba040", "message": "fixed javadoc for deletePodAsyncWithRetryStrategy method", "committedDate": "2020-08-31T21:59:27Z", "type": "commit"}, {"oid": "f9b5dcacdf3181a7aad2540b6b1c7b560c69dd4a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f9b5dcacdf3181a7aad2540b6b1c7b560c69dd4a", "message": "fix for integration test and added maxConcurrentShutdown in index.html", "committedDate": "2020-09-01T17:46:46Z", "type": "commit"}, {"oid": "8597bca2836390659420e4603a74f6f363c45a82", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8597bca2836390659420e4603a74f6f363c45a82", "message": "fix unit test failure and shutdown servers concurrently when domain serverStartPolicy is NEVER", "committedDate": "2020-09-01T19:36:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA5MDA0MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482090041", "bodyText": "Please create the domain by calling DomainProcessorTestSetup.createTestDomain(). That ensures consistency of symbols and ensures that as new requirements are added to the domain, all tests will use them. If you need to add to the created domain, you can do so in your test.", "author": "russgold", "createdAt": "2020-09-02T13:57:48Z", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {", "originalCommit": "8597bca2836390659420e4603a74f6f363c45a82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA5OTIxMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482099210", "bodyText": "This code can be simplified by extracting a method and using Stream.collect:\n\n  @NotNull\n  private List<ServerShutdownInfo> createServerShutdownInfosForCluster(String clusterName, String... servers) {\n    return Arrays.stream(servers).map(s -> createShutdownInfo(clusterName, s)).collect(Collectors.toList());\n  }\n  \n  private ServerShutdownInfo createShutdownInfo(String clusterName, String serverName) {\n    return new ServerShutdownInfo(configSupport.getWlsServer(clusterName, serverName).getName(), clusterName);\n  }", "author": "russgold", "createdAt": "2020-09-02T14:10:00Z", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2_bothClusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf0_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount1_3clusteredServersShutdownIn2Threads() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2, MS3, MS4);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2,MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    assertThat(MS2 + \" pod\", domainPresenceInfo.getServerPod(MS2), notNullValue());\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER, MS1, MS2, MS3, MS4));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.FALSE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount0_4clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2, MS3, MS4);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2,MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER, MS1, MS2, MS3, MS4));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withMultipleClusters_differentClusterScheduleAndShutdownDifferently() {\n+    final String CLUSTER2 = \"cluster2\";\n+\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0).withReplicas(1);\n+    configureCluster(CLUSTER2).withMaxConcurrentShutdown(1).withReplicas(1);\n+\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    addWlsCluster(CLUSTER2, PORT, MS3, MS4);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2,MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    List<ServerShutdownInfo> serverShutdownInfos =\n+            createServerShutdownInfosForCluster(CLUSTER, MS1, MS2);\n+    serverShutdownInfos.addAll(createServerShutdownInfosForCluster(CLUSTER2, MS3, MS4));\n+    invokeStepWithServerShutdownInfos(serverShutdownInfos);\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.FALSE));\n+  }\n+\n+  @Test\n+  public void maxClusterConcurrentShutdown_doesNotApplyToNonClusteredServers() {\n+    domain.getSpec().setMaxClusterConcurrentShutdown(1);\n+\n+    addWlsServers(MS3, MS4);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfos(MS3, MS4));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.TRUE));\n+  }\n+\n+  @NotNull", "originalCommit": "8597bca2836390659420e4603a74f6f363c45a82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEwMDg4Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482100886", "bodyText": "This code can be simplified:\n\n  @NotNull\n  private List<ServerShutdownInfo> createServerShutdownInfos(String... servers) {\n    return Arrays.stream(servers).map(this::createShutdownInfo).collect(Collectors.toList());\n  }\n\n  @Nonnull\n  private ServerShutdownInfo createShutdownInfo(String server) {\n    return new ServerShutdownInfo(configSupport.getWlsServer(server).getName(), null);\n  }", "author": "russgold", "createdAt": "2020-09-02T14:12:10Z", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2_bothClusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf0_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount1_3clusteredServersShutdownIn2Threads() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2, MS3, MS4);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2,MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    assertThat(MS2 + \" pod\", domainPresenceInfo.getServerPod(MS2), notNullValue());\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER, MS1, MS2, MS3, MS4));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.FALSE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount0_4clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2, MS3, MS4);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2,MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER, MS1, MS2, MS3, MS4));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withMultipleClusters_differentClusterScheduleAndShutdownDifferently() {\n+    final String CLUSTER2 = \"cluster2\";\n+\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0).withReplicas(1);\n+    configureCluster(CLUSTER2).withMaxConcurrentShutdown(1).withReplicas(1);\n+\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    addWlsCluster(CLUSTER2, PORT, MS3, MS4);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2,MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    List<ServerShutdownInfo> serverShutdownInfos =\n+            createServerShutdownInfosForCluster(CLUSTER, MS1, MS2);\n+    serverShutdownInfos.addAll(createServerShutdownInfosForCluster(CLUSTER2, MS3, MS4));\n+    invokeStepWithServerShutdownInfos(serverShutdownInfos);\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.FALSE));\n+  }\n+\n+  @Test\n+  public void maxClusterConcurrentShutdown_doesNotApplyToNonClusteredServers() {\n+    domain.getSpec().setMaxClusterConcurrentShutdown(1);\n+\n+    addWlsServers(MS3, MS4);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfos(MS3, MS4));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.TRUE));\n+  }\n+\n+  @NotNull\n+  private List<ServerShutdownInfo> createServerShutdownInfosForCluster(String clusterName, String... servers) {\n+    List<ServerShutdownInfo> serverShutdownInfos = new ArrayList<>();\n+    Arrays.stream(servers).forEach(server ->\n+            serverShutdownInfos.add(\n+                    new ServerShutdownInfo(configSupport.getWlsServer(clusterName, server).getName(),\n+                            clusterName)\n+            )\n+    );\n+    return serverShutdownInfos;\n+  }\n+\n+  @NotNull", "originalCommit": "8597bca2836390659420e4603a74f6f363c45a82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEwODU0Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482108547", "bodyText": "This line that executes the code you're testing is repeated in each test, with the only real differences being that in some tests you create infos without a cluster, in some you create them with a cluster, and in one you create them for multiple clusters. As written now, it is hard at first glance to see what is going on.\nThis could be clarified in a number of ways. Maybe the cleanest would use a builder pattern, so that you could do something like.\ncreateShutdownInfos()\n    .forServers(MS1, MS2)\n    .forClusteredServers(CLUSTER, MS3, MS4)\n    .shutdown();\n\nThat would greatly improve readability of the tests. Also, please make sure to leave a blank line between the execution portion of each unit test and the assertions.", "author": "russgold", "createdAt": "2020-09-02T14:22:31Z", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));", "originalCommit": "8597bca2836390659420e4603a74f6f363c45a82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExMTY2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482111660", "bodyText": "Get in the habit of doing static imports for assertThat. Showing the class name doesn't help readability.\nIn addition, you invoke DomainPresenceInfo.isServerPodBeingDeleted a lot. It would be worthwhile to have a method that simply returns the names of all of the pods being deleted. That way you could do a single assert on the collection.", "author": "russgold", "createdAt": "2020-09-02T14:26:26Z", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(", "originalCommit": "8597bca2836390659420e4603a74f6f363c45a82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExMjUwMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482112502", "bodyText": "Remove blank lines in the middle of your test setup, reserving them as dividers between setup, execution, and validation.", "author": "russgold", "createdAt": "2020-09-02T14:27:26Z", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2_bothClusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf0_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+", "originalCommit": "8597bca2836390659420e4603a74f6f363c45a82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNDQ2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482114464", "bodyText": "What is going on in this test? Why do the servers shut down concurrently with a concurrency of 1? There seems to be something important going on, and the name of the test doesn't clarify it.", "author": "russgold", "createdAt": "2020-09-02T14:29:47Z", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2_bothClusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf0_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently() {", "originalCommit": "8597bca2836390659420e4603a74f6f363c45a82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ0ODgyNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482448826", "bodyText": "OWLS-83136 has below requirement -\nIf a WL cluster shrinks to '0' (i.e. replica count is set to 0), then this indicates that the administrator isn't concerned about preserving replicated/volatile state, there's no need to shutdown one-at-a-time, and we should do a concurrent shutdown. We ignore the concurrency value when replica count is set to 0.\nI can look into changing the test name to clarify it. Please let me know if you have any suggestions.", "author": "ankedia", "createdAt": "2020-09-02T20:50:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNDQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk3NjEzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482976135", "bodyText": "How about whenClusterShutdown_concurrencySettingIsIgnored ? (replica count set to 0 means the cluster is shutting down, which is why we don't care about concurrency)", "author": "russgold", "createdAt": "2020-09-03T13:26:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNDQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNTQ1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482115453", "bodyText": "What is going on in this test? Why do the servers shut down in separate threads? There seems to be something important going on, and the name of the test doesn't clarify it. Is this actually two separate cases? If so, perhaps it should be two tests.", "author": "russgold", "createdAt": "2020-09-02T14:30:57Z", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2_bothClusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf0_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount1_3clusteredServersShutdownIn2Threads() {", "originalCommit": "8597bca2836390659420e4603a74f6f363c45a82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ3ODMzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482478335", "bodyText": "It's meant to test that 3rd clustered server is terminated only after one of the previous two servers is completely shutdown (since concurrency is 2). I'll change the name to  withConcurrencyOf2AndReplicaCount1_3rdClusteredServerIsShutdownAfterPreviousPodTerminated(). Please let me know if this is not clear or if you have any suggestions.", "author": "ankedia", "createdAt": "2020-09-02T21:14:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNTQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk4MTA5NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482981094", "bodyText": "The problem with the name is that it doesn't really inform the reader of what is going on. The point, apparently, is that the concurrency setting limits the number of simultaneous servers shutting down. The replica count is only relevant in that you have reduced it.\nSo maybe something like, whenMaxConcurrentShutdownSet_limitNumberOfServersShuttingDownAtOnce", "author": "russgold", "createdAt": "2020-09-03T13:33:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNTQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjUyNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482116527", "bodyText": "What is going on in this test? What is the significance of the concurrency of 2, here? The name doesn't explain.", "author": "russgold", "createdAt": "2020-09-02T14:32:19Z", "path": "operator/src/test/java/oracle/kubernetes/operator/steps/ServerDownIteratorStepTest.java", "diffHunk": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.kubernetes.operator.steps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nonnull;\n+\n+import com.meterware.simplestub.Memento;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodCondition;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodStatus;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.kubernetes.operator.KubernetesConstants;\n+import oracle.kubernetes.operator.LabelConstants;\n+import oracle.kubernetes.operator.PodAwaiterStepFactory;\n+import oracle.kubernetes.operator.ProcessingConstants;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo;\n+import oracle.kubernetes.operator.helpers.DomainPresenceInfo.ServerShutdownInfo;\n+import oracle.kubernetes.operator.helpers.KubernetesTestSupport;\n+import oracle.kubernetes.operator.helpers.LegalNames;\n+import oracle.kubernetes.operator.helpers.PodHelperTestBase;\n+import oracle.kubernetes.operator.helpers.TuningParametersStub;\n+import oracle.kubernetes.operator.utils.WlsDomainConfigSupport;\n+import oracle.kubernetes.operator.wlsconfig.WlsClusterConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsDomainConfig;\n+import oracle.kubernetes.operator.wlsconfig.WlsServerConfig;\n+import oracle.kubernetes.operator.work.Step;\n+import oracle.kubernetes.operator.work.TerminalStep;\n+import oracle.kubernetes.utils.TestUtils;\n+import oracle.kubernetes.weblogic.domain.ClusterConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfigurator;\n+import oracle.kubernetes.weblogic.domain.DomainConfiguratorFactory;\n+import oracle.kubernetes.weblogic.domain.model.Domain;\n+import oracle.kubernetes.weblogic.domain.model.DomainSpec;\n+import org.hamcrest.junit.MatcherAssert;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.junit.MatcherAssert.assertThat;\n+\n+public class ServerDownIteratorStepTest {\n+\n+  protected static final String DOMAIN_NAME = \"domain1\";\n+  private static final String NS = \"namespace\";\n+  private static final String UID = \"uid1\";\n+  protected static final String KUBERNETES_UID = \"12345\";\n+  private static final String ADMIN = \"asName\";\n+  private static final String CLUSTER = \"cluster1\";\n+  private static final boolean INCLUDE_SERVER_OUT_IN_POD_LOG = true;\n+  private static final String CREDENTIALS_SECRET_NAME = \"webLogicCredentialsSecretName\";\n+  private static final String LATEST_IMAGE = \"image:latest\";\n+  private static final String MS_PREFIX = \"ms\";\n+  private static final String MS1 = MS_PREFIX + \"1\";\n+  private static final String MS2 = MS_PREFIX + \"2\";\n+  private static final String MS3 = MS_PREFIX + \"3\";\n+  private static final String MS4 = MS_PREFIX + \"4\";\n+  private static final int MAX_SERVERS = 5;\n+  private static final int PORT = 8001;\n+  private static final String[] MANAGED_SERVER_NAMES =\n+          IntStream.rangeClosed(1, MAX_SERVERS)\n+                  .mapToObj(ServerDownIteratorStepTest::getManagedServerName).toArray(String[]::new);\n+\n+  @Nonnull\n+  private static String getManagedServerName(int n) {\n+    return MS_PREFIX + n;\n+  }\n+\n+  private final Domain domain = createDomain();\n+  private final DomainConfigurator configurator = DomainConfiguratorFactory.forDomain(domain);\n+  private final WlsDomainConfigSupport configSupport = new WlsDomainConfigSupport(DOMAIN_NAME);\n+\n+  private final Step nextStep = new TerminalStep();\n+  private final KubernetesTestSupport testSupport = new KubernetesTestSupport();\n+  private final List<Memento> mementos = new ArrayList<>();\n+  private DomainPresenceInfo domainPresenceInfo = createDomainPresenceInfoWithServers();\n+  private final WlsDomainConfig domainConfig = createDomainConfig();\n+\n+  private static WlsDomainConfig createDomainConfig() {\n+    WlsClusterConfig clusterConfig = new WlsClusterConfig(CLUSTER);\n+    for (String serverName : MANAGED_SERVER_NAMES) {\n+      clusterConfig.addServerConfig(new WlsServerConfig(serverName, \"domain1-\" + serverName, 8001));\n+    }\n+    return new WlsDomainConfig(\"base_domain\")\n+            .withAdminServer(ADMIN, \"domain1-admin-server\", 7001)\n+            .withCluster(clusterConfig);\n+  }\n+\n+  private DomainPresenceInfo createDomainPresenceInfoWithServers(String... serverNames) {\n+    DomainPresenceInfo dpi = new DomainPresenceInfo(domain);\n+    addServer(dpi, ADMIN);\n+    Arrays.asList(serverNames).forEach(serverName -> addServer(dpi, serverName));\n+    return dpi;\n+  }\n+\n+  private Domain createDomain() {\n+    return new Domain()\n+            .withApiVersion(KubernetesConstants.DOMAIN_VERSION)\n+            .withKind(KubernetesConstants.DOMAIN)\n+            .withMetadata(new V1ObjectMeta().namespace(NS).name(DOMAIN_NAME).uid(KUBERNETES_UID))\n+            .withSpec(createDomainSpec());\n+  }\n+\n+  private DomainSpec createDomainSpec() {\n+    return new DomainSpec()\n+            .withDomainUid(UID)\n+            .withWebLogicCredentialsSecret(new V1SecretReference().name(CREDENTIALS_SECRET_NAME))\n+            .withIncludeServerOutInPodLog(INCLUDE_SERVER_OUT_IN_POD_LOG)\n+            .withImage(LATEST_IMAGE);\n+  }\n+\n+  private static void addServer(DomainPresenceInfo domainPresenceInfo, String serverName) {\n+    if (serverName.equals(ADMIN)) {\n+      domainPresenceInfo.setServerPod(serverName, createReadyPod(serverName));\n+    } else {\n+      domainPresenceInfo.setServerPod(serverName, createPod(serverName));\n+    }\n+  }\n+\n+  private static V1Pod createReadyPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName))\n+            .spec(new V1PodSpec().nodeName(\"Node1\"))\n+            .status(new V1PodStatus().phase(\"Running\")\n+            .addConditionsItem(new V1PodCondition().type(\"Ready\").status(\"True\")));\n+  }\n+\n+  private static V1Pod createPod(String serverName) {\n+    return new V1Pod().metadata(withNames(new V1ObjectMeta().namespace(NS), serverName));\n+  }\n+\n+  private static V1ObjectMeta withNames(V1ObjectMeta objectMeta, String serverName) {\n+    return objectMeta\n+            .name(LegalNames.toPodName(UID, serverName))\n+            .putLabelsItem(LabelConstants.SERVERNAME_LABEL, serverName);\n+  }\n+\n+  /**\n+   * Setup env for tests.\n+   * @throws NoSuchFieldException if TestStepFactory fails to install\n+   */\n+  @Before\n+  public void setUp() throws NoSuchFieldException {\n+    mementos.add(TestUtils.silenceOperatorLogger().ignoringLoggedExceptions(ApiException.class));\n+    mementos.add(TuningParametersStub.install());\n+    mementos.add(testSupport.install());\n+\n+    testSupport.defineResources(domain);\n+    testSupport\n+            .addToPacket(ProcessingConstants.DOMAIN_TOPOLOGY, domainConfig)\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    testSupport.addComponent(\n+            ProcessingConstants.PODWATCHER_COMPONENT_NAME,\n+            PodAwaiterStepFactory.class,\n+            new PodHelperTestBase.DelayedPodAwaiterStepFactory(1));\n+\n+  }\n+\n+  /**\n+   * Cleanup env after tests.\n+   * @throws Exception if test support failed\n+   */\n+  @After\n+  public void tearDown() throws Exception {\n+    for (Memento memento : mementos) {\n+      memento.revert();\n+    }\n+\n+    testSupport.throwOnCompletionFailure();\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf1_bothClusteredServersShutdownSequentially() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(1);\n+    addWlsCluster(CLUSTER, 8001, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2_bothClusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf0_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(1).withReplicas(0);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2);\n+\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER,MS1, MS2));\n+\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.TRUE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount1_3clusteredServersShutdownIn2Threads() {\n+    configureCluster(CLUSTER).withMaxConcurrentShutdown(2).withReplicas(1);\n+    addWlsCluster(CLUSTER, PORT, MS1, MS2, MS3, MS4);\n+    domainPresenceInfo = createDomainPresenceInfoWithServers(MS1, MS2,MS3,MS4);\n+    testSupport\n+            .addDomainPresenceInfo(domainPresenceInfo);\n+    assertThat(MS2 + \" pod\", domainPresenceInfo.getServerPod(MS2), notNullValue());\n+\n+    invokeStepWithServerShutdownInfos(createServerShutdownInfosForCluster(CLUSTER, MS1, MS2, MS3, MS4));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS4), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS3), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.FALSE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+    testSupport.setTime(10, TimeUnit.SECONDS);\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS2), is(Boolean.TRUE));\n+    MatcherAssert.assertThat(\n+            domainPresenceInfo.isServerPodBeingDeleted(MS1), is(Boolean.FALSE));\n+  }\n+\n+  @Test\n+  public void withConcurrencyOf2AndReplicaCount0_4clusteredServersShutdownConcurrently() {", "originalCommit": "8597bca2836390659420e4603a74f6f363c45a82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ3NDMyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482474329", "bodyText": "This test is similar to withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently(). When replica count is set to 0, it indicates that the administrator isn't concerned about preserving replicated/volatile state, there's no need to shutdown one-at-a-time. We ignore the concurrency value in when replica count is set to 0.  This test has 4 servers and concurrency value is set to 2 (as opposed to 2 servers and concurrency of 1 in withReplicaCountOf0AndConcurrencyOf1_clusteredServersShutdownConcurrently()).", "author": "ankedia", "createdAt": "2020-09-02T21:09:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjUyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk4MzE2Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482983166", "bodyText": "So it tests the same thing, only with multiple clusters? Use more or less the same wording suggested above, then, only indicate multiple clusters. I'm not sure how much this adds. Was any additional code needed to make this pass that wasn't needed for the other test?\nOTOH, it might be interesting to prove that you can shut down one cluster without pay attention to concurrency limits while simultaneously shrinking another cluster and have that one pay attention to those limits.", "author": "russgold", "createdAt": "2020-09-03T13:36:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyNTYyNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482125624", "bodyText": "The ability to add a custom retry strategy seems pretty general and you seem to be adding a fair bit of code to make it work only for the deletePod case. A better pattern, I think, would be to add a withRetryStrategy method to CallBuilder, analogous to withFieldSelector and withLabelSelectors and pass it along in that fashion. That way it could be used in other cases. At least look at how difficult that would be to do.", "author": "russgold", "createdAt": "2020-09-02T14:44:14Z", "path": "operator/src/main/java/oracle/kubernetes/operator/helpers/CallBuilder.java", "diffHunk": "@@ -1183,6 +1184,29 @@ public Step deletePodAsync(\n         responseStep, new RequestParams(\"deletePod\", namespace, name, deleteOptions, domainUid), deletePod);\n   }\n \n+  /**", "originalCommit": "8597bca2836390659420e4603a74f6f363c45a82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b6fdd72d13cf7f40920b50b636fd5a8f3b1538cd", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b6fdd72d13cf7f40920b50b636fd5a8f3b1538cd", "message": "Address PR review comments.", "committedDate": "2020-09-03T00:05:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5MTExMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482991110", "bodyText": "A simpler way to do this would be:\nreturn Optional.ofNullable(cluster).map(Cluster::getMaxConcurrentShutdown).orElse(getMaxClusterConcurrentShutdown());\n\nwhere getMaxClusterConcurrentShutdown()", "author": "russgold", "createdAt": "2020-09-03T13:47:58Z", "path": "operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainSpec.java", "diffHunk": "@@ -958,6 +975,20 @@ public void setMaxClusterConcurrentStartup(Integer maxClusterConcurrentStartup)\n     this.maxClusterConcurrentStartup = maxClusterConcurrentStartup;\n   }\n \n+  private int getMaxConcurrentShutdownFor(Cluster cluster) {", "originalCommit": "b6fdd72d13cf7f40920b50b636fd5a8f3b1538cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTI0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483205244", "bodyText": "Fixed.", "author": "ankedia", "createdAt": "2020-09-03T19:26:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5MTExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNjU0Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483206542", "bodyText": "Fixed.", "author": "ankedia", "createdAt": "2020-09-03T19:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5MTExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5Mjk2Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r482992966", "bodyText": "This line should not be needed. The point is that the cluster is not configured.", "author": "russgold", "createdAt": "2020-09-03T13:50:32Z", "path": "operator/src/test/java/oracle/kubernetes/weblogic/domain/DomainTestBase.java", "diffHunk": "@@ -400,6 +401,46 @@ public void whenBothClusterAndDomainSpecified_maxConcurrentStartupFromCluster()\n         equalTo(1));\n   }\n \n+  @Test\n+  public void afterMaxConcurrentShutdownSetForCluster_canReadIt() {\n+    configureCluster(\"cluster1\").withMaxConcurrentShutdown(3);\n+\n+    assertThat(domain.getMaxConcurrentShutdown(\"cluster1\"), equalTo(3));\n+  }\n+\n+  @Test\n+  public void whenNotSpecified_maxConcurrentShutdownHasDefault() {\n+    configureCluster(\"cluster1\");\n+    configureDomain(domain).withMaxConcurrentShutdown(null);\n+\n+    assertThat(domain.getMaxConcurrentShutdown(\"cluster1\"),\n+            equalTo(DEFAULT_MAX_CLUSTER_CONCURRENT_SHUTDOWN));\n+  }\n+\n+  @Test\n+  public void whenNotSpecified_maxConcurrentShutdownFromDomain() {", "originalCommit": "b6fdd72d13cf7f40920b50b636fd5a8f3b1538cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTM3MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483205370", "bodyText": "Fixed", "author": "ankedia", "createdAt": "2020-09-03T19:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5Mjk2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNjYzMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483206631", "bodyText": "Fixed.", "author": "ankedia", "createdAt": "2020-09-03T19:28:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5Mjk2Ng=="}], "type": "inlineReview"}, {"oid": "147e5dd66aaba6663c4862a47f9734b1b2753123", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/147e5dd66aaba6663c4862a47f9734b1b2753123", "message": "Changes to address PR review comments.", "committedDate": "2020-09-03T19:23:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc3OTAwNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483779006", "bodyText": "Surprisingly, this text is slightly different. \"The default maximum number of \". \"shutdown\" -> \"shut down\". \"attribute\" -> \"field\". \"Defaults to 1.\" (add period).", "author": "rjeberhard", "createdAt": "2020-09-04T18:12:01Z", "path": "operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainSpec.java", "diffHunk": "@@ -208,6 +209,15 @@\n   @Range(minimum = 0)\n   private Integer maxClusterConcurrentStartup;\n \n+  @Description(\n+          \"The default maximum WebLogic Server instances that a cluster will shutdown in parallel when it is being \"", "originalCommit": "147e5dd66aaba6663c4862a47f9734b1b2753123", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc3OTczOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483779739", "bodyText": "Missing change to toString()", "author": "rjeberhard", "createdAt": "2020-09-04T18:13:48Z", "path": "operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainSpec.java", "diffHunk": "@@ -886,7 +902,8 @@ public boolean equals(Object other) {\n             .append(configOverrides, rhs.configOverrides)\n             .append(configOverrideSecrets, rhs.configOverrideSecrets)\n             .append(isAllowReplicasBelowMinDynClusterSize(), rhs.isAllowReplicasBelowMinDynClusterSize())\n-            .append(getMaxClusterConcurrentStartup(), rhs.getMaxClusterConcurrentStartup());\n+            .append(getMaxClusterConcurrentStartup(), rhs.getMaxClusterConcurrentStartup())", "originalCommit": "147e5dd66aaba6663c4862a47f9734b1b2753123", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc3OTk3Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483779972", "bodyText": "Missing change to toString()", "author": "rjeberhard", "createdAt": "2020-09-04T18:14:21Z", "path": "operator/src/main/java/oracle/kubernetes/weblogic/domain/model/Cluster.java", "diffHunk": "@@ -224,6 +241,7 @@ public boolean equals(Object o) {\n         .append(maxUnavailable, cluster.maxUnavailable)\n         .append(allowReplicasBelowMinDynClusterSize, cluster.allowReplicasBelowMinDynClusterSize)\n         .append(maxConcurrentStartup, cluster.maxConcurrentStartup)\n+        .append(maxConcurrentShutdown, cluster.maxConcurrentShutdown)", "originalCommit": "147e5dd66aaba6663c4862a47f9734b1b2753123", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc4MjA5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1892#discussion_r483782093", "bodyText": "\"The maximum number of WebLogic\". \"shutdown\" -> \"shut down\". \"count. \" (add space). Add a comma after \"spec.maxClusterConcurrentShutdown\" and then change \"(which in turn defaults to 1).\" to \"which defaults to 1.\"", "author": "rjeberhard", "createdAt": "2020-09-04T18:19:33Z", "path": "operator/src/main/java/oracle/kubernetes/weblogic/domain/model/Cluster.java", "diffHunk": "@@ -88,6 +88,15 @@\n   @Range(minimum = 0)\n   private Integer maxConcurrentStartup;\n \n+  @Description(\n+          \"The maximum WebLogic Server instances that will shutdown in parallel \"", "originalCommit": "147e5dd66aaba6663c4862a47f9734b1b2753123", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fa9a802c9a4a8cfd08ab497c151b0f26c149f33f", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/fa9a802c9a4a8cfd08ab497c151b0f26c149f33f", "message": "Changes to address PR review comments.", "committedDate": "2020-09-04T20:47:07Z", "type": "commit"}, {"oid": "8f71eaf45a2b2d71b9782a1bba75c4dc27297087", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8f71eaf45a2b2d71b9782a1bba75c4dc27297087", "message": "Changes to address PR review comments", "committedDate": "2020-09-04T20:57:36Z", "type": "commit"}, {"oid": "cfb2a3258acef8d01c5a8f3240f7928197f988a5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cfb2a3258acef8d01c5a8f3240f7928197f988a5", "message": "Resolve merge conflict", "committedDate": "2020-09-04T22:27:16Z", "type": "commit"}, {"oid": "1da2459d657f3d8e9806dbdf325f19cf75e03aed", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1da2459d657f3d8e9806dbdf325f19cf75e03aed", "message": "Enable unit tests", "committedDate": "2020-09-04T22:33:38Z", "type": "commit"}, {"oid": "7bc236c8dccf0bd9dfbf50c8a17b476ef71cdce0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7bc236c8dccf0bd9dfbf50c8a17b476ef71cdce0", "message": "Use Dongbo's change in unit test", "committedDate": "2020-09-04T22:53:36Z", "type": "commit"}, {"oid": "7be392d10e559249c78ff36b4f07b79747d1987e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7be392d10e559249c78ff36b4f07b79747d1987e", "message": "Merge remote-tracking branch 'origin/develop' into OWLS-83136-limit-concurrent-shutdowns", "committedDate": "2020-09-04T23:07:39Z", "type": "commit"}]}