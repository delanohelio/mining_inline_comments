{"pr_number": 1614, "pr_title": "Nginx mii new it", "pr_createdAt": "2020-05-02T00:53:14Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614", "timeline": [{"oid": "c0b211e7d11b55a7648455eb686ccc22e6f7cfd3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c0b211e7d11b55a7648455eb686ccc22e6f7cfd3", "message": "init commit", "committedDate": "2020-04-30T19:23:02Z", "type": "commit"}, {"oid": "798190a169b2642a7e6956a1b7a32f7c4d18cadf", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/798190a169b2642a7e6956a1b7a32f7c4d18cadf", "message": "use kubernetes API call to create ingress", "committedDate": "2020-05-01T00:41:12Z", "type": "commit"}, {"oid": "a4b6be698ed3b1a4375a6929c4f54c1ee6534b29", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a4b6be698ed3b1a4375a6929c4f54c1ee6534b29", "message": "add more debug info for Jenkins run", "committedDate": "2020-05-01T02:42:22Z", "type": "commit"}, {"oid": "e3cfb8afecdafe4c195118d86de5864f0da29423", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e3cfb8afecdafe4c195118d86de5864f0da29423", "message": "add more debug info for Jenkins run", "committedDate": "2020-05-01T03:29:28Z", "type": "commit"}, {"oid": "7519ca6318020e4eeb38f78ffd2b8d4251699f1d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7519ca6318020e4eeb38f78ffd2b8d4251699f1d", "message": "add more debug info for Jenkins run", "committedDate": "2020-05-01T04:37:27Z", "type": "commit"}, {"oid": "f37427de2d32e226281b523390ebb00868899a9a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f37427de2d32e226281b523390ebb00868899a9a", "message": "remove debug info for Jenkins run", "committedDate": "2020-05-01T04:51:05Z", "type": "commit"}, {"oid": "da9beaf5c9521389e5a7a6dcbf7f53966fceb3a8", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/da9beaf5c9521389e5a7a6dcbf7f53966fceb3a8", "message": "remove unused imports", "committedDate": "2020-05-01T04:54:16Z", "type": "commit"}, {"oid": "b3e427413bd0728b09fe2c9b5b2842fc18b601f7", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b3e427413bd0728b09fe2c9b5b2842fc18b601f7", "message": "get the latest from develop", "committedDate": "2020-05-01T19:48:23Z", "type": "commit"}, {"oid": "368bcaac348b6480b459c6f551b4402e194f4ac7", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/368bcaac348b6480b459c6f551b4402e194f4ac7", "message": "get Sankar's cleanup", "committedDate": "2020-05-01T23:13:28Z", "type": "commit"}, {"oid": "7b0d9509c3b703f372e6a5f144b9c165f37ccda1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7b0d9509c3b703f372e6a5f144b9c165f37ccda1", "message": "uninstall nginx release for now", "committedDate": "2020-05-02T00:42:48Z", "type": "commit"}, {"oid": "a26c9c9234718a80290ec90b096ec7f431ab0ee3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a26c9c9234718a80290ec90b096ec7f431ab0ee3", "message": "cleanup", "committedDate": "2020-05-02T05:58:58Z", "type": "commit"}, {"oid": "c6f852bd850a0aebad562c74fa48926f1990f2e7", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c6f852bd850a0aebad562c74fa48926f1990f2e7", "message": "more cleanup", "committedDate": "2020-05-02T12:50:46Z", "type": "commit"}, {"oid": "ff1e03c6f071ae1cafc8be81d1c541f869a1cc61", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ff1e03c6f071ae1cafc8be81d1c541f869a1cc61", "message": "cleanup", "committedDate": "2020-05-02T16:31:26Z", "type": "commit"}, {"oid": "5a4081a631da47b1284071854dd3be78d59bc803", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5a4081a631da47b1284071854dd3be78d59bc803", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into nginx-mii-new-it", "committedDate": "2020-05-04T16:43:15Z", "type": "commit"}, {"oid": "49296720511157a50acf208989f17ff93bf72e7a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/49296720511157a50acf208989f17ff93bf72e7a", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into nginx-mii-new-it", "committedDate": "2020-05-04T23:16:37Z", "type": "commit"}, {"oid": "a98473022acae51989e3359fb3825f92518e2103", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a98473022acae51989e3359fb3825f92518e2103", "message": "change DynamicClusterSize in sample wdt model file", "committedDate": "2020-05-05T01:51:39Z", "type": "commit"}, {"oid": "f50a12f69873649ac2ea50d54fbb00672a7b99f9", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f50a12f69873649ac2ea50d54fbb00672a7b99f9", "message": "Merge branch 'develop' into nginx-mii-new-it", "committedDate": "2020-05-05T18:50:53Z", "type": "commit"}, {"oid": "486b8376d245f54aa72cbf060ef52f01b4ccde15", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/486b8376d245f54aa72cbf060ef52f01b4ccde15", "message": "get the latest develop", "committedDate": "2020-05-05T19:23:50Z", "type": "commit"}, {"oid": "cc20393a31e9d2d59f2f4c62b6a7d5968d337d6a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cc20393a31e9d2d59f2f4c62b6a7d5968d337d6a", "message": "Merge branch 'nginx-mii-new-it' of https://github.com/oracle/weblogic-kubernetes-operator into nginx-mii-new-it", "committedDate": "2020-05-05T19:24:11Z", "type": "commit"}, {"oid": "f5f282cd562de543c51e96ea752d103e2ead5f1a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/f5f282cd562de543c51e96ea752d103e2ead5f1a", "message": "resolve merge conflicts", "committedDate": "2020-05-05T20:03:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjIyNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420506225", "bodyText": "NGINX - spelling", "author": "markxnelson", "createdAt": "2020-05-06T01:56:39Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -0,0 +1,618 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getIngressList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the sample application can be accessed via the ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the sample application can be accessed via the ingress controller\")\n+@IntegrationTest\n+class ItSimpleNginxValidation implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static String nginxNamespace = null;\n+  private static int nodeportshttp;\n+  private static int nodeportshttps;\n+\n+  private String domainUid = \"domain1\";\n+  private final String managedServerNameBase = \"managed-server\";\n+  private final int replicaCount = 2;\n+\n+  /**\n+   * Install operator and Nginx.", "originalCommit": "f5f282cd562de543c51e96ea752d103e2ead5f1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0ODI1MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420548250", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-06T05:10:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjIyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjM3MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420506371", "bodyText": "comment and log message don't match what you are doing", "author": "markxnelson", "createdAt": "2020-05-06T01:57:18Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -0,0 +1,618 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getIngressList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the sample application can be accessed via the ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the sample application can be accessed via the ingress controller\")\n+@IntegrationTest\n+class ItSimpleNginxValidation implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static String nginxNamespace = null;\n+  private static int nodeportshttp;\n+  private static int nodeportshttps;\n+\n+  private String domainUid = \"domain1\";\n+  private final String managedServerNameBase = \"managed-server\";\n+  private final int replicaCount = 2;\n+\n+  /**\n+   * Install operator and Nginx.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique operator namespace", "originalCommit": "f5f282cd562de543c51e96ea752d103e2ead5f1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0OTM4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420549384", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-06T05:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjQ1OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420506459", "bodyText": "spelling - NGINX - will not comment on any more, but this applies to all of them", "author": "markxnelson", "createdAt": "2020-05-06T01:57:39Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -0,0 +1,618 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getIngressList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the sample application can be accessed via the ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the sample application can be accessed via the ingress controller\")\n+@IntegrationTest\n+class ItSimpleNginxValidation implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static String nginxNamespace = null;\n+  private static int nodeportshttp;\n+  private static int nodeportshttps;\n+\n+  private String domainUid = \"domain1\";\n+  private final String managedServerNameBase = \"managed-server\";\n+  private final int replicaCount = 2;\n+\n+  /**\n+   * Install operator and Nginx.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique operator namespace\n+    logger.info(\"Creating an unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domain namespace\n+    logger.info(\"Creating an unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // get a new unique Nginx namespace", "originalCommit": "f5f282cd562de543c51e96ea752d103e2ead5f1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0OTQwNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420549406", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-06T05:15:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjYzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420506635", "bodyText": "OCIR -> registry\nyou don't know it will be OCIR", "author": "markxnelson", "createdAt": "2020-05-06T01:58:30Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -0,0 +1,618 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getIngressList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the sample application can be accessed via the ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the sample application can be accessed via the ingress controller\")\n+@IntegrationTest\n+class ItSimpleNginxValidation implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static String nginxNamespace = null;\n+  private static int nodeportshttp;\n+  private static int nodeportshttps;\n+\n+  private String domainUid = \"domain1\";\n+  private final String managedServerNameBase = \"managed-server\";\n+  private final int replicaCount = 2;\n+\n+  /**\n+   * Install operator and Nginx.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique operator namespace\n+    logger.info(\"Creating an unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domain namespace\n+    logger.info(\"Creating an unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // get a new unique Nginx namespace\n+    logger.info(\"Creating an unique namespace for Nginx\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    nginxNamespace = namespaces.get(2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+\n+    // get a free node port for Nginx\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify Nginx\n+    installAndVerifyNginx();\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    String managedServerPrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+    // create image with model files\n+    String miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster", "originalCommit": "f5f282cd562de543c51e96ea752d103e2ead5f1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0OTQ0OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420549449", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-06T05:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjg5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420506897", "bodyText": "very nice test! thank you", "author": "markxnelson", "createdAt": "2020-05-06T01:59:38Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -0,0 +1,618 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getIngressList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the sample application can be accessed via the ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the sample application can be accessed via the ingress controller\")\n+@IntegrationTest\n+class ItSimpleNginxValidation implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static String nginxNamespace = null;\n+  private static int nodeportshttp;\n+  private static int nodeportshttps;\n+\n+  private String domainUid = \"domain1\";\n+  private final String managedServerNameBase = \"managed-server\";\n+  private final int replicaCount = 2;\n+\n+  /**\n+   * Install operator and Nginx.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique operator namespace\n+    logger.info(\"Creating an unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domain namespace\n+    logger.info(\"Creating an unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // get a new unique Nginx namespace\n+    logger.info(\"Creating an unique namespace for Nginx\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    nginxNamespace = namespaces.get(2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+\n+    // get a free node port for Nginx\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify Nginx\n+    installAndVerifyNginx();\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    String managedServerPrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+    // create image with model files\n+    String miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap<>();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap<>();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\"))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }", "originalCommit": "f5f282cd562de543c51e96ea752d103e2ead5f1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0OTUyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420549529", "bodyText": "thank you!", "author": "xiancao", "createdAt": "2020-05-06T05:15:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzA5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420507096", "bodyText": "remove trailing space", "author": "markxnelson", "createdAt": "2020-05-06T02:00:22Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -0,0 +1,618 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getIngressList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the sample application can be accessed via the ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the sample application can be accessed via the ingress controller\")\n+@IntegrationTest\n+class ItSimpleNginxValidation implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static String nginxNamespace = null;\n+  private static int nodeportshttp;\n+  private static int nodeportshttps;\n+\n+  private String domainUid = \"domain1\";\n+  private final String managedServerNameBase = \"managed-server\";\n+  private final int replicaCount = 2;\n+\n+  /**\n+   * Install operator and Nginx.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique operator namespace\n+    logger.info(\"Creating an unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domain namespace\n+    logger.info(\"Creating an unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // get a new unique Nginx namespace\n+    logger.info(\"Creating an unique namespace for Nginx\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    nginxNamespace = namespaces.get(2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+\n+    // get a free node port for Nginx\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify Nginx\n+    installAndVerifyNginx();\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    String managedServerPrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+    // create image with model files\n+    String miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap<>();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap<>();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\"))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+  }\n+\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Create an ingress for a WebLogic domain in the specified domain namespace\")\n+  public void testCreateIngress() {\n+\n+    // create an ingress in domain namespace\n+    assertThat(assertDoesNotThrow(() -> createIngress(domainNamespace, domainUid)))\n+            .as(\"createIngress succeeds\")\n+            .withFailMessage(String.format(\"failed to create an ingress for domain %s in namespace %s\",\n+                domainUid, domainNamespace))\n+            .isTrue();\n+\n+    // check the ingress is created\n+    String ingressName = domainUid + \"-nginx\";\n+    assertThat(assertDoesNotThrow(() -> getIngressList(domainNamespace)))\n+        .as(String.format(\"found the ingress %s in namespace %s\", ingressName, domainNamespace))\n+        .withFailMessage(String.format(\"can not find ingress %s in namespace %s\", ingressName, domainNamespace))\n+        .contains(ingressName);\n+\n+    logger.info(\"ingress is created in namespace {0}\", domainNamespace);\n+  }\n+\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"Verify the application can be accessed through the ingress controller \")", "originalCommit": "f5f282cd562de543c51e96ea752d103e2ead5f1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0OTU2MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420549561", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-06T05:15:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzM0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420507348", "bodyText": "this feels like it might be universally reusable, maybe it belongs in a different class", "author": "markxnelson", "createdAt": "2020-05-06T02:01:38Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -0,0 +1,618 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getIngressList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the sample application can be accessed via the ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the sample application can be accessed via the ingress controller\")\n+@IntegrationTest\n+class ItSimpleNginxValidation implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static String nginxNamespace = null;\n+  private static int nodeportshttp;\n+  private static int nodeportshttps;\n+\n+  private String domainUid = \"domain1\";\n+  private final String managedServerNameBase = \"managed-server\";\n+  private final int replicaCount = 2;\n+\n+  /**\n+   * Install operator and Nginx.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique operator namespace\n+    logger.info(\"Creating an unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domain namespace\n+    logger.info(\"Creating an unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // get a new unique Nginx namespace\n+    logger.info(\"Creating an unique namespace for Nginx\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    nginxNamespace = namespaces.get(2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+\n+    // get a free node port for Nginx\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify Nginx\n+    installAndVerifyNginx();\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    String managedServerPrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+    // create image with model files\n+    String miiImage = createImageAndVerify();\n+\n+    // push the image to OCIR to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap<>();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap<>();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\"))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+  }\n+\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Create an ingress for a WebLogic domain in the specified domain namespace\")\n+  public void testCreateIngress() {\n+\n+    // create an ingress in domain namespace\n+    assertThat(assertDoesNotThrow(() -> createIngress(domainNamespace, domainUid)))\n+            .as(\"createIngress succeeds\")\n+            .withFailMessage(String.format(\"failed to create an ingress for domain %s in namespace %s\",\n+                domainUid, domainNamespace))\n+            .isTrue();\n+\n+    // check the ingress is created\n+    String ingressName = domainUid + \"-nginx\";\n+    assertThat(assertDoesNotThrow(() -> getIngressList(domainNamespace)))\n+        .as(String.format(\"found the ingress %s in namespace %s\", ingressName, domainNamespace))\n+        .withFailMessage(String.format(\"can not find ingress %s in namespace %s\", ingressName, domainNamespace))\n+        .contains(ingressName);\n+\n+    logger.info(\"ingress is created in namespace {0}\", domainNamespace);\n+  }\n+\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"Verify the application can be accessed through the ingress controller \")\n+  public void testSampleAppThroughIngressController() throws Exception {\n+\n+    List<String> managedServerNames = new ArrayList<>();\n+    for (int i = 1; i <= replicaCount; i++) {\n+      managedServerNames.add(managedServerNameBase + i);\n+    }\n+\n+    // check that Nginx can access the sample apps from all managed servers in the domain\n+    String curlCmd = String.format(\"curl --silent --noproxy '*' -H 'host: %s' http://%s:%s/sample-war/index.jsp\",\n+        domainUid + \".org\", K8S_NODEPORT_HOST, nodeportshttp);\n+    assertThat(callWebAppAndCheckForServerNameInResponse(curlCmd, managedServerNames, 50))\n+        .as(\"Nginx can access the sample app from all managed servers in the domain\")\n+        .withFailMessage(\"Nginx can not access the sample app from one or more of the managed servers\")\n+        .isTrue();\n+  }\n+\n+  /**\n+   * TODO: remove this after Sankar's PR is merged\n+   * The cleanup framework does not uninstall Nginx release. Do it here for now.\n+   */\n+  @AfterAll\n+  public void tearDownAll() {\n+    // uninstall Nginx release\n+    if (nginxHelmParams != null) {\n+      assertThat(uninstallNginx(nginxHelmParams))\n+          .as(\"Test uninstallNginx returns true\")\n+          .withFailMessage(\"uninstallNginx() did not return true\")\n+          .isTrue();\n+    }\n+  }\n+\n+  /**\n+   * Install WebLogic operator and wait until the operator pod is ready.\n+   */\n+  private static void installAndVerifyOperator() {", "originalCommit": "f5f282cd562de543c51e96ea752d103e2ead5f1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0OTg2Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420549866", "bodyText": "Vanaja will create a PR to re-organize the common methods used by everybody.", "author": "xiancao", "createdAt": "2020-05-06T05:17:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEwNDYwNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r421104606", "bodyText": "Just to clarify, I am not working on re-organizing the common methods..I will be creating a basic domain image for MII in extension class which can be used by It classes.", "author": "vanajamukkara", "createdAt": "2020-05-06T21:30:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzY1MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420507651", "bodyText": "feels like the cluster name should be a parameter", "author": "markxnelson", "createdAt": "2020-05-06T02:03:13Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Nginx.java", "diffHunk": "@@ -0,0 +1,159 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1HTTPIngressPath;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1HTTPIngressRuleValue;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1IngressBackend;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1IngressList;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1IngressRule;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1IngressSpec;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Helm;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+\n+/**\n+ * Utility class for Nginx ingress controller.\n+ */\n+public class Nginx {\n+\n+  private static final String INGRESS_API_VERSION = \"extensions/v1beta1\";\n+  private static final String INGRESS_KIND = \"Ingress\";\n+  private static final String INGRESS_NGINX_CLASS = \"nginx\";\n+\n+  /**\n+   * Install Nginx Helm chart.\n+   *\n+   * @param params the parameters to Helm install command such as release name, namespace, repo url or chart dir,\n+   *               chart name and chart values\n+   * @return true on success, false otherwise\n+   */\n+  public static boolean install(NginxParams params) {\n+    return Helm.install(params.getHelmParams(), params.getValues());\n+  }\n+\n+  /**\n+   * Upgrade Nginx Helm release.\n+   *\n+   * @param params the parameters to Helm upgrade command such as release name, namespace and chart values to override\n+   * @return true on success, false otherwise\n+   */\n+  public static boolean upgrade(NginxParams params) {\n+    return Helm.upgrade(params.getHelmParams(), params.getValues());\n+  }\n+\n+  /**\n+   * Uninstall Nginx Helm release.\n+   *\n+   * @param params the parameters to Helm uninstall command such as release name and namespace\n+   * @return true on success, false otherwise\n+   */\n+  public static boolean uninstall(HelmParams params) {\n+    return Helm.uninstall(params);\n+  }\n+\n+  /**\n+   * Create an ingress for the WebLogic domain with domainUid in the specified domain namespace.\n+   * This method assumes the cluster name is \"cluster-1\" and the managed server port is 8001.\n+   *\n+   * @param domainNamespace the WebLogic domain namespace in which the ingress will be created\n+   * @param domainUid the WebLogic domainUid which is backend to the ingress\n+   * @return true on success, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static boolean createIngress(String domainNamespace, String domainUid) throws ApiException {", "originalCommit": "f5f282cd562de543c51e96ea752d103e2ead5f1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzY3MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420507671", "bodyText": "probably the port too", "author": "markxnelson", "createdAt": "2020-05-06T02:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzY1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU1MDM4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420550389", "bodyText": "Added a cluster name and managed server port as parameters. Removed the createIngress(domainNamespace, domainUid) method.", "author": "xiancao", "createdAt": "2020-05-06T05:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzk5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420507993", "bodyText": ".test would be safer :)", "author": "markxnelson", "createdAt": "2020-05-06T02:04:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/Nginx.java", "diffHunk": "@@ -0,0 +1,159 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1HTTPIngressPath;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1HTTPIngressRuleValue;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1Ingress;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1IngressBackend;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1IngressList;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1IngressRule;\n+import io.kubernetes.client.openapi.models.ExtensionsV1beta1IngressSpec;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Helm;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+\n+/**\n+ * Utility class for Nginx ingress controller.\n+ */\n+public class Nginx {\n+\n+  private static final String INGRESS_API_VERSION = \"extensions/v1beta1\";\n+  private static final String INGRESS_KIND = \"Ingress\";\n+  private static final String INGRESS_NGINX_CLASS = \"nginx\";\n+\n+  /**\n+   * Install Nginx Helm chart.\n+   *\n+   * @param params the parameters to Helm install command such as release name, namespace, repo url or chart dir,\n+   *               chart name and chart values\n+   * @return true on success, false otherwise\n+   */\n+  public static boolean install(NginxParams params) {\n+    return Helm.install(params.getHelmParams(), params.getValues());\n+  }\n+\n+  /**\n+   * Upgrade Nginx Helm release.\n+   *\n+   * @param params the parameters to Helm upgrade command such as release name, namespace and chart values to override\n+   * @return true on success, false otherwise\n+   */\n+  public static boolean upgrade(NginxParams params) {\n+    return Helm.upgrade(params.getHelmParams(), params.getValues());\n+  }\n+\n+  /**\n+   * Uninstall Nginx Helm release.\n+   *\n+   * @param params the parameters to Helm uninstall command such as release name and namespace\n+   * @return true on success, false otherwise\n+   */\n+  public static boolean uninstall(HelmParams params) {\n+    return Helm.uninstall(params);\n+  }\n+\n+  /**\n+   * Create an ingress for the WebLogic domain with domainUid in the specified domain namespace.\n+   * This method assumes the cluster name is \"cluster-1\" and the managed server port is 8001.\n+   *\n+   * @param domainNamespace the WebLogic domain namespace in which the ingress will be created\n+   * @param domainUid the WebLogic domainUid which is backend to the ingress\n+   * @return true on success, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static boolean createIngress(String domainNamespace, String domainUid) throws ApiException {\n+    return createIngress(domainNamespace, domainUid, \"cluster-1\", 8001);\n+  }\n+\n+  /**\n+   * Create an ingress for the WebLogic domain with domainUid in the specified domain namespace.\n+   *\n+   * @param domainNamespace the WebLogic domain namespace in which the ingress will be created\n+   * @param domainUid the WebLogic domainUid which is backend to the ingress\n+   * @param clusterName the name of the WebLogic domain cluster\n+   * @param managedServerPort the port number of the WebLogic domain managed servers\n+   * @return true on success, false otherwise\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static boolean createIngress(String domainNamespace,\n+                                      String domainUid,\n+                                      String clusterName,\n+                                      int managedServerPort) throws ApiException {\n+\n+    // set the annotation for kubernetes.io/ingress.class to nginx\n+    HashMap<String, String> annotation = new HashMap<>();\n+    annotation.put(\"kubernetes.io/ingress.class\", INGRESS_NGINX_CLASS);\n+\n+    // set the http ingress paths\n+    ExtensionsV1beta1HTTPIngressPath httpIngressPath = new ExtensionsV1beta1HTTPIngressPath()\n+        .path(null)\n+        .backend(new ExtensionsV1beta1IngressBackend()\n+                .serviceName(domainUid + \"-cluster-\" + clusterName.toLowerCase().replace(\"_\", \"-\"))\n+                .servicePort(new IntOrString(managedServerPort))\n+        );\n+    ArrayList<ExtensionsV1beta1HTTPIngressPath> httpIngressPaths = new ArrayList<>();\n+    httpIngressPaths.add(httpIngressPath);\n+\n+    // set the ingress rule\n+    ExtensionsV1beta1IngressRule ingressRule = new ExtensionsV1beta1IngressRule()\n+        .host(domainUid + \".org\")", "originalCommit": "f5f282cd562de543c51e96ea752d103e2ead5f1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU1MDQyNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420550426", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-06T05:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNzk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwODExNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420508115", "bodyText": "space after //", "author": "markxnelson", "createdAt": "2020-05-06T02:05:21Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/primitive/Helm.java", "diffHunk": "@@ -94,13 +105,13 @@ public static boolean upgrade(HelmParams params, Map<String, Object> chartValues\n         .isNotNull()\n         .isNotEmpty();\n \n-    //chart reference to be used in helm upgrade\n+    //chart reference to be used in Helm upgrade", "originalCommit": "f5f282cd562de543c51e96ea752d103e2ead5f1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU1MDQ3MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420550470", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-06T05:19:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwODExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwODM1Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420508352", "bodyText": "you were right the first time, space before colon, not after", "author": "markxnelson", "createdAt": "2020-05-06T02:06:30Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -197,11 +223,11 @@ public static V1Pod getPod(String namespace, String labelSelector, String podNam\n             Boolean.FALSE // Watch for changes to the described resources.\n         );\n     for (V1Pod item : v1PodList.getItems()) {\n-      if (item.getMetadata().getName().startsWith(podName.trim())) {\n-        logger.info(\"Pod Name: \" + item.getMetadata().getName());\n-        logger.info(\"Pod Namespace: \" + item.getMetadata().getNamespace());\n-        logger.info(\"Pod UID: \" + item.getMetadata().getUid());\n-        logger.info(\"Pod Status: \" + item.getStatus().getPhase());\n+      if (item.getMetadata().getName().contains(podName.trim())) {\n+        logger.info(\"Pod Name :\" + item.getMetadata().getName());", "originalCommit": "f5f282cd562de543c51e96ea752d103e2ead5f1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU1MDQ5OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420550499", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-06T05:20:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwODM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwODU0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420508548", "bodyText": "try { \n  Thread.sleep(100); \n} catch (InterruptedException ignore) {\n  // ignored intentionally \n}", "author": "markxnelson", "createdAt": "2020-05-06T02:07:27Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+\n+/**\n+ * The utility class for tests.\n+ */\n+public class TestUtils {\n+\n+  /**\n+   * Call the curl command and check the app can be reached from all managed servers.\n+   *\n+   * @param curlCmd curl command to call the sample app\n+   * @param managedServerNames managed server names that the sample app response should return\n+   * @param maxIterations max iterations to call the curl command\n+   * @return true if the web app can hit all managed servers, false otherwise\n+   */\n+  public static boolean callWebAppAndCheckForServerNameInResponse(\n+                          String curlCmd,\n+                          List<String> managedServerNames,\n+                          int maxIterations) {\n+\n+    // first map all server names with false\n+    HashMap<String, Boolean> managedServers = new HashMap<>();\n+    managedServerNames.forEach(managedServerName ->\n+        managedServers.put(managedServerName, false)\n+    );\n+\n+    logger.info(\"Calling webapp at most {0} times using command: {1}\", maxIterations, curlCmd);\n+\n+    // check the response contains managed server name\n+    for (int i = 1; i <= maxIterations; i++) {\n+\n+      if (!managedServers.containsValue(false)) {\n+        return true;\n+      } else {\n+        try {\n+          // sometimes the pod is not ready even the condition check is ready, sleep a little bit\n+          Thread.sleep(100);", "originalCommit": "f5f282cd562de543c51e96ea752d103e2ead5f1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU1MDUzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420550535", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-06T05:20:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwODU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwODY4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420508684", "bodyText": "singular", "author": "markxnelson", "createdAt": "2020-05-06T02:07:58Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+\n+/**\n+ * The utility class for tests.\n+ */\n+public class TestUtils {\n+\n+  /**\n+   * Call the curl command and check the app can be reached from all managed servers.\n+   *\n+   * @param curlCmd curl command to call the sample app\n+   * @param managedServerNames managed server names that the sample app response should return\n+   * @param maxIterations max iterations to call the curl command\n+   * @return true if the web app can hit all managed servers, false otherwise\n+   */\n+  public static boolean callWebAppAndCheckForServerNameInResponse(\n+                          String curlCmd,\n+                          List<String> managedServerNames,\n+                          int maxIterations) {\n+\n+    // first map all server names with false\n+    HashMap<String, Boolean> managedServers = new HashMap<>();\n+    managedServerNames.forEach(managedServerName ->\n+        managedServers.put(managedServerName, false)\n+    );\n+\n+    logger.info(\"Calling webapp at most {0} times using command: {1}\", maxIterations, curlCmd);\n+\n+    // check the response contains managed server name\n+    for (int i = 1; i <= maxIterations; i++) {\n+\n+      if (!managedServers.containsValue(false)) {\n+        return true;\n+      } else {\n+        try {\n+          // sometimes the pod is not ready even the condition check is ready, sleep a little bit\n+          Thread.sleep(100);\n+          ExecResult result = ExecCommand.exec(curlCmd, true);\n+\n+          String response = result.stdout().trim();\n+          managedServers.keySet().forEach(key -> {\n+            if (response.contains(key)) {\n+              managedServers.put(key, true);\n+            }\n+          });\n+        } catch (Exception e) {\n+          logger.info(\"Got exceptions while running command: \" + curlCmd);", "originalCommit": "f5f282cd562de543c51e96ea752d103e2ead5f1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU1MDU2Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420550567", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-06T05:20:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwODY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwODc0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420508744", "bodyText": "managed server", "author": "markxnelson", "createdAt": "2020-05-06T02:08:17Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+\n+/**\n+ * The utility class for tests.\n+ */\n+public class TestUtils {\n+\n+  /**\n+   * Call the curl command and check the app can be reached from all managed servers.\n+   *\n+   * @param curlCmd curl command to call the sample app\n+   * @param managedServerNames managed server names that the sample app response should return\n+   * @param maxIterations max iterations to call the curl command\n+   * @return true if the web app can hit all managed servers, false otherwise\n+   */\n+  public static boolean callWebAppAndCheckForServerNameInResponse(\n+                          String curlCmd,\n+                          List<String> managedServerNames,\n+                          int maxIterations) {\n+\n+    // first map all server names with false\n+    HashMap<String, Boolean> managedServers = new HashMap<>();\n+    managedServerNames.forEach(managedServerName ->\n+        managedServers.put(managedServerName, false)\n+    );\n+\n+    logger.info(\"Calling webapp at most {0} times using command: {1}\", maxIterations, curlCmd);\n+\n+    // check the response contains managed server name\n+    for (int i = 1; i <= maxIterations; i++) {\n+\n+      if (!managedServers.containsValue(false)) {\n+        return true;\n+      } else {\n+        try {\n+          // sometimes the pod is not ready even the condition check is ready, sleep a little bit\n+          Thread.sleep(100);\n+          ExecResult result = ExecCommand.exec(curlCmd, true);\n+\n+          String response = result.stdout().trim();\n+          managedServers.keySet().forEach(key -> {\n+            if (response.contains(key)) {\n+              managedServers.put(key, true);\n+            }\n+          });\n+        } catch (Exception e) {\n+          logger.info(\"Got exceptions while running command: \" + curlCmd);\n+          return false;\n+        }\n+      }\n+    }\n+\n+    // after the max iterations, check if any managedserver value is false", "originalCommit": "f5f282cd562de543c51e96ea752d103e2ead5f1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU1MDU5OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420550599", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-06T05:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwODc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwODk1NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420508955", "bodyText": "feels odd to do the same calculation over and over\nwhy not do it once and store the result in a var", "author": "markxnelson", "createdAt": "2020-05-06T02:09:09Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+\n+/**\n+ * The utility class for tests.\n+ */\n+public class TestUtils {\n+\n+  /**\n+   * Call the curl command and check the app can be reached from all managed servers.\n+   *\n+   * @param curlCmd curl command to call the sample app\n+   * @param managedServerNames managed server names that the sample app response should return\n+   * @param maxIterations max iterations to call the curl command\n+   * @return true if the web app can hit all managed servers, false otherwise\n+   */\n+  public static boolean callWebAppAndCheckForServerNameInResponse(\n+                          String curlCmd,\n+                          List<String> managedServerNames,\n+                          int maxIterations) {\n+\n+    // first map all server names with false\n+    HashMap<String, Boolean> managedServers = new HashMap<>();\n+    managedServerNames.forEach(managedServerName ->\n+        managedServers.put(managedServerName, false)\n+    );\n+\n+    logger.info(\"Calling webapp at most {0} times using command: {1}\", maxIterations, curlCmd);\n+\n+    // check the response contains managed server name\n+    for (int i = 1; i <= maxIterations; i++) {\n+\n+      if (!managedServers.containsValue(false)) {\n+        return true;\n+      } else {\n+        try {\n+          // sometimes the pod is not ready even the condition check is ready, sleep a little bit\n+          Thread.sleep(100);\n+          ExecResult result = ExecCommand.exec(curlCmd, true);\n+\n+          String response = result.stdout().trim();\n+          managedServers.keySet().forEach(key -> {\n+            if (response.contains(key)) {\n+              managedServers.put(key, true);\n+            }\n+          });\n+        } catch (Exception e) {\n+          logger.info(\"Got exceptions while running command: \" + curlCmd);\n+          return false;\n+        }\n+      }\n+    }\n+\n+    // after the max iterations, check if any managedserver value is false\n+    managedServers.forEach((key, value) -> {\n+      if (value) {\n+        logger.info(\"The sample app can be accessed from the server {0}\", key);\n+      } else {\n+        logger.info(\"FAILURE: The sample app can not be accessed from the server {0}\", key);\n+      }\n+    });\n+\n+    // final check if any managed server value is false\n+    return !managedServers.containsValue(false);", "originalCommit": "f5f282cd562de543c51e96ea752d103e2ead5f1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU1MDY1Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420550657", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-06T05:20:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwODk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwOTA3OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420509078", "bodyText": "either fix your javadoc, or use <=", "author": "markxnelson", "createdAt": "2020-05-06T02:09:39Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+\n+/**\n+ * The utility class for tests.\n+ */\n+public class TestUtils {\n+\n+  /**\n+   * Call the curl command and check the app can be reached from all managed servers.\n+   *\n+   * @param curlCmd curl command to call the sample app\n+   * @param managedServerNames managed server names that the sample app response should return\n+   * @param maxIterations max iterations to call the curl command\n+   * @return true if the web app can hit all managed servers, false otherwise\n+   */\n+  public static boolean callWebAppAndCheckForServerNameInResponse(\n+                          String curlCmd,\n+                          List<String> managedServerNames,\n+                          int maxIterations) {\n+\n+    // first map all server names with false\n+    HashMap<String, Boolean> managedServers = new HashMap<>();\n+    managedServerNames.forEach(managedServerName ->\n+        managedServers.put(managedServerName, false)\n+    );\n+\n+    logger.info(\"Calling webapp at most {0} times using command: {1}\", maxIterations, curlCmd);\n+\n+    // check the response contains managed server name\n+    for (int i = 1; i <= maxIterations; i++) {\n+\n+      if (!managedServers.containsValue(false)) {\n+        return true;\n+      } else {\n+        try {\n+          // sometimes the pod is not ready even the condition check is ready, sleep a little bit\n+          Thread.sleep(100);\n+          ExecResult result = ExecCommand.exec(curlCmd, true);\n+\n+          String response = result.stdout().trim();\n+          managedServers.keySet().forEach(key -> {\n+            if (response.contains(key)) {\n+              managedServers.put(key, true);\n+            }\n+          });\n+        } catch (Exception e) {\n+          logger.info(\"Got exceptions while running command: \" + curlCmd);\n+          return false;\n+        }\n+      }\n+    }\n+\n+    // after the max iterations, check if any managedserver value is false\n+    managedServers.forEach((key, value) -> {\n+      if (value) {\n+        logger.info(\"The sample app can be accessed from the server {0}\", key);\n+      } else {\n+        logger.info(\"FAILURE: The sample app can not be accessed from the server {0}\", key);\n+      }\n+    });\n+\n+    // final check if any managed server value is false\n+    return !managedServers.containsValue(false);\n+  }\n+\n+  /**\n+   * Get the next free port between from and to.\n+   *\n+   * @param from range starting point\n+   * @param to range ending port\n+   * @return the port number which is free\n+   */\n+  public static int getNextFreePort(int from, int to) {\n+    int port;\n+    for (port = from; port < to; port++) {", "originalCommit": "f5f282cd562de543c51e96ea752d103e2ead5f1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU1MDcyMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r420550723", "bodyText": "fixed", "author": "xiancao", "createdAt": "2020-05-06T05:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwOTA3OA=="}], "type": "inlineReview"}, {"oid": "500776983799240851f663a5f4f685969c7e76be", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/500776983799240851f663a5f4f685969c7e76be", "message": "fix with Mark's comments", "committedDate": "2020-05-06T05:07:14Z", "type": "commit"}, {"oid": "96aea346280fe22ab6bd67489b0d86b037aded43", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/96aea346280fe22ab6bd67489b0d86b037aded43", "message": "Merge branch 'develop' into nginx-mii-new-it", "committedDate": "2020-05-06T21:35:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEwMzY0MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r421103640", "bodyText": "using --silent here, when curl fails I think you can't see the error message why its failing by using --silent..use --silent along with --showerror and can you make the curl fail and see if you get the actual error message printed to debug..", "author": "vanajamukkara", "createdAt": "2020-05-06T21:28:46Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItSimpleNginxValidation.java", "diffHunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.gson.JsonObject;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.NginxParams;\n+import oracle.weblogic.kubernetes.actions.impl.OperatorParams;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.GOOGLE_REPO_URL;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_CHART_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.NGINX_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_CHART_DIR;\n+import static oracle.weblogic.kubernetes.TestConstants.OPERATOR_RELEASE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_DUMMY_VALUE;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.STABLE_REPO_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ARCHIVE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.MODEL_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WDT_VERSION;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WIT_BUILD_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.buildAppArchive;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDockerConfigJson;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createIngress;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createMiiImage;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createServiceAccount;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultAppParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.defaultWitParams;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerLogin;\n+import static oracle.weblogic.kubernetes.actions.TestActions.dockerPush;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getIngressList;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorImageName;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installNginx;\n+import static oracle.weblogic.kubernetes.actions.TestActions.installOperator;\n+import static oracle.weblogic.kubernetes.actions.TestActions.uninstallNginx;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.doesImageExist;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isHelmReleaseDeployed;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.isNginxReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.operatorIsReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podReady;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.serviceExists;\n+import static oracle.weblogic.kubernetes.utils.FileUtils.checkDirectory;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.callWebAppAndCheckForServerNameInResponse;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify the sample application can be accessed via the ingress controller.\n+ */\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"Verify the sample application can be accessed via the ingress controller\")\n+@IntegrationTest\n+class ItSimpleNginxValidation implements LoggedTest {\n+\n+  // mii constants\n+  private static final String WDT_MODEL_FILE = \"model1-wls.yaml\";\n+  private static final String MII_IMAGE_NAME = \"mii-image\";\n+  private static final String APP_NAME = \"sample-app\";\n+\n+  // domain constants\n+  private static final String DOMAIN_VERSION = \"v7\";\n+  private static final String API_VERSION = \"weblogic.oracle/\" + DOMAIN_VERSION;\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private static HelmParams nginxHelmParams = null;\n+  private static String nginxNamespace = null;\n+  private static int nodeportshttp;\n+  private static int nodeportshttps;\n+\n+  private String domainUid = \"domain1\";\n+  private final String managedServerNameBase = \"managed-server\";\n+  private final String clusterName = \"cluster-1\";\n+  private final int managedServerPort = 8001;\n+  private final int replicaCount = 2;\n+\n+  /**\n+   * Install operator and NGINX.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(3) List<String> namespaces) {\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a unique operator namespace\n+    logger.info(\"Get a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a unique domain namespace\n+    logger.info(\"Get a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // get a unique NGINX namespace\n+    logger.info(\"Get a unique namespace for NGINX\");\n+    assertNotNull(namespaces.get(2), \"Namespace list is null\");\n+    nginxNamespace = namespaces.get(2);\n+\n+    // install and verify operator\n+    installAndVerifyOperator();\n+\n+    // get a free node port for NGINX\n+    nodeportshttp = getNextFreePort(30305, 30405);\n+    nodeportshttps = getNextFreePort(30443, 30543);\n+\n+    // install and verify NGINX\n+    installAndVerifyNginx();\n+  }\n+\n+  @Test\n+  @Order(1)\n+  @DisplayName(\"Create model in image domain\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testCreateMiiDomain() {\n+    // admin/managed server name here should match with model yaml in WDT_MODEL_FILE\n+    final String adminServerPodName = domainUid + \"-admin-server\";\n+    String managedServerPrefix = domainUid + \"-\" + managedServerNameBase;\n+\n+    // create image with model files\n+    String miiImage = createImageAndVerify();\n+\n+    // push the image to registry to make the test work in multi node cluster\n+    if (!REPO_USERNAME.equals(REPO_DUMMY_VALUE)) {\n+      logger.info(\"docker login\");\n+      assertTrue(dockerLogin(REPO_REGISTRY, REPO_USERNAME, REPO_PASSWORD), \"docker login failed\");\n+\n+      logger.info(\"docker push image {0} to OCIR\", miiImage);\n+      assertTrue(dockerPush(miiImage), String.format(\"docker push failed for image %s\", miiImage));\n+    }\n+\n+    // Create the V1Secret configuration\n+    V1Secret repoSecret = new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(REPO_SECRET_NAME)\n+            .namespace(domainNamespace))\n+        .type(\"kubernetes.io/dockerconfigjson\")\n+        .putDataItem(\".dockerconfigjson\", dockerConfigJson.getBytes());\n+\n+    boolean secretCreated = assertDoesNotThrow(() -> createSecret(repoSecret),\n+        String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+    assertTrue(secretCreated, String.format(\"createSecret failed while creating secret %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    Map<String, String> adminSecretMap = new HashMap<>();\n+    adminSecretMap.put(\"username\", \"weblogic\");\n+    adminSecretMap.put(\"password\", \"welcome1\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(adminSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(adminSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    Map<String, String> encryptionSecretMap = new HashMap<>();\n+    encryptionSecretMap.put(\"username\", \"weblogicenc\");\n+    encryptionSecretMap.put(\"password\", \"weblogicenc\");\n+    secretCreated = assertDoesNotThrow(() -> createSecret(new V1Secret()\n+        .metadata(new V1ObjectMeta()\n+            .name(encryptionSecretName)\n+            .namespace(domainNamespace))\n+        .stringData(encryptionSecretMap)), \"Create secret failed with ApiException\");\n+    assertTrue(secretCreated, String.format(\"create secret failed for %s\", encryptionSecretName));\n+\n+    // create the domain CR\n+    Domain domain = new Domain()\n+        .apiVersion(API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHomeSourceType(\"FromModel\")\n+            .image(miiImage)\n+            .addImagePullSecretsItem(new V1LocalObjectReference()\n+                .name(REPO_SECRET_NAME))\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(adminSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod()\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \")))\n+            .adminServer(new AdminServer()\n+                .serverStartState(\"RUNNING\"))\n+            .addClustersItem(new Cluster()\n+                .clusterName(\"cluster-1\")\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .model(new Model()\n+                    .domainType(\"WLS\")\n+                    .runtimeEncryptionSecret(encryptionSecretName))));\n+\n+    logger.info(\"Create domain custom resource for domainUid {0} in namespace {1}\",\n+        domainUid, domainNamespace);\n+    assertTrue(assertDoesNotThrow(() -> createDomainCustomResource(domain),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace)),\n+        String.format(\"Create domain custom resource failed with ApiException for %s in namespace %s\",\n+            domainUid, domainNamespace));\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resouce in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exist\n+    logger.info(\"Check for admin server pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodCreated(adminServerPodName);\n+\n+    // check managed server pods exists\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managed server pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodCreated(managedServerPrefix + i);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceCreated(adminServerPodName);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceCreated(managedServerPrefix + i);\n+    }\n+  }\n+\n+  @Test\n+  @Order(2)\n+  @DisplayName(\"Create an ingress for a WebLogic domain in the specified domain namespace\")\n+  public void testCreateIngress() {\n+\n+    // create an ingress in domain namespace\n+    assertThat(assertDoesNotThrow(() -> createIngress(domainNamespace, domainUid, clusterName, managedServerPort)))\n+            .as(\"createIngress succeeds\")\n+            .withFailMessage(String.format(\"failed to create an ingress for domain %s in namespace %s\",\n+                domainUid, domainNamespace))\n+            .isTrue();\n+\n+    // check the ingress is created\n+    String ingressName = domainUid + \"-nginx\";\n+    assertThat(assertDoesNotThrow(() -> getIngressList(domainNamespace)))\n+        .as(String.format(\"found the ingress %s in namespace %s\", ingressName, domainNamespace))\n+        .withFailMessage(String.format(\"can not find ingress %s in namespace %s\", ingressName, domainNamespace))\n+        .contains(ingressName);\n+\n+    logger.info(\"ingress is created in namespace {0}\", domainNamespace);\n+  }\n+\n+  @Test\n+  @Order(3)\n+  @DisplayName(\"Verify the application can be accessed through the ingress controller\")\n+  public void testSampleAppThroughIngressController() {\n+\n+    List<String> managedServerNames = new ArrayList<>();\n+    for (int i = 1; i <= replicaCount; i++) {\n+      managedServerNames.add(managedServerNameBase + i);\n+    }\n+\n+    // check that NGINX can access the sample apps from all managed servers in the domain\n+    String curlCmd = String.format(\"curl --silent --noproxy '*' -H 'host: %s' http://%s:%s/sample-war/index.jsp\",", "originalCommit": "500776983799240851f663a5f4f685969c7e76be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTExMTM3MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1614#discussion_r421111370", "bodyText": "log error message as well..result.stderr and result.stdout", "author": "vanajamukkara", "createdAt": "2020-05-06T21:45:47Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/TestUtils.java", "diffHunk": "@@ -0,0 +1,114 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+\n+/**\n+ * The utility class for tests.\n+ */\n+public class TestUtils {\n+\n+  /**\n+   * Call the curl command and check the app can be reached from all managed servers.\n+   *\n+   * @param curlCmd curl command to call the sample app\n+   * @param managedServerNames managed server names that the sample app response should return\n+   * @param maxIterations max iterations to call the curl command\n+   * @return true if the web app can hit all managed servers, false otherwise\n+   */\n+  public static boolean callWebAppAndCheckForServerNameInResponse(\n+                          String curlCmd,\n+                          List<String> managedServerNames,\n+                          int maxIterations) {\n+\n+    // first map all server names with false\n+    HashMap<String, Boolean> managedServers = new HashMap<>();\n+    managedServerNames.forEach(managedServerName ->\n+        managedServers.put(managedServerName, false)\n+    );\n+\n+    logger.info(\"Calling webapp at most {0} times using command: {1}\", maxIterations, curlCmd);\n+\n+    // check the response contains managed server name\n+    for (int i = 0; i < maxIterations; i++) {\n+\n+      if (managedServers.containsValue(false)) {\n+        try {\n+          // sometimes the pod is not ready even the condition check is ready, sleep a little bit\n+          Thread.sleep(100);\n+        } catch (InterruptedException ignore) {\n+          // ignore\n+        }\n+\n+        try {\n+          ExecResult result = ExecCommand.exec(curlCmd, true);\n+\n+          String response = result.stdout().trim();\n+          managedServers.keySet().forEach(key -> {\n+            if (response.contains(key)) {\n+              managedServers.put(key, true);\n+            }\n+          });\n+        } catch (Exception e) {\n+          logger.info(\"Got exception while running command: \" + curlCmd);", "originalCommit": "96aea346280fe22ab6bd67489b0d86b037aded43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}