{"pr_number": 1839, "pr_title": "JUnit5 Create Infrastructure for ELK Stack ", "pr_createdAt": "2020-07-29T23:24:16Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839", "timeline": [{"oid": "93a5285aa2f4bdfbb180e1faa2c1da5c3abd2bfd", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/93a5285aa2f4bdfbb180e1faa2c1da5c3abd2bfd", "message": "JUnit5 Create Infrastructure for ELK stack jenkins-ignore", "committedDate": "2020-07-29T22:44:02Z", "type": "commit"}, {"oid": "7e7c28b69839925a001ecc3b2c1cd202290cf253", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7e7c28b69839925a001ecc3b2c1cd202290cf253", "message": "JUnit5 Create Infrastructure for ELK stack jenkins-ignore", "committedDate": "2020-07-29T23:20:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MDk3OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463270979", "bodyText": "typo install", "author": "vanajamukkara", "createdAt": "2020-07-30T21:05:38Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItElkSample.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.actions.impl.LoggingExporterParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIBANA_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.TestConstants.LOGSTASH_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyElasticsearch;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyKibana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.uninstallAndVerifyElasticsearch;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.uninstallAndVerifyKibana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.verifyLoggingExporterReady;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify that Elasticsearch collects data from WebLogic logs and\n+ * stores them in its repository correctly.\n+ */\n+@DisplayName(\"Test to use Elasticsearch API to query WebLogic logs\")\n+@IntegrationTest\n+class ItElkSample {\n+\n+  // constants for Operator\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  // constants for ELK Stack\n+  private static LoggingExporterParams elasticsearchParams = null;\n+  private static LoggingExporterParams kibanaParams = null;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Elasticsearch, Kibana and Operator, create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domainNamespace\n+    logger.info(\"Assigning a unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Elasticsearch\n+    logger.info(\"Instull and verify Elasticsearch\");", "originalCommit": "7e7c28b69839925a001ecc3b2c1cd202290cf253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxODU3Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463318577", "bodyText": "fixed", "author": "hzhao-github", "createdAt": "2020-07-30T23:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MDk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MTMwMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463271302", "bodyText": "typo", "author": "vanajamukkara", "createdAt": "2020-07-30T21:06:19Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItElkSample.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.actions.impl.LoggingExporterParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIBANA_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.TestConstants.LOGSTASH_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyElasticsearch;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyKibana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.uninstallAndVerifyElasticsearch;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.uninstallAndVerifyKibana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.verifyLoggingExporterReady;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify that Elasticsearch collects data from WebLogic logs and\n+ * stores them in its repository correctly.\n+ */\n+@DisplayName(\"Test to use Elasticsearch API to query WebLogic logs\")\n+@IntegrationTest\n+class ItElkSample {\n+\n+  // constants for Operator\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  // constants for ELK Stack\n+  private static LoggingExporterParams elasticsearchParams = null;\n+  private static LoggingExporterParams kibanaParams = null;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Elasticsearch, Kibana and Operator, create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domainNamespace\n+    logger.info(\"Assigning a unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Elasticsearch\n+    logger.info(\"Instull and verify Elasticsearch\");\n+    elasticsearchParams = assertDoesNotThrow(() -> installAndVerifyElasticsearch(),\n+            String.format(\"Failed to install Elasticsearch\"));\n+    assertTrue(elasticsearchParams != null, \"Failed to install Elasticsearch\");\n+\n+    // install and verify Kibana\n+    logger.info(\"Instull and verify Kibana\");", "originalCommit": "7e7c28b69839925a001ecc3b2c1cd202290cf253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxODY1NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463318654", "bodyText": "fixed", "author": "hzhao-github", "createdAt": "2020-07-30T23:04:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MTMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MjI2Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463272262", "bodyText": "this test can not be run in parallel? why? u can remove slow tag, we are not using it.", "author": "vanajamukkara", "createdAt": "2020-07-30T21:08:30Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItElkSample.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.actions.impl.LoggingExporterParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIBANA_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.TestConstants.LOGSTASH_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyElasticsearch;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyKibana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.uninstallAndVerifyElasticsearch;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.uninstallAndVerifyKibana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.verifyLoggingExporterReady;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify that Elasticsearch collects data from WebLogic logs and\n+ * stores them in its repository correctly.\n+ */\n+@DisplayName(\"Test to use Elasticsearch API to query WebLogic logs\")\n+@IntegrationTest\n+class ItElkSample {\n+\n+  // constants for Operator\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  // constants for ELK Stack\n+  private static LoggingExporterParams elasticsearchParams = null;\n+  private static LoggingExporterParams kibanaParams = null;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Elasticsearch, Kibana and Operator, create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domainNamespace\n+    logger.info(\"Assigning a unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Elasticsearch\n+    logger.info(\"Instull and verify Elasticsearch\");\n+    elasticsearchParams = assertDoesNotThrow(() -> installAndVerifyElasticsearch(),\n+            String.format(\"Failed to install Elasticsearch\"));\n+    assertTrue(elasticsearchParams != null, \"Failed to install Elasticsearch\");\n+\n+    // install and verify Kibana\n+    logger.info(\"Instull and verify Kibana\");\n+    kibanaParams = assertDoesNotThrow(() -> installAndVerifyKibana(),\n+        String.format(\"Failed to install Kibana\"));\n+    assertTrue(kibanaParams != null, \"Failed to install Kibana\");\n+\n+    // install and verify Operator\n+    installAndVerifyOperator(opNamespace, opNamespace + \"-sa\", false, 0, true, domainNamespace);\n+  }\n+\n+  /**\n+   * Uninstall ELK Stack and delete domain custom resource.\n+   */\n+  @AfterAll\n+  void tearDown() {\n+    // uninstall ELK Stack\n+    if (elasticsearchParams != null) {\n+      logger.info(\"Uninstall Elasticsearch pod\");\n+      assertDoesNotThrow(() -> uninstallAndVerifyElasticsearch(elasticsearchParams),\n+          \"uninstallAndVerifyElasticsearch failed with ApiException\");\n+    }\n+\n+    if (kibanaParams != null) {\n+      logger.info(\"Uninstall Elasticsearch pod\");\n+      assertDoesNotThrow(() -> uninstallAndVerifyKibana(kibanaParams),\n+          \"uninstallAndVerifyKibana failed with ApiException\");\n+    }\n+  }\n+\n+  /**\n+   * Verify that ELK Stack is ready to use.\n+   *\n+   */\n+  @Test\n+  @DisplayName(\"Verify that ELK Stack is ready to use\")\n+  @Slow\n+  @MustNotRunInParallel", "originalCommit": "7e7c28b69839925a001ecc3b2c1cd202290cf253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxODk2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463318960", "bodyText": "removed", "author": "hzhao-github", "createdAt": "2020-07-30T23:05:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MjI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3Mjg2OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463272868", "bodyText": "return value not matching with method signature", "author": "vanajamukkara", "createdAt": "2020-07-30T21:09:50Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -1026,6 +1028,18 @@ public static void deletePod(String podName, String namespace) throws ApiExcepti\n     Kubernetes.deletePod(podName, namespace);\n   }\n \n+  /**\n+   * Get  Kubernetes pods in a namespace.\n+   *\n+   * @param namespace name of namespace\n+   * @param labelSelectors with which pods are decorated\n+   * @return V1PodList list of pods", "originalCommit": "7e7c28b69839925a001ecc3b2c1cd202290cf253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxOTQ1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463319453", "bodyText": "fixed", "author": "hzhao-github", "createdAt": "2020-07-30T23:07:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3Mjg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MzExMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463273111", "bodyText": "getOperatorPodName - fix typo", "author": "vanajamukkara", "createdAt": "2020-07-30T21:10:20Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -1026,6 +1028,18 @@ public static void deletePod(String podName, String namespace) throws ApiExcepti\n     Kubernetes.deletePod(podName, namespace);\n   }\n \n+  /**\n+   * Get  Kubernetes pods in a namespace.\n+   *\n+   * @param namespace name of namespace\n+   * @param labelSelectors with which pods are decorated\n+   * @return V1PodList list of pods\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static String getOperatorPadName(String namespace, String labelSelectors) throws ApiException {", "originalCommit": "7e7c28b69839925a001ecc3b2c1cd202290cf253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyMTA4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463321089", "bodyText": "fixed", "author": "hzhao-github", "createdAt": "2020-07-30T23:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MzExMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MzI4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463273289", "bodyText": "fix typo", "author": "vanajamukkara", "createdAt": "2020-07-30T21:10:44Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/TestActions.java", "diffHunk": "@@ -1026,6 +1028,18 @@ public static void deletePod(String podName, String namespace) throws ApiExcepti\n     Kubernetes.deletePod(podName, namespace);\n   }\n \n+  /**\n+   * Get  Kubernetes pods in a namespace.\n+   *\n+   * @param namespace name of namespace\n+   * @param labelSelectors with which pods are decorated\n+   * @return V1PodList list of pods\n+   * @throws ApiException if Kubernetes client API call fails\n+   */\n+  public static String getOperatorPadName(String namespace, String labelSelectors) throws ApiException {\n+    return Pod.getOperatorPadName(namespace, labelSelectors);", "originalCommit": "7e7c28b69839925a001ecc3b2c1cd202290cf253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyMTE0MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463321141", "bodyText": "fixed", "author": "hzhao-github", "createdAt": "2020-07-30T23:12:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3MzI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3NTU1OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463275559", "bodyText": "change the message as if it failed with ApiException it is captured in the above line", "author": "vanajamukkara", "createdAt": "2020-07-30T21:15:28Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/LoggingExporter.java", "diffHunk": "@@ -0,0 +1,474 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.assertions.impl.Deployment;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ELASTICSEARCH_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.ELASTICSEARCH_HTTP_PORT;\n+import static oracle.weblogic.kubernetes.TestConstants.KIBANA_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorPadName;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.isPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class for ELK Stack and WebLogic logging exporter.\n+ */\n+public class LoggingExporter {\n+\n+  private static LoggingFacade logger = getLogger();\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  private static final int maxIterationsPod = 10;\n+\n+  /**\n+   * Install Elasticsearch.\n+   *\n+   * @param params the parameters to install Elasticsearch\n+   * @return true if the Elasticsearch is successfully installed, false otherwise.\n+   */\n+  public static boolean installElasticsearch(LoggingExporterParams params) {\n+    String elasticsearchName = params.getElasticsearchName();\n+    String namespace = params.getLoggingExporterNamespace();\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", elasticsearchName);\n+\n+    // create Elasticsearch deployment CR\n+    logger.info(\"Create Elasticsearch deployment CR for {0} in namespace {1}\",\n+        elasticsearchName, namespace);\n+    V1Deployment elasticsearchDeployment = createElasticsearchDeploymentCr(params);\n+\n+    // create Elasticsearch deployment\n+    logger.info(\"Create Elasticsearch deployment {0} in namespace {1}\", elasticsearchName, namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(elasticsearchDeployment),\n+        String.format(\"Create Elasticsearch deployment failed with ApiException for %s in namespace %s\",\n+          elasticsearchName, namespace));\n+    assertTrue(deploymentCreated,\n+        String.format(\"Create Elasticsearch deployment failed with ApiException for %s in namespace %s\",", "originalCommit": "7e7c28b69839925a001ecc3b2c1cd202290cf253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyNDM3MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463324370", "bodyText": "changed the line 79", "author": "hzhao-github", "createdAt": "2020-07-30T23:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3NTU1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3NTY1NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463275654", "bodyText": "change the message as if it failed with ApiException it is captured in the above line", "author": "vanajamukkara", "createdAt": "2020-07-30T21:15:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/LoggingExporter.java", "diffHunk": "@@ -0,0 +1,474 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.assertions.impl.Deployment;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ELASTICSEARCH_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.ELASTICSEARCH_HTTP_PORT;\n+import static oracle.weblogic.kubernetes.TestConstants.KIBANA_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorPadName;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.isPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class for ELK Stack and WebLogic logging exporter.\n+ */\n+public class LoggingExporter {\n+\n+  private static LoggingFacade logger = getLogger();\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  private static final int maxIterationsPod = 10;\n+\n+  /**\n+   * Install Elasticsearch.\n+   *\n+   * @param params the parameters to install Elasticsearch\n+   * @return true if the Elasticsearch is successfully installed, false otherwise.\n+   */\n+  public static boolean installElasticsearch(LoggingExporterParams params) {\n+    String elasticsearchName = params.getElasticsearchName();\n+    String namespace = params.getLoggingExporterNamespace();\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", elasticsearchName);\n+\n+    // create Elasticsearch deployment CR\n+    logger.info(\"Create Elasticsearch deployment CR for {0} in namespace {1}\",\n+        elasticsearchName, namespace);\n+    V1Deployment elasticsearchDeployment = createElasticsearchDeploymentCr(params);\n+\n+    // create Elasticsearch deployment\n+    logger.info(\"Create Elasticsearch deployment {0} in namespace {1}\", elasticsearchName, namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(elasticsearchDeployment),\n+        String.format(\"Create Elasticsearch deployment failed with ApiException for %s in namespace %s\",\n+          elasticsearchName, namespace));\n+    assertTrue(deploymentCreated,\n+        String.format(\"Create Elasticsearch deployment failed with ApiException for %s in namespace %s\",\n+            elasticsearchName, namespace));\n+    logger.info(\"Check if Elasticsearch deployment {0} is ready in namespace {1}\",\n+        elasticsearchName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for Elasticsearch deployment {0}\"\n+                + \"to be completed in {1} namespace (elapsed time {2}ms, remaining time {3}ms)\",\n+                elasticsearchName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(Deployment.isReady(elasticsearchName, labels, namespace));\n+\n+    // create Elasticsearch service CR\n+    logger.info(\"Create Elasticsearch service CR for {0} in namespace {1}\",\n+        elasticsearchName, namespace);\n+    V1Service elasticsearchService = createElasticsearchServiceCr(params);\n+\n+    // create Elasticsearch service\n+    logger.info(\"Create Elasticsearch service {0} in namespace {1}\", elasticsearchName, namespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(elasticsearchService),\n+        String.format(\"Create Elasticsearch service failed with ApiException for %s in namespace %s\",\n+            elasticsearchName, namespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create Elasticsearch service failed with ApiException for %s in namespace %s\",\n+            elasticsearchName, namespace));\n+\n+    // check that Elasticsearch service exists in its namespace\n+    logger.info(\"Check that Elasticsearch service {0} exists in namespace {1}\",\n+        elasticsearchName, namespace);\n+    checkServiceExists(elasticsearchName, namespace);\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Install Kibana.\n+   *\n+   * @param params the parameters to install Kibana\n+   * @return true if the Kibana is successfully installed, false otherwise.\n+   */\n+  public static boolean installKibana(LoggingExporterParams params) {\n+    String kibanaName = params.getKibanaName();\n+    String namespace = params.getLoggingExporterNamespace();\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", kibanaName);\n+\n+    // create Kibana deployment CR\n+    logger.info(\"Create Kibana deployment CR for {0} in namespace {1}\", kibanaName, namespace);\n+    V1Deployment kibanaDeployment = createKibanaDeploymentCr(params);\n+\n+    // create Kibana deployment\n+    logger.info(\"Create Kibana deployment {0} in namespace {1}\", kibanaName, namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(kibanaDeployment),\n+        String.format(\"Create Kibana deployment failed with ApiException for %s in namespace $s\",\n+            kibanaName, namespace));\n+    assertTrue(deploymentCreated,\n+        String.format(\"Create Kibana deployment failed with ApiException for %s in %s namespace\",", "originalCommit": "7e7c28b69839925a001ecc3b2c1cd202290cf253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyNDQxMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463324411", "bodyText": "changed the line 137", "author": "hzhao-github", "createdAt": "2020-07-30T23:23:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3NTY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3NjQ0Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463276447", "bodyText": "change the message as if it failed with ApiException it is captured in the above line", "author": "vanajamukkara", "createdAt": "2020-07-30T21:17:21Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/LoggingExporter.java", "diffHunk": "@@ -0,0 +1,474 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.assertions.impl.Deployment;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ELASTICSEARCH_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.ELASTICSEARCH_HTTP_PORT;\n+import static oracle.weblogic.kubernetes.TestConstants.KIBANA_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorPadName;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.isPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class for ELK Stack and WebLogic logging exporter.\n+ */\n+public class LoggingExporter {\n+\n+  private static LoggingFacade logger = getLogger();\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  private static final int maxIterationsPod = 10;\n+\n+  /**\n+   * Install Elasticsearch.\n+   *\n+   * @param params the parameters to install Elasticsearch\n+   * @return true if the Elasticsearch is successfully installed, false otherwise.\n+   */\n+  public static boolean installElasticsearch(LoggingExporterParams params) {\n+    String elasticsearchName = params.getElasticsearchName();\n+    String namespace = params.getLoggingExporterNamespace();\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", elasticsearchName);\n+\n+    // create Elasticsearch deployment CR\n+    logger.info(\"Create Elasticsearch deployment CR for {0} in namespace {1}\",\n+        elasticsearchName, namespace);\n+    V1Deployment elasticsearchDeployment = createElasticsearchDeploymentCr(params);\n+\n+    // create Elasticsearch deployment\n+    logger.info(\"Create Elasticsearch deployment {0} in namespace {1}\", elasticsearchName, namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(elasticsearchDeployment),\n+        String.format(\"Create Elasticsearch deployment failed with ApiException for %s in namespace %s\",\n+          elasticsearchName, namespace));\n+    assertTrue(deploymentCreated,\n+        String.format(\"Create Elasticsearch deployment failed with ApiException for %s in namespace %s\",\n+            elasticsearchName, namespace));\n+    logger.info(\"Check if Elasticsearch deployment {0} is ready in namespace {1}\",\n+        elasticsearchName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for Elasticsearch deployment {0}\"\n+                + \"to be completed in {1} namespace (elapsed time {2}ms, remaining time {3}ms)\",\n+                elasticsearchName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(Deployment.isReady(elasticsearchName, labels, namespace));\n+\n+    // create Elasticsearch service CR\n+    logger.info(\"Create Elasticsearch service CR for {0} in namespace {1}\",\n+        elasticsearchName, namespace);\n+    V1Service elasticsearchService = createElasticsearchServiceCr(params);\n+\n+    // create Elasticsearch service\n+    logger.info(\"Create Elasticsearch service {0} in namespace {1}\", elasticsearchName, namespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(elasticsearchService),\n+        String.format(\"Create Elasticsearch service failed with ApiException for %s in namespace %s\",\n+            elasticsearchName, namespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create Elasticsearch service failed with ApiException for %s in namespace %s\",\n+            elasticsearchName, namespace));\n+\n+    // check that Elasticsearch service exists in its namespace\n+    logger.info(\"Check that Elasticsearch service {0} exists in namespace {1}\",\n+        elasticsearchName, namespace);\n+    checkServiceExists(elasticsearchName, namespace);\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Install Kibana.\n+   *\n+   * @param params the parameters to install Kibana\n+   * @return true if the Kibana is successfully installed, false otherwise.\n+   */\n+  public static boolean installKibana(LoggingExporterParams params) {\n+    String kibanaName = params.getKibanaName();\n+    String namespace = params.getLoggingExporterNamespace();\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", kibanaName);\n+\n+    // create Kibana deployment CR\n+    logger.info(\"Create Kibana deployment CR for {0} in namespace {1}\", kibanaName, namespace);\n+    V1Deployment kibanaDeployment = createKibanaDeploymentCr(params);\n+\n+    // create Kibana deployment\n+    logger.info(\"Create Kibana deployment {0} in namespace {1}\", kibanaName, namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(kibanaDeployment),\n+        String.format(\"Create Kibana deployment failed with ApiException for %s in namespace $s\",\n+            kibanaName, namespace));\n+    assertTrue(deploymentCreated,\n+        String.format(\"Create Kibana deployment failed with ApiException for %s in %s namespace\",\n+            kibanaName, namespace));\n+    logger.info(\"Checking if Kibana deployment is ready {0} completed in namespace {1}\",\n+        kibanaName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for Kibana deployment {0} to be completed in namespace {1}\"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                kibanaName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(Deployment.isReady(kibanaName, labels, namespace));\n+\n+    // create Kibana service CR\n+    logger.info(\"Create Kibana service CR for {0} in namespace {1}\", kibanaName, namespace);\n+    V1Service kibanaService = createKibanaServiceCr(params);\n+\n+    // create Kibana service\n+    logger.info(\"Create Kibana service for {0} in namespace {1}\", kibanaName, namespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(kibanaService),\n+        String.format(\"Create Kibana service failed with ApiException for %s in namespace %s\",\n+            kibanaName, namespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create Kibana service failed with ApiException for %s in namespace %s\",\n+            kibanaName, namespace));\n+\n+    // check that Kibana service exists in its namespace\n+    logger.info(\"Checking that Kibana service {0} exists in namespace {1}\",\n+        kibanaName, namespace);\n+    checkServiceExists(kibanaName, namespace);\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Uninstall Elasticsearch.\n+   *\n+   * @param params the parameters to uninstall Elasticsearch\n+   * @return true if the Elasticsearch is successfully uninstalled, false otherwise.\n+   */\n+  public static boolean uninstallElasticsearch(LoggingExporterParams params) {\n+    String elasticsearchName = params.getElasticsearchName();\n+    String namespace = params.getLoggingExporterNamespace();\n+\n+    // Delete Elasticsearch deployment\n+    try {\n+      Kubernetes.deleteDeployment(namespace, elasticsearchName);\n+    } catch (Exception ex) {\n+      logger.warning(\"Failed to delete deployment {0} \", elasticsearchName);\n+    }\n+\n+    logger.info(\"Delete Service {0} in namespace {1}\", elasticsearchName, namespace);\n+    boolean serviceDeleted =\n+        assertDoesNotThrow(() -> Kubernetes.deleteService(elasticsearchName, namespace),\n+            String.format(\"Delete service failed with ApiException for %s in %s namespace \",\n+              elasticsearchName, namespace));\n+    assertTrue(serviceDeleted, String.format(\n+        \"Delete service failed with ApiException for %s in %s namespace \", elasticsearchName, namespace));\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Uninstall Kibana.\n+   *\n+   * @param params the parameters to uninstall Kibana\n+   * @return true if the Kibana is successfully uninstalled, false otherwise.\n+   */\n+  public static boolean uninstallKibana(LoggingExporterParams params) {\n+    String kibanaName = params.getKibanaName();\n+    String namespace = params.getLoggingExporterNamespace();\n+\n+    // Delete Kibana deployment\n+    try {\n+      Kubernetes.deleteDeployment(namespace, kibanaName);\n+    } catch (Exception ex) {\n+      logger.warning(\"Failed to delete deployment {0} \", kibanaName);\n+    }\n+\n+    logger.info(\"Delete Service {0} in namespace {1}\", kibanaName, namespace);\n+    boolean serviceDeleted =\n+        assertDoesNotThrow(() -> Kubernetes.deleteService(kibanaName, namespace),\n+            String.format(\"Delete service failed with ApiException for %s in %s namespace \",\n+              kibanaName, namespace));\n+    assertTrue(serviceDeleted, String.format(\n+        \"Delete service failed with ApiException for %s in %s namespace \", kibanaName, namespace));", "originalCommit": "7e7c28b69839925a001ecc3b2c1cd202290cf253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyNjE4Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463326182", "bodyText": "changed the line 223", "author": "hzhao-github", "createdAt": "2020-07-30T23:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3NjQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3NjUzMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463276532", "bodyText": "change the message as if it failed with ApiException it is captured in the above line", "author": "vanajamukkara", "createdAt": "2020-07-30T21:17:32Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/LoggingExporter.java", "diffHunk": "@@ -0,0 +1,474 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.assertions.impl.Deployment;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ELASTICSEARCH_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.ELASTICSEARCH_HTTP_PORT;\n+import static oracle.weblogic.kubernetes.TestConstants.KIBANA_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorPadName;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.isPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class for ELK Stack and WebLogic logging exporter.\n+ */\n+public class LoggingExporter {\n+\n+  private static LoggingFacade logger = getLogger();\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  private static final int maxIterationsPod = 10;\n+\n+  /**\n+   * Install Elasticsearch.\n+   *\n+   * @param params the parameters to install Elasticsearch\n+   * @return true if the Elasticsearch is successfully installed, false otherwise.\n+   */\n+  public static boolean installElasticsearch(LoggingExporterParams params) {\n+    String elasticsearchName = params.getElasticsearchName();\n+    String namespace = params.getLoggingExporterNamespace();\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", elasticsearchName);\n+\n+    // create Elasticsearch deployment CR\n+    logger.info(\"Create Elasticsearch deployment CR for {0} in namespace {1}\",\n+        elasticsearchName, namespace);\n+    V1Deployment elasticsearchDeployment = createElasticsearchDeploymentCr(params);\n+\n+    // create Elasticsearch deployment\n+    logger.info(\"Create Elasticsearch deployment {0} in namespace {1}\", elasticsearchName, namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(elasticsearchDeployment),\n+        String.format(\"Create Elasticsearch deployment failed with ApiException for %s in namespace %s\",\n+          elasticsearchName, namespace));\n+    assertTrue(deploymentCreated,\n+        String.format(\"Create Elasticsearch deployment failed with ApiException for %s in namespace %s\",\n+            elasticsearchName, namespace));\n+    logger.info(\"Check if Elasticsearch deployment {0} is ready in namespace {1}\",\n+        elasticsearchName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for Elasticsearch deployment {0}\"\n+                + \"to be completed in {1} namespace (elapsed time {2}ms, remaining time {3}ms)\",\n+                elasticsearchName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(Deployment.isReady(elasticsearchName, labels, namespace));\n+\n+    // create Elasticsearch service CR\n+    logger.info(\"Create Elasticsearch service CR for {0} in namespace {1}\",\n+        elasticsearchName, namespace);\n+    V1Service elasticsearchService = createElasticsearchServiceCr(params);\n+\n+    // create Elasticsearch service\n+    logger.info(\"Create Elasticsearch service {0} in namespace {1}\", elasticsearchName, namespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(elasticsearchService),\n+        String.format(\"Create Elasticsearch service failed with ApiException for %s in namespace %s\",\n+            elasticsearchName, namespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create Elasticsearch service failed with ApiException for %s in namespace %s\",\n+            elasticsearchName, namespace));\n+\n+    // check that Elasticsearch service exists in its namespace\n+    logger.info(\"Check that Elasticsearch service {0} exists in namespace {1}\",\n+        elasticsearchName, namespace);\n+    checkServiceExists(elasticsearchName, namespace);\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Install Kibana.\n+   *\n+   * @param params the parameters to install Kibana\n+   * @return true if the Kibana is successfully installed, false otherwise.\n+   */\n+  public static boolean installKibana(LoggingExporterParams params) {\n+    String kibanaName = params.getKibanaName();\n+    String namespace = params.getLoggingExporterNamespace();\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", kibanaName);\n+\n+    // create Kibana deployment CR\n+    logger.info(\"Create Kibana deployment CR for {0} in namespace {1}\", kibanaName, namespace);\n+    V1Deployment kibanaDeployment = createKibanaDeploymentCr(params);\n+\n+    // create Kibana deployment\n+    logger.info(\"Create Kibana deployment {0} in namespace {1}\", kibanaName, namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(kibanaDeployment),\n+        String.format(\"Create Kibana deployment failed with ApiException for %s in namespace $s\",\n+            kibanaName, namespace));\n+    assertTrue(deploymentCreated,\n+        String.format(\"Create Kibana deployment failed with ApiException for %s in %s namespace\",\n+            kibanaName, namespace));\n+    logger.info(\"Checking if Kibana deployment is ready {0} completed in namespace {1}\",\n+        kibanaName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for Kibana deployment {0} to be completed in namespace {1}\"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                kibanaName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(Deployment.isReady(kibanaName, labels, namespace));\n+\n+    // create Kibana service CR\n+    logger.info(\"Create Kibana service CR for {0} in namespace {1}\", kibanaName, namespace);\n+    V1Service kibanaService = createKibanaServiceCr(params);\n+\n+    // create Kibana service\n+    logger.info(\"Create Kibana service for {0} in namespace {1}\", kibanaName, namespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(kibanaService),\n+        String.format(\"Create Kibana service failed with ApiException for %s in namespace %s\",\n+            kibanaName, namespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create Kibana service failed with ApiException for %s in namespace %s\",\n+            kibanaName, namespace));\n+\n+    // check that Kibana service exists in its namespace\n+    logger.info(\"Checking that Kibana service {0} exists in namespace {1}\",\n+        kibanaName, namespace);\n+    checkServiceExists(kibanaName, namespace);\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Uninstall Elasticsearch.\n+   *\n+   * @param params the parameters to uninstall Elasticsearch\n+   * @return true if the Elasticsearch is successfully uninstalled, false otherwise.\n+   */\n+  public static boolean uninstallElasticsearch(LoggingExporterParams params) {\n+    String elasticsearchName = params.getElasticsearchName();\n+    String namespace = params.getLoggingExporterNamespace();\n+\n+    // Delete Elasticsearch deployment\n+    try {\n+      Kubernetes.deleteDeployment(namespace, elasticsearchName);\n+    } catch (Exception ex) {\n+      logger.warning(\"Failed to delete deployment {0} \", elasticsearchName);\n+    }\n+\n+    logger.info(\"Delete Service {0} in namespace {1}\", elasticsearchName, namespace);\n+    boolean serviceDeleted =\n+        assertDoesNotThrow(() -> Kubernetes.deleteService(elasticsearchName, namespace),\n+            String.format(\"Delete service failed with ApiException for %s in %s namespace \",\n+              elasticsearchName, namespace));\n+    assertTrue(serviceDeleted, String.format(", "originalCommit": "7e7c28b69839925a001ecc3b2c1cd202290cf253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMyNjMxOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463326318", "bodyText": "changed the line 195", "author": "hzhao-github", "createdAt": "2020-07-30T23:30:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI3NjUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxNDk5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463314997", "bodyText": "could you please correct java doc description : add param, and correct return description ?", "author": "marinakog", "createdAt": "2020-07-30T22:52:39Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -448,6 +493,125 @@ public static HelmParams installAndVerifyVoyager(String voyagerNamespace,\n     return voyagerHelmParams;\n   }\n \n+  /**\n+   * Uninstall Elasticsearch.\n+   *\n+   * @return the Elasticsearch uninstallation parameters\n+   */\n+  public static boolean uninstallAndVerifyElasticsearch(LoggingExporterParams params) {", "originalCommit": "7e7c28b69839925a001ecc3b2c1cd202290cf253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMDMxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463330314", "bodyText": "fixed", "author": "hzhao-github", "createdAt": "2020-07-30T23:43:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxNDk5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxNTEzNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463315134", "bodyText": "Same here: could you please correct java doc description : add param, and correct return description ?", "author": "marinakog", "createdAt": "2020-07-30T22:53:07Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -448,6 +493,125 @@ public static HelmParams installAndVerifyVoyager(String voyagerNamespace,\n     return voyagerHelmParams;\n   }\n \n+  /**\n+   * Uninstall Elasticsearch.\n+   *\n+   * @return the Elasticsearch uninstallation parameters\n+   */\n+  public static boolean uninstallAndVerifyElasticsearch(LoggingExporterParams params) {\n+    // uninstall Elasticsearch\n+    assertThat(uninstallElasticsearch(params))\n+        .as(\"Elasticsearch uninstallation succeeds\")\n+        .withFailMessage(\"Elasticsearch uninstallation is failed\")\n+        .isTrue();\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Uninstall Kibana.\n+   *\n+   * @return the Kibana uninstallation parameters\n+   */\n+  public static boolean uninstallAndVerifyKibana(LoggingExporterParams params) {", "originalCommit": "7e7c28b69839925a001ecc3b2c1cd202290cf253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMDM0NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463330345", "bodyText": "fixed", "author": "hzhao-github", "createdAt": "2020-07-30T23:43:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxNTEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxNTcwNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463315704", "bodyText": "index index typo", "author": "marinakog", "createdAt": "2020-07-30T22:54:53Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -448,6 +493,125 @@ public static HelmParams installAndVerifyVoyager(String voyagerNamespace,\n     return voyagerHelmParams;\n   }\n \n+  /**\n+   * Uninstall Elasticsearch.\n+   *\n+   * @return the Elasticsearch uninstallation parameters\n+   */\n+  public static boolean uninstallAndVerifyElasticsearch(LoggingExporterParams params) {\n+    // uninstall Elasticsearch\n+    assertThat(uninstallElasticsearch(params))\n+        .as(\"Elasticsearch uninstallation succeeds\")\n+        .withFailMessage(\"Elasticsearch uninstallation is failed\")\n+        .isTrue();\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Uninstall Kibana.\n+   *\n+   * @return the Kibana uninstallation parameters\n+   */\n+  public static boolean uninstallAndVerifyKibana(LoggingExporterParams params) {\n+    // uninstall Kibana\n+    assertThat(uninstallKibana(params))\n+        .as(\"Elasticsearch uninstallation succeeds\")\n+        .withFailMessage(\"Elasticsearch uninstallation is failed\")\n+        .isTrue();\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Install Elasticsearch and wait up to five minutes until Elasticsearch pod is ready.\n+   *\n+   * @return Elasticsearch installation parameters\n+   */\n+  public static LoggingExporterParams installAndVerifyElasticsearch() {\n+    LoggingFacade logger = getLogger();\n+    final String elasticsearchPodNamePrefix = ELASTICSEARCH_NAME;\n+\n+    // parameters to install Elasticsearch\n+    LoggingExporterParams elasticsearchParams = new LoggingExporterParams()\n+        .elasticsearchName(ELASTICSEARCH_NAME)\n+        .elasticsearchImage(ELASTICSEARCH_IMAGE)\n+        .elasticsearchHttpPort(ELASTICSEARCH_HTTP_PORT)\n+        .elasticsearchHttpsPort(ELASTICSEARCH_HTTPS_PORT)\n+        .loggingExporterNamespace(ELKSTACK_NAMESPACE);\n+\n+    // install Elasticsearch\n+    assertThat(installElasticsearch(elasticsearchParams))\n+        .as(\"Elasticsearch installation succeeds\")\n+        .withFailMessage(\"Elasticsearch installation is failed\")\n+        .isTrue();\n+\n+    // wait until the Elasticsearch pod is ready.\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\n+                \"Waiting for Elasticsearch to be ready in namespace {0} (elapsed time {1}ms, remaining time {2}ms)\",\n+                ELKSTACK_NAMESPACE,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> isElkStackPodReady(ELKSTACK_NAMESPACE, elasticsearchPodNamePrefix),\n+            \"isElkStackPodReady failed with ApiException\"));\n+\n+    return elasticsearchParams;\n+  }\n+\n+  /**\n+   * Install Kibana and wait up to five minutes until Kibana pod is ready.\n+   *\n+   * @return Kibana installation parameters\n+   */\n+  public static LoggingExporterParams installAndVerifyKibana() {\n+    LoggingFacade logger = getLogger();\n+    final String kibanaPodNamePrefix = ELASTICSEARCH_NAME;\n+\n+    // parameters to install Kibana\n+    LoggingExporterParams kibanaParams = new LoggingExporterParams()\n+        .kibanaName(KIBANA_NAME)\n+        .kibanaImage(KIBANA_IMAGE)\n+        .kibanaType(KIBANA_TYPE)\n+        .loggingExporterNamespace(ELKSTACK_NAMESPACE)\n+        .kibanaContainerPort(KIBANA_PORT);\n+\n+    // install Kibana\n+    assertThat(installKibana(kibanaParams))\n+        .as(\"Kibana installation succeeds\")\n+        .withFailMessage(\"Kibana installation is failed\")\n+        .isTrue();\n+\n+    // wait until the Kibana pod is ready.\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\n+                \"Waiting for Kibana to be ready in namespace {0} (elapsed time {1}ms, remaining time {2}ms)\",\n+                ELKSTACK_NAMESPACE,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(assertDoesNotThrow(() -> isElkStackPodReady(ELKSTACK_NAMESPACE, kibanaPodNamePrefix),\n+            \"isElkStackPodReady failed with ApiException\"));\n+\n+    return kibanaParams;\n+  }\n+\n+  /**\n+   * Verify that the logging exporter is ready to use in Operator pod or WebLogic server pod.\n+   *\n+   * @param namespace namespace of Operator pod (for ELK Stack) or\n+   *                  WebLogic server pod (for WebLogic logging exporter)\n+   * @param labelSelector string containing the labels the Operator or WebLogic server is decorated with\n+   * @param index index key word used to search the index status of the logging exporter\n+   * @return a map containing key and value pair of logging exporter index", "originalCommit": "7e7c28b69839925a001ecc3b2c1cd202290cf253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMTEzOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463331139", "bodyText": "fixed", "author": "hzhao-github", "createdAt": "2020-07-30T23:46:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxNTcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxNjA0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463316044", "bodyText": "the Kibana -> Kibana", "author": "marinakog", "createdAt": "2020-07-30T22:55:52Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/LoggingExporter.java", "diffHunk": "@@ -0,0 +1,474 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.assertions.impl.Deployment;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ELASTICSEARCH_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.ELASTICSEARCH_HTTP_PORT;\n+import static oracle.weblogic.kubernetes.TestConstants.KIBANA_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorPadName;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.isPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class for ELK Stack and WebLogic logging exporter.\n+ */\n+public class LoggingExporter {\n+\n+  private static LoggingFacade logger = getLogger();\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  private static final int maxIterationsPod = 10;\n+\n+  /**\n+   * Install Elasticsearch.\n+   *\n+   * @param params the parameters to install Elasticsearch\n+   * @return true if the Elasticsearch is successfully installed, false otherwise.\n+   */\n+  public static boolean installElasticsearch(LoggingExporterParams params) {\n+    String elasticsearchName = params.getElasticsearchName();\n+    String namespace = params.getLoggingExporterNamespace();\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", elasticsearchName);\n+\n+    // create Elasticsearch deployment CR\n+    logger.info(\"Create Elasticsearch deployment CR for {0} in namespace {1}\",\n+        elasticsearchName, namespace);\n+    V1Deployment elasticsearchDeployment = createElasticsearchDeploymentCr(params);\n+\n+    // create Elasticsearch deployment\n+    logger.info(\"Create Elasticsearch deployment {0} in namespace {1}\", elasticsearchName, namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(elasticsearchDeployment),\n+        String.format(\"Create Elasticsearch deployment failed with ApiException for %s in namespace %s\",\n+          elasticsearchName, namespace));\n+    assertTrue(deploymentCreated,\n+        String.format(\"Create Elasticsearch deployment failed with ApiException for %s in namespace %s\",\n+            elasticsearchName, namespace));\n+    logger.info(\"Check if Elasticsearch deployment {0} is ready in namespace {1}\",\n+        elasticsearchName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for Elasticsearch deployment {0}\"\n+                + \"to be completed in {1} namespace (elapsed time {2}ms, remaining time {3}ms)\",\n+                elasticsearchName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(Deployment.isReady(elasticsearchName, labels, namespace));\n+\n+    // create Elasticsearch service CR\n+    logger.info(\"Create Elasticsearch service CR for {0} in namespace {1}\",\n+        elasticsearchName, namespace);\n+    V1Service elasticsearchService = createElasticsearchServiceCr(params);\n+\n+    // create Elasticsearch service\n+    logger.info(\"Create Elasticsearch service {0} in namespace {1}\", elasticsearchName, namespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(elasticsearchService),\n+        String.format(\"Create Elasticsearch service failed with ApiException for %s in namespace %s\",\n+            elasticsearchName, namespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create Elasticsearch service failed with ApiException for %s in namespace %s\",\n+            elasticsearchName, namespace));\n+\n+    // check that Elasticsearch service exists in its namespace\n+    logger.info(\"Check that Elasticsearch service {0} exists in namespace {1}\",\n+        elasticsearchName, namespace);\n+    checkServiceExists(elasticsearchName, namespace);\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Install Kibana.\n+   *\n+   * @param params the parameters to install Kibana\n+   * @return true if the Kibana is successfully installed, false otherwise.\n+   */", "originalCommit": "7e7c28b69839925a001ecc3b2c1cd202290cf253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMTg0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463331846", "bodyText": "fixed", "author": "hzhao-github", "createdAt": "2020-07-30T23:48:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxNjA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxNjI1Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463316256", "bodyText": "the Elastic -> Elastic", "author": "marinakog", "createdAt": "2020-07-30T22:56:32Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/LoggingExporter.java", "diffHunk": "@@ -0,0 +1,474 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.assertions.impl.Deployment;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ELASTICSEARCH_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.ELASTICSEARCH_HTTP_PORT;\n+import static oracle.weblogic.kubernetes.TestConstants.KIBANA_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorPadName;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.isPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class for ELK Stack and WebLogic logging exporter.\n+ */\n+public class LoggingExporter {\n+\n+  private static LoggingFacade logger = getLogger();\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  private static final int maxIterationsPod = 10;\n+\n+  /**\n+   * Install Elasticsearch.\n+   *\n+   * @param params the parameters to install Elasticsearch\n+   * @return true if the Elasticsearch is successfully installed, false otherwise.\n+   */\n+  public static boolean installElasticsearch(LoggingExporterParams params) {\n+    String elasticsearchName = params.getElasticsearchName();\n+    String namespace = params.getLoggingExporterNamespace();\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", elasticsearchName);\n+\n+    // create Elasticsearch deployment CR\n+    logger.info(\"Create Elasticsearch deployment CR for {0} in namespace {1}\",\n+        elasticsearchName, namespace);\n+    V1Deployment elasticsearchDeployment = createElasticsearchDeploymentCr(params);\n+\n+    // create Elasticsearch deployment\n+    logger.info(\"Create Elasticsearch deployment {0} in namespace {1}\", elasticsearchName, namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(elasticsearchDeployment),\n+        String.format(\"Create Elasticsearch deployment failed with ApiException for %s in namespace %s\",\n+          elasticsearchName, namespace));\n+    assertTrue(deploymentCreated,\n+        String.format(\"Create Elasticsearch deployment failed with ApiException for %s in namespace %s\",\n+            elasticsearchName, namespace));\n+    logger.info(\"Check if Elasticsearch deployment {0} is ready in namespace {1}\",\n+        elasticsearchName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for Elasticsearch deployment {0}\"\n+                + \"to be completed in {1} namespace (elapsed time {2}ms, remaining time {3}ms)\",\n+                elasticsearchName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(Deployment.isReady(elasticsearchName, labels, namespace));\n+\n+    // create Elasticsearch service CR\n+    logger.info(\"Create Elasticsearch service CR for {0} in namespace {1}\",\n+        elasticsearchName, namespace);\n+    V1Service elasticsearchService = createElasticsearchServiceCr(params);\n+\n+    // create Elasticsearch service\n+    logger.info(\"Create Elasticsearch service {0} in namespace {1}\", elasticsearchName, namespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(elasticsearchService),\n+        String.format(\"Create Elasticsearch service failed with ApiException for %s in namespace %s\",\n+            elasticsearchName, namespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create Elasticsearch service failed with ApiException for %s in namespace %s\",\n+            elasticsearchName, namespace));\n+\n+    // check that Elasticsearch service exists in its namespace\n+    logger.info(\"Check that Elasticsearch service {0} exists in namespace {1}\",\n+        elasticsearchName, namespace);\n+    checkServiceExists(elasticsearchName, namespace);\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Install Kibana.\n+   *\n+   * @param params the parameters to install Kibana\n+   * @return true if the Kibana is successfully installed, false otherwise.\n+   */\n+  public static boolean installKibana(LoggingExporterParams params) {\n+    String kibanaName = params.getKibanaName();\n+    String namespace = params.getLoggingExporterNamespace();\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", kibanaName);\n+\n+    // create Kibana deployment CR\n+    logger.info(\"Create Kibana deployment CR for {0} in namespace {1}\", kibanaName, namespace);\n+    V1Deployment kibanaDeployment = createKibanaDeploymentCr(params);\n+\n+    // create Kibana deployment\n+    logger.info(\"Create Kibana deployment {0} in namespace {1}\", kibanaName, namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(kibanaDeployment),\n+        String.format(\"Create Kibana deployment failed with ApiException for %s in namespace $s\",\n+            kibanaName, namespace));\n+    assertTrue(deploymentCreated,\n+        String.format(\"Create Kibana deployment failed with ApiException for %s in %s namespace\",\n+            kibanaName, namespace));\n+    logger.info(\"Checking if Kibana deployment is ready {0} completed in namespace {1}\",\n+        kibanaName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for Kibana deployment {0} to be completed in namespace {1}\"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                kibanaName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(Deployment.isReady(kibanaName, labels, namespace));\n+\n+    // create Kibana service CR\n+    logger.info(\"Create Kibana service CR for {0} in namespace {1}\", kibanaName, namespace);\n+    V1Service kibanaService = createKibanaServiceCr(params);\n+\n+    // create Kibana service\n+    logger.info(\"Create Kibana service for {0} in namespace {1}\", kibanaName, namespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(kibanaService),\n+        String.format(\"Create Kibana service failed with ApiException for %s in namespace %s\",\n+            kibanaName, namespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create Kibana service failed with ApiException for %s in namespace %s\",\n+            kibanaName, namespace));\n+\n+    // check that Kibana service exists in its namespace\n+    logger.info(\"Checking that Kibana service {0} exists in namespace {1}\",\n+        kibanaName, namespace);\n+    checkServiceExists(kibanaName, namespace);\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Uninstall Elasticsearch.\n+   *\n+   * @param params the parameters to uninstall Elasticsearch\n+   * @return true if the Elasticsearch is successfully uninstalled, false otherwise.\n+   */", "originalCommit": "7e7c28b69839925a001ecc3b2c1cd202290cf253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMTkxOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463331919", "bodyText": "fixed", "author": "hzhao-github", "createdAt": "2020-07-30T23:49:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxNjI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxNjM1Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463316357", "bodyText": "the Kibana -> Kibana", "author": "marinakog", "createdAt": "2020-07-30T22:56:48Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/actions/impl/LoggingExporter.java", "diffHunk": "@@ -0,0 +1,474 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.actions.impl;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+import io.kubernetes.client.custom.IntOrString;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1Deployment;\n+import io.kubernetes.client.openapi.models.V1DeploymentSpec;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LabelSelector;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Service;\n+import io.kubernetes.client.openapi.models.V1ServicePort;\n+import io.kubernetes.client.openapi.models.V1ServiceSpec;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Kubernetes;\n+import oracle.weblogic.kubernetes.assertions.impl.Deployment;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ELASTICSEARCH_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.ELASTICSEARCH_HTTP_PORT;\n+import static oracle.weblogic.kubernetes.TestConstants.KIBANA_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.actions.TestActions.execCommand;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getOperatorPadName;\n+import static oracle.weblogic.kubernetes.assertions.impl.Kubernetes.isPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Utility class for ELK Stack and WebLogic logging exporter.\n+ */\n+public class LoggingExporter {\n+\n+  private static LoggingFacade logger = getLogger();\n+  private static ConditionFactory withStandardRetryPolicy =\n+      with().pollDelay(2, SECONDS)\n+          .and().with().pollInterval(10, SECONDS)\n+          .atMost(5, MINUTES).await();\n+\n+  private static final int maxIterationsPod = 10;\n+\n+  /**\n+   * Install Elasticsearch.\n+   *\n+   * @param params the parameters to install Elasticsearch\n+   * @return true if the Elasticsearch is successfully installed, false otherwise.\n+   */\n+  public static boolean installElasticsearch(LoggingExporterParams params) {\n+    String elasticsearchName = params.getElasticsearchName();\n+    String namespace = params.getLoggingExporterNamespace();\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", elasticsearchName);\n+\n+    // create Elasticsearch deployment CR\n+    logger.info(\"Create Elasticsearch deployment CR for {0} in namespace {1}\",\n+        elasticsearchName, namespace);\n+    V1Deployment elasticsearchDeployment = createElasticsearchDeploymentCr(params);\n+\n+    // create Elasticsearch deployment\n+    logger.info(\"Create Elasticsearch deployment {0} in namespace {1}\", elasticsearchName, namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(elasticsearchDeployment),\n+        String.format(\"Create Elasticsearch deployment failed with ApiException for %s in namespace %s\",\n+          elasticsearchName, namespace));\n+    assertTrue(deploymentCreated,\n+        String.format(\"Create Elasticsearch deployment failed with ApiException for %s in namespace %s\",\n+            elasticsearchName, namespace));\n+    logger.info(\"Check if Elasticsearch deployment {0} is ready in namespace {1}\",\n+        elasticsearchName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for Elasticsearch deployment {0}\"\n+                + \"to be completed in {1} namespace (elapsed time {2}ms, remaining time {3}ms)\",\n+                elasticsearchName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(Deployment.isReady(elasticsearchName, labels, namespace));\n+\n+    // create Elasticsearch service CR\n+    logger.info(\"Create Elasticsearch service CR for {0} in namespace {1}\",\n+        elasticsearchName, namespace);\n+    V1Service elasticsearchService = createElasticsearchServiceCr(params);\n+\n+    // create Elasticsearch service\n+    logger.info(\"Create Elasticsearch service {0} in namespace {1}\", elasticsearchName, namespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(elasticsearchService),\n+        String.format(\"Create Elasticsearch service failed with ApiException for %s in namespace %s\",\n+            elasticsearchName, namespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create Elasticsearch service failed with ApiException for %s in namespace %s\",\n+            elasticsearchName, namespace));\n+\n+    // check that Elasticsearch service exists in its namespace\n+    logger.info(\"Check that Elasticsearch service {0} exists in namespace {1}\",\n+        elasticsearchName, namespace);\n+    checkServiceExists(elasticsearchName, namespace);\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Install Kibana.\n+   *\n+   * @param params the parameters to install Kibana\n+   * @return true if the Kibana is successfully installed, false otherwise.\n+   */\n+  public static boolean installKibana(LoggingExporterParams params) {\n+    String kibanaName = params.getKibanaName();\n+    String namespace = params.getLoggingExporterNamespace();\n+    Map labels = new HashMap<String, String>();\n+    labels.put(\"app\", kibanaName);\n+\n+    // create Kibana deployment CR\n+    logger.info(\"Create Kibana deployment CR for {0} in namespace {1}\", kibanaName, namespace);\n+    V1Deployment kibanaDeployment = createKibanaDeploymentCr(params);\n+\n+    // create Kibana deployment\n+    logger.info(\"Create Kibana deployment {0} in namespace {1}\", kibanaName, namespace);\n+    boolean deploymentCreated = assertDoesNotThrow(() -> Kubernetes.createDeployment(kibanaDeployment),\n+        String.format(\"Create Kibana deployment failed with ApiException for %s in namespace $s\",\n+            kibanaName, namespace));\n+    assertTrue(deploymentCreated,\n+        String.format(\"Create Kibana deployment failed with ApiException for %s in %s namespace\",\n+            kibanaName, namespace));\n+    logger.info(\"Checking if Kibana deployment is ready {0} completed in namespace {1}\",\n+        kibanaName, namespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for Kibana deployment {0} to be completed in namespace {1}\"\n+                + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                kibanaName,\n+                namespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(Deployment.isReady(kibanaName, labels, namespace));\n+\n+    // create Kibana service CR\n+    logger.info(\"Create Kibana service CR for {0} in namespace {1}\", kibanaName, namespace);\n+    V1Service kibanaService = createKibanaServiceCr(params);\n+\n+    // create Kibana service\n+    logger.info(\"Create Kibana service for {0} in namespace {1}\", kibanaName, namespace);\n+    boolean serviceCreated = assertDoesNotThrow(() -> Kubernetes.createService(kibanaService),\n+        String.format(\"Create Kibana service failed with ApiException for %s in namespace %s\",\n+            kibanaName, namespace));\n+    assertTrue(serviceCreated, String.format(\n+        \"Create Kibana service failed with ApiException for %s in namespace %s\",\n+            kibanaName, namespace));\n+\n+    // check that Kibana service exists in its namespace\n+    logger.info(\"Checking that Kibana service {0} exists in namespace {1}\",\n+        kibanaName, namespace);\n+    checkServiceExists(kibanaName, namespace);\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Uninstall Elasticsearch.\n+   *\n+   * @param params the parameters to uninstall Elasticsearch\n+   * @return true if the Elasticsearch is successfully uninstalled, false otherwise.\n+   */\n+  public static boolean uninstallElasticsearch(LoggingExporterParams params) {\n+    String elasticsearchName = params.getElasticsearchName();\n+    String namespace = params.getLoggingExporterNamespace();\n+\n+    // Delete Elasticsearch deployment\n+    try {\n+      Kubernetes.deleteDeployment(namespace, elasticsearchName);\n+    } catch (Exception ex) {\n+      logger.warning(\"Failed to delete deployment {0} \", elasticsearchName);\n+    }\n+\n+    logger.info(\"Delete Service {0} in namespace {1}\", elasticsearchName, namespace);\n+    boolean serviceDeleted =\n+        assertDoesNotThrow(() -> Kubernetes.deleteService(elasticsearchName, namespace),\n+            String.format(\"Delete service failed with ApiException for %s in %s namespace \",\n+              elasticsearchName, namespace));\n+    assertTrue(serviceDeleted, String.format(\n+        \"Delete service failed with ApiException for %s in %s namespace \", elasticsearchName, namespace));\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Uninstall Kibana.\n+   *\n+   * @param params the parameters to uninstall Kibana\n+   * @return true if the Kibana is successfully uninstalled, false otherwise.\n+   */", "originalCommit": "7e7c28b69839925a001ecc3b2c1cd202290cf253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMjA4NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r463332084", "bodyText": "fixed", "author": "hzhao-github", "createdAt": "2020-07-30T23:49:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxNjM1Nw=="}], "type": "inlineReview"}, {"oid": "3eee42e343aeb89165c0f45c194b3b424be1b1b1", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3eee42e343aeb89165c0f45c194b3b424be1b1b1", "message": "Changes based on comments jenkins-ignore", "committedDate": "2020-07-31T00:45:25Z", "type": "commit"}, {"oid": "80c8d92eb320d8552f80183832e07e932d1cc660", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/80c8d92eb320d8552f80183832e07e932d1cc660", "message": "Syncup with develop jenkins-ignore", "committedDate": "2020-08-01T22:07:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3MDIwNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r464570205", "bodyText": "remove and fix <<<<<<< HEAD", "author": "vanajamukkara", "createdAt": "2020-08-03T17:51:05Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/CommonTestUtils.java", "diffHunk": "@@ -460,7 +505,130 @@ public static HelmParams installAndVerifyVoyager(String voyagerNamespace,\n   }\n \n   /**\n-   * Install Traefik and wait for up to five minutes for the Traefik pod to be ready.\n+<<<<<<< HEAD", "originalCommit": "80c8d92eb320d8552f80183832e07e932d1cc660", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MjgyMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r464642820", "bodyText": "removed", "author": "hzhao-github", "createdAt": "2020-08-03T20:24:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3MDIwNQ=="}], "type": "inlineReview"}, {"oid": "ca4442e376678d70cd4f12c4e0a395d83a1d6129", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ca4442e376678d70cd4f12c4e0a395d83a1d6129", "message": "Minor change in installAndVerifyOperator jenkins-ignore", "committedDate": "2020-08-03T20:21:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyMzgzNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r465423834", "bodyText": "Can you please describe the usecase detail with step-by-step description. It will be helpful to triage the failures. How you are asserting that ELK is ready to use", "author": "anpanigr", "createdAt": "2020-08-05T01:46:10Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItElkSample.java", "diffHunk": "@@ -0,0 +1,122 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.actions.impl.LoggingExporterParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIBANA_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.TestConstants.LOGSTASH_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyElasticsearch;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyKibana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.uninstallAndVerifyElasticsearch;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.uninstallAndVerifyKibana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.verifyLoggingExporterReady;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify that Elasticsearch collects data from WebLogic logs and\n+ * stores them in its repository correctly.\n+ */\n+@DisplayName(\"Test to use Elasticsearch API to query WebLogic logs\")\n+@IntegrationTest\n+class ItElkSample {\n+\n+  // constants for Operator\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  // constants for ELK Stack\n+  private static LoggingExporterParams elasticsearchParams = null;\n+  private static LoggingExporterParams kibanaParams = null;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Elasticsearch, Kibana and Operator, create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domainNamespace\n+    logger.info(\"Assigning a unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Elasticsearch\n+    logger.info(\"install and verify Elasticsearch\");\n+    elasticsearchParams = assertDoesNotThrow(() -> installAndVerifyElasticsearch(),\n+            String.format(\"Failed to install Elasticsearch\"));\n+    assertTrue(elasticsearchParams != null, \"Failed to install Elasticsearch\");\n+\n+    // install and verify Kibana\n+    logger.info(\"install and verify Kibana\");\n+    kibanaParams = assertDoesNotThrow(() -> installAndVerifyKibana(),\n+        String.format(\"Failed to install Kibana\"));\n+    assertTrue(kibanaParams != null, \"Failed to install Kibana\");\n+\n+    // install and verify Operator\n+    installAndVerifyOperator(opNamespace, opNamespace + \"-sa\", false, 0, true, domainNamespace);\n+  }\n+\n+  /**\n+   * Uninstall ELK Stack and delete domain custom resource.\n+   */\n+  @AfterAll\n+  void tearDown() {\n+    // uninstall ELK Stack\n+    if (elasticsearchParams != null) {\n+      logger.info(\"Uninstall Elasticsearch pod\");\n+      assertDoesNotThrow(() -> uninstallAndVerifyElasticsearch(elasticsearchParams),\n+          \"uninstallAndVerifyElasticsearch failed with ApiException\");\n+    }\n+\n+    if (kibanaParams != null) {\n+      logger.info(\"Uninstall Elasticsearch pod\");\n+      assertDoesNotThrow(() -> uninstallAndVerifyKibana(kibanaParams),\n+          \"uninstallAndVerifyKibana failed with ApiException\");\n+    }\n+  }\n+\n+  /**", "originalCommit": "ca4442e376678d70cd4f12c4e0a395d83a1d6129", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1MjMzMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r465452331", "bodyText": "fixed", "author": "hzhao-github", "createdAt": "2020-08-05T03:37:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyMzgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyNDUyNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r465424525", "bodyText": "Can we include the image tag in the String KIBANA_IMAGE  instead of hard-coding the tag  (6.8.0)", "author": "anpanigr", "createdAt": "2020-08-05T01:48:49Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/TestConstants.java", "diffHunk": "@@ -90,6 +90,21 @@\n   public static final String VOYAGER_CHART_NAME = \"voyager\";\n   public static final String VOYAGER_CHART_VERSION = \"12.0.0\";\n \n+  // ELK Stack and WebLogic logging exporter constants\n+  public static final String ELASTICSEARCH_NAME = \"elasticsearch\";\n+  public static final String ELASTICSEARCH_IMAGE = ELASTICSEARCH_NAME + \":6.8.0\";\n+  public static final String ELASTICSEARCH_HOST = \"elasticsearch.default.svc.cluster.local\";\n+  public static final int ELASTICSEARCH_HTTP_PORT = 9200;\n+  public static final int ELASTICSEARCH_HTTPS_PORT = 9300;\n+  public static final String ELKSTACK_NAMESPACE = \"default\";\n+  public static final String LOGSTASH_INDEX_KEY = \"logstash\";\n+  public static final String WEBLOGIC_INDEX_KEY = \"wls\";\n+  public static final String KIBANA_INDEX_KEY = \"kibana\";\n+  public static final String KIBANA_NAME = \"kibana\";\n+  public static final String KIBANA_IMAGE = KIBANA_NAME + \":6.8.0\";", "originalCommit": "ca4442e376678d70cd4f12c4e0a395d83a1d6129", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1MjMwMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r465452302", "bodyText": "fixed", "author": "hzhao-github", "createdAt": "2020-08-05T03:37:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyNDUyNQ=="}], "type": "inlineReview"}, {"oid": "60a6a89c5c2c78f48008632e6e34d2fff93cb12d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/60a6a89c5c2c78f48008632e6e34d2fff93cb12d", "message": "Syncup with develop jenkins-ignore", "committedDate": "2020-08-05T02:14:20Z", "type": "commit"}, {"oid": "cb0052b87ea60cc8162a696ea10b9389e3473b88", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cb0052b87ea60cc8162a696ea10b9389e3473b88", "message": "Changes based on the comments jenkins-ignore", "committedDate": "2020-08-05T03:35:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQxOTg0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r466419848", "bodyText": "typo creaed -> created\nCan you provide more detail step(s)\na. Start the operator with Elk Enabled\nb. Install Kibana/ElasticSearch\nc.  Install or build Logging Exporter\nd. Start the WebLogic domain\ne. ....", "author": "anpanigr", "createdAt": "2020-08-06T13:40:30Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItElkSample.java", "diffHunk": "@@ -0,0 +1,122 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.actions.impl.LoggingExporterParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIBANA_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.TestConstants.LOGSTASH_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyElasticsearch;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyKibana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.uninstallAndVerifyElasticsearch;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.uninstallAndVerifyKibana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.verifyLoggingExporterReady;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify that Elasticsearch collects data from WebLogic logs and\n+ * stores them in its repository correctly.\n+ */\n+@DisplayName(\"Test to use Elasticsearch API to query WebLogic logs\")\n+@IntegrationTest\n+class ItElkSample {\n+\n+  // constants for Operator\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  // constants for ELK Stack\n+  private static LoggingExporterParams elasticsearchParams = null;\n+  private static LoggingExporterParams kibanaParams = null;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Elasticsearch, Kibana and Operator, create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domainNamespace\n+    logger.info(\"Assigning a unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Elasticsearch\n+    logger.info(\"install and verify Elasticsearch\");\n+    elasticsearchParams = assertDoesNotThrow(() -> installAndVerifyElasticsearch(),\n+            String.format(\"Failed to install Elasticsearch\"));\n+    assertTrue(elasticsearchParams != null, \"Failed to install Elasticsearch\");\n+\n+    // install and verify Kibana\n+    logger.info(\"install and verify Kibana\");\n+    kibanaParams = assertDoesNotThrow(() -> installAndVerifyKibana(),\n+        String.format(\"Failed to install Kibana\"));\n+    assertTrue(kibanaParams != null, \"Failed to install Kibana\");\n+\n+    // install and verify Operator\n+    installAndVerifyOperator(opNamespace, opNamespace + \"-sa\", false, 0, true, domainNamespace);\n+  }\n+\n+  /**\n+   * Uninstall ELK Stack and delete domain custom resource.\n+   */\n+  @AfterAll\n+  void tearDown() {\n+    // uninstall ELK Stack\n+    if (elasticsearchParams != null) {\n+      logger.info(\"Uninstall Elasticsearch pod\");\n+      assertDoesNotThrow(() -> uninstallAndVerifyElasticsearch(elasticsearchParams),\n+          \"uninstallAndVerifyElasticsearch failed with ApiException\");\n+    }\n+\n+    if (kibanaParams != null) {\n+      logger.info(\"Uninstall Elasticsearch pod\");\n+      assertDoesNotThrow(() -> uninstallAndVerifyKibana(kibanaParams),\n+          \"uninstallAndVerifyKibana failed with ApiException\");\n+    }\n+  }\n+\n+  /**\n+   * Verify that ELK Stack is ready to use by checking the index status of\n+   * Kibana and Logstash creaed in the Operator pod successfully.", "originalCommit": "cb0052b87ea60cc8162a696ea10b9389e3473b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUzNzQ5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r466537493", "bodyText": "This is a good idea. how about to add this detailed steps to junit5-elk-tests, #1848, because I may remove this class after this PR is merged", "author": "hzhao-github", "createdAt": "2020-08-06T16:31:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQxOTg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5MDA4Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r466590083", "bodyText": "I just added the comments below to ItElasticLogging in junit5-elk-tests, PR #1848\n/**\n\nTo test ELK Stack used in Operator env, this Elasticsearch test does\n\n\nInstall Kibana/Elasticsearch\n\n\n\n\nInstall and Start the operator with Elk Enabled\n\n\n\n\nVerify that ELK Stack is ready to use by checking the index status of\n\n\nKibana and Logstash created in the Operator pod successfully\n\n\nCreate and Start the WebLogic domain\n\n\n\n\nVerify that Elasticsearch collects data from WebLogic logs and\n\n\nstores them in its repository correctly.\n*/", "author": "hzhao-github", "createdAt": "2020-08-06T17:59:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQxOTg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcxNzE5NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r466717194", "bodyText": "Ok.", "author": "anpanigr", "createdAt": "2020-08-06T22:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQxOTg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQyMzg1NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r466423855", "bodyText": "Instead of adding single opaque Method (verifyLoggingExporterReady) need to provide small methods for each steps in the the usescase we are trying to verify.  This will be easy to triage by going step-by-step when the test fails", "author": "anpanigr", "createdAt": "2020-08-06T13:46:19Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItElkSample.java", "diffHunk": "@@ -0,0 +1,122 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.List;\n+\n+import oracle.weblogic.kubernetes.actions.impl.LoggingExporterParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.KIBANA_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.TestConstants.LOGSTASH_INDEX_KEY;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyElasticsearch;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyKibana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.uninstallAndVerifyElasticsearch;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.uninstallAndVerifyKibana;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.verifyLoggingExporterReady;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Verify that Elasticsearch collects data from WebLogic logs and\n+ * stores them in its repository correctly.\n+ */\n+@DisplayName(\"Test to use Elasticsearch API to query WebLogic logs\")\n+@IntegrationTest\n+class ItElkSample {\n+\n+  // constants for Operator\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+\n+  // constants for ELK Stack\n+  private static LoggingExporterParams elasticsearchParams = null;\n+  private static LoggingExporterParams kibanaParams = null;\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Elasticsearch, Kibana and Operator, create a one cluster domain.\n+   *\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   *                   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void init(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Assigning a unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    // get a new unique domainNamespace\n+    logger.info(\"Assigning a unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify Elasticsearch\n+    logger.info(\"install and verify Elasticsearch\");\n+    elasticsearchParams = assertDoesNotThrow(() -> installAndVerifyElasticsearch(),\n+            String.format(\"Failed to install Elasticsearch\"));\n+    assertTrue(elasticsearchParams != null, \"Failed to install Elasticsearch\");\n+\n+    // install and verify Kibana\n+    logger.info(\"install and verify Kibana\");\n+    kibanaParams = assertDoesNotThrow(() -> installAndVerifyKibana(),\n+        String.format(\"Failed to install Kibana\"));\n+    assertTrue(kibanaParams != null, \"Failed to install Kibana\");\n+\n+    // install and verify Operator\n+    installAndVerifyOperator(opNamespace, opNamespace + \"-sa\", false, 0, true, domainNamespace);\n+  }\n+\n+  /**\n+   * Uninstall ELK Stack and delete domain custom resource.\n+   */\n+  @AfterAll\n+  void tearDown() {\n+    // uninstall ELK Stack\n+    if (elasticsearchParams != null) {\n+      logger.info(\"Uninstall Elasticsearch pod\");\n+      assertDoesNotThrow(() -> uninstallAndVerifyElasticsearch(elasticsearchParams),\n+          \"uninstallAndVerifyElasticsearch failed with ApiException\");\n+    }\n+\n+    if (kibanaParams != null) {\n+      logger.info(\"Uninstall Elasticsearch pod\");\n+      assertDoesNotThrow(() -> uninstallAndVerifyKibana(kibanaParams),\n+          \"uninstallAndVerifyKibana failed with ApiException\");\n+    }\n+  }\n+\n+  /**\n+   * Verify that ELK Stack is ready to use by checking the index status of\n+   * Kibana and Logstash creaed in the Operator pod successfully.\n+   */\n+  @Test\n+  @DisplayName(\"Verify that ELK Stack is ready to use\")\n+  public void testLogLevelSearch() throws Exception {\n+    // Verify that Elastic Stack is ready to use\n+    verifyLoggingExporterReady(opNamespace, null, LOGSTASH_INDEX_KEY);", "originalCommit": "cb0052b87ea60cc8162a696ea10b9389e3473b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUzNjgzNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1839#discussion_r466536836", "bodyText": "This java class is not really test anything. The purpose of the class is to make sure the ELK Stack is installed successfully when running it on Jenkins. I may remove this class after the PR is merged. For real test cases, we have junit5-elk-tests, PR #1848", "author": "hzhao-github", "createdAt": "2020-08-06T16:30:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQyMzg1NQ=="}], "type": "inlineReview"}, {"oid": "28f556668b79fef813241b3b32fb98156cd0b7b7", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/28f556668b79fef813241b3b32fb98156cd0b7b7", "message": "Corrected a typo jenkins-ignore", "committedDate": "2020-08-06T17:11:49Z", "type": "commit"}]}