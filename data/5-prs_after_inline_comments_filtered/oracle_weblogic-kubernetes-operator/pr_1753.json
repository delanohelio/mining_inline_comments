{"pr_number": 1753, "pr_title": "Tests for Istio Configuration   ", "pr_createdAt": "2020-06-20T02:01:24Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753", "timeline": [{"oid": "a7c4c34a26014d2d933e26ec3e4b2f2882222a08", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a7c4c34a26014d2d933e26ec3e4b2f2882222a08", "message": "Addded istio test into develop branch", "committedDate": "2020-06-18T20:59:50Z", "type": "commit"}, {"oid": "1527e9537bdf361d9f5d98ffcaa50568a829eeb9", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1527e9537bdf361d9f5d98ffcaa50568a829eeb9", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into istio-develop", "committedDate": "2020-06-18T21:00:09Z", "type": "commit"}, {"oid": "436d798a10ca513d7dcbb829d3ea83b632a3a1e0", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/436d798a10ca513d7dcbb829d3ea83b632a3a1e0", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into istio-develop", "committedDate": "2020-06-19T21:45:17Z", "type": "commit"}, {"oid": "4aa04f742bb5a9d6a872336c09c8f0040a9b9343", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/4aa04f742bb5a9d6a872336c09c8f0040a9b9343", "message": "Updated Istio tests with new utility methods", "committedDate": "2020-06-20T01:53:49Z", "type": "commit"}, {"oid": "496880f40ed50fc5010f798225ebaa8039a0da9e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/496880f40ed50fc5010f798225ebaa8039a0da9e", "message": "Modify the istio template to incude domain uid", "committedDate": "2020-06-20T19:52:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2Mjk2MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443662961", "bodyText": "Replacing values in template file should be separate from deploying the service since this template is specific to your test. Also, the new file should not be in the src directory - better to put it in pv-root - maybe.", "author": "bhavaniravichandran", "createdAt": "2020-06-22T15:56:56Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/IstioUtils.java", "diffHunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ISTIO_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Command.defaultCommandParams;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The istio utility class for tests.\n+ */\n+public class IstioUtils {\n+\n+  /**\n+   * Install istio.\n+  */\n+  public static void installIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"install-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio installation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Uninstall istio.\n+  */\n+  public static void uninstallIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"uninstall-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio uninstallation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Get the http ingress port of istio installation.\n+   * @returns ingress port for istio-ingressgateway\n+  */\n+  public static int getIstioHttpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getIngressPort = null;\n+    getIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"http2\\\")].nodePort}'\");\n+    logger.info(\"getIngressPort: kubectl command {0}\", new String(getIngressPort));\n+    try {\n+      result = exec(new String(getIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the secure https ingress port of istio installation.\n+   * @returns secure ingress https port for istio-ingressgateway\n+  */\n+  public static int getIstioSecureIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getSecureIngressPort = null;\n+    getSecureIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getSecureIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"https\\\")].nodePort}'\");\n+    logger.info(\"getSecureIngressPort: kubectl command {0}\", new String(getSecureIngressPort));\n+    try {\n+      result = exec(new String(getSecureIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getSecureIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getSecureIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the tcp ingress port of istio installation.\n+   * @returns tcp ingress port for istio-ingressgateway\n+   */\n+  public static int getIstioTcpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getTcpIngressPort = null;\n+    getTcpIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getTcpIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"tcp\\\")].nodePort}'\");\n+    logger.info(\"getTcpIngressPort: kubectl command {0}\", new String(getTcpIngressPort));\n+    try {\n+      result = exec(new String(getTcpIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getTcpIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getTcpIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Deploy the Http Istio Gateway and Istio Virtualservice.\n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @param clusterServiceName  name of WebLogic cluster\n+   * @param adminServiceName name of the admin service\n+   * @returns true if deployment is success otherwise false\n+  */\n+  public static boolean deployHttpIstioGatewayAndVirtualservice(\n+       String domainNamespace, String domainUid, \n+       String adminServiceName, String clusterServiceName) throws IOException {\n+\n+    logger.info(\"Create a staging location for istio configuration objects\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");\n+    deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+    logger.info(\"Copy istio-http-template.service.yaml to staging location\");\n+    Path srcFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-http-template.service.yaml\");\n+    Path targetFile = Paths.get(fileTemp.toString(), \"istio-http-service.yaml\");\n+    Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    String out = targetFile.toString();\n+    replaceStringInFile(out, \"NAMESPACE\", domainNamespace); \n+    replaceStringInFile(out, \"DUID\", domainUid); \n+    replaceStringInFile(out, \"ADMIN_SERVICE\", adminServiceName); \n+    replaceStringInFile(out, \"CLUSTER_SERVICE\", clusterServiceName); ", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg0NTMwOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443845308", "bodyText": "Now the signature has been modified\n/**\n\nDeploy the tcp Istio Gateway and Istio virtual service.\n@param inputTemplateFile input template file\n@param outputTemplateFile output template file\n@param templateMap map containing template variable(s) to be replaced\n@return true if deployment is success otherwise false\n*/\npublic static boolean deployTcpIstioGatewayAndVirtualservice(\nString inputTemplateFile, String outputTemplateFile,\nMap<String, String> templateMap) throws IOException {", "author": "anpanigr", "createdAt": "2020-06-22T21:48:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2Mjk2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxOTk2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r444419960", "bodyText": "I think the calling method should only give the output file name and this method should create it in RESULTS_ROOT/testname. My preference is to have a separate method in utils to copy and update the yaml file (which could be a generic method if other tests want to use it) and that should return the Path where the new file was created which can then be an argument for this deploy method. This comment holds for both the http and TCP deploy service", "author": "bhavaniravichandran", "createdAt": "2020-06-23T18:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2Mjk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2MzM0OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443663349", "bodyText": "Same comment as for the Http service above.", "author": "bhavaniravichandran", "createdAt": "2020-06-22T15:57:29Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/IstioUtils.java", "diffHunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ISTIO_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Command.defaultCommandParams;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The istio utility class for tests.\n+ */\n+public class IstioUtils {\n+\n+  /**\n+   * Install istio.\n+  */\n+  public static void installIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"install-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio installation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Uninstall istio.\n+  */\n+  public static void uninstallIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"uninstall-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio uninstallation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Get the http ingress port of istio installation.\n+   * @returns ingress port for istio-ingressgateway\n+  */\n+  public static int getIstioHttpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getIngressPort = null;\n+    getIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"http2\\\")].nodePort}'\");\n+    logger.info(\"getIngressPort: kubectl command {0}\", new String(getIngressPort));\n+    try {\n+      result = exec(new String(getIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the secure https ingress port of istio installation.\n+   * @returns secure ingress https port for istio-ingressgateway\n+  */\n+  public static int getIstioSecureIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getSecureIngressPort = null;\n+    getSecureIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getSecureIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"https\\\")].nodePort}'\");\n+    logger.info(\"getSecureIngressPort: kubectl command {0}\", new String(getSecureIngressPort));\n+    try {\n+      result = exec(new String(getSecureIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getSecureIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getSecureIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the tcp ingress port of istio installation.\n+   * @returns tcp ingress port for istio-ingressgateway\n+   */\n+  public static int getIstioTcpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getTcpIngressPort = null;\n+    getTcpIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getTcpIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"tcp\\\")].nodePort}'\");\n+    logger.info(\"getTcpIngressPort: kubectl command {0}\", new String(getTcpIngressPort));\n+    try {\n+      result = exec(new String(getTcpIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getTcpIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getTcpIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Deploy the Http Istio Gateway and Istio Virtualservice.\n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @param clusterServiceName  name of WebLogic cluster\n+   * @param adminServiceName name of the admin service\n+   * @returns true if deployment is success otherwise false\n+  */\n+  public static boolean deployHttpIstioGatewayAndVirtualservice(\n+       String domainNamespace, String domainUid, \n+       String adminServiceName, String clusterServiceName) throws IOException {\n+\n+    logger.info(\"Create a staging location for istio configuration objects\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");\n+    deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+    logger.info(\"Copy istio-http-template.service.yaml to staging location\");\n+    Path srcFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-http-template.service.yaml\");\n+    Path targetFile = Paths.get(fileTemp.toString(), \"istio-http-service.yaml\");\n+    Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    String out = targetFile.toString();\n+    replaceStringInFile(out, \"NAMESPACE\", domainNamespace); \n+    replaceStringInFile(out, \"DUID\", domainUid); \n+    replaceStringInFile(out, \"ADMIN_SERVICE\", adminServiceName); \n+    replaceStringInFile(out, \"CLUSTER_SERVICE\", clusterServiceName); \n+    ExecResult result = null;\n+    StringBuffer deployIstioGateway = null;\n+    deployIstioGateway = new StringBuffer(\"kubectl apply -f \");\n+    deployIstioGateway.append(targetFile);\n+    logger.info(\"deployIstioGateway: kubectl command {0}\", new String(deployIstioGateway));\n+    try {\n+      result = exec(new String(deployIstioGateway), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in deployIstioGateway() {0}\", ex);\n+      return false;\n+    }\n+    logger.info(\"deployIstioHttpGateway: kubectl returned {0}\", result.toString());\n+    if (result.stdout().contains(\"istio-http-gateway created\")) {\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+  \n+  /**\n+   * Deploy the tcp Istio Gateway and Istio Virtualservice.\n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @param adminServiceName name of the admin service\n+   * @returns true if deployment is success otherwise false\n+  */\n+  public static boolean deployTcpIstioGatewayAndVirtualservice(\n+        String domainNamespace, String domainUid, String adminServiceName) throws IOException  {\n+\n+    logger.info(\"Create a staging location for istio configuration objects\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");\n+    deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+    logger.info(\"Copy istio-tcp-template.service.yaml to staging location\");\n+    Path srcFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-tcp-template.service.yaml\");\n+    Path targetFile = Paths.get(fileTemp.toString(), \"istio-tcp-service.yaml\");\n+    Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    String out = targetFile.toString();\n+    String adminService = adminServiceName + \".svc.cluster.local\";\n+    replaceStringInFile(out, \"NAMESPACE\", domainNamespace); \n+    replaceStringInFile(out, \"DUID\", domainUid); \n+    replaceStringInFile(out, \"ADMIN_SERVICE\", adminServiceName); ", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg0NTQ2NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443845465", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-22T21:49:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2MzM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY4OTUzMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443689530", "bodyText": "update the description with istio info", "author": "sankarpn", "createdAt": "2020-06-22T16:39:17Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -0,0 +1,293 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create domain in image domain using wdt and start the domain\")", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgxMTMwNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443811305", "bodyText": "@DisplayName(\"Test to create WebLogic domain in domainhome-in-image model with istio configuration\")", "author": "anpanigr", "createdAt": "2020-06-22T20:36:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY4OTUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5MDAyMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443690023", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private String adminServerName = \"admin-server\"; // do not modify\n          \n          \n            \n              private final String adminServerName = \"admin-server\"; // do not modify", "author": "sankarpn", "createdAt": "2020-06-22T16:40:08Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -0,0 +1,293 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create domain in image domain using wdt and start the domain\")\n+@IntegrationTest\n+class ItIstioDomainInImage implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid = \"istio-dii-wdt\";\n+  private String clusterName = \"cluster-1\"; // do not modify \n+  private String adminServerName = \"admin-server\"; // do not modify", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgxMjQ2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443812460", "bodyText": "modified as follows ...\nprivate final String domainUid = \"istio-dii-wdt\";\nprivate final String clusterName = \"cluster-1\"; // do not modify\nprivate final String adminServerName = \"admin-server\"; // do not modify", "author": "anpanigr", "createdAt": "2020-06-22T20:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5MDAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5MDcxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443690714", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private String clusterName = \"cluster-1\"; // do not modify \n          \n          \n            \n              private final String clusterName = \"cluster-1\"; // do not modify", "author": "sankarpn", "createdAt": "2020-06-22T16:41:16Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -0,0 +1,293 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create domain in image domain using wdt and start the domain\")\n+@IntegrationTest\n+class ItIstioDomainInImage implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid = \"istio-dii-wdt\";\n+  private String clusterName = \"cluster-1\"; // do not modify ", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgxMjYxOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443812618", "bodyText": "Done", "author": "anpanigr", "createdAt": "2020-06-22T20:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5MDcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5MTY5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443691696", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Create a domain in domain-home-in-image model.\n          \n          \n            \n               * Create a domain using domain-home-in-image model.", "author": "sankarpn", "createdAt": "2020-06-22T16:42:55Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -0,0 +1,293 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create domain in image domain using wdt and start the domain\")\n+@IntegrationTest\n+class ItIstioDomainInImage implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid = \"istio-dii-wdt\";\n+  private String clusterName = \"cluster-1\"; // do not modify \n+  private String adminServerName = \"admin-server\"; // do not modify\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    \n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a domain in domain-home-in-image model.", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgxMzIzMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443813231", "bodyText": "Modified : Create a domain using domainhome-in-image model.", "author": "anpanigr", "createdAt": "2020-06-22T20:40:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5MTY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5MTkzMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443691931", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Add istio Configuration with default readinessPort \n          \n          \n            \n               * Add istio configuration with default readinessPort", "author": "sankarpn", "createdAt": "2020-06-22T16:43:18Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -0,0 +1,293 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create domain in image domain using wdt and start the domain\")\n+@IntegrationTest\n+class ItIstioDomainInImage implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid = \"istio-dii-wdt\";\n+  private String clusterName = \"cluster-1\"; // do not modify \n+  private String adminServerName = \"admin-server\"; // do not modify\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    \n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a domain in domain-home-in-image model.\n+   * Add istio Configuration with default readinessPort ", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgxNDk0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443814946", "bodyText": "Modified: Add istio configuration with default readinessPort", "author": "anpanigr", "createdAt": "2020-06-22T20:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5MTkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5MjMzOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443692339", "bodyText": "isn't this done in beforeAll?", "author": "sankarpn", "createdAt": "2020-06-22T16:44:01Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -0,0 +1,293 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create domain in image domain using wdt and start the domain\")\n+@IntegrationTest\n+class ItIstioDomainInImage implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid = \"istio-dii-wdt\";\n+  private String clusterName = \"cluster-1\"; // do not modify \n+  private String adminServerName = \"admin-server\"; // do not modify\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    \n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a domain in domain-home-in-image model.\n+   * Add istio Configuration with default readinessPort \n+   * Do not add any AdminService under AdminServer configuration\n+   * Label domain namespace and operator namespace with istio-injection=enabled ", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgxNjMyOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443816328", "bodyText": "Removed the line :  Label domain namespace and operator namespace with istio-injection=enabled", "author": "anpanigr", "createdAt": "2020-06-22T20:46:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5MjMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5MjQ3Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443692476", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Deploy istio gateways and virtualservices \n          \n          \n            \n               * Deploy istio gateways and virtual services", "author": "sankarpn", "createdAt": "2020-06-22T16:44:16Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -0,0 +1,293 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create domain in image domain using wdt and start the domain\")\n+@IntegrationTest\n+class ItIstioDomainInImage implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid = \"istio-dii-wdt\";\n+  private String clusterName = \"cluster-1\"; // do not modify \n+  private String adminServerName = \"admin-server\"; // do not modify\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    \n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a domain in domain-home-in-image model.\n+   * Add istio Configuration with default readinessPort \n+   * Do not add any AdminService under AdminServer configuration\n+   * Label domain namespace and operator namespace with istio-injection=enabled \n+   * Deploy istio gateways and virtualservices ", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgxNjk5OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443816998", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-22T20:47:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5MjQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5Mjg5MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443692890", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Login to WebLogic console is successful thru istio http ingress port.\n          \n          \n            \n               * Verify login to WebLogic console is successful thru istio http ingress port.", "author": "sankarpn", "createdAt": "2020-06-22T16:45:01Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -0,0 +1,293 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create domain in image domain using wdt and start the domain\")\n+@IntegrationTest\n+class ItIstioDomainInImage implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid = \"istio-dii-wdt\";\n+  private String clusterName = \"cluster-1\"; // do not modify \n+  private String adminServerName = \"admin-server\"; // do not modify\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    \n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a domain in domain-home-in-image model.\n+   * Add istio Configuration with default readinessPort \n+   * Do not add any AdminService under AdminServer configuration\n+   * Label domain namespace and operator namespace with istio-injection=enabled \n+   * Deploy istio gateways and virtualservices \n+   * Verify domain pods runs in ready state and services are created.\n+   * Login to WebLogic console is successful thru istio http ingress port.", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgxODI5NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443818294", "bodyText": "Modified: Verify login to WebLogic console is successful thru istio ingress http port.", "author": "anpanigr", "createdAt": "2020-06-22T20:50:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5Mjg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5MzIzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443693235", "bodyText": "do we need to tag this as slow?", "author": "sankarpn", "createdAt": "2020-06-22T16:45:35Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -0,0 +1,293 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create domain in image domain using wdt and start the domain\")\n+@IntegrationTest\n+class ItIstioDomainInImage implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid = \"istio-dii-wdt\";\n+  private String clusterName = \"cluster-1\"; // do not modify \n+  private String adminServerName = \"admin-server\"; // do not modify\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    \n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a domain in domain-home-in-image model.\n+   * Add istio Configuration with default readinessPort \n+   * Do not add any AdminService under AdminServer configuration\n+   * Label domain namespace and operator namespace with istio-injection=enabled \n+   * Deploy istio gateways and virtualservices \n+   * Verify domain pods runs in ready state and services are created.\n+   * Login to WebLogic console is successful thru istio http ingress port.\n+   * Deploy a web application thru istio http ingress port using REST api  \n+   * Access web application thru istio http ingress port using curl\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domainhome-in-image with istio\")\n+  @Slow", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyMDU0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443820548", "bodyText": "These are the boiler plate tag inherited from the Template code for Tests", "author": "anpanigr", "createdAt": "2020-06-22T20:54:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5MzIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5MzYwMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443693600", "bodyText": "is there a reason why it shouldn't run in parallel?", "author": "sankarpn", "createdAt": "2020-06-22T16:46:12Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -0,0 +1,293 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create domain in image domain using wdt and start the domain\")\n+@IntegrationTest\n+class ItIstioDomainInImage implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid = \"istio-dii-wdt\";\n+  private String clusterName = \"cluster-1\"; // do not modify \n+  private String adminServerName = \"admin-server\"; // do not modify\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    \n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a domain in domain-home-in-image model.\n+   * Add istio Configuration with default readinessPort \n+   * Do not add any AdminService under AdminServer configuration\n+   * Label domain namespace and operator namespace with istio-injection=enabled \n+   * Deploy istio gateways and virtualservices \n+   * Verify domain pods runs in ready state and services are created.\n+   * Login to WebLogic console is successful thru istio http ingress port.\n+   * Deploy a web application thru istio http ingress port using REST api  \n+   * Access web application thru istio http ingress port using curl\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domainhome-in-image with istio\")\n+  @Slow\n+  @MustNotRunInParallel", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyMDU3MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443820570", "bodyText": "These are the boiler plate tag inherited from the Template code for Tests", "author": "anpanigr", "createdAt": "2020-06-22T20:54:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5MzYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5NDU2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443694564", "bodyText": "we don't need the above checks, the podReady will cover both existence and readiness.", "author": "sankarpn", "createdAt": "2020-06-22T16:47:52Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -0,0 +1,293 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create domain in image domain using wdt and start the domain\")\n+@IntegrationTest\n+class ItIstioDomainInImage implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid = \"istio-dii-wdt\";\n+  private String clusterName = \"cluster-1\"; // do not modify \n+  private String adminServerName = \"admin-server\"; // do not modify\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    \n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a domain in domain-home-in-image model.\n+   * Add istio Configuration with default readinessPort \n+   * Do not add any AdminService under AdminServer configuration\n+   * Label domain namespace and operator namespace with istio-injection=enabled \n+   * Deploy istio gateways and virtualservices \n+   * Verify domain pods runs in ready state and services are created.\n+   * Login to WebLogic console is successful thru istio http ingress port.\n+   * Deploy a web application thru istio http ingress port using REST api  \n+   * Access web application thru istio http ingress port using curl\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domainhome-in-image with istio\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testIstioDomainHomeInImageUsingWdt() {\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace);\n+\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create the domain CR\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, REPO_SECRET_NAME,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for adminserver pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managedserver pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE4NDg2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r444184860", "bodyText": "removed the checkPodExists code", "author": "anpanigr", "createdAt": "2020-06-23T12:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5NDU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5NTA2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443695064", "bodyText": "This should be done before pod readiness check. If no services are created the pods will never become ready.", "author": "sankarpn", "createdAt": "2020-06-22T16:48:47Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -0,0 +1,293 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create domain in image domain using wdt and start the domain\")\n+@IntegrationTest\n+class ItIstioDomainInImage implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid = \"istio-dii-wdt\";\n+  private String clusterName = \"cluster-1\"; // do not modify \n+  private String adminServerName = \"admin-server\"; // do not modify\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    \n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a domain in domain-home-in-image model.\n+   * Add istio Configuration with default readinessPort \n+   * Do not add any AdminService under AdminServer configuration\n+   * Label domain namespace and operator namespace with istio-injection=enabled \n+   * Deploy istio gateways and virtualservices \n+   * Verify domain pods runs in ready state and services are created.\n+   * Login to WebLogic console is successful thru istio http ingress port.\n+   * Deploy a web application thru istio http ingress port using REST api  \n+   * Access web application thru istio http ingress port using curl\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domainhome-in-image with istio\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testIstioDomainHomeInImageUsingWdt() {\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace);\n+\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create the domain CR\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, REPO_SECRET_NAME,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for adminserver pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managedserver pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE4NTA3Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r444185077", "bodyText": "Remove the  checkServiceExists code", "author": "anpanigr", "createdAt": "2020-06-23T12:29:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5NTA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5NTQ0Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443695443", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertTrue(deployRes, \"Could not deploy Http Istio Gateway/VirtualService\");\n          \n          \n            \n                assertTrue(deployRes, \"Failed to create Http Istio Gateway/VirtualService\");", "author": "sankarpn", "createdAt": "2020-06-22T16:49:28Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -0,0 +1,293 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create domain in image domain using wdt and start the domain\")\n+@IntegrationTest\n+class ItIstioDomainInImage implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid = \"istio-dii-wdt\";\n+  private String clusterName = \"cluster-1\"; // do not modify \n+  private String adminServerName = \"admin-server\"; // do not modify\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    \n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a domain in domain-home-in-image model.\n+   * Add istio Configuration with default readinessPort \n+   * Do not add any AdminService under AdminServer configuration\n+   * Label domain namespace and operator namespace with istio-injection=enabled \n+   * Deploy istio gateways and virtualservices \n+   * Verify domain pods runs in ready state and services are created.\n+   * Login to WebLogic console is successful thru istio http ingress port.\n+   * Deploy a web application thru istio http ingress port using REST api  \n+   * Access web application thru istio http ingress port using curl\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domainhome-in-image with istio\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testIstioDomainHomeInImageUsingWdt() {\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace);\n+\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create the domain CR\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, REPO_SECRET_NAME,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for adminserver pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managedserver pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String clusterService = domainUid + \"-cluster-\" + clusterName + \".\" + domainNamespace + \".svc.cluster.local\";\n+    boolean deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(domainNamespace, domainUid,  adminServerPodName, clusterService));\n+    assertTrue(deployRes, \"Could not deploy Http Istio Gateway/VirtualService\");", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyMzczMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443823731", "bodyText": "Modified", "author": "anpanigr", "createdAt": "2020-06-22T21:01:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5NTQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5NzgyNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443697826", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertTrue(deployRes, \"Could not deploy Istio DestinationRule\");\n          \n          \n            \n                assertTrue(deployRes, \"Failed to create Istio DestinationRule\");", "author": "sankarpn", "createdAt": "2020-06-22T16:53:27Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInImage.java", "diffHunk": "@@ -0,0 +1,293 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.annotations.tags.MustNotRunInParallel;\n+import oracle.weblogic.kubernetes.annotations.tags.Slow;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.WDT_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployIstioDestinationRule;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@DisplayName(\"Test to create domain in image domain using wdt and start the domain\")\n+@IntegrationTest\n+class ItIstioDomainInImage implements LoggedTest {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+  private String domainUid = \"istio-dii-wdt\";\n+  private String clusterName = \"cluster-1\"; // do not modify \n+  private String adminServerName = \"admin-server\"; // do not modify\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  /**\n+   * Install Operator.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    installIstio();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Label the domain/operator namespace with istio-injection=enabled\n+    \n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+  }\n+\n+  /**\n+   * Create a domain in domain-home-in-image model.\n+   * Add istio Configuration with default readinessPort \n+   * Do not add any AdminService under AdminServer configuration\n+   * Label domain namespace and operator namespace with istio-injection=enabled \n+   * Deploy istio gateways and virtualservices \n+   * Verify domain pods runs in ready state and services are created.\n+   * Login to WebLogic console is successful thru istio http ingress port.\n+   * Deploy a web application thru istio http ingress port using REST api  \n+   * Access web application thru istio http ingress port using curl\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domainhome-in-image with istio\")\n+  @Slow\n+  @MustNotRunInParallel\n+  public void testIstioDomainHomeInImageUsingWdt() {\n+    final String managedServerPrefix = domainUid + \"-managed-server\";\n+    final int replicaCount = 2;\n+\n+    // Create the repo secret to pull the image\n+    createDockerRegistrySecret(domainNamespace);\n+\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    createSecretWithUsernamePassword(adminSecretName, domainNamespace, ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create the domain CR\n+    createDomainResource(domainUid, domainNamespace, adminSecretName, REPO_SECRET_NAME,\n+        replicaCount);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+\n+    // check admin server pod exists\n+    logger.info(\"Check for adminserver pod {0} existence in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodExists(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods exist\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check for managedserver pod {0} existence in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodExists(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    String clusterService = domainUid + \"-cluster-\" + clusterName + \".\" + domainNamespace + \".svc.cluster.local\";\n+    boolean deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(domainNamespace, domainUid,  adminServerPodName, clusterService));\n+    assertTrue(deployRes, \"Could not deploy Http Istio Gateway/VirtualService\");\n+\n+    deployRes = assertDoesNotThrow(\n+        () -> deployIstioDestinationRule(domainNamespace, domainUid));\n+    assertTrue(deployRes, \"Could not deploy Istio DestinationRule\");", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyMzg1OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443823859", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-22T21:01:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY5NzgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwNDIxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443704214", "bodyText": "update above texts ti include istio", "author": "sankarpn", "createdAt": "2020-06-22T17:05:05Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInPV.java", "diffHunk": "@@ -0,0 +1,626 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyMzk1MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443823951", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-22T21:01:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwNDIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwNDUwOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443704509", "bodyText": "it is done in beforeAll", "author": "sankarpn", "createdAt": "2020-06-22T17:05:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInPV.java", "diffHunk": "@@ -0,0 +1,626 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItIstioDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+  private final String domainUid = \"istio-div\";\n+  private final String clusterName = \"mycluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    installIstio();\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assign a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Label the operator/domain namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Add istio Configuration \n+   * Label domain namespace and operator namespace with istio-injection=enabled ", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyNDAyMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443824020", "bodyText": "Remove the line from javadoc", "author": "anpanigr", "createdAt": "2020-06-22T21:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwNDUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwNDYyMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443704622", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Deploy istio gateways and virtualservices\n          \n          \n            \n               * Deploy istio gateways and virtual services", "author": "sankarpn", "createdAt": "2020-06-22T17:05:52Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInPV.java", "diffHunk": "@@ -0,0 +1,626 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItIstioDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+  private final String domainUid = \"istio-div\";\n+  private final String clusterName = \"mycluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    installIstio();\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assign a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Label the operator/domain namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Add istio Configuration \n+   * Label domain namespace and operator namespace with istio-injection=enabled \n+   * Deploy istio gateways and virtualservices", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwNTU1OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443705558", "bodyText": "move this before podReady check", "author": "sankarpn", "createdAt": "2020-06-22T17:07:42Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInPV.java", "diffHunk": "@@ -0,0 +1,626 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItIstioDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+  private final String domainUid = \"istio-div\";\n+  private final String clusterName = \"mycluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    installIstio();\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assign a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Label the operator/domain namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Add istio Configuration \n+   * Label domain namespace and operator namespace with istio-injection=enabled \n+   * Deploy istio gateways and virtualservices\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful thru ISTIO ingress Port.\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV with Istio\")\n+  public void testIstioDomainInPvUsingWlst() {\n+\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, domainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, domainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(() ->\n+            File.createTempFile(\"domain\", \"properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"domain_uid\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(() ->\n+            p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-istio-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, domainNamespace);\n+\n+    // Enable istio in domain custom resource configuration object.\n+    // Add T3Channel Service with port assigned to Istio TCP ingress port.\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid) \n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .istio(new Istio()\n+                    .enabled(Boolean.TRUE)\n+                    .readinessPort(8888))));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, domainNamespace);", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE4NTgzMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r444185831", "bodyText": "Refactored the code", "author": "anpanigr", "createdAt": "2020-06-23T12:31:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwNTU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwNTYzMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443705631", "bodyText": "same as above", "author": "sankarpn", "createdAt": "2020-06-22T17:07:53Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInPV.java", "diffHunk": "@@ -0,0 +1,626 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItIstioDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+  private final String domainUid = \"istio-div\";\n+  private final String clusterName = \"mycluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    installIstio();\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assign a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Label the operator/domain namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Add istio Configuration \n+   * Label domain namespace and operator namespace with istio-injection=enabled \n+   * Deploy istio gateways and virtualservices\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful thru ISTIO ingress Port.\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV with Istio\")\n+  public void testIstioDomainInPvUsingWlst() {\n+\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, domainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, domainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(() ->\n+            File.createTempFile(\"domain\", \"properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"domain_uid\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(() ->\n+            p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-istio-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, domainNamespace);\n+\n+    // Enable istio in domain custom resource configuration object.\n+    // Add T3Channel Service with port assigned to Istio TCP ingress port.\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid) \n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .istio(new Istio()\n+                    .enabled(Boolean.TRUE)\n+                    .readinessPort(8888))));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, domainNamespace);", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE4NTg5MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r444185890", "bodyText": "Refactored the code", "author": "anpanigr", "createdAt": "2020-06-23T12:31:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwNTYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwNTgyMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443705820", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertTrue(deployRes, \"Could not deploy Istio Gateway/Virtual Service\");\n          \n          \n            \n                assertTrue(deployRes, \"Failed to create  Istio Gateway/Virtual Service\");", "author": "sankarpn", "createdAt": "2020-06-22T17:08:13Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItIstioDomainInPV.java", "diffHunk": "@@ -0,0 +1,626 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import io.kubernetes.client.custom.Quantity;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Container;\n+import io.kubernetes.client.openapi.models.V1ContainerPort;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1HostPathVolumeSource;\n+import io.kubernetes.client.openapi.models.V1Job;\n+import io.kubernetes.client.openapi.models.V1JobCondition;\n+import io.kubernetes.client.openapi.models.V1JobSpec;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1PersistentVolume;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaim;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimSpec;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeClaimVolumeSource;\n+import io.kubernetes.client.openapi.models.V1PersistentVolumeSpec;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import io.kubernetes.client.openapi.models.V1PodTemplateSpec;\n+import io.kubernetes.client.openapi.models.V1ResourceRequirements;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1SecurityContext;\n+import io.kubernetes.client.openapi.models.V1Volume;\n+import io.kubernetes.client.openapi.models.V1VolumeMount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.Istio;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.extensions.LoggedTest;\n+import oracle.weblogic.kubernetes.utils.CommonTestUtils;\n+import oracle.weblogic.kubernetes.utils.DeployUtil;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import oracle.weblogic.kubernetes.utils.OracleHttpClient;\n+import org.apache.commons.io.FileUtils;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_PASSWORD_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.ADMIN_USERNAME_DEFAULT;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.KIND_REPO;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_EMAIL;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_PASSWORD;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_REGISTRY;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.OCR_USERNAME;\n+import static oracle.weblogic.kubernetes.TestConstants.PV_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.ITTESTS_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WLS_BASE_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.actions.TestActions.addLabelsToNamespace;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createConfigMap;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createNamespacedJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolume;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createPersistentVolumeClaim;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getJob;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getPodLog;\n+import static oracle.weblogic.kubernetes.actions.TestActions.listPods;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.adminNodePortAccessible;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.jobCompleted;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDomainAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createSecretWithUsernamePassword;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.deployHttpIstioGatewayAndVirtualservice;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.getIstioHttpIngressPort;\n+import static oracle.weblogic.kubernetes.utils.IstioUtils.installIstio;\n+import static oracle.weblogic.kubernetes.utils.TestUtils.getNextFreePort;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests to create domain in persistent volume using WLST.\n+ */\n+@DisplayName(\"Verify the WebLogic server pods can run with domain created in persistent volume\")\n+@IntegrationTest\n+public class ItIstioDomainInPV implements LoggedTest {\n+\n+  private static String opNamespace = null;\n+  private static String domainNamespace = null;\n+\n+  private static String image = WLS_BASE_IMAGE_NAME + \":\" + WLS_BASE_IMAGE_TAG;\n+  private static boolean isUseSecret = true;\n+\n+  private final String wlSecretName = \"weblogic-credentials\";\n+  private final String domainUid = \"istio-div\";\n+  private final String clusterName = \"mycluster\";\n+  private final String adminServerName = \"admin-server\";\n+  private final String adminServerPodName = domainUid + \"-\" + adminServerName;\n+\n+  // create standard, reusable retry/backoff policy\n+  private static final ConditionFactory withStandardRetryPolicy\n+      = with().pollDelay(2, SECONDS)\n+      .and().with().pollInterval(10, SECONDS)\n+      .atMost(5, MINUTES).await();\n+\n+\n+  /**\n+   * Assigns unique namespaces for operator and domains.\n+   * Pull WebLogic image if running tests in Kind cluster.\n+   * Installs operator.\n+   *\n+   * @param namespaces injected by JUnit\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+\n+    installIstio();\n+    logger.info(\"Assign a unique namespace for operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Assign a unique namespace for WebLogic domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // Label the operator/domain namespace with istio-injection=enabled\n+    Map<String, String> labelMap = new HashMap();\n+    labelMap.put(\"istio-injection\", \"enabled\");\n+\n+    assertDoesNotThrow(() -> addLabelsToNamespace(domainNamespace,labelMap));\n+    assertDoesNotThrow(() -> addLabelsToNamespace(opNamespace,labelMap));\n+\n+    // install operator and verify its running in ready state\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    //determine if the tests are running in Kind cluster. if true use images from Kind registry\n+    if (KIND_REPO != null) {\n+      String kindRepoImage = KIND_REPO + image.substring(TestConstants.OCR_REGISTRY.length() + 1);\n+      logger.info(\"Using image {0}\", kindRepoImage);\n+      image = kindRepoImage;\n+      isUseSecret = false;\n+    }\n+  }\n+\n+  /**\n+   * Create a WebLogic domain using WLST in a persistent volume.\n+   * Add istio Configuration \n+   * Label domain namespace and operator namespace with istio-injection=enabled \n+   * Deploy istio gateways and virtualservices\n+   * Verify domain pods runs in ready state and services are created.\n+   * Verify login to WebLogic console is successful thru ISTIO ingress Port.\n+   */\n+  @Test\n+  @DisplayName(\"Create WebLogic domain in PV with Istio\")\n+  public void testIstioDomainInPvUsingWlst() {\n+\n+    final String managedServerNameBase = \"wlst-ms-\";\n+    String managedServerPodNamePrefix = domainUid + \"-\" + managedServerNameBase;\n+    final int replicaCount = 2;\n+    final int t3ChannelPort = getNextFreePort(30000, 32767);  // the port range has to be between 30,000 to 32,767\n+\n+    final String pvName = domainUid + \"-pv\"; // name of the persistent volume\n+    final String pvcName = domainUid + \"-pvc\"; // name of the persistent volume claim\n+\n+    // create pull secrets for WebLogic image when running in non Kind Kubernetes cluster\n+    if (isUseSecret) {\n+      createOCRRepoSecret(domainNamespace);\n+    }\n+\n+\n+    // create WebLogic domain credential secret\n+    createSecretWithUsernamePassword(wlSecretName, domainNamespace,\n+        ADMIN_USERNAME_DEFAULT, ADMIN_PASSWORD_DEFAULT);\n+\n+    // create persistent volume and persistent volume claim for domain\n+    // these resources should be labeled with domainUid for cleanup after testing\n+    createPV(pvName, domainUid);\n+    createPVC(pvName, pvcName, domainUid, domainNamespace);\n+\n+    // create a temporary WebLogic domain property file\n+    File domainPropertiesFile = assertDoesNotThrow(() ->\n+            File.createTempFile(\"domain\", \"properties\"),\n+        \"Failed to create domain properties file\");\n+    Properties p = new Properties();\n+    p.setProperty(\"domain_path\", \"/shared/domains\");\n+    p.setProperty(\"domain_name\", domainUid);\n+    p.setProperty(\"domain_uid\", domainUid);\n+    p.setProperty(\"cluster_name\", clusterName);\n+    p.setProperty(\"admin_server_name\", adminServerName);\n+    p.setProperty(\"managed_server_port\", \"8001\");\n+    p.setProperty(\"admin_server_port\", \"7001\");\n+    p.setProperty(\"admin_username\", ADMIN_USERNAME_DEFAULT);\n+    p.setProperty(\"admin_password\", ADMIN_PASSWORD_DEFAULT);\n+    p.setProperty(\"admin_t3_public_address\", K8S_NODEPORT_HOST);\n+    p.setProperty(\"admin_t3_channel_port\", Integer.toString(t3ChannelPort));\n+    p.setProperty(\"number_of_ms\", \"4\");\n+    p.setProperty(\"managed_server_name_base\", managedServerNameBase);\n+    p.setProperty(\"domain_logs\", \"/shared/logs\");\n+    p.setProperty(\"production_mode_enabled\", \"true\");\n+    assertDoesNotThrow(() ->\n+            p.store(new FileOutputStream(domainPropertiesFile), \"wlst properties file\"),\n+        \"Failed to write domain properties file\");\n+\n+    // WLST script for creating domain\n+    Path wlstScript = Paths.get(RESOURCE_DIR, \"python-scripts\", \"wlst-create-istio-domain-onpv.py\");\n+\n+    // create configmap and domain on persistent volume using the WLST script and property file\n+    createDomainOnPVUsingWlst(wlstScript, domainPropertiesFile.toPath(),\n+        pvName, pvcName, domainNamespace);\n+\n+    // Enable istio in domain custom resource configuration object.\n+    // Add T3Channel Service with port assigned to Istio TCP ingress port.\n+    logger.info(\"Creating domain custom resource\");\n+    Domain domain = new Domain()\n+        .apiVersion(DOMAIN_API_VERSION)\n+        .kind(\"Domain\")\n+        .metadata(new V1ObjectMeta()\n+            .name(domainUid)\n+            .namespace(domainNamespace))\n+        .spec(new DomainSpec()\n+            .domainUid(domainUid)\n+            .domainHome(\"/shared/domains/\" + domainUid) \n+            .domainHomeSourceType(\"PersistentVolume\")\n+            .image(image)\n+            .imagePullPolicy(\"IfNotPresent\")\n+            .imagePullSecrets(isUseSecret ? Arrays.asList(\n+                new V1LocalObjectReference()\n+                    .name(OCR_SECRET_NAME))\n+                : null)\n+            .webLogicCredentialsSecret(new V1SecretReference()\n+                .name(wlSecretName)\n+                .namespace(domainNamespace))\n+            .includeServerOutInPodLog(true)\n+            .logHomeEnabled(Boolean.TRUE)\n+            .logHome(\"/shared/logs/\" + domainUid)\n+            .dataHome(\"\")\n+            .serverStartPolicy(\"IF_NEEDED\")\n+            .serverPod(new ServerPod() //serverpod\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"JAVA_OPTIONS\")\n+                    .value(\"-Dweblogic.StdoutDebugEnabled=false\"))\n+                .addEnvItem(new V1EnvVar()\n+                    .name(\"USER_MEM_ARGS\")\n+                    .value(\"-Djava.security.egd=file:/dev/./urandom \"))\n+                .addVolumesItem(new V1Volume()\n+                    .name(pvName)\n+                    .persistentVolumeClaim(new V1PersistentVolumeClaimVolumeSource()\n+                        .claimName(pvcName)))\n+                .addVolumeMountsItem(new V1VolumeMount()\n+                    .mountPath(\"/shared\")\n+                    .name(pvName)))\n+            .adminServer(new AdminServer() //admin server\n+                .serverStartState(\"RUNNING\")\n+                .adminService(new AdminService()\n+                    .addChannelsItem(new Channel()\n+                        .channelName(\"T3Channel\")\n+                        .nodePort(t3ChannelPort))))\n+            .addClustersItem(new Cluster() //cluster\n+                .clusterName(clusterName)\n+                .replicas(replicaCount)\n+                .serverStartState(\"RUNNING\"))\n+            .configuration(new Configuration()\n+                .istio(new Istio()\n+                    .enabled(Boolean.TRUE)\n+                    .readinessPort(8888))));\n+\n+    // verify the domain custom resource is created\n+    createDomainAndVerify(domain, domainNamespace);\n+\n+    // verify admin server pod is ready\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    // verify the admin server service created\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // verify managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Waiting for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkPodReady(managedServerPodNamePrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // verify managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Checking managed server service {0} is created in namespace {1}\",\n+          managedServerPodNamePrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPodNamePrefix + i, domainNamespace);\n+    }\n+\n+    String clusterService = domainUid + \"-cluster-\" + clusterName + \".\" + domainNamespace + \".svc.cluster.local\";\n+    boolean deployRes = assertDoesNotThrow(\n+        () -> deployHttpIstioGatewayAndVirtualservice(domainNamespace, domainUid, adminServerPodName, clusterService));\n+    assertTrue(deployRes, \"Could not deploy Istio Gateway/Virtual Service\");", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyNDE5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443824196", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-22T21:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwNTgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwNjg5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443706895", "bodyText": "This should be moved inside cleanuputil.java", "author": "sankarpn", "createdAt": "2020-06-22T17:10:12Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/extensions/IntegrationTestWatcher.java", "diffHunk": "@@ -313,6 +314,7 @@ public void afterAll(ExtensionContext context) {\n     } else {\n       logger.info(\"Starting cleanup after test class\");\n       CleanupUtil.cleanup(namespaces);\n+      IstioUtils.uninstallIstio();", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE4NjkxMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r444186913", "bodyText": "This is not a general cleanup task, so I put hem into  IstioUtils.", "author": "anpanigr", "createdAt": "2020-06-23T12:33:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwNjg5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI3MTMyOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r444271328", "bodyText": "@anpanigr we need to keep all cleanup code in one place.\nYou can put this this as a first step in CleanupUtil.java\npublic static void cleanup(List namespaces) {\ntry {\nIstioUtils.uninstallIstio();\n// If namespace list is empty or null return\nif (namespaces == null || namespaces.isEmpty()) {\nlogger.info(\"Nothing to cleanup\");\nreturn;\n}", "author": "sankarpn", "createdAt": "2020-06-23T14:32:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwNjg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwNzU2Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443707566", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Deploy application using REST API.\n          \n          \n            \n               * Deploy application using REST API with curl utility.", "author": "sankarpn", "createdAt": "2020-06-22T17:11:22Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/DeployUtil.java", "diffHunk": "@@ -266,4 +268,43 @@ private static void setImage(String namespace) {\n     logger.info(\"Using image {0}\", image);\n   }\n \n+  /**\n+   * Deploy application using REST API.", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyNTI5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443825297", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-22T21:04:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwNzU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwOTM2OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443709368", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @returns ingress port for istio-ingressgateway\n          \n          \n            \n               * @return ingress port for istio-ingressgateway", "author": "sankarpn", "createdAt": "2020-06-22T17:14:48Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/IstioUtils.java", "diffHunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ISTIO_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Command.defaultCommandParams;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The istio utility class for tests.\n+ */\n+public class IstioUtils {\n+\n+  /**\n+   * Install istio.\n+  */\n+  public static void installIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"install-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio installation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Uninstall istio.\n+  */\n+  public static void uninstallIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"uninstall-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio uninstallation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Get the http ingress port of istio installation.\n+   * @returns ingress port for istio-ingressgateway", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyNjE1Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443826153", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-22T21:06:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwOTM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwOTQ3OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443709479", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @returns secure ingress https port for istio-ingressgateway\n          \n          \n            \n               * @return secure ingress https port for istio-ingressgateway", "author": "sankarpn", "createdAt": "2020-06-22T17:15:02Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/IstioUtils.java", "diffHunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ISTIO_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Command.defaultCommandParams;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The istio utility class for tests.\n+ */\n+public class IstioUtils {\n+\n+  /**\n+   * Install istio.\n+  */\n+  public static void installIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"install-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio installation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Uninstall istio.\n+  */\n+  public static void uninstallIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"uninstall-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio uninstallation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Get the http ingress port of istio installation.\n+   * @returns ingress port for istio-ingressgateway\n+  */\n+  public static int getIstioHttpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getIngressPort = null;\n+    getIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"http2\\\")].nodePort}'\");\n+    logger.info(\"getIngressPort: kubectl command {0}\", new String(getIngressPort));\n+    try {\n+      result = exec(new String(getIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the secure https ingress port of istio installation.\n+   * @returns secure ingress https port for istio-ingressgateway", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyNjI0MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443826240", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-22T21:06:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwOTQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMDAzMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443710030", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @returns tcp ingress port for istio-ingressgateway\n          \n          \n            \n               * @return tcp ingress port for istio-ingressgateway", "author": "sankarpn", "createdAt": "2020-06-22T17:16:02Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/IstioUtils.java", "diffHunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ISTIO_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Command.defaultCommandParams;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The istio utility class for tests.\n+ */\n+public class IstioUtils {\n+\n+  /**\n+   * Install istio.\n+  */\n+  public static void installIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"install-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio installation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Uninstall istio.\n+  */\n+  public static void uninstallIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"uninstall-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio uninstallation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Get the http ingress port of istio installation.\n+   * @returns ingress port for istio-ingressgateway\n+  */\n+  public static int getIstioHttpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getIngressPort = null;\n+    getIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"http2\\\")].nodePort}'\");\n+    logger.info(\"getIngressPort: kubectl command {0}\", new String(getIngressPort));\n+    try {\n+      result = exec(new String(getIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the secure https ingress port of istio installation.\n+   * @returns secure ingress https port for istio-ingressgateway\n+  */\n+  public static int getIstioSecureIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getSecureIngressPort = null;\n+    getSecureIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getSecureIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"https\\\")].nodePort}'\");\n+    logger.info(\"getSecureIngressPort: kubectl command {0}\", new String(getSecureIngressPort));\n+    try {\n+      result = exec(new String(getSecureIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getSecureIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getSecureIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the tcp ingress port of istio installation.\n+   * @returns tcp ingress port for istio-ingressgateway", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyNjI5NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443826294", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-22T21:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMDAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMDI1NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443710255", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @returns true if deployment is success otherwise false\n          \n          \n            \n               * @return true if deployment is success otherwise false", "author": "sankarpn", "createdAt": "2020-06-22T17:16:23Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/IstioUtils.java", "diffHunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ISTIO_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Command.defaultCommandParams;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The istio utility class for tests.\n+ */\n+public class IstioUtils {\n+\n+  /**\n+   * Install istio.\n+  */\n+  public static void installIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"install-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio installation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Uninstall istio.\n+  */\n+  public static void uninstallIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"uninstall-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio uninstallation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Get the http ingress port of istio installation.\n+   * @returns ingress port for istio-ingressgateway\n+  */\n+  public static int getIstioHttpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getIngressPort = null;\n+    getIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"http2\\\")].nodePort}'\");\n+    logger.info(\"getIngressPort: kubectl command {0}\", new String(getIngressPort));\n+    try {\n+      result = exec(new String(getIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the secure https ingress port of istio installation.\n+   * @returns secure ingress https port for istio-ingressgateway\n+  */\n+  public static int getIstioSecureIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getSecureIngressPort = null;\n+    getSecureIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getSecureIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"https\\\")].nodePort}'\");\n+    logger.info(\"getSecureIngressPort: kubectl command {0}\", new String(getSecureIngressPort));\n+    try {\n+      result = exec(new String(getSecureIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getSecureIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getSecureIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the tcp ingress port of istio installation.\n+   * @returns tcp ingress port for istio-ingressgateway\n+   */\n+  public static int getIstioTcpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getTcpIngressPort = null;\n+    getTcpIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getTcpIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"tcp\\\")].nodePort}'\");\n+    logger.info(\"getTcpIngressPort: kubectl command {0}\", new String(getTcpIngressPort));\n+    try {\n+      result = exec(new String(getTcpIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getTcpIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getTcpIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Deploy the Http Istio Gateway and Istio Virtualservice.\n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @param clusterServiceName  name of WebLogic cluster\n+   * @param adminServiceName name of the admin service\n+   * @returns true if deployment is success otherwise false", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyNzAzOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443827038", "bodyText": "done.  Shouldn't t be results in a checksyle error.", "author": "anpanigr", "createdAt": "2020-06-22T21:07:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMDI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMDQyMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443710421", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Deploy the Http Istio Gateway and Istio Virtualservice.\n          \n          \n            \n               * Deploy the Http Istio Gateway and Istio virtual service.", "author": "sankarpn", "createdAt": "2020-06-22T17:16:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/IstioUtils.java", "diffHunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ISTIO_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Command.defaultCommandParams;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The istio utility class for tests.\n+ */\n+public class IstioUtils {\n+\n+  /**\n+   * Install istio.\n+  */\n+  public static void installIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"install-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio installation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Uninstall istio.\n+  */\n+  public static void uninstallIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"uninstall-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio uninstallation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Get the http ingress port of istio installation.\n+   * @returns ingress port for istio-ingressgateway\n+  */\n+  public static int getIstioHttpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getIngressPort = null;\n+    getIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"http2\\\")].nodePort}'\");\n+    logger.info(\"getIngressPort: kubectl command {0}\", new String(getIngressPort));\n+    try {\n+      result = exec(new String(getIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the secure https ingress port of istio installation.\n+   * @returns secure ingress https port for istio-ingressgateway\n+  */\n+  public static int getIstioSecureIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getSecureIngressPort = null;\n+    getSecureIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getSecureIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"https\\\")].nodePort}'\");\n+    logger.info(\"getSecureIngressPort: kubectl command {0}\", new String(getSecureIngressPort));\n+    try {\n+      result = exec(new String(getSecureIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getSecureIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getSecureIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the tcp ingress port of istio installation.\n+   * @returns tcp ingress port for istio-ingressgateway\n+   */\n+  public static int getIstioTcpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getTcpIngressPort = null;\n+    getTcpIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getTcpIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"tcp\\\")].nodePort}'\");\n+    logger.info(\"getTcpIngressPort: kubectl command {0}\", new String(getTcpIngressPort));\n+    try {\n+      result = exec(new String(getTcpIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getTcpIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getTcpIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Deploy the Http Istio Gateway and Istio Virtualservice.", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyNzc4MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443827780", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-22T21:09:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMDQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMDczOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443710739", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @returns true if deployment is success otherwise false\n          \n          \n            \n               * @return true if deployment is successful otherwise false", "author": "sankarpn", "createdAt": "2020-06-22T17:17:17Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/IstioUtils.java", "diffHunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ISTIO_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Command.defaultCommandParams;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The istio utility class for tests.\n+ */\n+public class IstioUtils {\n+\n+  /**\n+   * Install istio.\n+  */\n+  public static void installIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"install-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio installation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Uninstall istio.\n+  */\n+  public static void uninstallIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"uninstall-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio uninstallation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Get the http ingress port of istio installation.\n+   * @returns ingress port for istio-ingressgateway\n+  */\n+  public static int getIstioHttpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getIngressPort = null;\n+    getIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"http2\\\")].nodePort}'\");\n+    logger.info(\"getIngressPort: kubectl command {0}\", new String(getIngressPort));\n+    try {\n+      result = exec(new String(getIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the secure https ingress port of istio installation.\n+   * @returns secure ingress https port for istio-ingressgateway\n+  */\n+  public static int getIstioSecureIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getSecureIngressPort = null;\n+    getSecureIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getSecureIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"https\\\")].nodePort}'\");\n+    logger.info(\"getSecureIngressPort: kubectl command {0}\", new String(getSecureIngressPort));\n+    try {\n+      result = exec(new String(getSecureIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getSecureIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getSecureIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the tcp ingress port of istio installation.\n+   * @returns tcp ingress port for istio-ingressgateway\n+   */\n+  public static int getIstioTcpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getTcpIngressPort = null;\n+    getTcpIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getTcpIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"tcp\\\")].nodePort}'\");\n+    logger.info(\"getTcpIngressPort: kubectl command {0}\", new String(getTcpIngressPort));\n+    try {\n+      result = exec(new String(getTcpIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getTcpIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getTcpIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Deploy the Http Istio Gateway and Istio Virtualservice.\n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @param clusterServiceName  name of WebLogic cluster\n+   * @param adminServiceName name of the admin service\n+   * @returns true if deployment is success otherwise false\n+  */\n+  public static boolean deployHttpIstioGatewayAndVirtualservice(\n+       String domainNamespace, String domainUid, \n+       String adminServiceName, String clusterServiceName) throws IOException {\n+\n+    logger.info(\"Create a staging location for istio configuration objects\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");\n+    deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+    logger.info(\"Copy istio-http-template.service.yaml to staging location\");\n+    Path srcFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-http-template.service.yaml\");\n+    Path targetFile = Paths.get(fileTemp.toString(), \"istio-http-service.yaml\");\n+    Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    String out = targetFile.toString();\n+    replaceStringInFile(out, \"NAMESPACE\", domainNamespace); \n+    replaceStringInFile(out, \"DUID\", domainUid); \n+    replaceStringInFile(out, \"ADMIN_SERVICE\", adminServiceName); \n+    replaceStringInFile(out, \"CLUSTER_SERVICE\", clusterServiceName); \n+    ExecResult result = null;\n+    StringBuffer deployIstioGateway = null;\n+    deployIstioGateway = new StringBuffer(\"kubectl apply -f \");\n+    deployIstioGateway.append(targetFile);\n+    logger.info(\"deployIstioGateway: kubectl command {0}\", new String(deployIstioGateway));\n+    try {\n+      result = exec(new String(deployIstioGateway), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in deployIstioGateway() {0}\", ex);\n+      return false;\n+    }\n+    logger.info(\"deployIstioHttpGateway: kubectl returned {0}\", result.toString());\n+    if (result.stdout().contains(\"istio-http-gateway created\")) {\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+  \n+  /**\n+   * Deploy the tcp Istio Gateway and Istio Virtualservice.\n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @param adminServiceName name of the admin service\n+   * @returns true if deployment is success otherwise false", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMDg0Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443710842", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Deploy the tcp Istio Gateway and Istio Virtualservice.\n          \n          \n            \n               * Deploy the tcp Istio Gateway and Istio virtual service.", "author": "sankarpn", "createdAt": "2020-06-22T17:17:27Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/IstioUtils.java", "diffHunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ISTIO_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Command.defaultCommandParams;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The istio utility class for tests.\n+ */\n+public class IstioUtils {\n+\n+  /**\n+   * Install istio.\n+  */\n+  public static void installIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"install-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio installation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Uninstall istio.\n+  */\n+  public static void uninstallIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"uninstall-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio uninstallation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Get the http ingress port of istio installation.\n+   * @returns ingress port for istio-ingressgateway\n+  */\n+  public static int getIstioHttpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getIngressPort = null;\n+    getIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"http2\\\")].nodePort}'\");\n+    logger.info(\"getIngressPort: kubectl command {0}\", new String(getIngressPort));\n+    try {\n+      result = exec(new String(getIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the secure https ingress port of istio installation.\n+   * @returns secure ingress https port for istio-ingressgateway\n+  */\n+  public static int getIstioSecureIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getSecureIngressPort = null;\n+    getSecureIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getSecureIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"https\\\")].nodePort}'\");\n+    logger.info(\"getSecureIngressPort: kubectl command {0}\", new String(getSecureIngressPort));\n+    try {\n+      result = exec(new String(getSecureIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getSecureIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getSecureIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the tcp ingress port of istio installation.\n+   * @returns tcp ingress port for istio-ingressgateway\n+   */\n+  public static int getIstioTcpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getTcpIngressPort = null;\n+    getTcpIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getTcpIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"tcp\\\")].nodePort}'\");\n+    logger.info(\"getTcpIngressPort: kubectl command {0}\", new String(getTcpIngressPort));\n+    try {\n+      result = exec(new String(getTcpIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getTcpIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getTcpIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Deploy the Http Istio Gateway and Istio Virtualservice.\n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @param clusterServiceName  name of WebLogic cluster\n+   * @param adminServiceName name of the admin service\n+   * @returns true if deployment is success otherwise false\n+  */\n+  public static boolean deployHttpIstioGatewayAndVirtualservice(\n+       String domainNamespace, String domainUid, \n+       String adminServiceName, String clusterServiceName) throws IOException {\n+\n+    logger.info(\"Create a staging location for istio configuration objects\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");\n+    deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+    logger.info(\"Copy istio-http-template.service.yaml to staging location\");\n+    Path srcFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-http-template.service.yaml\");\n+    Path targetFile = Paths.get(fileTemp.toString(), \"istio-http-service.yaml\");\n+    Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    String out = targetFile.toString();\n+    replaceStringInFile(out, \"NAMESPACE\", domainNamespace); \n+    replaceStringInFile(out, \"DUID\", domainUid); \n+    replaceStringInFile(out, \"ADMIN_SERVICE\", adminServiceName); \n+    replaceStringInFile(out, \"CLUSTER_SERVICE\", clusterServiceName); \n+    ExecResult result = null;\n+    StringBuffer deployIstioGateway = null;\n+    deployIstioGateway = new StringBuffer(\"kubectl apply -f \");\n+    deployIstioGateway.append(targetFile);\n+    logger.info(\"deployIstioGateway: kubectl command {0}\", new String(deployIstioGateway));\n+    try {\n+      result = exec(new String(deployIstioGateway), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in deployIstioGateway() {0}\", ex);\n+      return false;\n+    }\n+    logger.info(\"deployIstioHttpGateway: kubectl returned {0}\", result.toString());\n+    if (result.stdout().contains(\"istio-http-gateway created\")) {\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+  \n+  /**\n+   * Deploy the tcp Istio Gateway and Istio Virtualservice.", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyNzg5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443827896", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-22T21:09:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMDg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMTM5Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443711397", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");\n          \n          \n            \n                Path tempDir = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");", "author": "sankarpn", "createdAt": "2020-06-22T17:18:28Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/IstioUtils.java", "diffHunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ISTIO_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Command.defaultCommandParams;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The istio utility class for tests.\n+ */\n+public class IstioUtils {\n+\n+  /**\n+   * Install istio.\n+  */\n+  public static void installIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"install-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio installation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Uninstall istio.\n+  */\n+  public static void uninstallIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"uninstall-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio uninstallation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Get the http ingress port of istio installation.\n+   * @returns ingress port for istio-ingressgateway\n+  */\n+  public static int getIstioHttpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getIngressPort = null;\n+    getIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"http2\\\")].nodePort}'\");\n+    logger.info(\"getIngressPort: kubectl command {0}\", new String(getIngressPort));\n+    try {\n+      result = exec(new String(getIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the secure https ingress port of istio installation.\n+   * @returns secure ingress https port for istio-ingressgateway\n+  */\n+  public static int getIstioSecureIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getSecureIngressPort = null;\n+    getSecureIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getSecureIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"https\\\")].nodePort}'\");\n+    logger.info(\"getSecureIngressPort: kubectl command {0}\", new String(getSecureIngressPort));\n+    try {\n+      result = exec(new String(getSecureIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getSecureIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getSecureIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the tcp ingress port of istio installation.\n+   * @returns tcp ingress port for istio-ingressgateway\n+   */\n+  public static int getIstioTcpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getTcpIngressPort = null;\n+    getTcpIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getTcpIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"tcp\\\")].nodePort}'\");\n+    logger.info(\"getTcpIngressPort: kubectl command {0}\", new String(getTcpIngressPort));\n+    try {\n+      result = exec(new String(getTcpIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getTcpIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getTcpIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Deploy the Http Istio Gateway and Istio Virtualservice.\n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @param clusterServiceName  name of WebLogic cluster\n+   * @param adminServiceName name of the admin service\n+   * @returns true if deployment is success otherwise false\n+  */\n+  public static boolean deployHttpIstioGatewayAndVirtualservice(\n+       String domainNamespace, String domainUid, \n+       String adminServiceName, String clusterServiceName) throws IOException {\n+\n+    logger.info(\"Create a staging location for istio configuration objects\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");\n+    deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+    logger.info(\"Copy istio-http-template.service.yaml to staging location\");\n+    Path srcFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-http-template.service.yaml\");\n+    Path targetFile = Paths.get(fileTemp.toString(), \"istio-http-service.yaml\");\n+    Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    String out = targetFile.toString();\n+    replaceStringInFile(out, \"NAMESPACE\", domainNamespace); \n+    replaceStringInFile(out, \"DUID\", domainUid); \n+    replaceStringInFile(out, \"ADMIN_SERVICE\", adminServiceName); \n+    replaceStringInFile(out, \"CLUSTER_SERVICE\", clusterServiceName); \n+    ExecResult result = null;\n+    StringBuffer deployIstioGateway = null;\n+    deployIstioGateway = new StringBuffer(\"kubectl apply -f \");\n+    deployIstioGateway.append(targetFile);\n+    logger.info(\"deployIstioGateway: kubectl command {0}\", new String(deployIstioGateway));\n+    try {\n+      result = exec(new String(deployIstioGateway), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in deployIstioGateway() {0}\", ex);\n+      return false;\n+    }\n+    logger.info(\"deployIstioHttpGateway: kubectl returned {0}\", result.toString());\n+    if (result.stdout().contains(\"istio-http-gateway created\")) {\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+  \n+  /**\n+   * Deploy the tcp Istio Gateway and Istio Virtualservice.\n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @param adminServiceName name of the admin service\n+   * @returns true if deployment is success otherwise false\n+  */\n+  public static boolean deployTcpIstioGatewayAndVirtualservice(\n+        String domainNamespace, String domainUid, String adminServiceName) throws IOException  {\n+\n+    logger.info(\"Create a staging location for istio configuration objects\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyOTMyMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443829323", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-22T21:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMTM5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMTcyMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443711720", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @returns true if deployment is success otherwise false\n          \n          \n            \n               * @return true if deployment is success otherwise false", "author": "sankarpn", "createdAt": "2020-06-22T17:19:05Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/IstioUtils.java", "diffHunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ISTIO_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Command.defaultCommandParams;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The istio utility class for tests.\n+ */\n+public class IstioUtils {\n+\n+  /**\n+   * Install istio.\n+  */\n+  public static void installIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"install-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio installation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Uninstall istio.\n+  */\n+  public static void uninstallIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"uninstall-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio uninstallation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Get the http ingress port of istio installation.\n+   * @returns ingress port for istio-ingressgateway\n+  */\n+  public static int getIstioHttpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getIngressPort = null;\n+    getIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"http2\\\")].nodePort}'\");\n+    logger.info(\"getIngressPort: kubectl command {0}\", new String(getIngressPort));\n+    try {\n+      result = exec(new String(getIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the secure https ingress port of istio installation.\n+   * @returns secure ingress https port for istio-ingressgateway\n+  */\n+  public static int getIstioSecureIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getSecureIngressPort = null;\n+    getSecureIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getSecureIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"https\\\")].nodePort}'\");\n+    logger.info(\"getSecureIngressPort: kubectl command {0}\", new String(getSecureIngressPort));\n+    try {\n+      result = exec(new String(getSecureIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getSecureIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getSecureIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the tcp ingress port of istio installation.\n+   * @returns tcp ingress port for istio-ingressgateway\n+   */\n+  public static int getIstioTcpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getTcpIngressPort = null;\n+    getTcpIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getTcpIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"tcp\\\")].nodePort}'\");\n+    logger.info(\"getTcpIngressPort: kubectl command {0}\", new String(getTcpIngressPort));\n+    try {\n+      result = exec(new String(getTcpIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getTcpIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getTcpIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Deploy the Http Istio Gateway and Istio Virtualservice.\n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @param clusterServiceName  name of WebLogic cluster\n+   * @param adminServiceName name of the admin service\n+   * @returns true if deployment is success otherwise false\n+  */\n+  public static boolean deployHttpIstioGatewayAndVirtualservice(\n+       String domainNamespace, String domainUid, \n+       String adminServiceName, String clusterServiceName) throws IOException {\n+\n+    logger.info(\"Create a staging location for istio configuration objects\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");\n+    deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+    logger.info(\"Copy istio-http-template.service.yaml to staging location\");\n+    Path srcFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-http-template.service.yaml\");\n+    Path targetFile = Paths.get(fileTemp.toString(), \"istio-http-service.yaml\");\n+    Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    String out = targetFile.toString();\n+    replaceStringInFile(out, \"NAMESPACE\", domainNamespace); \n+    replaceStringInFile(out, \"DUID\", domainUid); \n+    replaceStringInFile(out, \"ADMIN_SERVICE\", adminServiceName); \n+    replaceStringInFile(out, \"CLUSTER_SERVICE\", clusterServiceName); \n+    ExecResult result = null;\n+    StringBuffer deployIstioGateway = null;\n+    deployIstioGateway = new StringBuffer(\"kubectl apply -f \");\n+    deployIstioGateway.append(targetFile);\n+    logger.info(\"deployIstioGateway: kubectl command {0}\", new String(deployIstioGateway));\n+    try {\n+      result = exec(new String(deployIstioGateway), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in deployIstioGateway() {0}\", ex);\n+      return false;\n+    }\n+    logger.info(\"deployIstioHttpGateway: kubectl returned {0}\", result.toString());\n+    if (result.stdout().contains(\"istio-http-gateway created\")) {\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+  \n+  /**\n+   * Deploy the tcp Istio Gateway and Istio Virtualservice.\n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @param adminServiceName name of the admin service\n+   * @returns true if deployment is success otherwise false\n+  */\n+  public static boolean deployTcpIstioGatewayAndVirtualservice(\n+        String domainNamespace, String domainUid, String adminServiceName) throws IOException  {\n+\n+    logger.info(\"Create a staging location for istio configuration objects\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");\n+    deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+    logger.info(\"Copy istio-tcp-template.service.yaml to staging location\");\n+    Path srcFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-tcp-template.service.yaml\");\n+    Path targetFile = Paths.get(fileTemp.toString(), \"istio-tcp-service.yaml\");\n+    Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    String out = targetFile.toString();\n+    String adminService = adminServiceName + \".svc.cluster.local\";\n+    replaceStringInFile(out, \"NAMESPACE\", domainNamespace); \n+    replaceStringInFile(out, \"DUID\", domainUid); \n+    replaceStringInFile(out, \"ADMIN_SERVICE\", adminServiceName); \n+\n+    ExecResult result = null;\n+    StringBuffer deployIstioGateway = null;\n+    deployIstioGateway = new StringBuffer(\"kubectl apply -f \");\n+    deployIstioGateway.append(targetFile.toString());\n+    logger.info(\"deployIstioGateway: kubectl command {0}\", new String(deployIstioGateway));\n+    try {\n+      result = exec(new String(deployIstioGateway), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in deployIstioGateway() {0}\", ex);\n+      return false;\n+    }\n+    logger.info(\"deployIstioTcpGateway: kubectl returned {0}\", result.toString());\n+    if (result.stdout().contains(\"istio-tcp-gateway created\")) {\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Deploy the Istio DestinationRule. \n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @returns true if deployment is success otherwise false", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyNzk0NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443827944", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-22T21:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMTcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMjA3Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443712073", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");\n          \n          \n            \n                Path tempDir = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");", "author": "sankarpn", "createdAt": "2020-06-22T17:19:47Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/IstioUtils.java", "diffHunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ISTIO_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Command.defaultCommandParams;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The istio utility class for tests.\n+ */\n+public class IstioUtils {\n+\n+  /**\n+   * Install istio.\n+  */\n+  public static void installIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"install-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio installation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Uninstall istio.\n+  */\n+  public static void uninstallIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"uninstall-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio uninstallation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Get the http ingress port of istio installation.\n+   * @returns ingress port for istio-ingressgateway\n+  */\n+  public static int getIstioHttpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getIngressPort = null;\n+    getIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"http2\\\")].nodePort}'\");\n+    logger.info(\"getIngressPort: kubectl command {0}\", new String(getIngressPort));\n+    try {\n+      result = exec(new String(getIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the secure https ingress port of istio installation.\n+   * @returns secure ingress https port for istio-ingressgateway\n+  */\n+  public static int getIstioSecureIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getSecureIngressPort = null;\n+    getSecureIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getSecureIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"https\\\")].nodePort}'\");\n+    logger.info(\"getSecureIngressPort: kubectl command {0}\", new String(getSecureIngressPort));\n+    try {\n+      result = exec(new String(getSecureIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getSecureIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getSecureIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the tcp ingress port of istio installation.\n+   * @returns tcp ingress port for istio-ingressgateway\n+   */\n+  public static int getIstioTcpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getTcpIngressPort = null;\n+    getTcpIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getTcpIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"tcp\\\")].nodePort}'\");\n+    logger.info(\"getTcpIngressPort: kubectl command {0}\", new String(getTcpIngressPort));\n+    try {\n+      result = exec(new String(getTcpIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getTcpIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getTcpIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Deploy the Http Istio Gateway and Istio Virtualservice.\n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @param clusterServiceName  name of WebLogic cluster\n+   * @param adminServiceName name of the admin service\n+   * @returns true if deployment is success otherwise false\n+  */\n+  public static boolean deployHttpIstioGatewayAndVirtualservice(\n+       String domainNamespace, String domainUid, \n+       String adminServiceName, String clusterServiceName) throws IOException {\n+\n+    logger.info(\"Create a staging location for istio configuration objects\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");\n+    deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+    logger.info(\"Copy istio-http-template.service.yaml to staging location\");\n+    Path srcFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-http-template.service.yaml\");\n+    Path targetFile = Paths.get(fileTemp.toString(), \"istio-http-service.yaml\");\n+    Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    String out = targetFile.toString();\n+    replaceStringInFile(out, \"NAMESPACE\", domainNamespace); \n+    replaceStringInFile(out, \"DUID\", domainUid); \n+    replaceStringInFile(out, \"ADMIN_SERVICE\", adminServiceName); \n+    replaceStringInFile(out, \"CLUSTER_SERVICE\", clusterServiceName); \n+    ExecResult result = null;\n+    StringBuffer deployIstioGateway = null;\n+    deployIstioGateway = new StringBuffer(\"kubectl apply -f \");\n+    deployIstioGateway.append(targetFile);\n+    logger.info(\"deployIstioGateway: kubectl command {0}\", new String(deployIstioGateway));\n+    try {\n+      result = exec(new String(deployIstioGateway), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in deployIstioGateway() {0}\", ex);\n+      return false;\n+    }\n+    logger.info(\"deployIstioHttpGateway: kubectl returned {0}\", result.toString());\n+    if (result.stdout().contains(\"istio-http-gateway created\")) {\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+  \n+  /**\n+   * Deploy the tcp Istio Gateway and Istio Virtualservice.\n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @param adminServiceName name of the admin service\n+   * @returns true if deployment is success otherwise false\n+  */\n+  public static boolean deployTcpIstioGatewayAndVirtualservice(\n+        String domainNamespace, String domainUid, String adminServiceName) throws IOException  {\n+\n+    logger.info(\"Create a staging location for istio configuration objects\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");\n+    deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+    logger.info(\"Copy istio-tcp-template.service.yaml to staging location\");\n+    Path srcFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-tcp-template.service.yaml\");\n+    Path targetFile = Paths.get(fileTemp.toString(), \"istio-tcp-service.yaml\");\n+    Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    String out = targetFile.toString();\n+    String adminService = adminServiceName + \".svc.cluster.local\";\n+    replaceStringInFile(out, \"NAMESPACE\", domainNamespace); \n+    replaceStringInFile(out, \"DUID\", domainUid); \n+    replaceStringInFile(out, \"ADMIN_SERVICE\", adminServiceName); \n+\n+    ExecResult result = null;\n+    StringBuffer deployIstioGateway = null;\n+    deployIstioGateway = new StringBuffer(\"kubectl apply -f \");\n+    deployIstioGateway.append(targetFile.toString());\n+    logger.info(\"deployIstioGateway: kubectl command {0}\", new String(deployIstioGateway));\n+    try {\n+      result = exec(new String(deployIstioGateway), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in deployIstioGateway() {0}\", ex);\n+      return false;\n+    }\n+    logger.info(\"deployIstioTcpGateway: kubectl returned {0}\", result.toString());\n+    if (result.stdout().contains(\"istio-tcp-gateway created\")) {\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Deploy the Istio DestinationRule. \n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @returns true if deployment is success otherwise false\n+  */\n+  public static boolean deployIstioDestinationRule(\n+        String domainNamespace, String domainUid) throws IOException  {\n+\n+    logger.info(\"Create a staging location for istio configuration objects\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMzA5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443713093", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new Integer(result.stdout());\n          \n          \n            \n                  return Integer.ValueOf(result.stdout());", "author": "sankarpn", "createdAt": "2020-06-22T17:21:39Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/IstioUtils.java", "diffHunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ISTIO_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Command.defaultCommandParams;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The istio utility class for tests.\n+ */\n+public class IstioUtils {\n+\n+  /**\n+   * Install istio.\n+  */\n+  public static void installIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"install-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio installation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Uninstall istio.\n+  */\n+  public static void uninstallIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"uninstall-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio uninstallation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Get the http ingress port of istio installation.\n+   * @returns ingress port for istio-ingressgateway\n+  */\n+  public static int getIstioHttpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getIngressPort = null;\n+    getIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"http2\\\")].nodePort}'\");\n+    logger.info(\"getIngressPort: kubectl command {0}\", new String(getIngressPort));\n+    try {\n+      result = exec(new String(getIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the secure https ingress port of istio installation.\n+   * @returns secure ingress https port for istio-ingressgateway\n+  */\n+  public static int getIstioSecureIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getSecureIngressPort = null;\n+    getSecureIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getSecureIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"https\\\")].nodePort}'\");\n+    logger.info(\"getSecureIngressPort: kubectl command {0}\", new String(getSecureIngressPort));\n+    try {\n+      result = exec(new String(getSecureIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getSecureIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getSecureIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMDg5MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443830891", "bodyText": "ERROR]   symbol:   method ValueOf(java.lang.String)\n[ERROR]   location: class java.lang.Integer", "author": "anpanigr", "createdAt": "2020-06-22T21:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMzA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMzI0NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443713245", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new Integer(result.stdout());\n          \n          \n            \n                  return Integer.ValueOf(result.stdout());", "author": "sankarpn", "createdAt": "2020-06-22T17:21:53Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/IstioUtils.java", "diffHunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ISTIO_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Command.defaultCommandParams;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The istio utility class for tests.\n+ */\n+public class IstioUtils {\n+\n+  /**\n+   * Install istio.\n+  */\n+  public static void installIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"install-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio installation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Uninstall istio.\n+  */\n+  public static void uninstallIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"uninstall-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio uninstallation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Get the http ingress port of istio installation.\n+   * @returns ingress port for istio-ingressgateway\n+  */\n+  public static int getIstioHttpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getIngressPort = null;\n+    getIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"http2\\\")].nodePort}'\");\n+    logger.info(\"getIngressPort: kubectl command {0}\", new String(getIngressPort));\n+    try {\n+      result = exec(new String(getIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMzQyMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443713421", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new Integer(result.stdout());\n          \n          \n            \n                  return Integer.ValueOf(result.stdout());", "author": "sankarpn", "createdAt": "2020-06-22T17:22:09Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/IstioUtils.java", "diffHunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ISTIO_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Command.defaultCommandParams;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The istio utility class for tests.\n+ */\n+public class IstioUtils {\n+\n+  /**\n+   * Install istio.\n+  */\n+  public static void installIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"install-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio installation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Uninstall istio.\n+  */\n+  public static void uninstallIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"uninstall-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio uninstallation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Get the http ingress port of istio installation.\n+   * @returns ingress port for istio-ingressgateway\n+  */\n+  public static int getIstioHttpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getIngressPort = null;\n+    getIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"http2\\\")].nodePort}'\");\n+    logger.info(\"getIngressPort: kubectl command {0}\", new String(getIngressPort));\n+    try {\n+      result = exec(new String(getIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the secure https ingress port of istio installation.\n+   * @returns secure ingress https port for istio-ingressgateway\n+  */\n+  public static int getIstioSecureIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getSecureIngressPort = null;\n+    getSecureIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getSecureIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"https\\\")].nodePort}'\");\n+    logger.info(\"getSecureIngressPort: kubectl command {0}\", new String(getSecureIngressPort));\n+    try {\n+      result = exec(new String(getSecureIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getSecureIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getSecureIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the tcp ingress port of istio installation.\n+   * @returns tcp ingress port for istio-ingressgateway\n+   */\n+  public static int getIstioTcpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getTcpIngressPort = null;\n+    getTcpIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getTcpIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"tcp\\\")].nodePort}'\");\n+    logger.info(\"getTcpIngressPort: kubectl command {0}\", new String(getTcpIngressPort));\n+    try {\n+      result = exec(new String(getTcpIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getTcpIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getTcpIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxNDE5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443714193", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (result.stdout().contains(\"istio-http-gateway created\")) {\n          \n          \n            \n                return result.stdout().contains(\"istio-http-gateway created\");", "author": "sankarpn", "createdAt": "2020-06-22T17:23:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/IstioUtils.java", "diffHunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ISTIO_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Command.defaultCommandParams;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The istio utility class for tests.\n+ */\n+public class IstioUtils {\n+\n+  /**\n+   * Install istio.\n+  */\n+  public static void installIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"install-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio installation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Uninstall istio.\n+  */\n+  public static void uninstallIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"uninstall-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio uninstallation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Get the http ingress port of istio installation.\n+   * @returns ingress port for istio-ingressgateway\n+  */\n+  public static int getIstioHttpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getIngressPort = null;\n+    getIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"http2\\\")].nodePort}'\");\n+    logger.info(\"getIngressPort: kubectl command {0}\", new String(getIngressPort));\n+    try {\n+      result = exec(new String(getIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the secure https ingress port of istio installation.\n+   * @returns secure ingress https port for istio-ingressgateway\n+  */\n+  public static int getIstioSecureIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getSecureIngressPort = null;\n+    getSecureIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getSecureIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"https\\\")].nodePort}'\");\n+    logger.info(\"getSecureIngressPort: kubectl command {0}\", new String(getSecureIngressPort));\n+    try {\n+      result = exec(new String(getSecureIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getSecureIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getSecureIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the tcp ingress port of istio installation.\n+   * @returns tcp ingress port for istio-ingressgateway\n+   */\n+  public static int getIstioTcpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getTcpIngressPort = null;\n+    getTcpIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getTcpIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"tcp\\\")].nodePort}'\");\n+    logger.info(\"getTcpIngressPort: kubectl command {0}\", new String(getTcpIngressPort));\n+    try {\n+      result = exec(new String(getTcpIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getTcpIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getTcpIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Deploy the Http Istio Gateway and Istio Virtualservice.\n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @param clusterServiceName  name of WebLogic cluster\n+   * @param adminServiceName name of the admin service\n+   * @returns true if deployment is success otherwise false\n+  */\n+  public static boolean deployHttpIstioGatewayAndVirtualservice(\n+       String domainNamespace, String domainUid, \n+       String adminServiceName, String clusterServiceName) throws IOException {\n+\n+    logger.info(\"Create a staging location for istio configuration objects\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");\n+    deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+    logger.info(\"Copy istio-http-template.service.yaml to staging location\");\n+    Path srcFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-http-template.service.yaml\");\n+    Path targetFile = Paths.get(fileTemp.toString(), \"istio-http-service.yaml\");\n+    Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    String out = targetFile.toString();\n+    replaceStringInFile(out, \"NAMESPACE\", domainNamespace); \n+    replaceStringInFile(out, \"DUID\", domainUid); \n+    replaceStringInFile(out, \"ADMIN_SERVICE\", adminServiceName); \n+    replaceStringInFile(out, \"CLUSTER_SERVICE\", clusterServiceName); \n+    ExecResult result = null;\n+    StringBuffer deployIstioGateway = null;\n+    deployIstioGateway = new StringBuffer(\"kubectl apply -f \");\n+    deployIstioGateway.append(targetFile);\n+    logger.info(\"deployIstioGateway: kubectl command {0}\", new String(deployIstioGateway));\n+    try {\n+      result = exec(new String(deployIstioGateway), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in deployIstioGateway() {0}\", ex);\n+      return false;\n+    }\n+    logger.info(\"deployIstioHttpGateway: kubectl returned {0}\", result.toString());\n+    if (result.stdout().contains(\"istio-http-gateway created\")) {", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzNzcwOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443837708", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-22T21:30:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxNDE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxNDQzMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443714432", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (result.stdout().contains(\"istio-tcp-gateway created\")) {\n          \n          \n            \n                return result.stdout().contains(\"istio-tcp-gateway created\");", "author": "sankarpn", "createdAt": "2020-06-22T17:24:05Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/IstioUtils.java", "diffHunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ISTIO_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Command.defaultCommandParams;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The istio utility class for tests.\n+ */\n+public class IstioUtils {\n+\n+  /**\n+   * Install istio.\n+  */\n+  public static void installIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"install-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio installation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Uninstall istio.\n+  */\n+  public static void uninstallIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"uninstall-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio uninstallation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Get the http ingress port of istio installation.\n+   * @returns ingress port for istio-ingressgateway\n+  */\n+  public static int getIstioHttpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getIngressPort = null;\n+    getIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"http2\\\")].nodePort}'\");\n+    logger.info(\"getIngressPort: kubectl command {0}\", new String(getIngressPort));\n+    try {\n+      result = exec(new String(getIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the secure https ingress port of istio installation.\n+   * @returns secure ingress https port for istio-ingressgateway\n+  */\n+  public static int getIstioSecureIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getSecureIngressPort = null;\n+    getSecureIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getSecureIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"https\\\")].nodePort}'\");\n+    logger.info(\"getSecureIngressPort: kubectl command {0}\", new String(getSecureIngressPort));\n+    try {\n+      result = exec(new String(getSecureIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getSecureIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getSecureIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the tcp ingress port of istio installation.\n+   * @returns tcp ingress port for istio-ingressgateway\n+   */\n+  public static int getIstioTcpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getTcpIngressPort = null;\n+    getTcpIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getTcpIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"tcp\\\")].nodePort}'\");\n+    logger.info(\"getTcpIngressPort: kubectl command {0}\", new String(getTcpIngressPort));\n+    try {\n+      result = exec(new String(getTcpIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getTcpIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getTcpIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Deploy the Http Istio Gateway and Istio Virtualservice.\n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @param clusterServiceName  name of WebLogic cluster\n+   * @param adminServiceName name of the admin service\n+   * @returns true if deployment is success otherwise false\n+  */\n+  public static boolean deployHttpIstioGatewayAndVirtualservice(\n+       String domainNamespace, String domainUid, \n+       String adminServiceName, String clusterServiceName) throws IOException {\n+\n+    logger.info(\"Create a staging location for istio configuration objects\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");\n+    deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+    logger.info(\"Copy istio-http-template.service.yaml to staging location\");\n+    Path srcFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-http-template.service.yaml\");\n+    Path targetFile = Paths.get(fileTemp.toString(), \"istio-http-service.yaml\");\n+    Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    String out = targetFile.toString();\n+    replaceStringInFile(out, \"NAMESPACE\", domainNamespace); \n+    replaceStringInFile(out, \"DUID\", domainUid); \n+    replaceStringInFile(out, \"ADMIN_SERVICE\", adminServiceName); \n+    replaceStringInFile(out, \"CLUSTER_SERVICE\", clusterServiceName); \n+    ExecResult result = null;\n+    StringBuffer deployIstioGateway = null;\n+    deployIstioGateway = new StringBuffer(\"kubectl apply -f \");\n+    deployIstioGateway.append(targetFile);\n+    logger.info(\"deployIstioGateway: kubectl command {0}\", new String(deployIstioGateway));\n+    try {\n+      result = exec(new String(deployIstioGateway), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in deployIstioGateway() {0}\", ex);\n+      return false;\n+    }\n+    logger.info(\"deployIstioHttpGateway: kubectl returned {0}\", result.toString());\n+    if (result.stdout().contains(\"istio-http-gateway created\")) {\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+  \n+  /**\n+   * Deploy the tcp Istio Gateway and Istio Virtualservice.\n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @param adminServiceName name of the admin service\n+   * @returns true if deployment is success otherwise false\n+  */\n+  public static boolean deployTcpIstioGatewayAndVirtualservice(\n+        String domainNamespace, String domainUid, String adminServiceName) throws IOException  {\n+\n+    logger.info(\"Create a staging location for istio configuration objects\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");\n+    deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+    logger.info(\"Copy istio-tcp-template.service.yaml to staging location\");\n+    Path srcFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-tcp-template.service.yaml\");\n+    Path targetFile = Paths.get(fileTemp.toString(), \"istio-tcp-service.yaml\");\n+    Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    String out = targetFile.toString();\n+    String adminService = adminServiceName + \".svc.cluster.local\";\n+    replaceStringInFile(out, \"NAMESPACE\", domainNamespace); \n+    replaceStringInFile(out, \"DUID\", domainUid); \n+    replaceStringInFile(out, \"ADMIN_SERVICE\", adminServiceName); \n+\n+    ExecResult result = null;\n+    StringBuffer deployIstioGateway = null;\n+    deployIstioGateway = new StringBuffer(\"kubectl apply -f \");\n+    deployIstioGateway.append(targetFile.toString());\n+    logger.info(\"deployIstioGateway: kubectl command {0}\", new String(deployIstioGateway));\n+    try {\n+      result = exec(new String(deployIstioGateway), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in deployIstioGateway() {0}\", ex);\n+      return false;\n+    }\n+    logger.info(\"deployIstioTcpGateway: kubectl returned {0}\", result.toString());\n+    if (result.stdout().contains(\"istio-tcp-gateway created\")) {", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzNzc3Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443837776", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-22T21:30:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxNDQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxNTU5OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443715598", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (result.stdout().contains(\"destination-rule created\")) {\n          \n          \n            \n                return result.stdout().contains(\"destination-rule created\");", "author": "sankarpn", "createdAt": "2020-06-22T17:26:11Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/utils/IstioUtils.java", "diffHunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import oracle.weblogic.kubernetes.actions.impl.primitive.Command;\n+\n+import static oracle.weblogic.kubernetes.TestConstants.ISTIO_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.RESULTS_ROOT;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.RESOURCE_DIR;\n+import static oracle.weblogic.kubernetes.actions.ActionConstants.WORK_DIR;\n+import static oracle.weblogic.kubernetes.actions.impl.primitive.Command.defaultCommandParams;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.replaceStringInFile;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static org.apache.commons.io.FileUtils.deleteDirectory;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The istio utility class for tests.\n+ */\n+public class IstioUtils {\n+\n+  /**\n+   * Install istio.\n+  */\n+  public static void installIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"install-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio installation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Uninstall istio.\n+  */\n+  public static void uninstallIstio() {\n+\n+    Path istioInstallPath = \n+         Paths.get(RESOURCE_DIR, \"bash-scripts\", \"uninstall-istio.sh\");\n+    String installScript = istioInstallPath.toString();\n+    String command =\n+        String.format(\"%s %s %s\", installScript, ISTIO_VERSION, WORK_DIR);\n+    logger.info(\"Istio uninstallation command {0}\", command);\n+    assertTrue(() -> Command.withParams(\n+        defaultCommandParams()\n+            .command(command)\n+            .redirect(false))\n+        .execute());\n+  }\n+\n+  /**\n+   * Get the http ingress port of istio installation.\n+   * @returns ingress port for istio-ingressgateway\n+  */\n+  public static int getIstioHttpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getIngressPort = null;\n+    getIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"http2\\\")].nodePort}'\");\n+    logger.info(\"getIngressPort: kubectl command {0}\", new String(getIngressPort));\n+    try {\n+      result = exec(new String(getIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the secure https ingress port of istio installation.\n+   * @returns secure ingress https port for istio-ingressgateway\n+  */\n+  public static int getIstioSecureIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getSecureIngressPort = null;\n+    getSecureIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getSecureIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"https\\\")].nodePort}'\");\n+    logger.info(\"getSecureIngressPort: kubectl command {0}\", new String(getSecureIngressPort));\n+    try {\n+      result = exec(new String(getSecureIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getSecureIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getSecureIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Get the tcp ingress port of istio installation.\n+   * @returns tcp ingress port for istio-ingressgateway\n+   */\n+  public static int getIstioTcpIngressPort() {\n+    ExecResult result = null;\n+    StringBuffer getTcpIngressPort = null;\n+    getTcpIngressPort = new StringBuffer(\"kubectl -n istio-system get service istio-ingressgateway \");\n+    getTcpIngressPort.append(\"-o jsonpath='{.spec.ports[?(@.name==\\\"tcp\\\")].nodePort}'\");\n+    logger.info(\"getTcpIngressPort: kubectl command {0}\", new String(getTcpIngressPort));\n+    try {\n+      result = exec(new String(getTcpIngressPort), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in getTcpIngressPort() {0}\", ex);\n+      return 0;\n+    }\n+    logger.info(\"getTcpIngressPort: kubectl returned {0}\", result.toString());\n+    if (result.stdout() == null) {\n+      return 0;\n+    } else {\n+      return new Integer(result.stdout());\n+    }\n+  }\n+\n+  /**\n+   * Deploy the Http Istio Gateway and Istio Virtualservice.\n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @param clusterServiceName  name of WebLogic cluster\n+   * @param adminServiceName name of the admin service\n+   * @returns true if deployment is success otherwise false\n+  */\n+  public static boolean deployHttpIstioGatewayAndVirtualservice(\n+       String domainNamespace, String domainUid, \n+       String adminServiceName, String clusterServiceName) throws IOException {\n+\n+    logger.info(\"Create a staging location for istio configuration objects\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");\n+    deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+    logger.info(\"Copy istio-http-template.service.yaml to staging location\");\n+    Path srcFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-http-template.service.yaml\");\n+    Path targetFile = Paths.get(fileTemp.toString(), \"istio-http-service.yaml\");\n+    Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    String out = targetFile.toString();\n+    replaceStringInFile(out, \"NAMESPACE\", domainNamespace); \n+    replaceStringInFile(out, \"DUID\", domainUid); \n+    replaceStringInFile(out, \"ADMIN_SERVICE\", adminServiceName); \n+    replaceStringInFile(out, \"CLUSTER_SERVICE\", clusterServiceName); \n+    ExecResult result = null;\n+    StringBuffer deployIstioGateway = null;\n+    deployIstioGateway = new StringBuffer(\"kubectl apply -f \");\n+    deployIstioGateway.append(targetFile);\n+    logger.info(\"deployIstioGateway: kubectl command {0}\", new String(deployIstioGateway));\n+    try {\n+      result = exec(new String(deployIstioGateway), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in deployIstioGateway() {0}\", ex);\n+      return false;\n+    }\n+    logger.info(\"deployIstioHttpGateway: kubectl returned {0}\", result.toString());\n+    if (result.stdout().contains(\"istio-http-gateway created\")) {\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+  \n+  /**\n+   * Deploy the tcp Istio Gateway and Istio Virtualservice.\n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @param adminServiceName name of the admin service\n+   * @returns true if deployment is success otherwise false\n+  */\n+  public static boolean deployTcpIstioGatewayAndVirtualservice(\n+        String domainNamespace, String domainUid, String adminServiceName) throws IOException  {\n+\n+    logger.info(\"Create a staging location for istio configuration objects\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");\n+    deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+    logger.info(\"Copy istio-tcp-template.service.yaml to staging location\");\n+    Path srcFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-tcp-template.service.yaml\");\n+    Path targetFile = Paths.get(fileTemp.toString(), \"istio-tcp-service.yaml\");\n+    Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    String out = targetFile.toString();\n+    String adminService = adminServiceName + \".svc.cluster.local\";\n+    replaceStringInFile(out, \"NAMESPACE\", domainNamespace); \n+    replaceStringInFile(out, \"DUID\", domainUid); \n+    replaceStringInFile(out, \"ADMIN_SERVICE\", adminServiceName); \n+\n+    ExecResult result = null;\n+    StringBuffer deployIstioGateway = null;\n+    deployIstioGateway = new StringBuffer(\"kubectl apply -f \");\n+    deployIstioGateway.append(targetFile.toString());\n+    logger.info(\"deployIstioGateway: kubectl command {0}\", new String(deployIstioGateway));\n+    try {\n+      result = exec(new String(deployIstioGateway), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in deployIstioGateway() {0}\", ex);\n+      return false;\n+    }\n+    logger.info(\"deployIstioTcpGateway: kubectl returned {0}\", result.toString());\n+    if (result.stdout().contains(\"istio-tcp-gateway created\")) {\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Deploy the Istio DestinationRule. \n+   * @param domainNamespace name of the domain namespace\n+   * @param domainUid name of the domain identifier\n+   * @returns true if deployment is success otherwise false\n+  */\n+  public static boolean deployIstioDestinationRule(\n+        String domainNamespace, String domainUid) throws IOException  {\n+\n+    logger.info(\"Create a staging location for istio configuration objects\");\n+    Path fileTemp = Paths.get(RESULTS_ROOT, \"tmp\", \"istio\");\n+    deleteDirectory(fileTemp.toFile());\n+    Files.createDirectories(fileTemp);\n+\n+    logger.info(\"Copy istio-dr-template.yaml to staging location\");\n+    Path srcFile = Paths.get(RESOURCE_DIR, \"istio\", \"istio-dr-template.yaml\");\n+    Path targetFile = Paths.get(fileTemp.toString(), \"istio-dr.yaml\");\n+    Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);\n+\n+    String out = targetFile.toString();\n+    replaceStringInFile(out, \"NAMESPACE\", domainNamespace); \n+    replaceStringInFile(out, \"DUID\", domainUid); \n+\n+    ExecResult result = null;\n+    StringBuffer deployIstioGateway = null;\n+    deployIstioGateway = new StringBuffer(\"kubectl apply -f \");\n+    deployIstioGateway.append(targetFile.toString());\n+    logger.info(\"deployIstioDestinationRule: kubectl command {0}\", new String(deployIstioGateway));\n+    try {\n+      result = exec(new String(deployIstioGateway), true);\n+    } catch (Exception ex) {\n+      logger.info(\"Exception in deployIstioDestinationRule() {0}\", ex);\n+      return false;\n+    }\n+    logger.info(\"deployIstioDestinationRule: kubectl returned {0}\", result.toString());\n+    if (result.stdout().contains(\"destination-rule created\")) {", "originalCommit": "496880f40ed50fc5010f798225ebaa8039a0da9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzNzg3Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1753#discussion_r443837873", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-06-22T21:31:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxNTU5OA=="}], "type": "inlineReview"}, {"oid": "3b6a0ee9d48c4827acef97069a268f1bad6b6d15", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3b6a0ee9d48c4827acef97069a268f1bad6b6d15", "message": "Addressed the review comments", "committedDate": "2020-06-22T21:46:25Z", "type": "commit"}, {"oid": "7b2fb0a397d76c95efc6fed708d5058d370b83a4", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7b2fb0a397d76c95efc6fed708d5058d370b83a4", "message": "Moved the uninstallIstio() to CleanupUtil", "committedDate": "2020-06-23T15:40:44Z", "type": "commit"}, {"oid": "b677d6322bb1d226458a32b13a5ea7899e6aeb6e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b677d6322bb1d226458a32b13a5ea7899e6aeb6e", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into istio-develop", "committedDate": "2020-06-23T15:40:56Z", "type": "commit"}, {"oid": "1178a196458e4d4e5508d5efccf7a13579569768", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1178a196458e4d4e5508d5efccf7a13579569768", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into istio-develop", "committedDate": "2020-06-23T20:12:38Z", "type": "commit"}, {"oid": "abcd89b2527e83a7b7807ad9944af04485c68547", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/abcd89b2527e83a7b7807ad9944af04485c68547", "message": "Resolution to more review comments", "committedDate": "2020-06-23T22:33:43Z", "type": "commit"}]}