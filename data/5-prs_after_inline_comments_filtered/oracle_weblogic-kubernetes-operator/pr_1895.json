{"pr_number": 1895, "pr_title": "New Tests for ServerStartPolicy", "pr_createdAt": "2020-09-01T21:51:14Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895", "timeline": [{"oid": "52a9abdc2398be66cbba6ee0f415c136b8720c01", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/52a9abdc2398be66cbba6ee0f415c136b8720c01", "message": "Added new tests for ServerStartPolicy", "committedDate": "2020-09-01T21:40:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3ODUyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r481478529", "bodyText": "typo : scenarios", "author": "marinakog", "createdAt": "2020-09-01T23:01:47Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1237 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test class verifies the following scenerios.\n+ *", "originalCommit": "52a9abdc2398be66cbba6ee0f415c136b8720c01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjUzNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r481512537", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-09-02T00:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3ODUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4NDYxNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r481484616", "bodyText": "managed server", "author": "marinakog", "createdAt": "2020-09-01T23:20:42Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1237 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test class verifies the following scenerios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // Check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // Check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managedserver pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);", "originalCommit": "52a9abdc2398be66cbba6ee0f415c136b8720c01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjUxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r481512514", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-09-02T00:51:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4NDYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4NDY4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r481484689", "bodyText": "managed server", "author": "marinakog", "createdAt": "2020-09-01T23:20:54Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1237 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test class verifies the following scenerios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // Check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // Check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managedserver pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // Check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);", "originalCommit": "52a9abdc2398be66cbba6ee0f415c136b8720c01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjQ4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r481512489", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-09-02T00:50:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4NDY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4NTU5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r481485595", "bodyText": "server pod is not effected", "author": "marinakog", "createdAt": "2020-09-01T23:23:38Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1237 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test class verifies the following scenerios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // Check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // Check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managedserver pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // Check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managedserver service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // Check configured cluster configuration is available \n+    boolean isServerConfigured = \n+        checkManagedServerConfiguration(\"config-cluster-server1\");\n+    assertTrue(isServerConfigured, \n+        \"Could not find managed server from configured cluster\");\n+    logger.info(\"Found managed server from configured cluster\");\n+\n+    // Check standalone server configuration is available \n+    isServerConfigured = \n+       checkManagedServerConfiguration(\"standalone-managed\");\n+    logger.info(\"Found non-cluster managed server configuration\");\n+  }\n+\n+  /**\n+   * Stop the Administration server by patching the resource defintion with \n+   *  spec/adminServer/serverStartPolicy set to NEVER.\n+   * Make sure that Only the Administration server is stopped. \n+   * Restart the Administration server by patching the resource defintion with \n+   *  spec/adminServer/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that Administration server is in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the Administration server with serverStartPolicy\")\n+  public void testAdminServerRestart() {\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(adminShutdown) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(adminShutdown) failed\");\n+   \n+    checkPodDeleted(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"AdminServer shutdown success\");\n+\n+    // check managed server pods are not affected\n+    logger.info(\"Check managed server pods are not affected\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+    logger.info(\"Managed servers are still RUNNING after AdminServer is stopped\");\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer restart patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restart) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(restart) failed\");\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+    logger.info(\"AdminServer restart success\");\n+  }\n+\n+  /**\n+   * Stop a configured cluster by patching the resource defintion with \n+   *  spec/clusters/1/serverStartPolicy set to NEVER.\n+   * Make sure that ONLY servers in second Cluster are stopped. \n+   * Restart the cluster by patching the resource defintion with \n+   *  spec/clusters/1/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that servers in second cluster are in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the configured cluster with serverStartPolicy\")\n+  public void testConfigClusterRestart() {\n+\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+\n+    // Make sure that Configured Cluster Managed server is Ready \n+    checkPodReady(configServerPodName, domainUid, domainNamespace);\n+    checkServiceExists(configServerPodName, domainNamespace);\n+    logger.info(\"(BeforePatch) configured cluster managed server is RUNNING\");\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/clusters/1/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Configured cluster shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(clusterShutdown) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(configclusterShutdown) failed\");\n+   \n+    checkPodDeleted(configServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Config cluster shutdown success\");\n+\n+    // check managed server from other clusyter are not affected\n+    logger.info(\"Check managed server pods are not affected\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+    logger.info(\"Managed servers on cluster-1 are RUNNING after cluster-2 is stopped\");\n+\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/clusters/1/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Cluster restart patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(clusterRestart) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(clusterRestart) failed\");\n+    logger.info(\"Wait for Cluster server pod {0} to be ready in namespace {1}\",\n+        configServerPodName, domainNamespace);\n+    checkPodReady(configServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check configured cluster managed service {0} is created in namespace {1}\",\n+        configServerPodName, domainNamespace);\n+    checkServiceExists(configServerPodName, domainNamespace);\n+    logger.info(\"Configured cluster restart success\");\n+  }\n+\n+  /**\n+   * Stop a dynamic cluster by patching the resource defintion with \n+   *  spec/clusters/1/serverStartPolicy set to NEVER.\n+   * Make sure that ONLY servers in second Cluster are stopped. \n+   * Restart the dynamic cluster by patching the resource defintion with \n+   *  spec/clusters/1/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that servers in second cluster are in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the dynamic cluster with serverStartPolicy\")\n+  public void testDynamicClusterRestart() {\n+\n+    String dynamicServerPodName = domainUid + \"-managed-server1\";\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+\n+    // Make sure that dynamic cluster managed server is Ready \n+    checkPodReady(dynamicServerPodName, domainUid, domainNamespace);\n+    checkServiceExists(dynamicServerPodName, domainNamespace);\n+    logger.info(\"(BeforePatch) dynamic cluster Managed Server is RUNNING\");\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/clusters/0/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Dynamic cluster shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(dynamicClusterShutdown) failed\");\n+    assertTrue(crdPatched, \"patchDomainCustomResource(dynamicClusterShutdown) failed\");\n+   \n+    checkPodDeleted(dynamicServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Dynamic cluster shutdown success\");\n+\n+    // check managed server from other cluster are not affected\n+    logger.info(\"Check managed server pods are not affected\");\n+    checkPodReady(configServerPodName, domainUid, domainNamespace);", "originalCommit": "52a9abdc2398be66cbba6ee0f415c136b8720c01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjQzOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r481512438", "bodyText": "Here we make sure all the managed server(s) pod from other cluster are not affected.", "author": "anpanigr", "createdAt": "2020-09-02T00:50:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4NTU5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE5MDQ2Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482190466", "bodyText": "You have to save the pod creation timestamps before you attempt to restart servers and then after intended server is restarted verify other pods creation timestamps is not changed.", "author": "sankarpn", "createdAt": "2020-09-02T16:08:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4NTU5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ5MzU0MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482493540", "bodyText": "Modified the logic to compare the pod creation timestamp", "author": "anpanigr", "createdAt": "2020-09-02T21:32:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4NTU5NQ=="}], "type": "inlineReview"}, {"oid": "1d1f80f45201b3334085f291e46ee8bd1c1d9600", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1d1f80f45201b3334085f291e46ee8bd1c1d9600", "message": "Minor typo modification", "committedDate": "2020-09-02T00:48:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3OTE2OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482179169", "bodyText": "Is that the expected behavior? As long as there are servers running equal to replicaCount it shouldn't bring up ms1 right when ms2 is already running?", "author": "sankarpn", "createdAt": "2020-09-02T15:51:24Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1237 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count", "originalCommit": "1d1f80f45201b3334085f291e46ee8bd1c1d9600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzMzQwOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482233408", "bodyText": "This is the behavior I see in current code. Let us confirm with Ryan/Monica.\nAs Per Monica (09/02) this many be a BUG. Need to open a Operator BUG", "author": "anpanigr", "createdAt": "2020-09-02T17:12:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3OTE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3OTUxOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482179519", "bodyText": "same as above here", "author": "sankarpn", "createdAt": "2020-09-02T15:51:51Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1237 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count", "originalCommit": "1d1f80f45201b3334085f291e46ee8bd1c1d9600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzMzYwMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482233603", "bodyText": "This is the behavior I see in current code. Let us confirm with Ryan/Monica.", "author": "anpanigr", "createdAt": "2020-09-02T17:12:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3OTUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4MjM0NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482182345", "bodyText": "checkServiceExists has to be called before checkPodReady", "author": "sankarpn", "createdAt": "2020-09-02T15:55:39Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1237 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // Check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);", "originalCommit": "1d1f80f45201b3334085f291e46ee8bd1c1d9600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzNzQ5OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482237499", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-09-02T17:17:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4MjM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4MjY3MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482182671", "bodyText": "same thing here.\ncheckServiceExists has to be called before checkPodReady", "author": "sankarpn", "createdAt": "2020-09-02T15:56:10Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1237 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // Check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // Check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // Check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);", "originalCommit": "1d1f80f45201b3334085f291e46ee8bd1c1d9600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzNzU0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482237546", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-09-02T17:17:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4MjY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4NjYwMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482186600", "bodyText": "Instead of just verifying the ms pods are in ready state right after admin server pod is deleted save the pods start times before patching for managed servers and verify the managed servers are not restarted with creation time stamps after admin server pod is restarted", "author": "sankarpn", "createdAt": "2020-09-02T16:01:58Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1237 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // Check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // Check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // Check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // Check configured cluster configuration is available \n+    boolean isServerConfigured = \n+        checkManagedServerConfiguration(\"config-cluster-server1\");\n+    assertTrue(isServerConfigured, \n+        \"Could not find managed server from configured cluster\");\n+    logger.info(\"Found managed server from configured cluster\");\n+\n+    // Check standalone server configuration is available \n+    isServerConfigured = \n+       checkManagedServerConfiguration(\"standalone-managed\");\n+    logger.info(\"Found non-cluster managed server configuration\");\n+  }\n+\n+  /**\n+   * Stop the Administration server by patching the resource defintion with \n+   *  spec/adminServer/serverStartPolicy set to NEVER.\n+   * Make sure that Only the Administration server is stopped. \n+   * Restart the Administration server by patching the resource defintion with \n+   *  spec/adminServer/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that Administration server is in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the Administration server with serverStartPolicy\")\n+  public void testAdminServerRestart() {\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(adminShutdown) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(adminShutdown) failed\");\n+   \n+    checkPodDeleted(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"AdminServer shutdown success\");\n+\n+    // check managed server pods are not affected\n+    logger.info(\"Check managed server pods are not affected\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }", "originalCommit": "1d1f80f45201b3334085f291e46ee8bd1c1d9600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQyOTc3MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482429770", "bodyText": "Added the logic for managed server pod creation timestamp comparison.", "author": "anpanigr", "createdAt": "2020-09-02T20:36:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4NjYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4NjgwMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482186803", "bodyText": "checkServiceExists has to be called before checkPodReady", "author": "sankarpn", "createdAt": "2020-09-02T16:02:17Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1237 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // Check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // Check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // Check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // Check configured cluster configuration is available \n+    boolean isServerConfigured = \n+        checkManagedServerConfiguration(\"config-cluster-server1\");\n+    assertTrue(isServerConfigured, \n+        \"Could not find managed server from configured cluster\");\n+    logger.info(\"Found managed server from configured cluster\");\n+\n+    // Check standalone server configuration is available \n+    isServerConfigured = \n+       checkManagedServerConfiguration(\"standalone-managed\");\n+    logger.info(\"Found non-cluster managed server configuration\");\n+  }\n+\n+  /**\n+   * Stop the Administration server by patching the resource defintion with \n+   *  spec/adminServer/serverStartPolicy set to NEVER.\n+   * Make sure that Only the Administration server is stopped. \n+   * Restart the Administration server by patching the resource defintion with \n+   *  spec/adminServer/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that Administration server is in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the Administration server with serverStartPolicy\")\n+  public void testAdminServerRestart() {\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(adminShutdown) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(adminShutdown) failed\");\n+   \n+    checkPodDeleted(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"AdminServer shutdown success\");\n+\n+    // check managed server pods are not affected\n+    logger.info(\"Check managed server pods are not affected\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+    logger.info(\"Managed servers are still RUNNING after AdminServer is stopped\");\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer restart patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restart) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(restart) failed\");\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);", "originalCommit": "1d1f80f45201b3334085f291e46ee8bd1c1d9600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ5NjM0Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482496347", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-09-02T21:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4NjgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4NzQ5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482187493", "bodyText": "throughout the file checkServiceExists has to be called before checkPodReady", "author": "sankarpn", "createdAt": "2020-09-02T16:03:23Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1237 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // Check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // Check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // Check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // Check configured cluster configuration is available \n+    boolean isServerConfigured = \n+        checkManagedServerConfiguration(\"config-cluster-server1\");\n+    assertTrue(isServerConfigured, \n+        \"Could not find managed server from configured cluster\");\n+    logger.info(\"Found managed server from configured cluster\");\n+\n+    // Check standalone server configuration is available \n+    isServerConfigured = \n+       checkManagedServerConfiguration(\"standalone-managed\");\n+    logger.info(\"Found non-cluster managed server configuration\");\n+  }\n+\n+  /**\n+   * Stop the Administration server by patching the resource defintion with \n+   *  spec/adminServer/serverStartPolicy set to NEVER.\n+   * Make sure that Only the Administration server is stopped. \n+   * Restart the Administration server by patching the resource defintion with \n+   *  spec/adminServer/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that Administration server is in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the Administration server with serverStartPolicy\")\n+  public void testAdminServerRestart() {\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(adminShutdown) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(adminShutdown) failed\");\n+   \n+    checkPodDeleted(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"AdminServer shutdown success\");\n+\n+    // check managed server pods are not affected\n+    logger.info(\"Check managed server pods are not affected\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+    logger.info(\"Managed servers are still RUNNING after AdminServer is stopped\");\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer restart patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restart) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(restart) failed\");\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+    logger.info(\"AdminServer restart success\");\n+  }\n+\n+  /**\n+   * Stop a configured cluster by patching the resource defintion with \n+   *  spec/clusters/1/serverStartPolicy set to NEVER.\n+   * Make sure that ONLY servers in second Cluster are stopped. \n+   * Restart the cluster by patching the resource defintion with \n+   *  spec/clusters/1/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that servers in second cluster are in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the configured cluster with serverStartPolicy\")\n+  public void testConfigClusterRestart() {\n+\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+\n+    // Make sure that Configured Cluster Managed server is Ready \n+    checkPodReady(configServerPodName, domainUid, domainNamespace);\n+    checkServiceExists(configServerPodName, domainNamespace);", "originalCommit": "1d1f80f45201b3334085f291e46ee8bd1c1d9600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU2MjU2Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482562566", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-09-02T22:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4NzQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE5MjczMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482192732", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * cluster with SeeverStartuoPolicy IF_NEEDED. \n          \n          \n            \n               * cluster with serverStartPolicy IF_NEEDED.", "author": "sankarpn", "createdAt": "2020-09-02T16:11:33Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1237 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // Check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // Check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // Check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // Check configured cluster configuration is available \n+    boolean isServerConfigured = \n+        checkManagedServerConfiguration(\"config-cluster-server1\");\n+    assertTrue(isServerConfigured, \n+        \"Could not find managed server from configured cluster\");\n+    logger.info(\"Found managed server from configured cluster\");\n+\n+    // Check standalone server configuration is available \n+    isServerConfigured = \n+       checkManagedServerConfiguration(\"standalone-managed\");\n+    logger.info(\"Found non-cluster managed server configuration\");\n+  }\n+\n+  /**\n+   * Stop the Administration server by patching the resource defintion with \n+   *  spec/adminServer/serverStartPolicy set to NEVER.\n+   * Make sure that Only the Administration server is stopped. \n+   * Restart the Administration server by patching the resource defintion with \n+   *  spec/adminServer/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that Administration server is in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the Administration server with serverStartPolicy\")\n+  public void testAdminServerRestart() {\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(adminShutdown) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(adminShutdown) failed\");\n+   \n+    checkPodDeleted(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"AdminServer shutdown success\");\n+\n+    // check managed server pods are not affected\n+    logger.info(\"Check managed server pods are not affected\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+    logger.info(\"Managed servers are still RUNNING after AdminServer is stopped\");\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer restart patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restart) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(restart) failed\");\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+    logger.info(\"AdminServer restart success\");\n+  }\n+\n+  /**\n+   * Stop a configured cluster by patching the resource defintion with \n+   *  spec/clusters/1/serverStartPolicy set to NEVER.\n+   * Make sure that ONLY servers in second Cluster are stopped. \n+   * Restart the cluster by patching the resource defintion with \n+   *  spec/clusters/1/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that servers in second cluster are in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the configured cluster with serverStartPolicy\")\n+  public void testConfigClusterRestart() {\n+\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+\n+    // Make sure that Configured Cluster Managed server is Ready \n+    checkPodReady(configServerPodName, domainUid, domainNamespace);\n+    checkServiceExists(configServerPodName, domainNamespace);\n+    logger.info(\"(BeforePatch) configured cluster managed server is RUNNING\");\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/clusters/1/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Configured cluster shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(clusterShutdown) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(configclusterShutdown) failed\");\n+   \n+    checkPodDeleted(configServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Config cluster shutdown success\");\n+\n+    // check managed server from other cluster are not affected\n+    logger.info(\"Check managed server pods are not affected\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+    logger.info(\"Managed servers on cluster-1 are RUNNING after cluster-2 is stopped\");\n+\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/clusters/1/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Cluster restart patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(clusterRestart) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(clusterRestart) failed\");\n+    logger.info(\"Wait for Cluster server pod {0} to be ready in namespace {1}\",\n+        configServerPodName, domainNamespace);\n+    checkPodReady(configServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check configured cluster managed service {0} is created in namespace {1}\",\n+        configServerPodName, domainNamespace);\n+    checkServiceExists(configServerPodName, domainNamespace);\n+    logger.info(\"Configured cluster restart success\");\n+  }\n+\n+  /**\n+   * Stop a dynamic cluster by patching the resource defintion with \n+   *  spec/clusters/1/serverStartPolicy set to NEVER.\n+   * Make sure that ONLY servers in second Cluster are stopped. \n+   * Restart the dynamic cluster by patching the resource defintion with \n+   *  spec/clusters/1/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that servers in second cluster are in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the dynamic cluster with serverStartPolicy\")\n+  public void testDynamicClusterRestart() {\n+\n+    String dynamicServerPodName = domainUid + \"-managed-server1\";\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+\n+    // Make sure that dynamic cluster managed server is Ready \n+    checkPodReady(dynamicServerPodName, domainUid, domainNamespace);\n+    checkServiceExists(dynamicServerPodName, domainNamespace);\n+    logger.info(\"(BeforePatch) dynamic cluster Managed Server is RUNNING\");\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/clusters/0/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Dynamic cluster shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(dynamicClusterShutdown) failed\");\n+    assertTrue(crdPatched, \"patchDomainCustomResource(dynamicClusterShutdown) failed\");\n+   \n+    checkPodDeleted(dynamicServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Dynamic cluster shutdown success\");\n+\n+    // check managed server from other cluster are not affected\n+    logger.info(\"Check managed server pods are not affected\");\n+    checkPodReady(configServerPodName, domainUid, domainNamespace);\n+    checkServiceExists(configServerPodName, domainNamespace);\n+\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/clusters/0/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Dynamic cluster restart patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(dynamicClusterRestart) failed\");\n+    assertTrue(crdPatched, \"patchDomainCustomResource(dynamicClusterRestart) failed\");\n+    logger.info(\"Wait for dynamic Cluster server pod {0} to be ready in namespace {1}\", domainNamespace);\n+    checkPodReady(dynamicServerPodName, domainUid, domainNamespace);\n+    checkServiceExists(dynamicServerPodName, domainNamespace);\n+\n+    logger.info(\"Dynamic Cluster restart success\");\n+  }\n+\n+  /**\n+   * Stop the entire domain by patching the resource defintion with \n+   *  spec/serverStartPolicy set to NEVER.\n+   * Make sure that all servers in the domain are stopped. \n+   * Restart the domain by patching the resource defintion with \n+   *  spec/serverStartPolicy set to ADMIN_ONLY.\n+   * Make sure that ONLY Admin Server is in RUNNING state. \n+   * Restart the domain by patching the resource defintion with \n+   *  spec/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that all servers in the domain are in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the Domain with serverStartPolicy\")\n+  public void testDomainRestart() {\n+\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+    String standaloneServerPodName = domainUid + \"-standalone-managed\";\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Domain shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(domainShutdown) failed\");\n+    assertTrue(crdPatched, \"patchDomainCustomResource(domainShutdown) failed\");\n+    logger.info(\"!!! Domain Resource patched for shutdown (NEVER) !!!\");\n+   \n+    // make sure all the server pods are removed after patch\n+    checkPodDeleted(adminServerPodName, domainUid, domainNamespace);\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodDeleted(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+    checkPodDeleted(configServerPodName, domainUid, domainNamespace);\n+    checkPodDeleted(standaloneServerPodName, domainUid, domainNamespace);\n+    logger.info(\"!!! Domain shutdown (NEVER) success !!!\");\n+\n+    // Patch the Domain with serverStartPolicy set to ADMIN_ONLY\n+    // Here only Admin server pod should come up\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"ADMIN_ONLY\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Domain restart(adminonly) patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(adminonly) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(adminonly) failed\");\n+    logger.info(\"!!! Domain Resource patched for shutdown (ADMIN_ONLY) !!!\");\n+\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // make sure all other managed server pods are not provisioned \n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodDeleted(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+    checkPodDeleted(configServerPodName, domainUid, domainNamespace);\n+    checkPodDeleted(standaloneServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"!!! Domain restart (ADMIN_ONLY) success !!!\");\n+\n+    // Patch the Domain with serverStartPolicy set to IF_NEEDED\n+    // Here all the Servers should come up\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Domain restart(if_needed) patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(if_needed) failed\");\n+    assertTrue(crdPatched, \"patchDomainCustomResource(if_needed) failed\");\n+    logger.info(\"!!! Domain Resource patched for shutdown (IF_NEEDED) !!!\");\n+    \n+    // check dynamic managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+    checkPodReady(configServerPodName, domainUid, domainNamespace);\n+    checkPodReady(standaloneServerPodName, domainUid, domainNamespace);\n+    logger.info(\"!!! Domain restart (IF_NEEDED) success !!!\");\n+  }\n+\n+  /**\n+   * Add a second managed server (config-cluster-server2) in a configured \n+   * cluster with SeeverStartuoPolicy IF_NEEDED. ", "originalCommit": "1d1f80f45201b3334085f291e46ee8bd1c1d9600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzODU4OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482238588", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-09-02T17:19:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE5MjczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE5NDY3Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482194676", "bodyText": "why would the managed server be stopped? When the replicaCount is 1 how does changing the serverStartPolicy from ALWAYS to IF_NEEDED shutsdown the server? There is only one running server in this cluster right?", "author": "sankarpn", "createdAt": "2020-09-02T16:14:35Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1237 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // Check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // Check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // Check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // Check configured cluster configuration is available \n+    boolean isServerConfigured = \n+        checkManagedServerConfiguration(\"config-cluster-server1\");\n+    assertTrue(isServerConfigured, \n+        \"Could not find managed server from configured cluster\");\n+    logger.info(\"Found managed server from configured cluster\");\n+\n+    // Check standalone server configuration is available \n+    isServerConfigured = \n+       checkManagedServerConfiguration(\"standalone-managed\");\n+    logger.info(\"Found non-cluster managed server configuration\");\n+  }\n+\n+  /**\n+   * Stop the Administration server by patching the resource defintion with \n+   *  spec/adminServer/serverStartPolicy set to NEVER.\n+   * Make sure that Only the Administration server is stopped. \n+   * Restart the Administration server by patching the resource defintion with \n+   *  spec/adminServer/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that Administration server is in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the Administration server with serverStartPolicy\")\n+  public void testAdminServerRestart() {\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(adminShutdown) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(adminShutdown) failed\");\n+   \n+    checkPodDeleted(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"AdminServer shutdown success\");\n+\n+    // check managed server pods are not affected\n+    logger.info(\"Check managed server pods are not affected\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+    logger.info(\"Managed servers are still RUNNING after AdminServer is stopped\");\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer restart patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restart) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(restart) failed\");\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+    logger.info(\"AdminServer restart success\");\n+  }\n+\n+  /**\n+   * Stop a configured cluster by patching the resource defintion with \n+   *  spec/clusters/1/serverStartPolicy set to NEVER.\n+   * Make sure that ONLY servers in second Cluster are stopped. \n+   * Restart the cluster by patching the resource defintion with \n+   *  spec/clusters/1/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that servers in second cluster are in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the configured cluster with serverStartPolicy\")\n+  public void testConfigClusterRestart() {\n+\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+\n+    // Make sure that Configured Cluster Managed server is Ready \n+    checkPodReady(configServerPodName, domainUid, domainNamespace);\n+    checkServiceExists(configServerPodName, domainNamespace);\n+    logger.info(\"(BeforePatch) configured cluster managed server is RUNNING\");\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/clusters/1/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Configured cluster shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(clusterShutdown) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(configclusterShutdown) failed\");\n+   \n+    checkPodDeleted(configServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Config cluster shutdown success\");\n+\n+    // check managed server from other cluster are not affected\n+    logger.info(\"Check managed server pods are not affected\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+    logger.info(\"Managed servers on cluster-1 are RUNNING after cluster-2 is stopped\");\n+\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/clusters/1/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Cluster restart patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(clusterRestart) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(clusterRestart) failed\");\n+    logger.info(\"Wait for Cluster server pod {0} to be ready in namespace {1}\",\n+        configServerPodName, domainNamespace);\n+    checkPodReady(configServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check configured cluster managed service {0} is created in namespace {1}\",\n+        configServerPodName, domainNamespace);\n+    checkServiceExists(configServerPodName, domainNamespace);\n+    logger.info(\"Configured cluster restart success\");\n+  }\n+\n+  /**\n+   * Stop a dynamic cluster by patching the resource defintion with \n+   *  spec/clusters/1/serverStartPolicy set to NEVER.\n+   * Make sure that ONLY servers in second Cluster are stopped. \n+   * Restart the dynamic cluster by patching the resource defintion with \n+   *  spec/clusters/1/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that servers in second cluster are in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the dynamic cluster with serverStartPolicy\")\n+  public void testDynamicClusterRestart() {\n+\n+    String dynamicServerPodName = domainUid + \"-managed-server1\";\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+\n+    // Make sure that dynamic cluster managed server is Ready \n+    checkPodReady(dynamicServerPodName, domainUid, domainNamespace);\n+    checkServiceExists(dynamicServerPodName, domainNamespace);\n+    logger.info(\"(BeforePatch) dynamic cluster Managed Server is RUNNING\");\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/clusters/0/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Dynamic cluster shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(dynamicClusterShutdown) failed\");\n+    assertTrue(crdPatched, \"patchDomainCustomResource(dynamicClusterShutdown) failed\");\n+   \n+    checkPodDeleted(dynamicServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Dynamic cluster shutdown success\");\n+\n+    // check managed server from other cluster are not affected\n+    logger.info(\"Check managed server pods are not affected\");\n+    checkPodReady(configServerPodName, domainUid, domainNamespace);\n+    checkServiceExists(configServerPodName, domainNamespace);\n+\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/clusters/0/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Dynamic cluster restart patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(dynamicClusterRestart) failed\");\n+    assertTrue(crdPatched, \"patchDomainCustomResource(dynamicClusterRestart) failed\");\n+    logger.info(\"Wait for dynamic Cluster server pod {0} to be ready in namespace {1}\", domainNamespace);\n+    checkPodReady(dynamicServerPodName, domainUid, domainNamespace);\n+    checkServiceExists(dynamicServerPodName, domainNamespace);\n+\n+    logger.info(\"Dynamic Cluster restart success\");\n+  }\n+\n+  /**\n+   * Stop the entire domain by patching the resource defintion with \n+   *  spec/serverStartPolicy set to NEVER.\n+   * Make sure that all servers in the domain are stopped. \n+   * Restart the domain by patching the resource defintion with \n+   *  spec/serverStartPolicy set to ADMIN_ONLY.\n+   * Make sure that ONLY Admin Server is in RUNNING state. \n+   * Restart the domain by patching the resource defintion with \n+   *  spec/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that all servers in the domain are in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the Domain with serverStartPolicy\")\n+  public void testDomainRestart() {\n+\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+    String standaloneServerPodName = domainUid + \"-standalone-managed\";\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Domain shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(domainShutdown) failed\");\n+    assertTrue(crdPatched, \"patchDomainCustomResource(domainShutdown) failed\");\n+    logger.info(\"!!! Domain Resource patched for shutdown (NEVER) !!!\");\n+   \n+    // make sure all the server pods are removed after patch\n+    checkPodDeleted(adminServerPodName, domainUid, domainNamespace);\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodDeleted(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+    checkPodDeleted(configServerPodName, domainUid, domainNamespace);\n+    checkPodDeleted(standaloneServerPodName, domainUid, domainNamespace);\n+    logger.info(\"!!! Domain shutdown (NEVER) success !!!\");\n+\n+    // Patch the Domain with serverStartPolicy set to ADMIN_ONLY\n+    // Here only Admin server pod should come up\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"ADMIN_ONLY\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Domain restart(adminonly) patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(adminonly) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(adminonly) failed\");\n+    logger.info(\"!!! Domain Resource patched for shutdown (ADMIN_ONLY) !!!\");\n+\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // make sure all other managed server pods are not provisioned \n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodDeleted(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+    checkPodDeleted(configServerPodName, domainUid, domainNamespace);\n+    checkPodDeleted(standaloneServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"!!! Domain restart (ADMIN_ONLY) success !!!\");\n+\n+    // Patch the Domain with serverStartPolicy set to IF_NEEDED\n+    // Here all the Servers should come up\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Domain restart(if_needed) patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(if_needed) failed\");\n+    assertTrue(crdPatched, \"patchDomainCustomResource(if_needed) failed\");\n+    logger.info(\"!!! Domain Resource patched for shutdown (IF_NEEDED) !!!\");\n+    \n+    // check dynamic managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+    checkPodReady(configServerPodName, domainUid, domainNamespace);\n+    checkPodReady(standaloneServerPodName, domainUid, domainNamespace);\n+    logger.info(\"!!! Domain restart (IF_NEEDED) success !!!\");\n+  }\n+\n+  /**\n+   * Add a second managed server (config-cluster-server2) in a configured \n+   * cluster with SeeverStartuoPolicy IF_NEEDED. \n+   * Initially, server will not come up since the replica count is set to 1.\n+   * Update the serverStartPolicy for config-cluster-server2 to ALWAYS\n+   * by patching the resource defintion with \n+   *  spec/managedServers/1/serverStartPolicy set to ALWAYS.\n+   * Make sure that managed server config-cluster-server2 is up and running\n+   * Stop the managed server by patching the resource defintion \n+   *   with spec/managedServers/1/serverStartPolicy set to IF_NEEDED.\n+   * Make sure the specified managed server is stopped as per replica count.", "originalCommit": "1d1f80f45201b3334085f291e46ee8bd1c1d9600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU2Nzc2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482567764", "bodyText": "ALWAYS for managed server just start the managed server irrespective of replica count. You may go beyond the replica count. IF_NEEDED means it starts if we need to fulfill the replica count.\nRef : https://oracle.github.io/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle/startup/", "author": "anpanigr", "createdAt": "2020-09-02T22:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE5NDY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIwNTA0Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482205042", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * cluster with SeeverStartuoPolicy IF_NEEDED. \n          \n          \n            \n               * cluster with serverStartPolicy IF_NEEDED.", "author": "sankarpn", "createdAt": "2020-09-02T16:30:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1237 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    // Check admin server pod is ready\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // Check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // Check managed server services created\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // Check configured cluster configuration is available \n+    boolean isServerConfigured = \n+        checkManagedServerConfiguration(\"config-cluster-server1\");\n+    assertTrue(isServerConfigured, \n+        \"Could not find managed server from configured cluster\");\n+    logger.info(\"Found managed server from configured cluster\");\n+\n+    // Check standalone server configuration is available \n+    isServerConfigured = \n+       checkManagedServerConfiguration(\"standalone-managed\");\n+    logger.info(\"Found non-cluster managed server configuration\");\n+  }\n+\n+  /**\n+   * Stop the Administration server by patching the resource defintion with \n+   *  spec/adminServer/serverStartPolicy set to NEVER.\n+   * Make sure that Only the Administration server is stopped. \n+   * Restart the Administration server by patching the resource defintion with \n+   *  spec/adminServer/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that Administration server is in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the Administration server with serverStartPolicy\")\n+  public void testAdminServerRestart() {\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(adminShutdown) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(adminShutdown) failed\");\n+   \n+    checkPodDeleted(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"AdminServer shutdown success\");\n+\n+    // check managed server pods are not affected\n+    logger.info(\"Check managed server pods are not affected\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+    logger.info(\"Managed servers are still RUNNING after AdminServer is stopped\");\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer restart patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restart) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(restart) failed\");\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+    logger.info(\"AdminServer restart success\");\n+  }\n+\n+  /**\n+   * Stop a configured cluster by patching the resource defintion with \n+   *  spec/clusters/1/serverStartPolicy set to NEVER.\n+   * Make sure that ONLY servers in second Cluster are stopped. \n+   * Restart the cluster by patching the resource defintion with \n+   *  spec/clusters/1/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that servers in second cluster are in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the configured cluster with serverStartPolicy\")\n+  public void testConfigClusterRestart() {\n+\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+\n+    // Make sure that Configured Cluster Managed server is Ready \n+    checkPodReady(configServerPodName, domainUid, domainNamespace);\n+    checkServiceExists(configServerPodName, domainNamespace);\n+    logger.info(\"(BeforePatch) configured cluster managed server is RUNNING\");\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/clusters/1/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Configured cluster shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(clusterShutdown) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(configclusterShutdown) failed\");\n+   \n+    checkPodDeleted(configServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Config cluster shutdown success\");\n+\n+    // check managed server from other cluster are not affected\n+    logger.info(\"Check managed server pods are not affected\");\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+    logger.info(\"Managed servers on cluster-1 are RUNNING after cluster-2 is stopped\");\n+\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/clusters/1/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Cluster restart patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(clusterRestart) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(clusterRestart) failed\");\n+    logger.info(\"Wait for Cluster server pod {0} to be ready in namespace {1}\",\n+        configServerPodName, domainNamespace);\n+    checkPodReady(configServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"Check configured cluster managed service {0} is created in namespace {1}\",\n+        configServerPodName, domainNamespace);\n+    checkServiceExists(configServerPodName, domainNamespace);\n+    logger.info(\"Configured cluster restart success\");\n+  }\n+\n+  /**\n+   * Stop a dynamic cluster by patching the resource defintion with \n+   *  spec/clusters/1/serverStartPolicy set to NEVER.\n+   * Make sure that ONLY servers in second Cluster are stopped. \n+   * Restart the dynamic cluster by patching the resource defintion with \n+   *  spec/clusters/1/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that servers in second cluster are in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the dynamic cluster with serverStartPolicy\")\n+  public void testDynamicClusterRestart() {\n+\n+    String dynamicServerPodName = domainUid + \"-managed-server1\";\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+\n+    // Make sure that dynamic cluster managed server is Ready \n+    checkPodReady(dynamicServerPodName, domainUid, domainNamespace);\n+    checkServiceExists(dynamicServerPodName, domainNamespace);\n+    logger.info(\"(BeforePatch) dynamic cluster Managed Server is RUNNING\");\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/clusters/0/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Dynamic cluster shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(dynamicClusterShutdown) failed\");\n+    assertTrue(crdPatched, \"patchDomainCustomResource(dynamicClusterShutdown) failed\");\n+   \n+    checkPodDeleted(dynamicServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Dynamic cluster shutdown success\");\n+\n+    // check managed server from other cluster are not affected\n+    logger.info(\"Check managed server pods are not affected\");\n+    checkPodReady(configServerPodName, domainUid, domainNamespace);\n+    checkServiceExists(configServerPodName, domainNamespace);\n+\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/clusters/0/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Dynamic cluster restart patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(dynamicClusterRestart) failed\");\n+    assertTrue(crdPatched, \"patchDomainCustomResource(dynamicClusterRestart) failed\");\n+    logger.info(\"Wait for dynamic Cluster server pod {0} to be ready in namespace {1}\", domainNamespace);\n+    checkPodReady(dynamicServerPodName, domainUid, domainNamespace);\n+    checkServiceExists(dynamicServerPodName, domainNamespace);\n+\n+    logger.info(\"Dynamic Cluster restart success\");\n+  }\n+\n+  /**\n+   * Stop the entire domain by patching the resource defintion with \n+   *  spec/serverStartPolicy set to NEVER.\n+   * Make sure that all servers in the domain are stopped. \n+   * Restart the domain by patching the resource defintion with \n+   *  spec/serverStartPolicy set to ADMIN_ONLY.\n+   * Make sure that ONLY Admin Server is in RUNNING state. \n+   * Restart the domain by patching the resource defintion with \n+   *  spec/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that all servers in the domain are in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the Domain with serverStartPolicy\")\n+  public void testDomainRestart() {\n+\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+    String standaloneServerPodName = domainUid + \"-standalone-managed\";\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Domain shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(domainShutdown) failed\");\n+    assertTrue(crdPatched, \"patchDomainCustomResource(domainShutdown) failed\");\n+    logger.info(\"!!! Domain Resource patched for shutdown (NEVER) !!!\");\n+   \n+    // make sure all the server pods are removed after patch\n+    checkPodDeleted(adminServerPodName, domainUid, domainNamespace);\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodDeleted(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+    checkPodDeleted(configServerPodName, domainUid, domainNamespace);\n+    checkPodDeleted(standaloneServerPodName, domainUid, domainNamespace);\n+    logger.info(\"!!! Domain shutdown (NEVER) success !!!\");\n+\n+    // Patch the Domain with serverStartPolicy set to ADMIN_ONLY\n+    // Here only Admin server pod should come up\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"ADMIN_ONLY\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Domain restart(adminonly) patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(adminonly) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(adminonly) failed\");\n+    logger.info(\"!!! Domain Resource patched for shutdown (ADMIN_ONLY) !!!\");\n+\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    // make sure all other managed server pods are not provisioned \n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodDeleted(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+    checkPodDeleted(configServerPodName, domainUid, domainNamespace);\n+    checkPodDeleted(standaloneServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"!!! Domain restart (ADMIN_ONLY) success !!!\");\n+\n+    // Patch the Domain with serverStartPolicy set to IF_NEEDED\n+    // Here all the Servers should come up\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Domain restart(if_needed) patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(if_needed) failed\");\n+    assertTrue(crdPatched, \"patchDomainCustomResource(if_needed) failed\");\n+    logger.info(\"!!! Domain Resource patched for shutdown (IF_NEEDED) !!!\");\n+    \n+    // check dynamic managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+    checkPodReady(configServerPodName, domainUid, domainNamespace);\n+    checkPodReady(standaloneServerPodName, domainUid, domainNamespace);\n+    logger.info(\"!!! Domain restart (IF_NEEDED) success !!!\");\n+  }\n+\n+  /**\n+   * Add a second managed server (config-cluster-server2) in a configured \n+   * cluster with SeeverStartuoPolicy IF_NEEDED. \n+   * Initially, server will not come up since the replica count is set to 1.\n+   * Update the serverStartPolicy for config-cluster-server2 to ALWAYS\n+   * by patching the resource defintion with \n+   *  spec/managedServers/1/serverStartPolicy set to ALWAYS.\n+   * Make sure that managed server config-cluster-server2 is up and running\n+   * Stop the managed server by patching the resource defintion \n+   *   with spec/managedServers/1/serverStartPolicy set to IF_NEEDED.\n+   * Make sure the specified managed server is stopped as per replica count.\n+   */\n+\n+  @Test\n+  @DisplayName(\"Start/stop config cluster managed server by updating serverStartPolicy to ALWAYS/IF_NEEDED\")\n+  public void testStartAlwaysConfigClusterManaged() {\n+    String serverPodName = domainUid + \"-config-cluster-server2\";\n+\n+    // Make sure that managed server is not running \n+    checkPodDeleted(serverPodName, domainUid, domainNamespace);\n+\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/managedServers/1/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"ALWAYS\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Config cluster managed server patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(managedShutdown) failed\");\n+    assertTrue(crdPatched, \"patchDomainCustomResource(managedShutdown) failed\");\n+    logger.info(\"!!! Domain Resource patched for config cluster managed server !!!\");\n+    checkPodReady(serverPodName, domainUid, domainNamespace);\n+    checkServiceExists(serverPodName, domainNamespace);\n+    logger.info(\"Configured cluster managed Server is RUNNING\");\n+\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/managedServers/1/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"Managed restart patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(managedRestart) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(managedRestart) failed\");\n+    logger.info(\"!!! Domain resource patched for config cluster managed server shutdown !!!\");\n+\n+    logger.info(\"Wait for managed server ${0} to be shutdown\", serverPodName);\n+    checkPodDeleted(serverPodName, domainUid, domainNamespace);\n+    logger.info(\"Config cluster managed server shutdown success\");\n+  }\n+\n+  /**\n+   * Add a second managed server (config-cluster-server2) in a configured \n+   * cluster with SeeverStartuoPolicy IF_NEEDED. ", "originalCommit": "1d1f80f45201b3334085f291e46ee8bd1c1d9600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxOTMwMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482219301", "bodyText": "Also fix the typo throughout the file", "author": "sankarpn", "createdAt": "2020-09-02T16:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIwNTA0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU2Mjg2Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482562867", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-09-02T22:46:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIwNTA0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIyMDI4MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482220280", "bodyText": "Document how many clusters are created and how many servers in it initially.", "author": "sankarpn", "createdAt": "2020-09-02T16:55:14Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1237 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to mantain the \n+ *  replica count whle the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to mantain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create domain resource defintion.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism", "originalCommit": "1d1f80f45201b3334085f291e46ee8bd1c1d9600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MzQ4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r482253489", "bodyText": "Create a WebLogic domain with one dynamic cluster (with two managed servers)\none configured cluster (with two managed servers) and a standalone manged\nserver. The replica count is set to 1 and serverStartPolicy is set to\nIF_NEEDED at managed server level.", "author": "anpanigr", "createdAt": "2020-09-02T17:45:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIyMDI4MA=="}], "type": "inlineReview"}, {"oid": "1bb561d9694466e180aa832c156a0a67525a0650", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/1bb561d9694466e180aa832c156a0a67525a0650", "message": "Adddressed review comments", "committedDate": "2020-09-02T19:59:15Z", "type": "commit"}, {"oid": "ab4a3ddfb05df459aacd2ff856a3f6e8d521bae5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ab4a3ddfb05df459aacd2ff856a3f6e8d521bae5", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into start-policy", "committedDate": "2020-09-02T19:59:25Z", "type": "commit"}, {"oid": "3c2f5af267b47a41b85e3f4878399f534040fe3b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/3c2f5af267b47a41b85e3f4878399f534040fe3b", "message": "Added logic to check the managed server timestamp", "committedDate": "2020-09-02T21:30:15Z", "type": "commit"}, {"oid": "53a306fc3301eb747bab77eec72a56233e223afb", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/53a306fc3301eb747bab77eec72a56233e223afb", "message": "Resolved few typos", "committedDate": "2020-09-02T22:44:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA4Njg1MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483086851", "bodyText": "testConfigClusterStartServerUsingAlwaysAtServerLevel or testConfigClusterStartServerUsingAlways - same pattern as other test methods above cluster type followed by use case", "author": "vanajamukkara", "createdAt": "2020-09-03T15:58:11Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1258 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged", "originalCommit": "53a306fc3301eb747bab77eec72a56233e223afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE2NDM5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483164393", "bodyText": "modified the method name", "author": "anpanigr", "createdAt": "2020-09-03T18:09:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA4Njg1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA4ODMwMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483088303", "bodyText": "testDynamicClusterStartServerUsingAlwaysAtServerLevel or testDynamicClusterStartServerUsingAlways", "author": "vanajamukkara", "createdAt": "2020-09-03T16:00:14Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1258 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged", "originalCommit": "53a306fc3301eb747bab77eec72a56233e223afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE2NDM0Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483164343", "bodyText": "modified the method name", "author": "anpanigr", "createdAt": "2020-09-03T18:09:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA4ODMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEwNDk2MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483104960", "bodyText": "As we discussed, this can be removed as NEVER is covered in other use case", "author": "vanajamukkara", "createdAt": "2020-09-03T16:25:00Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1258 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged", "originalCommit": "53a306fc3301eb747bab77eec72a56233e223afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE2NDI4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483164289", "bodyText": "removed the methods", "author": "anpanigr", "createdAt": "2020-09-03T18:09:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEwNDk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEwNTAzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483105035", "bodyText": "As we discussed, this can be removed as NEVER is covered in other use case", "author": "vanajamukkara", "createdAt": "2020-09-03T16:25:08Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1258 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged", "originalCommit": "53a306fc3301eb747bab77eec72a56233e223afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE2NDE0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483164148", "bodyText": "removed the methods", "author": "anpanigr", "createdAt": "2020-09-03T18:09:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEwNTAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEwNjA4Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483106083", "bodyText": "testConfigClusterReplicaCountIsMaintained", "author": "vanajamukkara", "createdAt": "2020-09-03T16:26:45Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1258 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged", "originalCommit": "53a306fc3301eb747bab77eec72a56233e223afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE2Mzk5NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483163994", "bodyText": "modified the method name", "author": "anpanigr", "createdAt": "2020-09-03T18:09:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEwNjA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEwNjY1MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483106651", "bodyText": "testDynamicClusterReplicaCountIsMaintained", "author": "vanajamukkara", "createdAt": "2020-09-03T16:27:37Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1258 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged", "originalCommit": "53a306fc3301eb747bab77eec72a56233e223afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2MDQwMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483260403", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-09-03T21:20:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEwNjY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExMzExNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483113116", "bodyText": "serverStartPolicy at different levels in a MII domain", "author": "vanajamukkara", "createdAt": "2020-09-03T16:38:03Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1258 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")", "originalCommit": "53a306fc3301eb747bab77eec72a56233e223afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2MDk4NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483260985", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-09-03T21:21:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExMzExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExNDExMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483114111", "bodyText": "by changing", "author": "vanajamukkara", "createdAt": "2020-09-03T16:39:38Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1258 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy ", "originalCommit": "53a306fc3301eb747bab77eec72a56233e223afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2MTM0Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483261346", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-09-03T21:22:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExNDExMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExNDIxMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483114212", "bodyText": "by changing", "author": "vanajamukkara", "createdAt": "2020-09-03T16:39:48Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1258 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy ", "originalCommit": "53a306fc3301eb747bab77eec72a56233e223afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2MTQzOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483261439", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-09-03T21:22:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExNDIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExNTUwOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483115509", "bodyText": "there are unused variables, check the code in IDE for unused variables and cleanup", "author": "vanajamukkara", "createdAt": "2020-09-03T16:41:49Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1258 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;", "originalCommit": "53a306fc3301eb747bab77eec72a56233e223afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2MTk2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483261964", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-09-03T21:24:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExNTUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExNzY3Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483117672", "bodyText": "you can use checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);", "author": "vanajamukkara", "createdAt": "2020-09-03T16:45:22Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1258 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create a domain resource definition.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);", "originalCommit": "53a306fc3301eb747bab77eec72a56233e223afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2MjMzOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483262339", "bodyText": "replaced the occurrence of checkServiceExists/checkPodReady with checkPodReadyAndServiceExists", "author": "anpanigr", "createdAt": "2020-09-03T21:24:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExNzY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExNzgzNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483117836", "bodyText": "checkPodReadyAndServiceExists(adminServerPodName, domainUid, domainNamespace);", "author": "vanajamukkara", "createdAt": "2020-09-03T16:45:40Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1258 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create a domain resource definition.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);", "originalCommit": "53a306fc3301eb747bab77eec72a56233e223afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2MjQ1NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483262454", "bodyText": "replaced the occurrence of checkServiceExists/checkPodReady with checkPodReadyAndServiceExists", "author": "anpanigr", "createdAt": "2020-09-03T21:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExNzgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExODQzNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483118437", "bodyText": "assert missing here?", "author": "vanajamukkara", "createdAt": "2020-09-03T16:46:47Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1258 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create a domain resource definition.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // Check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // Check configured cluster configuration is available \n+    boolean isServerConfigured = \n+        checkManagedServerConfiguration(\"config-cluster-server1\");\n+    assertTrue(isServerConfigured, \n+        \"Could not find managed server from configured cluster\");\n+    logger.info(\"Found managed server from configured cluster\");\n+\n+    // Check standalone server configuration is available \n+    isServerConfigured = ", "originalCommit": "53a306fc3301eb747bab77eec72a56233e223afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2Mzk5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483263996", "bodyText": "added Boolean assertion", "author": "anpanigr", "createdAt": "2020-09-03T21:28:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExODQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyNTg4MQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483125881", "bodyText": "use isPodRestarted in TestAssertions", "author": "vanajamukkara", "createdAt": "2020-09-03T16:59:27Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1258 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create a domain resource definition.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // Check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // Check configured cluster configuration is available \n+    boolean isServerConfigured = \n+        checkManagedServerConfiguration(\"config-cluster-server1\");\n+    assertTrue(isServerConfigured, \n+        \"Could not find managed server from configured cluster\");\n+    logger.info(\"Found managed server from configured cluster\");\n+\n+    // Check standalone server configuration is available \n+    isServerConfigured = \n+       checkManagedServerConfiguration(\"standalone-managed\");\n+    logger.info(\"Found non-cluster managed server configuration\");\n+  }\n+\n+  /**\n+   * Stop the Administration server by patching the resource definition with \n+   *  spec/adminServer/serverStartPolicy set to NEVER.\n+   * Make sure that Only the Administration server is stopped. \n+   * Restart the Administration server by patching the resource definition with \n+   *  spec/adminServer/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that the Administration server is in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the Administration server with serverStartPolicy\")\n+  public void testAdminServerRestart() {\n+\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+    String dynamicServerPodName = domainUid + \"-managed-server1\";\n+    DateTime dynTs = getPodCreationTime(domainNamespace, dynamicServerPodName);\n+    DateTime cfgTs = getPodCreationTime(domainNamespace, configServerPodName);\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(adminShutdown) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(adminShutdown) failed\");\n+   \n+    checkPodDeleted(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"AdminServer shutdown success\");\n+\n+    logger.info(\"Check managed server pods are not affected\");\n+    DateTime dynTs2 = getPodCreationTime(domainNamespace, dynamicServerPodName);", "originalCommit": "53a306fc3301eb747bab77eec72a56233e223afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2ODI0OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483268249", "bodyText": "utils/CommonTestUtils has a method void checkPodRestarted(), there is no direct method for CommonTestUtils .isPodRestarted(). I used the comparison for copule of times, not much code duplication.", "author": "anpanigr", "createdAt": "2020-09-03T21:39:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyNTg4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM0NzQ4Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483347483", "bodyText": "Have you checked isPodRestarted in TestAssertions class?", "author": "vanajamukkara", "createdAt": "2020-09-04T02:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyNTg4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0OTI0MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483749240", "bodyText": "Modified tests to use TestAssertions.isPodRestarted() method to make sure pod is not re started.", "author": "anpanigr", "createdAt": "2020-09-04T17:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyNTg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyNzM0Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483127347", "bodyText": "lot of duplicated code, create a private method which takes path, value, other needed vars and patches the domain", "author": "vanajamukkara", "createdAt": "2020-09-03T17:02:00Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1258 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create a domain resource definition.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // Check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // Check configured cluster configuration is available \n+    boolean isServerConfigured = \n+        checkManagedServerConfiguration(\"config-cluster-server1\");\n+    assertTrue(isServerConfigured, \n+        \"Could not find managed server from configured cluster\");\n+    logger.info(\"Found managed server from configured cluster\");\n+\n+    // Check standalone server configuration is available \n+    isServerConfigured = \n+       checkManagedServerConfiguration(\"standalone-managed\");\n+    logger.info(\"Found non-cluster managed server configuration\");\n+  }\n+\n+  /**\n+   * Stop the Administration server by patching the resource definition with \n+   *  spec/adminServer/serverStartPolicy set to NEVER.\n+   * Make sure that Only the Administration server is stopped. \n+   * Restart the Administration server by patching the resource definition with \n+   *  spec/adminServer/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that the Administration server is in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the Administration server with serverStartPolicy\")\n+  public void testAdminServerRestart() {\n+\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+    String dynamicServerPodName = domainUid + \"-managed-server1\";\n+    DateTime dynTs = getPodCreationTime(domainNamespace, dynamicServerPodName);\n+    DateTime cfgTs = getPodCreationTime(domainNamespace, configServerPodName);\n+    StringBuffer patchStr = null;", "originalCommit": "53a306fc3301eb747bab77eec72a56233e223afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI0NDY4Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483244686", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-09-03T20:46:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyNzM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyNzU1Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483127556", "bodyText": "duplicated code", "author": "vanajamukkara", "createdAt": "2020-09-03T17:02:21Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1258 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create a domain resource definition.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // Check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // Check configured cluster configuration is available \n+    boolean isServerConfigured = \n+        checkManagedServerConfiguration(\"config-cluster-server1\");\n+    assertTrue(isServerConfigured, \n+        \"Could not find managed server from configured cluster\");\n+    logger.info(\"Found managed server from configured cluster\");\n+\n+    // Check standalone server configuration is available \n+    isServerConfigured = \n+       checkManagedServerConfiguration(\"standalone-managed\");\n+    logger.info(\"Found non-cluster managed server configuration\");\n+  }\n+\n+  /**\n+   * Stop the Administration server by patching the resource definition with \n+   *  spec/adminServer/serverStartPolicy set to NEVER.\n+   * Make sure that Only the Administration server is stopped. \n+   * Restart the Administration server by patching the resource definition with \n+   *  spec/adminServer/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that the Administration server is in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the Administration server with serverStartPolicy\")\n+  public void testAdminServerRestart() {\n+\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+    String dynamicServerPodName = domainUid + \"-managed-server1\";\n+    DateTime dynTs = getPodCreationTime(domainNamespace, dynamicServerPodName);\n+    DateTime cfgTs = getPodCreationTime(domainNamespace, configServerPodName);\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(adminShutdown) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(adminShutdown) failed\");\n+   \n+    checkPodDeleted(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"AdminServer shutdown success\");\n+\n+    logger.info(\"Check managed server pods are not affected\");\n+    DateTime dynTs2 = getPodCreationTime(domainNamespace, dynamicServerPodName);\n+    DateTime cfgTs2 = getPodCreationTime(domainNamespace, configServerPodName);\n+\n+    assertTrue(\n+        dynTs2.withTimeAtStartOfDay().isEqual(dynTs.withTimeAtStartOfDay()), \n+        \"Dynamic managed server pod creation time must be same\");\n+    assertTrue(\n+        cfgTs2.withTimeAtStartOfDay().isEqual(cfgTs.withTimeAtStartOfDay()), \n+        \"Configured managed server pod creation time must be same\");\n+\n+    patchStr = null;", "originalCommit": "53a306fc3301eb747bab77eec72a56233e223afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2MDI1Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483260256", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-09-03T21:20:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyNzU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyODEzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483128135", "bodyText": "use checkPodReadyAndServiceExists through out the class where ever it can be used", "author": "vanajamukkara", "createdAt": "2020-09-03T17:03:22Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1258 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create a domain resource definition.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // Check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // Check configured cluster configuration is available \n+    boolean isServerConfigured = \n+        checkManagedServerConfiguration(\"config-cluster-server1\");\n+    assertTrue(isServerConfigured, \n+        \"Could not find managed server from configured cluster\");\n+    logger.info(\"Found managed server from configured cluster\");\n+\n+    // Check standalone server configuration is available \n+    isServerConfigured = \n+       checkManagedServerConfiguration(\"standalone-managed\");\n+    logger.info(\"Found non-cluster managed server configuration\");\n+  }\n+\n+  /**\n+   * Stop the Administration server by patching the resource definition with \n+   *  spec/adminServer/serverStartPolicy set to NEVER.\n+   * Make sure that Only the Administration server is stopped. \n+   * Restart the Administration server by patching the resource definition with \n+   *  spec/adminServer/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that the Administration server is in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the Administration server with serverStartPolicy\")\n+  public void testAdminServerRestart() {\n+\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+    String dynamicServerPodName = domainUid + \"-managed-server1\";\n+    DateTime dynTs = getPodCreationTime(domainNamespace, dynamicServerPodName);\n+    DateTime cfgTs = getPodCreationTime(domainNamespace, configServerPodName);\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(adminShutdown) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(adminShutdown) failed\");\n+   \n+    checkPodDeleted(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"AdminServer shutdown success\");\n+\n+    logger.info(\"Check managed server pods are not affected\");\n+    DateTime dynTs2 = getPodCreationTime(domainNamespace, dynamicServerPodName);\n+    DateTime cfgTs2 = getPodCreationTime(domainNamespace, configServerPodName);\n+\n+    assertTrue(\n+        dynTs2.withTimeAtStartOfDay().isEqual(dynTs.withTimeAtStartOfDay()), \n+        \"Dynamic managed server pod creation time must be same\");\n+    assertTrue(\n+        cfgTs2.withTimeAtStartOfDay().isEqual(cfgTs.withTimeAtStartOfDay()), \n+        \"Configured managed server pod creation time must be same\");\n+\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer restart patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restart) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(restart) failed\");\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);", "originalCommit": "53a306fc3301eb747bab77eec72a56233e223afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2MDA5NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483260095", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-09-03T21:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyODEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyODUxMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483128513", "bodyText": "duplicated code, create a method and use every where", "author": "vanajamukkara", "createdAt": "2020-09-03T17:04:05Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,1258 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.actions.impl.primitive.HelmParams;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReady;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysConfigClusterManaged\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStartAlwaysDynamicClusterManaged\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testStopNeverConfigClusterManaged\n+ *  Stop a server in configured cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopNeverDynamicClusterManaged\n+ *  Stop a server in dynamic cluster by changing serverStartPolicy\n+ *   IF_NEEDED->ALWAYS->NEVER\n+ *\n+ * <p>testStopConfigClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStopDynamicClusterReplicaManaged\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different scope in a mii domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static HelmParams opHelmParams = null;\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create a domain resource definition.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Check managed server service {0} is created in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkServiceExists(managedServerPrefix + i, domainNamespace);\n+    }\n+\n+    // Check managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      logger.info(\"Wait for managed server pod {0} to be ready in namespace {1}\",\n+          managedServerPrefix + i, domainNamespace);\n+      checkPodReady(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+\n+    // Check configured cluster configuration is available \n+    boolean isServerConfigured = \n+        checkManagedServerConfiguration(\"config-cluster-server1\");\n+    assertTrue(isServerConfigured, \n+        \"Could not find managed server from configured cluster\");\n+    logger.info(\"Found managed server from configured cluster\");\n+\n+    // Check standalone server configuration is available \n+    isServerConfigured = \n+       checkManagedServerConfiguration(\"standalone-managed\");\n+    logger.info(\"Found non-cluster managed server configuration\");\n+  }\n+\n+  /**\n+   * Stop the Administration server by patching the resource definition with \n+   *  spec/adminServer/serverStartPolicy set to NEVER.\n+   * Make sure that Only the Administration server is stopped. \n+   * Restart the Administration server by patching the resource definition with \n+   *  spec/adminServer/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that the Administration server is in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the Administration server with serverStartPolicy\")\n+  public void testAdminServerRestart() {\n+\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+    String dynamicServerPodName = domainUid + \"-managed-server1\";\n+    DateTime dynTs = getPodCreationTime(domainNamespace, dynamicServerPodName);\n+    DateTime cfgTs = getPodCreationTime(domainNamespace, configServerPodName);\n+    StringBuffer patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"NEVER\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer shutdown patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    boolean crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(adminShutdown) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(adminShutdown) failed\");\n+   \n+    checkPodDeleted(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"AdminServer shutdown success\");\n+\n+    logger.info(\"Check managed server pods are not affected\");\n+    DateTime dynTs2 = getPodCreationTime(domainNamespace, dynamicServerPodName);\n+    DateTime cfgTs2 = getPodCreationTime(domainNamespace, configServerPodName);\n+\n+    assertTrue(\n+        dynTs2.withTimeAtStartOfDay().isEqual(dynTs.withTimeAtStartOfDay()), \n+        \"Dynamic managed server pod creation time must be same\");\n+    assertTrue(\n+        cfgTs2.withTimeAtStartOfDay().isEqual(cfgTs.withTimeAtStartOfDay()), \n+        \"Configured managed server pod creation time must be same\");\n+\n+    patchStr = null;\n+    patchStr = new StringBuffer(\"[{\");\n+    patchStr.append(\"\\\"op\\\": \\\"replace\\\",\")\n+        .append(\" \\\"path\\\": \\\"/spec/adminServer/serverStartPolicy\\\",\")\n+        .append(\" \\\"value\\\":  \\\"IF_NEEDED\\\"\")\n+        .append(\" }]\");\n+    logger.info(\"AdminServer restart patch string: {0}\", patchStr);\n+\n+    patch = new V1Patch(new String(patchStr));\n+    crdPatched = false;\n+    crdPatched = assertDoesNotThrow(() ->\n+            patchDomainCustomResource(domainUid, domainNamespace, patch, \"application/json-patch+json\"),\n+        \"patchDomainCustomResource(restart) failed\");\n+\n+    assertTrue(crdPatched, \"patchDomainCustomResource(restart) failed\");\n+    logger.info(\"Check admin service {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkServiceExists(adminServerPodName, domainNamespace);\n+    logger.info(\"Wait for admin server pod {0} to be ready in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReady(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"AdminServer restart success\");\n+  }\n+\n+  /**\n+   * Stop a configured cluster by patching the resource definition with \n+   *  spec/clusters/1/serverStartPolicy set to NEVER.\n+   * Make sure that only server(s) in the configured cluster are stopped. \n+   * Make sure that server(s) in the dynamic cluster are in RUNNING state. \n+   * Restart the cluster by patching the resource definition with \n+   *  spec/clusters/1/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that servers in the configured cluster are in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the configured cluster with serverStartPolicy\")\n+  public void testConfigClusterRestart() {\n+\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+    String dynamicServerPodName = domainUid + \"-managed-server1\";\n+\n+    DateTime dynTs = getPodCreationTime(domainNamespace, dynamicServerPodName);\n+\n+    checkServiceExists(configServerPodName, domainNamespace);\n+    checkPodReady(configServerPodName, domainUid, domainNamespace);\n+    logger.info(\"(BeforePatch) configured cluster managed server is RUNNING\");\n+\n+    StringBuffer patchStr = null;", "originalCommit": "53a306fc3301eb747bab77eec72a56233e223afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI0OTE1MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483249150", "bodyText": "done", "author": "anpanigr", "createdAt": "2020-09-03T20:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyODUxMw=="}], "type": "inlineReview"}, {"oid": "7891e94970fa789963e0e5b6903b1158bb2466f9", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7891e94970fa789963e0e5b6903b1158bb2466f9", "message": "Resolved more review comments, removed duplicate codes, used common utility methods", "committedDate": "2020-09-03T21:43:13Z", "type": "commit"}, {"oid": "477d31dc279356f5719d8dfacb9e6baffc202146", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/477d31dc279356f5719d8dfacb9e6baffc202146", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into start-policy", "committedDate": "2020-09-03T21:43:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM0OTQ0Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483349443", "bodyText": "this is not needed, test infra deletes the domain custom resource as part of cleanup logic", "author": "vanajamukkara", "createdAt": "2020-09-04T02:23:02Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItServerStartPolicy.java", "diffHunk": "@@ -0,0 +1,876 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.kubernetes.client.custom.V1Patch;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1EnvVar;\n+import io.kubernetes.client.openapi.models.V1LocalObjectReference;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Secret;\n+import io.kubernetes.client.openapi.models.V1SecretReference;\n+import io.kubernetes.client.openapi.models.V1ServiceAccount;\n+import oracle.weblogic.domain.AdminServer;\n+import oracle.weblogic.domain.AdminService;\n+import oracle.weblogic.domain.Channel;\n+import oracle.weblogic.domain.Cluster;\n+import oracle.weblogic.domain.Configuration;\n+import oracle.weblogic.domain.Domain;\n+import oracle.weblogic.domain.DomainSpec;\n+import oracle.weblogic.domain.ManagedServer;\n+import oracle.weblogic.domain.Model;\n+import oracle.weblogic.domain.ServerPod;\n+import oracle.weblogic.kubernetes.annotations.IntegrationTest;\n+import oracle.weblogic.kubernetes.annotations.Namespaces;\n+import oracle.weblogic.kubernetes.logging.LoggingFacade;\n+import oracle.weblogic.kubernetes.utils.ExecResult;\n+import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_API_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.DOMAIN_VERSION;\n+import static oracle.weblogic.kubernetes.TestConstants.K8S_NODEPORT_HOST;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_NAME;\n+import static oracle.weblogic.kubernetes.TestConstants.MII_BASIC_IMAGE_TAG;\n+import static oracle.weblogic.kubernetes.TestConstants.REPO_SECRET_NAME;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.createSecret;\n+import static oracle.weblogic.kubernetes.actions.TestActions.deleteDomainCustomResource;\n+import static oracle.weblogic.kubernetes.actions.TestActions.getServiceNodePort;\n+import static oracle.weblogic.kubernetes.actions.TestActions.patchDomainCustomResource;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.domainExists;\n+import static oracle.weblogic.kubernetes.assertions.TestAssertions.podDoesNotExist;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.checkPodReadyAndServiceExists;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createConfigMapAndVerify;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.createDockerRegistrySecret;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.getPodCreationTime;\n+import static oracle.weblogic.kubernetes.utils.CommonTestUtils.installAndVerifyOperator;\n+import static oracle.weblogic.kubernetes.utils.ExecCommand.exec;\n+import static oracle.weblogic.kubernetes.utils.ThreadSafeLogger.getLogger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\n+/**\n+ * Create a WebLogic domain with one dynamic cluster (with two managed servers)\n+ * one configured cluster (with two managed servers) and a standalone manged \n+ * server. The replica count is set to 1 and serverStartPolicy is set to \n+ * IF_NEEDED at managed server level. \n+ * This test class verifies the following scenarios.\n+ *\n+ * <p>testAdminServerRestart\n+ *  Restart the Administration Server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDomainRestart\n+ *  Restart the entire domain by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ADMIN_ONLY->IF_NEEDED\n+ *\n+ * <p>testConfigClusterRestart\n+ *  Restart all servers in configured cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterRestart\n+ *  Restart all servers in dynamic cluster by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testConfigClusterStartServerUsingAlways\n+ *  Restart a server in configured cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testDynamicClusterStartServerUsingAlways\n+ *  Restart a server in dynamic cluster (beyond replica count) \n+ *   IF_NEEDED->ALWAYS->IF_NEEDED\n+ *\n+ * <p>testConfigClusterReplicaCountIsMaintained\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in config\n+ *  cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testDynamicClusterReplicaCountIsMaintained\n+ *  Change the serverStartPolicy of a running managed server (say ms1) in a \n+ *  dynamic cluster to NEVER. \n+ *  Make sure next managed server (say ms2) is scheduled to run to maintain the \n+ *  replica count while the running managed server ms1 goes down.\n+ *  Change the serverStartPolicy of server ms1 to IF_NEEDED.\n+ *  Make sure server ms2 goes down and server ms1 is re-scheduled to maintain \n+ *  the replica count\n+ *\n+ * <p>testStandaloneManagedRestartIfNeeded\n+ *  Restart standalone server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->IF_NEEDED\n+ *\n+ * <p>testStandaloneManagedRestartAlways\n+ *  Restart standalone server by changing serverStartPolicy \n+ *   IF_NEEDED->NEVER->ALWAYS\n+ */\n+\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+@DisplayName(\"ServerStartPolicy attribute in different levels in a MII domain\")\n+@IntegrationTest\n+class ItServerStartPolicy {\n+\n+  private static V1ServiceAccount serviceAccount = null;\n+  private String serviceAccountName = null;\n+  private static String opNamespace = null;\n+  private static String operatorImage = null;\n+  private static String domainNamespace = null;\n+  private static ConditionFactory withStandardRetryPolicy = null;\n+  private static String dockerConfigJson = \"\";\n+\n+  private static int replicaCount = 1;\n+  private static final String domainUid = \"mii-start-policy\";\n+  private StringBuffer curlString = null;\n+\n+  private StringBuffer checkCluster = null;\n+  private V1Patch patch = null;\n+\n+  private static Map<String, Object> secretNameMap;\n+\n+  private final String adminServerPodName = domainUid + \"-admin-server\";\n+  private final String managedServerPrefix = domainUid + \"-managed-server\";\n+  private static LoggingFacade logger = null;\n+\n+  /**\n+   * Install Operator.\n+   * Create a domain resource definition.\n+   * @param namespaces list of namespaces created by the IntegrationTestWatcher by the\n+   JUnit engine parameter resolution mechanism\n+   */\n+  @BeforeAll\n+  public static void initAll(@Namespaces(2) List<String> namespaces) {\n+    logger = getLogger();\n+    // create standard, reusable retry/backoff policy\n+    withStandardRetryPolicy = with().pollDelay(2, SECONDS)\n+        .and().with().pollInterval(10, SECONDS)\n+        .atMost(5, MINUTES).await();\n+\n+    // get a new unique opNamespace\n+    logger.info(\"Creating unique namespace for Operator\");\n+    assertNotNull(namespaces.get(0), \"Namespace list is null\");\n+    opNamespace = namespaces.get(0);\n+\n+    logger.info(\"Creating unique namespace for Domain\");\n+    assertNotNull(namespaces.get(1), \"Namespace list is null\");\n+    domainNamespace = namespaces.get(1);\n+\n+    // install and verify operator\n+    installAndVerifyOperator(opNamespace, domainNamespace);\n+\n+    // Create the repo secret to pull the image\n+    assertDoesNotThrow(() -> createDockerRegistrySecret(domainNamespace),\n+          String.format(\"createSecret failed for %s\", REPO_SECRET_NAME));\n+\n+    // create secret for admin credentials\n+    logger.info(\"Create secret for admin credentials\");\n+    String adminSecretName = \"weblogic-credentials\";\n+    assertDoesNotThrow(() -> createDomainSecret(adminSecretName,\"weblogic\",\n+            \"welcome1\", domainNamespace),\n+            String.format(\"createSecret failed for %s\", adminSecretName));\n+\n+    // create encryption secret\n+    logger.info(\"Create encryption secret\");\n+    String encryptionSecretName = \"encryptionsecret\";\n+    assertDoesNotThrow(() -> createDomainSecret(encryptionSecretName, \"weblogicenc\",\n+            \"weblogicenc\", domainNamespace),\n+             String.format(\"createSecret failed for %s\", encryptionSecretName));\n+\n+    String configMapName = \"wls-ext-configmap\";\n+    createConfigMapAndVerify(\n+        configMapName, domainUid, domainNamespace,\n+        Arrays.asList(\"model.wls.ext.config.yaml\"));\n+\n+    // create the domain CR with a pre-defined configmap\n+    createDomainResource(domainUid, domainNamespace, adminSecretName,\n+        REPO_SECRET_NAME, encryptionSecretName,\n+        replicaCount, configMapName);\n+\n+    // wait for the domain to exist\n+    logger.info(\"Check for domain custom resource in namespace {0}\", domainNamespace);\n+    withStandardRetryPolicy\n+        .conditionEvaluationListener(\n+            condition -> logger.info(\"Waiting for domain {0} to be created in namespace {1} \"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                domainUid,\n+                domainNamespace,\n+                condition.getElapsedTimeInMS(),\n+                condition.getRemainingTimeInMS()))\n+        .until(domainExists(domainUid, DOMAIN_VERSION, domainNamespace));\n+  }\n+\n+  /**\n+   * Verify all server pods are running.\n+   * Verify k8s services for all servers are created.\n+   */\n+  @BeforeEach\n+  public void beforeEach() {\n+\n+    logger.info(\"Check admin service/pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, \n+          domainUid, domainNamespace);\n+\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, \n+                domainUid, domainNamespace);\n+    }\n+\n+    // Check configured cluster configuration is available \n+    boolean isServerConfigured = \n+         checkManagedServerConfiguration(\"config-cluster-server1\");\n+    assertTrue(isServerConfigured, \n+        \"Could not find managed server from configured cluster\");\n+    logger.info(\"Found managed server from configured cluster\");\n+\n+    // Check standalone server configuration is available \n+    boolean isStandaloneServerConfigured = \n+         checkManagedServerConfiguration(\"standalone-managed\");\n+    assertTrue(isStandaloneServerConfigured, \n+        \"Could not find standalone managed server from configured cluster\");\n+    logger.info(\"Found standalone managed server configuration\");\n+  }\n+\n+  /**\n+   * Stop the Administration server by patching the resource definition with \n+   *  spec/adminServer/serverStartPolicy set to NEVER.\n+   * Make sure that Only the Administration server is stopped. \n+   * Restart the Administration server by patching the resource definition with \n+   *  spec/adminServer/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that the Administration server is in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the Administration server with serverStartPolicy\")\n+  public void testAdminServerRestart() {\n+\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+    String dynamicServerPodName = domainUid + \"-managed-server1\";\n+\n+    DateTime dynTs = getPodCreationTime(domainNamespace, dynamicServerPodName);\n+    DateTime cfgTs = getPodCreationTime(domainNamespace, configServerPodName);\n+\n+    patchServerStartPolicy(\"/spec/adminServer/serverStartPolicy\", \"NEVER\");\n+    logger.info(\"Domain is patched to shutdown administration server\");\n+   \n+    checkPodDeleted(adminServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Administration server shutdown success\");\n+\n+    logger.info(\"Check managed server pods are not affected\");\n+    DateTime dynTs2 = getPodCreationTime(domainNamespace, dynamicServerPodName);\n+    DateTime cfgTs2 = getPodCreationTime(domainNamespace, configServerPodName);\n+\n+    assertTrue(\n+        dynTs2.withTimeAtStartOfDay().isEqual(dynTs.withTimeAtStartOfDay()), \n+        \"Dynamic managed server pod creation time must be same\");\n+    assertTrue(\n+        cfgTs2.withTimeAtStartOfDay().isEqual(cfgTs.withTimeAtStartOfDay()), \n+        \"Configured managed server pod creation time must be same\");\n+\n+    patchServerStartPolicy(\"/spec/adminServer/serverStartPolicy\", \"IF_NEEDED\");\n+    logger.info(\"Domain is patched to start administration server\");\n+\n+    logger.info(\"Check admin service/pod {0} is created in namespace {1}\",\n+        adminServerPodName, domainNamespace);\n+    checkPodReadyAndServiceExists(adminServerPodName, \n+            domainUid, domainNamespace);\n+    logger.info(\"AdminServer restart success\");\n+  }\n+\n+  /**\n+   * Stop a configured cluster by patching the resource definition with \n+   *  spec/clusters/1/serverStartPolicy set to NEVER.\n+   * Make sure that only server(s) in the configured cluster are stopped. \n+   * Make sure that server(s) in the dynamic cluster are in RUNNING state. \n+   * Restart the cluster by patching the resource definition with \n+   *  spec/clusters/1/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that servers in the configured cluster are in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the configured cluster with serverStartPolicy\")\n+  public void testConfigClusterRestart() {\n+\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+    String dynamicServerPodName = domainUid + \"-managed-server1\";\n+\n+    DateTime dynTs = getPodCreationTime(domainNamespace, dynamicServerPodName);\n+\n+    checkPodReadyAndServiceExists(configServerPodName, \n+              domainUid, domainNamespace);\n+    logger.info(\"(BeforePatch) configured cluster managed server is RUNNING\");\n+\n+    patchServerStartPolicy(\"/spec/clusters/1/serverStartPolicy\", \"NEVER\");\n+    logger.info(\"Domain is patched to shutdown configured cluster\");\n+\n+    checkPodDeleted(configServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Config cluster shutdown success\");\n+\n+    // check managed server from other cluster are not affected\n+    logger.info(\"Check dynamic managed server pods are not affected\");\n+    DateTime dynTs2 = getPodCreationTime(domainNamespace, dynamicServerPodName);\n+    assertTrue(\n+        dynTs2.withTimeAtStartOfDay().isEqual(dynTs.withTimeAtStartOfDay()),\n+        \"Dynamic managed server pod creation time must be same\");\n+\n+    patchServerStartPolicy(\"/spec/clusters/1/serverStartPolicy\", \"IF_NEEDED\");\n+    logger.info(\"Domain is patched to start configured cluster\");\n+\n+    checkPodReadyAndServiceExists(configServerPodName, \n+              domainUid, domainNamespace);\n+    logger.info(\"Configured cluster restart success\");\n+  }\n+\n+  /**\n+   * Stop a dynamic cluster by patching the resource definition with \n+   *  spec/clusters/1/serverStartPolicy set to NEVER.\n+   * Make sure that only servers in the dynamic cluster are stopped. \n+   * Make sure that only servers in the configured cluster are in the \n+   * RUNNING state. \n+   * Restart the dynamic cluster by patching the resource definition with \n+   *  spec/clusters/1/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that servers in the dynamic cluster are in RUNNING state again. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the dynamic cluster with serverStartPolicy\")\n+  public void testDynamicClusterRestart() {\n+\n+    String dynamicServerPodName = domainUid + \"-managed-server1\";\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+\n+    DateTime cfgTs = getPodCreationTime(domainNamespace, configServerPodName);\n+\n+    checkPodReadyAndServiceExists(dynamicServerPodName, \n+              domainUid, domainNamespace);\n+    logger.info(\"(BeforePatch) dynamic cluster managed server is RUNNING\");\n+\n+    patchServerStartPolicy(\"/spec/clusters/0/serverStartPolicy\", \"NEVER\");\n+    logger.info(\"Domain is patched to stop dynamic cluster\");\n+\n+    checkPodDeleted(dynamicServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Dynamic cluster shutdown success\");\n+\n+    // check managed server from other cluster are not affected\n+    logger.info(\"Check configured managed server pods are not affected\");\n+    DateTime cfgTs2 = getPodCreationTime(domainNamespace, configServerPodName);\n+    assertTrue(\n+        cfgTs2.withTimeAtStartOfDay().isEqual(cfgTs.withTimeAtStartOfDay()),\n+        \"Configured managed server pod creation time must be same\");\n+\n+    patchServerStartPolicy(\"/spec/clusters/0/serverStartPolicy\", \"IF_NEEDED\");\n+    logger.info(\"Domain is patched to start dynamic cluster\");\n+\n+    checkPodReadyAndServiceExists(dynamicServerPodName, \n+              domainUid, domainNamespace);\n+    logger.info(\"Dynamic cluster restart success\");\n+  }\n+\n+  /**\n+   * Stop the entire domain by patching the resource definition with \n+   *  spec/serverStartPolicy set to NEVER.\n+   * Make sure that all servers in the domain are stopped. \n+   * Restart the domain by patching the resource definition with \n+   *  spec/serverStartPolicy set to ADMIN_ONLY.\n+   * Make sure that ONLY Admin Server is in RUNNING state. \n+   * Restart the domain by patching the resource definition with \n+   *  spec/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that all servers in the domain are in RUNNING state. \n+   */\n+  @Test\n+  @DisplayName(\"Restart the Domain with serverStartPolicy\")\n+  public void testDomainRestart() {\n+\n+    String configServerPodName = domainUid + \"-config-cluster-server1\";\n+    String standaloneServerPodName = domainUid + \"-standalone-managed\";\n+\n+    patchServerStartPolicy(\"/spec/serverStartPolicy\", \"NEVER\");\n+    logger.info(\"Domain is patched to stop entire WebLogic domain\");\n+   \n+    // make sure all the server pods are removed after patch\n+    checkPodDeleted(adminServerPodName, domainUid, domainNamespace);\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodDeleted(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+    checkPodDeleted(configServerPodName, domainUid, domainNamespace);\n+    checkPodDeleted(standaloneServerPodName, domainUid, domainNamespace);\n+    logger.info(\"!!! Domain shutdown (NEVER) success !!!\");\n+\n+    // Patch the Domain with serverStartPolicy set to ADMIN_ONLY\n+    // Here only Admin server pod should come up\n+    patchServerStartPolicy(\"/spec/serverStartPolicy\", \"ADMIN_ONLY\");\n+    logger.info(\"Domain is patched to start only administrative server\");\n+\n+    checkPodReadyAndServiceExists(adminServerPodName, \n+             domainUid, domainNamespace);\n+    // make sure all other managed server pods are not provisioned \n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodDeleted(managedServerPrefix + i, domainUid, domainNamespace);\n+    }\n+    checkPodDeleted(configServerPodName, domainUid, domainNamespace);\n+    checkPodDeleted(standaloneServerPodName, domainUid, domainNamespace);\n+\n+    logger.info(\"!!! Domain restart (ADMIN_ONLY) success !!!\");\n+\n+    // Patch the Domain with serverStartPolicy set to IF_NEEDED\n+    // Here all the Servers should come up\n+    patchServerStartPolicy(\"/spec/serverStartPolicy\", \"IF_NEEDED\");\n+    logger.info(\"Domain is patched to start all servers in the domain\");\n+\n+    // check dynamic managed server pods are ready\n+    for (int i = 1; i <= replicaCount; i++) {\n+      checkPodReadyAndServiceExists(managedServerPrefix + i, \n+           domainUid, domainNamespace);\n+    }\n+\n+    checkPodReadyAndServiceExists(configServerPodName, \n+          domainUid, domainNamespace);\n+    checkPodReadyAndServiceExists(standaloneServerPodName, \n+          domainUid, domainNamespace);\n+    logger.info(\"!!! Domain restart (IF_NEEDED) success !!!\");\n+  }\n+\n+  /**\n+   * Add a second managed server (config-cluster-server2) in a configured \n+   * cluster with serverStartPolicy IF_NEEDED. \n+   * Initially, the server will not come up since the replica count is set to 1.\n+   * Update the serverStartPolicy for config-cluster-server2 to ALWAYS\n+   * by patching the resource definition with \n+   *  spec/managedServers/1/serverStartPolicy set to ALWAYS.\n+   * Make sure that managed server config-cluster-server2 is up and running\n+   * Stop the managed server by patching the resource definition \n+   *   with spec/managedServers/1/serverStartPolicy set to IF_NEEDED.\n+   * Make sure the specified managed server is stopped as per replica count.\n+   */\n+\n+  @Test\n+  @DisplayName(\"Start/stop config cluster managed server by updating serverStartPolicy to ALWAYS/IF_NEEDED\")\n+  public void testConfigClusterStartServerUsingAlways() {\n+    String serverPodName = domainUid + \"-config-cluster-server2\";\n+\n+    // Make sure that managed server is not running \n+    checkPodDeleted(serverPodName, domainUid, domainNamespace);\n+\n+    patchServerStartPolicy(\n+         \"/spec/managedServers/1/serverStartPolicy\", \"ALWAYS\");\n+    logger.info(\"Domain is patched to start configured cluster managed server\");\n+\n+    checkPodReadyAndServiceExists(serverPodName, \n+          domainUid, domainNamespace);\n+    logger.info(\"Configured cluster managed server is RUNNING\");\n+\n+    patchServerStartPolicy(\n+         \"/spec/managedServers/1/serverStartPolicy\", \"IF_NEEDED\");\n+    logger.info(\"Domain is patched to stop configured cluster managed server\");\n+\n+    logger.info(\"Wait for managed server ${0} to be shutdown\", serverPodName);\n+    checkPodDeleted(serverPodName, domainUid, domainNamespace);\n+    logger.info(\"Config cluster managed server shutdown success\");\n+  }\n+\n+  /**\n+   * Add managed server configuration (managed-server2) to CRD in a dynamic \n+   * cluster with ServerStartPolicy IF_NEEDED. \n+   * So initially, the server will not come up since replica count is set to 1.\n+   * Update the ServerStartPolicy for managed-server2 to ALWAYS\n+   * by patching the resource definition with \n+   *  spec/managedServers/2/serverStartPolicy set to ALWAYS.\n+   * Make sure that managed server managed-server2 is up and running\n+   * Stop the managed server by patching the resource definition \n+   *   with spec/managedServers/2/serverStartPolicy set to IF_NEEDED.\n+   * Make sure the specified managed server is stopped as per replica count.\n+   */\n+\n+  @Test\n+  @DisplayName(\"Start/stop dynamic cluster managed server by updating serverStartPolicy to ALWAYS/IF_NEEDED\")\n+  public void testDynamicClusterStartServerUsingAlways() {\n+    String serverPodName = domainUid + \"-managed-server2\";\n+\n+    // Make sure that managed server is not running \n+    checkPodDeleted(serverPodName, domainUid, domainNamespace);\n+    \n+    patchServerStartPolicy(\"/spec/managedServers/2/serverStartPolicy\", \n+                           \"ALWAYS\");\n+    logger.info(\"Domain resource patched to start the managed server\");\n+    checkPodReadyAndServiceExists(serverPodName, \n+          domainUid, domainNamespace);\n+    logger.info(\"Config cluster managed server is RUNNING\");\n+\n+    patchServerStartPolicy(\"/spec/managedServers/2/serverStartPolicy\", \n+                           \"IF_NEEDED\");\n+    logger.info(\"Domain resource patched to shutdown the managed server\");\n+\n+    logger.info(\"Wait for managed server ${0} to be shutdown\", serverPodName);\n+    checkPodDeleted(serverPodName, domainUid, domainNamespace);\n+    logger.info(\"Dynamic cluster managed server shutdown success\");\n+  }\n+\n+  /**\n+   * Add the first managed server (config-cluster-server1) in a configured \n+   * cluster with serverStartPolicy IF_NEEDED. \n+   * Initially, the server will come up since the replica count is set to 1.\n+   * (a) Update the serverStartPolicy for config-cluster-server1 to NEVER\n+   *      by patching the resource definition with \n+   *        spec/managedServers/3/serverStartPolicy set to NEVER.\n+   *     Make sure that managed server config-cluster-server1 is shutdown.\n+   *     Make sure that managed server config-cluster-server2 comes up\n+   *       to maintain the replica count of 1.\n+   * (b) Update the serverStartPolicy for config-cluster-server1 to IF_NEEDED\n+   *       by patching the resource definition with \n+   *       spec/managedServers/3/serverStartPolicy set to IF_NEEDED.\n+   *     Make sure that managed server config-cluster-server2 is shutdown.\n+   *     Make sure that managed server config-cluster-server1 comes up\n+   *       to maintain the replica count of 1.\n+   */\n+  @Test\n+  @DisplayName(\"Stop a running config cluster managed server and verify the replica count is maintained\")\n+  public void testConfigClusterReplicaCountIsMaintained() {\n+    String serverPodName = domainUid + \"-config-cluster-server1\";\n+    String serverPodName2 = domainUid + \"-config-cluster-server2\";\n+\n+    // Make sure that managed server(2) is not running \n+    checkPodDeleted(serverPodName2, domainUid, domainNamespace);\n+\n+    // Patch(Shutdown) the config-cluster-server1 \n+    patchServerStartPolicy(\n+         \"/spec/managedServers/3/serverStartPolicy\", \"NEVER\");\n+    logger.info(\"Domain is patched to shutdown cluster managed server\");\n+\n+    // Make sure config-cluster-server1 is deleted \n+    checkPodDeleted(serverPodName, domainUid, domainNamespace);\n+    // Make sure  config-cluster-server2 is started \n+    checkPodReadyAndServiceExists(serverPodName2, domainUid, domainNamespace);\n+    logger.info(\"Configured cluster managed Server(2) is RUNNING\");\n+\n+    // Patch(start) the config-cluster-server1 \n+    patchServerStartPolicy(\n+         \"/spec/managedServers/3/serverStartPolicy\", \"IF_NEEDED\");\n+\n+    // Make sure config-cluster-server2 is deleted \n+    checkPodDeleted(serverPodName2, domainUid, domainNamespace);\n+\n+    // Make sure config-cluster-server1 is re-started\n+    checkPodReadyAndServiceExists(serverPodName, domainUid, domainNamespace);\n+  }\n+\n+  /**\n+   * Add the first managed server (managed-server1) in a dynamic \n+   * cluster with serverStartPolicy IF_NEEDED. \n+   * Initially, the server will come up since the replica count is set to 1.\n+   * (a) Update the serverStartPolicy for managed-server1 to NEVER\n+   *      by patching the resource definition with \n+   *        spec/managedServers/4/serverStartPolicy set to NEVER.\n+   *     Make sure that managed server managed-server1 is shutdown.\n+   *     Make sure that managed server managed-server2 comes up\n+   *       to maintain the replica count of 1.\n+   * (b) Update the serverStartPolicy for managed-server1 to IF_NEEDED\n+   *       by patching the resource definition with \n+   *       spec/managedServers/4/serverStartPolicy set to IF_NEEDED.\n+   *     Make sure that managed server managed-server2 is shutdown.\n+   *     Make sure that managed server managed-server1 comes up\n+   *       to maintain the replica count of 1.\n+   */\n+  @Test\n+  @DisplayName(\"Stop a running dynamic cluster managed server and verify the replica count \")\n+  public void testDynamicClusterReplicaCountIsMaintained() {\n+    String serverPodName = domainUid + \"-managed-server1\";\n+    String serverPodName2 = domainUid + \"-managed-server2\";\n+\n+    // Make sure that managed server(2) is not running \n+    checkPodDeleted(serverPodName2, domainUid, domainNamespace);\n+\n+    // Patch(Shutdown) the managed-server1 \n+    patchServerStartPolicy(\n+         \"/spec/managedServers/4/serverStartPolicy\", \"NEVER\");\n+    logger.info(\"Domain is patched to shutdown dynamic managed server\");\n+\n+    // Make sure maanged-server1 is deleted \n+    checkPodDeleted(serverPodName, domainUid, domainNamespace);\n+    checkPodReadyAndServiceExists(serverPodName2, domainUid, domainNamespace);\n+    logger.info(\"Dynamic cluster managed server(2) is RUNNING\");\n+\n+    // Patch(start) the managed-server1 \n+    patchServerStartPolicy(\n+         \"/spec/managedServers/4/serverStartPolicy\", \"IF_NEEDED\");\n+    logger.info(\"Domain is patched to start dynamic managed server\");\n+\n+    // Make sure managed-server2 is deleted \n+    checkPodDeleted(serverPodName2, domainUid, domainNamespace);\n+\n+    // Make sure managed-server1 is re-started\n+    checkPodReadyAndServiceExists(serverPodName, domainUid, domainNamespace);\n+  }\n+\n+  /**\n+   * Start independent managed server by setting serverStartPolicy to IF_NEEDED.\n+   * Stop an independent managed server by patching the resource definition with \n+   *  spec/managedServers/0/serverStartPolicy set to NEVER.\n+   * Make sure that ONLY the specified managed server is stopped. \n+   * Restart the independent managed server by patching the resource definition \n+   * with spec/managedServers/0/serverStartPolicy set to ALWAYS.\n+   * Make sure that the specified managed server is in RUNNING state.\n+   */\n+\n+  // The usecase fails NEVER->ALWAYS\n+  // https://bug.oraclecorp.com/pls/bug/webbug_print.show?c_rptno=31833260\n+  @Disabled\n+  @Test\n+  @DisplayName(\"Restart the standalone managed server with serverStartPolicy\")\n+  public void testStandaloneManagedRestartAlways() {\n+\n+    String configServerPodName = domainUid + \"-standalone-managed\";\n+\n+    // Make sure that configured managed server is ready \n+    checkPodReadyAndServiceExists(configServerPodName, \n+            domainUid, domainNamespace);\n+    logger.info(\"Configured managed server is RUNNING\");\n+\n+    patchServerStartPolicy(\n+         \"/spec/managedServers/0/serverStartPolicy\", \"NEVER\");\n+    logger.info(\"Domain is patched to shutdown standalone managed server\");\n+\n+    checkPodDeleted(configServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Configured managed server shutdown success\");\n+\n+    patchServerStartPolicy(\n+         \"/spec/managedServers/0/serverStartPolicy\", \"ALWAYS\");\n+    logger.info(\"Domain is patched to start standalone managed server\");\n+\n+    checkPodReadyAndServiceExists(configServerPodName, \n+            domainUid, domainNamespace);\n+    logger.info(\"Configured managed server restart success\");\n+  }\n+\n+  /**\n+   * Start independent managed server by setting serverStartPolicy to IF_NEEDED.\n+   * Stop an independent managed server by patching the resource definition with \n+   *  spec/managedServers/0/serverStartPolicy set to NEVER.\n+   * Make sure that ONLY the specified managed server is stopped. \n+   * Restart the independent managed server by patching the resource definition \n+   * with spec/managedServers/0/serverStartPolicy set to IF_NEEDED.\n+   * Make sure that the specified managed server is in RUNNING state.\n+   */\n+\n+  // The usecase fails NEVER->IF_NEEDED\n+  // https://bug.oraclecorp.com/pls/bug/webbug_print.show?c_rptno=31833260\n+  @Disabled\n+  @Test\n+  @DisplayName(\"Restart the standalone managed server with serverStartPolicy\")\n+  public void testStandaloneManagedRestartIfNeeded() {\n+\n+    String configServerPodName = domainUid + \"-standalone-managed\";\n+\n+    // Make sure that configured managed server is ready \n+    checkPodReadyAndServiceExists(configServerPodName, \n+            domainUid, domainNamespace);\n+    logger.info(\"Standalone managed server is RUNNING\");\n+\n+    patchServerStartPolicy(\n+         \"/spec/managedServers/0/serverStartPolicy\", \"NEVER\");\n+    logger.info(\"Domain is patched to shutdown standalone managed server\");\n+\n+    checkPodDeleted(configServerPodName, domainUid, domainNamespace);\n+    logger.info(\"Standalone managed server shutdown success\");\n+\n+    patchServerStartPolicy(\n+         \"/spec/managedServers/0/serverStartPolicy\", \"IF_NEEDED\");\n+    logger.info(\"Domain is patched to start standalone managed server\");\n+\n+    checkPodReadyAndServiceExists(configServerPodName, \n+            domainUid, domainNamespace);\n+    logger.info(\"Standalone managed server restart success\");\n+  }\n+\n+  // This method is needed in this test class, since the cleanup util\n+  // won't clean up the images.\n+  @AfterAll\n+  void tearDown() {\n+    // Delete domain custom resource\n+    logger.info(\"Delete domain custom resource in namespace {0}\", domainNamespace);", "originalCommit": "477d31dc279356f5719d8dfacb9e6baffc202146", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0OTQwMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1895#discussion_r483749403", "bodyText": "removed tearDown()) method", "author": "anpanigr", "createdAt": "2020-09-04T17:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM0OTQ0Mw=="}], "type": "inlineReview"}, {"oid": "7eb67be8424afec5d03bcc9b7cbcd451845999c8", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/7eb67be8424afec5d03bcc9b7cbcd451845999c8", "message": "More review comments", "committedDate": "2020-09-04T16:58:42Z", "type": "commit"}, {"oid": "fdec5c571cd857419388e9fc443dedd2f540ed87", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/fdec5c571cd857419388e9fc443dedd2f540ed87", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into start-policy", "committedDate": "2020-09-04T16:58:54Z", "type": "commit"}]}