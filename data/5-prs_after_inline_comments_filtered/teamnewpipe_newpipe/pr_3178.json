{"pr_number": 3178, "pr_title": "Notification Improvements", "pr_createdAt": "2020-03-03T00:08:39Z", "pr_url": "https://github.com/TeamNewPipe/NewPipe/pull/3178", "timeline": [{"oid": "ac280ab1c47ea84884da4b8dd95deb5759233cae", "url": "https://github.com/TeamNewPipe/NewPipe/commit/ac280ab1c47ea84884da4b8dd95deb5759233cae", "message": "Notification Improvements\n- add MediaStyle notifications for Background and Popup playback\n- reduce excessive notification updating ( / recreating of Notification.Builder object) when playing background / popup media\n- add new buffering state indicator (can be disabled)\n- upscale close icon / downscale replay icon\n- add notification slot settings\n- move notification settings to appearance\n- fix Metadata (song title, artist and album art) sometimes not being set correctly\n- other misc notification fixes", "committedDate": "2020-05-14T14:40:56Z", "type": "forcePushed"}, {"oid": "db480bcbcb93f4a164bb2fa47d47e4834f1f92f8", "url": "https://github.com/TeamNewPipe/NewPipe/commit/db480bcbcb93f4a164bb2fa47d47e4834f1f92f8", "message": "Use vector drawables for close and replay", "committedDate": "2020-05-14T15:08:36Z", "type": "forcePushed"}, {"oid": "51b23ec55a3b0ef4cecd70cf9c348a5d13a9baeb", "url": "https://github.com/TeamNewPipe/NewPipe/commit/51b23ec55a3b0ef4cecd70cf9c348a5d13a9baeb", "message": "Log only in debug build", "committedDate": "2020-05-15T13:05:20Z", "type": "forcePushed"}, {"oid": "bbad733208f6599e3b7d0e96f2fe1566bccb1d3b", "url": "https://github.com/TeamNewPipe/NewPipe/commit/bbad733208f6599e3b7d0e96f2fe1566bccb1d3b", "message": "Log only in debug build", "committedDate": "2020-07-16T12:43:13Z", "type": "forcePushed"}, {"oid": "4abf6b2f5cb7fe38b0f3b4cc13e48c46b0725a2e", "url": "https://github.com/TeamNewPipe/NewPipe/commit/4abf6b2f5cb7fe38b0f3b4cc13e48c46b0725a2e", "message": "Notification Improvements\n- add MediaStyle notifications for Background and Popup playback\n- reduce excessive notification updating ( / recreating of Notification.Builder object) when playing background / popup media\n- add new buffering state indicator (can be disabled)\n- upscale close icon / downscale replay icon\n- add notification slot settings\n- move notification settings to appearance\n- fix Metadata (song title, artist and album art) sometimes not being set correctly\n- other misc notification fixes\n\nCo-authored-by: wb9688 <wb9688@users.noreply.github.com>", "committedDate": "2020-07-31T07:10:28Z", "type": "commit"}, {"oid": "7d499ffba1dd14b7c9610527a8f23e48d9b7fd2b", "url": "https://github.com/TeamNewPipe/NewPipe/commit/7d499ffba1dd14b7c9610527a8f23e48d9b7fd2b", "message": "Use vector drawables for close and replay", "committedDate": "2020-07-31T07:10:28Z", "type": "commit"}, {"oid": "caf7c55069804dce58b4be8e9df5b8211ae5ac78", "url": "https://github.com/TeamNewPipe/NewPipe/commit/caf7c55069804dce58b4be8e9df5b8211ae5ac78", "message": "Log only in debug build", "committedDate": "2020-07-31T07:10:28Z", "type": "commit"}, {"oid": "6de03f2bf0bf328fccf29bd7dd0d2407b0e1ed9b", "url": "https://github.com/TeamNewPipe/NewPipe/commit/6de03f2bf0bf328fccf29bd7dd0d2407b0e1ed9b", "message": "Fix crash when playing stream in background with shuffle in notification", "committedDate": "2020-07-31T07:25:32Z", "type": "commit"}, {"oid": "6de03f2bf0bf328fccf29bd7dd0d2407b0e1ed9b", "url": "https://github.com/TeamNewPipe/NewPipe/commit/6de03f2bf0bf328fccf29bd7dd0d2407b0e1ed9b", "message": "Fix crash when playing stream in background with shuffle in notification", "committedDate": "2020-07-31T07:25:32Z", "type": "forcePushed"}, {"oid": "963ee4dbab203975ce4fcfbc343222a50df47c29", "url": "https://github.com/TeamNewPipe/NewPipe/commit/963ee4dbab203975ce4fcfbc343222a50df47c29", "message": "Merge branch 'dev' into pr3178", "committedDate": "2020-08-02T20:59:43Z", "type": "commit"}, {"oid": "1a8ff8108709f15228712ad2942919d5c38662fa", "url": "https://github.com/TeamNewPipe/NewPipe/commit/1a8ff8108709f15228712ad2942919d5c38662fa", "message": "Use AppCompatImageButton to not crash on 4.4", "committedDate": "2020-08-03T12:17:12Z", "type": "commit"}, {"oid": "adef9a8acfd8a141ac0393be16ba3d7ac619a3f4", "url": "https://github.com/TeamNewPipe/NewPipe/commit/adef9a8acfd8a141ac0393be16ba3d7ac619a3f4", "message": "Rename notification functions: they are not background player only", "committedDate": "2020-08-15T13:16:17Z", "type": "commit"}, {"oid": "e08480f34532daca4c8f432ef902454869b1a719", "url": "https://github.com/TeamNewPipe/NewPipe/commit/e08480f34532daca4c8f432ef902454869b1a719", "message": "Completely remove old player notification", "committedDate": "2020-08-15T20:03:32Z", "type": "commit"}, {"oid": "c79997ebe36a8ef46d5e402e2f649ae16347e883", "url": "https://github.com/TeamNewPipe/NewPipe/commit/c79997ebe36a8ef46d5e402e2f649ae16347e883", "message": "Show hourglass icon when buffering", "committedDate": "2020-09-03T19:54:28Z", "type": "commit"}, {"oid": "7766fd13fd2274eb8bbe2bbfdc9f9849587dc62d", "url": "https://github.com/TeamNewPipe/NewPipe/commit/7766fd13fd2274eb8bbe2bbfdc9f9849587dc62d", "message": "Extract hardcoded strings into strings.xml and improve them", "committedDate": "2020-09-03T19:54:31Z", "type": "commit"}, {"oid": "8b3a09306bb65625b07b955f1312d3486203a167", "url": "https://github.com/TeamNewPipe/NewPipe/commit/8b3a09306bb65625b07b955f1312d3486203a167", "message": "Various notification code improvements\n\nImprove builder parameters\nReorder code and extract large icon function\nservice.startForeground() now is also provided with service type in android versions >= Q", "committedDate": "2020-09-03T19:54:31Z", "type": "commit"}, {"oid": "97ff9e9c5b68d6087a765187fa6540bb18518af8", "url": "https://github.com/TeamNewPipe/NewPipe/commit/97ff9e9c5b68d6087a765187fa6540bb18518af8", "message": "Merge branch 'dev' into pr3178", "committedDate": "2020-09-03T19:56:48Z", "type": "commit"}, {"oid": "97ff9e9c5b68d6087a765187fa6540bb18518af8", "url": "https://github.com/TeamNewPipe/NewPipe/commit/97ff9e9c5b68d6087a765187fa6540bb18518af8", "message": "Merge branch 'dev' into pr3178", "committedDate": "2020-09-03T19:56:48Z", "type": "forcePushed"}, {"oid": "628575dc5f35ed6f6675223ca79493a199bb3f03", "url": "https://github.com/TeamNewPipe/NewPipe/commit/628575dc5f35ed6f6675223ca79493a199bb3f03", "message": "Clean up MediaSessionManager", "committedDate": "2020-09-04T16:44:09Z", "type": "commit"}, {"oid": "408e819d321951a060dbafafa7dbfd94295bf4dd", "url": "https://github.com/TeamNewPipe/NewPipe/commit/408e819d321951a060dbafafa7dbfd94295bf4dd", "message": "Extract duplicate setActivityTitle code to own function", "committedDate": "2020-09-07T13:28:38Z", "type": "commit"}, {"oid": "71b32fe64104eabd422b7aa4cea6b30e53c48d22", "url": "https://github.com/TeamNewPipe/NewPipe/commit/71b32fe64104eabd422b7aa4cea6b30e53c48d22", "message": "Add notification costumization settings menu", "committedDate": "2020-09-08T20:00:24Z", "type": "commit"}, {"oid": "9cf0bc6c82751b2c5c672fc143efde101ee013e9", "url": "https://github.com/TeamNewPipe/NewPipe/commit/9cf0bc6c82751b2c5c672fc143efde101ee013e9", "message": "Make notification creation and cancelling more consistent", "committedDate": "2020-09-08T20:00:28Z", "type": "commit"}, {"oid": "bc8954fbbafc737cd950a2b86fe89694d87f0120", "url": "https://github.com/TeamNewPipe/NewPipe/commit/bc8954fbbafc737cd950a2b86fe89694d87f0120", "message": "Fix notification content intent not being updated when needed", "committedDate": "2020-09-08T20:00:28Z", "type": "commit"}, {"oid": "bd34c7ede3a7e01b19e6f5a1a8f9944db231826f", "url": "https://github.com/TeamNewPipe/NewPipe/commit/bd34c7ede3a7e01b19e6f5a1a8f9944db231826f", "message": "Make player foreground playback-specific in manifest", "committedDate": "2020-09-08T20:00:28Z", "type": "commit"}, {"oid": "bd34c7ede3a7e01b19e6f5a1a8f9944db231826f", "url": "https://github.com/TeamNewPipe/NewPipe/commit/bd34c7ede3a7e01b19e6f5a1a8f9944db231826f", "message": "Make player foreground playback-specific in manifest", "committedDate": "2020-09-08T20:00:28Z", "type": "forcePushed"}, {"oid": "a13e6b69e3aec237a765aec9bc02cd7a3ca5a82c", "url": "https://github.com/TeamNewPipe/NewPipe/commit/a13e6b69e3aec237a765aec9bc02cd7a3ca5a82c", "message": "Merge branch 'dev' into pr3178", "committedDate": "2020-09-08T21:58:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI1MDgwMw==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3178#discussion_r486250803", "bodyText": "Is this done to prevent negative positions when using rewind? If this is the case, please add a comment in the code to clarify why the check is necessary.", "author": "TobiGr", "createdAt": "2020-09-10T11:03:59Z", "path": "app/src/main/java/org/schabi/newpipe/player/BasePlayer.java", "diffHunk": "@@ -1239,7 +1242,14 @@ public void seekTo(final long positionMillis) {\n             Log.d(TAG, \"seekBy() called with: position = [\" + positionMillis + \"]\");\n         }\n         if (simpleExoPlayer != null) {\n-            simpleExoPlayer.seekTo(positionMillis);\n+            long normalizedPositionMillis = positionMillis;\n+            if (normalizedPositionMillis < 0) {\n+                normalizedPositionMillis = 0;\n+            } else if (normalizedPositionMillis > simpleExoPlayer.getDuration()) {\n+                normalizedPositionMillis = simpleExoPlayer.getDuration();\n+            }\n+\n+            simpleExoPlayer.seekTo(normalizedPositionMillis);", "originalCommit": "be73e9c249ca49d95309f9ed7a0fa168fec46f81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI1NzI3Mw==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3178#discussion_r486257273", "bodyText": "Just use the MainActivity.DEBUG instead of doing the same check again.", "author": "TobiGr", "createdAt": "2020-09-10T11:16:48Z", "path": "app/src/main/java/org/schabi/newpipe/player/helper/MediaSessionManager.java", "diffHunk": "@@ -3,44 +3,58 @@\n import android.content.Context;\n import android.content.Intent;\n import android.graphics.Bitmap;\n-import android.media.MediaMetadata;\n-import android.os.Build;\n import android.support.v4.media.MediaMetadataCompat;\n import android.support.v4.media.session.MediaSessionCompat;\n+import android.support.v4.media.session.PlaybackStateCompat;\n+import android.util.Log;\n import android.view.KeyEvent;\n \n import androidx.annotation.NonNull;\n import androidx.annotation.Nullable;\n-import androidx.annotation.RequiresApi;\n-import androidx.core.app.NotificationCompat;\n-import androidx.media.app.NotificationCompat.MediaStyle;\n import androidx.media.session.MediaButtonReceiver;\n \n import com.google.android.exoplayer2.Player;\n import com.google.android.exoplayer2.ext.mediasession.MediaSessionConnector;\n \n+import org.schabi.newpipe.BuildConfig;\n import org.schabi.newpipe.player.mediasession.MediaSessionCallback;\n import org.schabi.newpipe.player.mediasession.PlayQueueNavigator;\n import org.schabi.newpipe.player.mediasession.PlayQueuePlaybackController;\n \n public class MediaSessionManager {\n     private static final String TAG = \"MediaSessionManager\";\n+    public static final boolean DEBUG = !BuildConfig.BUILD_TYPE.equals(\"release\");", "originalCommit": "be73e9c249ca49d95309f9ed7a0fa168fec46f81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1605e50cef85e54a7ff6faee6519ba13c45c0b74", "url": "https://github.com/TeamNewPipe/NewPipe/commit/1605e50cef85e54a7ff6faee6519ba13c45c0b74", "message": "Update notification when play queue is edited", "committedDate": "2020-09-10T11:36:34Z", "type": "commit"}, {"oid": "52e89c1d1cea4226ec25c0708ecd0dea75794108", "url": "https://github.com/TeamNewPipe/NewPipe/commit/52e89c1d1cea4226ec25c0708ecd0dea75794108", "message": "Prevent seeking out of video duration in player", "committedDate": "2020-09-10T17:47:02Z", "type": "commit"}, {"oid": "5846fbabce47554d5596433c80c77f55d1e86ed0", "url": "https://github.com/TeamNewPipe/NewPipe/commit/5846fbabce47554d5596433c80c77f55d1e86ed0", "message": "Change \"image\" to \"thumbnail\"", "committedDate": "2020-09-10T17:47:07Z", "type": "commit"}, {"oid": "3eef5d8d3825ca8ba15532584cd36964a345d0ce", "url": "https://github.com/TeamNewPipe/NewPipe/commit/3eef5d8d3825ca8ba15532584cd36964a345d0ce", "message": "Remove useless metadata updates and fix seekbar not updating\n\nManually setting metadata is not needed, since exoplayer's sessionconnector already takes care of this\nHave the notification recreate only when strictly necessary, and recreate it if there was a timeline change, fixing the seekbar not updating at all sometimes", "committedDate": "2020-09-10T17:47:07Z", "type": "forcePushed"}, {"oid": "bccfe500b39de8416f1deac9cc4a9468d8bf01cd", "url": "https://github.com/TeamNewPipe/NewPipe/commit/bccfe500b39de8416f1deac9cc4a9468d8bf01cd", "message": "Fix seekbar invisible or not updating\n\nHave the notification recreate only when strictly necessary, and recreate it if there was a timeline change, fixing the seekbar not updating at all sometimes", "committedDate": "2020-09-10T18:22:22Z", "type": "commit"}, {"oid": "2017e6a3e31d2a03a399c82f712001a8e3c01a05", "url": "https://github.com/TeamNewPipe/NewPipe/commit/2017e6a3e31d2a03a399c82f712001a8e3c01a05", "message": "Refactor MediaSessionManager", "committedDate": "2020-09-10T18:36:52Z", "type": "commit"}, {"oid": "2017e6a3e31d2a03a399c82f712001a8e3c01a05", "url": "https://github.com/TeamNewPipe/NewPipe/commit/2017e6a3e31d2a03a399c82f712001a8e3c01a05", "message": "Refactor MediaSessionManager", "committedDate": "2020-09-10T18:36:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEzODc0Mg==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3178#discussion_r486138742", "bodyText": "Just a question. Was this the reason for the missing metadata? Because it was overwritten here?", "author": "Redirion", "createdAt": "2020-09-10T07:54:54Z", "path": "app/src/main/java/org/schabi/newpipe/player/helper/MediaSessionManager.java", "diffHunk": "@@ -49,46 +63,82 @@ public KeyEvent handleMediaButtonIntent(final Intent intent) {\n         return MediaButtonReceiver.handleIntent(mediaSession, intent);\n     }\n \n-    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)\n-    public void setLockScreenArt(final NotificationCompat.Builder builder,\n-                                 @Nullable final Bitmap thumbnailBitmap) {\n-        if (thumbnailBitmap == null || !mediaSession.isActive()) {\n+    public MediaSessionCompat.Token getSessionToken() {\n+        return mediaSession.getSessionToken();\n+    }\n+\n+    public void setMetadata(final String title,\n+                            final String artist,\n+                            final Bitmap albumArt,\n+                            final long duration) {\n+        if (albumArt == null || !mediaSession.isActive()) {\n             return;\n         }\n \n-        mediaSession.setMetadata(\n-                new MediaMetadataCompat.Builder()\n-                        .putBitmap(MediaMetadata.METADATA_KEY_ALBUM_ART, thumbnailBitmap)\n-                        .build()", "originalCommit": "be73e9c249ca49d95309f9ed7a0fa168fec46f81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwNTg3Ng==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3178#discussion_r487205876", "bodyText": "I can't help you with this, as this part was done by @cool-student. But I think you are right, and the issue was about inconsistent metadata updates not containing every piece of information", "author": "Stypox", "createdAt": "2020-09-11T18:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEzODc0Mg=="}], "type": "inlineReview"}, {"oid": "59e7ebabfa1514607e2ae0584539b8a021cbdce9", "url": "https://github.com/TeamNewPipe/NewPipe/commit/59e7ebabfa1514607e2ae0584539b8a021cbdce9", "message": "Random adjustements to notification", "committedDate": "2020-09-16T12:00:22Z", "type": "commit"}, {"oid": "7317737e90ef096fd72b3d1df1e16d04ff2d1d06", "url": "https://github.com/TeamNewPipe/NewPipe/commit/7317737e90ef096fd72b3d1df1e16d04ff2d1d06", "message": "Fix invisible queue close button", "committedDate": "2020-09-19T11:44:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE5NjQwNw==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3178#discussion_r492196407", "bodyText": "The action titles need to be localized for better accessibility.", "author": "TobiGr", "createdAt": "2020-09-21T16:34:15Z", "path": "app/src/main/java/org/schabi/newpipe/player/NotificationUtil.java", "diffHunk": "@@ -0,0 +1,368 @@\n+package org.schabi.newpipe.player;\n+\n+import android.annotation.SuppressLint;\n+import android.app.PendingIntent;\n+import android.app.Service;\n+import android.content.Intent;\n+import android.content.pm.ServiceInfo;\n+import android.graphics.Bitmap;\n+import android.graphics.Matrix;\n+import android.os.Build;\n+import android.util.Log;\n+\n+import androidx.annotation.DrawableRes;\n+import androidx.annotation.Nullable;\n+import androidx.core.app.NotificationCompat;\n+import androidx.core.app.NotificationManagerCompat;\n+import androidx.core.content.ContextCompat;\n+\n+import org.schabi.newpipe.MainActivity;\n+import org.schabi.newpipe.R;\n+import org.schabi.newpipe.util.NavigationHelper;\n+\n+import java.util.List;\n+\n+import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;\n+import static com.google.android.exoplayer2.Player.REPEAT_MODE_ALL;\n+import static com.google.android.exoplayer2.Player.REPEAT_MODE_ONE;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_BUFFERING;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_CLOSE;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_FAST_FORWARD;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_FAST_REWIND;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_PLAY_NEXT;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_PLAY_PAUSE;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_PLAY_PREVIOUS;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_REPEAT;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_SHUFFLE;\n+\n+/**\n+ * This is a utility class for player notifications.\n+ *\n+ * @author cool-student\n+ */\n+public final class NotificationUtil {\n+    private static final String TAG = NotificationUtil.class.getSimpleName();\n+    private static final boolean DEBUG = BasePlayer.DEBUG;\n+    private static final int NOTIFICATION_ID = 123789;\n+\n+    @Nullable private static NotificationUtil instance = null;\n+\n+    @NotificationConstants.Action\n+    private int[] notificationSlots = NotificationConstants.SLOT_DEFAULTS.clone();\n+\n+    private NotificationManagerCompat notificationManager;\n+    private NotificationCompat.Builder notificationBuilder;\n+\n+    private NotificationUtil() {\n+    }\n+\n+    public static NotificationUtil getInstance() {\n+        if (instance == null) {\n+            instance = new NotificationUtil();\n+        }\n+        return instance;\n+    }\n+\n+\n+    /////////////////////////////////////////////////////\n+    // NOTIFICATION\n+    /////////////////////////////////////////////////////\n+\n+    /**\n+     * Creates the notification if it does not exist already and recreates it if forceRecreate is\n+     * true. Updates the notification with the data in the player.\n+     * @param player the player currently open, to take data from\n+     * @param forceRecreate whether to force the recreation of the notification even if it already\n+     *                      exists\n+     */\n+    synchronized void createNotificationIfNeededAndUpdate(final VideoPlayerImpl player,\n+                                                          final boolean forceRecreate) {\n+        if (forceRecreate || notificationBuilder == null) {\n+            notificationBuilder = createNotification(player);\n+        }\n+        updateNotification(player);\n+        notificationManager.notify(NOTIFICATION_ID, notificationBuilder.build());\n+    }\n+\n+    private synchronized NotificationCompat.Builder createNotification(\n+            final VideoPlayerImpl player) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"createNotification()\");\n+        }\n+        notificationManager = NotificationManagerCompat.from(player.context);\n+        final NotificationCompat.Builder builder = new NotificationCompat.Builder(player.context,\n+                player.context.getString(R.string.notification_channel_id));\n+\n+        initializeNotificationSlots(player);\n+\n+        // count the number of real slots, to make sure compact slots indices are not out of bound\n+        int nonNothingSlotCount = 5;\n+        if (notificationSlots[3] == NotificationConstants.NOTHING) {\n+            --nonNothingSlotCount;\n+        }\n+        if (notificationSlots[4] == NotificationConstants.NOTHING) {\n+            --nonNothingSlotCount;\n+        }\n+\n+        // build the compact slot indices array (need code to convert from Integer... because Java)\n+        final List<Integer> compactSlotList = NotificationConstants.getCompactSlotsFromPreferences(\n+                player.context, player.sharedPreferences, nonNothingSlotCount);\n+        final int[] compactSlots = new int[compactSlotList.size()];\n+        for (int i = 0; i < compactSlotList.size(); i++) {\n+            compactSlots[i] = compactSlotList.get(i);\n+        }\n+\n+        builder.setStyle(new androidx.media.app.NotificationCompat.MediaStyle()\n+                    .setMediaSession(player.mediaSessionManager.getSessionToken())\n+                    .setShowActionsInCompactView(compactSlots))\n+                .setPriority(NotificationCompat.PRIORITY_HIGH)\n+                .setSmallIcon(R.drawable.ic_newpipe_triangle_white)\n+                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n+                .setColor(ContextCompat.getColor(player.context, R.color.gray))\n+                .setCategory(NotificationCompat.CATEGORY_TRANSPORT)\n+                .setDeleteIntent(PendingIntent.getBroadcast(player.context, NOTIFICATION_ID,\n+                        new Intent(ACTION_CLOSE), FLAG_UPDATE_CURRENT));\n+\n+        return builder;\n+    }\n+\n+    /**\n+     * Updates the notification builder and the button icons depending on the playback state.\n+     * @param player the player currently open, to take data from\n+     */\n+    private synchronized void updateNotification(final VideoPlayerImpl player) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"updateNotification()\");\n+        }\n+\n+        // also update content intent, in case the user switched players\n+        notificationBuilder.setContentIntent(PendingIntent.getActivity(player.context,\n+                NOTIFICATION_ID, getIntentForNotification(player), FLAG_UPDATE_CURRENT));\n+        notificationBuilder.setContentTitle(player.getVideoTitle());\n+        notificationBuilder.setContentText(player.getUploaderName());\n+        notificationBuilder.setTicker(player.getVideoTitle());\n+        updateActions(notificationBuilder, player);\n+        setLargeIcon(notificationBuilder, player);\n+    }\n+\n+\n+    boolean hasSlotWithBuffering() {\n+        return notificationSlots[1] == NotificationConstants.PLAY_PAUSE_BUFFERING\n+                || notificationSlots[2] == NotificationConstants.PLAY_PAUSE_BUFFERING;\n+    }\n+\n+\n+    void createNotificationAndStartForeground(final VideoPlayerImpl player, final Service service) {\n+        if (notificationBuilder == null) {\n+            notificationBuilder = createNotification(player);\n+        }\n+        updateNotification(player);\n+\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n+            service.startForeground(NOTIFICATION_ID, notificationBuilder.build(),\n+                    ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK);\n+        } else {\n+            service.startForeground(NOTIFICATION_ID, notificationBuilder.build());\n+        }\n+    }\n+\n+    void cancelNotificationAndStopForeground(final Service service) {\n+        service.stopForeground(true);\n+\n+        if (notificationManager != null) {\n+            notificationManager.cancel(NOTIFICATION_ID);\n+        }\n+        notificationManager = null;\n+        notificationBuilder = null;\n+    }\n+\n+\n+    /////////////////////////////////////////////////////\n+    // ACTIONS\n+    /////////////////////////////////////////////////////\n+\n+    private void initializeNotificationSlots(final VideoPlayerImpl player) {\n+        for (int i = 0; i < 5; ++i) {\n+            notificationSlots[i] = player.sharedPreferences.getInt(\n+                    player.context.getString(NotificationConstants.SLOT_PREF_KEYS[i]),\n+                    NotificationConstants.SLOT_DEFAULTS[i]);\n+        }\n+    }\n+\n+    @SuppressLint(\"RestrictedApi\")\n+    private void updateActions(final NotificationCompat.Builder builder,\n+                               final VideoPlayerImpl player) {\n+        builder.mActions.clear();\n+        for (int i = 0; i < 5; ++i) {\n+            addAction(builder, player, notificationSlots[i]);\n+        }\n+    }\n+\n+    private void addAction(final NotificationCompat.Builder builder,\n+                           final VideoPlayerImpl player,\n+                           @NotificationConstants.Action final int slot) {\n+        final NotificationCompat.Action action = getAction(player, slot);\n+        if (action != null) {\n+            builder.addAction(action);\n+        }\n+    }\n+\n+    @Nullable\n+    private NotificationCompat.Action getAction(\n+            final VideoPlayerImpl player,\n+            @NotificationConstants.Action final int selectedAction) {\n+        final int baseActionIcon = NotificationConstants.ACTION_ICONS[selectedAction];\n+        switch (selectedAction) {\n+            case NotificationConstants.PREVIOUS:\n+                return getAction(player, baseActionIcon, \"Previous\", ACTION_PLAY_PREVIOUS);", "originalCommit": "7317737e90ef096fd72b3d1df1e16d04ff2d1d06", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE5NjU3Ng==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3178#discussion_r492196576", "bodyText": "Same here", "author": "TobiGr", "createdAt": "2020-09-21T16:34:32Z", "path": "app/src/main/java/org/schabi/newpipe/player/NotificationUtil.java", "diffHunk": "@@ -0,0 +1,368 @@\n+package org.schabi.newpipe.player;\n+\n+import android.annotation.SuppressLint;\n+import android.app.PendingIntent;\n+import android.app.Service;\n+import android.content.Intent;\n+import android.content.pm.ServiceInfo;\n+import android.graphics.Bitmap;\n+import android.graphics.Matrix;\n+import android.os.Build;\n+import android.util.Log;\n+\n+import androidx.annotation.DrawableRes;\n+import androidx.annotation.Nullable;\n+import androidx.core.app.NotificationCompat;\n+import androidx.core.app.NotificationManagerCompat;\n+import androidx.core.content.ContextCompat;\n+\n+import org.schabi.newpipe.MainActivity;\n+import org.schabi.newpipe.R;\n+import org.schabi.newpipe.util.NavigationHelper;\n+\n+import java.util.List;\n+\n+import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;\n+import static com.google.android.exoplayer2.Player.REPEAT_MODE_ALL;\n+import static com.google.android.exoplayer2.Player.REPEAT_MODE_ONE;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_BUFFERING;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_CLOSE;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_FAST_FORWARD;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_FAST_REWIND;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_PLAY_NEXT;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_PLAY_PAUSE;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_PLAY_PREVIOUS;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_REPEAT;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_SHUFFLE;\n+\n+/**\n+ * This is a utility class for player notifications.\n+ *\n+ * @author cool-student\n+ */\n+public final class NotificationUtil {\n+    private static final String TAG = NotificationUtil.class.getSimpleName();\n+    private static final boolean DEBUG = BasePlayer.DEBUG;\n+    private static final int NOTIFICATION_ID = 123789;\n+\n+    @Nullable private static NotificationUtil instance = null;\n+\n+    @NotificationConstants.Action\n+    private int[] notificationSlots = NotificationConstants.SLOT_DEFAULTS.clone();\n+\n+    private NotificationManagerCompat notificationManager;\n+    private NotificationCompat.Builder notificationBuilder;\n+\n+    private NotificationUtil() {\n+    }\n+\n+    public static NotificationUtil getInstance() {\n+        if (instance == null) {\n+            instance = new NotificationUtil();\n+        }\n+        return instance;\n+    }\n+\n+\n+    /////////////////////////////////////////////////////\n+    // NOTIFICATION\n+    /////////////////////////////////////////////////////\n+\n+    /**\n+     * Creates the notification if it does not exist already and recreates it if forceRecreate is\n+     * true. Updates the notification with the data in the player.\n+     * @param player the player currently open, to take data from\n+     * @param forceRecreate whether to force the recreation of the notification even if it already\n+     *                      exists\n+     */\n+    synchronized void createNotificationIfNeededAndUpdate(final VideoPlayerImpl player,\n+                                                          final boolean forceRecreate) {\n+        if (forceRecreate || notificationBuilder == null) {\n+            notificationBuilder = createNotification(player);\n+        }\n+        updateNotification(player);\n+        notificationManager.notify(NOTIFICATION_ID, notificationBuilder.build());\n+    }\n+\n+    private synchronized NotificationCompat.Builder createNotification(\n+            final VideoPlayerImpl player) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"createNotification()\");\n+        }\n+        notificationManager = NotificationManagerCompat.from(player.context);\n+        final NotificationCompat.Builder builder = new NotificationCompat.Builder(player.context,\n+                player.context.getString(R.string.notification_channel_id));\n+\n+        initializeNotificationSlots(player);\n+\n+        // count the number of real slots, to make sure compact slots indices are not out of bound\n+        int nonNothingSlotCount = 5;\n+        if (notificationSlots[3] == NotificationConstants.NOTHING) {\n+            --nonNothingSlotCount;\n+        }\n+        if (notificationSlots[4] == NotificationConstants.NOTHING) {\n+            --nonNothingSlotCount;\n+        }\n+\n+        // build the compact slot indices array (need code to convert from Integer... because Java)\n+        final List<Integer> compactSlotList = NotificationConstants.getCompactSlotsFromPreferences(\n+                player.context, player.sharedPreferences, nonNothingSlotCount);\n+        final int[] compactSlots = new int[compactSlotList.size()];\n+        for (int i = 0; i < compactSlotList.size(); i++) {\n+            compactSlots[i] = compactSlotList.get(i);\n+        }\n+\n+        builder.setStyle(new androidx.media.app.NotificationCompat.MediaStyle()\n+                    .setMediaSession(player.mediaSessionManager.getSessionToken())\n+                    .setShowActionsInCompactView(compactSlots))\n+                .setPriority(NotificationCompat.PRIORITY_HIGH)\n+                .setSmallIcon(R.drawable.ic_newpipe_triangle_white)\n+                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n+                .setColor(ContextCompat.getColor(player.context, R.color.gray))\n+                .setCategory(NotificationCompat.CATEGORY_TRANSPORT)\n+                .setDeleteIntent(PendingIntent.getBroadcast(player.context, NOTIFICATION_ID,\n+                        new Intent(ACTION_CLOSE), FLAG_UPDATE_CURRENT));\n+\n+        return builder;\n+    }\n+\n+    /**\n+     * Updates the notification builder and the button icons depending on the playback state.\n+     * @param player the player currently open, to take data from\n+     */\n+    private synchronized void updateNotification(final VideoPlayerImpl player) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"updateNotification()\");\n+        }\n+\n+        // also update content intent, in case the user switched players\n+        notificationBuilder.setContentIntent(PendingIntent.getActivity(player.context,\n+                NOTIFICATION_ID, getIntentForNotification(player), FLAG_UPDATE_CURRENT));\n+        notificationBuilder.setContentTitle(player.getVideoTitle());\n+        notificationBuilder.setContentText(player.getUploaderName());\n+        notificationBuilder.setTicker(player.getVideoTitle());\n+        updateActions(notificationBuilder, player);\n+        setLargeIcon(notificationBuilder, player);\n+    }\n+\n+\n+    boolean hasSlotWithBuffering() {\n+        return notificationSlots[1] == NotificationConstants.PLAY_PAUSE_BUFFERING\n+                || notificationSlots[2] == NotificationConstants.PLAY_PAUSE_BUFFERING;\n+    }\n+\n+\n+    void createNotificationAndStartForeground(final VideoPlayerImpl player, final Service service) {\n+        if (notificationBuilder == null) {\n+            notificationBuilder = createNotification(player);\n+        }\n+        updateNotification(player);\n+\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n+            service.startForeground(NOTIFICATION_ID, notificationBuilder.build(),\n+                    ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK);\n+        } else {\n+            service.startForeground(NOTIFICATION_ID, notificationBuilder.build());\n+        }\n+    }\n+\n+    void cancelNotificationAndStopForeground(final Service service) {\n+        service.stopForeground(true);\n+\n+        if (notificationManager != null) {\n+            notificationManager.cancel(NOTIFICATION_ID);\n+        }\n+        notificationManager = null;\n+        notificationBuilder = null;\n+    }\n+\n+\n+    /////////////////////////////////////////////////////\n+    // ACTIONS\n+    /////////////////////////////////////////////////////\n+\n+    private void initializeNotificationSlots(final VideoPlayerImpl player) {\n+        for (int i = 0; i < 5; ++i) {\n+            notificationSlots[i] = player.sharedPreferences.getInt(\n+                    player.context.getString(NotificationConstants.SLOT_PREF_KEYS[i]),\n+                    NotificationConstants.SLOT_DEFAULTS[i]);\n+        }\n+    }\n+\n+    @SuppressLint(\"RestrictedApi\")\n+    private void updateActions(final NotificationCompat.Builder builder,\n+                               final VideoPlayerImpl player) {\n+        builder.mActions.clear();\n+        for (int i = 0; i < 5; ++i) {\n+            addAction(builder, player, notificationSlots[i]);\n+        }\n+    }\n+\n+    private void addAction(final NotificationCompat.Builder builder,\n+                           final VideoPlayerImpl player,\n+                           @NotificationConstants.Action final int slot) {\n+        final NotificationCompat.Action action = getAction(player, slot);\n+        if (action != null) {\n+            builder.addAction(action);\n+        }\n+    }\n+\n+    @Nullable\n+    private NotificationCompat.Action getAction(\n+            final VideoPlayerImpl player,\n+            @NotificationConstants.Action final int selectedAction) {\n+        final int baseActionIcon = NotificationConstants.ACTION_ICONS[selectedAction];\n+        switch (selectedAction) {\n+            case NotificationConstants.PREVIOUS:\n+                return getAction(player, baseActionIcon, \"Previous\", ACTION_PLAY_PREVIOUS);\n+\n+            case NotificationConstants.NEXT:\n+                return getAction(player, baseActionIcon, \"Next\", ACTION_PLAY_NEXT);\n+\n+            case NotificationConstants.REWIND:\n+                return getAction(player, baseActionIcon, \"Rewind\", ACTION_FAST_REWIND);\n+\n+            case NotificationConstants.FORWARD:\n+                return getAction(player, baseActionIcon, \"Forward\", ACTION_FAST_FORWARD);\n+\n+            case NotificationConstants.SMART_REWIND_PREVIOUS:\n+                if (player.playQueue != null && player.playQueue.size() > 1) {\n+                    return getAction(player, R.drawable.exo_notification_previous,\n+                            \"Previous\", ACTION_PLAY_PREVIOUS);\n+                } else {\n+                    return getAction(player, R.drawable.exo_controls_rewind,\n+                            \"Rewind\", ACTION_FAST_REWIND);\n+                }\n+\n+            case NotificationConstants.SMART_FORWARD_NEXT:\n+                if (player.playQueue != null && player.playQueue.size() > 1) {\n+                    return getAction(player, R.drawable.exo_notification_next,\n+                            \"Next\", ACTION_PLAY_NEXT);\n+                } else {\n+                    return getAction(player, R.drawable.exo_controls_fastforward,\n+                            \"Forward\", ACTION_FAST_FORWARD);\n+                }\n+\n+            case NotificationConstants.PLAY_PAUSE:\n+                final boolean pauseOrPlay = player.isPlaying()\n+                        || player.getCurrentState() == BasePlayer.STATE_PREFLIGHT\n+                        || player.getCurrentState() == BasePlayer.STATE_BLOCKED\n+                        || player.getCurrentState() == BasePlayer.STATE_BUFFERING;\n+                return getAction(player,\n+                        pauseOrPlay ? R.drawable.exo_notification_pause\n+                                : R.drawable.exo_notification_play,\n+                        pauseOrPlay ? \"Pause\" : \"Play\",\n+                        ACTION_PLAY_PAUSE);\n+\n+            case NotificationConstants.PLAY_PAUSE_BUFFERING:\n+                if (player.getCurrentState() == BasePlayer.STATE_PREFLIGHT\n+                        || player.getCurrentState() == BasePlayer.STATE_BLOCKED\n+                        || player.getCurrentState() == BasePlayer.STATE_BUFFERING) {\n+                    return getAction(player, R.drawable.ic_hourglass_top_white_24dp_png,\n+                            \"Buffering\", ACTION_BUFFERING);\n+                } else {\n+                    return getAction(player,\n+                            player.isPlaying() ? R.drawable.exo_notification_pause\n+                                    : R.drawable.exo_notification_play,\n+                            player.isPlaying() ? \"Pause\" : \"Play\",", "originalCommit": "7317737e90ef096fd72b3d1df1e16d04ff2d1d06", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE5NzAyMg==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3178#discussion_r492197022", "bodyText": "See above", "author": "TobiGr", "createdAt": "2020-09-21T16:35:12Z", "path": "app/src/main/java/org/schabi/newpipe/player/NotificationUtil.java", "diffHunk": "@@ -0,0 +1,368 @@\n+package org.schabi.newpipe.player;\n+\n+import android.annotation.SuppressLint;\n+import android.app.PendingIntent;\n+import android.app.Service;\n+import android.content.Intent;\n+import android.content.pm.ServiceInfo;\n+import android.graphics.Bitmap;\n+import android.graphics.Matrix;\n+import android.os.Build;\n+import android.util.Log;\n+\n+import androidx.annotation.DrawableRes;\n+import androidx.annotation.Nullable;\n+import androidx.core.app.NotificationCompat;\n+import androidx.core.app.NotificationManagerCompat;\n+import androidx.core.content.ContextCompat;\n+\n+import org.schabi.newpipe.MainActivity;\n+import org.schabi.newpipe.R;\n+import org.schabi.newpipe.util.NavigationHelper;\n+\n+import java.util.List;\n+\n+import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;\n+import static com.google.android.exoplayer2.Player.REPEAT_MODE_ALL;\n+import static com.google.android.exoplayer2.Player.REPEAT_MODE_ONE;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_BUFFERING;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_CLOSE;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_FAST_FORWARD;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_FAST_REWIND;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_PLAY_NEXT;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_PLAY_PAUSE;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_PLAY_PREVIOUS;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_REPEAT;\n+import static org.schabi.newpipe.player.MainPlayer.ACTION_SHUFFLE;\n+\n+/**\n+ * This is a utility class for player notifications.\n+ *\n+ * @author cool-student\n+ */\n+public final class NotificationUtil {\n+    private static final String TAG = NotificationUtil.class.getSimpleName();\n+    private static final boolean DEBUG = BasePlayer.DEBUG;\n+    private static final int NOTIFICATION_ID = 123789;\n+\n+    @Nullable private static NotificationUtil instance = null;\n+\n+    @NotificationConstants.Action\n+    private int[] notificationSlots = NotificationConstants.SLOT_DEFAULTS.clone();\n+\n+    private NotificationManagerCompat notificationManager;\n+    private NotificationCompat.Builder notificationBuilder;\n+\n+    private NotificationUtil() {\n+    }\n+\n+    public static NotificationUtil getInstance() {\n+        if (instance == null) {\n+            instance = new NotificationUtil();\n+        }\n+        return instance;\n+    }\n+\n+\n+    /////////////////////////////////////////////////////\n+    // NOTIFICATION\n+    /////////////////////////////////////////////////////\n+\n+    /**\n+     * Creates the notification if it does not exist already and recreates it if forceRecreate is\n+     * true. Updates the notification with the data in the player.\n+     * @param player the player currently open, to take data from\n+     * @param forceRecreate whether to force the recreation of the notification even if it already\n+     *                      exists\n+     */\n+    synchronized void createNotificationIfNeededAndUpdate(final VideoPlayerImpl player,\n+                                                          final boolean forceRecreate) {\n+        if (forceRecreate || notificationBuilder == null) {\n+            notificationBuilder = createNotification(player);\n+        }\n+        updateNotification(player);\n+        notificationManager.notify(NOTIFICATION_ID, notificationBuilder.build());\n+    }\n+\n+    private synchronized NotificationCompat.Builder createNotification(\n+            final VideoPlayerImpl player) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"createNotification()\");\n+        }\n+        notificationManager = NotificationManagerCompat.from(player.context);\n+        final NotificationCompat.Builder builder = new NotificationCompat.Builder(player.context,\n+                player.context.getString(R.string.notification_channel_id));\n+\n+        initializeNotificationSlots(player);\n+\n+        // count the number of real slots, to make sure compact slots indices are not out of bound\n+        int nonNothingSlotCount = 5;\n+        if (notificationSlots[3] == NotificationConstants.NOTHING) {\n+            --nonNothingSlotCount;\n+        }\n+        if (notificationSlots[4] == NotificationConstants.NOTHING) {\n+            --nonNothingSlotCount;\n+        }\n+\n+        // build the compact slot indices array (need code to convert from Integer... because Java)\n+        final List<Integer> compactSlotList = NotificationConstants.getCompactSlotsFromPreferences(\n+                player.context, player.sharedPreferences, nonNothingSlotCount);\n+        final int[] compactSlots = new int[compactSlotList.size()];\n+        for (int i = 0; i < compactSlotList.size(); i++) {\n+            compactSlots[i] = compactSlotList.get(i);\n+        }\n+\n+        builder.setStyle(new androidx.media.app.NotificationCompat.MediaStyle()\n+                    .setMediaSession(player.mediaSessionManager.getSessionToken())\n+                    .setShowActionsInCompactView(compactSlots))\n+                .setPriority(NotificationCompat.PRIORITY_HIGH)\n+                .setSmallIcon(R.drawable.ic_newpipe_triangle_white)\n+                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n+                .setColor(ContextCompat.getColor(player.context, R.color.gray))\n+                .setCategory(NotificationCompat.CATEGORY_TRANSPORT)\n+                .setDeleteIntent(PendingIntent.getBroadcast(player.context, NOTIFICATION_ID,\n+                        new Intent(ACTION_CLOSE), FLAG_UPDATE_CURRENT));\n+\n+        return builder;\n+    }\n+\n+    /**\n+     * Updates the notification builder and the button icons depending on the playback state.\n+     * @param player the player currently open, to take data from\n+     */\n+    private synchronized void updateNotification(final VideoPlayerImpl player) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"updateNotification()\");\n+        }\n+\n+        // also update content intent, in case the user switched players\n+        notificationBuilder.setContentIntent(PendingIntent.getActivity(player.context,\n+                NOTIFICATION_ID, getIntentForNotification(player), FLAG_UPDATE_CURRENT));\n+        notificationBuilder.setContentTitle(player.getVideoTitle());\n+        notificationBuilder.setContentText(player.getUploaderName());\n+        notificationBuilder.setTicker(player.getVideoTitle());\n+        updateActions(notificationBuilder, player);\n+        setLargeIcon(notificationBuilder, player);\n+    }\n+\n+\n+    boolean hasSlotWithBuffering() {\n+        return notificationSlots[1] == NotificationConstants.PLAY_PAUSE_BUFFERING\n+                || notificationSlots[2] == NotificationConstants.PLAY_PAUSE_BUFFERING;\n+    }\n+\n+\n+    void createNotificationAndStartForeground(final VideoPlayerImpl player, final Service service) {\n+        if (notificationBuilder == null) {\n+            notificationBuilder = createNotification(player);\n+        }\n+        updateNotification(player);\n+\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n+            service.startForeground(NOTIFICATION_ID, notificationBuilder.build(),\n+                    ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK);\n+        } else {\n+            service.startForeground(NOTIFICATION_ID, notificationBuilder.build());\n+        }\n+    }\n+\n+    void cancelNotificationAndStopForeground(final Service service) {\n+        service.stopForeground(true);\n+\n+        if (notificationManager != null) {\n+            notificationManager.cancel(NOTIFICATION_ID);\n+        }\n+        notificationManager = null;\n+        notificationBuilder = null;\n+    }\n+\n+\n+    /////////////////////////////////////////////////////\n+    // ACTIONS\n+    /////////////////////////////////////////////////////\n+\n+    private void initializeNotificationSlots(final VideoPlayerImpl player) {\n+        for (int i = 0; i < 5; ++i) {\n+            notificationSlots[i] = player.sharedPreferences.getInt(\n+                    player.context.getString(NotificationConstants.SLOT_PREF_KEYS[i]),\n+                    NotificationConstants.SLOT_DEFAULTS[i]);\n+        }\n+    }\n+\n+    @SuppressLint(\"RestrictedApi\")\n+    private void updateActions(final NotificationCompat.Builder builder,\n+                               final VideoPlayerImpl player) {\n+        builder.mActions.clear();\n+        for (int i = 0; i < 5; ++i) {\n+            addAction(builder, player, notificationSlots[i]);\n+        }\n+    }\n+\n+    private void addAction(final NotificationCompat.Builder builder,\n+                           final VideoPlayerImpl player,\n+                           @NotificationConstants.Action final int slot) {\n+        final NotificationCompat.Action action = getAction(player, slot);\n+        if (action != null) {\n+            builder.addAction(action);\n+        }\n+    }\n+\n+    @Nullable\n+    private NotificationCompat.Action getAction(\n+            final VideoPlayerImpl player,\n+            @NotificationConstants.Action final int selectedAction) {\n+        final int baseActionIcon = NotificationConstants.ACTION_ICONS[selectedAction];\n+        switch (selectedAction) {\n+            case NotificationConstants.PREVIOUS:\n+                return getAction(player, baseActionIcon, \"Previous\", ACTION_PLAY_PREVIOUS);\n+\n+            case NotificationConstants.NEXT:\n+                return getAction(player, baseActionIcon, \"Next\", ACTION_PLAY_NEXT);\n+\n+            case NotificationConstants.REWIND:\n+                return getAction(player, baseActionIcon, \"Rewind\", ACTION_FAST_REWIND);\n+\n+            case NotificationConstants.FORWARD:\n+                return getAction(player, baseActionIcon, \"Forward\", ACTION_FAST_FORWARD);\n+\n+            case NotificationConstants.SMART_REWIND_PREVIOUS:\n+                if (player.playQueue != null && player.playQueue.size() > 1) {\n+                    return getAction(player, R.drawable.exo_notification_previous,\n+                            \"Previous\", ACTION_PLAY_PREVIOUS);\n+                } else {\n+                    return getAction(player, R.drawable.exo_controls_rewind,\n+                            \"Rewind\", ACTION_FAST_REWIND);\n+                }\n+\n+            case NotificationConstants.SMART_FORWARD_NEXT:\n+                if (player.playQueue != null && player.playQueue.size() > 1) {\n+                    return getAction(player, R.drawable.exo_notification_next,\n+                            \"Next\", ACTION_PLAY_NEXT);\n+                } else {\n+                    return getAction(player, R.drawable.exo_controls_fastforward,\n+                            \"Forward\", ACTION_FAST_FORWARD);\n+                }\n+\n+            case NotificationConstants.PLAY_PAUSE:\n+                final boolean pauseOrPlay = player.isPlaying()\n+                        || player.getCurrentState() == BasePlayer.STATE_PREFLIGHT\n+                        || player.getCurrentState() == BasePlayer.STATE_BLOCKED\n+                        || player.getCurrentState() == BasePlayer.STATE_BUFFERING;\n+                return getAction(player,\n+                        pauseOrPlay ? R.drawable.exo_notification_pause\n+                                : R.drawable.exo_notification_play,\n+                        pauseOrPlay ? \"Pause\" : \"Play\",\n+                        ACTION_PLAY_PAUSE);\n+\n+            case NotificationConstants.PLAY_PAUSE_BUFFERING:\n+                if (player.getCurrentState() == BasePlayer.STATE_PREFLIGHT\n+                        || player.getCurrentState() == BasePlayer.STATE_BLOCKED\n+                        || player.getCurrentState() == BasePlayer.STATE_BUFFERING) {\n+                    return getAction(player, R.drawable.ic_hourglass_top_white_24dp_png,\n+                            \"Buffering\", ACTION_BUFFERING);\n+                } else {\n+                    return getAction(player,\n+                            player.isPlaying() ? R.drawable.exo_notification_pause\n+                                    : R.drawable.exo_notification_play,\n+                            player.isPlaying() ? \"Pause\" : \"Play\",\n+                            ACTION_PLAY_PAUSE);\n+                }\n+\n+            case NotificationConstants.REPEAT:\n+                return getAction(player, getRepeatModeDrawable(player.getRepeatMode()),\n+                        getRepeatModeTitle(player.getRepeatMode()), ACTION_REPEAT);\n+\n+            case NotificationConstants.SHUFFLE:\n+                final boolean shuffled = player.playQueue != null && player.playQueue.isShuffled();\n+                return getAction(player,\n+                        shuffled ? R.drawable.exo_controls_shuffle_on\n+                                : R.drawable.exo_controls_shuffle_off,\n+                        shuffled ? \"ShuffleOn\" : \"ShuffleOff\",", "originalCommit": "7317737e90ef096fd72b3d1df1e16d04ff2d1d06", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "11e048abb1fc1eee6588b93da87657d197381c27", "url": "https://github.com/TeamNewPipe/NewPipe/commit/11e048abb1fc1eee6588b93da87657d197381c27", "message": "Remove hardcoded and duplicate strings, use exoplayer ones", "committedDate": "2020-09-22T16:17:09Z", "type": "commit"}, {"oid": "814efbf8df0eb21594cdb30232ee545b12a84ce0", "url": "https://github.com/TeamNewPipe/NewPipe/commit/814efbf8df0eb21594cdb30232ee545b12a84ce0", "message": "Remove ACTION_BUFFERING, update buffering only if needed\n\n- ACTION_BUFFERING was just wrong: why should the user be able to trigger the internal onBuffering() state by pressing on the buffering button? So that was replaced by a null intent, doing nothing.\n- Now updating notification in onBuffering() only when buffering actions are not already buffering, to prevent useless updates", "committedDate": "2020-09-22T16:17:16Z", "type": "commit"}, {"oid": "b4e073cde7d737ea6c6230ecb17f47acac1da0b8", "url": "https://github.com/TeamNewPipe/NewPipe/commit/b4e073cde7d737ea6c6230ecb17f47acac1da0b8", "message": "Show replay icon in notification when player state is completed", "committedDate": "2020-09-22T16:17:16Z", "type": "commit"}]}