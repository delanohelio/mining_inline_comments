{"pr_number": 3065, "pr_title": "Added the ability to remove all watched videos from a local playlist", "pr_createdAt": "2020-02-08T06:41:44Z", "pr_url": "https://github.com/TeamNewPipe/NewPipe/pull/3065", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1ODc5OQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r388758799", "bodyText": "deleteItem(playlist_item) probably crashes because it has to be called on the main thread (not sure though).", "author": "Stypox", "createdAt": "2020-03-06T08:00:43Z", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -300,6 +316,20 @@ public void onComplete() {}\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                //Solution, Scorched Earth, Copy non duplicates, clear playlist, then copy back over\n+                //Other options didn't work as intended, or crashed. Like deleteItem(playlist_item) crashes when called in this function.", "originalCommit": "27af9a9c4bded24583fe7242350364fde38540b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgzNjQ4OA==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r388836488", "bodyText": "Converting the AsyncTask to ReactiveX.\nEdit: Tested and does work.\nAdded\nprivate Disposable removeWatchedWorker;\nonOptionsItemSelected Looks like\nRemoveWatchedStreams remover = new RemoveWatchedStreams();\n// It's the same class, just without extending AsyncTask.\n\nremover.onPreExecute();\nremoveWatchedWorker = Flowable.just(playlistManager.getPlaylistStreams(playlistId).blockingFirst())\n    .subscribeOn(Schedulers.newThread())\n    .filter((@NonNull List<PlaylistStreamEntry> playlist) -> {\n        remover.doInBackground(playlist);\n        return true;\n    }\n).observeOn(AndroidSchedulers.mainThread())\n    .subscribe(playlist -> {\n    remover.onPostExecute();\n}, (@io.reactivex.annotations.NonNull Throwable throwable) -> {\n    onError(throwable);\n});\n\nIt still uses the scorched earth method.\nI still haven't figured out how to get the deleteItem() to not crash.\nDue to the below, I think it's the better method.\nWith the scorched earth method.\n\nThere are less calls to the itemListAdapter\nif the app crashed, goes wrong, etc, it doesn't effect anything, it only writes once everything is done, and it's quite fast.\nless function calls, calling deleteItem will call multiple functions that aren't needed until the end.\nFor example updateThumbnailUrl() doesn't need to be called each time, only at the end.", "author": "GradyClark", "createdAt": "2020-03-06T10:50:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1ODc5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM2NjcyNA==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r389366724", "bodyText": "Switched it over to ReactiveX in commit fb193ce\nNo problem!\nI really have enjoyed NewPipe, and really thank you, and everyone else who has worked hard to make NewPipe happen!", "author": "GradyClark", "createdAt": "2020-03-08T12:53:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1ODc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI1NjAxMA==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r391256010", "bodyText": "Before this line you should add this code to dispose removeWatchedWorker if it is not null:\nif (removeWatchedWorker != null) {\n    removeWatchedWorker.dispose();\n}", "author": "Stypox", "createdAt": "2020-03-11T20:41:50Z", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -300,6 +321,32 @@ public void onComplete() {}\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                RemoveWatchedStreams remover = new RemoveWatchedStreams();\n+\n+                remover.onPreExecute();\n+                removeWatchedWorker = Flowable.just(playlistManager.getPlaylistStreams(playlistId).blockingFirst())", "originalCommit": "fb193ce3622f34b212bff6a645887f98940eb63c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMxNTA2MQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r393315061", "bodyText": "Fixed in commit 81bcac5", "author": "GradyClark", "createdAt": "2020-03-16T21:16:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI1NjAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI1NzE1Ng==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r391257156", "bodyText": "I'm not sure this should be done inside a nested class. You could do the same things in three functions without nesting things (at least, that's how I have seen it done in other places in the repository)", "author": "Stypox", "createdAt": "2020-03-11T20:44:13Z", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -616,5 +663,75 @@ private PlayQueue getPlayQueue(final int index) {\n         }\n         return new SinglePlayQueue(streamInfoItems, index);\n     }\n+\n+    private class RemoveWatchedStreams{", "originalCommit": "fb193ce3622f34b212bff6a645887f98940eb63c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMxNTk2Mw==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r393315963", "bodyText": "Removed the class in commit 81bcac5", "author": "GradyClark", "createdAt": "2020-03-16T21:18:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI1NzE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI1NzQ5MQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r391257491", "bodyText": "Match the style of the repo: } else {\nAlso below: spaces between if and (: if (", "author": "Stypox", "createdAt": "2020-03-11T20:45:03Z", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -616,5 +663,75 @@ private PlayQueue getPlayQueue(final int index) {\n         }\n         return new SinglePlayQueue(streamInfoItems, index);\n     }\n+\n+    private class RemoveWatchedStreams{\n+        List<PlaylistStreamEntry> localItems = new ArrayList<>();\n+        Long RemovedItemCount = 0l;\n+        boolean thumbnailVideoRemoved = false;\n+\n+        // Do this in the main thread\n+        protected void onPreExecute() {\n+            showLoading();\n+        }\n+\n+        // Do not do this in the main thread\n+        protected Long doInBackground(List<PlaylistStreamEntry> playlist) {\n+\n+            HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+            Iterator<StreamHistoryEntry> it_history;\n+            StreamHistoryEntry history_item;\n+\n+            Iterator<PlaylistStreamEntry> it_playlist = playlist.iterator();\n+            PlaylistStreamEntry playlist_item = null;\n+\n+            boolean isNonDuplicate;\n+\n+            while (it_playlist.hasNext()) {\n+                playlist_item = it_playlist.next();\n+\n+                it_history = recordManager.getStreamHistory().blockingFirst().iterator();\n+\n+                isNonDuplicate = true;\n+                while (it_history.hasNext()) {\n+                    history_item = it_history.next();\n+                    if (history_item.streamId == playlist_item.streamId) {\n+                        isNonDuplicate = false;\n+                        break;\n+                    }\n+                }\n+                if (isNonDuplicate) {\n+                    localItems.add(playlist_item);\n+                }\n+                else\n+                {", "originalCommit": "fb193ce3622f34b212bff6a645887f98940eb63c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMxNjQyMQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r393316421", "bodyText": "Fixed in commit 81bcac5", "author": "GradyClark", "createdAt": "2020-03-16T21:19:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI1NzQ5MQ=="}], "type": "inlineReview"}, {"oid": "ff255a01d3a38c0cabe8a84dda1ccd4ec7042db7", "url": "https://github.com/TeamNewPipe/NewPipe/commit/ff255a01d3a38c0cabe8a84dda1ccd4ec7042db7", "message": "Merge branch 'dev' into dev", "committedDate": "2020-03-16T22:52:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5NDgzMQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r393494831", "bodyText": "As you can see above, the same thing is being done with other disposables. So reorder code to make it uniform.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                    if (removeWatchedWorker != null) removeWatchedWorker.dispose();\n          \n          \n            \n                    removeWatchedWorker = null;\n          \n          \n            \n            \n          \n          \n            \n                    debouncedSaveSignal = null;\n          \n          \n            \n                    playlistManager = null;\n          \n          \n            \n                    disposables = null;\n          \n          \n            \n                    if (removeWatchedWorker != null) removeWatchedWorker.dispose();\n          \n          \n            \n            \n          \n          \n            \n                    debouncedSaveSignal = null;\n          \n          \n            \n                    playlistManager = null;\n          \n          \n            \n                    disposables = null;\n          \n          \n            \n                    removeWatchedWorker = null;", "author": "Stypox", "createdAt": "2020-03-17T07:51:30Z", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -255,6 +273,9 @@ public void onDestroy() {\n         if (debouncedSaveSignal != null) debouncedSaveSignal.onComplete();\n         if (disposables != null) disposables.dispose();\n \n+        if (removeWatchedWorker != null) removeWatchedWorker.dispose();\n+        removeWatchedWorker = null;\n+\n         debouncedSaveSignal = null;\n         playlistManager = null;\n         disposables = null;", "originalCommit": "ff255a01d3a38c0cabe8a84dda1ccd4ec7042db7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEzOTg2Nw==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r394139867", "bodyText": "fixed in 6223c36", "author": "GradyClark", "createdAt": "2020-03-18T07:05:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5NDgzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5NTkzNA==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r393495934", "bodyText": "Rename to removeWatchedDisposable", "author": "Stypox", "createdAt": "2020-03-17T07:54:13Z", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -67,6 +75,8 @@\n     private View headerPopupButton;\n     private View headerBackgroundButton;\n \n+    private Disposable removeWatchedWorker;", "originalCommit": "ff255a01d3a38c0cabe8a84dda1ccd4ec7042db7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE0MDA2NQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r394140065", "bodyText": "Refactored in 6223c36", "author": "GradyClark", "createdAt": "2020-03-18T07:05:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5NTkzNA=="}], "type": "inlineReview"}, {"oid": "66c95f901dfa31c193375abfdef8028f527834de", "url": "https://github.com/TeamNewPipe/NewPipe/commit/66c95f901dfa31c193375abfdef8028f527834de", "message": "Added the ability to remove all watched videos from local playlists\n\nChanges:\n - local_playlist_control.xml\n   * A copy of playlist_control.xml\n   * To hold the 'Remove Watched Videos' buttton\n\n - local_playlist_header.xml\n   * Changed the include layout\tto now include local_playlist_control.xml\n\n - strings.xml\n   * added string 'remove_watched' with value 'Remove Watched'\n\n - LocalPlaylistFragment.java\n   * Added the functionality to remove watched videos,\n      to the 'Remove Watched Videos' button in local_playlist_control.xml.\n      In the background via AsyncTask.\n      This will also change the playlist's thumbnail, if the thumbnail video is removed.\n\nTested on:\n - Pixel", "committedDate": "2020-04-03T17:47:31Z", "type": "commit"}, {"oid": "954399b2557eb43976dd344daee25b53d629811e", "url": "https://github.com/TeamNewPipe/NewPipe/commit/954399b2557eb43976dd344daee25b53d629811e", "message": "Moved the 'Remove Watched' button to the three dot menu button.", "committedDate": "2020-04-03T17:49:01Z", "type": "commit"}, {"oid": "8cab79003052ef8b1b0bd3782498a04ce9b287c9", "url": "https://github.com/TeamNewPipe/NewPipe/commit/8cab79003052ef8b1b0bd3782498a04ce9b287c9", "message": "- Will now use ReactiveX instead of AsyncTask, when removing watched videos.\n- Removed redundant file 'local_playlist_control'\n- Fixed grammer issue", "committedDate": "2020-04-03T17:49:41Z", "type": "commit"}, {"oid": "98fc88dec6daa0a0ef5b8507bc1a03569b163543", "url": "https://github.com/TeamNewPipe/NewPipe/commit/98fc88dec6daa0a0ef5b8507bc1a03569b163543", "message": "Simplified the removal of watched videos, into the function `removeWatchedStreams`\n  Replaced unnecessary nested class.\nFixed formating issues", "committedDate": "2020-04-03T17:49:41Z", "type": "commit"}, {"oid": "0ac2865b7484b64b00a2da1178d015ea06d831c0", "url": "https://github.com/TeamNewPipe/NewPipe/commit/0ac2865b7484b64b00a2da1178d015ea06d831c0", "message": "Optimised 'removeWatchedStreams'\nRemoved merge mistake\nReordered code\nRefactored 'removeWatchedWorker' to 'removeWatchedDisposable'", "committedDate": "2020-04-03T17:50:12Z", "type": "commit"}, {"oid": "9c3f138b8e30e17bad4530e4b85b81fcec4f44bf", "url": "https://github.com/TeamNewPipe/NewPipe/commit/9c3f138b8e30e17bad4530e4b85b81fcec4f44bf", "message": "Use binary search to remove watched items from playlists", "committedDate": "2020-04-03T17:51:29Z", "type": "commit"}, {"oid": "9c3f138b8e30e17bad4530e4b85b81fcec4f44bf", "url": "https://github.com/TeamNewPipe/NewPipe/commit/9c3f138b8e30e17bad4530e4b85b81fcec4f44bf", "message": "Use binary search to remove watched items from playlists", "committedDate": "2020-04-03T17:51:29Z", "type": "forcePushed"}, {"oid": "6571fdbaa282be16fa2675623ba5af496ef6f39b", "url": "https://github.com/TeamNewPipe/NewPipe/commit/6571fdbaa282be16fa2675623ba5af496ef6f39b", "message": "Fix checkstyle errors", "committedDate": "2020-04-03T18:13:56Z", "type": "commit"}, {"oid": "92ca1e6e0910178d82063e275dfd6e77c46de27e", "url": "https://github.com/TeamNewPipe/NewPipe/commit/92ca1e6e0910178d82063e275dfd6e77c46de27e", "message": "Check if already running before removing watched", "committedDate": "2020-04-03T18:41:21Z", "type": "commit"}, {"oid": "92ca1e6e0910178d82063e275dfd6e77c46de27e", "url": "https://github.com/TeamNewPipe/NewPipe/commit/92ca1e6e0910178d82063e275dfd6e77c46de27e", "message": "Check if already running before removing watched", "committedDate": "2020-04-03T18:41:21Z", "type": "forcePushed"}, {"oid": "fe1646caa00e8791c131f2be92b973afb95a3032", "url": "https://github.com/TeamNewPipe/NewPipe/commit/fe1646caa00e8791c131f2be92b973afb95a3032", "message": "Changed \"Remove Watched\":\n- Will now execute on the io thread\n- Added confirmation dialog\n  - Warning the user, and asking if they also want to remove partially watched videos", "committedDate": "2020-04-14T18:15:07Z", "type": "commit"}, {"oid": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648", "url": "https://github.com/TeamNewPipe/NewPipe/commit/1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648", "message": "Merge branch 'dev' of https://github.com/TeamNewPipe/NewPipe into dev", "committedDate": "2020-04-14T18:24:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzODkyNQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r408638925", "bodyText": "Declare variables right where you first use them. Redeclaring a variable every cycle of the while loop does not slow down anything, since declaring is just telling the compiler \"I need to have this memory at this point\", so memory is really allocated only once.", "author": "Stypox", "createdAt": "2020-04-15T07:34:51Z", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = Flowable.just(Flowable.just(removePartiallyWatched,\n+                playlistManager.getPlaylistStreams(playlistId).blockingFirst()))\n+                .subscribeOn(Schedulers.io())\n+                .map(flow -> {\n+                    boolean localRemovePartiallyWatched = (boolean) flow.blockingFirst();\n+                    List<PlaylistStreamEntry> playlist\n+                            = (List<PlaylistStreamEntry>) flow.blockingLast();\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!localRemovePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)\n+                                .blockingGet().iterator();\n+                    }\n+\n+                    // already sorted by ^ getStreamHistorySortedById(), binary search can be used\n+                    ArrayList<Long> historyStreamIds = new ArrayList<>();\n+                    while (historyIter.hasNext()) {\n+                        historyStreamIds.add(historyIter.next().getStreamId());\n+                    }\n+\n+                    if (localRemovePartiallyWatched) {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            if (indexInHistory < 0) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    } else {\n+                        boolean hasState = false;", "originalCommit": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc1MDQ2Ng==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409750466", "bodyText": "Fixed in db335d5", "author": "GradyClark", "createdAt": "2020-04-16T18:05:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzODkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzOTQ2OA==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r408639468", "bodyText": "Anyway, I don't think here another variable is needed, you could just go with\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        hasState = streamStatesIter.next() != null;\n          \n          \n            \n                                        if (indexInHistory < 0 ||  hasState) {\n          \n          \n            \n                                        if (indexInHistory < 0 || streamStatesIter.next() != null) {", "author": "Stypox", "createdAt": "2020-04-15T07:35:50Z", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = Flowable.just(Flowable.just(removePartiallyWatched,\n+                playlistManager.getPlaylistStreams(playlistId).blockingFirst()))\n+                .subscribeOn(Schedulers.io())\n+                .map(flow -> {\n+                    boolean localRemovePartiallyWatched = (boolean) flow.blockingFirst();\n+                    List<PlaylistStreamEntry> playlist\n+                            = (List<PlaylistStreamEntry>) flow.blockingLast();\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!localRemovePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)\n+                                .blockingGet().iterator();\n+                    }\n+\n+                    // already sorted by ^ getStreamHistorySortedById(), binary search can be used\n+                    ArrayList<Long> historyStreamIds = new ArrayList<>();\n+                    while (historyIter.hasNext()) {\n+                        historyStreamIds.add(historyIter.next().getStreamId());\n+                    }\n+\n+                    if (localRemovePartiallyWatched) {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            if (indexInHistory < 0) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    } else {\n+                        boolean hasState = false;\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            hasState = streamStatesIter.next() != null;\n+                            if (indexInHistory < 0 ||  hasState) {", "originalCommit": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwNDk1Ng==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409204956", "bodyText": "streamStatesIter Has to be incremented each time to keep up with the playlistIter\nstreamStatesIter.next() Doesn't always get called in the \"OR\" conditional, thus would make them increasingly out of sync, each time indexInHistory >= 0", "author": "GradyClark", "createdAt": "2020-04-16T00:09:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzOTQ2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ3MzQyNQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409473425", "bodyText": "Oh, I see, you are right", "author": "Stypox", "createdAt": "2020-04-16T11:09:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzOTQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MDg4NA==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r408640884", "bodyText": "Do you really need to pass removePartiallyWatched to the Flowable? I think you can access it just as normal inside the lambda body below", "author": "Stypox", "createdAt": "2020-04-15T07:38:28Z", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = Flowable.just(Flowable.just(removePartiallyWatched,", "originalCommit": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwNTQwNQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409205405", "bodyText": "I'm really new with ReactiveX, I did that just to make sure that there would be no chance of a weird issue occurring, do you think I should change it?", "author": "GradyClark", "createdAt": "2020-04-16T00:10:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MDg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ3Mjg2Nw==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409472867", "bodyText": "Yes, nothing strange should happen, as removePartiallyWatched is declared as final", "author": "Stypox", "createdAt": "2020-04-16T11:08:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MDg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc0NDkyMQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409744921", "bodyText": "I tried using that just now, and it causes the removeWatchedDisposable to never dispose.\nSo you can only use the 'remove watched' ability once, then you have to shut down and reopen the app.\nI found a way around it, by force disposing it.", "author": "GradyClark", "createdAt": "2020-04-16T17:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MDg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc1MDM2MA==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409750360", "bodyText": "Fixed in db335d5", "author": "GradyClark", "createdAt": "2020-04-16T18:05:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MDg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NDI3OA==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r408644278", "bodyText": "In my opinion it is difficult to read all of these declarations here, maybe they should be distributed right befor the places in code where they are being used (e.g. streamStatesIter would be moved on line 405, before the if (!localRemovePartiallyWatched) branch where it is used). But I'm not sure if it's the same for others. ;-)", "author": "Stypox", "createdAt": "2020-04-15T07:44:30Z", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = Flowable.just(Flowable.just(removePartiallyWatched,\n+                playlistManager.getPlaylistStreams(playlistId).blockingFirst()))\n+                .subscribeOn(Schedulers.io())\n+                .map(flow -> {\n+                    boolean localRemovePartiallyWatched = (boolean) flow.blockingFirst();\n+                    List<PlaylistStreamEntry> playlist\n+                            = (List<PlaylistStreamEntry>) flow.blockingLast();\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+                    boolean thumbnailVideoRemoved = false;", "originalCommit": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwODUzMw==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409208533", "bodyText": "How does this look?", "author": "GradyClark", "createdAt": "2020-04-16T00:21:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NDI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ3NDAxMQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409474011", "bodyText": "Looks better, thanks :-D", "author": "Stypox", "createdAt": "2020-04-16T11:10:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NDI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc1MDA4NQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409750085", "bodyText": "Fixed in db335d5", "author": "GradyClark", "createdAt": "2020-04-16T18:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NDI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NTk1NQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r408645955", "bodyText": "Usually a \"Builder\" variable is never saved, since it is needed exactly once. Also, why can't you use AlertDialog directly without the full path specification?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            android.app.AlertDialog.Builder builder =\n          \n          \n            \n                            new android.app.AlertDialog.Builder(getActivity());\n          \n          \n            \n                            builder.setMessage(R.string.remove_watched_popup_warning)\n          \n          \n            \n                                    .setTitle(R.string.remove_watched_popup_title)\n          \n          \n            \n                                    .setPositiveButton(R.string.remove_watched_popup_yes,\n          \n          \n            \n                                            (DialogInterface d, int id) -> removeWatchedStreams(false))\n          \n          \n            \n                                    .setNeutralButton(\n          \n          \n            \n                                            R.string.remove_watched_popup_yes_and_partially_watched_videos,\n          \n          \n            \n                                            (DialogInterface d, int id) -> removeWatchedStreams(true))\n          \n          \n            \n                                    .setNegativeButton(R.string.remove_watched_popup_cancel,\n          \n          \n            \n                                            (DialogInterface d, int id) -> d.cancel());\n          \n          \n            \n                            builder.create().show();\n          \n          \n            \n                            new AlertDialog.Builder(getActivity())\n          \n          \n            \n                                    .setMessage(R.string.remove_watched_popup_warning)\n          \n          \n            \n                                    .setTitle(R.string.remove_watched_popup_title)\n          \n          \n            \n                                    .setPositiveButton(R.string.remove_watched_popup_yes,\n          \n          \n            \n                                            (DialogInterface d, int id) -> removeWatchedStreams(false))\n          \n          \n            \n                                    .setNeutralButton(\n          \n          \n            \n                                            R.string.remove_watched_popup_yes_and_partially_watched_videos,\n          \n          \n            \n                                            (DialogInterface d, int id) -> removeWatchedStreams(true))\n          \n          \n            \n                                    .setNegativeButton(R.string.remove_watched_popup_cancel,\n          \n          \n            \n                                            (DialogInterface d, int id) -> d.cancel());\n          \n          \n            \n                                    .create()\n          \n          \n            \n                                    .show();", "author": "Stypox", "createdAt": "2020-04-15T07:47:33Z", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,121 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                android.app.AlertDialog.Builder builder =\n+                new android.app.AlertDialog.Builder(getActivity());\n+                builder.setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.remove_watched_popup_yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.remove_watched_popup_cancel,\n+                                (DialogInterface d, int id) -> d.cancel());\n+                builder.create().show();", "originalCommit": "1d0c3de65f4943b2d1b33b03ef9eb51ef7fcc648", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc0OTk5MQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r409749991", "bodyText": "Fixed in db335d5", "author": "GradyClark", "createdAt": "2020-04-16T18:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NTk1NQ=="}], "type": "inlineReview"}, {"oid": "db335d5cec3b77be37d897279973f1fbf94537af", "url": "https://github.com/TeamNewPipe/NewPipe/commit/db335d5cec3b77be37d897279973f1fbf94537af", "message": "Removed redundant code\nreorganized code", "committedDate": "2020-04-16T17:58:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNjU3Mw==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r410926573", "bodyText": "They should all have a space after //. Also, there probably is a proper way of solving this.", "author": "wb9688", "createdAt": "2020-04-19T15:15:42Z", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,127 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                new AlertDialog.Builder(getActivity())\n+                        .setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.cancel,\n+                                (DialogInterface d, int id) -> d.cancel())\n+                        .create()\n+                        .show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = playlistManager.getPlaylistStreams(playlistId)\n+                .subscribeOn(Schedulers.io())\n+                .map((List<PlaylistStreamEntry> playlist) -> {\n+                    //Playlist data\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+\n+                    //History data\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+\n+                    //Remove Watched, Functionality data\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!removePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)\n+                                .blockingGet().iterator();\n+                    }\n+\n+                    // already sorted by ^ getStreamHistorySortedById(), binary search can be used\n+                    ArrayList<Long> historyStreamIds = new ArrayList<>();\n+                    while (historyIter.hasNext()) {\n+                        historyStreamIds.add(historyIter.next().getStreamId());\n+                    }\n+\n+                    if (removePartiallyWatched) {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            if (indexInHistory < 0) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    } else {\n+                        while (playlistIter.hasNext()) {\n+                            PlaylistStreamEntry playlistItem = playlistIter.next();\n+                            int indexInHistory = Collections.binarySearch(historyStreamIds,\n+                                    playlistItem.getStreamId());\n+\n+                            boolean hasState = streamStatesIter.next() != null;\n+                            if (indexInHistory < 0 ||  hasState) {\n+                                notWatchedItems.add(playlistItem);\n+                            } else if (!thumbnailVideoRemoved\n+                                    && playlistManager.getPlaylistThumbnail(playlistId)\n+                                    .equals(playlistItem.getStreamEntity().getThumbnailUrl())) {\n+                                thumbnailVideoRemoved = true;\n+                            }\n+                        }\n+                    }\n+\n+                    return Flowable.just(notWatchedItems, thumbnailVideoRemoved);\n+                })\n+                .observeOn(AndroidSchedulers.mainThread())\n+                .subscribe(flow -> {\n+                    List<PlaylistStreamEntry> notWatchedItems =\n+                            (List<PlaylistStreamEntry>) flow.blockingFirst();\n+                    boolean thumbnailVideoRemoved = (Boolean) flow.blockingLast();\n+\n+                    itemListAdapter.clearStreamItemList();\n+                    itemListAdapter.addItems(notWatchedItems);\n+                    saveChanges();\n+\n+\n+                    if (thumbnailVideoRemoved) {\n+                        updateThumbnailUrl();\n+                    }\n+\n+                    long videoCount = itemListAdapter.getItemsList().size();\n+                    setVideoCount(videoCount);\n+                    if (videoCount == 0) {\n+                        showEmptyState();\n+                    }\n+\n+                    hideLoading();\n+\n+                    //If this is not done, 'removeWatchedDisposable', will never be disposed of.\n+                    //Why: Because using the 'removePartiallyWatched' in this functions parms,\n+                    // prevents it from disposing. Exact reason for this behavior is unknown", "originalCommit": "db335d5cec3b77be37d897279973f1fbf94537af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5MTgwNQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411891805", "bodyText": "I have looked around, and I'm not sure what the solution would be.", "author": "GradyClark", "createdAt": "2020-04-21T05:58:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNjU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5ODQ0MQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411898441", "bodyText": "Fixed '// ' issue in 776dddd", "author": "GradyClark", "createdAt": "2020-04-21T06:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNjU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3ODg3MQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r412278871", "bodyText": "@GradyClark: I think you should just add this thing to the already existing CompositeDisposable in this class (i.e. disposables) and not do this stuff here at all, see e.g. here.", "author": "wb9688", "createdAt": "2020-04-21T15:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNjU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc4MTgzMw==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r413781833", "bodyText": "@wb9688 but then how can he check if the removal is already going on, and in that case do nothing? See line 385", "author": "Stypox", "createdAt": "2020-04-23T12:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNjU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc5MDIwNQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r413790205", "bodyText": "@Stypox: Can't you create e.g. a private boolean isRemovingWatched for that?", "author": "wb9688", "createdAt": "2020-04-23T12:53:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNjU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNzAyOQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r410927029", "bodyText": "I'd personally prefer formatting it something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Log.d(TAG, \"onCreateOptionsMenu() called with: menu = [\" + menu\n          \n          \n            \n                                + \"], inflater = [\" + inflater + \"]\");\n          \n          \n            \n                        Log.d(TAG, \"onCreateOptionsMenu() called with: \"\n          \n          \n            \n                                + \"menu = [\" + menu + \"], inflater = [\" + inflater + \"]\");", "author": "wb9688", "createdAt": "2020-04-19T15:17:58Z", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -244,6 +256,16 @@ public void onPause() {\n         saveImmediate();\n     }\n \n+    @Override\n+    public void onCreateOptionsMenu(final Menu menu, final MenuInflater inflater) {\n+        if (DEBUG) {\n+            Log.d(TAG, \"onCreateOptionsMenu() called with: menu = [\" + menu\n+                    + \"], inflater = [\" + inflater + \"]\");", "originalCommit": "db335d5cec3b77be37d897279973f1fbf94537af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5ODUxMg==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411898512", "bodyText": "Fixed in 776dddd", "author": "GradyClark", "createdAt": "2020-04-21T06:14:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNzAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNzQ1Ng==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r410927456", "bodyText": "A lot of variables in this function could be final", "author": "wb9688", "createdAt": "2020-04-19T15:19:49Z", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,127 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                new AlertDialog.Builder(getActivity())\n+                        .setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.cancel,\n+                                (DialogInterface d, int id) -> d.cancel())\n+                        .create()\n+                        .show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {", "originalCommit": "db335d5cec3b77be37d897279973f1fbf94537af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4OTYwMA==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411889600", "bodyText": "I don't think that is necessary", "author": "GradyClark", "createdAt": "2020-04-21T05:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNzQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkxMTE0OA==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411911148", "bodyText": "It is not necessary, but it is a good idea to do so, @wb9688 is right", "author": "Stypox", "createdAt": "2020-04-21T06:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNzQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkyMjIzMA==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411922230", "bodyText": "Fixed in 7361100", "author": "GradyClark", "createdAt": "2020-04-21T06:59:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyNzQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyODAyMg==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r410928022", "bodyText": "This could be moved down I think", "author": "wb9688", "createdAt": "2020-04-19T15:22:40Z", "path": "app/src/main/java/org/schabi/newpipe/local/playlist/LocalPlaylistFragment.java", "diffHunk": "@@ -331,6 +358,127 @@ public void onComplete() { }\n         };\n     }\n \n+    @Override\n+    public boolean onOptionsItemSelected(final MenuItem item) {\n+        switch (item.getItemId()) {\n+            case R.id.menu_item_removeWatched:\n+                new AlertDialog.Builder(getActivity())\n+                        .setMessage(R.string.remove_watched_popup_warning)\n+                        .setTitle(R.string.remove_watched_popup_title)\n+                        .setPositiveButton(R.string.yes,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(false))\n+                        .setNeutralButton(\n+                                R.string.remove_watched_popup_yes_and_partially_watched_videos,\n+                                (DialogInterface d, int id) -> removeWatchedStreams(true))\n+                        .setNegativeButton(R.string.cancel,\n+                                (DialogInterface d, int id) -> d.cancel())\n+                        .create()\n+                        .show();\n+                break;\n+            default:\n+                return super.onOptionsItemSelected(item);\n+        }\n+        return true;\n+    }\n+\n+    public void removeWatchedStreams(final boolean removePartiallyWatched) {\n+        if (removeWatchedDisposable != null && !removeWatchedDisposable.isDisposed()) {\n+            // already running\n+            return;\n+        }\n+        showLoading();\n+\n+        removeWatchedDisposable = playlistManager.getPlaylistStreams(playlistId)\n+                .subscribeOn(Schedulers.io())\n+                .map((List<PlaylistStreamEntry> playlist) -> {\n+                    //Playlist data\n+                    Iterator<PlaylistStreamEntry> playlistIter = playlist.iterator();\n+\n+                    //History data\n+                    HistoryRecordManager recordManager = new HistoryRecordManager(getContext());\n+                    Iterator<StreamHistoryEntry> historyIter = recordManager\n+                            .getStreamHistorySortedById().blockingFirst().iterator();\n+                    Iterator<StreamStateEntity> streamStatesIter = null;\n+\n+                    //Remove Watched, Functionality data\n+                    List<PlaylistStreamEntry> notWatchedItems = new ArrayList<>();\n+                    boolean thumbnailVideoRemoved = false;\n+\n+                    if (!removePartiallyWatched) {\n+                        streamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)", "originalCommit": "db335d5cec3b77be37d897279973f1fbf94537af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4ODU1MQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411888551", "bodyText": "The space is to separate the variables, and the functions", "author": "GradyClark", "createdAt": "2020-04-21T05:51:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyODAyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkxMjUzNw==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411912537", "bodyText": "I think he meant to move the\nstreamStatesIter = recordManager.loadLocalStreamStateBatch(playlist)\n                                .blockingGet().iterator();\n\nblock under the } else { branch below (where removePartiallyWatched == false), i.e. after line 432, so that a check is removed and also less space is used.", "author": "Stypox", "createdAt": "2020-04-21T06:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyODAyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkxNjcwNA==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411916704", "bodyText": "Yes, and its initial declaration as well", "author": "wb9688", "createdAt": "2020-04-21T06:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyODAyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkxOTc0OQ==", "url": "https://github.com/TeamNewPipe/NewPipe/pull/3065#discussion_r411919749", "bodyText": "Ah, I'll fix it in the next commit. 7361100", "author": "GradyClark", "createdAt": "2020-04-21T06:55:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkyODAyMg=="}], "type": "inlineReview"}, {"oid": "776ddddc8374e2bc2cabb189ca4c4ad6ec5b990c", "url": "https://github.com/TeamNewPipe/NewPipe/commit/776ddddc8374e2bc2cabb189ca4c4ad6ec5b990c", "message": "fixed naming and formatting issues", "committedDate": "2020-04-21T06:03:42Z", "type": "commit"}, {"oid": "73611004a0484fce5f6be54654d8107294e53543", "url": "https://github.com/TeamNewPipe/NewPipe/commit/73611004a0484fce5f6be54654d8107294e53543", "message": "Code cleanup, and best practices", "committedDate": "2020-04-21T06:57:23Z", "type": "commit"}, {"oid": "437b86d1a7cfe362172ef9522aa2bafd8d91d698", "url": "https://github.com/TeamNewPipe/NewPipe/commit/437b86d1a7cfe362172ef9522aa2bafd8d91d698", "message": "Use centralized CompositeDisposable instead of custom Disposable\n\nAlso do not show any dialog if the user is aready removing watched videos in a local playlist", "committedDate": "2020-04-23T21:35:00Z", "type": "commit"}]}