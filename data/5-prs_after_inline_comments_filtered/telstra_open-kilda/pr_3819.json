{"pr_number": 3819, "pr_title": "Move BFD session transition code out of FSM", "pr_createdAt": "2020-11-02T08:48:25Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3819", "timeline": [{"oid": "b4faf84447c16269f59859562b5a12f845d49a09", "url": "https://github.com/telstra/open-kilda/commit/b4faf84447c16269f59859562b5a12f845d49a09", "message": "Move BFD session transition code out of FSM\n\nAs part of BFD session FSM simplification, all code responsible for\nswitch/transfer between different session sessions has been moved out of\nFSM. Now it implemented as plain java code.", "committedDate": "2020-11-03T14:30:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4ODQ2OQ==", "url": "https://github.com/telstra/open-kilda/pull/3819#discussion_r518588469", "bodyText": "offtop: I've just realized we use I notation in interfaces for the network topology, isn't it controversial to  style guides?\np.s. - not to address this in current pr:)", "author": "timofei-durakov", "createdAt": "2020-11-06T08:19:27Z", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/controller/bfd/BfdLogicalPortFsm.java", "diffHunk": "@@ -51,16 +52,16 @@\n     private final int logicalPortNumber;\n \n     private BfdSessionData sessionData;\n+    private boolean online;\n \n     public BfdLogicalPortFsm(\n-            IBfdLogicalPortCarrier carrier, SwitchStatusMonitor switchStatusMonitor,\n+            IBfdLogicalPortCarrier carrier, SwitchOnlineStatusMonitor switchOnlineStatusMonitor,", "originalCommit": "35043ce82101f35562d443da355959447cce067e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ1NTgyMw==", "url": "https://github.com/telstra/open-kilda/pull/3819#discussion_r520455823", "bodyText": "Yes, it breaks our naming convention... (when most of these interfaces were invented there was no such convention, it was declared later).", "author": "surabujin", "createdAt": "2020-11-10T10:31:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4ODQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU5MDIxOA==", "url": "https://github.com/telstra/open-kilda/pull/3819#discussion_r518590218", "bodyText": "is rotate a good verb for this method?", "author": "timofei-durakov", "createdAt": "2020-11-06T08:22:50Z", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/controller/bfd/BfdSessionController.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.network.controller.bfd;\n+\n+import org.openkilda.messaging.floodlight.response.BfdSessionResponse;\n+import org.openkilda.wfm.share.model.Endpoint;\n+import org.openkilda.wfm.topology.network.model.BfdSessionData;\n+import org.openkilda.wfm.topology.network.utils.SwitchOnlineStatusListener;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class BfdSessionController implements SwitchOnlineStatusListener {\n+    private final BfdSessionFsm.BfdSessionFsmFactory fsmFactory;\n+\n+    @Getter\n+    private final Endpoint logical;\n+    private final int physicalPortNumber;\n+\n+    private BfdSessionManager manager;\n+    private BfdSessionData sessionData;\n+\n+    public BfdSessionController(\n+            BfdSessionFsm.BfdSessionFsmFactory fsmFactory, Endpoint logical, int physicalPortNumber) {\n+        this.fsmFactory = fsmFactory;\n+\n+        this.logical = logical;\n+        this.physicalPortNumber = physicalPortNumber;\n+\n+        manager = new BfdSessionDummy(fsmFactory.getCarrier(), logical, physicalPortNumber);\n+\n+        fsmFactory.getSwitchOnlineStatusMonitor().subscribe(logical.getDatapath(), this);\n+    }\n+\n+    public void enableUpdate(BfdSessionData sessionData) {\n+        this.sessionData = sessionData;\n+        rotate();\n+    }\n+\n+    /**\n+     * Handle BFD session disable/remove request.\n+     */\n+    public void disable() {\n+        sessionData = null;\n+        if (manager.disable()) {\n+            rotate();\n+        }\n+    }\n+\n+    public void speakerResponse(String key) {\n+        manager.speakerResponse(key);\n+    }\n+\n+    public void speakerResponse(String key, BfdSessionResponse response) {\n+        manager.speakerResponse(key, response);\n+    }\n+\n+    /**\n+     * Handle manager's complete notification - cleanup resource, do mangers rotation.\n+     */\n+    public void handleCompleteNotification(boolean error) {\n+        manager = new BfdSessionDummy(fsmFactory.getCarrier(), logical, physicalPortNumber);\n+        if (! error) {\n+            rotate();\n+        } // in case of error new attempt will be done on explicit enable request or on switch offline-to-online event\n+    }\n+\n+    @Override\n+    public void switchOnlineStatusUpdate(boolean isOnline) {\n+        if (isOnline && manager.isDummy()) {\n+            rotate();\n+        }\n+    }\n+\n+    private void rotate() {", "originalCommit": "35043ce82101f35562d443da355959447cce067e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ1NzEwOA==", "url": "https://github.com/telstra/open-kilda/pull/3819#discussion_r520457108", "bodyText": "it replaces the existing FSM with a new one. As for me \"rotate\" correct term for such a process. If you have some other term in mind - please share it.", "author": "surabujin", "createdAt": "2020-11-10T10:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU5MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2MDcyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3819#discussion_r520460725", "bodyText": "Swap?", "author": "timofei-durakov", "createdAt": "2020-11-10T10:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU5MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2NTQ3OQ==", "url": "https://github.com/telstra/open-kilda/pull/3819#discussion_r520465479", "bodyText": "Replace?:)", "author": "timofei-durakov", "createdAt": "2020-11-10T10:46:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU5MDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE4OTIxMA==", "url": "https://github.com/telstra/open-kilda/pull/3819#discussion_r521189210", "bodyText": "ok, let's name it replace.", "author": "surabujin", "createdAt": "2020-11-11T08:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU5MDIxOA=="}], "type": "inlineReview"}, {"oid": "5124a70748af1c624a6f2662df34970608e5ff37", "url": "https://github.com/telstra/open-kilda/commit/5124a70748af1c624a6f2662df34970608e5ff37", "message": "Move BFD session transition code out of FSM\n\nAs part of BFD session FSM simplification, all code responsible for\nswitch/transfer between different session sessions has been moved out of\nFSM. Now it implemented as plain java code.", "committedDate": "2020-11-10T10:45:26Z", "type": "forcePushed"}, {"oid": "038dda8a5c0fe398b0e862606751c0574f0d03ca", "url": "https://github.com/telstra/open-kilda/commit/038dda8a5c0fe398b0e862606751c0574f0d03ca", "message": "Move BFD session transition code out of FSM\n\nAs part of BFD session FSM simplification, all code responsible for\nswitch/transfer between different session sessions has been moved out of\nFSM. Now it implemented as plain java code.", "committedDate": "2020-11-11T08:21:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM5Mzk5Nw==", "url": "https://github.com/telstra/open-kilda/pull/3819#discussion_r524393997", "bodyText": "si -> is", "author": "rozdy", "createdAt": "2020-11-16T16:21:41Z", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/controller/bfd/BfdSessionDummy.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.network.controller.bfd;\n+\n+import org.openkilda.messaging.floodlight.response.BfdSessionResponse;\n+import org.openkilda.wfm.share.model.Endpoint;\n+import org.openkilda.wfm.topology.network.model.BfdSessionData;\n+import org.openkilda.wfm.topology.network.service.IBfdSessionCarrier;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class BfdSessionDummy implements BfdSessionManager {\n+    private final IBfdSessionCarrier carrier;\n+\n+    private final Endpoint logical;\n+    private final int physicalPortNumber;\n+\n+    public BfdSessionDummy(IBfdSessionCarrier carrier, Endpoint logical, int physicalPortNumber) {\n+        this.carrier = carrier;\n+        this.logical = logical;\n+        this.physicalPortNumber = physicalPortNumber;\n+    }\n+\n+    @Override\n+    public boolean isOperationalAndEqualTo(BfdSessionData sessionData) {\n+        return false;\n+    }\n+\n+    @Override\n+    public void speakerResponse(String key) {\n+        reportMissingManger(String.format(\"speakerResponse(\\\"%s\\\")\", key));\n+    }\n+\n+    @Override\n+    public void speakerResponse(String key, BfdSessionResponse response) {\n+        reportMissingManger(String.format(\"speakerResponse(\\\"%s\\\", %s)\", key, response));\n+    }\n+\n+    @Override\n+    public boolean disable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isDummy() {\n+        return true;\n+    }\n+\n+    private void reportMissingManger(String callDetails) {\n+        log.error(\"There si no active BFD session FSM for {} - ignore call {}\", logical, callDetails);", "originalCommit": "038dda8a5c0fe398b0e862606751c0574f0d03ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAwMDg5NA==", "url": "https://github.com/telstra/open-kilda/pull/3819#discussion_r527000894", "bodyText": "fixed", "author": "surabujin", "createdAt": "2020-11-19T15:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM5Mzk5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQwMzc0OQ==", "url": "https://github.com/telstra/open-kilda/pull/3819#discussion_r524403749", "bodyText": "Move this comment closer to loop.", "author": "rozdy", "createdAt": "2020-11-16T16:34:46Z", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/controller/bfd/BfdSessionFsm.java", "diffHunk": "@@ -27,279 +27,355 @@\n import org.openkilda.persistence.repositories.BfdSessionRepository;\n import org.openkilda.persistence.repositories.RepositoryFactory;\n import org.openkilda.persistence.repositories.SwitchRepository;\n+import org.openkilda.persistence.tx.TransactionCallback;\n import org.openkilda.persistence.tx.TransactionManager;\n import org.openkilda.wfm.share.model.Endpoint;\n-import org.openkilda.wfm.share.model.IslReference;\n import org.openkilda.wfm.share.utils.AbstractBaseFsm;\n import org.openkilda.wfm.share.utils.FsmExecutor;\n import org.openkilda.wfm.topology.network.controller.bfd.BfdSessionFsm.BfdSessionFsmContext;\n import org.openkilda.wfm.topology.network.controller.bfd.BfdSessionFsm.Event;\n import org.openkilda.wfm.topology.network.controller.bfd.BfdSessionFsm.State;\n import org.openkilda.wfm.topology.network.error.SwitchReferenceLookupException;\n import org.openkilda.wfm.topology.network.model.BfdDescriptor;\n+import org.openkilda.wfm.topology.network.model.BfdSessionData;\n import org.openkilda.wfm.topology.network.model.LinkStatus;\n import org.openkilda.wfm.topology.network.service.IBfdSessionCarrier;\n+import org.openkilda.wfm.topology.network.utils.EndpointStatusListener;\n+import org.openkilda.wfm.topology.network.utils.EndpointStatusMonitor;\n+import org.openkilda.wfm.topology.network.utils.SwitchOnlineStatusListener;\n+import org.openkilda.wfm.topology.network.utils.SwitchOnlineStatusMonitor;\n \n import lombok.Builder;\n import lombok.Getter;\n+import lombok.ToString;\n import lombok.Value;\n import lombok.extern.slf4j.Slf4j;\n import org.squirrelframework.foundation.fsm.StateMachineBuilder;\n import org.squirrelframework.foundation.fsm.StateMachineBuilderFactory;\n \n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.Random;\n \n @Slf4j\n-public final class BfdSessionFsm extends\n-        AbstractBaseFsm<BfdSessionFsm, State, Event, BfdSessionFsmContext> {\n+public final class BfdSessionFsm\n+        extends AbstractBaseFsm<BfdSessionFsm, State, Event, BfdSessionFsmContext>\n+        implements BfdSessionManager, SwitchOnlineStatusListener, EndpointStatusListener {\n     static final int BFD_UDP_PORT = 3784;\n \n+    private final Random random = new Random();\n+\n     private final TransactionManager transactionManager;\n     private final SwitchRepository switchRepository;\n     private final BfdSessionRepository bfdSessionRepository;\n \n-    private final Random random = new Random();\n+    private final IBfdSessionCarrier carrier;\n \n-    @Getter\n-    private final Endpoint physicalEndpoint;\n-    @Getter\n     private final Endpoint logicalEndpoint;\n+    private final int physicalPortNumber;\n+    private final BfdSessionData sessionData;\n \n-    private final PortStatusMonitor portStatusMonitor;\n-\n-    private IslReference islReference;\n     private BfdProperties properties;\n-    private BfdProperties effectiveProperties;\n-    private BfdDescriptor sessionDescriptor = null;\n+    private Integer discriminator;\n+\n     private BfdSessionAction action = null;\n+    private boolean error = false;\n+    private boolean online;\n+    private LinkStatus endpointStatus;\n \n-    public static BfdSessionFsmFactory factory() {\n-        return new BfdSessionFsmFactory();\n+    public static BfdSessionFsmFactory factory(\n+            PersistenceManager persistenceManager, SwitchOnlineStatusMonitor switchOnlineStatusMonitor,\n+            EndpointStatusMonitor endpointStatusMonitor, IBfdSessionCarrier carrier) {\n+        return new BfdSessionFsmFactory(persistenceManager, switchOnlineStatusMonitor, endpointStatusMonitor, carrier);\n     }\n \n-    public BfdSessionFsm(PersistenceManager persistenceManager, Endpoint endpoint, Integer physicalPortNumber) {\n+    public BfdSessionFsm(\n+            PersistenceManager persistenceManager,\n+            SwitchOnlineStatusMonitor switchOnlineStatusMonitor, EndpointStatusMonitor endpointStatusMonitor,\n+            IBfdSessionCarrier carrier, Endpoint logical, Integer physicalPortNumber, BfdSessionData sessionData) {\n         transactionManager = persistenceManager.getTransactionManager();\n \n         RepositoryFactory repositoryFactory = persistenceManager.getRepositoryFactory();\n         this.switchRepository = repositoryFactory.createSwitchRepository();\n         this.bfdSessionRepository = repositoryFactory.createBfdSessionRepository();\n \n-        this.logicalEndpoint = endpoint;\n-        this.physicalEndpoint = Endpoint.of(logicalEndpoint.getDatapath(), physicalPortNumber);\n+        this.carrier = carrier;\n+\n+        this.logicalEndpoint = logical;\n+        this.physicalPortNumber = physicalPortNumber;\n+        this.sessionData = sessionData;\n \n-        portStatusMonitor = new PortStatusMonitor(this);\n+        online = switchOnlineStatusMonitor.subscribe(logical.getDatapath(), this);\n+        endpointStatus = endpointStatusMonitor.subscribe(logical, this);\n     }\n \n     // -- external API --\n \n-    public void updateLinkStatus(IBfdSessionCarrier carrier, LinkStatus status) {\n-        portStatusMonitor.update(carrier, status);\n+    @Override\n+    public boolean isOperationalAndEqualTo(BfdSessionData goal) {\n+        switch (getCurrentState()) {\n+            case ACTIVE:\n+            case WAIT_STATUS:\n+            case UP:\n+            case DOWN:\n+            case OFFLINE:\n+                BfdSessionData effective = new BfdSessionData(sessionData.getReference(), properties);\n+                return effective.equals(goal);\n+\n+            default:\n+                return false;\n+        }\n     }\n \n-    // FIXME(surabujin): extremely unreliable\n-    public boolean isDoingCleanup() {\n-        return State.DO_CLEANUP == getCurrentState();\n+    @Override\n+    public void speakerResponse(String key) {\n+        speakerResponse(key, null);  // timeout\n     }\n \n-    // -- FSM actions --\n+    @Override\n+    public void speakerResponse(String key, BfdSessionResponse response) {\n+        if (action != null) {\n+            action.consumeSpeakerResponse(key, response)\n+                    .ifPresent(result -> handleActionResult(result, response));\n+        }\n+    }\n \n-    public void consumeHistory(State from, State to, Event event, BfdSessionFsmContext context) {\n-        Optional<BfdSession> session = loadBfdSession();\n-        if (session.isPresent()) {\n-            BfdSession dbView = session.get();\n-            try {\n-                sessionDescriptor = BfdDescriptor.builder()\n-                        .local(makeSwitchReference(dbView.getSwitchId(), dbView.getIpAddress()))\n-                        .remote(makeSwitchReference(dbView.getRemoteSwitchId(), dbView.getRemoteIpAddress()))\n-                        .discriminator(dbView.getDiscriminator())\n-                        .build();\n-                properties = effectiveProperties = BfdProperties.builder()\n-                        .interval(dbView.getInterval())\n-                        .multiplier(dbView.getMultiplier())\n-                        .build();\n-            } catch (SwitchReferenceLookupException e) {\n-                log.error(\"{} - unable to use stored BFD session data {} - {}\",\n-                        makeLogPrefix(), dbView, e.getMessage());\n-            }\n+    @Override\n+    public boolean disable() {\n+        if (! isTerminated()) {\n+            handle(Event.DISABLE);\n+            return false;\n         }\n+        return true;\n     }\n \n-    public void handleInitChoice(State from, State to, Event event, BfdSessionFsmContext context) {\n-        if (sessionDescriptor == null) {\n-            fire(Event._INIT_CHOICE_CLEAN, context);\n-        } else {\n-            fire(Event._INIT_CHOICE_DIRTY, context);\n+    @Override\n+    public void switchOnlineStatusUpdate(boolean isOnline) {\n+        online = isOnline;\n+        if (! isTerminated()) {\n+            handle(isOnline ? Event.ONLINE : Event.OFFLINE);\n         }\n     }\n \n-    public void idleEnter(State from, State to, Event event, BfdSessionFsmContext context) {\n-        logInfo(\"ready for setup requests\");\n+    @Override\n+    public void endpointStatusUpdate(LinkStatus status) {\n+        endpointStatus = status;\n+        if (! isTerminated()) {\n+            handle(mapEndpointStatusToEvent(status));\n+        }\n     }\n \n-    public void doSetupEnter(State from, State to, Event event, BfdSessionFsmContext context) {\n-        portStatusMonitor.cleanTransitions();\n+    public void handle(Event event) {\n+        handle(event, BfdSessionFsmContext.builder().build());\n+    }\n \n-        logInfo(String.format(\"BFD session setup process have started - discriminator:%s, remote-datapath:%s\",\n-                sessionDescriptor.getDiscriminator(), sessionDescriptor.getRemote().getDatapath()));\n-        action = new BfdSessionSetupAction(context.getOutput(), makeBfdSessionRecord(properties));\n+    public void handle(Event event, BfdSessionFsmContext context) {\n+        BfdSessionFsmFactory.EXECUTOR.fire(this, event, context);\n     }\n \n-    public void saveIslReference(State from, State to, Event event, BfdSessionFsmContext context) {\n-        islReference = context.getIslReference();\n-        properties = context.getProperties();\n+    @Override\n+    public boolean isDummy() {\n+        return false;\n     }\n \n-    public void savePropertiesAction(State from, State to, Event event, BfdSessionFsmContext context) {\n-        properties = context.getProperties();\n+    // -- FSM actions --\n+\n+    public void enterEnterAction(State from, State to, Event event, BfdSessionFsmContext context) {\n+        loadExistingSession();\n     }\n \n-    public void doAllocateResources(State from, State to, Event event, BfdSessionFsmContext context) {\n-        try {\n-            sessionDescriptor = allocateDiscriminator(makeSessionDescriptor(islReference));\n-        } catch (SwitchReferenceLookupException e) {\n-            logError(String.format(\"Can't allocate BFD-session resources - %s\", e.getMessage()));\n-            fire(Event.FAIL, context);\n+    public void prepareEnterAction(State from, State to, Event event, BfdSessionFsmContext context) {\n+        Optional<BfdDescriptor> descriptor = allocateDiscriminator(context);\n+        if (online && descriptor.isPresent()) {\n+            action = new BfdSessionCreateAction(carrier, makeBfdSessionRecord(descriptor.get()));\n+            fire(Event.READY, context);\n         }\n     }\n \n-    public void doReleaseResources(State from, State to, Event event, BfdSessionFsmContext context) {\n-        transactionManager.doInTransaction(() -> {\n-            bfdSessionRepository.findBySwitchIdAndPort(logicalEndpoint.getDatapath(), logicalEndpoint.getPortNumber())\n-                    .ifPresent(value -> {\n-                        if (value.getDiscriminator().equals(sessionDescriptor.getDiscriminator())) {\n-                            bfdSessionRepository.remove(value);\n-                        }\n-                    });\n-        });\n-        sessionDescriptor = null;\n+    public void sendSessionCreateRequestAction(State from, State to, Event event, BfdSessionFsmContext context) {\n+        Optional<BfdDescriptor> descriptor = makeSessionDescriptor(context);\n+        if (descriptor.isPresent()) {\n+            action = new BfdSessionCreateAction(carrier, makeBfdSessionRecord(descriptor.get()));\n+            fire(Event.READY, context);\n+        }\n     }\n \n-    public void activeEnter(State from, State to, Event event, BfdSessionFsmContext context) {\n-        logInfo(\"BFD session is operational\");\n+    public void creatingEnterAction(State from, State to, Event event, BfdSessionFsmContext context) {\n+        endpointStatus = null;\n+    }\n \n-        effectiveProperties = properties;\n+    public void activeEnterAction(State from, State to, Event event, BfdSessionFsmContext context) {\n+        logInfo(\"BFD session is operational\");\n         saveEffectiveProperties();\n     }\n \n-    public void activeExit(State from, State to, Event event, BfdSessionFsmContext context) {\n+    public void activeExitAction(State from, State to, Event event, BfdSessionFsmContext context) {\n         logInfo(\"notify consumer(s) to STOP react on BFD event\");\n-        portStatusMonitor.cleanTransitions();\n-        context.getOutput().bfdKillNotification(physicalEndpoint);\n+        carrier.bfdKillNotification(getPhysicalEndpoint());\n     }\n \n-    public void waitStatusEnter(State from, State to, Event event, BfdSessionFsmContext context) {\n-        portStatusMonitor.pull(context.getOutput());\n+    public void offlineEnterAction(State from, State to, Event event, BfdSessionFsmContext context) {\n+        endpointStatus = null;\n     }\n \n-    public void upEnter(State from, State to, Event event, BfdSessionFsmContext context) {\n+    public void waitStatusEnterAction(State from, State to, Event event, BfdSessionFsmContext context) {\n+        if (endpointStatus != null) {\n+            fire(mapEndpointStatusToEvent(endpointStatus), context);\n+        }\n+    }\n+\n+    public void upEnterAction(State from, State to, Event event, BfdSessionFsmContext context) {\n         logInfo(\"LINK detected\");\n-        context.getOutput().bfdUpNotification(physicalEndpoint);\n+        carrier.bfdUpNotification(getPhysicalEndpoint());\n     }\n \n-    public void downEnter(State from, State to, Event event, BfdSessionFsmContext context) {\n+    public void downEnterAction(State from, State to, Event event, BfdSessionFsmContext context) {\n         logInfo(\"LINK corrupted\");\n-        context.getOutput().bfdDownNotification(physicalEndpoint);\n+        carrier.bfdDownNotification(getPhysicalEndpoint());\n     }\n \n-    public void setupFailEnter(State from, State to, Event event, BfdSessionFsmContext context) {\n-        logError(\"BFD-setup action have failed\");\n-        context.getOutput().bfdFailNotification(physicalEndpoint);\n+    public void removingEnterAction(State from, State to, Event event, BfdSessionFsmContext context) {\n+        makeSessionRemoveAction(context);\n     }\n \n-    public void removeFailEnter(State from, State to, Event event, BfdSessionFsmContext context) {\n-        logError(\"BFD-remove action have failed\");\n-        context.getOutput().bfdFailNotification(physicalEndpoint);\n+    public void sessionRemoveAction(State from, State to, Event event, BfdSessionFsmContext context) {\n+        makeSessionRemoveAction(context);\n     }\n \n-    public void chargedFailEnter(State from, State to, Event event, BfdSessionFsmContext context) {\n-        logError(\"BFD-remove action have failed (for re-setup)\");\n+    public void emitBfdFailAction(State from, State to, Event event, BfdSessionFsmContext context) {\n+        emitBfdFail();\n     }\n \n-    public void makeBfdRemoveAction(State from, State to, Event event, BfdSessionFsmContext context) {\n-        logInfo(String.format(\"perform BFD session remove - discriminator:%s, remote-datapath:%s\",\n-                sessionDescriptor.getDiscriminator(), sessionDescriptor.getRemote().getDatapath()));\n-        BfdProperties bfdProperties = this.effectiveProperties;\n-        if (bfdProperties == null) {\n-            bfdProperties = properties;\n-        }\n-        action = new BfdSessionRemoveAction(context.getOutput(), makeBfdSessionRecord(bfdProperties));\n+    public void errorEnterAction(State from, State to, Event event, BfdSessionFsmContext context) {\n+        error = true;\n+        emitBfdFail();\n     }\n \n-    public void proxySpeakerResponseIntoAction(State from, State to, Event event, BfdSessionFsmContext context) {\n-        action.consumeSpeakerResponse(context.getRequestKey(), context.getBfdSessionResponse())\n-                .ifPresent(result -> handleActionResult(result, context));\n+    public void housekeepingEnterAction(State from, State to, Event event, BfdSessionFsmContext context) {\n+        releaseDiscriminator();\n     }\n \n-    public void reportSetupSuccess(State from, State to, Event event, BfdSessionFsmContext context) {\n-        logInfo(\"BFD session setup is successfully completed\");\n+    public void stopEnterAction(State from, State to, Event event, BfdSessionFsmContext context) {\n+        carrier.sessionRotateRequest(logicalEndpoint, error);\n     }\n \n     // -- private/service methods --\n-    private NoviBfdSession makeBfdSessionRecord(BfdProperties bfdProperties) {\n-        if (bfdProperties == null) {\n-            throw new IllegalArgumentException(String.format(\n-                    \"Can't produce %s without properties (properties is null)\", NoviBfdSession.class.getSimpleName()));\n+\n+    private void disableIfConfigured() {\n+        if (discriminator != null && properties != null && properties.isEnabled()) {\n+            handle(Event.DISABLE);\n+        } else {\n+            discriminator = null;\n+            properties = null;\n+        }\n+    }\n+\n+    private void loadExistingSession() {\n+        transactionManager.doInTransaction(() -> loadBfdSession().ifPresent(this::loadExistingSession));\n+    }\n+\n+    private void loadExistingSession(BfdSession dbView) {\n+        discriminator = dbView.getDiscriminator();\n+        properties = BfdProperties.builder()\n+                .interval(dbView.getInterval())\n+                .multiplier(dbView.getMultiplier())\n+                .build();\n+    }\n+\n+    private void makeSessionRemoveAction(BfdSessionFsmContext context) {\n+        if (online) {\n+            makeSessionDescriptor(context).ifPresent(\n+                    descriptor -> action = new BfdSessionRemoveAction(carrier, makeBfdSessionRecord(descriptor)));\n         }\n+    }\n+\n+    private NoviBfdSession makeBfdSessionRecord(BfdDescriptor descriptor) {\n+        if (discriminator == null) {\n+            throw new IllegalStateException(makeLogPrefix() + \" there is no allocated discriminator\");\n+        }\n+\n+        BfdProperties effectiveProperties = properties != null ? properties : sessionData.getProperties();\n         return NoviBfdSession.builder()\n-                .target(sessionDescriptor.getLocal())\n-                .remote(sessionDescriptor.getRemote())\n-                .physicalPortNumber(physicalEndpoint.getPortNumber())\n+                .target(descriptor.getLocal())\n+                .remote(descriptor.getRemote())\n+                .physicalPortNumber(physicalPortNumber)\n                 .logicalPortNumber(logicalEndpoint.getPortNumber())\n                 .udpPortNumber(BFD_UDP_PORT)\n-                .discriminator(sessionDescriptor.getDiscriminator())\n+                .discriminator(discriminator)\n                 .keepOverDisconnect(true)\n-                .intervalMs((int) bfdProperties.getInterval().toMillis())\n-                .multiplier(bfdProperties.getMultiplier())\n+                .intervalMs((int) effectiveProperties.getInterval().toMillis())\n+                .multiplier(effectiveProperties.getMultiplier())\n                 .build();\n     }\n \n-    private BfdDescriptor allocateDiscriminator(BfdDescriptor descriptor) {\n-        BfdSession dbView;\n+    private Optional<BfdDescriptor> allocateDiscriminator(BfdSessionFsmContext context) {\n+        Optional<BfdDescriptor> descriptor = makeSessionDescriptor(context);\n+        descriptor.ifPresent(this::allocateDiscriminator);\n+        return descriptor;\n+    }\n+\n+    private void allocateDiscriminator(BfdDescriptor descriptor) {\n         while (true) {\n             try {\n-                dbView = transactionManager.doInTransaction(() -> {\n-                    BfdSession bfdSession = loadBfdSession().orElse(null);\n-                    if (bfdSession == null || bfdSession.getDiscriminator() == null) {\n-                        // FIXME(surabujin): loop will never end if all possible discriminators are allocated\n-                        int discriminator = random.nextInt();\n-                        if (bfdSession != null) {\n-                            bfdSession.setDiscriminator(discriminator);\n-                            descriptor.fill(bfdSession);\n-                        } else {\n-                            bfdSession = BfdSession.builder()\n-                                    .switchId(logicalEndpoint.getDatapath())\n-                                    .port(logicalEndpoint.getPortNumber())\n-                                    .physicalPort(physicalEndpoint.getPortNumber())\n-                                    .discriminator(discriminator)\n-                                    .build();\n-                            descriptor.fill(bfdSession);\n-                            bfdSessionRepository.add(bfdSession);\n-                        }\n-                    }\n-                    return bfdSession;\n-                });\n+                discriminator = transactionManager.doInTransaction(\n+                        () -> allocateDiscriminator(descriptor, loadBfdSession().orElse(null)));\n                 break;\n             } catch (ConstraintViolationException ex) {\n                 log.warn(\"ConstraintViolationException on allocate bfd discriminator\");\n             }\n         }\n+    }\n \n-        return descriptor.toBuilder()\n-                .discriminator(dbView.getDiscriminator())\n-                .build();\n+    private Integer allocateDiscriminator(BfdDescriptor descriptor, BfdSession bfdSession) {\n+        if (bfdSession != null && bfdSession.getDiscriminator() != null) {\n+            return bfdSession.getDiscriminator();\n+        }\n+\n+        // FIXME(surabujin): loop will never end if all possible discriminators are allocated", "originalCommit": "038dda8a5c0fe398b0e862606751c0574f0d03ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAwMTc4NA==", "url": "https://github.com/telstra/open-kilda/pull/3819#discussion_r527001784", "bodyText": "moved", "author": "surabujin", "createdAt": "2020-11-19T15:59:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQwMzc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQwODU5Mg==", "url": "https://github.com/telstra/open-kilda/pull/3819#discussion_r524408592", "bodyText": "Maybe we can rename Enter FSM state to Init or something else to avoid enterEnter in method name?", "author": "rozdy", "createdAt": "2020-11-16T16:40:56Z", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/controller/bfd/BfdSessionFsm.java", "diffHunk": "@@ -364,335 +443,220 @@ private void reportActionFailure(BfdSessionAction.ActionResult result) {\n         }\n     }\n \n-    private void logInfo(String message) {\n+    private Endpoint getPhysicalEndpoint() {\n+        return Endpoint.of(logicalEndpoint.getDatapath(), physicalPortNumber);\n+    }\n+\n+    private Event mapEndpointStatusToEvent(LinkStatus status) {\n+        Event event;\n+        switch (status) {\n+            case UP:\n+                event = Event.PORT_UP;\n+                break;\n+            case DOWN:\n+                event = Event.PORT_DOWN;\n+                break;\n+\n+            default:\n+                throw new IllegalStateException(String.format(\n+                        \"%s - there is no mapping from %s.%s into %s\",\n+                        makeLogPrefix(), status.getClass().getName(), status, Event.class.getName()));\n+        }\n+        return event;\n+    }\n+\n+    private void logInfo(String message, Object... args) {\n         if (log.isInfoEnabled()) {\n-            log.info(\"{} - {}\", makeLogPrefix(), message);\n+            log.info(\"{} - \" + message, makeLogPrefix(), args);\n         }\n     }\n \n-    private void logError(String message) {\n+    private void logError(String message, Object... args) {\n         if (log.isErrorEnabled()) {\n-            log.error(\"{} - {}\", makeLogPrefix(), message);\n+            log.error(\"{} - \" + message, makeLogPrefix(), args);\n         }\n     }\n \n     private String makeLogPrefix() {\n-        return String.format(\"BFD session %s(physical-port:%s)\", logicalEndpoint, physicalEndpoint.getPortNumber());\n+        return String.format(\"BFD session %s(physical-port:%s)\", logicalEndpoint, physicalPortNumber);\n     }\n \n     public static class BfdSessionFsmFactory {\n         public static final FsmExecutor<BfdSessionFsm, State, Event, BfdSessionFsmContext> EXECUTOR\n                 = new FsmExecutor<>(Event.NEXT);\n \n+        private final PersistenceManager persistenceManager;\n+        @Getter\n+        private final SwitchOnlineStatusMonitor switchOnlineStatusMonitor;\n+        private final EndpointStatusMonitor endpointStatusMonitor;\n+\n+        @Getter\n+        private final IBfdSessionCarrier carrier;\n+\n         private final StateMachineBuilder<BfdSessionFsm, State, Event, BfdSessionFsmContext> builder;\n \n-        BfdSessionFsmFactory() {\n-            final String doReleaseResourcesMethod = \"doReleaseResources\";\n-            final String saveIslReferenceMethod = \"saveIslReference\";\n-            final String savePropertiesMethod = \"savePropertiesAction\";\n-            final String makeBfdRemoveActionMethod = \"makeBfdRemoveAction\";\n-            final String proxySpeakerResponseIntoActionMethod = \"proxySpeakerResponseIntoAction\";\n+        BfdSessionFsmFactory(\n+                PersistenceManager persistenceManager, SwitchOnlineStatusMonitor switchOnlineStatusMonitor,\n+                EndpointStatusMonitor endpointStatusMonitor, IBfdSessionCarrier carrier) {\n+            this.persistenceManager = persistenceManager;\n+            this.switchOnlineStatusMonitor = switchOnlineStatusMonitor;\n+            this.endpointStatusMonitor = endpointStatusMonitor;\n+            this.carrier = carrier;\n \n             builder = StateMachineBuilderFactory.create(\n                     BfdSessionFsm.class, State.class, Event.class, BfdSessionFsmContext.class,\n                     // extra parameters\n-                    PersistenceManager.class, Endpoint.class, Integer.class);\n+                    PersistenceManager.class, SwitchOnlineStatusMonitor.class, EndpointStatusMonitor.class,\n+                    IBfdSessionCarrier.class, Endpoint.class, Integer.class, BfdSessionData.class);\n \n-            // INIT\n-            builder.transition()\n-                    .from(State.INIT).to(State.INIT_CHOICE).on(Event.HISTORY)\n-                    .callMethod(\"consumeHistory\");\n+            final String sessionRemoveAction = \"sessionRemoveAction\";\n+            final String emitBfdFailAction = \"emitBfdFailAction\";\n \n-            // INIT_CHOICE\n-            builder.transition()\n-                    .from(State.INIT_CHOICE).to(State.IDLE).on(Event._INIT_CHOICE_CLEAN);\n-            builder.transition()\n-                    .from(State.INIT_CHOICE).to(State.INIT_REMOVE).on(Event._INIT_CHOICE_DIRTY);\n-            builder.onEntry(State.INIT_CHOICE)\n-                    .callMethod(\"handleInitChoice\");\n-\n-            // IDLE\n-            builder.transition()\n-                    .from(State.IDLE).to(State.INIT_SETUP).on(Event.ENABLE_UPDATE)\n-                    .callMethod(saveIslReferenceMethod);\n-            builder.transition()\n-                    .from(State.IDLE).to(State.UNOPERATIONAL).on(Event.OFFLINE);\n-            builder.onEntry(State.IDLE)\n-                    .callMethod(\"idleEnter\");\n-\n-            // UNOPERATIONAL\n-            builder.transition()\n-                    .from(State.UNOPERATIONAL).to(State.IDLE).on(Event.ONLINE);\n-            builder.transition()\n-                    .from(State.UNOPERATIONAL).to(State.PENDING).on(Event.ENABLE_UPDATE)\n-                    .callMethod(savePropertiesMethod);\n-\n-            // PENDING\n-            builder.transition()\n-                    .from(State.PENDING).to(State.UNOPERATIONAL).on(Event.DISABLE);\n-            builder.transition()\n-                    .from(State.PENDING).to(State.INIT_SETUP).on(Event.ONLINE);\n-            builder.onEntry(State.PENDING)\n-                    .callMethod(saveIslReferenceMethod);\n-\n-            // INIT_SETUP\n-            builder.transition()\n-                    .from(State.INIT_SETUP).to(State.IDLE).on(Event.FAIL);\n-            builder.transition()\n-                    .from(State.INIT_SETUP).to(State.DO_SETUP).on(Event.NEXT);\n-            builder.onEntry(State.INIT_SETUP)\n-                    .callMethod(\"doAllocateResources\");\n-\n-            // DO_SETUP\n-            builder.transition()\n-                    .from(State.DO_SETUP).to(State.ACTIVE).on(Event.ACTION_SUCCESS)\n-                    .callMethod(\"reportSetupSuccess\");\n-            builder.transition()\n-                    .from(State.DO_SETUP).to(State.INIT_REMOVE).on(Event.DISABLE);\n+            // ENTER\n+            builder.onEntry(State.ENTER)\n+                    .callMethod(\"enterEnterAction\");", "originalCommit": "038dda8a5c0fe398b0e862606751c0574f0d03ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAwMjY2Mw==", "url": "https://github.com/telstra/open-kilda/pull/3819#discussion_r527002663", "bodyText": "... I would not do it. Besides, I don't see issues in enterEnter name.", "author": "surabujin", "createdAt": "2020-11-19T16:00:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQwODU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQxNzU1NQ==", "url": "https://github.com/telstra/open-kilda/pull/3819#discussion_r524417555", "bodyText": "switchId -> reference", "author": "rozdy", "createdAt": "2020-11-16T16:52:10Z", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/utils/BaseMonitor.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.network.utils;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public abstract class BaseMonitor<R, L, S, E extends BaseMonitorEntry<L, S>> {\n+    protected final Map<R, E> monitors = new HashMap<>();\n+\n+    public S subscribe(R switchId, L listener) {", "originalCommit": "038dda8a5c0fe398b0e862606751c0574f0d03ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAwMzYyNA==", "url": "https://github.com/telstra/open-kilda/pull/3819#discussion_r527003624", "bodyText": "fixed (evolution artifact).", "author": "surabujin", "createdAt": "2020-11-19T16:01:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQxNzU1NQ=="}], "type": "inlineReview"}, {"oid": "cfbbd602049e3d6ccca59822576b0fcb8ffb121e", "url": "https://github.com/telstra/open-kilda/commit/cfbbd602049e3d6ccca59822576b0fcb8ffb121e", "message": "Move BFD session transition code out of FSM\n\nAs part of BFD session FSM simplification, all code responsible for\nswitch/transfer between different session sessions has been moved out of\nFSM. Now it implemented as plain java code.", "committedDate": "2020-11-19T16:13:06Z", "type": "forcePushed"}, {"oid": "3cf20cae788d4cffd3af7514a5fc296d14172a2b", "url": "https://github.com/telstra/open-kilda/commit/3cf20cae788d4cffd3af7514a5fc296d14172a2b", "message": "Move BFD session transition code out of FSM\n\nAs part of BFD session FSM simplification, all code responsible for\nswitch/transfer between different session sessions has been moved out of\nFSM. Now it implemented as plain java code.", "committedDate": "2020-12-03T11:21:06Z", "type": "commit"}, {"oid": "3cf20cae788d4cffd3af7514a5fc296d14172a2b", "url": "https://github.com/telstra/open-kilda/commit/3cf20cae788d4cffd3af7514a5fc296d14172a2b", "message": "Move BFD session transition code out of FSM\n\nAs part of BFD session FSM simplification, all code responsible for\nswitch/transfer between different session sessions has been moved out of\nFSM. Now it implemented as plain java code.", "committedDate": "2020-12-03T11:21:06Z", "type": "forcePushed"}]}