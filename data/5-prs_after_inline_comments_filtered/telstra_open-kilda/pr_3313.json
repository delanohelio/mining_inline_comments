{"pr_number": 3313, "pr_title": "Toolset for cookie bit manipulations", "pr_createdAt": "2020-03-18T13:36:28Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3313", "timeline": [{"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "url": "https://github.com/telstra/open-kilda/commit/97ddfaefcb8a3d297c9937caec65ca6114ac466e", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-03-23T08:47:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MTI5NQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399961295", "bodyText": "Why methods in Schema are not static? Are they have some state?\nWe have only 2 directions. Do we really need to pass direction emun every time? Maybe it's better to create 2 methods like: makeForward(long effectiveId) and makeReverse(long effectiveId)?\n\nBecause of these 2 points we have to use\nFlowSegmentCookieSchema.INSTANCE.make(cookie, FlowPathDirection.FORWARD)\ninstead of\nFlowSegmentCookieSchema.makeForward(cookie)", "author": "niksv", "createdAt": "2020-03-30T06:50:10Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {\n+        return setFlowEffectiveId(makeBlank(), effectiveId);\n+    }\n+\n+    public Cookie make(long effectiveId, FlowPathDirection direction) {", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYwODM5OQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401608399", "bodyText": "1 - there are too many limits from static methods and no benefits (if you take a look at #3331 you will see that in some cases schemas can inherit each other).\n2 - direction can be not only written in the cookie but read too.", "author": "surabujin", "createdAt": "2020-04-01T13:19:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MTI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MjMzOQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399962339", "bodyText": "why effective? what does it mean?", "author": "niksv", "createdAt": "2020-03-30T06:52:49Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYwOTA4Mw==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401609083", "bodyText": "This is my personal... preferences, I follow naming style of linux/unix system ('effective' term goes from effective-user-id term - this is not some constant ID but ID used right now, I believe it is close enough to our use case). Propose a better term.", "author": "surabujin", "createdAt": "2020-04-01T13:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MjMzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1Njg4Ng==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r404656886", "bodyText": "+1 to @niksv for me it doesn't meaningful, let's try to rename?", "author": "timofei-durakov", "createdAt": "2020-04-07T09:11:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MjMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzAwOQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399963009", "bodyText": "What if direction flag is NOT set? is it a valid case?", "author": "niksv", "createdAt": "2020-03-30T06:54:25Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {\n+        return setFlowEffectiveId(makeBlank(), effectiveId);\n+    }\n+\n+    public Cookie make(long effectiveId, FlowPathDirection direction) {\n+        Cookie cookie = setFlowEffectiveId(makeBlank(), effectiveId);\n+        return setDirection(cookie, direction);\n+    }\n+\n+    @Override\n+    public Cookie makeBlank() {\n+        return new Cookie(setType(0, CookieType.SERVICE_OR_FLOW_SEGMENT));\n+    }\n+\n+    @Override\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        super.validate(cookie);\n+\n+        validateServiceFlag(cookie, false);\n+\n+        long raw = cookie.getValue();\n+        int directionBitsSetCount = 0;\n+        BitField[] mutuallyExclusiveFlags = {FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG};\n+        for (BitField field : mutuallyExclusiveFlags) {\n+            directionBitsSetCount += getField(raw, field);\n+        }\n+\n+        if (1 < directionBitsSetCount) {\n+            throw new InvalidCookieException(\"Illegal flags combination - both the direction bits are set\", cookie);\n+        }", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYxNDU2NA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401614564", "bodyText": "The current implementation (https://github.com/telstra/open-kilda/blob/develop/src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java#L234) do not enforce presence of direction bits. I do not want to introduce this limit now.", "author": "surabujin", "createdAt": "2020-04-01T13:28:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjAwOA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399966008", "bodyText": "Why LLDP type and ARP type have different naming?\nI guess it must be LLDP_INPUT_CUSTOMER_TYPE and ARP_INPUT_CUSTOMER_TYPE", "author": "niksv", "createdAt": "2020-03-30T07:01:23Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+public abstract class CookieSchema {\n+    // update ALL_FIELDS if modify fields list\n+    static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n+    static final BitField TYPE_FIELD   = new BitField(0x1FF0_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n+\n+    protected abstract Cookie makeBlank();\n+\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        // inheritors can implement validate logic\n+    }\n+\n+    /**\n+     * Extract and return \"type\" field.\n+     */\n+    public CookieType getType(Cookie cookie) {\n+        return resolveEnum(CookieType.values(), getRawType(cookie), CookieType.class);\n+    }\n+\n+    // TODO: drop?\n+    protected int getRawType(Cookie cookie) {\n+        return (int) getField(cookie.getValue(), TYPE_FIELD);\n+    }\n+\n+    protected long setType(long value, CookieType type) {\n+        return setField(value, TYPE_FIELD, type.getValue());\n+    }\n+\n+    protected long getField(long value, BitField field) {\n+        long payload = value & field.getMask();\n+        return payload >>> field.getOffset();\n+    }\n+\n+    protected Cookie setField(Cookie cookie, BitField field, long payload) {\n+        long raw = setField(cookie.getValue(), field, payload);\n+        return new Cookie(raw);\n+    }\n+\n+    protected long setField(long value, BitField field, long payload) {\n+        long mask = field.getMask();\n+        payload <<= field.getOffset();\n+        payload &= mask;\n+        return (value & ~mask) | payload;\n+    }\n+\n+    protected void validateServiceFlag(Cookie cookie, boolean expectedValue) throws InvalidCookieException {\n+        boolean actual = getField(cookie.getValue(), SERVICE_FLAG) != 0;\n+        if (expectedValue != actual) {\n+            throw new InvalidCookieException(\n+                    String.format(\"Service flag is expected to be %s\", expectedValue ? \"set\" : \"unset\"), cookie);\n+        }\n+    }\n+\n+    protected static <T extends NumericEnumField> T resolveEnum(T[] valuesSpace, long needle, Class<T> typeRef) {\n+        for (T entry : valuesSpace) {\n+            if (entry.getValue() == needle) {\n+                return entry;\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(String.format(\n+                \"Unable to map value %x value into %s value\", needle, typeRef.getSimpleName()));\n+    }\n+\n+    // 9 bit long field\n+    public enum CookieType implements NumericEnumField {\n+        SERVICE_OR_FLOW_SEGMENT(0x000),\n+        LLDP(0x001),", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYxODcxOQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401618719", "bodyText": "Because... I took it from the existing definition in Cookie.java (it was renamed later). Renamed.", "author": "surabujin", "createdAt": "2020-04-01T13:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NzUyNg==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399967526", "bodyText": "why effective? It is confusing. Do you mean \"unmasked cookie\" or something else?", "author": "niksv", "createdAt": "2020-03-30T07:04:54Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {\n+        return setFlowEffectiveId(makeBlank(), effectiveId);\n+    }\n+\n+    public Cookie make(long effectiveId, FlowPathDirection direction) {\n+        Cookie cookie = setFlowEffectiveId(makeBlank(), effectiveId);\n+        return setDirection(cookie, direction);\n+    }\n+\n+    @Override\n+    public Cookie makeBlank() {\n+        return new Cookie(setType(0, CookieType.SERVICE_OR_FLOW_SEGMENT));\n+    }\n+\n+    @Override\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        super.validate(cookie);\n+\n+        validateServiceFlag(cookie, false);\n+\n+        long raw = cookie.getValue();\n+        int directionBitsSetCount = 0;\n+        BitField[] mutuallyExclusiveFlags = {FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG};\n+        for (BitField field : mutuallyExclusiveFlags) {\n+            directionBitsSetCount += getField(raw, field);\n+        }\n+\n+        if (1 < directionBitsSetCount) {\n+            throw new InvalidCookieException(\"Illegal flags combination - both the direction bits are set\", cookie);\n+        }\n+    }\n+\n+    /**\n+     * Read the direction bits and return direction as {@link FlowPathDirection} constant.\n+     *\n+     * <p>Raise {@link IllegalArgumentException} if all direction bits are equal to 0.\n+     */\n+    public FlowPathDirection getValidatedDirection(Cookie cookie) {\n+        FlowPathDirection direction = getDirection(cookie);\n+        if (FlowPathDirection.UNKNOWN == direction) {\n+            throw new IllegalArgumentException(String.format(\"Cookie %s have no the direction marker\", cookie));\n+        }\n+        return direction;\n+    }\n+\n+    /**\n+     * Extract and return normalized representation flow path direction.\n+     */\n+    public FlowPathDirection getDirection(Cookie cookie) {\n+        long raw = cookie.getValue();\n+        if (getField(raw, FLOW_FORWARD_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.FORWARD;\n+        } else if (getField(raw, FLOW_REVERSE_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.REVERSE;\n+        } else {\n+            return FlowPathDirection.UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Set direction bits to the value passed as directions argument.\n+     */\n+    public Cookie setDirection(Cookie cookie, FlowPathDirection direction) {\n+        int forward = 0;\n+        int reverse = 0;\n+        if (direction == FlowPathDirection.FORWARD) {\n+            forward = 1;\n+        } else if (direction == FlowPathDirection.REVERSE) {\n+            reverse = 1;\n+        } else if (direction == FlowPathDirection.UNKNOWN) {\n+            // nothing to do\n+        } else {\n+            throw new IllegalArgumentException(String.format(\n+                    \"Unable to map %s.%s into cookie direction bits\",\n+                    FlowPathDirection.class.getSimpleName(), direction));\n+        }\n+\n+        long raw = setField(cookie.getValue(), FLOW_FORWARD_DIRECTION_FLAG, forward);\n+        raw = setField(raw, FLOW_REVERSE_DIRECTION_FLAG, reverse);\n+        return new Cookie(raw);\n+    }\n+\n+    public Cookie setFlowEffectiveId(Cookie cookie, long effectiveId) {\n+        return new Cookie(setField(cookie.getValue(), FLOW_EFFECTIVE_ID_FIELD, effectiveId));", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYxOTE3MA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401619170", "bodyText": "You have already asked it.", "author": "surabujin", "createdAt": "2020-04-01T13:34:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NzUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2OTk3Ng==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399969976", "bodyText": "maybe we need to add Method isForward()?", "author": "niksv", "createdAt": "2020-03-30T07:10:05Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/adapter/FlowSideAdapter.java", "diffHunk": "@@ -40,7 +42,7 @@ public static FlowSideAdapter makeIngressAdapter(Flow flow, FlowPath path) {\n      * Determine \"forward\" direction for provided flow/path pair and create adapter to access dest endpoint.\n      */\n     public static FlowSideAdapter makeEgressAdapter(Flow flow, FlowPath path) {\n-        if (path.getCookie().isMaskedAsForward()) {\n+        if (FlowSegmentCookieSchema.INSTANCE.getValidatedDirection(path.getCookie()) == FlowPathDirection.FORWARD) {", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyMDM2Nw==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401620367", "bodyText": "No. Read direction and compare.\nYou will need too many such 'isSomething()` methods.", "author": "surabujin", "createdAt": "2020-04-01T13:36:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2OTk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MjQzMg==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399972432", "bodyText": "Why do we need to set UNKNOWN direction? where it can be used?", "author": "niksv", "createdAt": "2020-03-30T07:15:13Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {\n+        return setFlowEffectiveId(makeBlank(), effectiveId);\n+    }\n+\n+    public Cookie make(long effectiveId, FlowPathDirection direction) {\n+        Cookie cookie = setFlowEffectiveId(makeBlank(), effectiveId);\n+        return setDirection(cookie, direction);\n+    }\n+\n+    @Override\n+    public Cookie makeBlank() {\n+        return new Cookie(setType(0, CookieType.SERVICE_OR_FLOW_SEGMENT));\n+    }\n+\n+    @Override\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        super.validate(cookie);\n+\n+        validateServiceFlag(cookie, false);\n+\n+        long raw = cookie.getValue();\n+        int directionBitsSetCount = 0;\n+        BitField[] mutuallyExclusiveFlags = {FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG};\n+        for (BitField field : mutuallyExclusiveFlags) {\n+            directionBitsSetCount += getField(raw, field);\n+        }\n+\n+        if (1 < directionBitsSetCount) {\n+            throw new InvalidCookieException(\"Illegal flags combination - both the direction bits are set\", cookie);\n+        }\n+    }\n+\n+    /**\n+     * Read the direction bits and return direction as {@link FlowPathDirection} constant.\n+     *\n+     * <p>Raise {@link IllegalArgumentException} if all direction bits are equal to 0.\n+     */\n+    public FlowPathDirection getValidatedDirection(Cookie cookie) {\n+        FlowPathDirection direction = getDirection(cookie);\n+        if (FlowPathDirection.UNKNOWN == direction) {\n+            throw new IllegalArgumentException(String.format(\"Cookie %s have no the direction marker\", cookie));\n+        }\n+        return direction;\n+    }\n+\n+    /**\n+     * Extract and return normalized representation flow path direction.\n+     */\n+    public FlowPathDirection getDirection(Cookie cookie) {\n+        long raw = cookie.getValue();\n+        if (getField(raw, FLOW_FORWARD_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.FORWARD;\n+        } else if (getField(raw, FLOW_REVERSE_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.REVERSE;\n+        } else {\n+            return FlowPathDirection.UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Set direction bits to the value passed as directions argument.\n+     */\n+    public Cookie setDirection(Cookie cookie, FlowPathDirection direction) {\n+        int forward = 0;\n+        int reverse = 0;\n+        if (direction == FlowPathDirection.FORWARD) {\n+            forward = 1;\n+        } else if (direction == FlowPathDirection.REVERSE) {\n+            reverse = 1;\n+        } else if (direction == FlowPathDirection.UNKNOWN) {\n+            // nothing to do", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyMTQwOA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401621408", "bodyText": "Because direction bits are not enforced.", "author": "surabujin", "createdAt": "2020-04-01T13:38:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MjQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3NjExOA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399976118", "bodyText": "I think this is not a best way to set a field. Try to put setField(cookie.getValue(), FLOW_FORWARD_DIRECTION_FLAG, forward); into if (direction == FlowPathDirection.FORWARD) {\nSomething like this:\n        long raw = cookie.getValue();\n        if (direction == FlowPathDirection.FORWARD) {\n            raw = setField(cookie.getValue(), FLOW_FORWARD_DIRECTION_FLAG, 1);\n        } else if (direction == FlowPathDirection.REVERSE) {\n            raw = setField(raw, FLOW_REVERSE_DIRECTION_FLAG, 1);\n        } else if (direction == FlowPathDirection.UNKNOWN) {\n            // nothing to do\n        } else {\n            throw new IllegalArgumentException(String.format(\n                    \"Unable to map %s.%s into cookie direction bits\",\n                    FlowPathDirection.class.getSimpleName(), direction));\n        }\n\n        return new Cookie(raw);", "author": "niksv", "createdAt": "2020-03-30T07:23:03Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {\n+        return setFlowEffectiveId(makeBlank(), effectiveId);\n+    }\n+\n+    public Cookie make(long effectiveId, FlowPathDirection direction) {\n+        Cookie cookie = setFlowEffectiveId(makeBlank(), effectiveId);\n+        return setDirection(cookie, direction);\n+    }\n+\n+    @Override\n+    public Cookie makeBlank() {\n+        return new Cookie(setType(0, CookieType.SERVICE_OR_FLOW_SEGMENT));\n+    }\n+\n+    @Override\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        super.validate(cookie);\n+\n+        validateServiceFlag(cookie, false);\n+\n+        long raw = cookie.getValue();\n+        int directionBitsSetCount = 0;\n+        BitField[] mutuallyExclusiveFlags = {FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG};\n+        for (BitField field : mutuallyExclusiveFlags) {\n+            directionBitsSetCount += getField(raw, field);\n+        }\n+\n+        if (1 < directionBitsSetCount) {\n+            throw new InvalidCookieException(\"Illegal flags combination - both the direction bits are set\", cookie);\n+        }\n+    }\n+\n+    /**\n+     * Read the direction bits and return direction as {@link FlowPathDirection} constant.\n+     *\n+     * <p>Raise {@link IllegalArgumentException} if all direction bits are equal to 0.\n+     */\n+    public FlowPathDirection getValidatedDirection(Cookie cookie) {\n+        FlowPathDirection direction = getDirection(cookie);\n+        if (FlowPathDirection.UNKNOWN == direction) {\n+            throw new IllegalArgumentException(String.format(\"Cookie %s have no the direction marker\", cookie));\n+        }\n+        return direction;\n+    }\n+\n+    /**\n+     * Extract and return normalized representation flow path direction.\n+     */\n+    public FlowPathDirection getDirection(Cookie cookie) {\n+        long raw = cookie.getValue();\n+        if (getField(raw, FLOW_FORWARD_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.FORWARD;\n+        } else if (getField(raw, FLOW_REVERSE_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.REVERSE;\n+        } else {\n+            return FlowPathDirection.UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Set direction bits to the value passed as directions argument.\n+     */\n+    public Cookie setDirection(Cookie cookie, FlowPathDirection direction) {\n+        int forward = 0;\n+        int reverse = 0;\n+        if (direction == FlowPathDirection.FORWARD) {\n+            forward = 1;\n+        } else if (direction == FlowPathDirection.REVERSE) {\n+            reverse = 1;\n+        } else if (direction == FlowPathDirection.UNKNOWN) {\n+            // nothing to do\n+        } else {\n+            throw new IllegalArgumentException(String.format(\n+                    \"Unable to map %s.%s into cookie direction bits\",\n+                    FlowPathDirection.class.getSimpleName(), direction));\n+        }\n+\n+        long raw = setField(cookie.getValue(), FLOW_FORWARD_DIRECTION_FLAG, forward);\n+        raw = setField(raw, FLOW_REVERSE_DIRECTION_FLAG, reverse);", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyNDA1Mg==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401624052", "bodyText": "I still don't see any benefits here. Is the benefit in not defining 2 int variables?\nPS You lost 0 0 variant (\"nothing to do branch\"), plus you must update both bits, or you can make the cookie with both direction bits set.", "author": "surabujin", "createdAt": "2020-04-01T13:41:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3NjExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwOTM3OQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r400009379", "bodyText": "you can use @Test(expected = IllegalArgumentException.class) for such tests\n    @Test(expected = IllegalArgumentException.class)\n    public void ensureNoEmptyMasks() {\n             new BitField(0);\n    }", "author": "niksv", "createdAt": "2020-03-30T08:23:25Z", "path": "src-java/kilda-model/src/test/java/org/openkilda/model/bitops/cookie/CookieSchemaTest.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class CookieSchemaTest extends GenericCookieSchemaTest {\n+    @Test\n+    public void ensureNoEmptyMasks() {\n+        try {\n+            new BitField(0);\n+            Assert.fail();\n+        } catch (IllegalArgumentException e) {\n+            // expected behaviour\n+        }\n+    }", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyNTQzMA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401625430", "bodyText": "ok", "author": "surabujin", "createdAt": "2020-04-01T13:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwOTM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwOTQ2OQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r400009469", "bodyText": "same", "author": "niksv", "createdAt": "2020-03-30T08:23:33Z", "path": "src-java/kilda-model/src/test/java/org/openkilda/model/bitops/cookie/CookieSchemaTest.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class CookieSchemaTest extends GenericCookieSchemaTest {\n+    @Test\n+    public void ensureNoEmptyMasks() {\n+        try {\n+            new BitField(0);\n+            Assert.fail();\n+        } catch (IllegalArgumentException e) {\n+            // expected behaviour\n+        }\n+    }\n+\n+    @Test\n+    public void ensureNoGapsInMask() {\n+        try {\n+            new BitField(5);\n+            Assert.fail();\n+        } catch (IllegalArgumentException e) {\n+            // expected behaviour\n+        }", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAxMzgyMA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r400013820", "bodyText": "why 9?\nit is 1001 as binary. should it be 7FF0?", "author": "niksv", "createdAt": "2020-03-30T08:30:54Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/ServiceCookieSchema.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.MeterId;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ServiceCookieSchema extends CookieSchema {\n+    public static final ServiceCookieSchema INSTANCE = new ServiceCookieSchema();\n+\n+    private static final Set<CookieType> allowedTypes = Stream.of(\n+            CookieType.SERVICE_OR_FLOW_SEGMENT,\n+            CookieType.LLDP,\n+            CookieType.MULTI_TABLE_ISL_VLAN_EGRESS_RULES,\n+            CookieType.MULTI_TABLE_ISL_VXLAN_EGRESS_RULES,\n+            CookieType.MULTI_TABLE_ISL_VXLAN_TRANSIT_RULES,\n+            CookieType.MULTI_TABLE_INGRESS_RULES,\n+            CookieType.ARP_INPUT_CUSTOMER_TYPE\n+    ).collect(Collectors.toSet());\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                   used by generic cookie -> 0x9FF0_0000_0000_0000L", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYzMDI3Mw==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401630273", "bodyText": "hex(0x8000000000000000 | 0x1ff0000000000000) => 0x9ff0000000000000\nbin(0x8000000000000000 | 0x1ff0000000000000) => 0b1001111111110000000000000000000000000000000000000000000000000000", "author": "surabujin", "createdAt": "2020-04-01T13:49:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAxMzgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAxMzg4Mw==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r400013883", "bodyText": "why 9?\nit is 1001 as binary. should it be 7FF0?", "author": "niksv", "createdAt": "2020-03-30T08:31:00Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAyNjA3MA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r400026070", "bodyText": "Honestly I don't like the idea of creating so many classes (schemas, types, etc).\nCookie class is a one place were you can find all information related to cookie(types, subtypes, schema with description of all bits used in cookie)\nInformation from the left(which were removed ) is readable, complete and easy understandable.\nNow we have several classes, with several subtypes, placed in different files. It's hard to work with such number of classes. It's easy to make a mistake. Usage in code doesn't looks like a syntax sugar. Example\nWas:\nlong cookie = flowResources.getUnmaskedCookie();\nCookie.buildForwardCookie(cookie)\n\nNow:\nCookie blank = FlowSegmentCookieSchema.INSTANCE.makeBlank();\nCookie flowCookie = FlowSegmentCookieSchema.INSTANCE.setFlowEffectiveId(\nblank, flowResources.getUnmaskedCookie());\nFlowSegmentCookieSchema.INSTANCE.setDirection(flowCookie, FlowPathDirection.FORWARD)\n\nMaybe we shouldn't make simple things difficult?", "author": "niksv", "createdAt": "2020-03-30T08:50:51Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java", "diffHunk": "@@ -45,101 +47,110 @@\n  * </p>\n  */\n @Value\n+@EqualsAndHashCode(of = {\"value\"})\n public class Cookie implements Comparable<Cookie>, Serializable {\n     private static final long serialVersionUID = 1L;\n \n-    public static final long DEFAULT_RULE_FLAG                   = 0x8000_0000_0000_0000L;\n-    public static final long FLOW_PATH_FORWARD_FLAG              = 0x4000_0000_0000_0000L;\n-    public static final long FLOW_PATH_REVERSE_FLAG              = 0x2000_0000_0000_0000L;\n-\n-    // There is no alive system that use this deprecated direction flags so it should be save to drop it.\n-    @Deprecated\n-    public static final long DEPRECATED_FLOW_PATH_DIRECTION_FLAG = 0x0080_0000_0000_0000L;\n-    public static final long FLOW_COOKIE_VALUE_MASK              = 0x0000_0000_000F_FFFFL;\n-    public static final long ISL_COOKIE_VALUE_MASK               = 0x0000_0000_000F_FFFFL;\n-    public static final long INGRESS_RULE_COOKIE_VALUE_MASK      = 0x0000_0000_000F_FFFFL;\n-\n-    public static final long DROP_RULE_COOKIE                           = 0x01L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_BROADCAST_RULE_COOKIE         = 0x02L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_UNICAST_RULE_COOKIE           = 0x03L | DEFAULT_RULE_FLAG;\n-    public static final long DROP_VERIFICATION_LOOP_RULE_COOKIE         = 0x04L | DEFAULT_RULE_FLAG;\n-    public static final long CATCH_BFD_RULE_COOKIE                      = 0x05L | DEFAULT_RULE_FLAG;\n-    public static final long ROUND_TRIP_LATENCY_RULE_COOKIE             = 0x06L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_UNICAST_VXLAN_RULE_COOKIE     = 0x07L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE = 0x08L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_INGRESS_DROP_COOKIE             = 0x09L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_POST_INGRESS_DROP_COOKIE        = 0x0AL | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_EGRESS_PASS_THROUGH_COOKIE      = 0x0BL | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_TRANSIT_DROP_COOKIE             = 0x0CL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_INPUT_PRE_DROP_COOKIE                 = 0x0DL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_TRANSIT_COOKIE                        = 0x0EL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_INGRESS_COOKIE                        = 0x0FL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_COOKIE                   = 0x10L | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_VXLAN_COOKIE             = 0x11L | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_ONE_SWITCH_COOKIE        = 0x12L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_INPUT_PRE_DROP_COOKIE                  = 0x13L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_TRANSIT_COOKIE                         = 0x14L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_INGRESS_COOKIE                         = 0x15L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_COOKIE                    = 0x16L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_VXLAN_COOKIE              = 0x17L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_ONE_SWITCH_COOKIE         = 0x18L | DEFAULT_RULE_FLAG;\n-\n-    // 9 bits cookie type \"field\"\n-    public static final long TYPE_MASK                               = 0x1FF0_0000_0000_0000L;\n-    public static final long FLOW_COOKIE_TYPE                        = 0x0000_0000_0000_0000L;\n-    public static final long LLDP_INPUT_CUSTOMER_TYPE                = 0x0010_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VLAN_EGRESS_RULES_TYPE   = 0x0020_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VXLAN_EGRESS_RULES_TYPE  = 0x0030_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VXLAN_TRANSIT_RULES_TYPE = 0x0040_0000_0000_0000L;\n-    public static final long MULTITABLE_INGRESS_RULES_TYPE           = 0x0050_0000_0000_0000L;\n-    public static final long ARP_INPUT_CUSTOMER_TYPE                 = 0x0060_0000_0000_0000L;\n-\n-    private final long value;\n-\n-    /**\n-     * Create {@code Cookie} instance and perform it's validation.\n-     */\n-    public static Cookie decode(long rawValue) {\n-        Cookie cookie = new Cookie(rawValue);\n-        cookie.ensureNoFlagsConflicts();\n-        return cookie;\n-    }\n+    // FIXME(surabujin): get rid from this constants", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY0MjY0NA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401642644", "bodyText": "At first, we have used long type to represent cookie in our code. It produced a great number of different errors in all imaginable places. So it was wrapped into special type to ensure that if code expect the cookie it will receive the cookie and compiler will guarantee this - this is when Cookie class appears. At some later point, this guarantee was eliminated with methods like\n    public static long encodeIslVlanEgress(int port) {\n        return new Cookie(port | DEFAULT_RULE_FLAG)\n                .setType(CookieType.MULTI_TABLE_ISL_VLAN_EGRESS_RULES)\n                .getValue();\n    }\n\ni.e. methods that receive simple/generic type and return simple/generic type.\nLater cookie \"schema\" becomes more complex - type field was introduced and this field defines the meaning of other bits. So now cookie have not documented and not defined in any way restrictions which bits can be defined at the same time and which must collide. Keeping this all in \"simple\" way how it now - is keeping it in the way this restriction can't be easily defined in code and as the result can't be covered with tests.\nThe goal of all these \"extra classes as you say\" is to define each \"conflicting\" schema in its own class. It is verbose enough way to define \"compatible\" bits (and not compatible). Another goal is to eliminate the possibility to use simple/generic types instead of Cookie type (but it can't be reached so easy).", "author": "surabujin", "createdAt": "2020-04-01T14:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAyNjA3MA=="}], "type": "inlineReview"}, {"oid": "bc5b9e18387ae5eaeb4125dc40722eb55e50ad81", "url": "https://github.com/telstra/open-kilda/commit/bc5b9e18387ae5eaeb4125dc40722eb55e50ad81", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-01T15:56:41Z", "type": "forcePushed"}, {"oid": "4cf03b92f9d6af815863798c1b4a8216dd65f16a", "url": "https://github.com/telstra/open-kilda/commit/4cf03b92f9d6af815863798c1b4a8216dd65f16a", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-02T12:23:43Z", "type": "forcePushed"}, {"oid": "fad4c687d5a5138b887dd521e1d2356c2533828b", "url": "https://github.com/telstra/open-kilda/commit/fad4c687d5a5138b887dd521e1d2356c2533828b", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-02T13:14:03Z", "type": "forcePushed"}, {"oid": "5cf0df10539a775f8eace6e31727df522945edf6", "url": "https://github.com/telstra/open-kilda/commit/5cf0df10539a775f8eace6e31727df522945edf6", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-02T17:36:23Z", "type": "forcePushed"}, {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "url": "https://github.com/telstra/open-kilda/commit/16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-06T11:14:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY0NzUwMA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r404647500", "bodyText": "this approach will lead to issue in future, it's like using Maps instead of Class Objects", "author": "timofei-durakov", "createdAt": "2020-04-07T08:56:05Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+public abstract class CookieSchema {\n+    // update ALL_FIELDS if modify fields list\n+    static final BitField TYPE_FIELD   = new BitField(0x1FF0_0000_0000_0000L);\n+    static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n+\n+    protected abstract Cookie makeBlank();\n+\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        // inheritors can implement validate logic\n+    }\n+\n+    /**\n+     * Extract and return \"type\" field.\n+     */\n+    public CookieType getType(Cookie cookie) {\n+        int numericType = (int) getField(cookie.getValue(), TYPE_FIELD);\n+        return resolveEnum(CookieType.values(), numericType, CookieType.class);\n+    }\n+\n+    protected long setType(long value, CookieType type) {\n+        return setField(value, TYPE_FIELD, type.getValue());\n+    }\n+\n+    protected long getField(long value, BitField field) {\n+        long payload = value & field.getMask();\n+        return payload >>> field.getOffset();\n+    }\n+\n+    protected Cookie setField(Cookie cookie, BitField field, long payload) {\n+        long raw = setField(cookie.getValue(), field, payload);\n+        return new Cookie(raw);\n+    }", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4MDQ3NQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405480475", "bodyText": "+1 Please, consider introducing a cookie builder.", "author": "sergii-iakovenko", "createdAt": "2020-04-08T12:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY0NzUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgwNjM0NA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r406806344", "bodyText": "...", "author": "surabujin", "createdAt": "2020-04-10T15:22:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY0NzUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY0OTcwMQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r404649701", "bodyText": "why not switch/case?", "author": "timofei-durakov", "createdAt": "2020-04-07T08:59:24Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {\n+        return setFlowEffectiveId(makeBlank(), effectiveId);\n+    }\n+\n+    public Cookie make(long effectiveId, FlowPathDirection direction) {\n+        Cookie cookie = setFlowEffectiveId(makeBlank(), effectiveId);\n+        return setDirection(cookie, direction);\n+    }\n+\n+    @Override\n+    public Cookie makeBlank() {\n+        return new Cookie(setType(0, CookieType.SERVICE_OR_FLOW_SEGMENT));\n+    }\n+\n+    @Override\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        super.validate(cookie);\n+\n+        validateServiceFlag(cookie, false);\n+\n+        long raw = cookie.getValue();\n+        int directionBitsSetCount = 0;\n+        BitField[] mutuallyExclusiveFlags = {FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG};\n+        for (BitField field : mutuallyExclusiveFlags) {\n+            directionBitsSetCount += getField(raw, field);\n+        }\n+\n+        if (1 < directionBitsSetCount) {\n+            throw new InvalidCookieException(\"Illegal flags combination - both the direction bits are set\", cookie);\n+        }\n+    }\n+\n+    /**\n+     * Read the direction bits and return direction as {@link FlowPathDirection} constant.\n+     *\n+     * <p>Raise {@link IllegalArgumentException} if all direction bits are equal to 0.\n+     */\n+    public FlowPathDirection getValidatedDirection(Cookie cookie) {\n+        FlowPathDirection direction = getDirection(cookie);\n+        if (FlowPathDirection.UNKNOWN == direction) {\n+            throw new IllegalArgumentException(String.format(\"Cookie %s have no the direction marker\", cookie));\n+        }\n+        return direction;\n+    }\n+\n+    /**\n+     * Extract and return normalized representation flow path direction.\n+     */\n+    public FlowPathDirection getDirection(Cookie cookie) {\n+        long raw = cookie.getValue();\n+        if (getField(raw, FLOW_FORWARD_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.FORWARD;\n+        } else if (getField(raw, FLOW_REVERSE_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.REVERSE;\n+        } else {\n+            return FlowPathDirection.UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Set direction bits to the value passed as directions argument.\n+     */\n+    public Cookie setDirection(Cookie cookie, FlowPathDirection direction) {\n+        int forward = 0;\n+        int reverse = 0;\n+        if (direction == FlowPathDirection.FORWARD) {", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgwNjUzOQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r406806539", "bodyText": "don't matter.", "author": "surabujin", "createdAt": "2020-04-10T15:23:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY0OTcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1NTgzMA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r404655830", "bodyText": "this need a javadoc", "author": "timofei-durakov", "createdAt": "2020-04-07T09:09:22Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+public abstract class CookieSchema {\n+    // update ALL_FIELDS if modify fields list\n+    static final BitField TYPE_FIELD   = new BitField(0x1FF0_0000_0000_0000L);\n+    static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n+\n+    protected abstract Cookie makeBlank();\n+\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        // inheritors can implement validate logic\n+    }\n+\n+    /**\n+     * Extract and return \"type\" field.\n+     */\n+    public CookieType getType(Cookie cookie) {\n+        int numericType = (int) getField(cookie.getValue(), TYPE_FIELD);\n+        return resolveEnum(CookieType.values(), numericType, CookieType.class);\n+    }\n+\n+    protected long setType(long value, CookieType type) {\n+        return setField(value, TYPE_FIELD, type.getValue());\n+    }\n+\n+    protected long getField(long value, BitField field) {\n+        long payload = value & field.getMask();\n+        return payload >>> field.getOffset();\n+    }\n+\n+    protected Cookie setField(Cookie cookie, BitField field, long payload) {\n+        long raw = setField(cookie.getValue(), field, payload);\n+        return new Cookie(raw);\n+    }\n+\n+    protected long setField(long value, BitField field, long payload) {\n+        long mask = field.getMask();\n+        payload <<= field.getOffset();\n+        payload &= mask;\n+        return (value & ~mask) | payload;\n+    }\n+\n+    protected void validateServiceFlag(Cookie cookie, boolean expectedValue) throws InvalidCookieException {\n+        boolean actual = getField(cookie.getValue(), SERVICE_FLAG) != 0;\n+        if (expectedValue != actual) {\n+            throw new InvalidCookieException(\n+                    String.format(\"Service flag is expected to be %s\", expectedValue ? \"set\" : \"unset\"), cookie);\n+        }\n+    }\n+\n+    protected static <T extends NumericEnumField> T resolveEnum(T[] valuesSpace, long needle, Class<T> typeRef) {", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1OTA1NQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r404659055", "bodyText": "No java doc", "author": "timofei-durakov", "createdAt": "2020-04-07T09:14:25Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/BitField.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops;\n+\n+import org.openkilda.model.Cookie;\n+\n+import lombok.Getter;\n+\n+@Getter\n+public class BitField {", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM0ODI5OA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405348298", "bodyText": "nit: This could be a part of the generatedMap.", "author": "sergii-iakovenko", "createdAt": "2020-04-08T08:29:11Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/HistoryMapper.java", "diffHunk": "@@ -97,25 +99,18 @@\n      * Note: you have to additionally set {@link org.openkilda.wfm.share.history.model.FlowDumpData.DumpType}\n      * to the dump data.\n      */\n-    @Mapping(target = \"sourceSwitch\", expression = \"java(flow.getSrcSwitch().getSwitchId())\")\n-    @Mapping(target = \"destinationSwitch\", expression = \"java(flow.getDestSwitch().getSwitchId())\")\n-    @Mapping(source = \"flow.srcPort\", target = \"sourcePort\")\n-    @Mapping(source = \"flow.destPort\", target = \"destinationPort\")\n-    @Mapping(source = \"flow.srcVlan\", target = \"sourceVlan\")\n-    @Mapping(source = \"flow.destVlan\", target = \"destinationVlan\")\n-    @Mapping(source = \"flow.flowId\", target = \"flowId\")\n-    @Mapping(source = \"flow.bandwidth\", target = \"bandwidth\")\n-    @Mapping(source = \"flow.ignoreBandwidth\", target = \"ignoreBandwidth\")\n-    @Mapping(target = \"forwardCookie\", expression =\n-            \"java(org.openkilda.model.Cookie.buildForwardCookie(resources.getUnmaskedCookie()))\")\n-    @Mapping(target = \"reverseCookie\", expression =\n-            \"java(org.openkilda.model.Cookie.buildReverseCookie(resources.getUnmaskedCookie()))\")\n-    @Mapping(source = \"resources.forward.meterId\", target = \"forwardMeterId\")\n-    @Mapping(source = \"resources.reverse.meterId\", target = \"reverseMeterId\")\n-    @Mapping(source = \"dumpType\", target = \"dumpType\")\n-    @BeanMapping(ignoreByDefault = true)\n-    public abstract FlowDumpData map(Flow flow, FlowResources resources, DumpType dumpType);\n+    public FlowDumpData map(Flow flow, FlowResources resources, DumpType dumpType) {\n+        FlowDumpData result = generatedMap(flow, resources, dumpType);\n+\n+        result.setSourceSwitch(flow.getSrcSwitch().getSwitchId());", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxMDAwMw==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r406810003", "bodyText": "moved.", "author": "surabujin", "createdAt": "2020-04-10T15:30:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM0ODI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0MDY5Mg==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405440692", "bodyText": "nit: although there's no such rule in OpenKilda code convention, comparing of enum values in reverse argument order (CookieType.XYZ == cookieType instead of cookieType == CookieType.XYZ) is a controversial practice, which has no benefits but leads to poor readability. BTW, the sonar rule doesn't list this variant as a compliant one - https://rules.sonarsource.com/java/RSPEC-4551", "author": "sergii-iakovenko", "createdAt": "2020-04-08T11:03:06Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java", "diffHunk": "@@ -710,27 +714,27 @@ private Long processInstallDefaultFlowByCookie(SwitchId switchId, long cookie) t\n             return switchManager.installArpPostIngressOneSwitchFlow(dpid);\n         } else if (cookie == ARP_TRANSIT_COOKIE) {\n             return switchManager.installArpTransitFlow(dpid);\n-        } else if (Cookie.isIngressRulePassThrough(cookie)) {\n-            long port = Cookie.getValueFromIntermediateCookie(cookie);\n+        } else if (CookieType.MULTI_TABLE_INGRESS_RULES == cookieType) {\n+            long port = ServiceCookieSchema.INSTANCE.getUniqueId(encodedCookie);\n             return switchManager.installIntermediateIngressRule(dpid, (int) port);\n-        } else if (Cookie.isIslVlanEgress(cookie)) {\n-            long port = Cookie.getValueFromIntermediateCookie(cookie);\n+        } else if (CookieType.MULTI_TABLE_ISL_VLAN_EGRESS_RULES == cookieType) {", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxMjU5NQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r406812595", "bodyText": "Don't see any difference in readability - in any case you must read both sides of ==. Swapped.", "author": "surabujin", "createdAt": "2020-04-10T15:36:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0MDY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0MzY3OQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405443679", "bodyText": "Please, don't use internal or library-specific collection classes. In addition to standard java collections, we have 2 libraries in dependencies: apache commons and guava.", "author": "sergii-iakovenko", "createdAt": "2020-04-08T11:09:06Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/connected/ConnectedDevicesService.java", "diffHunk": "@@ -52,17 +41,35 @@\n import net.floodlightcontroller.packet.Ethernet;\n import net.floodlightcontroller.packet.IPacket;\n import net.floodlightcontroller.packet.LLDP;\n+import org.mapstruct.ap.internal.util.Collections;", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxMzE3Mg==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r406813172", "bodyText": "It was not intentional.", "author": "surabujin", "createdAt": "2020-04-10T15:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0MzY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0ODQ5Ng==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405448496", "bodyText": "If this is supposed to be a constant, then use an unmodifiable set and name the field in upper-case. Please, check guava's ImmutableSet.of.", "author": "sergii-iakovenko", "createdAt": "2020-04-08T11:18:53Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/connected/ConnectedDevicesService.java", "diffHunk": "@@ -52,17 +41,35 @@\n import net.floodlightcontroller.packet.Ethernet;\n import net.floodlightcontroller.packet.IPacket;\n import net.floodlightcontroller.packet.LLDP;\n+import org.mapstruct.ap.internal.util.Collections;\n import org.projectfloodlight.openflow.protocol.OFType;\n import org.projectfloodlight.openflow.types.U64;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Set;\n \n public class ConnectedDevicesService implements IService, IInputTranslator {\n     private static final Logger logger = LoggerFactory.getLogger(ConnectedDevicesService.class);\n \n+    private static final Set<ServiceCookieTag> lldpServiceTags = Collections.asSet(", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1NjM2NA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405456364", "bodyText": "What does the blank cookie mean from business logic standpoint? Shouldn't this be some kind of cookie builder?", "author": "sergii-iakovenko", "createdAt": "2020-04-08T11:34:40Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/common/actions/BaseResourceAllocationAction.java", "diffHunk": "@@ -190,12 +192,17 @@ protected boolean isNotSamePath(PathPair pathPair, FlowPathPair flowPathPair) {\n \n     protected FlowPathPair createFlowPathPair(Flow flow, FlowPathPair pathsToReuseBandwidth,\n                                               PathPair pathPair, FlowResources flowResources) {\n-        long cookie = flowResources.getUnmaskedCookie();\n-        FlowPath newForwardPath = flowPathBuilder.buildFlowPath(flow, flowResources.getForward(),\n-                pathPair.getForward(), Cookie.buildForwardCookie(cookie));\n+        Cookie blank = FlowSegmentCookieSchema.INSTANCE.makeBlank();", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NTkxNg==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405465916", "bodyText": "Could you please add javadoc with some explanation why UNKNOWN path direction is available / possible in Kilda data model?\nLooks like this value was introduced just to cover a specific case when a method can't determine a cookie direction, which not a reason to introduce a new direction into the model. Null or Optional.empty() may address this.", "author": "sergii-iakovenko", "createdAt": "2020-04-08T11:53:00Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/FlowPathDirection.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/* Copyright 2019 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model;\n+\n+public enum FlowPathDirection {\n+    UNKNOWN,", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxNjA1MQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r406816051", "bodyText": "I can't explain why this value is possible. Up to now, we do not restrict the flow(also we do not have a separation between flow cookies and other cookies) cookie to have a specific direction. And I have no plans to add this restriction in this PR.", "author": "surabujin", "createdAt": "2020-04-10T15:44:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NTkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5MDkzNw==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r408690937", "bodyText": "Ok, then I'd call those cookies as with \"unspecified\" direction rather than UNKNOWN. The current version (UNKNOWN) sounds like we can't determine it for some reason...", "author": "sergii-iakovenko", "createdAt": "2020-04-15T09:03:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NTkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQwMDEyMA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r409400120", "bodyText": "Renamed to \"UNDEFINED\".", "author": "surabujin", "createdAt": "2020-04-16T09:06:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NTkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3NzgxOQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405477819", "bodyText": "nit: Can't this be just as following?\nif (mask == 0) throw new IllegalArgumentException(\"Bit field mask must not be 0\");\nlong theBit = Long.lowestOneBit(mask);\nif (theBit != mask) throw new IllegalArgumentException(\"Illegal bit field mask\");\noffset = Long.numberOfTrailingZeros(theBit) + 1;", "author": "sergii-iakovenko", "createdAt": "2020-04-08T12:14:17Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/BitField.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops;\n+\n+import org.openkilda.model.Cookie;\n+\n+import lombok.Getter;\n+\n+@Getter\n+public class BitField {\n+    private final long mask;\n+    private final int offset;\n+\n+    public BitField(long mask) {", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyNjU4Ng==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r406826586", "bodyText": "Long.lowestOneBit(mask) return one lowest bit, so this approach fails for any bit field(mask) longer than 1 bit.", "author": "surabujin", "createdAt": "2020-04-10T16:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3NzgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5NDgyMA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r408694820", "bodyText": "Got it.", "author": "sergii-iakovenko", "createdAt": "2020-04-15T09:10:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3NzgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3OTg1Ng==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405479856", "bodyText": "Why did CookieSchema become a part of the bitops package? Shouldn't it be on the same level as the cookie entity? I'd propose to move the cookie and cookie schema under \"org.openkilda.model.cookie\".", "author": "sergii-iakovenko", "createdAt": "2020-04-08T12:18:04Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyNzg4NQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r406827885", "bodyText": "Move Cookie class and all related classes into org.openkilda.model.cookie was my initial idea. But it produces so huge change, that I have decided to do it in some late and as a PR that contains class movements only.", "author": "surabujin", "createdAt": "2020-04-10T16:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3OTg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5NTI0NQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r408695245", "bodyText": "Ok", "author": "sergii-iakovenko", "createdAt": "2020-04-15T09:10:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3OTg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ5NjkyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405496925", "bodyText": "nit: where is @OverRide?", "author": "sergii-iakovenko", "createdAt": "2020-04-08T12:47:20Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+public abstract class CookieSchema {\n+    // update ALL_FIELDS if modify fields list\n+    static final BitField TYPE_FIELD   = new BitField(0x1FF0_0000_0000_0000L);\n+    static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n+\n+    protected abstract Cookie makeBlank();\n+\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        // inheritors can implement validate logic\n+    }\n+\n+    /**\n+     * Extract and return \"type\" field.\n+     */\n+    public CookieType getType(Cookie cookie) {\n+        int numericType = (int) getField(cookie.getValue(), TYPE_FIELD);\n+        return resolveEnum(CookieType.values(), numericType, CookieType.class);\n+    }\n+\n+    protected long setType(long value, CookieType type) {\n+        return setField(value, TYPE_FIELD, type.getValue());\n+    }\n+\n+    protected long getField(long value, BitField field) {\n+        long payload = value & field.getMask();\n+        return payload >>> field.getOffset();\n+    }\n+\n+    protected Cookie setField(Cookie cookie, BitField field, long payload) {\n+        long raw = setField(cookie.getValue(), field, payload);\n+        return new Cookie(raw);\n+    }\n+\n+    protected long setField(long value, BitField field, long payload) {\n+        long mask = field.getMask();\n+        payload <<= field.getOffset();\n+        payload &= mask;\n+        return (value & ~mask) | payload;\n+    }\n+\n+    protected void validateServiceFlag(Cookie cookie, boolean expectedValue) throws InvalidCookieException {\n+        boolean actual = getField(cookie.getValue(), SERVICE_FLAG) != 0;\n+        if (expectedValue != actual) {\n+            throw new InvalidCookieException(\n+                    String.format(\"Service flag is expected to be %s\", expectedValue ? \"set\" : \"unset\"), cookie);\n+        }\n+    }\n+\n+    protected static <T extends NumericEnumField> T resolveEnum(T[] valuesSpace, long needle, Class<T> typeRef) {\n+        for (T entry : valuesSpace) {\n+            if (entry.getValue() == needle) {\n+                return entry;\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(String.format(\n+                \"Unable to map value %x value into %s value\", needle, typeRef.getSimpleName()));\n+    }\n+\n+    // 9 bit long type field\n+    public enum CookieType implements NumericEnumField {\n+        SERVICE_OR_FLOW_SEGMENT(0x000),\n+        LLDP_INPUT_CUSTOMER_TYPE(0x001),\n+        MULTI_TABLE_ISL_VLAN_EGRESS_RULES(0x002),\n+        MULTI_TABLE_ISL_VXLAN_EGRESS_RULES(0x003),\n+        MULTI_TABLE_ISL_VXLAN_TRANSIT_RULES(0x004),\n+        MULTI_TABLE_INGRESS_RULES(0x005),\n+        ARP_INPUT_CUSTOMER_TYPE(0x006),\n+        INGRESS_SEGMENT(0x007),   // used for ingress flow segment and for one switch flow segments\n+        SHARED_OF_FLOW(0x008);\n+\n+        private int value;\n+\n+        CookieType(int value) {\n+            this.value = value;\n+        }\n+\n+        public int getValue() {", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d18950867d8d842cfbda875554772e850533ec88", "url": "https://github.com/telstra/open-kilda/commit/d18950867d8d842cfbda875554772e850533ec88", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-10T19:50:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5ODQwNw==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r408698407", "bodyText": "It makes sense to declare the class as abstract. No need to allow instantiating it.", "author": "sergii-iakovenko", "createdAt": "2020-04-15T09:16:23Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+import com.fasterxml.jackson.annotation.JsonValue;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@EqualsAndHashCode(of = {\"value\"})\n+public class CookieBase implements Serializable {", "originalCommit": "d18950867d8d842cfbda875554772e850533ec88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQwMTQxNQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r409401415", "bodyText": "done", "author": "surabujin", "createdAt": "2020-04-16T09:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5ODQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwMTc0Nw==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r408701747", "bodyText": "You can allow the builder to set both value and type, but as for now use only the type.", "author": "sergii-iakovenko", "createdAt": "2020-04-15T09:22:05Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java", "diffHunk": "@@ -44,102 +38,133 @@\n  * 5 - Multi-table customer flow rule for ingress table pass-through\n  * </p>\n  */\n-@Value\n-public class Cookie implements Comparable<Cookie>, Serializable {\n-    private static final long serialVersionUID = 1L;\n-\n-    public static final long DEFAULT_RULE_FLAG                   = 0x8000_0000_0000_0000L;\n-    public static final long FLOW_PATH_FORWARD_FLAG              = 0x4000_0000_0000_0000L;\n-    public static final long FLOW_PATH_REVERSE_FLAG              = 0x2000_0000_0000_0000L;\n-\n-    // There is no alive system that use this deprecated direction flags so it should be save to drop it.\n-    @Deprecated\n-    public static final long DEPRECATED_FLOW_PATH_DIRECTION_FLAG = 0x0080_0000_0000_0000L;\n-    public static final long FLOW_COOKIE_VALUE_MASK              = 0x0000_0000_000F_FFFFL;\n-    public static final long ISL_COOKIE_VALUE_MASK               = 0x0000_0000_000F_FFFFL;\n-    public static final long INGRESS_RULE_COOKIE_VALUE_MASK      = 0x0000_0000_000F_FFFFL;\n-\n-    public static final long DROP_RULE_COOKIE                           = 0x01L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_BROADCAST_RULE_COOKIE         = 0x02L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_UNICAST_RULE_COOKIE           = 0x03L | DEFAULT_RULE_FLAG;\n-    public static final long DROP_VERIFICATION_LOOP_RULE_COOKIE         = 0x04L | DEFAULT_RULE_FLAG;\n-    public static final long CATCH_BFD_RULE_COOKIE                      = 0x05L | DEFAULT_RULE_FLAG;\n-    public static final long ROUND_TRIP_LATENCY_RULE_COOKIE             = 0x06L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_UNICAST_VXLAN_RULE_COOKIE     = 0x07L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE = 0x08L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_INGRESS_DROP_COOKIE             = 0x09L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_POST_INGRESS_DROP_COOKIE        = 0x0AL | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_EGRESS_PASS_THROUGH_COOKIE      = 0x0BL | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_TRANSIT_DROP_COOKIE             = 0x0CL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_INPUT_PRE_DROP_COOKIE                 = 0x0DL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_TRANSIT_COOKIE                        = 0x0EL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_INGRESS_COOKIE                        = 0x0FL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_COOKIE                   = 0x10L | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_VXLAN_COOKIE             = 0x11L | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_ONE_SWITCH_COOKIE        = 0x12L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_INPUT_PRE_DROP_COOKIE                  = 0x13L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_TRANSIT_COOKIE                         = 0x14L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_INGRESS_COOKIE                         = 0x15L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_COOKIE                    = 0x16L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_VXLAN_COOKIE              = 0x17L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_ONE_SWITCH_COOKIE         = 0x18L | DEFAULT_RULE_FLAG;\n+public class Cookie extends CookieBase implements Comparable<Cookie> {\n+    // FIXME(surabujin): get rid from this constants (it will allow to merge CookieBase into Cookie)\n+    public static final long DROP_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.DROP_RULE_COOKIE).getValue();\n+    public static final long VERIFICATION_BROADCAST_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.VERIFICATION_BROADCAST_RULE_COOKIE).getValue();\n+    public static final long VERIFICATION_UNICAST_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.VERIFICATION_UNICAST_RULE_COOKIE).getValue();\n+    public static final long DROP_VERIFICATION_LOOP_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.DROP_VERIFICATION_LOOP_RULE_COOKIE).getValue();\n+    public static final long CATCH_BFD_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.CATCH_BFD_RULE_COOKIE).getValue();\n+    public static final long ROUND_TRIP_LATENCY_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ROUND_TRIP_LATENCY_RULE_COOKIE).getValue();\n+    public static final long VERIFICATION_UNICAST_VXLAN_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.VERIFICATION_UNICAST_VXLAN_RULE_COOKIE).getValue();\n+    public static final long MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE).getValue();\n+    public static final long MULTITABLE_INGRESS_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_INGRESS_DROP_COOKIE).getValue();\n+    public static final long MULTITABLE_POST_INGRESS_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_POST_INGRESS_DROP_COOKIE).getValue();\n+    public static final long MULTITABLE_EGRESS_PASS_THROUGH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_EGRESS_PASS_THROUGH_COOKIE).getValue();\n+    public static final long MULTITABLE_TRANSIT_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_TRANSIT_DROP_COOKIE).getValue();\n+    public static final long LLDP_INPUT_PRE_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_INPUT_PRE_DROP_COOKIE).getValue();\n+    public static final long LLDP_TRANSIT_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_TRANSIT_COOKIE).getValue();\n+    public static final long LLDP_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_INGRESS_COOKIE).getValue();\n+    public static final long LLDP_POST_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_POST_INGRESS_COOKIE).getValue();\n+    public static final long LLDP_POST_INGRESS_VXLAN_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_POST_INGRESS_VXLAN_COOKIE).getValue();\n+    public static final long LLDP_POST_INGRESS_ONE_SWITCH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_POST_INGRESS_ONE_SWITCH_COOKIE).getValue();\n+    public static final long ARP_INPUT_PRE_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_INPUT_PRE_DROP_COOKIE).getValue();\n+    public static final long ARP_TRANSIT_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_TRANSIT_COOKIE).getValue();\n+    public static final long ARP_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_INGRESS_COOKIE).getValue();\n+    public static final long ARP_POST_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_POST_INGRESS_COOKIE).getValue();\n+    public static final long ARP_POST_INGRESS_VXLAN_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_POST_INGRESS_VXLAN_COOKIE).getValue();\n+    public static final long ARP_POST_INGRESS_ONE_SWITCH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_POST_INGRESS_ONE_SWITCH_COOKIE).getValue();\n \n-    // 9 bits cookie type \"field\"\n-    public static final long TYPE_MASK                               = 0x1FF0_0000_0000_0000L;\n-    public static final long FLOW_COOKIE_TYPE                        = 0x0000_0000_0000_0000L;\n-    public static final long LLDP_INPUT_CUSTOMER_TYPE                = 0x0010_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VLAN_EGRESS_RULES_TYPE   = 0x0020_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VXLAN_EGRESS_RULES_TYPE  = 0x0030_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VXLAN_TRANSIT_RULES_TYPE = 0x0040_0000_0000_0000L;\n-    public static final long MULTITABLE_INGRESS_RULES_TYPE           = 0x0050_0000_0000_0000L;\n-    public static final long ARP_INPUT_CUSTOMER_TYPE                 = 0x0060_0000_0000_0000L;\n+    @JsonCreator\n+    public Cookie(long value) {\n+        super(value);\n+    }\n \n-    private final long value;\n+    @Builder\n+    public Cookie(CookieType type) {", "originalCommit": "d18950867d8d842cfbda875554772e850533ec88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQwNzIwNg==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r409407206", "bodyText": "Em... why for? This 2 different use cases - one \"restore\" cookie from the raw value (direct new Cookie(raw) call) and another build new cookie from fields provided by the app (builder way). I do not want to add value field into the builder, to will make it less obvious.", "author": "surabujin", "createdAt": "2020-04-16T09:17:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwMTc0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYzMDM3Mg==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r412630372", "bodyText": "Got it.", "author": "sergii-iakovenko", "createdAt": "2020-04-22T02:52:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwMTc0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwMjI0NQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r408702245", "bodyText": "Why is the value called \"blank\"?", "author": "sergii-iakovenko", "createdAt": "2020-04-15T09:22:49Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java", "diffHunk": "@@ -44,102 +38,133 @@\n  * 5 - Multi-table customer flow rule for ingress table pass-through\n  * </p>\n  */\n-@Value\n-public class Cookie implements Comparable<Cookie>, Serializable {\n-    private static final long serialVersionUID = 1L;\n-\n-    public static final long DEFAULT_RULE_FLAG                   = 0x8000_0000_0000_0000L;\n-    public static final long FLOW_PATH_FORWARD_FLAG              = 0x4000_0000_0000_0000L;\n-    public static final long FLOW_PATH_REVERSE_FLAG              = 0x2000_0000_0000_0000L;\n-\n-    // There is no alive system that use this deprecated direction flags so it should be save to drop it.\n-    @Deprecated\n-    public static final long DEPRECATED_FLOW_PATH_DIRECTION_FLAG = 0x0080_0000_0000_0000L;\n-    public static final long FLOW_COOKIE_VALUE_MASK              = 0x0000_0000_000F_FFFFL;\n-    public static final long ISL_COOKIE_VALUE_MASK               = 0x0000_0000_000F_FFFFL;\n-    public static final long INGRESS_RULE_COOKIE_VALUE_MASK      = 0x0000_0000_000F_FFFFL;\n-\n-    public static final long DROP_RULE_COOKIE                           = 0x01L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_BROADCAST_RULE_COOKIE         = 0x02L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_UNICAST_RULE_COOKIE           = 0x03L | DEFAULT_RULE_FLAG;\n-    public static final long DROP_VERIFICATION_LOOP_RULE_COOKIE         = 0x04L | DEFAULT_RULE_FLAG;\n-    public static final long CATCH_BFD_RULE_COOKIE                      = 0x05L | DEFAULT_RULE_FLAG;\n-    public static final long ROUND_TRIP_LATENCY_RULE_COOKIE             = 0x06L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_UNICAST_VXLAN_RULE_COOKIE     = 0x07L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE = 0x08L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_INGRESS_DROP_COOKIE             = 0x09L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_POST_INGRESS_DROP_COOKIE        = 0x0AL | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_EGRESS_PASS_THROUGH_COOKIE      = 0x0BL | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_TRANSIT_DROP_COOKIE             = 0x0CL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_INPUT_PRE_DROP_COOKIE                 = 0x0DL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_TRANSIT_COOKIE                        = 0x0EL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_INGRESS_COOKIE                        = 0x0FL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_COOKIE                   = 0x10L | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_VXLAN_COOKIE             = 0x11L | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_ONE_SWITCH_COOKIE        = 0x12L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_INPUT_PRE_DROP_COOKIE                  = 0x13L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_TRANSIT_COOKIE                         = 0x14L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_INGRESS_COOKIE                         = 0x15L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_COOKIE                    = 0x16L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_VXLAN_COOKIE              = 0x17L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_ONE_SWITCH_COOKIE         = 0x18L | DEFAULT_RULE_FLAG;\n+public class Cookie extends CookieBase implements Comparable<Cookie> {\n+    // FIXME(surabujin): get rid from this constants (it will allow to merge CookieBase into Cookie)\n+    public static final long DROP_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.DROP_RULE_COOKIE).getValue();\n+    public static final long VERIFICATION_BROADCAST_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.VERIFICATION_BROADCAST_RULE_COOKIE).getValue();\n+    public static final long VERIFICATION_UNICAST_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.VERIFICATION_UNICAST_RULE_COOKIE).getValue();\n+    public static final long DROP_VERIFICATION_LOOP_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.DROP_VERIFICATION_LOOP_RULE_COOKIE).getValue();\n+    public static final long CATCH_BFD_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.CATCH_BFD_RULE_COOKIE).getValue();\n+    public static final long ROUND_TRIP_LATENCY_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ROUND_TRIP_LATENCY_RULE_COOKIE).getValue();\n+    public static final long VERIFICATION_UNICAST_VXLAN_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.VERIFICATION_UNICAST_VXLAN_RULE_COOKIE).getValue();\n+    public static final long MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE).getValue();\n+    public static final long MULTITABLE_INGRESS_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_INGRESS_DROP_COOKIE).getValue();\n+    public static final long MULTITABLE_POST_INGRESS_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_POST_INGRESS_DROP_COOKIE).getValue();\n+    public static final long MULTITABLE_EGRESS_PASS_THROUGH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_EGRESS_PASS_THROUGH_COOKIE).getValue();\n+    public static final long MULTITABLE_TRANSIT_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_TRANSIT_DROP_COOKIE).getValue();\n+    public static final long LLDP_INPUT_PRE_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_INPUT_PRE_DROP_COOKIE).getValue();\n+    public static final long LLDP_TRANSIT_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_TRANSIT_COOKIE).getValue();\n+    public static final long LLDP_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_INGRESS_COOKIE).getValue();\n+    public static final long LLDP_POST_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_POST_INGRESS_COOKIE).getValue();\n+    public static final long LLDP_POST_INGRESS_VXLAN_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_POST_INGRESS_VXLAN_COOKIE).getValue();\n+    public static final long LLDP_POST_INGRESS_ONE_SWITCH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_POST_INGRESS_ONE_SWITCH_COOKIE).getValue();\n+    public static final long ARP_INPUT_PRE_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_INPUT_PRE_DROP_COOKIE).getValue();\n+    public static final long ARP_TRANSIT_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_TRANSIT_COOKIE).getValue();\n+    public static final long ARP_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_INGRESS_COOKIE).getValue();\n+    public static final long ARP_POST_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_POST_INGRESS_COOKIE).getValue();\n+    public static final long ARP_POST_INGRESS_VXLAN_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_POST_INGRESS_VXLAN_COOKIE).getValue();\n+    public static final long ARP_POST_INGRESS_ONE_SWITCH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_POST_INGRESS_ONE_SWITCH_COOKIE).getValue();\n \n-    // 9 bits cookie type \"field\"\n-    public static final long TYPE_MASK                               = 0x1FF0_0000_0000_0000L;\n-    public static final long FLOW_COOKIE_TYPE                        = 0x0000_0000_0000_0000L;\n-    public static final long LLDP_INPUT_CUSTOMER_TYPE                = 0x0010_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VLAN_EGRESS_RULES_TYPE   = 0x0020_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VXLAN_EGRESS_RULES_TYPE  = 0x0030_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VXLAN_TRANSIT_RULES_TYPE = 0x0040_0000_0000_0000L;\n-    public static final long MULTITABLE_INGRESS_RULES_TYPE           = 0x0050_0000_0000_0000L;\n-    public static final long ARP_INPUT_CUSTOMER_TYPE                 = 0x0060_0000_0000_0000L;\n+    @JsonCreator\n+    public Cookie(long value) {\n+        super(value);\n+    }\n \n-    private final long value;\n+    @Builder\n+    public Cookie(CookieType type) {\n+        super(0, type);\n+    }\n \n     /**\n-     * Create {@code Cookie} instance and perform it's validation.\n+     * Conver existing {@link Cookie} instance into {@link CookieBuilder}.\n      */\n-    public static Cookie decode(long rawValue) {\n-        Cookie cookie = new Cookie(rawValue);\n-        cookie.ensureNoFlagsConflicts();\n-        return cookie;\n+    public CookieBuilder toBuilder() {\n+        return new CookieBuilder()\n+                .type(getType());\n     }\n \n-    @JsonCreator\n-    public Cookie(long value) {\n-        this.value = value;\n-    }\n-\n-    public static Cookie buildForwardCookie(long unmaskedCookie) {\n-        return new Cookie(unmaskedCookie | Cookie.FLOW_PATH_FORWARD_FLAG);\n+    protected Cookie(long blank, CookieType type) {", "originalCommit": "d18950867d8d842cfbda875554772e850533ec88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQxODUxNQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r409418515", "bodyText": "Because it is incomplete yet... Can't find normal name for this argument. If not blank only stub is coming to the mind. Renamed it into value :(", "author": "surabujin", "createdAt": "2020-04-16T09:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwMjI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwNDY0OQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r408704649", "bodyText": "nit: I'd call it \"isValid\" and swap with \"validate\" to be overwritten by inheritors.", "author": "sergii-iakovenko", "createdAt": "2020-04-15T09:26:46Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+import com.fasterxml.jackson.annotation.JsonValue;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@EqualsAndHashCode(of = {\"value\"})\n+public class CookieBase implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // update ALL_FIELDS if modify fields list\n+    static final BitField TYPE_FIELD = new BitField(0x1FF0_0000_0000_0000L);\n+    static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n+\n+    private final long value;\n+\n+    CookieBase(long value) {\n+        this.value = value;\n+    }\n+\n+    protected CookieBase(long blank, CookieType type) {\n+        value = setField(blank, TYPE_FIELD, type.getValue());\n+    }\n+\n+    /**\n+     * Validate cookie value without throwing exception in case of validation fail, but returning {@code false} result.\n+     */\n+    public boolean safeValidate() {", "originalCommit": "d18950867d8d842cfbda875554772e850533ec88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQyODQ3MQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r409428471", "bodyText": "In this case it can't report what exactly goes wrong (not this info brought with exception raised by validate).\nPS safeValidate renamed into isValid.", "author": "surabujin", "createdAt": "2020-04-16T09:51:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwNDY0OQ=="}], "type": "inlineReview"}, {"oid": "72ec444294b5826d0b25ba4e1bddec7cad08452a", "url": "https://github.com/telstra/open-kilda/commit/72ec444294b5826d0b25ba4e1bddec7cad08452a", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-16T10:09:55Z", "type": "forcePushed"}, {"oid": "ab215549cabd075f8736e2d5efd41c1fd1b8a2d1", "url": "https://github.com/telstra/open-kilda/commit/ab215549cabd075f8736e2d5efd41c1fd1b8a2d1", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-21T10:28:48Z", "type": "forcePushed"}, {"oid": "9fcf126a66db8bbe254862ed4d2ce4bd3be23c22", "url": "https://github.com/telstra/open-kilda/commit/9fcf126a66db8bbe254862ed4d2ce4bd3be23c22", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-21T10:39:55Z", "type": "forcePushed"}, {"oid": "c55abc7650b8adfd5e68f95844deac4c502e511e", "url": "https://github.com/telstra/open-kilda/commit/c55abc7650b8adfd5e68f95844deac4c502e511e", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-23T13:00:05Z", "type": "forcePushed"}, {"oid": "716fb4d1429b877edd0916e708bf5ce222b3ed59", "url": "https://github.com/telstra/open-kilda/commit/716fb4d1429b877edd0916e708bf5ce222b3ed59", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-23T13:55:31Z", "type": "forcePushed"}, {"oid": "274fb37f9a52685e00edb5ab9351e8ed6e3bda94", "url": "https://github.com/telstra/open-kilda/commit/274fb37f9a52685e00edb5ab9351e8ed6e3bda94", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-24T08:02:43Z", "type": "commit"}, {"oid": "274fb37f9a52685e00edb5ab9351e8ed6e3bda94", "url": "https://github.com/telstra/open-kilda/commit/274fb37f9a52685e00edb5ab9351e8ed6e3bda94", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-24T08:02:43Z", "type": "forcePushed"}]}