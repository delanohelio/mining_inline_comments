{"pr_number": 3097, "pr_title": "Fix double network failure handling", "pr_createdAt": "2020-01-08T17:24:07Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3097", "timeline": [{"oid": "237e1f090231481b2aa3fae832556654109d843f", "url": "https://github.com/telstra/open-kilda/commit/237e1f090231481b2aa3fae832556654109d843f", "message": "Fix double network failure handling\n\nAdd queue in front of reroute \"handler\" so if reroute for the flow is\ngoing and new reroute request for this flow received (double network\nfailure case) second request will be postponed.\n\nAt the end of reroute request processing \"handler\" check presence of\npostponed request and handle them.", "committedDate": "2020-01-09T09:09:20Z", "type": "forcePushed"}, {"oid": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "url": "https://github.com/telstra/open-kilda/commit/d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "message": "Fix double network failure handling\n\nAdd queue in front of reroute \"handler\" so if reroute for the flow is\ngoing and new reroute request for this flow received (double network\nfailure case) second request will be postponed.\n\nAt the end of reroute request processing \"handler\" check presence of\npostponed request and handle them.", "committedDate": "2020-01-09T11:42:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5ODQwMg==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364698402", "bodyText": "nit: wouldn't call it queue since you refactored that", "author": "timofei-durakov", "createdAt": "2020-01-09T11:50:53Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.model.PathId;\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class RerouteRetryQueue {", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5OTc5MQ==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364699791", "bodyText": "nit: why not to throw exception here?", "author": "timofei-durakov", "createdAt": "2020-01-09T11:54:28Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Slf4j\n+public class RerouteRetryManager {\n+    private final Map<String, RerouteRetryQueue> queueByFlowId = new HashMap<>();\n+\n+    /**\n+     * Save entry into retry queue. Return true if it is only entry for this flowId (i.e. operation should not be\n+     * postponed).\n+     */\n+    public boolean push(FlowRerouteFact entity) {\n+        RerouteRetryQueue queue = queueByFlowId.computeIfAbsent(\n+                entity.getFlowId(), ignore -> new RerouteRetryQueue());\n+        queue.add(entity);\n+        log.info(\"Size of flow reroute queue for {} is {}\", entity.getFlowId(), queue.size());\n+        return queue.size() == 1;\n+    }\n+\n+    /**\n+     * Locate and return fist entry in queue.\n+     */\n+    public Optional<FlowRerouteFact> peek(String flowId) {\n+        RerouteRetryQueue queue = queueByFlowId.get(flowId);\n+        if (queue == null) {\n+            return Optional.empty();", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwMDI4Mw==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364700283", "bodyText": "same", "author": "timofei-durakov", "createdAt": "2020-01-09T11:55:36Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Slf4j\n+public class RerouteRetryManager {\n+    private final Map<String, RerouteRetryQueue> queueByFlowId = new HashMap<>();\n+\n+    /**\n+     * Save entry into retry queue. Return true if it is only entry for this flowId (i.e. operation should not be\n+     * postponed).\n+     */\n+    public boolean push(FlowRerouteFact entity) {\n+        RerouteRetryQueue queue = queueByFlowId.computeIfAbsent(\n+                entity.getFlowId(), ignore -> new RerouteRetryQueue());\n+        queue.add(entity);\n+        log.info(\"Size of flow reroute queue for {} is {}\", entity.getFlowId(), queue.size());\n+        return queue.size() == 1;\n+    }\n+\n+    /**\n+     * Locate and return fist entry in queue.\n+     */\n+    public Optional<FlowRerouteFact> peek(String flowId) {\n+        RerouteRetryQueue queue = queueByFlowId.get(flowId);\n+        if (queue == null) {\n+            return Optional.empty();\n+        }\n+\n+        // use method raises exception on empty queue access, because queue can't be empty by used design\n+        return queue.get();\n+    }\n+\n+    /**\n+     * Locate, remove and return fist entry in queue.\n+     */\n+    public Optional<FlowRerouteFact> remove(String flowId) {\n+        RerouteRetryQueue queue = queueByFlowId.get(flowId);\n+        if (queue == null) {\n+            return Optional.empty();", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwMTI4Ng==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364701286", "bodyText": "let's rename it to handlePostponedRequest?", "author": "timofei-durakov", "createdAt": "2020-01-09T11:58:12Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java", "diffHunk": "@@ -69,6 +73,16 @@ public FlowRerouteService(FlowRerouteHubCarrier carrier, PersistenceManager pers\n                 speakerCommandRetriesLimit);\n     }\n \n+    /**\n+     * Handle postponed reroute request.\n+     */\n+    public void handleRequest(FlowRerouteFact reroute) {", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwMjQ1Mw==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364702453", "bodyText": "this is a very strange return result for a method call, tbh I'd implement size here istead", "author": "timofei-durakov", "createdAt": "2020-01-09T12:01:28Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Slf4j\n+public class RerouteRetryManager {\n+    private final Map<String, RerouteRetryQueue> queueByFlowId = new HashMap<>();\n+\n+    /**\n+     * Save entry into retry queue. Return true if it is only entry for this flowId (i.e. operation should not be\n+     * postponed).\n+     */\n+    public boolean push(FlowRerouteFact entity) {\n+        RerouteRetryQueue queue = queueByFlowId.computeIfAbsent(\n+                entity.getFlowId(), ignore -> new RerouteRetryQueue());\n+        queue.add(entity);\n+        log.info(\"Size of flow reroute queue for {} is {}\", entity.getFlowId(), queue.size());\n+        return queue.size() == 1;", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxMjQ4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364712489", "bodyText": "+1", "author": "niksv", "createdAt": "2020-01-09T12:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwMjQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwNjY2MA==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364706660", "bodyText": "check queue size rather than push return value that is tight to 1 size", "author": "timofei-durakov", "createdAt": "2020-01-09T12:12:53Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java", "diffHunk": "@@ -87,24 +101,15 @@ public void handleRequest(String key, CommandContext commandContext, String flow\n             return;\n         }\n \n-        String eventKey = commandContext.getCorrelationId();\n-        if (flowEventRepository.existsByTaskId(eventKey)) {\n-            log.error(\"Attempt to reuse key {}, but there's a history record(s) for it.\", eventKey);\n-            return;\n+        FlowRerouteFact reroute = new FlowRerouteFact(\n+                key, commandContext, flowId, pathsToReroute, forceReroute, rerouteReason);\n+        if (retryQueue.push(reroute)) {", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwODI0Mw==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364708243", "bodyText": "will this exception be raised each time there are no pending reroutes in a queue?", "author": "timofei-durakov", "createdAt": "2020-01-09T12:16:36Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java", "diffHunk": "@@ -151,12 +156,54 @@ public void handleTimeout(String key) {\n         removeIfFinished(fsm, key);\n     }\n \n+    private void initReroute(FlowRerouteFact reroute) {\n+        final CommandContext commandContext = reroute.getCommandContext();\n+\n+        String eventKey = commandContext.getCorrelationId();\n+        if (flowEventRepository.existsByTaskId(eventKey)) {\n+            log.error(\"Attempt to reuse key {}, but there's a history record(s) for it.\", eventKey);\n+            return;\n+        }\n+\n+        final String flowId =  reroute.getFlowId();\n+        final String key = reroute.getKey();\n+        FlowRerouteFsm fsm = fsmFactory.newInstance(commandContext, flowId);\n+        fsms.put(key, fsm);\n+\n+        FlowRerouteContext context = FlowRerouteContext.builder()\n+                .flowId(flowId)\n+                .pathsToReroute(reroute.getPathsToReroute())\n+                .forceReroute(reroute.isForceReroute())\n+                .rerouteReason(reroute.getRerouteReason())\n+                .build();\n+        fsmExecutor.fire(fsm, Event.NEXT, context);\n+\n+        removeIfFinished(fsm, key);\n+    }\n+\n     private void removeIfFinished(FlowRerouteFsm fsm, String key) {\n         if (fsm.isTerminated()) {\n-            log.debug(\"FSM with key {} is finished with state {}\", key, fsm.getCurrentState());\n-            fsms.remove(key);\n+            performHousekeeping(fsm, key);\n \n-            carrier.cancelTimeoutCallback(key);\n+            // use some sort of recursion here, because iterative way require too complex scheme to clean/use retryQueue\n+            retryQueue.peek(fsm.getFlowId()).ifPresent(carrier::injectRetry);\n+        }\n+    }\n+\n+    private void performHousekeeping(FlowRerouteFsm fsm, String key) {\n+        log.debug(\"FSM with key {} is finished with state {}\", key, fsm.getCurrentState());\n+        fsms.remove(key);\n+\n+        carrier.cancelTimeoutCallback(key);\n+\n+        FlowRerouteFact reroute = retryQueue.remove(fsm.getFlowId())\n+                .orElseThrow(() -> new IllegalStateException(String.format(", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxMTY0Ng==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364711646", "bodyText": "As far as I can see state with active == null and pending != null is inconsistent for this structure. Maybe we should return only active Fact here for consistency with remove method?", "author": "rozdy", "createdAt": "2020-01-09T12:25:15Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.model.PathId;\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class RerouteRetryQueue {\n+    private FlowRerouteFact active = null;\n+    private FlowRerouteFact pending = null;\n+\n+    /**\n+     * Add request into \"queue\".\n+     */\n+    public void add(FlowRerouteFact reroute) {\n+        if (active == null) {\n+            active = reroute;\n+        } else if (pending == null) {\n+            pending = reroute;\n+        } else {\n+            pending = mergePending(pending, reroute);\n+        }\n+    }\n+\n+    /**\n+     * Return first/active queue entry.\n+     */\n+    public Optional<FlowRerouteFact> get() {\n+        FlowRerouteFact result = active;\n+        if (result == null) {\n+            result = pending;\n+        }", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxNjg1Mg==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364716852", "bodyText": "or throw exception if active == null and pending != null", "author": "niksv", "createdAt": "2020-01-09T12:39:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxMTY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxNTcwNw==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364715707", "bodyText": "all 4 rerouteFact objects has same reason \"reason 1\". So check if we set right reason you need to have different reasons", "author": "niksv", "createdAt": "2020-01-09T12:36:07Z", "path": "services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.model.PathId;\n+import org.openkilda.wfm.CommandContext;\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class RerouteRetryQueueTest {\n+    private final CommandContext context = new CommandContext();\n+    private final String flowId = \"flowA\";\n+    private final FlowRerouteFact rerouteEmpty = new FlowRerouteFact(\n+            \"empty\", context, flowId, null, false, \"reason 1\");\n+    private final FlowRerouteFact reroutePathA = new FlowRerouteFact(\n+            \"pathA\", context, flowId, Collections.singleton(new PathId(\"flowA-pathA\")), false, \"reason 1\");\n+    private final FlowRerouteFact reroutePathB = new FlowRerouteFact(\n+            \"pathB\", context, flowId, Collections.singleton(new PathId(\"flowA-pathB\")), false, \"reason 1\");\n+    private final FlowRerouteFact rerouteForced = new FlowRerouteFact(\n+            \"forced\", context, flowId, null, true, \"reason 1\");\n+\n+    @Test\n+    public void addAndSizeOperations() {\n+        RerouteRetryQueue queue = new RerouteRetryQueue();\n+\n+        Assert.assertEquals(0, queue.size());\n+        Assert.assertTrue(queue.isEmpty());\n+\n+        queue.add(rerouteEmpty);\n+        Assert.assertEquals(1, queue.size());\n+        Assert.assertFalse(queue.isEmpty());\n+\n+        queue.add(reroutePathA);\n+        Assert.assertEquals(2, queue.size());\n+        Assert.assertFalse(queue.isEmpty());\n+\n+        queue.add(reroutePathB);\n+        Assert.assertEquals(2, queue.size());\n+        Assert.assertFalse(queue.isEmpty());\n+    }\n+\n+    @Test\n+    public void removeAndSizeOperations() {\n+        RerouteRetryQueue queue = new RerouteRetryQueue();\n+\n+        // empty\n+        Assert.assertFalse(queue.remove().isPresent());\n+\n+        Optional<FlowRerouteFact> reroute;\n+\n+        // one entry\n+        queue.add(rerouteEmpty);\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+        Assert.assertFalse(queue.remove().isPresent());\n+        Assert.assertEquals(0, queue.size());\n+\n+        // two entry\n+        queue.add(rerouteEmpty);\n+        queue.add(reroutePathA);\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+        Assert.assertEquals(1, queue.size());\n+\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(reroutePathA, reroute.get());\n+        Assert.assertFalse(queue.remove().isPresent());\n+        Assert.assertEquals(0, queue.size());\n+\n+        Assert.assertFalse(queue.remove().isPresent());\n+\n+        // more than 2 entry\n+        queue.add(rerouteEmpty);\n+        queue.add(reroutePathA);\n+        queue.add(reroutePathB);\n+\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+        Assert.assertEquals(1, queue.size());\n+\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertNotEquals(reroutePathA, reroute.get());  // merged entry\n+        Assert.assertNotEquals(reroutePathB, reroute.get());  // merged entry\n+        Assert.assertFalse(queue.remove().isPresent());\n+        Assert.assertEquals(0, queue.size());\n+\n+        Assert.assertFalse(queue.remove().isPresent());\n+    }\n+\n+    @Test\n+    public void getOperations() {\n+        RerouteRetryQueue queue = new RerouteRetryQueue();\n+        Assert.assertFalse(queue.get().isPresent());\n+\n+        Optional<FlowRerouteFact> reroute;\n+        queue.add(rerouteEmpty);\n+        reroute = queue.get();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+\n+        queue.add(reroutePathA);\n+        reroute = queue.get();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+\n+        queue.remove();\n+        reroute = queue.get();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(reroutePathA, reroute.get());\n+    }\n+\n+    @Test\n+    public void mergeOperation() {\n+        RerouteRetryQueue queue = new RerouteRetryQueue();\n+        queue.add(rerouteEmpty);\n+        queue.add(reroutePathA);\n+        queue.add(rerouteForced);\n+        queue.add(reroutePathB);\n+\n+        Optional<FlowRerouteFact> potential;\n+        queue.remove();\n+        potential = queue.get();\n+        Assert.assertTrue(potential.isPresent());\n+\n+        FlowRerouteFact reroute = potential.get();\n+        Assert.assertEquals(reroutePathB.getKey(), reroute.getKey());\n+        Assert.assertSame(reroutePathB.getCommandContext(), reroute.getCommandContext());\n+        Assert.assertEquals(reroutePathB.getFlowId(), reroute.getFlowId());\n+\n+        Set<PathId> expectedPaths = Stream.of(rerouteEmpty, reroutePathA, rerouteForced, reroutePathB)\n+                .map(FlowRerouteFact::getPathsToReroute)\n+                .filter(Objects::nonNull)\n+                .flatMap(Collection::stream)\n+                .collect(Collectors.toSet());\n+        Assert.assertEquals(expectedPaths, reroute.getPathsToReroute());\n+        Assert.assertTrue(reroute.isForceReroute());\n+        Assert.assertEquals(reroutePathB.getRerouteReason(), reroute.getRerouteReason());", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ea3030ad2005623b88080eea0083e72050543e0c", "url": "https://github.com/telstra/open-kilda/commit/ea3030ad2005623b88080eea0083e72050543e0c", "message": "Fix double network failure handling\n\nAdd queue in front of reroute \"handler\" so if reroute for the flow is\ngoing and new reroute request for this flow received (double network\nfailure case) second request will be postponed.\n\nAt the end of reroute request processing \"handler\" check presence of\npostponed request and handle them.", "committedDate": "2020-01-09T12:37:10Z", "type": "forcePushed"}, {"oid": "69c9c42f410be58fe1cb21ff59a7accfd8c79d42", "url": "https://github.com/telstra/open-kilda/commit/69c9c42f410be58fe1cb21ff59a7accfd8c79d42", "message": "Fix double network failure handling\n\nAdd queue in front of reroute \"handler\" so if reroute for the flow is\ngoing and new reroute request for this flow received (double network\nfailure case) second request will be postponed.\n\nAt the end of reroute request processing \"handler\" check presence of\npostponed request and handle them.", "committedDate": "2020-01-09T15:06:53Z", "type": "forcePushed"}, {"oid": "324470bfb8bc878d94826c4b5b872985e5231092", "url": "https://github.com/telstra/open-kilda/commit/324470bfb8bc878d94826c4b5b872985e5231092", "message": "Fix double network failure handling\n\nAdd queue in front of reroute \"handler\" so if reroute for the flow is\ngoing and new reroute request for this flow received (double network\nfailure case) second request will be postponed.\n\nAt the end of reroute request processing \"handler\" check presence of\npostponed request and handle them.", "committedDate": "2020-01-10T08:19:26Z", "type": "commit"}, {"oid": "324470bfb8bc878d94826c4b5b872985e5231092", "url": "https://github.com/telstra/open-kilda/commit/324470bfb8bc878d94826c4b5b872985e5231092", "message": "Fix double network failure handling\n\nAdd queue in front of reroute \"handler\" so if reroute for the flow is\ngoing and new reroute request for this flow received (double network\nfailure case) second request will be postponed.\n\nAt the end of reroute request processing \"handler\" check presence of\npostponed request and handle them.", "committedDate": "2020-01-10T08:19:26Z", "type": "forcePushed"}]}