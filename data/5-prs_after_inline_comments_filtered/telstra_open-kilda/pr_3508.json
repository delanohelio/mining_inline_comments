{"pr_number": 3508, "pr_title": "Implement persistence layer for OrientDB", "pr_createdAt": "2020-05-27T00:35:27Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3508", "timeline": [{"oid": "9d15000458fac9ae7a32dea3b04dc1825b958373", "url": "https://github.com/telstra/open-kilda/commit/9d15000458fac9ae7a32dea3b04dc1825b958373", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-05-27T14:44:17Z", "type": "forcePushed"}, {"oid": "eb6a353be243e80defc5fac66228ee021a5735a1", "url": "https://github.com/telstra/open-kilda/commit/eb6a353be243e80defc5fac66228ee021a5735a1", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-05-27T17:13:00Z", "type": "forcePushed"}, {"oid": "3ea477d63a2f719200462a157020494ed4e7ffcb", "url": "https://github.com/telstra/open-kilda/commit/3ea477d63a2f719200462a157020494ed4e7ffcb", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-05-28T04:05:09Z", "type": "forcePushed"}, {"oid": "eac772eed5139347e86852be9fb883d5d23f31f9", "url": "https://github.com/telstra/open-kilda/commit/eac772eed5139347e86852be9fb883d5d23f31f9", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-05-28T06:32:42Z", "type": "forcePushed"}, {"oid": "6f5d79cec07263467a5d576b32226bfb783d663b", "url": "https://github.com/telstra/open-kilda/commit/6f5d79cec07263467a5d576b32226bfb783d663b", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-05-28T10:50:29Z", "type": "forcePushed"}, {"oid": "f60f0a254e8706a451f86f104dde9be921b2625d", "url": "https://github.com/telstra/open-kilda/commit/f60f0a254e8706a451f86f104dde9be921b2625d", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-08-19T19:50:59Z", "type": "forcePushed"}, {"oid": "8d7026f35f76ba0c3f1c07f94e0d4b1d351cde9e", "url": "https://github.com/telstra/open-kilda/commit/8d7026f35f76ba0c3f1c07f94e0d4b1d351cde9e", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-09-02T23:06:34Z", "type": "forcePushed"}, {"oid": "8dd10e044e260b816f77dce9695219264fc6a233", "url": "https://github.com/telstra/open-kilda/commit/8dd10e044e260b816f77dce9695219264fc6a233", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-09-02T23:13:21Z", "type": "forcePushed"}, {"oid": "0dc30cf13bdf39cea4a745756a062e76eec429d3", "url": "https://github.com/telstra/open-kilda/commit/0dc30cf13bdf39cea4a745756a062e76eec429d3", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-09-08T04:31:00Z", "type": "forcePushed"}, {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "url": "https://github.com/telstra/open-kilda/commit/c84e814a5dcd272031eec9c4fcc7039d79662afb", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-09-09T13:01:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3NTI2MA==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486375260", "bodyText": "cookie -> meter", "author": "rozdy", "createdAt": "2020-09-10T14:10:39Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/MeterPool.java", "diffHunk": "@@ -42,60 +44,78 @@\n public class MeterPool {\n     private final TransactionManager transactionManager;\n     private final FlowMeterRepository flowMeterRepository;\n-    private final SwitchRepository switchRepository;\n \n     private final MeterId minMeterId;\n     private final MeterId maxMeterId;\n+    private final int poolSize;\n \n-    public MeterPool(PersistenceManager persistenceManager, MeterId minMeterId, MeterId maxMeterId) {\n+    private Map<SwitchId, MeterId> nextMeters = new HashMap<>();\n+\n+    public MeterPool(PersistenceManager persistenceManager, MeterId minMeterId, MeterId maxMeterId, int poolSize) {\n         transactionManager = persistenceManager.getTransactionManager();\n         RepositoryFactory repositoryFactory = persistenceManager.getRepositoryFactory();\n         flowMeterRepository = repositoryFactory.createFlowMeterRepository();\n-        switchRepository = repositoryFactory.createSwitchRepository();\n \n         this.minMeterId = minMeterId;\n         this.maxMeterId = maxMeterId;\n+        this.poolSize = poolSize;\n     }\n \n     /**\n      * Allocates a meter for the flow path.\n      */\n+    @TransactionRequired\n     public MeterId allocate(SwitchId switchId, String flowId, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            Switch theSwitch = switchRepository.findById(switchId)\n-                    .orElseThrow(() ->\n-                            new ResourceNotAvailableException(format(\"No switch for meter allocation: %s\", switchId)));\n-            return allocate(theSwitch, flowId, pathId);\n-        });\n-    }\n-\n-    /**\n-     * Allocates a meter for the flow path.\n-     */\n-    public MeterId allocate(Switch theSwitch, String flowId, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            String noMetersErrorMessage = format(\"No meter available for switch %s\", theSwitch);\n-\n-            MeterId startMeterId = new MeterId(\n-                    ResourceUtils.computeStartValue(minMeterId.getValue(), maxMeterId.getValue()));\n-            SwitchId switchId = theSwitch.getSwitchId();\n-            MeterId availableMeterId = flowMeterRepository.findUnassignedMeterId(switchId, startMeterId, maxMeterId)\n-                    .orElse(flowMeterRepository.findUnassignedMeterId(switchId, minMeterId, maxMeterId)\n-                            .orElseThrow(() -> new ResourceNotAvailableException(noMetersErrorMessage)));\n-            if (availableMeterId.compareTo(maxMeterId) > 0) {\n-                throw new ResourceNotAvailableException(noMetersErrorMessage);\n+        MeterId nextMeter = nextMeters.get(switchId);\n+        if (nextMeter != null && nextMeter.getValue() > 0) {\n+            if (nextMeter.compareTo(maxMeterId) <= 0 && !flowMeterRepository.exists(switchId, nextMeter)) {\n+                addMeter(flowId, pathId, switchId, nextMeter);\n+                nextMeters.put(switchId, new MeterId(nextMeter.getValue() + 1));\n+                return nextMeter;\n+            } else {\n+                nextMeters.remove(switchId);\n             }\n+        }\n+        // The pool requires (re-)initialization.\n+        if (!nextMeters.containsKey(switchId)) {\n+            long numOfPools = (maxMeterId.getValue() - minMeterId.getValue()) / poolSize;\n+            if (numOfPools > 1) {\n+                long poolToTake = Math.abs(new Random().nextInt()) % numOfPools;\n+                Optional<MeterId> availableMeter = flowMeterRepository.findFirstUnassignedMeter(switchId,\n+                        new MeterId(minMeterId.getValue() + poolToTake * poolSize),\n+                        new MeterId(minMeterId.getValue() + (poolToTake + 1) * poolSize - 1));\n+                if (availableMeter.isPresent()) {\n+                    nextMeter = availableMeter.get();\n+                    addMeter(flowId, pathId, switchId, nextMeter);\n+                    nextMeters.put(switchId, new MeterId(nextMeter.getValue() + 1));\n+                    return nextMeter;\n+                }\n+            }\n+            // The pool requires full scan.\n+            nextMeter = new MeterId(-1);\n+            nextMeters.put(switchId, nextMeter);\n+        }\n+        if (nextMeter != null && nextMeter.getValue() == -1) {\n+            Optional<MeterId> availableCookie = flowMeterRepository.findFirstUnassignedMeter(switchId,", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzODQyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488038425", "bodyText": "Nice catch. Fixed.", "author": "sergii-iakovenko", "createdAt": "2020-09-14T15:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3NTI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3NjMzMQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486376331", "bodyText": "cookie -> vlan", "author": "rozdy", "createdAt": "2020-09-10T14:12:03Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/transitvlan/TransitVlanPool.java", "diffHunk": "@@ -60,27 +66,53 @@ public TransitVlanEncapsulation allocate(Flow flow, PathId pathId, PathId opposi\n                 .orElseGet(() -> allocate(flow, pathId));\n     }\n \n+    @TransactionRequired\n     private TransitVlanEncapsulation allocate(Flow flow, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            int startValue = ResourceUtils.computeStartValue(minTransitVlan, maxTransitVlan);\n-            int availableVlan = transitVlanRepository.findUnassignedTransitVlan(startValue, maxTransitVlan)\n-                    .orElse(transitVlanRepository.findUnassignedTransitVlan(minTransitVlan, maxTransitVlan)\n-                            .orElseThrow(() -> new ResourceNotAvailableException(\"No vlan available\")));\n-            if (availableVlan > maxTransitVlan) {\n-                throw new ResourceNotAvailableException(\"No vlan available\");\n+        if (nextVlan > 0) {\n+            if (nextVlan <= maxTransitVlan && !transitVlanRepository.exists(nextVlan)) {\n+                return addVlan(flow, pathId, nextVlan++);\n+            } else {\n+                nextVlan = 0;\n+            }\n+        }\n+        // The pool requires (re-)initialization.\n+        if (nextVlan == 0) {\n+            long numOfPools = (maxTransitVlan - minTransitVlan) / poolSize;\n+            if (numOfPools > 1) {\n+                long poolToTake = Math.abs(new Random().nextInt()) % numOfPools;\n+                Optional<Integer> availableVlan = transitVlanRepository.findFirstUnassignedVlan(\n+                        minTransitVlan + (int) poolToTake * poolSize,\n+                        minTransitVlan + (int) (poolToTake + 1) * poolSize - 1);\n+                if (availableVlan.isPresent()) {\n+                    nextVlan = availableVlan.get();\n+                    return addVlan(flow, pathId, nextVlan++);\n+                }\n             }\n+            // The pool requires full scan.\n+            nextVlan = -1;\n+        }\n+        if (nextVlan == -1) {\n+            Optional<Integer> availableCookie = transitVlanRepository.findFirstUnassignedVlan(minTransitVlan,", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzODgyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488038825", "bodyText": "Fixed.", "author": "sergii-iakovenko", "createdAt": "2020-09-14T15:48:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3NjMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3NzUyMQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486377521", "bodyText": "vlan -> vxlan", "author": "rozdy", "createdAt": "2020-09-10T14:13:36Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPool.java", "diffHunk": "@@ -60,27 +65,53 @@ public VxlanEncapsulation allocate(Flow flow, PathId pathId, PathId oppositePath\n                 .orElseGet(() -> allocate(flow, pathId));\n     }\n \n+    @TransactionRequired\n     private VxlanEncapsulation allocate(Flow flow, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            int startValue = ResourceUtils.computeStartValue(minVxlan, maxVxlan);\n-            int availableVxlan = vxlanRepository.findUnassignedVxlan(startValue, maxVxlan)\n-                    .orElse(vxlanRepository.findUnassignedVxlan(minVxlan, maxVxlan)\n-                            .orElseThrow(() -> new ResourceNotAvailableException(\"No vxlan available\")));\n-            if (availableVxlan > maxVxlan) {\n-                throw new ResourceNotAvailableException(\"No vxlan available\");\n+        if (nextVxlan > 0) {\n+            if (nextVxlan <= maxVxlan && !vxlanRepository.exists(nextVxlan)) {\n+                return addVxlan(flow, pathId, nextVxlan++);\n+            } else {\n+                nextVxlan = 0;\n+            }\n+        }\n+        // The pool requires (re-)initialization.\n+        if (nextVxlan == 0) {\n+            long numOfPools = (maxVxlan - minVxlan) / poolSize;\n+            if (numOfPools > 1) {\n+                long poolToTake = Math.abs(new Random().nextInt()) % numOfPools;\n+                Optional<Integer> availableVlan = vxlanRepository.findFirstUnassignedVxlan(", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzOTE4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488039189", "bodyText": "Fixed.", "author": "sergii-iakovenko", "createdAt": "2020-09-14T15:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3NzUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3Nzg3MA==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486377870", "bodyText": "cookie -> vxlan", "author": "rozdy", "createdAt": "2020-09-10T14:14:03Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPool.java", "diffHunk": "@@ -60,27 +65,53 @@ public VxlanEncapsulation allocate(Flow flow, PathId pathId, PathId oppositePath\n                 .orElseGet(() -> allocate(flow, pathId));\n     }\n \n+    @TransactionRequired\n     private VxlanEncapsulation allocate(Flow flow, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            int startValue = ResourceUtils.computeStartValue(minVxlan, maxVxlan);\n-            int availableVxlan = vxlanRepository.findUnassignedVxlan(startValue, maxVxlan)\n-                    .orElse(vxlanRepository.findUnassignedVxlan(minVxlan, maxVxlan)\n-                            .orElseThrow(() -> new ResourceNotAvailableException(\"No vxlan available\")));\n-            if (availableVxlan > maxVxlan) {\n-                throw new ResourceNotAvailableException(\"No vxlan available\");\n+        if (nextVxlan > 0) {\n+            if (nextVxlan <= maxVxlan && !vxlanRepository.exists(nextVxlan)) {\n+                return addVxlan(flow, pathId, nextVxlan++);\n+            } else {\n+                nextVxlan = 0;\n+            }\n+        }\n+        // The pool requires (re-)initialization.\n+        if (nextVxlan == 0) {\n+            long numOfPools = (maxVxlan - minVxlan) / poolSize;\n+            if (numOfPools > 1) {\n+                long poolToTake = Math.abs(new Random().nextInt()) % numOfPools;\n+                Optional<Integer> availableVlan = vxlanRepository.findFirstUnassignedVxlan(\n+                        minVxlan + (int) poolToTake * poolSize,\n+                        minVxlan + (int) (poolToTake + 1) * poolSize - 1);\n+                if (availableVlan.isPresent()) {\n+                    nextVxlan = availableVlan.get();\n+                    return addVxlan(flow, pathId, nextVxlan++);\n+                }\n             }\n+            // The pool requires full scan.\n+            nextVxlan = -1;\n+        }\n+        if (nextVxlan == -1) {\n+            Optional<Integer> availableCookie = vxlanRepository.findFirstUnassignedVxlan(minVxlan,", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NDE4Nw==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488284187", "bodyText": "Fixed.", "author": "sergii-iakovenko", "createdAt": "2020-09-14T22:59:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3Nzg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM4MjQ3Nw==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486382477", "bodyText": "You can chain this calls as it is builder now.", "author": "rozdy", "createdAt": "2020-09-10T14:20:01Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/IslMapper.java", "diffHunk": "@@ -72,29 +72,29 @@ public IslInfoData map(Isl isl) {\n             return null;\n         }\n \n-        Isl isl = new Isl();\n-\n+        Isl.IslBuilder isl = Isl.builder();\n         PathNode sourcePathNode = islInfoData.getSource();\n         if (sourcePathNode != null) {\n-            isl.setSrcSwitch(Switch.builder().switchId(sourcePathNode.getSwitchId()).build());\n-            isl.setSrcPort(sourcePathNode.getPortNo());\n+            isl.srcSwitch(Switch.builder().switchId(sourcePathNode.getSwitchId()).build());\n+            isl.srcPort(sourcePathNode.getPortNo());\n         }\n \n         PathNode destinationPathNode = islInfoData.getDestination();\n         if (destinationPathNode != null) {\n-            isl.setDestSwitch(Switch.builder().switchId(destinationPathNode.getSwitchId()).build());\n-            isl.setDestPort(destinationPathNode.getPortNo());\n+            isl.destSwitch(Switch.builder().switchId(destinationPathNode.getSwitchId()).build());\n+            isl.destPort(destinationPathNode.getPortNo());\n         }\n-        isl.setLatency((int) islInfoData.getLatency());\n-        isl.setSpeed(islInfoData.getSpeed());\n-        isl.setAvailableBandwidth(islInfoData.getAvailableBandwidth());\n-        isl.setStatus(map(islInfoData.getState()));\n-        isl.setCost(islInfoData.getCost());\n-        isl.setUnderMaintenance(islInfoData.isUnderMaintenance());\n-        isl.setEnableBfd(islInfoData.isEnableBfd());\n-        isl.setBfdSessionStatus(islInfoData.getBfdSessionStatus());\n-\n-        return isl;\n+\n+        isl.latency((int) islInfoData.getLatency());\n+        isl.speed(islInfoData.getSpeed());\n+        isl.availableBandwidth(islInfoData.getAvailableBandwidth());\n+        isl.status(map(islInfoData.getState()));\n+        isl.cost(islInfoData.getCost());\n+        isl.underMaintenance(islInfoData.isUnderMaintenance());\n+        isl.enableBfd(islInfoData.isEnableBfd());\n+        isl.bfdSessionStatus(islInfoData.getBfdSessionStatus());", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NDc3Ng==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488284776", "bodyText": "Make sense. Refactored.", "author": "sergii-iakovenko", "createdAt": "2020-09-14T23:01:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM4MjQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM4ODYzOA==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486388638", "bodyText": "vlans -> vxlans", "author": "rozdy", "createdAt": "2020-09-10T14:27:43Z", "path": "src-java/base-topology/base-storm-topology/src/test/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPoolTest.java", "diffHunk": "@@ -53,48 +52,52 @@\n \n     @Before\n     public void setUp() {\n-        vxlanPool = new VxlanPool(persistenceManager, MIN_VXLAN, MAX_VXLAN);\n+        vxlanPool = new VxlanPool(persistenceManager, MIN_VXLAN, MAX_VXLAN, 1);\n         vxlanRepository = persistenceManager.getRepositoryFactory().createVxlanRepository();\n-\n-        SwitchRepository switchRepository = persistenceManager.getRepositoryFactory().createSwitchRepository();\n-        switchRepository.createOrUpdate(SWITCH_A);\n-        switchRepository.createOrUpdate(SWITCH_B);\n     }\n \n     @Test\n     public void vxlanIdPool() {\n-        Set<Integer> vxlans = new HashSet<>();\n-        for (int i = MIN_VXLAN; i <= MAX_VXLAN; i++) {\n-            Flow flow = Flow.builder().flowId(format(\"flow_%d\", i)).srcSwitch(SWITCH_A).destSwitch(SWITCH_B).build();\n-            vxlans.add(vxlanPool.allocate(\n-                    flow,\n-                    new PathId(format(\"path_%d\", i)),\n-                    new PathId(format(\"opposite_dummy_%d\", i))).getVxlan().getVni());\n-        }\n-        assertEquals(MAX_VXLAN - MIN_VXLAN + 1, vxlans.size());\n-        vxlans.forEach(vni -> assertTrue(vni >= MIN_VXLAN && vni <= MAX_VXLAN));\n+        transactionManager.doInTransaction(() -> {\n+            Set<Integer> vxlans = new HashSet<>();\n+            for (int i = MIN_VXLAN; i <= MAX_VXLAN; i++) {\n+                Flow flow = Flow.builder()\n+                        .flowId(format(\"flow_%d\", i)).srcSwitch(SWITCH_A).destSwitch(SWITCH_B).build();\n+                vxlans.add(vxlanPool.allocate(\n+                        flow,\n+                        new PathId(format(\"path_%d\", i)),\n+                        new PathId(format(\"opposite_dummy_%d\", i))).getVxlan().getVni());\n+            }\n+            assertEquals(MAX_VXLAN - MIN_VXLAN + 1, vxlans.size());\n+            vxlans.forEach(vni -> assertTrue(vni >= MIN_VXLAN && vni <= MAX_VXLAN));\n+        });\n     }\n \n \n     @Test(expected = ResourceNotAvailableException.class)\n     public void vxlanPoolFullTest() {\n-        for (int i = MIN_VXLAN; i <= MAX_VXLAN + 1; i++) {\n-            Flow flow = Flow.builder().flowId(format(\"flow_%d\", i)).srcSwitch(SWITCH_A).destSwitch(SWITCH_B).build();\n-            assertTrue(vxlanPool.allocate(flow, new PathId(format(\"path_%d\", i)),\n-                    new PathId(format(\"op_path_%d\", i))).getVxlan().getVni() > 0);\n-        }\n+        transactionManager.doInTransaction(() -> {\n+            for (int i = MIN_VXLAN; i <= MAX_VXLAN + 1; i++) {\n+                Flow flow = Flow.builder()\n+                        .flowId(format(\"flow_%d\", i)).srcSwitch(SWITCH_A).destSwitch(SWITCH_B).build();\n+                assertTrue(vxlanPool.allocate(flow, new PathId(format(\"path_%d\", i)),\n+                        new PathId(format(\"op_path_%d\", i))).getVxlan().getVni() > 0);\n+            }\n+        });\n     }\n \n     @Test\n     public void deallocateVxlanTest() {\n-        vxlanPool.allocate(FLOW_1, PATH_ID_1, PATH_ID_2);\n-        vxlanPool.allocate(FLOW_2, PATH_ID_2, PATH_ID_1);\n-        int vni = vxlanPool.allocate(FLOW_3, PATH_ID_3, PATH_ID_3).getVxlan().getVni();\n-        assertEquals(2, vxlanRepository.findAll().size());\n+        transactionManager.doInTransaction(() -> {\n+            vxlanPool.allocate(FLOW_1, PATH_ID_1, PATH_ID_2);\n+            vxlanPool.allocate(FLOW_2, PATH_ID_2, PATH_ID_1);\n+            int vni = vxlanPool.allocate(FLOW_3, PATH_ID_3, PATH_ID_3).getVxlan().getVni();\n+            assertEquals(2, vxlanRepository.findAll().size());\n \n-        vxlanPool.deallocate(PATH_ID_1);\n-        Collection<Vxlan> transitVlans = vxlanRepository.findAll();\n-        assertEquals(1, transitVlans.size());\n-        assertEquals(vni, transitVlans.iterator().next().getVni());\n+            vxlanPool.deallocate(PATH_ID_1);\n+            Collection<Vxlan> transitVlans = vxlanRepository.findAll();", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NTIxMQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488285211", "bodyText": "Fixed.", "author": "sergii-iakovenko", "createdAt": "2020-09-14T23:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM4ODYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTgxNA==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486479814", "bodyText": "Why we need do detach if we already used copying constructor?", "author": "rozdy", "createdAt": "2020-09-10T16:32:39Z", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/SwitchOperationsService.java", "diffHunk": "@@ -95,8 +95,11 @@ public SwitchOperationsService(RepositoryFactory repositoryFactory,\n      * @param switchId switch id.\n      */\n     public GetSwitchResponse getSwitch(SwitchId switchId) throws SwitchNotFoundException {\n-        return new GetSwitchResponse(\n-                switchRepository.findById(switchId).orElseThrow(() -> new SwitchNotFoundException(switchId)));\n+        Switch sw = switchRepository.findById(switchId)\n+                .map(Switch::new)\n+                .orElseThrow(() -> new SwitchNotFoundException(switchId));\n+        switchRepository.detach(sw);", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NjQ5OQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488286499", "bodyText": "Nice catch! Fixed.", "author": "sergii-iakovenko", "createdAt": "2020-09-14T23:06:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4NzM5Mw==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486487393", "bodyText": "What is sf?", "author": "rozdy", "createdAt": "2020-09-10T16:44:54Z", "path": "src-java/network-topology/network-storm-topology/src/test/java/org/openkilda/wfm/topology/network/service/NetworkSwitchServiceTest.java", "diffHunk": "@@ -907,9 +903,7 @@ private void verifyNewSwitchAfterSwitchSync(List<SpeakerSwitchPortView> ports) {\n                 LinkStatus.of(ports.get(0).getState()));\n         verify(carrier).sendAffectedFlowRerouteRequest(alphaDatapath);\n \n-        verify(switchRepository).createOrUpdate(argThat(sw ->\n-                sw.getStatus() == SwitchStatus.INACTIVE && sw.getSwitchId() == alphaDatapath));\n-        verify(switchPropertiesRepository).createOrUpdate(argThat(sf ->\n+        verify(switchPropertiesRepository).add(argThat(sf ->", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MDM3OA==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488040378", "bodyText": "No idea. It wasn't changed in this PR. However, I'll rename it to \"s\".", "author": "sergii-iakovenko", "createdAt": "2020-09-14T15:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4NzM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5MjI3Mg==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486492272", "bodyText": "Looks like we don't need this inheritance.", "author": "rozdy", "createdAt": "2020-09-10T16:53:10Z", "path": "src-java/northbound-service/northbound/src/test/java/org/openkilda/northbound/controller/v1/FlowControllerTest.java", "diffHunk": "@@ -64,7 +64,7 @@\n @WebAppConfiguration\n @ContextConfiguration(classes = TestConfig.class)\n @TestPropertySource(\"classpath:northbound.properties\")\n-public class FlowControllerTest extends NorthboundBaseTest {\n+public class FlowControllerTest extends InMemoryGraphBasedTest {", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NzgyOQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488287829", "bodyText": "Right. Removed.", "author": "sergii-iakovenko", "createdAt": "2020-09-14T23:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5MjI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5MjQ4MQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486492481", "bodyText": "And here.", "author": "rozdy", "createdAt": "2020-09-10T16:53:26Z", "path": "src-java/northbound-service/northbound/src/test/java/org/openkilda/northbound/controller/v1/SwitchControllerTest.java", "diffHunk": "@@ -53,7 +53,7 @@\n @RunWith(SpringJUnit4ClassRunner.class)\n @WebAppConfiguration\n @ContextConfiguration(classes = TestConfig.class)\n-public class SwitchControllerTest extends NorthboundBaseTest {\n+public class SwitchControllerTest extends InMemoryGraphBasedTest {", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4Nzg4MA==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488287880", "bodyText": "Right. Removed.", "author": "sergii-iakovenko", "createdAt": "2020-09-14T23:11:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5MjQ4MQ=="}], "type": "inlineReview"}, {"oid": "047ccb4ac7c7c0e1368abc7061198be78a903388", "url": "https://github.com/telstra/open-kilda/commit/047ccb4ac7c7c0e1368abc7061198be78a903388", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-09-14T07:01:32Z", "type": "forcePushed"}, {"oid": "d4d3d1e93029769ea3bae5b3bcd89be37268cf99", "url": "https://github.com/telstra/open-kilda/commit/d4d3d1e93029769ea3bae5b3bcd89be37268cf99", "message": "Temporary disable failing functional tests.", "committedDate": "2020-09-15T06:54:22Z", "type": "forcePushed"}, {"oid": "5c75729c529676f470cd51a0b1302b8d3d63809f", "url": "https://github.com/telstra/open-kilda/commit/5c75729c529676f470cd51a0b1302b8d3d63809f", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-09-15T23:35:27Z", "type": "forcePushed"}, {"oid": "e87ded82f3d353ba7e0dac70aff574403fb88825", "url": "https://github.com/telstra/open-kilda/commit/e87ded82f3d353ba7e0dac70aff574403fb88825", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-09-23T21:53:27Z", "type": "forcePushed"}, {"oid": "731547e6ff7803213c447010bcc28013fb300b48", "url": "https://github.com/telstra/open-kilda/commit/731547e6ff7803213c447010bcc28013fb300b48", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-09-24T10:00:33Z", "type": "forcePushed"}, {"oid": "03afdab3d9bd6dcda5e962d7dd13788012df2217", "url": "https://github.com/telstra/open-kilda/commit/03afdab3d9bd6dcda5e962d7dd13788012df2217", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-09-24T21:42:42Z", "type": "forcePushed"}, {"oid": "aae9afddb5c903273f253e4fcf957c671a9ed2cd", "url": "https://github.com/telstra/open-kilda/commit/aae9afddb5c903273f253e4fcf957c671a9ed2cd", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-10-01T16:39:09Z", "type": "commit"}, {"oid": "aae9afddb5c903273f253e4fcf957c671a9ed2cd", "url": "https://github.com/telstra/open-kilda/commit/aae9afddb5c903273f253e4fcf957c671a9ed2cd", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-10-01T16:39:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNzY3MA==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r498517670", "bodyText": "I'm not very familiar with new DB but how it should work? After changing local Instance of device it will be saved in DB automatically?", "author": "niksv", "createdAt": "2020-10-01T21:16:35Z", "path": "src-java/connecteddevices-topology/connecteddevices-storm-topology/src/main/java/org/openkilda/wfm/topology/connecteddevices/service/PacketService.java", "diffHunk": "@@ -97,8 +97,6 @@ public void handleLldpData(LldpInfoData data) {\n             device.setTimeLastSeen(Instant.ofEpochMilli(data.getTimestamp()));\n             device.setFlowId(flowRelatedData.flowId);\n             device.setSource(flowRelatedData.source);\n-\n-            switchConnectedDeviceRepository.createOrUpdate(device);", "originalCommit": "aae9afddb5c903273f253e4fcf957c671a9ed2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY4MTA3OQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r498681079", "bodyText": "The implementation relies on the concept of persistence context (persistence-layer). When the entity instance is in the persistent state, all changes that you make to this instance will be applied to the corresponding storage records upon committing of the transaction or closing the persistence context. This means that you don't have to call save, update or other repository methods to get these changes to the storage.\nThe same approach is used in JPA, Hibernate and many other solutions.", "author": "sergii-iakovenko", "createdAt": "2020-10-02T08:22:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNzY3MA=="}], "type": "inlineReview"}]}