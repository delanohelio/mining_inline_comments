{"pr_number": 3473, "pr_title": "Add fields to 'PATCH /flows/{flow-id}/'", "pr_createdAt": "2020-05-15T09:05:05Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3473", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY3MDEzMg==", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r425670132", "bodyText": "I think you cat remove it because name is the same", "author": "niksv", "createdAt": "2020-05-15T09:11:11Z", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/RequestedFlowMapper.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.share.mappers;\n+\n+import org.openkilda.messaging.command.flow.FlowRequest;\n+import org.openkilda.model.Flow;\n+\n+import org.mapstruct.Mapper;\n+import org.mapstruct.Mapping;\n+import org.mapstruct.factory.Mappers;\n+\n+@Mapper\n+public abstract class RequestedFlowMapper {\n+\n+    public static final RequestedFlowMapper INSTANCE = Mappers.getMapper(RequestedFlowMapper.class);\n+\n+    /**\n+     * Convert {@link Flow} to {@link FlowRequest}.\n+     */\n+    @Mapping(target = \"flowId\", source = \"flowId\")", "originalCommit": "90fdc0399eca9e330aab1e1d186f942d6ad8428d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyNDEyOA==", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r428824128", "bodyText": "Did you mean \"your cat\"?", "author": "surabujin", "createdAt": "2020-05-21T18:08:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY3MDEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI0MTE4Mg==", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r429241182", "bodyText": ":)", "author": "niksv", "createdAt": "2020-05-22T13:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY3MDEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5MDgwOQ==", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r425690809", "bodyText": "same", "author": "niksv", "createdAt": "2020-05-15T09:48:40Z", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/RequestedFlowMapper.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.share.mappers;\n+\n+import org.openkilda.messaging.command.flow.FlowRequest;\n+import org.openkilda.model.Flow;\n+\n+import org.mapstruct.Mapper;\n+import org.mapstruct.Mapping;\n+import org.mapstruct.factory.Mappers;\n+\n+@Mapper\n+public abstract class RequestedFlowMapper {\n+\n+    public static final RequestedFlowMapper INSTANCE = Mappers.getMapper(RequestedFlowMapper.class);\n+\n+    /**\n+     * Convert {@link Flow} to {@link FlowRequest}.\n+     */\n+    @Mapping(target = \"flowId\", source = \"flowId\")\n+    @Mapping(target = \"sourceSwitch\", expression = \"java(flow.getSrcSwitch().getSwitchId())\")\n+    @Mapping(target = \"sourcePort\", source = \"srcPort\")\n+    @Mapping(target = \"sourceVlan\", source = \"srcVlan\")\n+    @Mapping(target = \"destinationSwitch\", expression = \"java(flow.getDestSwitch().getSwitchId())\")\n+    @Mapping(target = \"destinationPort\", source = \"destPort\")\n+    @Mapping(target = \"destinationVlan\", source = \"destVlan\")\n+    @Mapping(target = \"encapsulationType\", source = \"encapsulationType\")", "originalCommit": "90fdc0399eca9e330aab1e1d186f942d6ad8428d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5MDk0Ng==", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r425690946", "bodyText": "same", "author": "niksv", "createdAt": "2020-05-15T09:48:57Z", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/RequestedFlowMapper.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.share.mappers;\n+\n+import org.openkilda.messaging.command.flow.FlowRequest;\n+import org.openkilda.model.Flow;\n+\n+import org.mapstruct.Mapper;\n+import org.mapstruct.Mapping;\n+import org.mapstruct.factory.Mappers;\n+\n+@Mapper\n+public abstract class RequestedFlowMapper {\n+\n+    public static final RequestedFlowMapper INSTANCE = Mappers.getMapper(RequestedFlowMapper.class);\n+\n+    /**\n+     * Convert {@link Flow} to {@link FlowRequest}.\n+     */\n+    @Mapping(target = \"flowId\", source = \"flowId\")\n+    @Mapping(target = \"sourceSwitch\", expression = \"java(flow.getSrcSwitch().getSwitchId())\")\n+    @Mapping(target = \"sourcePort\", source = \"srcPort\")\n+    @Mapping(target = \"sourceVlan\", source = \"srcVlan\")\n+    @Mapping(target = \"destinationSwitch\", expression = \"java(flow.getDestSwitch().getSwitchId())\")\n+    @Mapping(target = \"destinationPort\", source = \"destPort\")\n+    @Mapping(target = \"destinationVlan\", source = \"destVlan\")\n+    @Mapping(target = \"encapsulationType\", source = \"encapsulationType\")\n+    @Mapping(target = \"pathComputationStrategy\",\n+            expression = \"java(java.util.Optional.ofNullable(flow.getPathComputationStrategy())\"\n+                    + \".map(pcs -> pcs.toString().toLowerCase())\"\n+                    + \".orElse(null))\")\n+    @Mapping(target = \"bandwidth\", source = \"bandwidth\")\n+    @Mapping(target = \"ignoreBandwidth\", source = \"ignoreBandwidth\")\n+    @Mapping(target = \"periodicPings\", source = \"periodicPings\")\n+    @Mapping(target = \"allocateProtectedPath\", source = \"allocateProtectedPath\")\n+    @Mapping(target = \"description\", source = \"description\")\n+    @Mapping(target = \"maxLatency\", source = \"maxLatency\")\n+    @Mapping(target = \"priority\", source = \"priority\")\n+    @Mapping(target = \"pinned\", source = \"pinned\")\n+    @Mapping(target = \"detectConnectedDevices\", source = \"detectConnectedDevices\")", "originalCommit": "90fdc0399eca9e330aab1e1d186f942d6ad8428d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5NDk2OQ==", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r425694969", "bodyText": "what about:\n\ncomparing with current DiverseFlowId?\nsetting DiverseFlowId = null to do not diverse with any flow?", "author": "niksv", "createdAt": "2020-05-15T09:56:40Z", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java", "diffHunk": "@@ -330,42 +329,72 @@ public Flow updateFlow(FlowOperationsCarrier carrier, FlowDto flow) throws FlowN\n \n             return Optional.of(result.updatedFlow(currentFlow).build());\n \n-        }).orElseThrow(() -> new FlowNotFoundException(flow.getFlowId()));\n+        }).orElseThrow(() -> new FlowNotFoundException(flowPatch.getFlowId()));\n \n-        if (updateFlowResult.isNeedRerouteFlow()) {\n-            Flow updatedFlow = updateFlowResult.getUpdatedFlow();\n-            Set<IslEndpoint> affectedIslEndpoints =\n-                    Sets.newHashSet(new IslEndpoint(flow.getSourceSwitch(), flow.getSourcePort()),\n-                            new IslEndpoint(flow.getDestinationSwitch(), flow.getDestinationPort()));\n-            carrier.sendRerouteRequest(updatedFlow.getPaths(), affectedIslEndpoints,\n-                    updateFlowResult.getRerouteReason());\n+        Flow updatedFlow = updateFlowResult.getUpdatedFlow();\n+        if (updateFlowResult.isNeedUpdateFlow()) {\n+            FlowRequest flowRequest = RequestedFlowMapper.INSTANCE.toFlowRequest(updatedFlow);\n+            carrier.sendUpdateRequest(addChangedFields(flowRequest, flowPatch));\n+        } else {\n+            carrier.sendNorthboundResponse(new FlowResponse(FlowMapper.INSTANCE.map(updatedFlow)));\n         }\n \n         return updateFlowResult.getUpdatedFlow();\n     }\n \n     @VisibleForTesting\n-    UpdateFlowResult.UpdateFlowResultBuilder prepareFlowUpdateResult(FlowDto flowDto, Flow flow) {\n-        boolean changedStrategy = flowDto.getPathComputationStrategy() != null\n-                && !flowDto.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n-        boolean changedMaxLatency = flowDto.getMaxLatency() != null\n-                && !flowDto.getMaxLatency().equals(flow.getMaxLatency());\n-        boolean strategyIsMaxLatency = PathComputationStrategy.MAX_LATENCY.equals(flowDto.getPathComputationStrategy())\n-                || flowDto.getPathComputationStrategy() == null\n+    UpdateFlowResult.UpdateFlowResultBuilder prepareFlowUpdateResult(FlowPatch flowPatch, Flow flow) {\n+        boolean changedStrategy = flowPatch.getPathComputationStrategy() != null\n+                && !flowPatch.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n+        boolean changedMaxLatency = flowPatch.getMaxLatency() != null\n+                && !flowPatch.getMaxLatency().equals(flow.getMaxLatency());\n+        boolean strategyIsMaxLatency =\n+                PathComputationStrategy.MAX_LATENCY.equals(flowPatch.getPathComputationStrategy())\n+                || flowPatch.getPathComputationStrategy() == null\n                 && PathComputationStrategy.MAX_LATENCY.equals(flow.getPathComputationStrategy());\n \n-        String reason = null;\n-        if (changedStrategy) {\n-            reason = format(\"initiated via Northbound, path computation strategy was changed from %s to %s\",\n-                    flow.getPathComputationStrategy(), flowDto.getPathComputationStrategy());\n-        } else if (changedMaxLatency && strategyIsMaxLatency) {\n-            reason = format(\"initiated via Northbound, max latency was changed from %d to %d\",\n-                    flow.getMaxLatency(), flowDto.getMaxLatency());\n-        }\n+        boolean changedSourceSwitch = flowPatch.getSourceSwitch() != null\n+                && !flow.getSrcSwitch().getSwitchId().equals(flowPatch.getSourceSwitch());\n+        boolean changedSourcePort = flowPatch.getSourcePort() != null\n+                && flow.getSrcPort() != flowPatch.getSourcePort();\n+        boolean changedSourceVlan = flowPatch.getSourceVlan() != null\n+                && flow.getSrcVlan() != flowPatch.getSourceVlan();\n+        boolean changedSourceEndpoint = changedSourceSwitch || changedSourcePort || changedSourceVlan;\n+\n+        boolean changedDestinationSwitch = flowPatch.getDestinationSwitch() != null\n+                && !flow.getDestSwitch().getSwitchId().equals(flowPatch.getDestinationSwitch());\n+        boolean changedDestinationPort = flowPatch.getDestinationPort() != null\n+                && flow.getDestPort() != flowPatch.getDestinationPort();\n+        boolean changedDestinationVlan = flowPatch.getDestinationVlan() != null\n+                && flow.getDestVlan() != flowPatch.getDestinationVlan();\n+        boolean changedDestinationEndpoint\n+                = changedDestinationSwitch || changedDestinationPort || changedDestinationVlan;\n+\n+        boolean addedDiverseFlowId = flowPatch.getDiverseFlowId() != null;", "originalCommit": "90fdc0399eca9e330aab1e1d186f942d6ad8428d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc0OTYxNA==", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r425749614", "bodyText": "Fixed", "author": "dpoltavets", "createdAt": "2020-05-15T11:52:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5NDk2OQ=="}], "type": "inlineReview"}, {"oid": "38f6321e3c598e180ed5e077dec56ca4b10fb53e", "url": "https://github.com/telstra/open-kilda/commit/38f6321e3c598e180ed5e077dec56ca4b10fb53e", "message": "Added fields to 'PATCH /flows/{flow-id}/'", "committedDate": "2020-05-15T10:53:05Z", "type": "forcePushed"}, {"oid": "9b551889c0ac911e4eaa44de4a8cef9f61b23c9c", "url": "https://github.com/telstra/open-kilda/commit/9b551889c0ac911e4eaa44de4a8cef9f61b23c9c", "message": "Added fields to 'PATCH /flows/{flow-id}/'", "committedDate": "2020-05-18T09:47:44Z", "type": "forcePushed"}, {"oid": "a35249f6f9e4fa122c6e14d3a1cfea2b96a6da93", "url": "https://github.com/telstra/open-kilda/commit/a35249f6f9e4fa122c6e14d3a1cfea2b96a6da93", "message": "Added fields to 'PATCH /flows/{flow-id}/'", "committedDate": "2020-05-18T11:58:11Z", "type": "forcePushed"}, {"oid": "b78642c704c8cb6aebc58eb58a96e3d72eb0996c", "url": "https://github.com/telstra/open-kilda/commit/b78642c704c8cb6aebc58eb58a96e3d72eb0996c", "message": "Added fields to 'PATCH /flows/{flow-id}/'", "committedDate": "2020-05-19T06:15:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODAyMTQ3Mw==", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r428021473", "bodyText": "Interesting fact: empty string is actually a valid name for a flow", "author": "rtretyak", "createdAt": "2020-05-20T13:43:24Z", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v1/FlowController.java", "diffHunk": "@@ -148,6 +148,9 @@\n     @PatchMapping(value = \"/{flow-id:.+}\")\n     @ResponseStatus(HttpStatus.OK)\n     public CompletableFuture<FlowResponsePayload> patchFlow(@PathVariable(name = \"flow-id\") String flowId,\n+                                                            @ApiParam(value = \"To remove flow from a diverse group, \"\n+                                                                    + \"need to pass the parameter \\\"diverse_flow_id\\\" \"\n+                                                                    + \"equal to the empty string.\")", "originalCommit": "b78642c704c8cb6aebc58eb58a96e3d72eb0996c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA1OTgyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r428059825", "bodyText": "in v1 it is \"port-id\"\nin v2 it is \"port_number\"\nhere it is \"port_id\"\nI think this should be made consistent with v1 and read \"port-id\" as well", "author": "rtretyak", "createdAt": "2020-05-20T14:30:24Z", "path": "src-java/northbound-service/northbound-api/src/main/java/org/openkilda/northbound/dto/v1/flows/FlowEndpointDto.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.northbound.dto.v1.flows;\n+\n+import org.openkilda.model.SwitchId;\n+\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy.SnakeCaseStrategy;\n+import com.fasterxml.jackson.databind.annotation.JsonNaming;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+@Data\n+@NoArgsConstructor\n+@AllArgsConstructor\n+@JsonNaming(value = SnakeCaseStrategy.class)\n+public class FlowEndpointDto {\n+    private SwitchId switchId;\n+    private Integer portId;", "originalCommit": "b78642c704c8cb6aebc58eb58a96e3d72eb0996c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1MDMwMw==", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r428450303", "bodyText": "could be rewritten:\nupdateRequired = false;\nupdate Required |= flowPatch.getPathComputationStrategy() != null\n&& !flowDto.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n&& !flowPatch.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\nno need in separate booleans from what I see here", "author": "timofei-durakov", "createdAt": "2020-05-21T05:21:21Z", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java", "diffHunk": "@@ -334,42 +334,95 @@ public Flow updateFlow(FlowOperationsCarrier carrier, FlowDto flow) throws FlowN\n \n             return Optional.of(result.updatedFlow(currentFlow).build());\n \n-        }).orElseThrow(() -> new FlowNotFoundException(flow.getFlowId()));\n+        }).orElseThrow(() -> new FlowNotFoundException(flowPatch.getFlowId()));\n \n-        if (updateFlowResult.isNeedRerouteFlow()) {\n-            Flow updatedFlow = updateFlowResult.getUpdatedFlow();\n-            Set<IslEndpoint> affectedIslEndpoints =\n-                    Sets.newHashSet(new IslEndpoint(flow.getSourceSwitch(), flow.getSourcePort()),\n-                            new IslEndpoint(flow.getDestinationSwitch(), flow.getDestinationPort()));\n-            carrier.sendRerouteRequest(updatedFlow.getPaths(), affectedIslEndpoints,\n-                    updateFlowResult.getRerouteReason());\n+        Flow updatedFlow = updateFlowResult.getUpdatedFlow();\n+        if (updateFlowResult.isNeedUpdateFlow()) {\n+            FlowRequest flowRequest = RequestedFlowMapper.INSTANCE.toFlowRequest(updatedFlow);\n+            carrier.sendUpdateRequest(addChangedFields(flowRequest, flowPatch, updateFlowResult.getDiverseFlowId()));\n+        } else {\n+            carrier.sendNorthboundResponse(new FlowResponse(FlowMapper.INSTANCE.map(updatedFlow)));\n         }\n \n         return updateFlowResult.getUpdatedFlow();\n     }\n \n     @VisibleForTesting\n-    UpdateFlowResult.UpdateFlowResultBuilder prepareFlowUpdateResult(FlowDto flowDto, Flow flow) {\n-        boolean changedStrategy = flowDto.getPathComputationStrategy() != null\n-                && !flowDto.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n-        boolean changedMaxLatency = flowDto.getMaxLatency() != null\n-                && !flowDto.getMaxLatency().equals(flow.getMaxLatency());\n-        boolean strategyIsMaxLatency = PathComputationStrategy.MAX_LATENCY.equals(flowDto.getPathComputationStrategy())\n-                || flowDto.getPathComputationStrategy() == null\n+    UpdateFlowResult.UpdateFlowResultBuilder prepareFlowUpdateResult(FlowPatch flowPatch, Flow flow) {\n+        boolean changedStrategy = flowPatch.getPathComputationStrategy() != null\n+                && !flowPatch.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n+        boolean changedMaxLatency = flowPatch.getMaxLatency() != null\n+                && !flowPatch.getMaxLatency().equals(flow.getMaxLatency());\n+        boolean strategyIsMaxLatency =\n+                PathComputationStrategy.MAX_LATENCY.equals(flowPatch.getPathComputationStrategy())\n+                || flowPatch.getPathComputationStrategy() == null\n                 && PathComputationStrategy.MAX_LATENCY.equals(flow.getPathComputationStrategy());\n \n-        String reason = null;\n-        if (changedStrategy) {\n-            reason = format(\"initiated via Northbound, path computation strategy was changed from %s to %s\",\n-                    flow.getPathComputationStrategy(), flowDto.getPathComputationStrategy());\n-        } else if (changedMaxLatency && strategyIsMaxLatency) {\n-            reason = format(\"initiated via Northbound, max latency was changed from %d to %d\",\n-                    flow.getMaxLatency(), flowDto.getMaxLatency());\n+        boolean changedSourceSwitch = flowPatch.getSourceSwitch() != null\n+                && !flow.getSrcSwitch().getSwitchId().equals(flowPatch.getSourceSwitch());\n+        boolean changedSourcePort = flowPatch.getSourcePort() != null\n+                && flow.getSrcPort() != flowPatch.getSourcePort();\n+        boolean changedSourceVlan = flowPatch.getSourceVlan() != null\n+                && flow.getSrcVlan() != flowPatch.getSourceVlan();\n+        boolean changedSourceEndpoint = changedSourceSwitch || changedSourcePort || changedSourceVlan;\n+\n+        boolean changedDestinationSwitch = flowPatch.getDestinationSwitch() != null\n+                && !flow.getDestSwitch().getSwitchId().equals(flowPatch.getDestinationSwitch());\n+        boolean changedDestinationPort = flowPatch.getDestinationPort() != null\n+                && flow.getDestPort() != flowPatch.getDestinationPort();\n+        boolean changedDestinationVlan = flowPatch.getDestinationVlan() != null\n+                && flow.getDestVlan() != flowPatch.getDestinationVlan();\n+        boolean changedDestinationEndpoint\n+                = changedDestinationSwitch || changedDestinationPort || changedDestinationVlan;", "originalCommit": "b78642c704c8cb6aebc58eb58a96e3d72eb0996c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4NzkyMg==", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r429087922", "bodyText": "Fixed.", "author": "dpoltavets", "createdAt": "2020-05-22T07:31:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1MDMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1MDQzNw==", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r428450437", "bodyText": "typo: FlowPatch", "author": "timofei-durakov", "createdAt": "2020-05-21T05:22:00Z", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/test/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsServiceTest.java", "diffHunk": "@@ -105,34 +107,34 @@ public void shouldUpdateMaxLatencyAndPriorityFlowFields() throws FlowNotFoundExc\n         flow.setStatus(FlowStatus.UP);\n         flowRepository.createOrUpdate(flow);\n \n-        FlowDto receivedFlow = FlowDto.builder()\n+        FlowPatch receivedFlow = FlowPatch.builder()\n                 .flowId(testFlowId)\n                 .maxLatency(maxLatency)\n                 .priority(priority)\n                 .targetPathComputationStrategy(pathComputationStrategy)\n                 .build();\n \n-        Flow updatedFlow = flowOperationsService.updateFlow(null, receivedFlow);\n+        Flow updatedFlow = flowOperationsService.updateFlow(new FlowCarrierImpl(), receivedFlow);\n \n         assertEquals(maxLatency, updatedFlow.getMaxLatency());\n         assertEquals(priority, updatedFlow.getPriority());\n         assertEquals(pathComputationStrategy, updatedFlow.getTargetPathComputationStrategy());\n \n-        receivedFlow = FlowDto.builder()\n+        receivedFlow = FlowPatch.builder()\n                 .flowId(testFlowId)\n                 .build();\n-        updatedFlow = flowOperationsService.updateFlow(null, receivedFlow);\n+        updatedFlow = flowOperationsService.updateFlow(new FlowCarrierImpl(), receivedFlow);\n \n         assertEquals(maxLatency, updatedFlow.getMaxLatency());\n         assertEquals(priority, updatedFlow.getPriority());\n         assertEquals(pathComputationStrategy, updatedFlow.getTargetPathComputationStrategy());\n     }\n \n     @Test\n-    public void shouldPrepareFlowUpdateResultWithChangedStrategyReason() {\n-        // given: FlowDto with COST strategy and Flow with MAX_LATENCY strategy\n+    public void shouldPrepareFlowUpdateResultWithChangedStrategy() {\n+        // given: FlowPath with COST strategy and Flow with MAX_LATENCY strategy", "originalCommit": "b78642c704c8cb6aebc58eb58a96e3d72eb0996c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4Nzk1NQ==", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r429087955", "bodyText": "Fixed.", "author": "dpoltavets", "createdAt": "2020-05-22T07:31:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1MDQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1MDQ3Mg==", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r428450472", "bodyText": "same", "author": "timofei-durakov", "createdAt": "2020-05-21T05:22:07Z", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/test/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsServiceTest.java", "diffHunk": "@@ -147,16 +149,15 @@ public void shouldPrepareFlowUpdateResultWithChangedStrategyReason() {\n         // when: compare this flows\n         UpdateFlowResult result = flowOperationsService.prepareFlowUpdateResult(flowDto, flow).build();\n \n-        // then: needRerouteFlow flag set to true and rerouteReason is \"path computation strategy was changed\"\n-        assertTrue(result.isNeedRerouteFlow());\n-        assertTrue(result.getRerouteReason().contains(\"path computation strategy was changed\"));\n+        // then: needUpdateFlow flag set to true\n+        assertTrue(result.isNeedUpdateFlow());\n     }\n \n     @Test\n-    public void shouldPrepareFlowUpdateResultWithChangedMaxLatencyReasonFirstCase() {\n-        // given: FlowDto with max latency and no strategy and Flow with MAX_LATENCY strategy and no max latency\n+    public void shouldPrepareFlowUpdateResultWithChangedMaxLatencyFirstCase() {\n+        // given: FlowPath with max latency and no strategy and Flow with MAX_LATENCY strategy and no max latency", "originalCommit": "b78642c704c8cb6aebc58eb58a96e3d72eb0996c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4Nzk5MA==", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r429087990", "bodyText": "Fixed.", "author": "dpoltavets", "createdAt": "2020-05-22T07:31:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1MDQ3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3MjI2Ng==", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r428072266", "bodyText": "diverse-flowid in v1", "author": "rtretyak", "createdAt": "2020-05-20T14:46:22Z", "path": "src-java/northbound-service/northbound-api/src/main/java/org/openkilda/northbound/dto/v1/flows/FlowPatchDto.java", "diffHunk": "@@ -36,14 +42,33 @@\n     @JsonProperty(\"target_path_computation_strategy\")\n     private String targetPathComputationStrategy;\n \n+    @JsonProperty(\"diverse_flow_id\")", "originalCommit": "b78642c704c8cb6aebc58eb58a96e3d72eb0996c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "656970b51fdb97431e8b38cb37a445758289c77d", "url": "https://github.com/telstra/open-kilda/commit/656970b51fdb97431e8b38cb37a445758289c77d", "message": "Added fields to 'PATCH /flows/{flow-id}/'", "committedDate": "2020-05-21T10:55:09Z", "type": "forcePushed"}, {"oid": "5788dd2534296be6032f4e5a33ed4f8989a7dc80", "url": "https://github.com/telstra/open-kilda/commit/5788dd2534296be6032f4e5a33ed4f8989a7dc80", "message": "Added fields to 'PATCH /flows/{flow-id}/'", "committedDate": "2020-05-22T07:30:46Z", "type": "forcePushed"}, {"oid": "359a4536c727505923c091e5ffbc64faff9cea6a", "url": "https://github.com/telstra/open-kilda/commit/359a4536c727505923c091e5ffbc64faff9cea6a", "message": "Added fields to 'PATCH /flows/{flow-id}/'", "committedDate": "2020-05-25T14:31:24Z", "type": "forcePushed"}, {"oid": "5b34d4dc5fa7e5cacd4ddf17b52260da64803ead", "url": "https://github.com/telstra/open-kilda/commit/5b34d4dc5fa7e5cacd4ddf17b52260da64803ead", "message": "Added fields to 'PATCH /flows/{flow-id}/'", "committedDate": "2020-05-26T05:23:49Z", "type": "forcePushed"}, {"oid": "25ab6d6e7f1f1683904b625e0a45ddc0228b1a86", "url": "https://github.com/telstra/open-kilda/commit/25ab6d6e7f1f1683904b625e0a45ddc0228b1a86", "message": "Added fields to 'PATCH /flows/{flow-id}/'", "committedDate": "2020-05-26T10:32:52Z", "type": "forcePushed"}, {"oid": "a5534153af76476d36bad0295615ab9effc81d66", "url": "https://github.com/telstra/open-kilda/commit/a5534153af76476d36bad0295615ab9effc81d66", "message": "Added fields to 'PATCH /flows/{flow-id}/'", "committedDate": "2020-05-26T10:55:06Z", "type": "commit"}, {"oid": "a5534153af76476d36bad0295615ab9effc81d66", "url": "https://github.com/telstra/open-kilda/commit/a5534153af76476d36bad0295615ab9effc81d66", "message": "Added fields to 'PATCH /flows/{flow-id}/'", "committedDate": "2020-05-26T10:55:06Z", "type": "forcePushed"}]}