{"pr_number": 3693, "pr_title": "Add an operations queue to the Reroute topology.", "pr_createdAt": "2020-08-25T08:34:11Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3693", "timeline": [{"oid": "d2b30c872db1a0847b00e5028eca03bd93b9a7f0", "url": "https://github.com/telstra/open-kilda/commit/d2b30c872db1a0847b00e5028eca03bd93b9a7f0", "message": "Added an operations queue to the Reroute topology.", "committedDate": "2020-08-31T05:16:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI3NjEwNQ==", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r480276105", "bodyText": "Do we need success field in PathSwapResult only to log it here? We already logged it in H&S.", "author": "rozdy", "createdAt": "2020-08-31T17:25:04Z", "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/service/OperationQueueService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.service;\n+\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.info.InfoData;\n+import org.openkilda.wfm.topology.reroute.bolts.OperationQueueCarrier;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class OperationQueueService {\n+    private final OperationQueueCarrier carrier;\n+\n+    private final Map<String, FlowQueueData> flowCommands = new HashMap<>();\n+\n+    public OperationQueueService(OperationQueueCarrier carrier) {\n+        this.carrier = carrier;\n+    }\n+\n+    /**\n+     * Add command to the front of the queue.\n+     */\n+    public void addFirst(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addFirst(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Add command to the end of the queue.\n+     */\n+    public void addLast(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addLast(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Handle timeout.\n+     */\n+    public void handleTimeout(String correlationId) {\n+        log.warn(\"Operation with correlationId {} has timed out\", correlationId);\n+        Collection<FlowQueueData> foundQueueData = flowCommands.values().stream()\n+                .filter(flowQueueData -> correlationId.equals(flowQueueData.getTaskInProgress()))\n+                .collect(Collectors.toList());\n+\n+        if (foundQueueData.isEmpty()) {\n+            log.warn(\"No queue data with correlationId {} found. Timeout event skipped.\", correlationId);\n+        } else if (foundQueueData.size() > 1) {\n+            log.error(\"Found more than one queue data with correlationId {}. Timed out all of them.\", correlationId);\n+        }\n+\n+        foundQueueData.forEach(queueData -> operationCompleted(queueData, null));\n+    }\n+\n+    public void operationCompleted(String flowId, InfoData response) {\n+        operationCompleted(getFlowQueueData(flowId), response);\n+    }\n+\n+    private void operationCompleted(FlowQueueData queueData, InfoData response) {\n+        log.info(\"Flow command {} has been completed with response {}\", queueData.getTaskInProgress(), response);", "originalCommit": "d2b30c872db1a0847b00e5028eca03bd93b9a7f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgzOTA2Ng==", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r482839066", "bodyText": "maybe we should use warn/error log level here?", "author": "niksv", "createdAt": "2020-09-03T09:27:48Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/pathswap/action/OnFinishedWithErrorAction.java", "diffHunk": "@@ -36,5 +36,9 @@ public OnFinishedWithErrorAction(FlowOperationsDashboardLogger dashboardLogger)\n     public void execute(State from, State to, Event event, FlowPathSwapContext context, FlowPathSwapFsm stateMachine) {\n         dashboardLogger.onFailedFlowUpdate(stateMachine.getFlowId(), stateMachine.getErrorReason());\n         stateMachine.saveActionToHistory(\"Failed to swap paths for the flow\", stateMachine.getErrorReason());\n+\n+        log.info(\"Flow {} path swap failed\", stateMachine.getFlowId());", "originalCommit": "d2b30c872db1a0847b00e5028eca03bd93b9a7f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3NjU3Nw==", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r483376577", "bodyText": "The warn level is now used here.", "author": "dpoltavets", "createdAt": "2020-09-04T04:18:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgzOTA2Ng=="}], "type": "inlineReview"}, {"oid": "6df27f1aeafeb56e82cf5511f079925120faa33b", "url": "https://github.com/telstra/open-kilda/commit/6df27f1aeafeb56e82cf5511f079925120faa33b", "message": "Added an operations queue to the Reroute topology.", "committedDate": "2020-09-04T04:16:49Z", "type": "forcePushed"}, {"oid": "6742f4bf78f080594c93c846d10cd47edfa6f77d", "url": "https://github.com/telstra/open-kilda/commit/6742f4bf78f080594c93c846d10cd47edfa6f77d", "message": "Added an operations queue to the Reroute topology.", "committedDate": "2020-10-06T06:17:11Z", "type": "forcePushed"}, {"oid": "e4fa5472eb92f83bedffd7a29f22f62435c18df8", "url": "https://github.com/telstra/open-kilda/commit/e4fa5472eb92f83bedffd7a29f22f62435c18df8", "message": "Added an operations queue to the Reroute topology.", "committedDate": "2020-10-06T10:03:18Z", "type": "forcePushed"}, {"oid": "3315800259b82775cc21a509656551945c906cec", "url": "https://github.com/telstra/open-kilda/commit/3315800259b82775cc21a509656551945c906cec", "message": "Added an operations queue to the Reroute topology.", "committedDate": "2020-10-14T06:47:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYwNzI4Mw==", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506607283", "bodyText": "Do we really want to use anchored emit here (getCurrentTuple())?", "author": "surabujin", "createdAt": "2020-10-16T17:05:52Z", "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/FlowRerouteQueueBolt.java", "diffHunk": "@@ -106,15 +110,15 @@ protected void init() {\n     public void declareOutputFields(OutputFieldsDeclarer declarer) {\n         super.declareOutputFields(declarer);\n         declarer.declareStream(TimeWindowBolt.STREAM_TIME_WINDOW_EVENT_ID, new Fields(FIELD_ID_CONTEXT));\n-        declarer.declareStream(STREAM_FLOWHS_ID, RerouteTopology.KAFKA_FIELDS);\n+        declarer.declareStream(STREAM_OPERATION_QUEUE_ID, FIELDS_OPERATION_QUEUE);\n         declarer.declareStream(STREAM_NORTHBOUND_ID, RerouteTopology.KAFKA_FIELDS);\n     }\n \n     @Override\n     public void sendRerouteRequest(String correlationId, FlowRerouteRequest request) {\n         log.info(\"Send reroute request {} with correlationId {}\", request, correlationId);\n-        getOutput().emit(STREAM_FLOWHS_ID, getCurrentTuple(),\n-                new Values(correlationId, new CommandMessage(request, System.currentTimeMillis(), correlationId)));\n+        emit(STREAM_OPERATION_QUEUE_ID, getCurrentTuple(),", "originalCommit": "3315800259b82775cc21a509656551945c906cec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzQ2OTEyMA==", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r507469120", "bodyText": "Anchor has been removed.", "author": "dpoltavets", "createdAt": "2020-10-19T05:16:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYwNzI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYwODcyNA==", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506608724", "bodyText": "... code is better without this garbage.", "author": "surabujin", "createdAt": "2020-10-16T17:08:49Z", "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/OperationQueueBolt.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.bolts;\n+\n+import static org.openkilda.wfm.topology.utils.KafkaRecordTranslator.FIELD_ID_KEY;\n+import static org.openkilda.wfm.topology.utils.KafkaRecordTranslator.FIELD_ID_PAYLOAD;\n+\n+import org.openkilda.messaging.MessageData;\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.command.CommandMessage;\n+import org.openkilda.messaging.command.flow.FlowPathSwapRequest;\n+import org.openkilda.messaging.command.flow.FlowRerouteRequest;\n+import org.openkilda.messaging.info.reroute.PathSwapResult;\n+import org.openkilda.messaging.info.reroute.RerouteResultInfoData;\n+import org.openkilda.wfm.CommandContext;\n+import org.openkilda.wfm.error.PipelineException;\n+import org.openkilda.wfm.share.hubandspoke.CoordinatedBolt;\n+import org.openkilda.wfm.topology.reroute.service.OperationQueueService;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.storm.topology.OutputFieldsDeclarer;\n+import org.apache.storm.tuple.Fields;\n+import org.apache.storm.tuple.Tuple;\n+import org.apache.storm.tuple.Values;\n+\n+@Slf4j\n+public class OperationQueueBolt extends CoordinatedBolt implements OperationQueueCarrier {\n+    public static final String BOLT_ID = \"operation-queue\";\n+\n+    public static final String FLOW_ID_FIELD = RerouteBolt.FLOW_ID_FIELD;\n+\n+    public static final String REROUTE_QUEUE_STREAM = \"reroute-queue-stream\";\n+    public static final Fields REROUTE_QUEUE_FIELDS = new Fields(FLOW_ID_FIELD, FIELD_ID_PAYLOAD, FIELD_ID_CONTEXT);\n+\n+    public static final Fields FLOW_HS_FIELDS = new Fields(FIELD_ID_KEY, FIELD_ID_PAYLOAD);\n+\n+    private transient OperationQueueService service;\n+\n+    public OperationQueueBolt(int defaultTimeout) {\n+        super(true, defaultTimeout);\n+    }\n+\n+    /**\n+     * {@inheritDoc}", "originalCommit": "3315800259b82775cc21a509656551945c906cec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NTMzNg==", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506675336", "bodyText": "Removed.", "author": "dpoltavets", "createdAt": "2020-10-16T19:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYwODcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYxMjIxOA==", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506612218", "bodyText": "Why you use 2 arguments if you read the first argument value from the second argument value?\nPS Other service calls have the same issue with flowId arguments.", "author": "surabujin", "createdAt": "2020-10-16T17:14:40Z", "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/OperationQueueBolt.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.bolts;\n+\n+import static org.openkilda.wfm.topology.utils.KafkaRecordTranslator.FIELD_ID_KEY;\n+import static org.openkilda.wfm.topology.utils.KafkaRecordTranslator.FIELD_ID_PAYLOAD;\n+\n+import org.openkilda.messaging.MessageData;\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.command.CommandMessage;\n+import org.openkilda.messaging.command.flow.FlowPathSwapRequest;\n+import org.openkilda.messaging.command.flow.FlowRerouteRequest;\n+import org.openkilda.messaging.info.reroute.PathSwapResult;\n+import org.openkilda.messaging.info.reroute.RerouteResultInfoData;\n+import org.openkilda.wfm.CommandContext;\n+import org.openkilda.wfm.error.PipelineException;\n+import org.openkilda.wfm.share.hubandspoke.CoordinatedBolt;\n+import org.openkilda.wfm.topology.reroute.service.OperationQueueService;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.storm.topology.OutputFieldsDeclarer;\n+import org.apache.storm.tuple.Fields;\n+import org.apache.storm.tuple.Tuple;\n+import org.apache.storm.tuple.Values;\n+\n+@Slf4j\n+public class OperationQueueBolt extends CoordinatedBolt implements OperationQueueCarrier {\n+    public static final String BOLT_ID = \"operation-queue\";\n+\n+    public static final String FLOW_ID_FIELD = RerouteBolt.FLOW_ID_FIELD;\n+\n+    public static final String REROUTE_QUEUE_STREAM = \"reroute-queue-stream\";\n+    public static final Fields REROUTE_QUEUE_FIELDS = new Fields(FLOW_ID_FIELD, FIELD_ID_PAYLOAD, FIELD_ID_CONTEXT);\n+\n+    public static final Fields FLOW_HS_FIELDS = new Fields(FIELD_ID_KEY, FIELD_ID_PAYLOAD);\n+\n+    private transient OperationQueueService service;\n+\n+    public OperationQueueBolt(int defaultTimeout) {\n+        super(true, defaultTimeout);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected void init() {\n+        this.service = new OperationQueueService(this);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected void handleInput(Tuple tuple) throws PipelineException {\n+        CommandContext context = pullContext(tuple);\n+        MessageData data = pullValue(tuple, FIELD_ID_PAYLOAD, MessageData.class);\n+        if (data instanceof FlowPathSwapRequest) {\n+            FlowPathSwapRequest flowPathSwapRequest = (FlowPathSwapRequest) data;\n+            service.addFirst(flowPathSwapRequest.getFlowId(), context.getCorrelationId(), flowPathSwapRequest);\n+        } else if (data instanceof FlowRerouteRequest) {\n+            FlowRerouteRequest flowRerouteRequest = (FlowRerouteRequest) data;\n+            service.addLast(flowRerouteRequest.getFlowId(), context.getCorrelationId(), flowRerouteRequest);\n+        } else if (data instanceof RerouteResultInfoData) {\n+            RerouteResultInfoData rerouteResultInfoData = (RerouteResultInfoData) data;\n+            service.operationCompleted(rerouteResultInfoData.getFlowId(), rerouteResultInfoData);", "originalCommit": "3315800259b82775cc21a509656551945c906cec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NzM5OA==", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506677398", "bodyText": "We cannot get flowId from the second argument in the method itself, because the methods require InfoData or CommandData, which do not contain this field.", "author": "dpoltavets", "createdAt": "2020-10-16T19:21:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYxMjIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYxODE3Mw==", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506618173", "bodyText": "newContext ... looks extremely weird. Can we have just context? Or just redefine correlationId, while we don't need context itself.", "author": "surabujin", "createdAt": "2020-10-16T17:25:20Z", "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/RerouteBolt.java", "diffHunk": "@@ -158,29 +163,25 @@ public void emitManualRerouteCommand(String flowId, FlowThrottlingData flowThrot\n      * Emit swap command for consumer.\n      *\n      * @param correlationId correlation id to pass through\n-     * @param path affected paths\n-     * @param reason initial reason of reroute\n+     * @param flowId flow\n+     * @param reason initial reason of path swap\n      */\n     @Override\n-    public void emitPathSwapCommand(String correlationId, FlowPath path, String reason) {\n-        FlowPathSwapRequest request = new FlowPathSwapRequest(path.getFlow().getFlowId(), path.getPathId());\n-        getOutput().emit(STREAM_SWAP_ID, getCurrentTuple(), new Values(correlationId,\n-                new CommandMessage(request, System.currentTimeMillis(), correlationId)));\n+    public void emitPathSwapCommand(String correlationId, String flowId, String reason) {\n+        CommandContext newContext = new CommandContext(correlationId).fork(UUID.randomUUID().toString());", "originalCommit": "3315800259b82775cc21a509656551945c906cec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NTI1Nw==", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506675257", "bodyText": "Renamed to context.", "author": "dpoltavets", "createdAt": "2020-10-16T19:17:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYxODE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyMTQzMw==", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506621433", "bodyText": "Why warn? Ther is normal to have no such records due to race condition on timeout remove request.", "author": "surabujin", "createdAt": "2020-10-16T17:31:10Z", "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/service/OperationQueueService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.service;\n+\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.info.InfoData;\n+import org.openkilda.wfm.topology.reroute.bolts.OperationQueueCarrier;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class OperationQueueService {\n+    private final OperationQueueCarrier carrier;\n+\n+    private final Map<String, FlowQueueData> flowCommands = new HashMap<>();\n+\n+    public OperationQueueService(OperationQueueCarrier carrier) {\n+        this.carrier = carrier;\n+    }\n+\n+    /**\n+     * Add command to the front of the queue.\n+     */\n+    public void addFirst(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addFirst(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Add command to the end of the queue.\n+     */\n+    public void addLast(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addLast(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Handle timeout.\n+     */\n+    public void handleTimeout(String correlationId) {\n+        log.warn(\"Operation with correlationId {} has timed out\", correlationId);\n+        Collection<FlowQueueData> foundQueueData = flowCommands.values().stream()\n+                .filter(flowQueueData -> correlationId.equals(flowQueueData.getTaskInProgress()))\n+                .collect(Collectors.toList());\n+\n+        if (foundQueueData.isEmpty()) {\n+            log.warn(\"No queue data with correlationId {} found. Timeout event skipped.\", correlationId);", "originalCommit": "3315800259b82775cc21a509656551945c906cec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NTAwOA==", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506675008", "bodyText": "Fixed.", "author": "dpoltavets", "createdAt": "2020-10-16T19:16:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyMTQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyNzUxMw==", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506627513", "bodyText": "Have we ever clean up this map? This approach creates a memory leak that can be triggered/used via NB API (you need to produce reroute requests for not existing/unique flowId... endlessly).", "author": "surabujin", "createdAt": "2020-10-16T17:40:57Z", "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/service/OperationQueueService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.service;\n+\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.info.InfoData;\n+import org.openkilda.wfm.topology.reroute.bolts.OperationQueueCarrier;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class OperationQueueService {\n+    private final OperationQueueCarrier carrier;\n+\n+    private final Map<String, FlowQueueData> flowCommands = new HashMap<>();\n+\n+    public OperationQueueService(OperationQueueCarrier carrier) {\n+        this.carrier = carrier;\n+    }\n+\n+    /**\n+     * Add command to the front of the queue.\n+     */\n+    public void addFirst(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addFirst(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Add command to the end of the queue.\n+     */\n+    public void addLast(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addLast(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Handle timeout.\n+     */\n+    public void handleTimeout(String correlationId) {\n+        log.warn(\"Operation with correlationId {} has timed out\", correlationId);\n+        Collection<FlowQueueData> foundQueueData = flowCommands.values().stream()\n+                .filter(flowQueueData -> correlationId.equals(flowQueueData.getTaskInProgress()))\n+                .collect(Collectors.toList());\n+\n+        if (foundQueueData.isEmpty()) {\n+            log.warn(\"No queue data with correlationId {} found. Timeout event skipped.\", correlationId);\n+        } else if (foundQueueData.size() > 1) {\n+            log.error(\"Found more than one queue data with correlationId {}. Timed out all of them.\", correlationId);\n+        }\n+\n+        foundQueueData.forEach(queueData -> operationCompleted(queueData, null));\n+    }\n+\n+    public void operationCompleted(String flowId, InfoData response) {\n+        operationCompleted(getFlowQueueData(flowId), response);\n+    }\n+\n+    private void operationCompleted(FlowQueueData queueData, InfoData response) {\n+        log.info(\"Flow command {} has been completed with response {}\", queueData.getTaskInProgress(), response);\n+        queueData.setTaskInProgress(null);\n+        processQueue(queueData);\n+    }\n+\n+    private void processQueue(FlowQueueData queueData) {\n+        if (!queueData.getQueue().isEmpty() && !queueData.isOperationInProgress()) {\n+            OperationData operationData = queueData.getQueue().pop();\n+            carrier.emitRequest(operationData.getCorrelationId(), operationData.getCommandData());\n+            queueData.setTaskInProgress(operationData.getCorrelationId());\n+            log.info(\"Flow command {} has been sent\", operationData.getCommandData());\n+        }\n+    }\n+\n+    private FlowQueueData getFlowQueueData(String flowId) {\n+        return flowCommands.computeIfAbsent(flowId, v -> new FlowQueueData());", "originalCommit": "3315800259b82775cc21a509656551945c906cec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NDkzNA==", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506674934", "bodyText": "Good point! Clean up has been added.", "author": "dpoltavets", "createdAt": "2020-10-16T19:16:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyNzUxMw=="}], "type": "inlineReview"}, {"oid": "66add84650acbdfcdd2a20f1d29391d9547e685c", "url": "https://github.com/telstra/open-kilda/commit/66add84650acbdfcdd2a20f1d29391d9547e685c", "message": "Added an operations queue to the Reroute topology.\n\nSince the swap paths operation is not blocked by the 'in_progress' flow status, during a network breakdown, these flows may not process correctly. This fix orders swap paths requests and reroute requests for protected flows.", "committedDate": "2020-10-16T19:13:50Z", "type": "forcePushed"}, {"oid": "5fedd9de46b17e56e5efc361e78f3336ce367648", "url": "https://github.com/telstra/open-kilda/commit/5fedd9de46b17e56e5efc361e78f3336ce367648", "message": "Added an operations queue to the Reroute topology.\n\nSince the swap paths operation is not blocked by the 'in_progress' flow status, during a network breakdown, these flows may not process correctly. This fix orders swap paths requests and reroute requests for protected flows.", "committedDate": "2020-10-19T05:15:51Z", "type": "commit"}, {"oid": "5fedd9de46b17e56e5efc361e78f3336ce367648", "url": "https://github.com/telstra/open-kilda/commit/5fedd9de46b17e56e5efc361e78f3336ce367648", "message": "Added an operations queue to the Reroute topology.\n\nSince the swap paths operation is not blocked by the 'in_progress' flow status, during a network breakdown, these flows may not process correctly. This fix orders swap paths requests and reroute requests for protected flows.", "committedDate": "2020-10-19T05:15:51Z", "type": "forcePushed"}]}