{"pr_number": 3538, "pr_title": "Server42 Part 3 Storm Control Topology", "pr_createdAt": "2020-06-11T17:17:23Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3538", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI2NTU5Mg==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r440265592", "bodyText": "Perhaps we can move this \"mapping\" inside mapping class/utility and produce it with mapstruct?", "author": "surabujin", "createdAt": "2020-06-15T15:36:26Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/bolts/FlowUpdateHubBolt.java", "diffHunk": "@@ -112,6 +119,43 @@ public void sendPeriodicPingNotification(String flowId, boolean enabled) {\n         emitWithContext(Stream.HUB_TO_PING_SENDER.name(), getCurrentTuple(), new Values(currentKey, message));\n     }\n \n+    @Override\n+    public void sendActivateFlowMonitoring(RequestedFlow flow) {\n+        //TODO(nmarchenko) move that to some util method to avoid duplicate with create\n+        FlowEndpointPayload src = FlowEndpointPayload.builder()", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1NTI4Nw==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445055287", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:27:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI2NTU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI2NjU4NA==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r440266584", "bodyText": "you don't trust to .equals(...) method?", "author": "surabujin", "createdAt": "2020-06-15T15:37:54Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/create/action/OnFinishedAction.java", "diffHunk": "@@ -38,6 +38,9 @@ public void perform(State from, State to, Event event, FlowCreateContext context\n         RequestedFlow requestedFlow = stateMachine.getTargetFlow();\n         stateMachine.getCarrier().sendPeriodicPingNotification(requestedFlow.getFlowId(),\n                 requestedFlow.isPeriodicPings());\n+        if (requestedFlow.getSrcSwitch().toLong() != requestedFlow.getDestSwitch().toLong()) {", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1ODgzNw==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445058837", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:33:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI2NjU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NTU2Mg==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r440675562", "bodyText": "return featureTogglesRepository.find()\n                .map(FeatureToggles::getServer42FlowRtt)\n                .orElse(FeatureToggles.DEFAULTS.getServer42FlowRtt());\n\nWhy not?\nIt will allow us to keep all default values in a single place and change them at any time without worries that some places use hardcoded default values.", "author": "surabujin", "createdAt": "2020-06-16T08:26:40Z", "path": "src-java/server42/server42-control-storm-topology/src/main/java/org/openkilda/server42/control/topology/service/FlowRttService.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+\n+package org.openkilda.server42.control.topology.service;\n+\n+import org.openkilda.model.FeatureToggles;\n+import org.openkilda.model.Flow;\n+import org.openkilda.model.SwitchId;\n+import org.openkilda.model.SwitchProperties;\n+import org.openkilda.persistence.PersistenceManager;\n+import org.openkilda.persistence.repositories.FeatureTogglesRepository;\n+import org.openkilda.persistence.repositories.FlowRepository;\n+import org.openkilda.persistence.repositories.RepositoryFactory;\n+import org.openkilda.persistence.repositories.SwitchPropertiesRepository;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class FlowRttService {\n+\n+    private final IFlowCarrier carrier;\n+    private final FeatureTogglesRepository featureTogglesRepository;\n+    private final SwitchPropertiesRepository switchPropertiesRepository;\n+    private final FlowRepository flowRepository;\n+\n+    public FlowRttService(IFlowCarrier carrier, PersistenceManager persistenceManager) {\n+        this.carrier = carrier;\n+        RepositoryFactory repositoryFactory = persistenceManager.getRepositoryFactory();\n+        switchPropertiesRepository = repositoryFactory.createSwitchPropertiesRepository();\n+        featureTogglesRepository = repositoryFactory.createFeatureTogglesRepository();\n+        flowRepository = repositoryFactory.createFlowRepository();\n+    }\n+\n+    /**\n+     * Check if rtt global feature enabled and rtt enabled for switch then ask carrier to activate flow.\n+     *\n+     * @param flowId flow id\n+     * @param port switch customer port\n+     * @param vlan switch customer vlan id\n+     * @param isForward is endpoint forward\n+     */\n+    public void activateFlowMonitoring(String flowId, SwitchId switchId, Integer port, Integer vlan,\n+                                       boolean isForward) {\n+        if (isFlowRttFeatureToggle() && isFlowRttFeatureEnabledFor(switchId)) {\n+            carrier.notifyActivateFlowMonitoring(flowId, switchId, port, vlan, isForward);\n+        } else {\n+            log.info(\"skip activation of flow RTT for flow: {} and switch:{}\", flowId, switchId);\n+        }\n+    }\n+\n+    /**\n+     * Activate monitoring for all existed flows on provided switch.\n+     * @param switchId switch id\n+     */\n+    public void activateFlowMonitoringForSwitch(SwitchId switchId) {\n+        Map<Boolean, List<Flow>> flowByDirection =\n+                flowRepository.findByEndpointSwitch(switchId).stream().collect(Collectors.partitioningBy(\n+                        f -> f.getSrcSwitch().getSwitchId().toLong() == switchId.toLong()));\n+\n+        flowByDirection.get(true).forEach(flow -> carrier.notifyActivateFlowMonitoring(flow.getFlowId(),\n+                switchId, flow.getSrcPort(), flow.getSrcVlan(), true\n+        ));\n+\n+        flowByDirection.get(false).forEach(flow -> carrier.notifyActivateFlowMonitoring(flow.getFlowId(),\n+                switchId, flow.getDestPort(), flow.getDestVlan(), false\n+        ));\n+    }\n+\n+    private boolean isFlowRttFeatureToggle() {\n+        return featureTogglesRepository.find().map(FeatureToggles::getServer42FlowRtt).orElse(false);", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1OTMyMw==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445059323", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NTU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3OTA0OQ==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r440679049", "bodyText": "Should we filter out one-switch flows here?", "author": "surabujin", "createdAt": "2020-06-16T08:32:10Z", "path": "src-java/server42/server42-control-storm-topology/src/main/java/org/openkilda/server42/control/topology/service/FlowRttService.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+\n+package org.openkilda.server42.control.topology.service;\n+\n+import org.openkilda.model.FeatureToggles;\n+import org.openkilda.model.Flow;\n+import org.openkilda.model.SwitchId;\n+import org.openkilda.model.SwitchProperties;\n+import org.openkilda.persistence.PersistenceManager;\n+import org.openkilda.persistence.repositories.FeatureTogglesRepository;\n+import org.openkilda.persistence.repositories.FlowRepository;\n+import org.openkilda.persistence.repositories.RepositoryFactory;\n+import org.openkilda.persistence.repositories.SwitchPropertiesRepository;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class FlowRttService {\n+\n+    private final IFlowCarrier carrier;\n+    private final FeatureTogglesRepository featureTogglesRepository;\n+    private final SwitchPropertiesRepository switchPropertiesRepository;\n+    private final FlowRepository flowRepository;\n+\n+    public FlowRttService(IFlowCarrier carrier, PersistenceManager persistenceManager) {\n+        this.carrier = carrier;\n+        RepositoryFactory repositoryFactory = persistenceManager.getRepositoryFactory();\n+        switchPropertiesRepository = repositoryFactory.createSwitchPropertiesRepository();\n+        featureTogglesRepository = repositoryFactory.createFeatureTogglesRepository();\n+        flowRepository = repositoryFactory.createFlowRepository();\n+    }\n+\n+    /**\n+     * Check if rtt global feature enabled and rtt enabled for switch then ask carrier to activate flow.\n+     *\n+     * @param flowId flow id\n+     * @param port switch customer port\n+     * @param vlan switch customer vlan id\n+     * @param isForward is endpoint forward\n+     */\n+    public void activateFlowMonitoring(String flowId, SwitchId switchId, Integer port, Integer vlan,\n+                                       boolean isForward) {\n+        if (isFlowRttFeatureToggle() && isFlowRttFeatureEnabledFor(switchId)) {\n+            carrier.notifyActivateFlowMonitoring(flowId, switchId, port, vlan, isForward);\n+        } else {\n+            log.info(\"skip activation of flow RTT for flow: {} and switch:{}\", flowId, switchId);\n+        }\n+    }\n+\n+    /**\n+     * Activate monitoring for all existed flows on provided switch.\n+     * @param switchId switch id\n+     */\n+    public void activateFlowMonitoringForSwitch(SwitchId switchId) {\n+        Map<Boolean, List<Flow>> flowByDirection =\n+                flowRepository.findByEndpointSwitch(switchId).stream().collect(Collectors.partitioningBy(", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2MTUyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445061525", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:38:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3OTA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4Mjc3OQ==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r440682779", "bodyText": "Possible NPE here - chances are low but still exists. If there is a \"corrupter\" flow in DB with only 1 path in one direction - and there is only one such flow for this switch - NPE will arrive here (and for reverse/false side too).", "author": "surabujin", "createdAt": "2020-06-16T08:38:01Z", "path": "src-java/server42/server42-control-storm-topology/src/main/java/org/openkilda/server42/control/topology/service/FlowRttService.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+\n+package org.openkilda.server42.control.topology.service;\n+\n+import org.openkilda.model.FeatureToggles;\n+import org.openkilda.model.Flow;\n+import org.openkilda.model.SwitchId;\n+import org.openkilda.model.SwitchProperties;\n+import org.openkilda.persistence.PersistenceManager;\n+import org.openkilda.persistence.repositories.FeatureTogglesRepository;\n+import org.openkilda.persistence.repositories.FlowRepository;\n+import org.openkilda.persistence.repositories.RepositoryFactory;\n+import org.openkilda.persistence.repositories.SwitchPropertiesRepository;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class FlowRttService {\n+\n+    private final IFlowCarrier carrier;\n+    private final FeatureTogglesRepository featureTogglesRepository;\n+    private final SwitchPropertiesRepository switchPropertiesRepository;\n+    private final FlowRepository flowRepository;\n+\n+    public FlowRttService(IFlowCarrier carrier, PersistenceManager persistenceManager) {\n+        this.carrier = carrier;\n+        RepositoryFactory repositoryFactory = persistenceManager.getRepositoryFactory();\n+        switchPropertiesRepository = repositoryFactory.createSwitchPropertiesRepository();\n+        featureTogglesRepository = repositoryFactory.createFeatureTogglesRepository();\n+        flowRepository = repositoryFactory.createFlowRepository();\n+    }\n+\n+    /**\n+     * Check if rtt global feature enabled and rtt enabled for switch then ask carrier to activate flow.\n+     *\n+     * @param flowId flow id\n+     * @param port switch customer port\n+     * @param vlan switch customer vlan id\n+     * @param isForward is endpoint forward\n+     */\n+    public void activateFlowMonitoring(String flowId, SwitchId switchId, Integer port, Integer vlan,\n+                                       boolean isForward) {\n+        if (isFlowRttFeatureToggle() && isFlowRttFeatureEnabledFor(switchId)) {\n+            carrier.notifyActivateFlowMonitoring(flowId, switchId, port, vlan, isForward);\n+        } else {\n+            log.info(\"skip activation of flow RTT for flow: {} and switch:{}\", flowId, switchId);\n+        }\n+    }\n+\n+    /**\n+     * Activate monitoring for all existed flows on provided switch.\n+     * @param switchId switch id\n+     */\n+    public void activateFlowMonitoringForSwitch(SwitchId switchId) {\n+        Map<Boolean, List<Flow>> flowByDirection =\n+                flowRepository.findByEndpointSwitch(switchId).stream().collect(Collectors.partitioningBy(\n+                        f -> f.getSrcSwitch().getSwitchId().toLong() == switchId.toLong()));\n+\n+        flowByDirection.get(true).forEach(flow -> carrier.notifyActivateFlowMonitoring(flow.getFlowId(),", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2MjYwOA==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445062608", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4Mjc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY5MjAxMA==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r440692010", "bodyText": "Abstract bolt already does this (with the only difference - it will add \"Unhandled exception prefix\" to the log message).", "author": "surabujin", "createdAt": "2020-06-16T08:52:16Z", "path": "src-java/server42/server42-control-storm-topology/src/main/java/org/openkilda/server42/control/topology/storm/bolt/flow/FlowHandler.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.server42.control.topology.storm.bolt.flow;\n+\n+import org.openkilda.messaging.payload.flow.FlowEndpointPayload;\n+import org.openkilda.model.SwitchId;\n+import org.openkilda.persistence.PersistenceManager;\n+import org.openkilda.server42.control.messaging.flowrtt.AddFlow;\n+import org.openkilda.server42.control.messaging.flowrtt.ClearFlows;\n+import org.openkilda.server42.control.messaging.flowrtt.Headers;\n+import org.openkilda.server42.control.messaging.flowrtt.RemoveFlow;\n+import org.openkilda.server42.control.topology.service.FlowRttService;\n+import org.openkilda.server42.control.topology.service.IFlowCarrier;\n+import org.openkilda.server42.control.topology.storm.ComponentId;\n+import org.openkilda.server42.control.topology.storm.bolt.flow.command.FlowCommand;\n+import org.openkilda.server42.control.topology.storm.bolt.router.Router;\n+import org.openkilda.server42.messaging.FlowDirection;\n+import org.openkilda.wfm.AbstractBolt;\n+import org.openkilda.wfm.error.PipelineException;\n+\n+import org.apache.storm.kafka.bolt.mapper.FieldNameBasedTupleToKafkaMapper;\n+import org.apache.storm.topology.OutputFieldsDeclarer;\n+import org.apache.storm.tuple.Fields;\n+import org.apache.storm.tuple.Tuple;\n+import org.apache.storm.tuple.Values;\n+\n+public class FlowHandler extends AbstractBolt\n+        implements IFlowCarrier {\n+\n+    public static final String BOLT_ID = ComponentId.FLOW_HANDLER.toString();\n+\n+    public static final String STREAM_CONTROL_COMMANDS_ID = \"control.commands\";\n+    public static final Fields STREAM_CONTROL_COMMANDS_FIELDS = new Fields(FieldNameBasedTupleToKafkaMapper.BOLT_KEY,\n+            FieldNameBasedTupleToKafkaMapper.BOLT_MESSAGE);\n+    private final PersistenceManager persistenceManager;\n+    private transient FlowRttService flowRttService;\n+\n+    public FlowHandler(PersistenceManager persistenceManager) {\n+        this.persistenceManager = persistenceManager;\n+    }\n+\n+    protected void init() {\n+        this.flowRttService = new FlowRttService(this, persistenceManager);\n+    }\n+\n+    @Override\n+    protected void handleInput(Tuple input) throws Exception {\n+        String source = input.getSourceComponent();\n+        if (Router.BOLT_ID.equals(source)) {\n+            handleRouterCommand(input);\n+        } else {\n+            unhandledInput(input);\n+        }\n+    }\n+\n+    @Override\n+    protected void handleException(Exception error) throws Exception {", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA0NDIyMw==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445044223", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:07:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY5MjAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY5NDY1OQ==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r440694659", "bodyText": "Why there is no headers(correlation-id) here?", "author": "surabujin", "createdAt": "2020-06-16T08:56:22Z", "path": "src-java/server42/server42-control-storm-topology/src/main/java/org/openkilda/server42/control/topology/storm/bolt/flow/FlowHandler.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.server42.control.topology.storm.bolt.flow;\n+\n+import org.openkilda.messaging.payload.flow.FlowEndpointPayload;\n+import org.openkilda.model.SwitchId;\n+import org.openkilda.persistence.PersistenceManager;\n+import org.openkilda.server42.control.messaging.flowrtt.AddFlow;\n+import org.openkilda.server42.control.messaging.flowrtt.ClearFlows;\n+import org.openkilda.server42.control.messaging.flowrtt.Headers;\n+import org.openkilda.server42.control.messaging.flowrtt.RemoveFlow;\n+import org.openkilda.server42.control.topology.service.FlowRttService;\n+import org.openkilda.server42.control.topology.service.IFlowCarrier;\n+import org.openkilda.server42.control.topology.storm.ComponentId;\n+import org.openkilda.server42.control.topology.storm.bolt.flow.command.FlowCommand;\n+import org.openkilda.server42.control.topology.storm.bolt.router.Router;\n+import org.openkilda.server42.messaging.FlowDirection;\n+import org.openkilda.wfm.AbstractBolt;\n+import org.openkilda.wfm.error.PipelineException;\n+\n+import org.apache.storm.kafka.bolt.mapper.FieldNameBasedTupleToKafkaMapper;\n+import org.apache.storm.topology.OutputFieldsDeclarer;\n+import org.apache.storm.tuple.Fields;\n+import org.apache.storm.tuple.Tuple;\n+import org.apache.storm.tuple.Values;\n+\n+public class FlowHandler extends AbstractBolt\n+        implements IFlowCarrier {\n+\n+    public static final String BOLT_ID = ComponentId.FLOW_HANDLER.toString();\n+\n+    public static final String STREAM_CONTROL_COMMANDS_ID = \"control.commands\";\n+    public static final Fields STREAM_CONTROL_COMMANDS_FIELDS = new Fields(FieldNameBasedTupleToKafkaMapper.BOLT_KEY,\n+            FieldNameBasedTupleToKafkaMapper.BOLT_MESSAGE);\n+    private final PersistenceManager persistenceManager;\n+    private transient FlowRttService flowRttService;\n+\n+    public FlowHandler(PersistenceManager persistenceManager) {\n+        this.persistenceManager = persistenceManager;\n+    }\n+\n+    protected void init() {\n+        this.flowRttService = new FlowRttService(this, persistenceManager);\n+    }\n+\n+    @Override\n+    protected void handleInput(Tuple input) throws Exception {\n+        String source = input.getSourceComponent();\n+        if (Router.BOLT_ID.equals(source)) {\n+            handleRouterCommand(input);\n+        } else {\n+            unhandledInput(input);\n+        }\n+    }\n+\n+    @Override\n+    protected void handleException(Exception error) throws Exception {\n+        try {\n+            super.handleException(error);\n+        } catch (Exception e) {\n+            log.error(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override\n+    public void declareOutputFields(OutputFieldsDeclarer outputFieldsDeclarer) {\n+        outputFieldsDeclarer.declareStream(STREAM_CONTROL_COMMANDS_ID, STREAM_CONTROL_COMMANDS_FIELDS);\n+    }\n+\n+    private void handleRouterCommand(Tuple input) throws PipelineException {\n+        handleCommand(input, Router.FIELD_ID_COMMAND);\n+    }\n+\n+    private void handleCommand(Tuple input, String fieldName) throws PipelineException {\n+        FlowCommand command = pullValue(input, fieldName, FlowCommand.class);\n+        command.apply(this);\n+    }\n+\n+    public void processActivateFlowMonitoring(String flowId, FlowEndpointPayload flow, boolean isForward) {\n+        flowRttService.activateFlowMonitoring(flowId, flow.getDatapath(), flow.getPortNumber(),\n+                flow.getVlanId(), isForward);\n+    }\n+\n+    public void processDeactivateFlowMonitoring(SwitchId switchId, String flowId) {\n+        // no logic just repack\n+        notifyDeactivateFlowMonitoring(switchId, flowId);\n+    }\n+\n+    public void processActivateFlowMonitoringOnSwitch(SwitchId switchId) {\n+        flowRttService.activateFlowMonitoringForSwitch(switchId);\n+    }\n+\n+    public void processDeactivateFlowMonitoringOnSwitch(SwitchId switchId) {\n+        // no logic just repack\n+        notifyDeactivateFlowMonitoring(switchId);\n+    }\n+\n+    @Override\n+    public void notifyActivateFlowMonitoring(String flowId, SwitchId switchId, Integer port, Integer vlan,\n+                                             boolean isForward) {\n+        AddFlow addFlow = AddFlow.builder()\n+                .flowId(flowId)\n+                .port(port)\n+                .tunnelId(vlan.longValue())\n+                .direction(isForward ? FlowDirection.FORWARD : FlowDirection.REVERSE)\n+                .headers(buildHeader())\n+                .build();\n+\n+        emit(STREAM_CONTROL_COMMANDS_ID, getCurrentTuple(), new Values(switchId.toString(), addFlow));\n+    }\n+\n+    @Override\n+    public void notifyDeactivateFlowMonitoring(SwitchId switchId, String flowId) {\n+        RemoveFlow removeFlow = RemoveFlow.builder()\n+                .flowId(flowId)\n+                .headers(buildHeader())\n+                .build();\n+        emit(STREAM_CONTROL_COMMANDS_ID, getCurrentTuple(), new Values(switchId.toString(), removeFlow));\n+    }\n+\n+    private void notifyDeactivateFlowMonitoring(SwitchId switchId) {\n+        ClearFlows clearFlows = new ClearFlows();", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2MDY3Nw==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445060677", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY5NDY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYxMzIyMg==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r443613222", "bodyText": "2020", "author": "rozdy", "createdAt": "2020-06-22T14:45:47Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/kafka/ObjectSerializer.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/* Copyright 2019 Telstra Open Source", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2MzAwNQ==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445063005", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYxMzIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE1NzYzNg==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r444157636", "bodyText": "Why can't we make KafkaEncoder not abstract? Can we get rid of this class?", "author": "rozdy", "createdAt": "2020-06-23T11:38:33Z", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/bolts/Server42EncoderBolt.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.nbworker.bolts;\n+\n+import org.openkilda.wfm.share.bolt.KafkaEncoder;\n+\n+public class Server42EncoderBolt extends KafkaEncoder {", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2NDAwMQ==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445064001", "bodyText": "we will reimplement the entire messaging system after we move to the next Kafka client.", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE1NzYzNg=="}], "type": "inlineReview"}, {"oid": "c9534318ef7cd137e98ca5bfb387d9a407712ef5", "url": "https://github.com/telstra/open-kilda/commit/c9534318ef7cd137e98ca5bfb387d9a407712ef5", "message": "Server42 Part 3 Storm Control Topology", "committedDate": "2020-06-29T17:20:21Z", "type": "forcePushed"}, {"oid": "2ea326ca00cd4d5ebce06dc5303f22de2a192f20", "url": "https://github.com/telstra/open-kilda/commit/2ea326ca00cd4d5ebce06dc5303f22de2a192f20", "message": "Server42 Part 3 Storm Control Topology", "committedDate": "2020-07-03T06:43:50Z", "type": "forcePushed"}, {"oid": "aad37ce69ebc40d569c8f918c206e9dfae43ff00", "url": "https://github.com/telstra/open-kilda/commit/aad37ce69ebc40d569c8f918c206e9dfae43ff00", "message": "Server42 Part 3 Storm Control Topology", "committedDate": "2020-07-03T06:53:37Z", "type": "forcePushed"}, {"oid": "4c2ced8230250ad464b435fdaf3c59097b43db8b", "url": "https://github.com/telstra/open-kilda/commit/4c2ced8230250ad464b435fdaf3c59097b43db8b", "message": "Server42 Part 3 Storm Control Topology", "committedDate": "2020-07-03T09:02:13Z", "type": "commit"}, {"oid": "4c2ced8230250ad464b435fdaf3c59097b43db8b", "url": "https://github.com/telstra/open-kilda/commit/4c2ced8230250ad464b435fdaf3c59097b43db8b", "message": "Server42 Part 3 Storm Control Topology", "committedDate": "2020-07-03T09:02:13Z", "type": "forcePushed"}]}