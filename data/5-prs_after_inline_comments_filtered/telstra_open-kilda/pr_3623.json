{"pr_number": 3623, "pr_title": "Simultaneous switch availability in multimple regions", "pr_createdAt": "2020-07-10T14:01:44Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3623", "timeline": [{"oid": "a213912cf06b17ba0808710c961546f1fb72eb0c", "url": "https://github.com/telstra/open-kilda/commit/a213912cf06b17ba0808710c961546f1fb72eb0c", "message": "Support for multiple simultaneousswitch to controller connections\n\nFloodlightRouter topology monitor switch connections to the speakers. It\nthack \"active\" connection/region accordnig to the data reported from\nspeaker (connection/disconnect events) and to the region alive status\nproduced by floodlightrouter itself.\n\nSo requests will be routed into active region. This region tracked on\nper switch level i.e. each switch have own active region. Active region\nchanged only on switch disconnect event (for this region) or on region\ndisconnect/unavailability.", "committedDate": "2020-07-20T07:42:38Z", "type": "forcePushed"}, {"oid": "a4283e121836df48f808812db1122cdc689af0de", "url": "https://github.com/telstra/open-kilda/commit/a4283e121836df48f808812db1122cdc689af0de", "message": "Support for multiple simultaneousswitch to controller connections\n\nFloodlightRouter topology monitor switch connections to the speakers. It\nthack \"active\" connection/region accordnig to the data reported from\nspeaker (connection/disconnect events) and to the region alive status\nproduced by floodlightrouter itself.\n\nSo requests will be routed into active region. This region tracked on\nper switch level i.e. each switch have own active region. Active region\nchanged only on switch disconnect event (for this region) or on region\ndisconnect/unavailability.", "committedDate": "2020-07-20T09:11:33Z", "type": "forcePushed"}, {"oid": "30f790a049a075f62eb513546bb3ffaa0d258be8", "url": "https://github.com/telstra/open-kilda/commit/30f790a049a075f62eb513546bb3ffaa0d258be8", "message": "Support for multiple simultaneousswitch to controller connections\n\nFloodlightRouter topology monitor switch connections to the speakers. It\nthack \"active\" connection/region accordnig to the data reported from\nspeaker (connection/disconnect events) and to the region alive status\nproduced by floodlightrouter itself.\n\nSo requests will be routed into active region. This region tracked on\nper switch level i.e. each switch have own active region. Active region\nchanged only on switch disconnect event (for this region) or on region\ndisconnect/unavailability.", "committedDate": "2020-07-29T08:43:25Z", "type": "forcePushed"}, {"oid": "c600f66fd6a4b0a1e022fcee495fbe9eb527ca8f", "url": "https://github.com/telstra/open-kilda/commit/c600f66fd6a4b0a1e022fcee495fbe9eb527ca8f", "message": "Support for multiple simultaneousswitch to controller connections\n\nFloodlightRouter topology monitor switch connections to the speakers. It\nthack \"active\" connection/region accordnig to the data reported from\nspeaker (connection/disconnect events) and to the region alive status\nproduced by floodlightrouter itself.\n\nSo requests will be routed into active region. This region tracked on\nper switch level i.e. each switch have own active region. Active region\nchanged only on switch disconnect event (for this region) or on region\ndisconnect/unavailability.", "committedDate": "2020-07-30T11:30:16Z", "type": "forcePushed"}, {"oid": "d117bb0fda486ea31d2c22b56ac26ce974ac9a49", "url": "https://github.com/telstra/open-kilda/commit/d117bb0fda486ea31d2c22b56ac26ce974ac9a49", "message": "Support for multiple simultaneousswitch to controller connections\n\nFloodlightRouter topology monitor switch connections to the speakers. It\nthack \"active\" connection/region accordnig to the data reported from\nspeaker (connection/disconnect events) and to the region alive status\nproduced by floodlightrouter itself.\n\nSo requests will be routed into active region. This region tracked on\nper switch level i.e. each switch have own active region. Active region\nchanged only on switch disconnect event (for this region) or on region\ndisconnect/unavailability.", "committedDate": "2020-07-30T12:14:24Z", "type": "forcePushed"}, {"oid": "2dfa8f7b0bd223abc40b8c113a0d42b36b450862", "url": "https://github.com/telstra/open-kilda/commit/2dfa8f7b0bd223abc40b8c113a0d42b36b450862", "message": "Support for multiple simultaneousswitch to controller connections\n\nFloodlightRouter topology monitor switch connections to the speakers. It\nthack \"active\" connection/region accordnig to the data reported from\nspeaker (connection/disconnect events) and to the region alive status\nproduced by floodlightrouter itself.\n\nSo requests will be routed into active region. This region tracked on\nper switch level i.e. each switch have own active region. Active region\nchanged only on switch disconnect event (for this region) or on region\ndisconnect/unavailability.", "committedDate": "2020-07-30T15:43:00Z", "type": "forcePushed"}, {"oid": "e43b2dd2d0cc486729cd3768876af3a24899c63c", "url": "https://github.com/telstra/open-kilda/commit/e43b2dd2d0cc486729cd3768876af3a24899c63c", "message": "Support for multiple simultaneousswitch to controller connections\n\nFloodlightRouter topology monitor switch connections to the speakers. It\nthack \"active\" connection/region accordnig to the data reported from\nspeaker (connection/disconnect events) and to the region alive status\nproduced by floodlightrouter itself.\n\nSo requests will be routed into active region. This region tracked on\nper switch level i.e. each switch have own active region. Active region\nchanged only on switch disconnect event (for this region) or on region\ndisconnect/unavailability.", "committedDate": "2020-07-31T06:15:17Z", "type": "forcePushed"}, {"oid": "0e61b76ca8093f27ca2b5d3d079cb1d993e5a6ce", "url": "https://github.com/telstra/open-kilda/commit/0e61b76ca8093f27ca2b5d3d079cb1d993e5a6ce", "message": "Support multiple simultaneous FL connections from a single switch\n\nFloodlightRouter topology monitor switch connections to the speakers. It\nthack \"active\" connection/region accordnig to the data reported from\nspeaker (connection/disconnect events) and to the region alive status\nproduced by floodlightrouter itself.\n\nSo requests will be routed into active region. This region tracked on\nper switch level i.e. each switch have own active region. Active region\nchanged only on switch disconnect event (for this region) or on region\ndisconnect/unavailability.", "committedDate": "2020-07-31T06:34:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMyNjk2Mw==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r464326963", "bodyText": "Closing bracket is missing", "author": "rozdy", "createdAt": "2020-08-03T10:24:07Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java", "diffHunk": "@@ -271,8 +269,22 @@ private void handleCommand(CommandMessage message) {\n             doRemoveIslDefaultRule(message);\n         } else if (data instanceof DumpGroupsRequest) {\n             doDumpGroupsRequest(message);\n+        } else if (data instanceof BroadcastWrapper) {\n+            handleBroadcastCommand(message, (BroadcastWrapper) data);\n         } else {\n-            logger.error(\"Unable to handle '{}' request - handler not found.\", data);\n+            handlerNotFound(data);\n+        }\n+    }\n+\n+    private void handleBroadcastCommand(CommandMessage message, BroadcastWrapper wrapper) {\n+        CommandData payload = wrapper.getPayload();\n+        if (payload instanceof PortsCommandData) {\n+            doPortsCommandDataRequest(wrapper.getScope(), (PortsCommandData) payload, message.getCorrelationId());\n+        } else if (payload instanceof ConnectModeRequest) {\n+            // FIXME(surabujin) - caller do not expect multiple responses(from multiple regions", "originalCommit": "0e61b76ca8093f27ca2b5d3d079cb1d993e5a6ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYwMDQ1Nw==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r465600457", "bodyText": "bracket added", "author": "surabujin", "createdAt": "2020-08-05T09:36:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMyNjk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzMTYwMw==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r464331603", "bodyText": "I don't like boolean readWriteMode. Either change to enum or rename to something like writeAllowedMode.", "author": "rozdy", "createdAt": "2020-08-03T10:34:28Z", "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/info/discovery/NetworkDumpSwitchData.java", "diffHunk": "@@ -38,9 +40,19 @@\n     @JsonProperty(value = \"switch_record\", required = true)\n     private SpeakerSwitchView switchView;\n \n+    @JsonProperty(\"read_write_mode\")\n+    private boolean readWriteMode;\n+\n     @JsonCreator\n     public NetworkDumpSwitchData(\n-            @JsonProperty(\"switch_record\") @NonNull SpeakerSwitchView switchView) {\n+            @JsonProperty(\"switch_record\") @NonNull SpeakerSwitchView switchView,\n+            @JsonProperty(\"read_write_mode\") boolean readWriteMode) {", "originalCommit": "0e61b76ca8093f27ca2b5d3d079cb1d993e5a6ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYwNjE0Ng==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r465606146", "bodyText": "if (switchEntry.isReadWriteMode()) {...} as for me is better than if (switchEntry.isWriteAllowedMode) {...}, I would like to keed it's current name. If it is strict requirement - let me know.\nPS read-only and read-write terms are widely used across the code of this feature, this is one more reason to keep the current name.", "author": "surabujin", "createdAt": "2020-08-05T09:46:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzMTYwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY1NzYxNQ==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r465657615", "bodyText": "Ok, now I get it ReadWrite is the name of the mode and it's true or false. First time reading it looks like true is write mode and false is read mode. Now I can't suggest better name for it.", "author": "rozdy", "createdAt": "2020-08-05T11:24:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzMTYwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk0ODQ5NA==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r466948494", "bodyText": "readWriteMode is very hard to understand, if the main focus in this pair of modes in write permissions, why not to call it writeMode of type boolean", "author": "timofei-durakov", "createdAt": "2020-08-07T10:08:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzMTYwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3NzgzOA==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r468377838", "bodyText": "Because it will differ from other parts of code that use readOnly and readWrite names.", "author": "surabujin", "createdAt": "2020-08-11T07:23:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzMTYwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM5MDYwOA==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r468390608", "bodyText": "and that's the thing as for me, we really can't have less permissions than read for the switch, and the only thing that should be checked is whether it allows to write or not. This approach blurs focus on what is really important here.", "author": "timofei-durakov", "createdAt": "2020-08-11T07:48:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzMTYwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ1MDYxNA==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r468450614", "bodyText": "My point is to use the same terms across code - floodlightrouter use 2 terms(as for now) to define/describe switch capabilities - it is read-write-mode and read-only-mode. That why I insist on the same term here.\nObvious another way - to use some enum to define these modes. The cost of this solution - more complex handling of these modes (need to track extra/unknown modes). This is a more correct way to solve this naming issue than new/other terminology.\nDo you insist on renaming?", "author": "surabujin", "createdAt": "2020-08-11T09:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzMTYwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ1MjI0OA==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r468452248", "bodyText": "yes, please do. I worry about losing context here in a months or so, thank you!", "author": "timofei-durakov", "createdAt": "2020-08-11T09:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzMTYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzNDYxMQ==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r464334611", "bodyText": "Consider renaming to \"switch mapping expire delay\".", "author": "rozdy", "createdAt": "2020-08-03T10:41:41Z", "path": "src-java/floodlightrouter-topology/floodlightrouter-storm-topology/src/main/java/org/openkilda/wfm/topology/floodlightrouter/FloodlightRouterTopologyConfig.java", "diffHunk": "@@ -43,4 +43,8 @@\n     @Default(\"1\")\n     @Converter(StringToSetConverter.class)\n     Set<String> getFloodlightRegions();\n+\n+    @Key(\"floodlight.switch.mapping.remove.delay.seconds\")\n+    @Default(\"900\")\n+    Long getSwitchMappingRemoveDelay();", "originalCommit": "0e61b76ca8093f27ca2b5d3d079cb1d993e5a6ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYwOTkyMw==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r465609923", "bodyText": "This is the delay before actual removal after the mapping removes request... so the current name should be more accurate... Again if you insist - let me know.", "author": "surabujin", "createdAt": "2020-08-05T09:53:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzNDYxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzODQ4Nw==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r464338487", "bodyText": "Why don't use pullValue here?", "author": "rozdy", "createdAt": "2020-08-03T10:50:34Z", "path": "src-java/floodlightrouter-topology/floodlightrouter-storm-topology/src/main/java/org/openkilda/wfm/topology/floodlightrouter/bolts/RegionTrackerBolt.java", "diffHunk": "@@ -150,79 +126,69 @@ private void handleTick() {\n         }\n     }\n \n-    private void handleInput(Tuple input) {\n-        String sourceComponent = input.getSourceComponent();\n-        Message message = (Message) input.getValueByField(AbstractTopology.MESSAGE_FIELD);\n+    private void handleNetworkNotification(Tuple input) {\n+        String stream = input.getSourceStreamId();\n+        if (SpeakerToNetworkProxyBolt.STREAM_ALIVE_EVIDENCE_ID.equals(stream)) {\n+            handleAliveEvidenceNotification(input);\n+        } else if (SpeakerToNetworkProxyBolt.STREAM_REGION_NOTIFICATION_ID.equals(stream)) {\n+            handleRegionNotification(input);\n+        } else {\n+            unhandledInput(input);\n+        }\n+    }\n \n-        // setup correct command context\n-        commandContext = new CommandContext(message);\n+    private void handleAliveEvidenceNotification(Tuple input) {\n+        String region = input.getStringByField(SpeakerToNetworkProxyBolt.FIELD_ID_REGION);\n+        long timestamp = input.getLongByField(SpeakerToNetworkProxyBolt.FIELD_ID_TIMESTAMP);\n \n-        switch (sourceComponent) {\n-            case ComponentType.KILDA_TOPO_DISCO_REPLY_BOLT:\n-                routerService.processSpeakerDiscoResponse(this, message);\n-                break;\n-            default:\n-                log.error(\"Unknown input stream handled: {}\", sourceComponent);\n-                break;\n-        }\n+        floodlightTracker.handleAliveEvidence(region, timestamp);\n     }\n \n-    private void setupTuple(Tuple input) {\n-        currentTuple = input;\n-        commandContext = new CommandContext();\n+    private void handleRegionNotification(Tuple input) {\n+        String region = input.getStringByField(SpeakerToNetworkProxyBolt.FIELD_ID_REGION);\n+        InfoData payload = (InfoData) input.getValueByField(SpeakerToNetworkProxyBolt.FIELD_ID_PAYLOAD);", "originalCommit": "0e61b76ca8093f27ca2b5d3d079cb1d993e5a6ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY4MTE4MQ==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r465681181", "bodyText": "Missed during refactoring. Replaced with pullValue provided by AbstractBolt.", "author": "surabujin", "createdAt": "2020-08-05T12:12:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzODQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM0MDU2Ng==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r464340566", "bodyText": "As I can see not only discovery notifications may be suppressed here.", "author": "rozdy", "createdAt": "2020-08-03T10:55:17Z", "path": "src-java/floodlightrouter-topology/floodlightrouter-storm-topology/src/main/java/org/openkilda/wfm/topology/floodlightrouter/bolts/SpeakerToControllerProxyBolt.java", "diffHunk": "@@ -41,8 +69,79 @@ protected void handleInput(Tuple input) throws Exception {\n         proxy(key, payload);\n     }\n \n-    protected void proxy(String key, Object payload) {\n-        getOutput().emit(getCurrentTuple(), makeDefaultTuple(key, payload));\n+    private void handleSwitchMappingUpdate(Tuple input) throws PipelineException {\n+        RegionMappingUpdate update = pullValue(input, SwitchMonitorBolt.FIELD_ID_PAYLOAD, RegionMappingUpdate.class);\n+        switchMapping.update(update);\n+    }\n+\n+    private void proxy(String key, Object value) {\n+        if (value instanceof InfoMessage) {\n+            proxyInfoMessage(key, (InfoMessage) value);\n+        } else {\n+            proxyOther(key, value);\n+        }\n+    }\n+\n+    protected void proxyInfoMessage(String key, InfoMessage envelope) {\n+        InfoData payload = envelope.getData();\n+        if (payload instanceof IslInfoData) {\n+            proxyOnlyIfActiveRegion(key, envelope, (IslInfoData) payload);\n+        } else if (payload instanceof PortInfoData) {\n+            proxyOnlyIfActiveRegion(key, envelope, (PortInfoData) payload);\n+        } else if (payload instanceof IslOneWayLatency) {\n+            proxyOnlyIfActiveRegion(key, envelope, (IslOneWayLatency) payload);\n+        } else if (payload instanceof IslBaseLatency) {\n+            proxyOnlyIfActiveRegion(key, envelope, (IslBaseLatency) payload);\n+        } else if (payload instanceof ConnectedDevicePacketBase) {\n+            proxyOnlyIfActiveRegion(key, envelope, (ConnectedDevicePacketBase) payload);\n+        } else {\n+            proxyOther(key, envelope);\n+        }\n+    }\n+\n+    protected void proxyOther(String key, Object value) {\n+        getOutput().emit(getCurrentTuple(), makeDefaultTuple(key, value));\n+    }\n+\n+    private void proxyOnlyIfActiveRegion(String key, InfoMessage envelope, IslInfoData payload) {\n+        SwitchId switchId = payload.getDestination().getSwitchId();\n+        proxyOnlyIfActiveRegion(key, envelope, switchId);\n+    }\n+\n+    private void proxyOnlyIfActiveRegion(String key, InfoMessage envelope, PortInfoData payload) {\n+        proxyOnlyIfActiveRegion(key, envelope, payload.getSwitchId());\n+    }\n+\n+    private void proxyOnlyIfActiveRegion(String key, InfoMessage envelope, IslOneWayLatency payload) {\n+        proxyOnlyIfActiveRegion(key, envelope, payload.getDstSwitchId());\n+    }\n+\n+    private void proxyOnlyIfActiveRegion(String key, InfoMessage envelope, IslBaseLatency payload) {\n+        proxyOnlyIfActiveRegion(key, envelope, payload.getSrcSwitchId());\n+    }\n+\n+    private void proxyOnlyIfActiveRegion(String key, InfoMessage envelope, ConnectedDevicePacketBase payload) {\n+        proxyOnlyIfActiveRegion(key, envelope, payload.getSwitchId());\n+    }\n+\n+    private void proxyOnlyIfActiveRegion(String key, InfoMessage envelope, SwitchId switchId) {\n+        switchMapping.lookupReadWriteRegion(switchId).ifPresent(activeRegion -> {\n+            String region = envelope.getRegion();\n+            if (Objects.equals(activeRegion, region)) {\n+                proxyOther(key, envelope);\n+            } else {\n+                log.debug(\n+                        \"Suppress discovery notification {} (received via region \\\"{}\\\" while active region is \\\"{}\\\")\",", "originalCommit": "0e61b76ca8093f27ca2b5d3d079cb1d993e5a6ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY4Mjc0Mw==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r465682743", "bodyText": "Yes... it become true during testing of this feature (i.e. at the start it filters out only discovery event). Made the message more generic.", "author": "surabujin", "createdAt": "2020-08-05T12:15:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM0MDU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1MjQ0Ng==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r464352446", "bodyText": "The same naming issue. Rename to writeAllowedMode.", "author": "rozdy", "createdAt": "2020-08-03T11:23:51Z", "path": "src-java/floodlightrouter-topology/floodlightrouter-storm-topology/src/main/java/org/openkilda/wfm/topology/floodlightrouter/model/RegionMappingUpdate.java", "diffHunk": "@@ -13,14 +13,15 @@\n  *   limitations under the License.\n  */\n \n-package org.openkilda.wfm.topology.floodlightrouter.service;\n+package org.openkilda.wfm.topology.floodlightrouter.model;\n \n import org.openkilda.model.SwitchId;\n \n import lombok.Value;\n \n @Value\n-public class SwitchMapping {\n+public class RegionMappingUpdate {\n     private SwitchId switchId;\n     private String region;\n+    private boolean readWriteMode;", "originalCommit": "0e61b76ca8093f27ca2b5d3d079cb1d993e5a6ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY4MzAyNg==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r465683026", "bodyText": "Same reason to keep this name.", "author": "surabujin", "createdAt": "2020-08-05T12:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1MjQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1NDAxOA==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r464354018", "bodyText": "os -> is", "author": "rozdy", "createdAt": "2020-08-03T11:27:17Z", "path": "src-java/floodlightrouter-topology/floodlightrouter-storm-topology/src/main/java/org/openkilda/wfm/topology/floodlightrouter/service/monitor/SwitchConnectMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.floodlightrouter.service.monitor;\n+\n+import org.openkilda.messaging.info.InfoData;\n+import org.openkilda.messaging.info.discovery.NetworkDumpSwitchData;\n+import org.openkilda.messaging.info.event.SwitchInfoData;\n+import org.openkilda.model.SwitchId;\n+import org.openkilda.wfm.topology.floodlightrouter.model.RegionMappingUpdate;\n+import org.openkilda.wfm.topology.floodlightrouter.service.SwitchMonitorCarrier;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public abstract class SwitchConnectMonitor {\n+    protected final SwitchMonitorCarrier carrier;\n+    private final Clock clock;\n+    protected final SwitchId switchId;\n+\n+    protected final Set<String> availableInRegions = new HashSet<>();\n+    private String activeRegion = null;\n+\n+    /**\n+     * Last time when connection was marked as unavailable. Caller must use {@code isAvailable()} result to detect\n+     * is connection now available or not.\n+     */\n+    @Getter\n+    private Instant becomeUnavailableAt;\n+\n+    public SwitchConnectMonitor(SwitchMonitorCarrier carrier, Clock clock, SwitchId switchId) {\n+        this.carrier = carrier;\n+        this.clock = clock;\n+        this.switchId = switchId;\n+\n+        // connection os not active yet... so it is inactive", "originalCommit": "0e61b76ca8093f27ca2b5d3d079cb1d993e5a6ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY4MzYyMQ==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r465683621", "bodyText": "fixed", "author": "surabujin", "createdAt": "2020-08-05T12:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1NDAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1NjQ5Mg==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r464356492", "bodyText": "Rename here too.", "author": "rozdy", "createdAt": "2020-08-03T11:33:17Z", "path": "src-java/floodlightrouter-topology/floodlightrouter-storm-topology/src/main/java/org/openkilda/wfm/topology/floodlightrouter/service/monitor/SwitchConnectMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.floodlightrouter.service.monitor;\n+\n+import org.openkilda.messaging.info.InfoData;\n+import org.openkilda.messaging.info.discovery.NetworkDumpSwitchData;\n+import org.openkilda.messaging.info.event.SwitchInfoData;\n+import org.openkilda.model.SwitchId;\n+import org.openkilda.wfm.topology.floodlightrouter.model.RegionMappingUpdate;\n+import org.openkilda.wfm.topology.floodlightrouter.service.SwitchMonitorCarrier;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public abstract class SwitchConnectMonitor {\n+    protected final SwitchMonitorCarrier carrier;\n+    private final Clock clock;\n+    protected final SwitchId switchId;\n+\n+    protected final Set<String> availableInRegions = new HashSet<>();\n+    private String activeRegion = null;\n+\n+    /**\n+     * Last time when connection was marked as unavailable. Caller must use {@code isAvailable()} result to detect\n+     * is connection now available or not.\n+     */\n+    @Getter\n+    private Instant becomeUnavailableAt;\n+\n+    public SwitchConnectMonitor(SwitchMonitorCarrier carrier, Clock clock, SwitchId switchId) {\n+        this.carrier = carrier;\n+        this.clock = clock;\n+        this.switchId = switchId;\n+\n+        // connection os not active yet... so it is inactive\n+        becomeUnavailableAt = clock.instant();\n+    }\n+\n+    /**\n+     * Handle switch status notification.\n+     */\n+    public boolean handleSwitchStatusNotification(SwitchInfoData notification, String region) {\n+        ensureSwitchIdMatch(notification.getSwitchId());\n+\n+        if (isConnectNotification(notification)) {\n+            handleConnect(notification, region);\n+        } else if (isDisconnectNotification(notification)) {\n+            handleDisconnect(notification, region);\n+        } else {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Handle region offline notification.\n+     */\n+    public void handleRegionOfflineNotification(String region) {\n+        if (availableInRegions.remove(region)) {\n+            handleAvailableRegionsSetUpdate();\n+            if (availableInRegions.isEmpty()) {\n+                becomeUnavailableDueToRegionOffline();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle network dump response.\n+     */\n+    public void handleNetworkDumpResponse(NetworkDumpSwitchData switchData, String region) {\n+        ensureSwitchIdMatch(switchData.getSwitchId());\n+\n+        boolean availableNow = isAvailable();\n+        handleConnect(switchData, region);\n+        if (availableNow && Objects.equals(activeRegion, region)) {\n+            // proxy network dump for active region only\n+            carrier.switchStatusUpdateNotification(switchId, switchData);\n+        }\n+    }\n+\n+    public boolean isAvailable() {\n+        return ! availableInRegions.isEmpty();\n+    }\n+\n+    protected void handleConnect(InfoData notification, String region) {\n+        if (availableInRegions.add(region)) {\n+            if (availableInRegions.size() == 1) {\n+                becomeAvailable(notification, region);\n+            }\n+            handleAvailableRegionsSetUpdate();\n+        }\n+    }\n+\n+    protected void handleDisconnect(SwitchInfoData notification, String region) {\n+        if (availableInRegions.remove(region)) {\n+            handleAvailableRegionsSetUpdate();\n+            if (availableInRegions.isEmpty()) {\n+                becomeUnavailable(notification);\n+            }\n+        }\n+    }\n+\n+    protected void becomeAvailable(InfoData notification, String region) {\n+        activeRegion = region;\n+        log.info(\"Set {} active region for {} to \\\"{}\\\"\", formatConnectMode(), switchId, activeRegion);\n+\n+        carrier.regionUpdateNotification(new RegionMappingUpdate(switchId, activeRegion, isReadWriteMode()));\n+        carrier.switchStatusUpdateNotification(switchId, notification);\n+    }\n+\n+    protected void becomeUnavailable(InfoData notification) {\n+        becomeUnavailableAt = clock.instant();\n+        activeRegion = null;\n+        log.info(\"There is no any {} available regions for {} - switch is unavailable\", formatConnectMode(), switchId);\n+\n+        carrier.regionUpdateNotification(new RegionMappingUpdate(switchId, null, isReadWriteMode()));\n+        carrier.switchStatusUpdateNotification(switchId, notification);\n+    }\n+\n+    protected abstract void becomeUnavailableDueToRegionOffline();\n+\n+    protected void handleAvailableRegionsSetUpdate() {\n+        log.info(\n+                \"List of {} availability zones for {} has changed to: {}\",\n+                formatConnectMode(), switchId, formatAvailableRegionsSet());\n+        if (!availableInRegions.contains(activeRegion) && !availableInRegions.isEmpty()) {\n+            swapActiveRegion();\n+        }\n+    }\n+\n+    protected void ensureSwitchIdMatch(SwitchId affectedSwitchId) {\n+        if (!switchId.equals(affectedSwitchId)) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"Got status update notification for wrong switch %s, can process notification only for %s\",\n+                    affectedSwitchId, switchId));\n+        }\n+    }\n+\n+    protected abstract boolean isReadWriteMode();", "originalCommit": "0e61b76ca8093f27ca2b5d3d079cb1d993e5a6ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c8423c760734553acaf07ea95ac4d1c01f5fd5ab", "url": "https://github.com/telstra/open-kilda/commit/c8423c760734553acaf07ea95ac4d1c01f5fd5ab", "message": "Support multiple simultaneous FL connections from a single switch\n\nFloodlightRouter topology monitor switch connections to the speakers. It\nthack \"active\" connection/region accordnig to the data reported from\nspeaker (connection/disconnect events) and to the region alive status\nproduced by floodlightrouter itself.\n\nSo requests will be routed into active region. This region tracked on\nper switch level i.e. each switch have own active region. Active region\nchanged only on switch disconnect event (for this region) or on region\ndisconnect/unavailability.", "committedDate": "2020-08-03T16:43:13Z", "type": "forcePushed"}, {"oid": "3f9c22aa3c74b234404ae131d1d9ddb5c7a102f3", "url": "https://github.com/telstra/open-kilda/commit/3f9c22aa3c74b234404ae131d1d9ddb5c7a102f3", "message": "Support multiple simultaneous FL connections from a single switch\n\nFloodlightRouter topology monitor switch connections to the speakers. It\nthack \"active\" connection/region accordnig to the data reported from\nspeaker (connection/disconnect events) and to the region alive status\nproduced by floodlightrouter itself.\n\nSo requests will be routed into active region. This region tracked on\nper switch level i.e. each switch have own active region. Active region\nchanged only on switch disconnect event (for this region) or on region\ndisconnect/unavailability.", "committedDate": "2020-08-05T12:32:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcxNDQ2MQ==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r467714461", "bodyText": "could you please add a java doc why this wrapper is needed, it will help", "author": "timofei-durakov", "createdAt": "2020-08-10T06:48:45Z", "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/BroadcastWrapper.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.messaging.command;\n+\n+import org.openkilda.model.SwitchId;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.EqualsAndHashCode;\n+import lombok.Value;\n+\n+import java.util.Set;\n+\n+@Value\n+@EqualsAndHashCode(callSuper = false)\n+public class BroadcastWrapper extends CommandData {", "originalCommit": "3f9c22aa3c74b234404ae131d1d9ddb5c7a102f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM5MTUzNw==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r468391537", "bodyText": "Added.", "author": "surabujin", "createdAt": "2020-08-11T07:50:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcxNDQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcxNTAxMw==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r467715013", "bodyText": "why not switches? scope is too abstract:-p", "author": "timofei-durakov", "createdAt": "2020-08-10T06:50:23Z", "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/BroadcastWrapper.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.messaging.command;\n+\n+import org.openkilda.model.SwitchId;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.EqualsAndHashCode;\n+import lombok.Value;\n+\n+import java.util.Set;\n+\n+@Value\n+@EqualsAndHashCode(callSuper = false)\n+public class BroadcastWrapper extends CommandData {\n+    @JsonProperty(\"scope\")\n+    private Set<SwitchId> scope;", "originalCommit": "3f9c22aa3c74b234404ae131d1d9ddb5c7a102f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM5NDY2OQ==", "url": "https://github.com/telstra/open-kilda/pull/3623#discussion_r468394669", "bodyText": "\"switches\" is even more abstract here as for me. It doesn't bring any \"restriction\" of \"affected area\" meaning only the type of data stored in the set.\n\"switch\" is most used term in our system, it is the main focus in open-kilda, so this term is everywhere. If there is any possibility to not use the term \"switch\", I will prefer to not use it.", "author": "surabujin", "createdAt": "2020-08-11T07:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcxNTAxMw=="}], "type": "inlineReview"}, {"oid": "56108b947232aabccf944e3bcd9953197fe7abb6", "url": "https://github.com/telstra/open-kilda/commit/56108b947232aabccf944e3bcd9953197fe7abb6", "message": "Support multiple simultaneous FL connections from a single switch\n\nFloodlightRouter topology monitor switch connections to the speakers. It\nthack \"active\" connection/region accordnig to the data reported from\nspeaker (connection/disconnect events) and to the region alive status\nproduced by floodlightrouter itself.\n\nSo requests will be routed into active region. This region tracked on\nper switch level i.e. each switch have own active region. Active region\nchanged only on switch disconnect event (for this region) or on region\ndisconnect/unavailability.", "committedDate": "2020-08-11T08:11:46Z", "type": "forcePushed"}, {"oid": "89f8cbfb984b67e1292c4bea1e81bff5fe814942", "url": "https://github.com/telstra/open-kilda/commit/89f8cbfb984b67e1292c4bea1e81bff5fe814942", "message": "Support multiple simultaneous FL connections from a single switch\n\nFloodlightRouter topology monitor switch connections to the speakers. It\nthack \"active\" connection/region accordnig to the data reported from\nspeaker (connection/disconnect events) and to the region alive status\nproduced by floodlightrouter itself.\n\nSo requests will be routed into active region. This region tracked on\nper switch level i.e. each switch have own active region. Active region\nchanged only on switch disconnect event (for this region) or on region\ndisconnect/unavailability.", "committedDate": "2020-08-11T10:14:12Z", "type": "commit"}, {"oid": "89f8cbfb984b67e1292c4bea1e81bff5fe814942", "url": "https://github.com/telstra/open-kilda/commit/89f8cbfb984b67e1292c4bea1e81bff5fe814942", "message": "Support multiple simultaneous FL connections from a single switch\n\nFloodlightRouter topology monitor switch connections to the speakers. It\nthack \"active\" connection/region accordnig to the data reported from\nspeaker (connection/disconnect events) and to the region alive status\nproduced by floodlightrouter itself.\n\nSo requests will be routed into active region. This region tracked on\nper switch level i.e. each switch have own active region. Active region\nchanged only on switch disconnect event (for this region) or on region\ndisconnect/unavailability.", "committedDate": "2020-08-11T10:14:12Z", "type": "forcePushed"}]}