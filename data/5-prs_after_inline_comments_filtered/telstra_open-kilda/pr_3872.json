{"pr_number": 3872, "pr_title": "Added kafka message versioning with ZooKeeper", "pr_createdAt": "2020-11-23T21:13:35Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3872", "timeline": [{"oid": "7b5321ca3f874e7fa318d31b6d2bc33ef2aaf51b", "url": "https://github.com/telstra/open-kilda/commit/7b5321ca3f874e7fa318d31b6d2bc33ef2aaf51b", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-11-24T07:44:21Z", "type": "forcePushed"}, {"oid": "3885faa85f4ed5f48d3915078e85bdc806e23453", "url": "https://github.com/telstra/open-kilda/commit/3885faa85f4ed5f48d3915078e85bdc806e23453", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-11-24T07:54:44Z", "type": "forcePushed"}, {"oid": "9d3177a2e75412bdb118ba6f1a08873dbd5ae528", "url": "https://github.com/telstra/open-kilda/commit/9d3177a2e75412bdb118ba6f1a08873dbd5ae528", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-11-25T08:18:07Z", "type": "forcePushed"}, {"oid": "731ed35ac0a40aad187737468474b3c860d36b22", "url": "https://github.com/telstra/open-kilda/commit/731ed35ac0a40aad187737468474b3c860d36b22", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-11-25T13:08:48Z", "type": "forcePushed"}, {"oid": "8eed973e18eca4b022be0a4352c5407d703006b6", "url": "https://github.com/telstra/open-kilda/commit/8eed973e18eca4b022be0a4352c5407d703006b6", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-11-25T13:10:11Z", "type": "forcePushed"}, {"oid": "bcb2f05c227e2eeb17df224c1b814b22538de527", "url": "https://github.com/telstra/open-kilda/commit/bcb2f05c227e2eeb17df224c1b814b22538de527", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-11-25T13:45:25Z", "type": "forcePushed"}, {"oid": "cfbd8683aee6ba4141d719449f99b5544a857d3d", "url": "https://github.com/telstra/open-kilda/commit/cfbd8683aee6ba4141d719449f99b5544a857d3d", "message": "Create zk build version by default", "committedDate": "2020-11-26T07:07:45Z", "type": "forcePushed"}, {"oid": "bfbfd675d899959960a6983a124a73cb3f7c9575", "url": "https://github.com/telstra/open-kilda/commit/bfbfd675d899959960a6983a124a73cb3f7c9575", "message": "Create zk build version by default", "committedDate": "2020-11-26T07:23:02Z", "type": "forcePushed"}, {"oid": "4d2f07133ecee67768543cd2c40362301d2cf680", "url": "https://github.com/telstra/open-kilda/commit/4d2f07133ecee67768543cd2c40362301d2cf680", "message": "Fixes", "committedDate": "2020-11-27T11:13:00Z", "type": "forcePushed"}, {"oid": "a388ab403b82caa9e495e7312174faf3e0e651e6", "url": "https://github.com/telstra/open-kilda/commit/a388ab403b82caa9e495e7312174faf3e0e651e6", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-11-27T11:28:57Z", "type": "forcePushed"}, {"oid": "eabb46e760d8ea081f7fbdc52f59231299f2b7a8", "url": "https://github.com/telstra/open-kilda/commit/eabb46e760d8ea081f7fbdc52f59231299f2b7a8", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-11-27T11:31:26Z", "type": "forcePushed"}, {"oid": "0b40151a229b2bcebfdda3f7b13ad1d679cbc598", "url": "https://github.com/telstra/open-kilda/commit/0b40151a229b2bcebfdda3f7b13ad1d679cbc598", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-11-28T08:09:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDgyMTM5OA==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r530821398", "bodyText": "why not debug?", "author": "timofei-durakov", "createdAt": "2020-11-26T07:33:38Z", "path": "src-java/base-topology/base-messaging/src/main/java/org/openkilda/messaging/kafka/versioning/VersioningConsumerInterceptor.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.messaging.kafka.versioning;\n+\n+import static org.openkilda.messaging.Utils.CONSUMER_COMPONENT_NAME_PROPERTY;\n+import static org.openkilda.messaging.Utils.CONSUMER_RUN_ID_PROPERTY;\n+import static org.openkilda.messaging.Utils.CONSUMER_ZOOKEEPER_CONNECTION_STRING_PROPERTY;\n+import static org.openkilda.messaging.Utils.MESSAGE_VERSION_HEADER;\n+import static org.openkilda.messaging.Utils.getValue;\n+\n+import org.openkilda.bluegreen.BuildVersionObserver;\n+import org.openkilda.bluegreen.ZkWatchDog;\n+\n+import com.google.common.collect.Lists;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.kafka.clients.consumer.ConsumerInterceptor;\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.apache.kafka.clients.consumer.OffsetAndMetadata;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.header.Header;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Slf4j\n+public class VersioningConsumerInterceptor<K, V> implements ConsumerInterceptor<K, V>, BuildVersionObserver {\n+    private String componentName;\n+    private String runId;\n+    private volatile String version;\n+\n+    @Override\n+    public ConsumerRecords<K, V> onConsume(ConsumerRecords<K, V> records) {\n+        Map<TopicPartition, List<ConsumerRecord<K, V>>> filteredRecordMap = new HashMap<>();\n+\n+        for (TopicPartition partition : records.partitions()) {\n+            List<ConsumerRecord<K, V>> filteredRecords = new ArrayList<>();\n+\n+            for (ConsumerRecord<K, V> record : records.records(partition)) {\n+                if (checkRecordVersion(record)) {\n+                    filteredRecords.add(record);\n+                }\n+            }\n+\n+            filteredRecordMap.put(partition, filteredRecords);\n+        }\n+        return new ConsumerRecords<>(filteredRecordMap);\n+    }\n+\n+    private boolean checkRecordVersion(ConsumerRecord<K, V> record) {\n+        List<Header> headers = Lists.newArrayList(record.headers().headers(MESSAGE_VERSION_HEADER));\n+\n+        if (version == null) {\n+            log.info(\"Messaging version is not set for component {} with id {}. Skip record {}\",\n+                    componentName, runId, record);\n+            return false;\n+        }\n+\n+        if (headers.isEmpty()) {\n+            if (log.isTraceEnabled()) {\n+                log.trace(String.format(\"Missed %s header for record %s\", MESSAGE_VERSION_HEADER, record));", "originalCommit": "bfbfd675d899959960a6983a124a73cb3f7c9575", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDgyMTcxNQ==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r530821715", "bodyText": "found", "author": "timofei-durakov", "createdAt": "2020-11-26T07:34:27Z", "path": "src-java/base-topology/base-messaging/src/main/java/org/openkilda/messaging/kafka/versioning/VersioningConsumerInterceptor.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.messaging.kafka.versioning;\n+\n+import static org.openkilda.messaging.Utils.CONSUMER_COMPONENT_NAME_PROPERTY;\n+import static org.openkilda.messaging.Utils.CONSUMER_RUN_ID_PROPERTY;\n+import static org.openkilda.messaging.Utils.CONSUMER_ZOOKEEPER_CONNECTION_STRING_PROPERTY;\n+import static org.openkilda.messaging.Utils.MESSAGE_VERSION_HEADER;\n+import static org.openkilda.messaging.Utils.getValue;\n+\n+import org.openkilda.bluegreen.BuildVersionObserver;\n+import org.openkilda.bluegreen.ZkWatchDog;\n+\n+import com.google.common.collect.Lists;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.kafka.clients.consumer.ConsumerInterceptor;\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.apache.kafka.clients.consumer.OffsetAndMetadata;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.header.Header;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Slf4j\n+public class VersioningConsumerInterceptor<K, V> implements ConsumerInterceptor<K, V>, BuildVersionObserver {\n+    private String componentName;\n+    private String runId;\n+    private volatile String version;\n+\n+    @Override\n+    public ConsumerRecords<K, V> onConsume(ConsumerRecords<K, V> records) {\n+        Map<TopicPartition, List<ConsumerRecord<K, V>>> filteredRecordMap = new HashMap<>();\n+\n+        for (TopicPartition partition : records.partitions()) {\n+            List<ConsumerRecord<K, V>> filteredRecords = new ArrayList<>();\n+\n+            for (ConsumerRecord<K, V> record : records.records(partition)) {\n+                if (checkRecordVersion(record)) {\n+                    filteredRecords.add(record);\n+                }\n+            }\n+\n+            filteredRecordMap.put(partition, filteredRecords);\n+        }\n+        return new ConsumerRecords<>(filteredRecordMap);\n+    }\n+\n+    private boolean checkRecordVersion(ConsumerRecord<K, V> record) {\n+        List<Header> headers = Lists.newArrayList(record.headers().headers(MESSAGE_VERSION_HEADER));\n+\n+        if (version == null) {\n+            log.info(\"Messaging version is not set for component {} with id {}. Skip record {}\",\n+                    componentName, runId, record);\n+            return false;\n+        }\n+\n+        if (headers.isEmpty()) {\n+            if (log.isTraceEnabled()) {\n+                log.trace(String.format(\"Missed %s header for record %s\", MESSAGE_VERSION_HEADER, record));\n+            }\n+            return false;\n+        }\n+\n+        if (headers.size() > 1) {\n+            log.warn(String.format(\"Fount more than one %s headers for record %s\", MESSAGE_VERSION_HEADER, record));", "originalCommit": "bfbfd675d899959960a6983a124a73cb3f7c9575", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDgyMTg2Mg==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r530821862", "bodyText": "the same", "author": "timofei-durakov", "createdAt": "2020-11-26T07:34:52Z", "path": "src-java/base-topology/base-messaging/src/main/java/org/openkilda/messaging/kafka/versioning/VersioningConsumerInterceptor.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.messaging.kafka.versioning;\n+\n+import static org.openkilda.messaging.Utils.CONSUMER_COMPONENT_NAME_PROPERTY;\n+import static org.openkilda.messaging.Utils.CONSUMER_RUN_ID_PROPERTY;\n+import static org.openkilda.messaging.Utils.CONSUMER_ZOOKEEPER_CONNECTION_STRING_PROPERTY;\n+import static org.openkilda.messaging.Utils.MESSAGE_VERSION_HEADER;\n+import static org.openkilda.messaging.Utils.getValue;\n+\n+import org.openkilda.bluegreen.BuildVersionObserver;\n+import org.openkilda.bluegreen.ZkWatchDog;\n+\n+import com.google.common.collect.Lists;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.kafka.clients.consumer.ConsumerInterceptor;\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.apache.kafka.clients.consumer.OffsetAndMetadata;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.header.Header;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Slf4j\n+public class VersioningConsumerInterceptor<K, V> implements ConsumerInterceptor<K, V>, BuildVersionObserver {\n+    private String componentName;\n+    private String runId;\n+    private volatile String version;\n+\n+    @Override\n+    public ConsumerRecords<K, V> onConsume(ConsumerRecords<K, V> records) {\n+        Map<TopicPartition, List<ConsumerRecord<K, V>>> filteredRecordMap = new HashMap<>();\n+\n+        for (TopicPartition partition : records.partitions()) {\n+            List<ConsumerRecord<K, V>> filteredRecords = new ArrayList<>();\n+\n+            for (ConsumerRecord<K, V> record : records.records(partition)) {\n+                if (checkRecordVersion(record)) {\n+                    filteredRecords.add(record);\n+                }\n+            }\n+\n+            filteredRecordMap.put(partition, filteredRecords);\n+        }\n+        return new ConsumerRecords<>(filteredRecordMap);\n+    }\n+\n+    private boolean checkRecordVersion(ConsumerRecord<K, V> record) {\n+        List<Header> headers = Lists.newArrayList(record.headers().headers(MESSAGE_VERSION_HEADER));\n+\n+        if (version == null) {\n+            log.info(\"Messaging version is not set for component {} with id {}. Skip record {}\",\n+                    componentName, runId, record);\n+            return false;\n+        }\n+\n+        if (headers.isEmpty()) {\n+            if (log.isTraceEnabled()) {\n+                log.trace(String.format(\"Missed %s header for record %s\", MESSAGE_VERSION_HEADER, record));\n+            }\n+            return false;\n+        }\n+\n+        if (headers.size() > 1) {\n+            log.warn(String.format(\"Fount more than one %s headers for record %s\", MESSAGE_VERSION_HEADER, record));\n+            // TODO maybe need to be replaced with some soft handling. Maybe check all versions in list\n+            // Currently such hard constraints are needed to test versioning massaging\n+            return false;\n+        }\n+\n+        if (!version.equals(new String(headers.get(0).value()))) {\n+            if (log.isTraceEnabled()) {", "originalCommit": "bfbfd675d899959960a6983a124a73cb3f7c9575", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7c29f8c4c2370b0b49a068a9b10756eb065b7af3", "url": "https://github.com/telstra/open-kilda/commit/7c29f8c4c2370b0b49a068a9b10756eb065b7af3", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-02T07:53:04Z", "type": "forcePushed"}, {"oid": "b16257805eef789ba31f95b21436e9efe73a35ae", "url": "https://github.com/telstra/open-kilda/commit/b16257805eef789ba31f95b21436e9efe73a35ae", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-02T10:31:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1MjA1Mg==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r535352052", "bodyText": "that is debugging message no info", "author": "nikitamarchenko", "createdAt": "2020-12-03T15:47:46Z", "path": "src-java/base-topology/base-messaging/src/main/java/org/openkilda/messaging/kafka/versioning/VersioningConsumerInterceptor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.messaging.kafka.versioning;\n+\n+import static org.openkilda.messaging.Utils.CONSUMER_COMPONENT_NAME_PROPERTY;\n+import static org.openkilda.messaging.Utils.CONSUMER_RUN_ID_PROPERTY;\n+import static org.openkilda.messaging.Utils.CONSUMER_ZOOKEEPER_CONNECTION_STRING_PROPERTY;\n+import static org.openkilda.messaging.Utils.MESSAGE_VERSION_HEADER;\n+import static org.openkilda.messaging.Utils.getValue;\n+\n+import org.openkilda.bluegreen.BuildVersionObserver;\n+import org.openkilda.bluegreen.ZkWatchDog;\n+\n+import com.google.common.collect.Lists;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.kafka.clients.consumer.ConsumerInterceptor;\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.apache.kafka.clients.consumer.OffsetAndMetadata;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.header.Header;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Slf4j\n+public class VersioningConsumerInterceptor<K, V> extends VersioningInterceptorBase\n+        implements ConsumerInterceptor<K, V>, BuildVersionObserver {\n+\n+    public VersioningConsumerInterceptor() {\n+        log.info(\"Initializing VersioningConsumerInterceptor\");", "originalCommit": "b16257805eef789ba31f95b21436e9efe73a35ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg5NDkyOA==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r535894928", "bodyText": "fixed", "author": "niksv", "createdAt": "2020-12-04T07:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1MjA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1NjU3MA==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r535356570", "bodyText": "must be some reconnect process", "author": "nikitamarchenko", "createdAt": "2020-12-03T15:52:11Z", "path": "src-java/base-topology/base-messaging/src/main/java/org/openkilda/messaging/kafka/versioning/VersioningConsumerInterceptor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.messaging.kafka.versioning;\n+\n+import static org.openkilda.messaging.Utils.CONSUMER_COMPONENT_NAME_PROPERTY;\n+import static org.openkilda.messaging.Utils.CONSUMER_RUN_ID_PROPERTY;\n+import static org.openkilda.messaging.Utils.CONSUMER_ZOOKEEPER_CONNECTION_STRING_PROPERTY;\n+import static org.openkilda.messaging.Utils.MESSAGE_VERSION_HEADER;\n+import static org.openkilda.messaging.Utils.getValue;\n+\n+import org.openkilda.bluegreen.BuildVersionObserver;\n+import org.openkilda.bluegreen.ZkWatchDog;\n+\n+import com.google.common.collect.Lists;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.kafka.clients.consumer.ConsumerInterceptor;\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.apache.kafka.clients.consumer.OffsetAndMetadata;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.header.Header;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Slf4j\n+public class VersioningConsumerInterceptor<K, V> extends VersioningInterceptorBase\n+        implements ConsumerInterceptor<K, V>, BuildVersionObserver {\n+\n+    public VersioningConsumerInterceptor() {\n+        log.info(\"Initializing VersioningConsumerInterceptor\");\n+    }\n+\n+    @Override\n+    public ConsumerRecords<K, V> onConsume(ConsumerRecords<K, V> records) {\n+        Map<TopicPartition, List<ConsumerRecord<K, V>>> filteredRecordMap = new HashMap<>();\n+\n+        for (TopicPartition partition : records.partitions()) {\n+            List<ConsumerRecord<K, V>> filteredRecords = new ArrayList<>();\n+\n+            for (ConsumerRecord<K, V> record : records.records(partition)) {\n+                if (checkRecordVersion(record)) {\n+                    filteredRecords.add(record);\n+                }\n+            }\n+\n+            filteredRecordMap.put(partition, filteredRecords);\n+        }\n+        return new ConsumerRecords<>(filteredRecordMap);\n+    }\n+\n+    private boolean checkRecordVersion(ConsumerRecord<K, V> record) {\n+        List<Header> headers = Lists.newArrayList(record.headers().headers(MESSAGE_VERSION_HEADER));\n+\n+        if (version == null) {\n+            if (isVersionIsNotTimeoutPassed()) {\n+                // We will write this log every 60 seconds to do not spam in logs\n+                log.warn(\"Messaging version is not set for component {} with id {}. Skip record {}\",\n+                        componentName, runId, record);\n+                versionIsNotSetTimestamp = Instant.now();\n+            }\n+            return false;\n+        }\n+\n+        if (headers.isEmpty()) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(String.format(\"Missed %s header for record %s\", MESSAGE_VERSION_HEADER, record));\n+            }\n+            return false;\n+        }\n+\n+        if (headers.size() > 1) {\n+            log.warn(String.format(\"Found more than one %s headers for record %s\", MESSAGE_VERSION_HEADER, record));\n+            return false;\n+        }\n+\n+        if (!version.equals(new String(headers.get(0).value()))) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Skip record {} with version {}. Target version is {}\",\n+                        record, new String(headers.get(0).value()), version);\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void configure(Map<String, ?> configs) {\n+        String connectionString = getValue(configs, CONSUMER_ZOOKEEPER_CONNECTION_STRING_PROPERTY, String.class);\n+        runId = getValue(configs, CONSUMER_RUN_ID_PROPERTY, String.class);\n+        componentName = getValue(configs, CONSUMER_COMPONENT_NAME_PROPERTY, String.class);\n+        log.info(\"Configuring VersioningConsumerInterceptor for component {} with id {} and connection string {}\",\n+                componentName, runId, connectionString);\n+\n+        try {\n+            ZkWatchDog watchDog = ZkWatchDog.builder()\n+                    .id(runId)\n+                    .serviceName(componentName)\n+                    .connectionString(connectionString).build();\n+\n+            watchDog.subscribe(this);\n+        } catch (IOException e) {\n+            log.error(\"Component {} with id {} can't connect to ZooKeeper with connection string: {}, received: {}\",", "originalCommit": "b16257805eef789ba31f95b21436e9efe73a35ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3NDIzMQ==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r535974231", "bodyText": "fixed", "author": "niksv", "createdAt": "2020-12-04T09:53:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1NjU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1ODE1OA==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r535358158", "bodyText": "watchDog?", "author": "nikitamarchenko", "createdAt": "2020-12-03T15:54:08Z", "path": "src-java/base-topology/base-messaging/src/main/java/org/openkilda/messaging/kafka/versioning/VersioningConsumerInterceptor.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.messaging.kafka.versioning;\n+\n+import static org.openkilda.messaging.Utils.CONSUMER_COMPONENT_NAME_PROPERTY;\n+import static org.openkilda.messaging.Utils.CONSUMER_RUN_ID_PROPERTY;\n+import static org.openkilda.messaging.Utils.CONSUMER_ZOOKEEPER_CONNECTION_STRING_PROPERTY;\n+import static org.openkilda.messaging.Utils.MESSAGE_VERSION_HEADER;\n+import static org.openkilda.messaging.Utils.getValue;\n+\n+import org.openkilda.bluegreen.BuildVersionObserver;\n+import org.openkilda.bluegreen.ZkWatchDog;\n+\n+import com.google.common.collect.Lists;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.kafka.clients.consumer.ConsumerInterceptor;\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.apache.kafka.clients.consumer.OffsetAndMetadata;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.header.Header;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Slf4j\n+public class VersioningConsumerInterceptor<K, V> extends VersioningInterceptorBase\n+        implements ConsumerInterceptor<K, V>, BuildVersionObserver {\n+\n+    public VersioningConsumerInterceptor() {\n+        log.info(\"Initializing VersioningConsumerInterceptor\");\n+    }\n+\n+    @Override\n+    public ConsumerRecords<K, V> onConsume(ConsumerRecords<K, V> records) {\n+        Map<TopicPartition, List<ConsumerRecord<K, V>>> filteredRecordMap = new HashMap<>();\n+\n+        for (TopicPartition partition : records.partitions()) {\n+            List<ConsumerRecord<K, V>> filteredRecords = new ArrayList<>();\n+\n+            for (ConsumerRecord<K, V> record : records.records(partition)) {\n+                if (checkRecordVersion(record)) {\n+                    filteredRecords.add(record);\n+                }\n+            }\n+\n+            filteredRecordMap.put(partition, filteredRecords);\n+        }\n+        return new ConsumerRecords<>(filteredRecordMap);\n+    }\n+\n+    private boolean checkRecordVersion(ConsumerRecord<K, V> record) {\n+        List<Header> headers = Lists.newArrayList(record.headers().headers(MESSAGE_VERSION_HEADER));\n+\n+        if (version == null) {\n+            if (isVersionIsNotTimeoutPassed()) {\n+                // We will write this log every 60 seconds to do not spam in logs\n+                log.warn(\"Messaging version is not set for component {} with id {}. Skip record {}\",\n+                        componentName, runId, record);\n+                versionIsNotSetTimestamp = Instant.now();\n+            }\n+            return false;\n+        }\n+\n+        if (headers.isEmpty()) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(String.format(\"Missed %s header for record %s\", MESSAGE_VERSION_HEADER, record));\n+            }\n+            return false;\n+        }\n+\n+        if (headers.size() > 1) {\n+            log.warn(String.format(\"Found more than one %s headers for record %s\", MESSAGE_VERSION_HEADER, record));\n+            return false;\n+        }\n+\n+        if (!version.equals(new String(headers.get(0).value()))) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Skip record {} with version {}. Target version is {}\",\n+                        record, new String(headers.get(0).value()), version);\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void configure(Map<String, ?> configs) {\n+        String connectionString = getValue(configs, CONSUMER_ZOOKEEPER_CONNECTION_STRING_PROPERTY, String.class);\n+        runId = getValue(configs, CONSUMER_RUN_ID_PROPERTY, String.class);\n+        componentName = getValue(configs, CONSUMER_COMPONENT_NAME_PROPERTY, String.class);\n+        log.info(\"Configuring VersioningConsumerInterceptor for component {} with id {} and connection string {}\",\n+                componentName, runId, connectionString);\n+\n+        try {\n+            ZkWatchDog watchDog = ZkWatchDog.builder()\n+                    .id(runId)\n+                    .serviceName(componentName)\n+                    .connectionString(connectionString).build();\n+\n+            watchDog.subscribe(this);\n+        } catch (IOException e) {\n+            log.error(\"Component {} with id {} can't connect to ZooKeeper with connection string: {}, received: {}\",\n+                    componentName, runId, connectionString, e.getMessage());\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    @Override\n+    public void onCommit(Map<TopicPartition, OffsetAndMetadata> offsets) {\n+        // nothing to do here\n+    }\n+\n+    @Override\n+    public void close() {\n+        // nothing to do here", "originalCommit": "b16257805eef789ba31f95b21436e9efe73a35ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkwODE3MQ==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r535908171", "bodyText": "fixed", "author": "niksv", "createdAt": "2020-12-04T08:06:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1ODE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1OTE4Mw==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r535359183", "bodyText": "make it debug", "author": "nikitamarchenko", "createdAt": "2020-12-03T15:55:19Z", "path": "src-java/base-topology/base-messaging/src/main/java/org/openkilda/messaging/kafka/versioning/VersioningProducerInterceptor.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.messaging.kafka.versioning;\n+\n+import static org.openkilda.messaging.Utils.MESSAGE_VERSION_HEADER;\n+import static org.openkilda.messaging.Utils.PRODUCER_COMPONENT_NAME_PROPERTY;\n+import static org.openkilda.messaging.Utils.PRODUCER_RUN_ID_PROPERTY;\n+import static org.openkilda.messaging.Utils.PRODUCER_ZOOKEEPER_CONNECTION_STRING_PROPERTY;\n+import static org.openkilda.messaging.Utils.getValue;\n+\n+import org.openkilda.bluegreen.BuildVersionObserver;\n+import org.openkilda.bluegreen.ZkWatchDog;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.kafka.clients.producer.ProducerInterceptor;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.clients.producer.RecordMetadata;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Map;\n+\n+@Slf4j\n+public class VersioningProducerInterceptor<K, V> extends VersioningInterceptorBase\n+        implements ProducerInterceptor<K, V>, BuildVersionObserver {\n+\n+    public VersioningProducerInterceptor() {\n+        log.info(\"Initializing VersioningProducerInterceptor\");", "originalCommit": "b16257805eef789ba31f95b21436e9efe73a35ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg5NDk4Ng==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r535894986", "bodyText": "fixed", "author": "niksv", "createdAt": "2020-12-04T07:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1OTE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3MDEzMg==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r535370132", "bodyText": "In our app, you will call getBytes billion times on one constant version.", "author": "nikitamarchenko", "createdAt": "2020-12-03T16:09:05Z", "path": "src-java/base-topology/base-messaging/src/main/java/org/openkilda/messaging/kafka/versioning/VersioningProducerInterceptor.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.messaging.kafka.versioning;\n+\n+import static org.openkilda.messaging.Utils.MESSAGE_VERSION_HEADER;\n+import static org.openkilda.messaging.Utils.PRODUCER_COMPONENT_NAME_PROPERTY;\n+import static org.openkilda.messaging.Utils.PRODUCER_RUN_ID_PROPERTY;\n+import static org.openkilda.messaging.Utils.PRODUCER_ZOOKEEPER_CONNECTION_STRING_PROPERTY;\n+import static org.openkilda.messaging.Utils.getValue;\n+\n+import org.openkilda.bluegreen.BuildVersionObserver;\n+import org.openkilda.bluegreen.ZkWatchDog;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.kafka.clients.producer.ProducerInterceptor;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.clients.producer.RecordMetadata;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Map;\n+\n+@Slf4j\n+public class VersioningProducerInterceptor<K, V> extends VersioningInterceptorBase\n+        implements ProducerInterceptor<K, V>, BuildVersionObserver {\n+\n+    public VersioningProducerInterceptor() {\n+        log.info(\"Initializing VersioningProducerInterceptor\");\n+    }\n+\n+    @Override\n+    public ProducerRecord<K, V> onSend(ProducerRecord<K, V> record) {\n+        if (record.headers().headers(MESSAGE_VERSION_HEADER).iterator().hasNext()) {\n+            log.info(\"Kafka record {} already has header {}: {}\",\n+                    record, MESSAGE_VERSION_HEADER,\n+                    new String(record.headers().headers(MESSAGE_VERSION_HEADER).iterator().next().value()));\n+            record.headers().remove(MESSAGE_VERSION_HEADER);\n+        }\n+\n+        if (version == null) {\n+            if (isVersionIsNotTimeoutPassed()) {\n+                // We will write this log every 60 seconds to do not spam in logs\n+                log.warn(\"Messaging version is not set for component {} with id {}. Skip record {}\",\n+                        componentName, runId, record);\n+                versionIsNotSetTimestamp = Instant.now();\n+            }\n+            // We can't return null record. We will return record without version.\n+            // Such records wouldn't be read by Kafka Consumer with VersioningConsumerInterceptor\n+            return record;\n+        }\n+\n+        record.headers().add(MESSAGE_VERSION_HEADER, version.getBytes());", "originalCommit": "b16257805eef789ba31f95b21436e9efe73a35ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkwMDMyMA==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r535900320", "bodyText": "fixed", "author": "niksv", "createdAt": "2020-12-04T07:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3MDEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM4NzUyOA==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r535387528", "bodyText": "need reconnect process", "author": "nikitamarchenko", "createdAt": "2020-12-03T16:30:59Z", "path": "src-java/base-topology/base-messaging/src/main/java/org/openkilda/messaging/kafka/versioning/VersioningProducerInterceptor.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.messaging.kafka.versioning;\n+\n+import static org.openkilda.messaging.Utils.MESSAGE_VERSION_HEADER;\n+import static org.openkilda.messaging.Utils.PRODUCER_COMPONENT_NAME_PROPERTY;\n+import static org.openkilda.messaging.Utils.PRODUCER_RUN_ID_PROPERTY;\n+import static org.openkilda.messaging.Utils.PRODUCER_ZOOKEEPER_CONNECTION_STRING_PROPERTY;\n+import static org.openkilda.messaging.Utils.getValue;\n+\n+import org.openkilda.bluegreen.BuildVersionObserver;\n+import org.openkilda.bluegreen.ZkWatchDog;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.kafka.clients.producer.ProducerInterceptor;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.clients.producer.RecordMetadata;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Map;\n+\n+@Slf4j\n+public class VersioningProducerInterceptor<K, V> extends VersioningInterceptorBase\n+        implements ProducerInterceptor<K, V>, BuildVersionObserver {\n+\n+    public VersioningProducerInterceptor() {\n+        log.info(\"Initializing VersioningProducerInterceptor\");\n+    }\n+\n+    @Override\n+    public ProducerRecord<K, V> onSend(ProducerRecord<K, V> record) {\n+        if (record.headers().headers(MESSAGE_VERSION_HEADER).iterator().hasNext()) {\n+            log.info(\"Kafka record {} already has header {}: {}\",\n+                    record, MESSAGE_VERSION_HEADER,\n+                    new String(record.headers().headers(MESSAGE_VERSION_HEADER).iterator().next().value()));\n+            record.headers().remove(MESSAGE_VERSION_HEADER);\n+        }\n+\n+        if (version == null) {\n+            if (isVersionIsNotTimeoutPassed()) {\n+                // We will write this log every 60 seconds to do not spam in logs\n+                log.warn(\"Messaging version is not set for component {} with id {}. Skip record {}\",\n+                        componentName, runId, record);\n+                versionIsNotSetTimestamp = Instant.now();\n+            }\n+            // We can't return null record. We will return record without version.\n+            // Such records wouldn't be read by Kafka Consumer with VersioningConsumerInterceptor\n+            return record;\n+        }\n+\n+        record.headers().add(MESSAGE_VERSION_HEADER, version.getBytes());\n+        return record;\n+    }\n+\n+    @Override\n+    public void onAcknowledgement(RecordMetadata metadata, Exception exception) {\n+        // nothing to do\n+    }\n+\n+    public void close() {\n+        // nothing to do\n+    }\n+\n+    @Override\n+    public void configure(Map<String, ?> configs) {\n+        String connectionString = getValue(configs, PRODUCER_ZOOKEEPER_CONNECTION_STRING_PROPERTY, String.class);\n+        runId = getValue(configs, PRODUCER_RUN_ID_PROPERTY, String.class);\n+        componentName = getValue(configs, PRODUCER_COMPONENT_NAME_PROPERTY, String.class);\n+        log.info(\"Configuring VersioningProducerInterceptor for component {} with id {} and connection string {}\",\n+                componentName, runId, connectionString);\n+\n+        try {\n+            ZkWatchDog watchDog = ZkWatchDog.builder()\n+                    .id(runId)\n+                    .serviceName(componentName)\n+                    .connectionString(connectionString).build();\n+\n+            watchDog.subscribe(this);\n+        } catch (IOException e) {\n+            log.error(\"Component {} with id {} can't connect to ZooKeeper with connection string: {}, received: {}\",", "originalCommit": "b16257805eef789ba31f95b21436e9efe73a35ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3NDMwOQ==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r535974309", "bodyText": "fixed", "author": "niksv", "createdAt": "2020-12-04T09:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM4NzUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5MTkzOA==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r535391938", "bodyText": "you print that on stderr stream, not in logger", "author": "nikitamarchenko", "createdAt": "2020-12-03T16:36:48Z", "path": "src-java/base-topology/base-messaging/src/main/java/org/openkilda/messaging/kafka/versioning/VersioningProducerInterceptor.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.messaging.kafka.versioning;\n+\n+import static org.openkilda.messaging.Utils.MESSAGE_VERSION_HEADER;\n+import static org.openkilda.messaging.Utils.PRODUCER_COMPONENT_NAME_PROPERTY;\n+import static org.openkilda.messaging.Utils.PRODUCER_RUN_ID_PROPERTY;\n+import static org.openkilda.messaging.Utils.PRODUCER_ZOOKEEPER_CONNECTION_STRING_PROPERTY;\n+import static org.openkilda.messaging.Utils.getValue;\n+\n+import org.openkilda.bluegreen.BuildVersionObserver;\n+import org.openkilda.bluegreen.ZkWatchDog;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.kafka.clients.producer.ProducerInterceptor;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.clients.producer.RecordMetadata;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Map;\n+\n+@Slf4j\n+public class VersioningProducerInterceptor<K, V> extends VersioningInterceptorBase\n+        implements ProducerInterceptor<K, V>, BuildVersionObserver {\n+\n+    public VersioningProducerInterceptor() {\n+        log.info(\"Initializing VersioningProducerInterceptor\");\n+    }\n+\n+    @Override\n+    public ProducerRecord<K, V> onSend(ProducerRecord<K, V> record) {\n+        if (record.headers().headers(MESSAGE_VERSION_HEADER).iterator().hasNext()) {\n+            log.info(\"Kafka record {} already has header {}: {}\",\n+                    record, MESSAGE_VERSION_HEADER,\n+                    new String(record.headers().headers(MESSAGE_VERSION_HEADER).iterator().next().value()));\n+            record.headers().remove(MESSAGE_VERSION_HEADER);\n+        }\n+\n+        if (version == null) {\n+            if (isVersionIsNotTimeoutPassed()) {\n+                // We will write this log every 60 seconds to do not spam in logs\n+                log.warn(\"Messaging version is not set for component {} with id {}. Skip record {}\",\n+                        componentName, runId, record);\n+                versionIsNotSetTimestamp = Instant.now();\n+            }\n+            // We can't return null record. We will return record without version.\n+            // Such records wouldn't be read by Kafka Consumer with VersioningConsumerInterceptor\n+            return record;\n+        }\n+\n+        record.headers().add(MESSAGE_VERSION_HEADER, version.getBytes());\n+        return record;\n+    }\n+\n+    @Override\n+    public void onAcknowledgement(RecordMetadata metadata, Exception exception) {\n+        // nothing to do\n+    }\n+\n+    public void close() {\n+        // nothing to do\n+    }\n+\n+    @Override\n+    public void configure(Map<String, ?> configs) {\n+        String connectionString = getValue(configs, PRODUCER_ZOOKEEPER_CONNECTION_STRING_PROPERTY, String.class);\n+        runId = getValue(configs, PRODUCER_RUN_ID_PROPERTY, String.class);\n+        componentName = getValue(configs, PRODUCER_COMPONENT_NAME_PROPERTY, String.class);\n+        log.info(\"Configuring VersioningProducerInterceptor for component {} with id {} and connection string {}\",\n+                componentName, runId, connectionString);\n+\n+        try {\n+            ZkWatchDog watchDog = ZkWatchDog.builder()\n+                    .id(runId)\n+                    .serviceName(componentName)\n+                    .connectionString(connectionString).build();\n+\n+            watchDog.subscribe(this);\n+        } catch (IOException e) {\n+            log.error(\"Component {} with id {} can't connect to ZooKeeper with connection string: {}, received: {}\",\n+                    componentName, runId, connectionString, e.getMessage());\n+            e.printStackTrace();", "originalCommit": "b16257805eef789ba31f95b21436e9efe73a35ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg5NTA4Ng==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r535895086", "bodyText": "fixed", "author": "niksv", "createdAt": "2020-12-04T07:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5MTkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQxMTAwNg==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r535411006", "bodyText": "looking like python", "author": "nikitamarchenko", "createdAt": "2020-12-03T16:57:04Z", "path": "src-java/blue-green/src/main/java/org/openkilda/bluegreen/ZkClient.java", "diffHunk": "@@ -73,10 +73,14 @@ protected ZooKeeper getZk() throws IOException {\n     }\n \n     protected void ensureZNode(String... path) throws KeeperException, InterruptedException {\n+        ensureZNode(\"\".getBytes(), path);", "originalCommit": "b16257805eef789ba31f95b21436e9efe73a35ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg5NTYyOA==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r535895628", "bodyText": "fixed", "author": "niksv", "createdAt": "2020-12-04T07:41:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQxMTAwNg=="}], "type": "inlineReview"}, {"oid": "e6115c836e93bf44b9e97ec92474bf084b3005f2", "url": "https://github.com/telstra/open-kilda/commit/e6115c836e93bf44b9e97ec92474bf084b3005f2", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-04T09:16:32Z", "type": "forcePushed"}, {"oid": "f174b433b65f6ac67c4ede0f9e284d48d9d0ee8e", "url": "https://github.com/telstra/open-kilda/commit/f174b433b65f6ac67c4ede0f9e284d48d9d0ee8e", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-04T12:10:15Z", "type": "forcePushed"}, {"oid": "c1be45fc9a95538801fa852f6dee5ff0dc133ce0", "url": "https://github.com/telstra/open-kilda/commit/c1be45fc9a95538801fa852f6dee5ff0dc133ce0", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-04T15:01:11Z", "type": "forcePushed"}, {"oid": "82f0f770f1b2ca942c191c25a7bd5e04f0c17fe3", "url": "https://github.com/telstra/open-kilda/commit/82f0f770f1b2ca942c191c25a7bd5e04f0c17fe3", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-07T08:26:59Z", "type": "forcePushed"}, {"oid": "3e13b4b55acf0075d8b00eb2e3145e080ab1027b", "url": "https://github.com/telstra/open-kilda/commit/3e13b4b55acf0075d8b00eb2e3145e080ab1027b", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-07T09:19:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzNjY1MA==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r538236650", "bodyText": "move it config files", "author": "nikitamarchenko", "createdAt": "2020-12-08T10:50:05Z", "path": "src-java/server42/server42-stats/src/main/java/org/openkilda/server42/stats/kafka/KafkaConfig.java", "diffHunk": "@@ -15,16 +15,61 @@\n \n package org.openkilda.server42.stats.kafka;\n \n+import static org.openkilda.bluegreen.kafka.Utils.CONSUMER_COMPONENT_NAME_PROPERTY;\n+import static org.openkilda.bluegreen.kafka.Utils.CONSUMER_RUN_ID_PROPERTY;\n+import static org.openkilda.bluegreen.kafka.Utils.CONSUMER_ZOOKEEPER_CONNECTION_STRING_PROPERTY;\n+import static org.openkilda.bluegreen.kafka.Utils.PRODUCER_COMPONENT_NAME_PROPERTY;\n+import static org.openkilda.bluegreen.kafka.Utils.PRODUCER_RUN_ID_PROPERTY;\n+import static org.openkilda.bluegreen.kafka.Utils.PRODUCER_ZOOKEEPER_CONNECTION_STRING_PROPERTY;\n+\n+import org.openkilda.bluegreen.kafka.interceptors.VersioningConsumerInterceptor;\n+import org.openkilda.bluegreen.kafka.interceptors.VersioningProducerInterceptor;\n+\n import org.apache.kafka.clients.admin.NewTopic;\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.clients.producer.ProducerConfig;\n import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.boot.autoconfigure.kafka.KafkaProperties;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Configuration;\n import org.springframework.kafka.config.TopicBuilder;\n+import org.springframework.kafka.core.ConsumerFactory;\n+import org.springframework.kafka.core.DefaultKafkaConsumerFactory;\n+import org.springframework.kafka.core.DefaultKafkaProducerFactory;\n+import org.springframework.kafka.core.ProducerFactory;\n+\n+import java.util.Map;\n \n @Configuration\n public class KafkaConfig {\n+    public static final String SERVER_42_RUN_ID = \"server42-run-id\";\n+    public static final String SERVER_42_STATS_COMPONENT_NAME = \"server42-stats\";\n+\n+    @Value(\"${zookeeper.connect_string}\")\n+    private String zookeeperConnectString;\n+\n     @Bean\n     public NewTopic toStorm(@Value(\"${openkilda.server42.stats.kafka.topic.flowrtt.to_storm}\") String name) {\n         return TopicBuilder.name(name).build();\n     }\n+\n+    @Bean\n+    public ConsumerFactory<?, ?> kafkaConsumerFactory(KafkaProperties properties) {", "originalCommit": "3e13b4b55acf0075d8b00eb2e3145e080ab1027b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI4MTEwMw==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r538281103", "bodyText": "fixed", "author": "niksv", "createdAt": "2020-12-08T11:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzNjY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzNjczMw==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r538236733", "bodyText": "move it config files", "author": "nikitamarchenko", "createdAt": "2020-12-08T10:50:13Z", "path": "src-java/server42/server42-stats/src/main/java/org/openkilda/server42/stats/kafka/KafkaConfig.java", "diffHunk": "@@ -15,16 +15,61 @@\n \n package org.openkilda.server42.stats.kafka;\n \n+import static org.openkilda.bluegreen.kafka.Utils.CONSUMER_COMPONENT_NAME_PROPERTY;\n+import static org.openkilda.bluegreen.kafka.Utils.CONSUMER_RUN_ID_PROPERTY;\n+import static org.openkilda.bluegreen.kafka.Utils.CONSUMER_ZOOKEEPER_CONNECTION_STRING_PROPERTY;\n+import static org.openkilda.bluegreen.kafka.Utils.PRODUCER_COMPONENT_NAME_PROPERTY;\n+import static org.openkilda.bluegreen.kafka.Utils.PRODUCER_RUN_ID_PROPERTY;\n+import static org.openkilda.bluegreen.kafka.Utils.PRODUCER_ZOOKEEPER_CONNECTION_STRING_PROPERTY;\n+\n+import org.openkilda.bluegreen.kafka.interceptors.VersioningConsumerInterceptor;\n+import org.openkilda.bluegreen.kafka.interceptors.VersioningProducerInterceptor;\n+\n import org.apache.kafka.clients.admin.NewTopic;\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.clients.producer.ProducerConfig;\n import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.boot.autoconfigure.kafka.KafkaProperties;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Configuration;\n import org.springframework.kafka.config.TopicBuilder;\n+import org.springframework.kafka.core.ConsumerFactory;\n+import org.springframework.kafka.core.DefaultKafkaConsumerFactory;\n+import org.springframework.kafka.core.DefaultKafkaProducerFactory;\n+import org.springframework.kafka.core.ProducerFactory;\n+\n+import java.util.Map;\n \n @Configuration\n public class KafkaConfig {\n+    public static final String SERVER_42_RUN_ID = \"server42-run-id\";\n+    public static final String SERVER_42_STATS_COMPONENT_NAME = \"server42-stats\";\n+\n+    @Value(\"${zookeeper.connect_string}\")\n+    private String zookeeperConnectString;\n+\n     @Bean\n     public NewTopic toStorm(@Value(\"${openkilda.server42.stats.kafka.topic.flowrtt.to_storm}\") String name) {\n         return TopicBuilder.name(name).build();\n     }\n+\n+    @Bean\n+    public ConsumerFactory<?, ?> kafkaConsumerFactory(KafkaProperties properties) {\n+        Map<String, Object> updatedProperties = properties.buildConsumerProperties();\n+        updatedProperties.put(ConsumerConfig.INTERCEPTOR_CLASSES_CONFIG, VersioningConsumerInterceptor.class.getName());\n+        updatedProperties.put(CONSUMER_COMPONENT_NAME_PROPERTY, SERVER_42_STATS_COMPONENT_NAME);\n+        updatedProperties.put(CONSUMER_RUN_ID_PROPERTY, SERVER_42_RUN_ID);\n+        updatedProperties.put(CONSUMER_ZOOKEEPER_CONNECTION_STRING_PROPERTY, zookeeperConnectString);\n+        return new DefaultKafkaConsumerFactory<>(updatedProperties);\n+    }\n+\n+    @Bean\n+    public ProducerFactory<?, ?> kafkaProducerFactory(KafkaProperties properties) {", "originalCommit": "3e13b4b55acf0075d8b00eb2e3145e080ab1027b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI4MTM0NA==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r538281344", "bodyText": "fixed", "author": "niksv", "createdAt": "2020-12-08T11:53:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzNjczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzNjg2MA==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r538236860", "bodyText": "move it config files", "author": "nikitamarchenko", "createdAt": "2020-12-08T10:50:27Z", "path": "src-java/server42/server42-control/src/main/java/org/openkilda/server42/control/kafka/KafkaConfig.java", "diffHunk": "@@ -49,4 +73,24 @@ public NewTopic fromStorm(@Value(\"${openkilda.server42.control.kafka.topic.from_\n         factory.setRecordFilterStrategy(kafkaRecordFilter);\n         return factory;\n     }\n+\n+    @Bean\n+    public ConsumerFactory<?, ?> kafkaConsumerFactory(KafkaProperties properties) {", "originalCommit": "3e13b4b55acf0075d8b00eb2e3145e080ab1027b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI4MTIyNw==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r538281227", "bodyText": "fixed", "author": "niksv", "createdAt": "2020-12-08T11:53:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzNjg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzNjk0Nw==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r538236947", "bodyText": "move it config files", "author": "nikitamarchenko", "createdAt": "2020-12-08T10:50:35Z", "path": "src-java/server42/server42-control/src/main/java/org/openkilda/server42/control/kafka/KafkaConfig.java", "diffHunk": "@@ -49,4 +73,24 @@ public NewTopic fromStorm(@Value(\"${openkilda.server42.control.kafka.topic.from_\n         factory.setRecordFilterStrategy(kafkaRecordFilter);\n         return factory;\n     }\n+\n+    @Bean\n+    public ConsumerFactory<?, ?> kafkaConsumerFactory(KafkaProperties properties) {\n+        Map<String, Object> updatedProperties = properties.buildConsumerProperties();\n+        updatedProperties.put(ConsumerConfig.INTERCEPTOR_CLASSES_CONFIG, VersioningConsumerInterceptor.class.getName());\n+        updatedProperties.put(CONSUMER_COMPONENT_NAME_PROPERTY, SERVER_42_CONTROL_COMPONENT_NAME);\n+        updatedProperties.put(CONSUMER_RUN_ID_PROPERTY, SERVER_42_RUN_ID);\n+        updatedProperties.put(CONSUMER_ZOOKEEPER_CONNECTION_STRING_PROPERTY, zookeeperConnectString);\n+        return new DefaultKafkaConsumerFactory<>(updatedProperties);\n+    }\n+\n+    @Bean\n+    public ProducerFactory<?, ?> kafkaProducerFactory(KafkaProperties properties) {", "originalCommit": "3e13b4b55acf0075d8b00eb2e3145e080ab1027b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI4MTQ1OA==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r538281458", "bodyText": "fixed", "author": "niksv", "createdAt": "2020-12-08T11:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzNjk0Nw=="}], "type": "inlineReview"}, {"oid": "749cbeb0c7ee90e84e5bbb9c30be3a03e7f0517f", "url": "https://github.com/telstra/open-kilda/commit/749cbeb0c7ee90e84e5bbb9c30be3a03e7f0517f", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-08T11:52:01Z", "type": "forcePushed"}, {"oid": "c42db9fb4ea0da5562e555df0c1b24bf3f8d77f4", "url": "https://github.com/telstra/open-kilda/commit/c42db9fb4ea0da5562e555df0c1b24bf3f8d77f4", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-09T14:32:29Z", "type": "forcePushed"}, {"oid": "6ea225b74b18ea5c591b01dfc22026490d91568d", "url": "https://github.com/telstra/open-kilda/commit/6ea225b74b18ea5c591b01dfc22026490d91568d", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-10T07:22:34Z", "type": "forcePushed"}, {"oid": "b6ffc009a9b9a1028b95d39a311a55c4156fd8c8", "url": "https://github.com/telstra/open-kilda/commit/b6ffc009a9b9a1028b95d39a311a55c4156fd8c8", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-11T11:23:47Z", "type": "forcePushed"}, {"oid": "60a0af1f3fb34fdce8b9c8bd82e70a0ccac05c09", "url": "https://github.com/telstra/open-kilda/commit/60a0af1f3fb34fdce8b9c8bd82e70a0ccac05c09", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-11T12:14:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ1MDY3Mg==", "url": "https://github.com/telstra/open-kilda/pull/3872#discussion_r542450672", "bodyText": "I would like to switch into \"error\" state and inject error instead of receive records into onConsume i.e. if the interceptor is in an error state it must drop all records passed into onConsume and inject one(or one per partition) error message with all required details.\nSo our code can read this message and report it in a controlled way. It should be much safer from a storm point of view - i.e. produce errors on received records, instead of an uncontrolled endless restart of workers.", "author": "surabujin", "createdAt": "2020-12-14T14:59:57Z", "path": "src-java/blue-green/src/main/java/org/openkilda/bluegreen/kafka/interceptors/VersioningConsumerInterceptor.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.bluegreen.kafka.interceptors;\n+\n+import static java.lang.String.format;\n+import static org.openkilda.bluegreen.kafka.Utils.CONSUMER_COMPONENT_NAME_PROPERTY;\n+import static org.openkilda.bluegreen.kafka.Utils.CONSUMER_RUN_ID_PROPERTY;\n+import static org.openkilda.bluegreen.kafka.Utils.CONSUMER_ZOOKEEPER_CONNECTION_STRING_PROPERTY;\n+import static org.openkilda.bluegreen.kafka.Utils.MESSAGE_VERSION_HEADER;\n+import static org.openkilda.bluegreen.kafka.Utils.getValue;\n+\n+import com.google.common.collect.Lists;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.kafka.clients.consumer.ConsumerInterceptor;\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.apache.kafka.clients.consumer.OffsetAndMetadata;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.header.Header;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Slf4j\n+public class VersioningConsumerInterceptor<K, V> extends VersioningInterceptorBase\n+        implements ConsumerInterceptor<K, V> {\n+\n+    public VersioningConsumerInterceptor() {\n+        log.debug(\"Initializing VersioningConsumerInterceptor\");\n+    }\n+\n+    @Override\n+    public ConsumerRecords<K, V> onConsume(ConsumerRecords<K, V> records) {\n+        if (!watchDog.isConnectionAlive()) {\n+            if (isZooKeeperConnectTimeoutPassed()) {\n+                log.error(\"Component {} with id {} tries to reconnect to ZooKeeper with connection string: {}\",\n+                        componentName, runId, connectionString);\n+                cantConnectToZooKeeperTimestamp = Instant.now();\n+            }\n+            watchDog.init(); // try to reconnect\n+        }\n+\n+        Map<TopicPartition, List<ConsumerRecord<K, V>>> filteredRecordMap = new HashMap<>();\n+\n+        for (TopicPartition partition : records.partitions()) {\n+            List<ConsumerRecord<K, V>> filteredRecords = new ArrayList<>();\n+\n+            for (ConsumerRecord<K, V> record : records.records(partition)) {\n+                if (checkRecordVersion(record)) {\n+                    filteredRecords.add(record);\n+                }\n+            }\n+\n+            filteredRecordMap.put(partition, filteredRecords);\n+        }\n+        return new ConsumerRecords<>(filteredRecordMap);\n+    }\n+\n+    private boolean checkRecordVersion(ConsumerRecord<K, V> record) {\n+        List<Header> headers = Lists.newArrayList(record.headers().headers(MESSAGE_VERSION_HEADER));\n+\n+        if (version == null) {\n+            if (isVersionTimeoutPassed()) {\n+                // We will write this log every 60 seconds to do not spam in logs\n+                log.warn(\"Messaging version is not set for component {} with id {}. Skip record {}\",\n+                        componentName, runId, record);\n+                versionIsNotSetTimestamp = Instant.now();\n+            }\n+            return false;\n+        }\n+\n+        if (headers.isEmpty()) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Missed {} header for record {}\", MESSAGE_VERSION_HEADER, record);\n+            }\n+            return false;\n+        }\n+\n+        if (headers.size() > 1) {\n+            log.warn(\"Found more than one {} headers for record {}\", MESSAGE_VERSION_HEADER, record);\n+            return false;\n+        }\n+\n+        if (!Arrays.equals(version, headers.get(0).value())) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Skip record {} with version {}. Target version is {}\",\n+                        record, new String(headers.get(0).value()), getVersionAsString());\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void configure(Map<String, ?> configs) {\n+        connectionString = getValue(configs, CONSUMER_ZOOKEEPER_CONNECTION_STRING_PROPERTY, String.class);", "originalCommit": "60a0af1f3fb34fdce8b9c8bd82e70a0ccac05c09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5016a513cea391d87199073873bda51a47a60608", "url": "https://github.com/telstra/open-kilda/commit/5016a513cea391d87199073873bda51a47a60608", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-17T07:30:54Z", "type": "forcePushed"}, {"oid": "45302dbdba1056f0515c850e9c50512a23c06c96", "url": "https://github.com/telstra/open-kilda/commit/45302dbdba1056f0515c850e9c50512a23c06c96", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-17T12:27:17Z", "type": "forcePushed"}, {"oid": "0d5ea4be81046c8479f21de1b88f35a6cbdb1b5d", "url": "https://github.com/telstra/open-kilda/commit/0d5ea4be81046c8479f21de1b88f35a6cbdb1b5d", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-21T18:54:48Z", "type": "forcePushed"}, {"oid": "a28d94de98958b7ee3d97a52eb4ad40c36894eee", "url": "https://github.com/telstra/open-kilda/commit/a28d94de98958b7ee3d97a52eb4ad40c36894eee", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-21T19:00:34Z", "type": "forcePushed"}, {"oid": "7aad382db3e02530a95564a4be1086ca2a4f9f34", "url": "https://github.com/telstra/open-kilda/commit/7aad382db3e02530a95564a4be1086ca2a4f9f34", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-21T19:18:33Z", "type": "forcePushed"}, {"oid": "bc7fc3087816094130f7dcf351f3d5c50242978b", "url": "https://github.com/telstra/open-kilda/commit/bc7fc3087816094130f7dcf351f3d5c50242978b", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-22T14:50:13Z", "type": "forcePushed"}, {"oid": "9e14c93848284033f16de1f23814cd41ff1b21f7", "url": "https://github.com/telstra/open-kilda/commit/9e14c93848284033f16de1f23814cd41ff1b21f7", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-25T09:02:58Z", "type": "forcePushed"}, {"oid": "c7c6d01900ce1456bf7b5456900a749faa46d9ab", "url": "https://github.com/telstra/open-kilda/commit/c7c6d01900ce1456bf7b5456900a749faa46d9ab", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-25T09:56:46Z", "type": "commit"}, {"oid": "c7c6d01900ce1456bf7b5456900a749faa46d9ab", "url": "https://github.com/telstra/open-kilda/commit/c7c6d01900ce1456bf7b5456900a749faa46d9ab", "message": "Added kafka message versioning with ZooKeeper", "committedDate": "2020-12-25T09:56:46Z", "type": "forcePushed"}]}