{"pr_number": 13653, "pr_title": "WFLY-13973 Writing default-mdb-instance-pool to ejb3 subsystem throws\u2026", "pr_createdAt": "2020-10-16T03:03:56Z", "pr_url": "https://github.com/wildfly/wildfly/pull/13653", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY1MjY2Nw==", "url": "https://github.com/wildfly/wildfly/pull/13653#discussion_r507652667", "bodyText": "@chengfang I think if you execute a :write-attribute with the same value that was there, you end up removing the capability requirement set a few lines above. Perhaps you need some guard to check that the new and old requirement names are not the same?\nEssentially AbstractWriteAttributeHandler doesn't do any comparison itself of the old and new values to check", "author": "kabir", "createdAt": "2020-10-19T10:51:55Z", "path": "ejb3/src/main/java/org/jboss/as/ejb3/subsystem/EJB3SubsystemDefaultPoolWriteHandler.java", "diffHunk": "@@ -78,44 +81,63 @@ protected void recordCapabilitiesAndRequirements(OperationContext context, Attri\n         ModelNode model = resource.getModel();\n \n         // de-register the default bean instance pool capability requirement on the default bean instance pool that supports it\n-        if (poolAttribute.getName().equals(DEFAULT_SLSB_INSTANCE_POOL) || model.hasDefined(DEFAULT_SLSB_INSTANCE_POOL)) {\n-\n-            // NOTE: the new value may contain an expression, so we need to resolve it first\n-            ModelNode resolvedNewValue = new ModelNode();\n-            try {\n-                resolvedNewValue = context.resolveExpressions(newValue);\n-\n-                // register the new requirement\n-                String newSLSBRequirementName = RuntimeCapability.buildDynamicCapabilityName(STRICT_MAX_POOL_CONFIG_CAPABILITY_NAME, resolvedNewValue.asString());\n-                context.registerAdditionalCapabilityRequirement(newSLSBRequirementName, DEFAULT_SLSB_POOL_CONFIG_CAPABILITY_NAME, DEFAULT_SLSB_INSTANCE_POOL);\n-            } catch(OperationFailedException ofe) {\n-                // if the new value cannot be resolved, deregister the old value only (in the finally clause)\n-                EjbLogger.ROOT_LOGGER.defaultPoolExpressionCouldNotBeResolved(DEFAULT_SLSB_INSTANCE_POOL, model.get(DEFAULT_SLSB_INSTANCE_POOL).asString());\n-\n-            } finally {\n-                // de-register the old requirement\n-                String oldSLSBRequirementName = RuntimeCapability.buildDynamicCapabilityName(STRICT_MAX_POOL_CONFIG_CAPABILITY_NAME, oldValue.asString());\n-                context.deregisterCapabilityRequirement(oldSLSBRequirementName, DEFAULT_SLSB_POOL_CONFIG_CAPABILITY_NAME, DEFAULT_SLSB_INSTANCE_POOL);\n+        if (poolAttribute.getName().equals(DEFAULT_SLSB_INSTANCE_POOL)) {\n+            if (oldValue.isDefined()) {\n+\n+                // NOTE: the new value may contain an expression, so we need to resolve it first\n+                try {\n+                    if (newValue.isDefined()) {\n+                        ModelNode resolvedNewValue = context.resolveExpressions(newValue);\n+\n+                        // register the new requirement\n+                        String newSLSBRequirementName = RuntimeCapability.buildDynamicCapabilityName(STRICT_MAX_POOL_CONFIG_CAPABILITY_NAME, resolvedNewValue.asString());\n+                        context.registerAdditionalCapabilityRequirement(newSLSBRequirementName, DEFAULT_SLSB_POOL_CONFIG_CAPABILITY_NAME, DEFAULT_SLSB_INSTANCE_POOL);\n+                    }\n+                } catch (OperationFailedException ofe) {\n+                    // if the new value cannot be resolved, deregister the old value only (in the finally clause)\n+                    EjbLogger.ROOT_LOGGER.defaultPoolExpressionCouldNotBeResolved(DEFAULT_SLSB_INSTANCE_POOL, model.get(DEFAULT_SLSB_INSTANCE_POOL).asString());\n+                } finally {\n+                    // de-register the old requirement\n+                    String oldSLSBRequirementName = RuntimeCapability.buildDynamicCapabilityName(STRICT_MAX_POOL_CONFIG_CAPABILITY_NAME, oldValue.asString());\n+                    context.deregisterCapabilityRequirement(oldSLSBRequirementName, DEFAULT_SLSB_POOL_CONFIG_CAPABILITY_NAME, DEFAULT_SLSB_INSTANCE_POOL);", "originalCommit": "c828176ac576f7ec065973a61d4bbe7ec83703aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk0ODkzNA==", "url": "https://github.com/wildfly/wildfly/pull/13653#discussion_r507948934", "bodyText": "I added a check to compare old and new requirement name, and only de-register it if they differ. I did it for both default-slsb-instance-pool and default-mdb-instance-pool.", "author": "chengfang", "createdAt": "2020-10-19T17:53:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY1MjY2Nw=="}], "type": "inlineReview"}, {"oid": "7c53c4f1db35e25f4303b46b48fffa678b081879", "url": "https://github.com/wildfly/wildfly/commit/7c53c4f1db35e25f4303b46b48fffa678b081879", "message": "WFLY-13973 Writing default-mdb-instance-pool to ejb3 subsystem throws IllegalStateException", "committedDate": "2020-10-19T17:50:13Z", "type": "commit"}, {"oid": "7c53c4f1db35e25f4303b46b48fffa678b081879", "url": "https://github.com/wildfly/wildfly/commit/7c53c4f1db35e25f4303b46b48fffa678b081879", "message": "WFLY-13973 Writing default-mdb-instance-pool to ejb3 subsystem throws IllegalStateException", "committedDate": "2020-10-19T17:50:13Z", "type": "forcePushed"}]}