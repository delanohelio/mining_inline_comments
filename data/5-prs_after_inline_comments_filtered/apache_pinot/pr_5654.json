{"pr_number": 5654, "pr_title": "[Part 1] Add geo support", "pr_createdAt": "2020-07-02T21:20:46Z", "pr_url": "https://github.com/apache/pinot/pull/5654", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3MjIzMQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449272231", "bodyText": "plz ignore this, seems some search/replace error", "author": "yupeng9", "createdAt": "2020-07-02T21:23:22Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/broker/helix/BrokerUserDefinedMessageHandlerFactory.java", "diffHunk": "@@ -96,7 +96,7 @@ public HelixTaskResult handleMessage() {\n \n     @Override\n     public void onError(Exception e, ErrorCode code, ErrorType type) {\n-      LOGGER.error(\"Got error while refreshing segment: {} of table: {} (error code: {}, error type: {})\", _segmentName,", "originalCommit": "f84b1a9c9e9213c7f37aafd77ea1b4000e4cfb60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDQ0MA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449800440", "bodyText": "what does this function do? please add java docs", "author": "kishoreg", "createdAt": "2020-07-04T19:47:33Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class ConstructFromTextFunction extends BaseTransformFunction {", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk5NDk1MA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r450994950", "bodyText": "Added. This is an abstract class for implementing the geo constructor functions like StGeomFromText and StGeogFromText", "author": "yupeng9", "createdAt": "2020-07-07T16:32:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDQ4MQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449800481", "bodyText": "function -> functions", "author": "kishoreg", "createdAt": "2020-07-04T19:48:16Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAsTextFunction.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzNzExMA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449837110", "bodyText": "hmm, then I cannot define scalar function in this package for inbuilt transformation functions.", "author": "yupeng9", "createdAt": "2020-07-05T05:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDU3OA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449800578", "bodyText": "sweet", "author": "kishoreg", "createdAt": "2020-07-04T19:49:42Z", "path": "pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java", "diffHunk": "@@ -87,11 +90,14 @@ public void onMessage(String message) {\n                   }\n \n                   JsonNode group = messageJSON.get(\"group\");\n+                  System.out.println(String.format(\"reading group %s\", group.get(\"group_id\")));\n                   if (group != null) {\n                     extracted.set(\"group_city\", group.get(\"group_city\"));\n                     extracted.set(\"group_country\", group.get(\"group_country\"));\n                     extracted.set(\"group_id\", group.get(\"group_id\"));\n                     extracted.set(\"group_name\", group.get(\"group_name\"));\n+                    extracted.set(\"group_lat\", group.get(\"group_lat\"));", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDYwMg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449800602", "bodyText": "logger?", "author": "kishoreg", "createdAt": "2020-07-04T19:50:05Z", "path": "pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java", "diffHunk": "@@ -101,18 +107,18 @@ public void onMessage(String message) {\n                     producer.produce(\"meetupRSVPEvents\", extracted.toString().getBytes(StandardCharsets.UTF_8));\n                   }\n                 } catch (Exception e) {\n-                  //LOGGER.error(\"error processing raw event \", e);\n+                  LOGGER.error(\"error processing raw event \", e);\n                 }\n               }\n             });\n             session.getBasicRemote().sendText(\"\");\n           } catch (IOException e) {\n-            //LOGGER.error(\"found an event where data did not have all the fields, don't care about for quickstart\");\n+            LOGGER.error(\"found an event where data did not have all the fields, don't care about for quickstart\", e);\n           }\n         }\n       }, cec, new URI(\"ws://stream.meetup.com/2/rsvps\"));\n     } catch (Exception e) {\n-      //e.printStackTrace();\n+      e.printStackTrace();", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgyNjQ4Mg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449826482", "bodyText": "Tab space indicates not following Pinot code-styling.", "author": "mayankshriv", "createdAt": "2020-07-05T03:09:56Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.lang.Double.NaN;\n+import static java.lang.Double.isNaN;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_FACTORY;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_GET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SRID;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ */\n+public class GeometrySerde extends Serializer {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgyNjU1OQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449826559", "bodyText": "Initialize list with size if known.", "author": "mayankshriv", "createdAt": "2020-07-05T03:11:02Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.lang.Double.NaN;\n+import static java.lang.Double.isNaN;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_FACTORY;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_GET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SRID;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ */\n+public class GeometrySerde extends Serializer {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n+\n+    @Override\n+    public void write(Kryo kryo, Output output, Object object) {\n+        if (!(object instanceof Geometry)) {\n+            throw new UnsupportedOperationException(\"Cannot serialize object of type \" +\n+                    object.getClass().getName());\n+        }\n+        writeGeometry(output, (Geometry) object);\n+    }\n+\n+    @Override\n+    public Object read(Kryo kryo, Input input, Class aClass) {\n+        byte typeByte = input.readByte();\n+        GeometrySerializationType type = readGeometryType(typeByte);\n+        GeometryFactory factory = getGeometryFactory(typeByte);\n+\n+        return readGeometry(input, type, factory);\n+    }\n+\n+    private Geometry readGeometry(Input input, GeometrySerializationType type, GeometryFactory factory) {\n+        switch (type) {\n+            case POINT:\n+                return readPoint(input, factory);\n+            case MULTI_POINT:\n+                return readMultiPoint(input, factory);\n+            case LINE_STRING:\n+                return readPolyline(input, false, factory);\n+            case MULTI_LINE_STRING:\n+                return readPolyline(input, true, factory);\n+            case POLYGON:\n+                return readPolygon(input, false, factory);\n+            case MULTI_POLYGON:\n+                return readPolygon(input, true, factory);\n+            case GEOMETRY_COLLECTION:\n+                return readGeometryCollection(input, factory);\n+            default:\n+                throw new UnsupportedOperationException(\"Unexpected type: \" + type);\n+        }\n+    }\n+\n+    private Point readPoint(Input input, GeometryFactory factory) {\n+        Coordinate coordinates = readCoordinate(input);\n+        if (isNaN(coordinates.x) || isNaN(coordinates.y)) {\n+            return factory.createPoint();\n+        }\n+        return factory.createPoint(coordinates);\n+    }\n+\n+    private Coordinate readCoordinate(Input input) {\n+        return new Coordinate(input.readDouble(), input.readDouble());\n+    }\n+\n+    private Coordinate[] readCoordinates(Input input, int count) {\n+        requireNonNull(input, \"input is null\");\n+        verify(count > 0);\n+        Coordinate[] coordinates = new Coordinate[count];\n+        for (int i = 0; i < count; i++) {\n+            coordinates[i] = readCoordinate(input);\n+        }\n+        return coordinates;\n+    }\n+\n+    private Geometry readMultiPoint(Input input, GeometryFactory factory) {\n+        int pointCount = input.readInt();\n+        Point[] points = new Point[pointCount];\n+        for (int i = 0; i < pointCount; i++) {\n+            points[i] = readPoint(input, factory);\n+        }\n+        return factory.createMultiPoint(points);\n+    }\n+\n+    private GeometrySerializationType readGeometryType(byte typeByte) {\n+        return GeometrySerializationType.fromID(typeByte & GEOGRAPHY_GET_MASK);\n+    }\n+\n+    private Geometry readPolyline(Input input, boolean multitype, GeometryFactory factory) {\n+        int partCount = input.readInt();\n+        if (partCount == 0) {\n+            if (multitype) {\n+                return factory.createMultiLineString();\n+            }\n+            return factory.createLineString();\n+        }\n+\n+        int pointCount = input.readInt();\n+        int[] startIndexes = new int[partCount];\n+        for (int i = 0; i < partCount; i++) {\n+            startIndexes[i] = input.readInt();\n+        }\n+\n+        int[] partLengths = new int[partCount];\n+        if (partCount > 1) {\n+            partLengths[0] = startIndexes[1];\n+            for (int i = 1; i < partCount - 1; i++) {\n+                partLengths[i] = startIndexes[i + 1] - startIndexes[i];\n+            }\n+        }\n+        partLengths[partCount - 1] = pointCount - startIndexes[partCount - 1];\n+\n+        LineString[] lineStrings = new LineString[partCount];\n+\n+        for (int i = 0; i < partCount; i++) {\n+            lineStrings[i] = factory.createLineString(readCoordinates(input, partLengths[i]));\n+        }\n+\n+        if (multitype) {\n+            return factory.createMultiLineString(lineStrings);\n+        }\n+        verify(lineStrings.length == 1);\n+        return lineStrings[0];\n+    }\n+\n+    private Geometry readPolygon(Input input, boolean multitype, GeometryFactory factory) {\n+        int partCount = input.readInt();\n+        if (partCount == 0) {\n+            if (multitype) {\n+                return factory.createMultiPolygon();\n+            }\n+            return factory.createPolygon();\n+        }\n+\n+        int pointCount = input.readInt();\n+        int[] startIndexes = new int[partCount];\n+        for (int i = 0; i < partCount; i++) {\n+            startIndexes[i] = input.readInt();\n+        }\n+\n+        int[] partLengths = new int[partCount];\n+        if (partCount > 1) {\n+            partLengths[0] = startIndexes[1];\n+            for (int i = 1; i < partCount - 1; i++) {\n+                partLengths[i] = startIndexes[i + 1] - startIndexes[i];\n+            }\n+        }\n+        partLengths[partCount - 1] = pointCount - startIndexes[partCount - 1];\n+\n+        LinearRing shell = null;\n+        List<LinearRing> holes = new ArrayList<>();", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDE0OA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830148", "bodyText": "Please use Pinot code style (name of member variables starts with _ to avoid qualifying with this.", "author": "mayankshriv", "createdAt": "2020-07-05T03:38:55Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.apache.pinot.core.geospatial.GeometryType;\n+\n+public enum GeometrySerializationType\n+{\n+    POINT(0, GeometryType.POINT),\n+    MULTI_POINT(1, GeometryType.MULTI_POINT),\n+    LINE_STRING(2, GeometryType.LINE_STRING),\n+    MULTI_LINE_STRING(3, GeometryType.MULTI_LINE_STRING),\n+    POLYGON(4, GeometryType.POLYGON),\n+    MULTI_POLYGON(5, GeometryType.MULTI_POLYGON),\n+    GEOMETRY_COLLECTION(6, GeometryType.GEOMETRY_COLLECTION),\n+    ENVELOPE(7, GeometryType.POLYGON);\n+\n+    private final int id;\n+    private final GeometryType geometryType;\n+\n+    GeometrySerializationType(int id, GeometryType geometryType)\n+    {\n+        this.id = id;", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyODgwMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r450628803", "bodyText": "Sure. thanks.", "author": "yupeng9", "createdAt": "2020-07-07T06:02:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDMxMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830313", "bodyText": "Consider using a Static Map, if this list has a chance to grow.", "author": "mayankshriv", "createdAt": "2020-07-05T03:41:04Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.apache.pinot.core.geospatial.GeometryType;\n+\n+public enum GeometrySerializationType\n+{\n+    POINT(0, GeometryType.POINT),\n+    MULTI_POINT(1, GeometryType.MULTI_POINT),\n+    LINE_STRING(2, GeometryType.LINE_STRING),\n+    MULTI_LINE_STRING(3, GeometryType.MULTI_LINE_STRING),\n+    POLYGON(4, GeometryType.POLYGON),\n+    MULTI_POLYGON(5, GeometryType.MULTI_POLYGON),\n+    GEOMETRY_COLLECTION(6, GeometryType.GEOMETRY_COLLECTION),\n+    ENVELOPE(7, GeometryType.POLYGON);\n+\n+    private final int id;\n+    private final GeometryType geometryType;\n+\n+    GeometrySerializationType(int id, GeometryType geometryType)\n+    {\n+        this.id = id;\n+        this.geometryType = geometryType;\n+    }\n+\n+    public int id()\n+    {\n+        return id;\n+    }\n+\n+    public GeometryType getGeometryType()\n+    {\n+        return geometryType;\n+    }\n+\n+    public static GeometrySerializationType fromID(int id)\n+    {\n+        switch (id) {", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyOTQ3OA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r450629478", "bodyText": "This list is unlikely to grow, given the OGC geo is a well-defined standard per https://www.ogc.org/standards/sfa", "author": "yupeng9", "createdAt": "2020-07-07T06:04:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDM1MA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830350", "bodyText": "Please add Java doc to all classes and their public methods.", "author": "mayankshriv", "createdAt": "2020-07-05T03:41:36Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializer.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Geometry;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+\n+public class GeometrySerializer {", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDQ2Mg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830462", "bodyText": "Utils.rethrow will preserve the original exception.", "author": "mayankshriv", "createdAt": "2020-07-05T03:42:57Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class ConstructFromTextFunction extends BaseTransformFunction {\n+    private TransformFunction _transformFunction;\n+    private byte[][] _results;\n+    private WKTReader _reader;\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        Preconditions\n+                .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\",\n+                        getName());\n+        TransformFunction transformFunction = arguments.get(0);\n+        Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+                \"The argument must be single-valued for transform function: %s\", getName());\n+        _transformFunction = transformFunction;\n+        _reader = new WKTReader(getGeometryFactory());\n+    }\n+\n+    abstract protected GeometryFactory getGeometryFactory();\n+\n+    @Override\n+    public TransformResultMetadata getResultMetadata() {\n+        return BYTES_SV_NO_DICTIONARY_METADATA;\n+    }\n+\n+    @Override\n+    public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+        if (_results == null) {\n+            _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+        }\n+        String[] argumentValues = _transformFunction.transformToStringValuesSV(projectionBlock);\n+        int length = projectionBlock.getNumDocs();\n+        for (int i = 0; i < length; i++) {\n+            try {\n+                Geometry geometry = _reader.read(argumentValues[i]);\n+                _results[i] = GeometrySerializer.serialize(geometry);\n+            } catch (ParseException e) {\n+                throw new RuntimeException(String.format(\"Failed to parse geometry from String %s\", argumentValues[i]));", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAyNzIyMQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r451027221", "bodyText": "Good to see this util", "author": "yupeng9", "createdAt": "2020-07-07T17:26:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDczMQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830731", "bodyText": "Would be good to add the benchmark results in the PR description.", "author": "mayankshriv", "createdAt": "2020-07-05T03:47:55Z", "path": "pinot-core/src/test/java/org/apache/pinot/core/geospatial/serde/BenchmarkSerde.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.io.Resources;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+\n+import static com.google.common.io.Resources.getResource;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.openjdk.jmh.annotations.Mode.Throughput;\n+\n+import static org.apache.pinot.core.geospatial.serde.GeometrySerializer.serialize;\n+import static org.apache.pinot.core.geospatial.serde.GeometrySerializer.deserialize;\n+\n+@State(Scope.Thread)\n+@Fork(2)\n+@Warmup(iterations = 3, time = 3, timeUnit = SECONDS)\n+@Measurement(iterations = 5, time = 4, timeUnit = SECONDS)\n+@OutputTimeUnit(SECONDS)\n+@BenchmarkMode(Throughput)\n+public class BenchmarkSerde", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAyNzcyNw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r451027727", "bodyText": "Sounds good", "author": "yupeng9", "createdAt": "2020-07-07T17:27:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDczMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA2ODk4Nw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r451068987", "bodyText": "Added https://gist.github.com/yupeng9/8e2b081ffb372593492ebb6a41da97fd to the description", "author": "yupeng9", "createdAt": "2020-07-07T18:41:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDg3Nw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830877", "bodyText": "Unsure if LOGGER should be used here?", "author": "mayankshriv", "createdAt": "2020-07-05T03:50:23Z", "path": "pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java", "diffHunk": "@@ -87,11 +90,14 @@ public void onMessage(String message) {\n                   }\n \n                   JsonNode group = messageJSON.get(\"group\");\n+                  System.out.println(String.format(\"reading group %s\", group.get(\"group_id\")));", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAyOTg3Mg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r451029872", "bodyText": "removed. it was for debugging purpose.", "author": "yupeng9", "createdAt": "2020-07-07T17:31:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0Mjg1MA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r451242850", "bodyText": "Please follow the Pinot coding convention of using underscore as the prefix for member variables. Same for other classes", "author": "Jackie-Jiang", "createdAt": "2020-07-08T02:14:56Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, \"ST_Point\"),\n+  MULTI_POINT(true, \"ST_MultiPoint\"),\n+  LINE_STRING(false, \"ST_LineString\"),\n+  MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n+  POLYGON(false, \"ST_Polygon\"),\n+  MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n+\n+  private final boolean multitype;", "originalCommit": "6eb63ccd911373dbfd817f6a680c553ee2a6a44d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MzAyMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r451243023", "bodyText": "As an example of Pinot coding convention\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                this.multitype = multitype;\n          \n          \n            \n                _multitype = multitype;", "author": "Jackie-Jiang", "createdAt": "2020-07-08T02:15:41Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, \"ST_Point\"),\n+  MULTI_POINT(true, \"ST_MultiPoint\"),\n+  LINE_STRING(false, \"ST_LineString\"),\n+  MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n+  POLYGON(false, \"ST_Polygon\"),\n+  MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n+\n+  private final boolean multitype;\n+  private final String name;\n+\n+  GeometryType(boolean multitype, String name) {\n+    this.multitype = multitype;", "originalCommit": "6eb63ccd911373dbfd817f6a680c553ee2a6a44d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NjgxNQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r452386815", "bodyText": "Thanks for taking a pass, updated the style", "author": "yupeng9", "createdAt": "2020-07-09T17:45:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MzAyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxOTUxNg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r452419516", "bodyText": "@Jackie-Jiang any reason we set checkstyle severity to warning but not error. I saw we have such a rule for member variable, but the maven checkstyle does not fail the build", "author": "yupeng9", "createdAt": "2020-07-09T18:45:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MzAyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0ODQzOQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r452448439", "bodyText": "Good suggestion. We can switch it to error once we fixed all the existing code with wrong code styles. Opened issue #5675 to track this", "author": "Jackie-Jiang", "createdAt": "2020-07-09T19:42:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MzAyMw=="}], "type": "inlineReview"}, {"oid": "5329f2fb56cf3b7c43c11371f91f39d98be5df39", "url": "https://github.com/apache/pinot/commit/5329f2fb56cf3b7c43c11371f91f39d98be5df39", "message": "add geo support\n\n - add geo-spatial data model\n - add serde\n - add benchmark\n - add geospatial functions", "committedDate": "2020-07-16T03:56:34Z", "type": "commit"}, {"oid": "e778f612067ad12f6b007339b2b413003b4efa54", "url": "https://github.com/apache/pinot/commit/e778f612067ad12f6b007339b2b413003b4efa54", "message": "cleanup", "committedDate": "2020-07-16T03:56:34Z", "type": "commit"}, {"oid": "b4cf2ad048c6127ce5f69350c5cd8f2577455a64", "url": "https://github.com/apache/pinot/commit/b4cf2ad048c6127ce5f69350c5cd8f2577455a64", "message": "revert id/code change", "committedDate": "2020-07-16T03:56:36Z", "type": "commit"}, {"oid": "2ac9fe3a6ecc078d9cc69fa5a2b7f386a3c364ea", "url": "https://github.com/apache/pinot/commit/2ac9fe3a6ecc078d9cc69fa5a2b7f386a3c364ea", "message": "more cleanup", "committedDate": "2020-07-16T03:57:20Z", "type": "commit"}, {"oid": "d548d2488bb52bd2915c89dfa7782fd030e381c5", "url": "https://github.com/apache/pinot/commit/d548d2488bb52bd2915c89dfa7782fd030e381c5", "message": "address comments", "committedDate": "2020-07-16T03:57:20Z", "type": "commit"}, {"oid": "0ebb9c5078119d7d8ad7918d9221ab775995b00a", "url": "https://github.com/apache/pinot/commit/0ebb9c5078119d7d8ad7918d9221ab775995b00a", "message": "more styling", "committedDate": "2020-07-16T03:57:20Z", "type": "commit"}, {"oid": "b14d7c53eb23b9b94a9ec6fe902edcf87d053201", "url": "https://github.com/apache/pinot/commit/b14d7c53eb23b9b94a9ec6fe902edcf87d053201", "message": "Change the relationship function not applicable to geographical functions", "committedDate": "2020-07-17T01:57:30Z", "type": "commit"}, {"oid": "b14d7c53eb23b9b94a9ec6fe902edcf87d053201", "url": "https://github.com/apache/pinot/commit/b14d7c53eb23b9b94a9ec6fe902edcf87d053201", "message": "Change the relationship function not applicable to geographical functions", "committedDate": "2020-07-17T01:57:30Z", "type": "forcePushed"}, {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "url": "https://github.com/apache/pinot/commit/bb51f43a4419008e9a727d7c8355330d232ec9b9", "message": "fix test failure", "committedDate": "2020-07-17T02:36:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTM4OQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456811389", "bodyText": "(nit) Add an empty line in front, and capitalize the comment", "author": "Jackie-Jiang", "createdAt": "2020-07-18T17:38:03Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java", "diffHunk": "@@ -57,8 +57,27 @@\n   MAPVALUE(\"mapValue\"),\n \n   // Special type for annotation based scalar functions\n-  SCALAR(\"scalar\");\n+  SCALAR(\"scalar\"),\n+  // geo constructors", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTM5NQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456811395", "bodyText": "(nit) Empty line after", "author": "Jackie-Jiang", "createdAt": "2020-07-18T17:38:17Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java", "diffHunk": "@@ -57,8 +57,27 @@\n   MAPVALUE(\"mapValue\"),\n \n   // Special type for annotation based scalar functions\n-  SCALAR(\"scalar\");\n+  SCALAR(\"scalar\"),\n+  // geo constructors\n+  ST_GEOG_FROM_TEXT(\"ST_GeogFromText\"),\n+  ST_GEOM_FROM_TEXT(\"ST_GeomFromText\"),\n+  ST_GEOG_FROM_WKB(\"ST_GeogFromWKB\"),\n+  ST_GEOM_FROM_WKB(\"ST_GeomFromWKB\"),\n+  ST_POINT(\"ST_Point\"),\n+  ST_POLYGON(\"ST_Polygon\"),\n \n+  // geo measurements\n+  ST_AREA(\"ST_Area\"),\n+  ST_DISTANCE(\"ST_Distance\"),\n+  ST_GEOMETRY_TYPE(\"ST_GEOMETRY_TYPE\"),\n+\n+  // geo outputs\n+  ST_AS_BINARY(\"ST_AsBinary\"),\n+  ST_AS_TEXT(\"ST_AsText\"),\n+\n+  // geo relationship\n+  ST_CONTAINS(\"ST_Contains\"),\n+  ST_EQUALS(\"ST_Equals\");", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTY2NQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456811665", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              ST_GEOMETRY_TYPE(\"ST_GEOMETRY_TYPE\"),\n          \n          \n            \n              ST_GEOMETRY_TYPE(\"ST_GeometryType\"),", "author": "Jackie-Jiang", "createdAt": "2020-07-18T17:41:30Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java", "diffHunk": "@@ -57,8 +57,27 @@\n   MAPVALUE(\"mapValue\"),\n \n   // Special type for annotation based scalar functions\n-  SCALAR(\"scalar\");\n+  SCALAR(\"scalar\"),\n+  // geo constructors\n+  ST_GEOG_FROM_TEXT(\"ST_GeogFromText\"),\n+  ST_GEOM_FROM_TEXT(\"ST_GeomFromText\"),\n+  ST_GEOG_FROM_WKB(\"ST_GeogFromWKB\"),\n+  ST_GEOM_FROM_WKB(\"ST_GeomFromWKB\"),\n+  ST_POINT(\"ST_Point\"),\n+  ST_POLYGON(\"ST_Polygon\"),\n \n+  // geo measurements\n+  ST_AREA(\"ST_Area\"),\n+  ST_DISTANCE(\"ST_Distance\"),\n+  ST_GEOMETRY_TYPE(\"ST_GEOMETRY_TYPE\"),", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzQ3Nw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456813477", "bodyText": "Is there a standard function to return the SRID of the geometry? (Identify whether it is geometry or geography)", "author": "Jackie-Jiang", "createdAt": "2020-07-18T18:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTY2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1NzI4Ng==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r457857286", "bodyText": "Yes, it returns the type of the geometry as a string. EG: 'ST_Linestring', 'ST_Polygon','ST_MultiPolygon' etc", "author": "yupeng9", "createdAt": "2020-07-21T06:06:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMjEzNQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456812135", "bodyText": "Thanks for updating the javadoc. Add BYTES here as well", "author": "Jackie-Jiang", "createdAt": "2020-07-18T17:47:23Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/Schema.java", "diffHunk": "@@ -400,7 +400,7 @@ public String toSingleLineJsonString() {\n    * Validates a pinot schema.\n    * <p>The following validations are performed:\n    * <ul>\n-   *   <li>For dimension, time, date time fields, support {@link DataType}: INT, LONG, FLOAT, DOUBLE, STRING</li>\n+   *   <li>For dimension, time, date time fields, support {@link DataType}: INT, LONG, FLOAT, DOUBLE, STRING, BYTES</li>\n    *   <li>For non-derived metric fields, support {@link DataType}: INT, LONG, FLOAT, DOUBLE</li>", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzM2OQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456813369", "bodyText": "Avoid static import.\nPlease re-order the imports using PinotStyle within config/codestyle-intellij.xml or config/codestyle-eclipse.xml", "author": "Jackie-Jiang", "createdAt": "2020-07-18T18:02:08Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzcwNw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456813707", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final boolean _multitype;\n          \n          \n            \n              private final boolean _multiType;", "author": "Jackie-Jiang", "createdAt": "2020-07-18T18:06:00Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, \"ST_Point\"),\n+  MULTI_POINT(true, \"ST_MultiPoint\"),\n+  LINE_STRING(false, \"ST_LineString\"),\n+  MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n+  POLYGON(false, \"ST_Polygon\"),\n+  MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n+\n+  private final boolean _multitype;", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzcyNQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456813725", "bodyText": "Seems never used. How are you planning to use the multi-type info?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T18:06:20Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, \"ST_Point\"),\n+  MULTI_POINT(true, \"ST_MultiPoint\"),\n+  LINE_STRING(false, \"ST_LineString\"),\n+  MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n+  POLYGON(false, \"ST_Polygon\"),\n+  MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n+\n+  private final boolean _multitype;\n+  private final String _name;\n+\n+  GeometryType(boolean multitype, String name) {\n+    _multitype = multitype;\n+    _name = name;\n+  }\n+\n+  public boolean isMultitype() {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg2MTYzMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r457861633", "bodyText": "not in this PR. It's useful in function like https://postgis.net/docs/ST_GeometryN.html", "author": "yupeng9", "createdAt": "2020-07-21T06:18:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxOTkzNw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456819937", "bodyText": "Checked the Kryo implementation, it is only providing a buffer to the stream (very similar to BufferedInputStream and BufferedOutputStream). So I'm pretty sure reading/writing with pre-sized ByteBuffer will be much faster and the garbage generated will be much less. Also, with ByteBuffer we can store values with LITTLE_ENDIEN (linux native) to further improve the performance.\nI'd recommend revisiting this part because once the data is persistent, it will be hard to change", "author": "Jackie-Jiang", "createdAt": "2020-07-18T19:24:15Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.lang.Double.NaN;\n+import static java.lang.Double.isNaN;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_FACTORY;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_GET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SRID;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ */\n+public class GeometrySerde extends Serializer {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n+\n+  @Override\n+  public void write(Kryo kryo, Output output, Object object) {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3NDk5Ng==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458374996", "bodyText": "Thanks. This is a very good suggestion. It's true that using pre-sized ByteBuffer would be more performant than the stream API. I run a benchmark on three implementations: stream, ByteBuffer with Big_Endian, ByteBuffer with Little_Endian: https://docs.google.com/spreadsheets/d/1ANkC7I4N-TxtzFI-fDbchJ9uGmyQtOG_ViYY0mSstNM/edit#gid=0.\nThe benchmark confirms the performance gain. Also, the result shows BIG_ENDIAN is more performant, as it's Java's default order. I will go with the default order.", "author": "yupeng9", "createdAt": "2020-07-21T20:41:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxOTkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMDA1OQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456820059", "bodyText": "Can we use GeometryType instead of introducing this extra type? I don't think ENVELOPE is used", "author": "Jackie-Jiang", "createdAt": "2020-07-18T19:25:46Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.apache.pinot.core.geospatial.GeometryType;\n+\n+\n+/**\n+ * The geometry type used in serialization\n+ */\n+public enum GeometrySerializationType {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3OTgzNw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458379837", "bodyText": "removed.", "author": "yupeng9", "createdAt": "2020-07-21T20:51:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMDA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMDEyMg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456820122", "bodyText": "You can keep a static array with id as the index to prevent the branching of switch", "author": "Jackie-Jiang", "createdAt": "2020-07-18T19:26:28Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.apache.pinot.core.geospatial.GeometryType;\n+\n+\n+/**\n+ * The geometry type used in serialization\n+ */\n+public enum GeometrySerializationType {\n+  POINT(0, GeometryType.POINT),\n+  MULTI_POINT(1, GeometryType.MULTI_POINT),\n+  LINE_STRING(2, GeometryType.LINE_STRING),\n+  MULTI_LINE_STRING(3, GeometryType.MULTI_LINE_STRING),\n+  POLYGON(4, GeometryType.POLYGON),\n+  MULTI_POLYGON(5, GeometryType.MULTI_POLYGON),\n+  GEOMETRY_COLLECTION(6, GeometryType.GEOMETRY_COLLECTION),\n+  ENVELOPE(7, GeometryType.POLYGON);\n+\n+  private final int _id;\n+  private final GeometryType _geometryType;\n+\n+  GeometrySerializationType(int id, GeometryType geometryType) {\n+    _id = id;\n+    _geometryType = geometryType;\n+  }\n+\n+  /**\n+   * @return the id of the serialization type\n+   */\n+  public int id() {\n+    return _id;\n+  }\n+\n+  /**\n+   * @return the type in the geometry model\n+   */\n+  public GeometryType getGeometryType() {\n+    return _geometryType;\n+  }\n+\n+  /**\n+   * Constructs the serialization type from the id\n+   * @param id id of the serialization type\n+   * @return the serialization type\n+   */\n+  public static GeometrySerializationType fromID(int id) {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMjk0OA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456822948", "bodyText": "Based on https://locationtech.github.io/jts/javadoc/org/locationtech/jts/geom/Geometry.html, there is another type LINEAR_RING. Should we include that?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:01:59Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, \"ST_Point\"),\n+  MULTI_POINT(true, \"ST_MultiPoint\"),\n+  LINE_STRING(false, \"ST_LineString\"),", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg2MDcxNw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r457860717", "bodyText": "LINEAR_RING is a subtype of LINEAR_STRING", "author": "yupeng9", "createdAt": "2020-07-21T06:16:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMjk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzEwMg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823102", "bodyText": "Seems the code is borrowed from Presto? (https://github.com/prestodb/presto/blob/master/presto-geospatial-toolkit/src/main/java/com/facebook/presto/geospatial/serde/JtsGeometrySerde.java)\nCan you please include that in the javadoc?\nAlso, do we need to keep the same serialization format as presto? Using LITTLE_ENDIEN (linux native order) can improve the performance of ser/de", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:04:17Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.lang.Double.NaN;\n+import static java.lang.Double.isNaN;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_FACTORY;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_GET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SRID;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ */\n+public class GeometrySerde extends Serializer {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM2MjU4MA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458362580", "bodyText": "They are not exactly same, in particular, the differences are:\n\nPresto uses schema to indicate geometry vs geography info, while we encode this in the type byte.\nPresto serializes additional information such as envelope to be compatible with ESRI serialization, but the serde here does not, which is simpler and faster\n\nAdded this to the comments", "author": "yupeng9", "createdAt": "2020-07-21T20:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzI3NA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823274", "bodyText": "Javadoc describing the format of the serialized bytes will be preferred", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:06:10Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.lang.Double.NaN;\n+import static java.lang.Double.isNaN;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_FACTORY;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_GET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SRID;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ */\n+public class GeometrySerde extends Serializer {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n+\n+  @Override\n+  public void write(Kryo kryo, Output output, Object object) {\n+    if (!(object instanceof Geometry)) {\n+      throw new UnsupportedOperationException(\"Cannot serialize object of type \" + object.getClass().getName());\n+    }\n+    writeGeometry(output, (Geometry) object);\n+  }\n+\n+  @Override\n+  public Object read(Kryo kryo, Input input, Class aClass) {\n+    byte typeByte = input.readByte();\n+    GeometrySerializationType type = readGeometryType(typeByte);\n+    GeometryFactory factory = getGeometryFactory(typeByte);\n+\n+    return readGeometry(input, type, factory);\n+  }\n+\n+  private Geometry readGeometry(Input input, GeometrySerializationType type, GeometryFactory factory) {\n+    switch (type) {\n+      case POINT:\n+        return readPoint(input, factory);\n+      case MULTI_POINT:\n+        return readMultiPoint(input, factory);\n+      case LINE_STRING:\n+        return readPolyline(input, false, factory);\n+      case MULTI_LINE_STRING:\n+        return readPolyline(input, true, factory);\n+      case POLYGON:\n+        return readPolygon(input, false, factory);\n+      case MULTI_POLYGON:\n+        return readPolygon(input, true, factory);\n+      case GEOMETRY_COLLECTION:\n+        return readGeometryCollection(input, factory);\n+      default:\n+        throw new UnsupportedOperationException(\"Unexpected type: \" + type);\n+    }\n+  }\n+\n+  private Point readPoint(Input input, GeometryFactory factory) {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzUyMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823523", "bodyText": "Also check the data type, should be STRING", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:09:42Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from text.\n+ */\n+abstract class ConstructFromTextFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKTReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3Nzc4Ng==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458477786", "bodyText": "added", "author": "yupeng9", "createdAt": "2020-07-22T01:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzYzMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823633", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Utils.rethrowException(\n          \n          \n            \n                        new RuntimeException(String.format(\"Failed to parse geometry from String %s\", argumentValues[i])));\n          \n          \n            \n                    throw new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i]));", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:10:38Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from text.\n+ */\n+abstract class ConstructFromTextFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKTReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _reader = new WKTReader(getGeometryFactory());\n+  }\n+\n+  abstract protected GeometryFactory getGeometryFactory();\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return BYTES_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    String[] argumentValues = _transformFunction.transformToStringValuesSV(projectionBlock);\n+    int length = projectionBlock.getNumDocs();\n+    for (int i = 0; i < length; i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        _results[i] = GeometrySerializer.serialize(geometry);\n+      } catch (ParseException e) {\n+        Utils.rethrowException(\n+            new RuntimeException(String.format(\"Failed to parse geometry from String %s\", argumentValues[i])));", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzY1NA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823654", "bodyText": "(nit) re-order imports. Same for other classes", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:11:09Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzY4Ng==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823686", "bodyText": "Also check data type, should be BYTES", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:11:42Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKBReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from well-known binary (WKB) format.\n+ */\n+abstract class ConstructFromWKBFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKBReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzc1OQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823759", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new RuntimeException(String.format(\"Failed to parse geometry from bytes %s\", argumentValues[i]));\n          \n          \n            \n                    throw new RuntimeException(String.format(\"Failed to parse geometry from bytes: %s\", BytesUtils.toHexString(argumentValues[i])));", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:12:31Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKBReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from well-known binary (WKB) format.\n+ */\n+abstract class ConstructFromWKBFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKBReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _reader = new WKBReader(getGeometryFactory());\n+  }\n+\n+  abstract protected GeometryFactory getGeometryFactory();\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return BYTES_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    byte[][] argumentValues = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        _results[i] = GeometrySerializer.serialize(geometry);\n+      } catch (ParseException e) {\n+        throw new RuntimeException(String.format(\"Failed to parse geometry from bytes %s\", argumentValues[i]));", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4MTA5OA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458481098", "bodyText": "good catch", "author": "yupeng9", "createdAt": "2020-07-22T01:30:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzc1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzgzNA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823834", "bodyText": "Move this line out of the try-catch", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:13:43Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from text.\n+ */\n+abstract class ConstructFromTextFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKTReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _reader = new WKTReader(getGeometryFactory());\n+  }\n+\n+  abstract protected GeometryFactory getGeometryFactory();\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return BYTES_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    String[] argumentValues = _transformFunction.transformToStringValuesSV(projectionBlock);\n+    int length = projectionBlock.getNumDocs();\n+    for (int i = 0; i < length; i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        _results[i] = GeometrySerializer.serialize(geometry);", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3ODE4NA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458478184", "bodyText": "then i have to have another line to initialize geometry", "author": "yupeng9", "createdAt": "2020-07-22T01:20:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzgzOA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823838", "bodyText": "Move this line out of the try-catch", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:13:47Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKBReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from well-known binary (WKB) format.\n+ */\n+abstract class ConstructFromWKBFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKBReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _reader = new WKBReader(getGeometryFactory());\n+  }\n+\n+  abstract protected GeometryFactory getGeometryFactory();\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return BYTES_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    byte[][] argumentValues = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        _results[i] = GeometrySerializer.serialize(geometry);", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzg3OQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823879", "bodyText": "Also check data type, should be BYTES. Same for other classes", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:14:37Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNDMwMQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456824301", "bodyText": "(nit) Cache numDocs, same for other classes\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Geometry geometry;\n          \n          \n            \n                for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n          \n          \n            \n                  geometry = GeometrySerializer.deserialize(values[i]);\n          \n          \n            \n                int numDocs = projectionBlock.getNumDocs();\n          \n          \n            \n                for (int i = 0; i < numDocs; i++) {\n          \n          \n            \n                  Geometry geometry = GeometrySerializer.deserialize(values[i]);", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:19:49Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4MjQ3MQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458482471", "bodyText": "I don't think it's needed. JIT will take care of it", "author": "yupeng9", "createdAt": "2020-07-22T01:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNDMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyMzc0MA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459023740", "bodyText": "Not necessary. I did some benchmark on this and there is performance difference", "author": "Jackie-Jiang", "createdAt": "2020-07-22T19:14:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNDMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNDQ4Nw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456824487", "bodyText": "I don't quite follow the comment. Where is isExteriorRing() used?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:22:07Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = GeometryUtils.isGeography(geometry) ? calculateGeographyArea(geometry) : geometry.getArea();\n+    }\n+    return _results;\n+  }\n+\n+  private double calculateGeographyArea(Geometry geometry) {\n+    Polygon polygon = (Polygon) geometry;\n+\n+    // See https://www.movable-type.co.uk/scripts/latlong.html\n+    // and http://osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html\n+    // and https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\n+    // for the underlying Maths\n+\n+    double sphericalExcess = Math.abs(computeSphericalExcess(polygon.getExteriorRing()));\n+\n+    for (int i = 0; i < polygon.getNumInteriorRing(); i++) {\n+      sphericalExcess -= Math.abs(computeSphericalExcess(polygon.getInteriorRingN(i)));\n+    }\n+\n+    // Math.abs is required here because for Polygons with a 2D area of 0\n+    // isExteriorRing returns false for the exterior ring", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNDY3Ng==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456824676", "bodyText": "Prefix with _ for member variables", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:24:43Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = GeometryUtils.isGeography(geometry) ? calculateGeographyArea(geometry) : geometry.getArea();\n+    }\n+    return _results;\n+  }\n+\n+  private double calculateGeographyArea(Geometry geometry) {\n+    Polygon polygon = (Polygon) geometry;\n+\n+    // See https://www.movable-type.co.uk/scripts/latlong.html\n+    // and http://osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html\n+    // and https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\n+    // for the underlying Maths\n+\n+    double sphericalExcess = Math.abs(computeSphericalExcess(polygon.getExteriorRing()));\n+\n+    for (int i = 0; i < polygon.getNumInteriorRing(); i++) {\n+      sphericalExcess -= Math.abs(computeSphericalExcess(polygon.getInteriorRingN(i)));\n+    }\n+\n+    // Math.abs is required here because for Polygons with a 2D area of 0\n+    // isExteriorRing returns false for the exterior ring\n+    return Math.abs(sphericalExcess * GeometryUtils.EARTH_RADIUS_M * GeometryUtils.EARTH_RADIUS_M);\n+  }\n+\n+  private static double computeSphericalExcess(LineString lineString) {\n+    if (lineString.getNumPoints() < 3) {\n+      // A path with less than 3 distinct points is not valid for calculating an area\n+      throw new RuntimeException(\"Polygon is not valid: a loop contains less then 3 vertices.\");\n+    }\n+\n+    // Initialize the calculator with the last point\n+    SphericalExcessCalculator calculator = new SphericalExcessCalculator(lineString.getEndPoint());\n+\n+    // Our calculations rely on not processing the same point twice\n+    int start = lineString.getStartPoint().equals(lineString.getEndPoint()) ? 1 : 0;\n+\n+    for (int i = start; i < lineString.getNumPoints(); i++) {\n+      calculator.add(lineString.getPointN(i));\n+    }\n+    return calculator.computeSphericalExcess();\n+  }\n+\n+  private static class SphericalExcessCalculator {\n+    private static final double TWO_PI = 2 * Math.PI;\n+    private static final double THREE_PI = 3 * Math.PI;\n+\n+    private double sphericalExcess;", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNTU4MQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456825581", "bodyText": "I believe start point is always the same as end point? Or the more than 3 points check does not stand?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:35:46Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = GeometryUtils.isGeography(geometry) ? calculateGeographyArea(geometry) : geometry.getArea();\n+    }\n+    return _results;\n+  }\n+\n+  private double calculateGeographyArea(Geometry geometry) {\n+    Polygon polygon = (Polygon) geometry;\n+\n+    // See https://www.movable-type.co.uk/scripts/latlong.html\n+    // and http://osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html\n+    // and https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\n+    // for the underlying Maths\n+\n+    double sphericalExcess = Math.abs(computeSphericalExcess(polygon.getExteriorRing()));\n+\n+    for (int i = 0; i < polygon.getNumInteriorRing(); i++) {\n+      sphericalExcess -= Math.abs(computeSphericalExcess(polygon.getInteriorRingN(i)));\n+    }\n+\n+    // Math.abs is required here because for Polygons with a 2D area of 0\n+    // isExteriorRing returns false for the exterior ring\n+    return Math.abs(sphericalExcess * GeometryUtils.EARTH_RADIUS_M * GeometryUtils.EARTH_RADIUS_M);\n+  }\n+\n+  private static double computeSphericalExcess(LineString lineString) {\n+    if (lineString.getNumPoints() < 3) {\n+      // A path with less than 3 distinct points is not valid for calculating an area\n+      throw new RuntimeException(\"Polygon is not valid: a loop contains less then 3 vertices.\");\n+    }\n+\n+    // Initialize the calculator with the last point\n+    SphericalExcessCalculator calculator = new SphericalExcessCalculator(lineString.getEndPoint());\n+\n+    // Our calculations rely on not processing the same point twice\n+    int start = lineString.getStartPoint().equals(lineString.getEndPoint()) ? 1 : 0;", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4NTc5Mg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458485792", "bodyText": "true. can be optimized.", "author": "yupeng9", "createdAt": "2020-07-22T01:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNTU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNTkwMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456825903", "bodyText": "Cool, thanks for adding the reference of the algorithm.\nDidn't review the algorithm implementation carefully, please make sure it is covered by test", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:39:58Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = GeometryUtils.isGeography(geometry) ? calculateGeographyArea(geometry) : geometry.getArea();\n+    }\n+    return _results;\n+  }\n+\n+  private double calculateGeographyArea(Geometry geometry) {\n+    Polygon polygon = (Polygon) geometry;\n+\n+    // See https://www.movable-type.co.uk/scripts/latlong.html\n+    // and http://osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html\n+    // and https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\n+    // for the underlying Maths", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjA5Mg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456826092", "bodyText": "Do you mean should be close to 2Pi or -2Pi?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:42:22Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = GeometryUtils.isGeography(geometry) ? calculateGeographyArea(geometry) : geometry.getArea();\n+    }\n+    return _results;\n+  }\n+\n+  private double calculateGeographyArea(Geometry geometry) {\n+    Polygon polygon = (Polygon) geometry;\n+\n+    // See https://www.movable-type.co.uk/scripts/latlong.html\n+    // and http://osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html\n+    // and https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\n+    // for the underlying Maths\n+\n+    double sphericalExcess = Math.abs(computeSphericalExcess(polygon.getExteriorRing()));\n+\n+    for (int i = 0; i < polygon.getNumInteriorRing(); i++) {\n+      sphericalExcess -= Math.abs(computeSphericalExcess(polygon.getInteriorRingN(i)));\n+    }\n+\n+    // Math.abs is required here because for Polygons with a 2D area of 0\n+    // isExteriorRing returns false for the exterior ring\n+    return Math.abs(sphericalExcess * GeometryUtils.EARTH_RADIUS_M * GeometryUtils.EARTH_RADIUS_M);\n+  }\n+\n+  private static double computeSphericalExcess(LineString lineString) {\n+    if (lineString.getNumPoints() < 3) {\n+      // A path with less than 3 distinct points is not valid for calculating an area\n+      throw new RuntimeException(\"Polygon is not valid: a loop contains less then 3 vertices.\");\n+    }\n+\n+    // Initialize the calculator with the last point\n+    SphericalExcessCalculator calculator = new SphericalExcessCalculator(lineString.getEndPoint());\n+\n+    // Our calculations rely on not processing the same point twice\n+    int start = lineString.getStartPoint().equals(lineString.getEndPoint()) ? 1 : 0;\n+\n+    for (int i = start; i < lineString.getNumPoints(); i++) {\n+      calculator.add(lineString.getPointN(i));\n+    }\n+    return calculator.computeSphericalExcess();\n+  }\n+\n+  private static class SphericalExcessCalculator {\n+    private static final double TWO_PI = 2 * Math.PI;\n+    private static final double THREE_PI = 3 * Math.PI;\n+\n+    private double sphericalExcess;\n+    private double courseDelta;\n+\n+    private boolean firstPoint;\n+    private double firstInitialBearing;\n+    private double previousFinalBearing;\n+\n+    private double previousPhi;\n+    private double previousCos;\n+    private double previousSin;\n+    private double previousTan;\n+    private double previousLongitude;\n+\n+    private boolean done;\n+\n+    public SphericalExcessCalculator(Point endPoint) {\n+      previousPhi = toRadians(endPoint.getY());\n+      previousSin = Math.sin(previousPhi);\n+      previousCos = Math.cos(previousPhi);\n+      previousTan = Math.tan(previousPhi / 2);\n+      previousLongitude = toRadians(endPoint.getX());\n+      firstPoint = true;\n+    }\n+\n+    private void add(Point point)\n+        throws IllegalStateException {\n+      checkState(!done, \"Computation of spherical excess is complete\");\n+\n+      double phi = toRadians(point.getY());\n+      double tan = Math.tan(phi / 2);\n+      double longitude = toRadians(point.getX());\n+\n+      // We need to check for that specifically\n+      // Otherwise calculating the bearing is not deterministic\n+      if (longitude == previousLongitude && phi == previousPhi) {\n+        throw new RuntimeException(\"Polygon is not valid: it has two identical consecutive vertices\");\n+      }\n+\n+      double deltaLongitude = longitude - previousLongitude;\n+      sphericalExcess += 2 * Math.atan2(Math.tan(deltaLongitude / 2) * (previousTan + tan), 1 + previousTan * tan);\n+\n+      double cos = Math.cos(phi);\n+      double sin = Math.sin(phi);\n+      double sinOfDeltaLongitude = Math.sin(deltaLongitude);\n+      double cosOfDeltaLongitude = Math.cos(deltaLongitude);\n+\n+      // Initial bearing from previous to current\n+      double y = sinOfDeltaLongitude * cos;\n+      double x = previousCos * sin - previousSin * cos * cosOfDeltaLongitude;\n+      double initialBearing = (Math.atan2(y, x) + TWO_PI) % TWO_PI;\n+\n+      // Final bearing from previous to current = opposite of bearing from current to previous\n+      double finalY = -sinOfDeltaLongitude * previousCos;\n+      double finalX = previousSin * cos - previousCos * sin * cosOfDeltaLongitude;\n+      double finalBearing = (Math.atan2(finalY, finalX) + PI) % TWO_PI;\n+\n+      // When processing our first point we don't yet have a previousFinalBearing\n+      if (firstPoint) {\n+        // So keep our initial bearing around, and we'll use it at the end\n+        // with the last final bearing\n+        firstInitialBearing = initialBearing;\n+        firstPoint = false;\n+      } else {\n+        courseDelta += (initialBearing - previousFinalBearing + THREE_PI) % TWO_PI - PI;\n+      }\n+\n+      courseDelta += (finalBearing - initialBearing + THREE_PI) % TWO_PI - PI;\n+\n+      previousFinalBearing = finalBearing;\n+      previousCos = cos;\n+      previousSin = sin;\n+      previousPhi = phi;\n+      previousTan = tan;\n+      previousLongitude = longitude;\n+    }\n+\n+    public double computeSphericalExcess() {\n+      if (!done) {\n+        // Now that we have our last final bearing, we can calculate the remaining course delta\n+        courseDelta += (firstInitialBearing - previousFinalBearing + THREE_PI) % TWO_PI - PI;\n+\n+        // The courseDelta should be 2Pi or - 2Pi, unless a pole is enclosed (and then it should be ~ 0)", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5NDMwMA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458494300", "bodyText": "it shall be 2PI or 2PI per https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\nSince it makes 360 degree complete turn", "author": "yupeng9", "createdAt": "2020-07-22T02:19:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjgwOQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456826809", "bodyText": "Maybe better to use a separate class for all the scalar functions?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:51:52Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAsTextFunction.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.function.annotations.ScalarFunction;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * Returns the text representation of the geometry object.\n+ */\n+public class StAsTextFunction extends BaseTransformFunction {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StAsTextFunction.class);\n+  private TransformFunction _transformFunction;\n+  private static WKTWriter _writer;\n+  public static final String FUNCTION_NAME = \"ST_AsText\";\n+  private String[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _writer = new WKTWriter();\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return STRING_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public String[] transformToStringValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new String[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = _writer.write(geometry);\n+    }\n+    return _results;\n+  }\n+\n+  @ScalarFunction\n+  public static String stAsText(byte[] bytes) {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5ODMyMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458498323", "bodyText": "sure. moved", "author": "yupeng9", "createdAt": "2020-07-22T02:34:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjk5Nw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456826997", "bodyText": "null cannot be added to double[]\nCheck empty point before calculating the distance (for both geometry and geography)", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:54:49Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5OTAzNw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458499037", "bodyText": "hmm, without null handling, what's the default value we return for bytes?", "author": "yupeng9", "createdAt": "2020-07-22T02:36:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyODI5Nw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459028297", "bodyText": "I think you can return Double.NaN here to indicate empty geometry", "author": "Jackie-Jiang", "createdAt": "2020-07-22T19:22:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjk5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzA2Mg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827062", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new RuntimeException(\n          \n          \n            \n                        String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n          \n          \n            \n                    throw new RuntimeException(\"The first and second arguments shall either all be geometry or all geography\");", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:55:20Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzI3MA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827270", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n          \n          \n            \n                  throw new RuntimeException(\"Latitude must be between -90 and 90\");\n          \n          \n            \n                }\n          \n          \n            \n                Preconditions.checkArgument(latitude >= MIN_LATITUDE && latitude <= MAX_LATITUDE, \"Latitude must be between -90 and 90\");", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:57:49Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {\n+    if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n+      throw new RuntimeException(\"Latitude must be between -90 and 90\");\n+    }", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzQyMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827423", "bodyText": "Return primitive double, or it will throw NPE", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:59:39Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {\n+    if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n+      throw new RuntimeException(\"Latitude must be between -90 and 90\");\n+    }\n+  }\n+\n+  public static void checkLongitude(double longitude) {\n+    if (Double.isNaN(longitude) || Double.isInfinite(longitude) || longitude < MIN_LONGITUDE\n+        || longitude > MAX_LONGITUDE) {\n+      throw new RuntimeException(\"Longitude must be between -180 and 180\");\n+    }\n+  }\n+\n+  public static Double sphericalDistance(Geometry leftGeometry, Geometry rightGeometry) {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzYyMQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827621", "bodyText": "Does it work on line across dateline?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T21:01:46Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {\n+    if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n+      throw new RuntimeException(\"Latitude must be between -90 and 90\");\n+    }\n+  }\n+\n+  public static void checkLongitude(double longitude) {\n+    if (Double.isNaN(longitude) || Double.isInfinite(longitude) || longitude < MIN_LONGITUDE\n+        || longitude > MAX_LONGITUDE) {\n+      throw new RuntimeException(\"Longitude must be between -180 and 180\");\n+    }\n+  }\n+\n+  public static Double sphericalDistance(Geometry leftGeometry, Geometry rightGeometry) {\n+    if (leftGeometry.isEmpty() || rightGeometry.isEmpty()) {\n+      return null;\n+    }\n+\n+    validateGeographyType(\"ST_Distance\", leftGeometry, EnumSet.of(GeometryType.POINT));\n+    validateGeographyType(\"ST_Distance\", rightGeometry, EnumSet.of(GeometryType.POINT));\n+    Point leftPoint = (Point) leftGeometry;\n+    Point rightPoint = (Point) rightGeometry;\n+\n+    // greatCircleDistance returns distance in KM.\n+    return greatCircleDistance(leftPoint.getY(), leftPoint.getX(), rightPoint.getY(), rightPoint.getX()) * 1000;\n+  }\n+\n+  /**\n+   * Calculate the distance between two points on Earth.\n+   * <p>\n+   * This assumes a spherical Earth, and uses the Vincenty formula. (https://en.wikipedia\n+   * .org/wiki/Great-circle_distance)\n+   */\n+  public static double greatCircleDistance(double latitude1, double longitude1, double latitude2, double longitude2) {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzc3Mw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827773", "bodyText": "Directly return value in meter instead of km?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T21:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUwMTAwNw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458501007", "bodyText": "yes, per https://en.wikipedia.org/wiki/Great-circle_distance", "author": "yupeng9", "createdAt": "2020-07-22T02:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzczOA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827738", "bodyText": "Can be simplified to geometry instanceof Point", "author": "Jackie-Jiang", "createdAt": "2020-07-18T21:03:28Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {\n+    if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n+      throw new RuntimeException(\"Latitude must be between -90 and 90\");\n+    }\n+  }\n+\n+  public static void checkLongitude(double longitude) {\n+    if (Double.isNaN(longitude) || Double.isInfinite(longitude) || longitude < MIN_LONGITUDE\n+        || longitude > MAX_LONGITUDE) {\n+      throw new RuntimeException(\"Longitude must be between -180 and 180\");\n+    }\n+  }\n+\n+  public static Double sphericalDistance(Geometry leftGeometry, Geometry rightGeometry) {\n+    if (leftGeometry.isEmpty() || rightGeometry.isEmpty()) {\n+      return null;\n+    }\n+\n+    validateGeographyType(\"ST_Distance\", leftGeometry, EnumSet.of(GeometryType.POINT));", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUwMDU4MA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458500580", "bodyText": "try to reuse the same error msg template of several functions", "author": "yupeng9", "createdAt": "2020-07-22T02:43:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyNjE4MA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459026180", "bodyText": "There will be quite big performance difference, especially for per-value check", "author": "Jackie-Jiang", "createdAt": "2020-07-22T19:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzgxOQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827819", "bodyText": "Make all helper methods private", "author": "Jackie-Jiang", "createdAt": "2020-07-18T21:04:39Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzkzNA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827934", "bodyText": "Equals should work on geography as well?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T21:05:34Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StEqualsFunction.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * Function that returns true if the given geometries represent the same geometry.\n+ */\n+public class StEqualsFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"ST_Equals\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private int[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) || GeometryUtils.isGeography(secondGeometry)) {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUwMTc2OA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458501768", "bodyText": "yes, it should", "author": "yupeng9", "createdAt": "2020-07-22T02:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyODI3OA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456828278", "bodyText": "This doesn't seem right that St_Polygon is the same as ST_GeomFromText", "author": "Jackie-Jiang", "createdAt": "2020-07-18T21:10:25Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StPolygonFunction.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.locationtech.jts.geom.GeometryFactory;\n+\n+\n+/**\n+ * Constructor function for polygon object from text.\n+ */\n+public class StPolygonFunction extends ConstructFromTextFunction {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUwMjk3Mg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458502972", "bodyText": "yup, added the constraint of checking polygon type", "author": "yupeng9", "createdAt": "2020-07-22T02:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyODI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyODMyOA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456828328", "bodyText": "Remove?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T21:11:06Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BaseTransformFunction.java", "diffHunk": "@@ -41,7 +41,10 @@\n       new TransformResultMetadata(DataType.STRING, true, false);\n   protected static final TransformResultMetadata STRING_MV_NO_DICTIONARY_METADATA =\n       new TransformResultMetadata(DataType.STRING, false, false);\n+  protected static final TransformResultMetadata BYTES_SV_NO_DICTIONARY_METADATA =\n+          new TransformResultMetadata(DataType.BYTES, true, false);\n \n+  private boolean[] _booleanValuesSV;", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "url": "https://github.com/apache/pinot/commit/b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "message": "addressed comments", "committedDate": "2020-07-22T03:36:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk5ODIzNw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458998237", "bodyText": "(nit) reformat", "author": "Jackie-Jiang", "createdAt": "2020-07-22T18:30:08Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, 0,\"ST_Point\"),", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk5ODkwOA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458998908", "bodyText": "(nit) _multiType? (IDE identify multitype as typo)", "author": "Jackie-Jiang", "createdAt": "2020-07-22T18:31:15Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, 0,\"ST_Point\"),\n+  MULTI_POINT(true, 1,\"ST_MultiPoint\"),\n+  LINE_STRING(false, 2,\"ST_LineString\"),\n+  MULTI_LINE_STRING(true, 3,\"ST_MultiLineString\"),\n+  POLYGON(false, 4,\"ST_Polygon\"),\n+  MULTI_POLYGON(true, 5,\"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, 6,\"ST_GeomCollection\");\n+\n+  private final boolean _multitype;", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk5OTE4MQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458999181", "bodyText": "Remove this class", "author": "Jackie-Jiang", "createdAt": "2020-07-22T18:31:43Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.apache.pinot.core.geospatial.GeometryType;\n+\n+\n+/**\n+ * The geometry type used in serialization\n+ */\n+public enum GeometrySerializationType {", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAwMTEzMQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459001131", "bodyText": "Keep an static GeometryType array\nprivate static final GeometryType[] ID_TO_TYPE_MAP = new GeometryType[] {POINT, MULTI_POINT, ...};\nThen you can avoid the switch branching for better performance\nreturn ID_TO_TYPE_MAP[id];", "author": "Jackie-Jiang", "createdAt": "2020-07-22T18:34:51Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, 0,\"ST_Point\"),\n+  MULTI_POINT(true, 1,\"ST_MultiPoint\"),\n+  LINE_STRING(false, 2,\"ST_LineString\"),\n+  MULTI_LINE_STRING(true, 3,\"ST_MultiLineString\"),\n+  POLYGON(false, 4,\"ST_Polygon\"),\n+  MULTI_POLYGON(true, 5,\"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, 6,\"ST_GeomCollection\");\n+\n+  private final boolean _multitype;\n+  private final int _id;\n+  private final String _name;\n+\n+  GeometryType(boolean multitype, int id, String name) {\n+    _multitype = multitype;\n+    _id = id;\n+    _name = name;\n+  }\n+\n+  public boolean isMultitype() {\n+    return _multitype;\n+  }\n+\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  /**\n+   * @return the id of the serialization type\n+   */\n+  public int id() {\n+    return _id;\n+  }\n+\n+  /**\n+   * Constructs the serialization type from the id\n+   * @param id id of the serialization type\n+   * @return the serialization type\n+   */\n+  public static GeometryType fromID(int id) {\n+    switch (id) {", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAwMjI3Ng==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459002276", "bodyText": "(nit) Remove the unused LOGGER (we don't want to log within serde as it is per-value based and can easily flood the log)", "author": "Jackie-Jiang", "createdAt": "2020-07-22T18:36:44Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,510 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.Iterables;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ *\n+ * This serialization is similar to Presto's https://github.com/prestodb/presto/blob/master/presto-geospatial-toolkit/src/main/java/com/facebook/presto/geospatial/serde/JtsGeometrySerde.java,\n+ * with the following differences:\n+ *  - The geometry vs geography info is encoded in the type byte.\n+ *  - The envelope info is not serialized\n+ */\n+public class GeometrySerde {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAwNDcxNQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459004715", "bodyText": "Merge GeometrySerde into this class? I don't see the value of keeping them separate", "author": "Jackie-Jiang", "createdAt": "2020-07-22T18:40:57Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializer.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+/**\n+ * A serializer that serializes a geometry object into bytes and vice versa.\n+ */\n+public class GeometrySerializer {", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAxMDQ4NQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459010485", "bodyText": "(nit) Redundant check", "author": "Jackie-Jiang", "createdAt": "2020-07-22T18:50:29Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,510 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.Iterables;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ *\n+ * This serialization is similar to Presto's https://github.com/prestodb/presto/blob/master/presto-geospatial-toolkit/src/main/java/com/facebook/presto/geospatial/serde/JtsGeometrySerde.java,\n+ * with the following differences:\n+ *  - The geometry vs geography info is encoded in the type byte.\n+ *  - The envelope info is not serialized\n+ */\n+public class GeometrySerde {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n+  private static final int TYPE_SIZE = Byte.BYTES;\n+  private static final int COORDINATE_SIZE = Double.BYTES + Double.BYTES;\n+\n+  byte[] writeGeometry(Geometry geometry) {\n+    byte[] bytes = new byte[getByteSize(geometry)];\n+    ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n+    writeGeometryByteBuffer(byteBuffer, geometry);\n+    return bytes;\n+  }\n+\n+  public Geometry readGeometry(byte[] bytes) {\n+    return readGeometry(ByteBuffer.wrap(bytes));\n+  }\n+\n+  private Geometry readGeometry(ByteBuffer byteBuffer) {\n+    byte typeByte = byteBuffer.get();\n+    GeometryType type = readGeometryType(typeByte);\n+    GeometryFactory factory = getGeometryFactory(typeByte);\n+    Geometry geometry = readGeometry(byteBuffer, type, factory);\n+    return geometry;\n+  }\n+\n+  private Geometry readGeometry(ByteBuffer byteBuffer, GeometryType type, GeometryFactory factory) {\n+    switch (type) {\n+      case POINT:\n+        return readPoint(byteBuffer, factory);\n+      case MULTI_POINT:\n+        return readMultiPoint(byteBuffer, factory);\n+      case LINE_STRING:\n+        return readPolyline(byteBuffer, false, factory);\n+      case MULTI_LINE_STRING:\n+        return readPolyline(byteBuffer, true, factory);\n+      case POLYGON:\n+        return readPolygon(byteBuffer, false, factory);\n+      case MULTI_POLYGON:\n+        return readPolygon(byteBuffer, true, factory);\n+      case GEOMETRY_COLLECTION:\n+        return readGeometryCollection(byteBuffer, factory);\n+      default:\n+        throw new UnsupportedOperationException(\"Unexpected type: \" + type);\n+    }\n+  }\n+\n+  private Point readPoint(ByteBuffer byteBuffer, GeometryFactory factory) {\n+    Coordinate coordinates = readCoordinate(byteBuffer);\n+    if (Double.isNaN(coordinates.x) || Double.isNaN(coordinates.y)) {\n+      return factory.createPoint();\n+    }\n+    return factory.createPoint(coordinates);\n+  }\n+\n+  private Coordinate readCoordinate(ByteBuffer byteBuffer) {\n+    return new Coordinate(byteBuffer.getDouble(), byteBuffer.getDouble());\n+  }\n+\n+  private Coordinate[] readCoordinates(ByteBuffer byteBuffer, int count) {\n+    Objects.requireNonNull(byteBuffer, \"input is null\");", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAxNTQxNA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459015414", "bodyText": "Let's use Preconditions for argument check. Same for other places", "author": "Jackie-Jiang", "createdAt": "2020-07-22T18:59:05Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,510 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.Iterables;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ *\n+ * This serialization is similar to Presto's https://github.com/prestodb/presto/blob/master/presto-geospatial-toolkit/src/main/java/com/facebook/presto/geospatial/serde/JtsGeometrySerde.java,\n+ * with the following differences:\n+ *  - The geometry vs geography info is encoded in the type byte.\n+ *  - The envelope info is not serialized\n+ */\n+public class GeometrySerde {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n+  private static final int TYPE_SIZE = Byte.BYTES;\n+  private static final int COORDINATE_SIZE = Double.BYTES + Double.BYTES;\n+\n+  byte[] writeGeometry(Geometry geometry) {\n+    byte[] bytes = new byte[getByteSize(geometry)];\n+    ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n+    writeGeometryByteBuffer(byteBuffer, geometry);\n+    return bytes;\n+  }\n+\n+  public Geometry readGeometry(byte[] bytes) {\n+    return readGeometry(ByteBuffer.wrap(bytes));\n+  }\n+\n+  private Geometry readGeometry(ByteBuffer byteBuffer) {\n+    byte typeByte = byteBuffer.get();\n+    GeometryType type = readGeometryType(typeByte);\n+    GeometryFactory factory = getGeometryFactory(typeByte);\n+    Geometry geometry = readGeometry(byteBuffer, type, factory);\n+    return geometry;\n+  }\n+\n+  private Geometry readGeometry(ByteBuffer byteBuffer, GeometryType type, GeometryFactory factory) {\n+    switch (type) {\n+      case POINT:\n+        return readPoint(byteBuffer, factory);\n+      case MULTI_POINT:\n+        return readMultiPoint(byteBuffer, factory);\n+      case LINE_STRING:\n+        return readPolyline(byteBuffer, false, factory);\n+      case MULTI_LINE_STRING:\n+        return readPolyline(byteBuffer, true, factory);\n+      case POLYGON:\n+        return readPolygon(byteBuffer, false, factory);\n+      case MULTI_POLYGON:\n+        return readPolygon(byteBuffer, true, factory);\n+      case GEOMETRY_COLLECTION:\n+        return readGeometryCollection(byteBuffer, factory);\n+      default:\n+        throw new UnsupportedOperationException(\"Unexpected type: \" + type);\n+    }\n+  }\n+\n+  private Point readPoint(ByteBuffer byteBuffer, GeometryFactory factory) {\n+    Coordinate coordinates = readCoordinate(byteBuffer);\n+    if (Double.isNaN(coordinates.x) || Double.isNaN(coordinates.y)) {\n+      return factory.createPoint();\n+    }\n+    return factory.createPoint(coordinates);\n+  }\n+\n+  private Coordinate readCoordinate(ByteBuffer byteBuffer) {\n+    return new Coordinate(byteBuffer.getDouble(), byteBuffer.getDouble());\n+  }\n+\n+  private Coordinate[] readCoordinates(ByteBuffer byteBuffer, int count) {\n+    Objects.requireNonNull(byteBuffer, \"input is null\");\n+    Verify.verify(count > 0);", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAxODcyMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459018723", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Utils.rethrowException(\n          \n          \n            \n                        new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i])));\n          \n          \n            \n                    throw new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i]));", "author": "Jackie-Jiang", "createdAt": "2020-07-22T19:04:46Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from text.\n+ */\n+abstract class ConstructFromTextFunction extends BaseTransformFunction {\n+  protected TransformFunction _transformFunction;\n+  protected byte[][] _results;\n+  protected WKTReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().getDataType() == FieldSpec.DataType.STRING,\n+        \"The argument must be of string type\");\n+    _transformFunction = transformFunction;\n+    _reader = new WKTReader(getGeometryFactory());\n+  }\n+\n+  abstract protected GeometryFactory getGeometryFactory();\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return BYTES_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    String[] argumentValues = _transformFunction.transformToStringValuesSV(projectionBlock);\n+    int length = projectionBlock.getNumDocs();\n+    for (int i = 0; i < length; i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        _results[i] = GeometrySerializer.serialize(geometry);\n+      } catch (ParseException e) {\n+        Utils.rethrowException(\n+            new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i])));", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyMDIyOA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459020228", "bodyText": "(Major) Should this be GEOGRAPHY_FACTORY for longitude and latitude?", "author": "Jackie-Jiang", "createdAt": "2020-07-22T19:07:25Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ScalarFunctions.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import org.apache.pinot.common.function.annotations.ScalarFunction;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.io.WKTWriter;\n+\n+\n+/**\n+ * Geospatial scalar functions that can be used in transformation.\n+ */\n+public class ScalarFunctions {\n+\n+  /**\n+   * Creates a point.\n+   *\n+   * @param longitude longitude\n+   * @param latitude latitude\n+   * @return the created point\n+   */\n+  @ScalarFunction\n+  public static byte[] stPoint(double longitude, double latitude) {\n+    return GeometrySerializer\n+        .serialize(GeometryUtils.GEOMETRY_FACTORY.createPoint(new Coordinate(longitude, latitude)));", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE4MzczMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459183733", "bodyText": "good point. Changed the argument to x,y", "author": "yupeng9", "createdAt": "2020-07-23T02:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyMDIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyODkyMg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459028922", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Utils.rethrowException(\n          \n          \n            \n                        new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i])));\n          \n          \n            \n                    throw new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i]));", "author": "Jackie-Jiang", "createdAt": "2020-07-22T19:23:34Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StPolygonFunction.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.EnumSet;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.io.ParseException;\n+\n+\n+/**\n+ * Constructor function for polygon object from text.\n+ */\n+public class StPolygonFunction extends ConstructFromTextFunction {\n+  public static final String FUNCTION_NAME = \"ST_Polygon\";\n+\n+  @Override\n+  protected GeometryFactory getGeometryFactory() {\n+    return GeometryUtils.GEOMETRY_FACTORY;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    String[] argumentValues = _transformFunction.transformToStringValuesSV(projectionBlock);\n+    int length = projectionBlock.getNumDocs();\n+    for (int i = 0; i < length; i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        Preconditions.checkArgument(geometry instanceof Polygon, \"The geometry object must be polygon\");\n+        _results[i] = GeometrySerializer.serialize(geometry);\n+      } catch (ParseException e) {\n+        Utils.rethrowException(\n+            new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i])));", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0d6285fc24af3b6869ba865c20205d91f38bb958", "url": "https://github.com/apache/pinot/commit/0d6285fc24af3b6869ba865c20205d91f38bb958", "message": "more comments", "committedDate": "2020-07-23T02:44:01Z", "type": "commit"}]}