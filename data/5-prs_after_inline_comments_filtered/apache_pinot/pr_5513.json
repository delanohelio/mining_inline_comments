{"pr_number": 5513, "pr_title": "Return Select only Literal Expression at Broker", "pr_createdAt": "2020-06-07T21:27:55Z", "pr_url": "https://github.com/apache/pinot/pull/5513", "timeline": [{"oid": "6cb68005c11422b6944b21d2b890223da94893fe", "url": "https://github.com/apache/pinot/commit/6cb68005c11422b6944b21d2b890223da94893fe", "message": "Support Selection Literal only queries", "committedDate": "2020-06-07T23:00:43Z", "type": "forcePushed"}, {"oid": "f0ae0917501a46225fe26c828c276b31db54ec24", "url": "https://github.com/apache/pinot/commit/f0ae0917501a46225fe26c828c276b31db54ec24", "message": "Support Selection Literal only queries", "committedDate": "2020-06-08T00:51:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc2MDAyOA==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r436760028", "bodyText": "Does this work only with AS?", "author": "mayankshriv", "createdAt": "2020-06-08T14:39:26Z", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -676,14 +678,25 @@ protected static Expression invokeCompileTimeFunctionExpression(Expression funcE\n       try {\n         FunctionInvoker invoker = new FunctionInvoker(functionInfo);\n         Object result = invoker.process(arguments);\n-        if (result instanceof String) {\n-          result = String.format(\"'%s'\", result);\n-        }\n         return RequestUtils.getLiteralExpression(result);\n       } catch (Exception e) {\n         throw new SqlCompilationException(new IllegalArgumentException(\"Unsupported function - \" + funcName, e));\n       }\n     }\n     return funcExpr;\n   }\n+\n+  public static boolean isLiteralOnlyExpression(Expression e) {\n+    if (e.getType() == ExpressionType.LITERAL) {\n+      return true;\n+    }\n+    if (e.getType() == ExpressionType.FUNCTION) {\n+      Function functionCall = e.getFunctionCall();\n+      if (functionCall.getOperator().equalsIgnoreCase(SqlKind.AS.toString())) {", "originalCommit": "f0ae0917501a46225fe26c828c276b31db54ec24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5NDYyMA==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r436894620", "bodyText": "Yes, the CalciteSQLParser already evaluated the transform function with literals and replace it with literal.\nSo the only left over is to handle here is Literal and Function AS.", "author": "xiangfu0", "createdAt": "2020-06-08T18:03:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc2MDAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc2NDcxMw==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r436764713", "bodyText": "Would be good to state in the PR description that this feature is only supported for SQL mode.", "author": "mayankshriv", "createdAt": "2020-06-08T14:45:55Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -435,6 +455,116 @@ static void handleQueryLimitOverride(BrokerRequest brokerRequest, int queryLimit\n     }\n   }\n \n+  /**\n+   * Check if a SQL parsed BrokerRequest is a literal only query.\n+   * @param brokerRequest\n+   * @return true if this query selects only Literals\n+   *\n+   */\n+  @VisibleForTesting\n+  static boolean isLiteralOnlyQuery(BrokerRequest brokerRequest) {\n+    if (brokerRequest.getPinotQuery() != null) {", "originalCommit": "f0ae0917501a46225fe26c828c276b31db54ec24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5NDk1OQ==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r436894959", "bodyText": "added", "author": "xiangfu0", "createdAt": "2020-06-08T18:03:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc2NDcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwODQzMA==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437008430", "bodyText": "This can potentially flood the log. Can we extract line 376-405 in existing code into a method and call that here?", "author": "Jackie-Jiang", "createdAt": "2020-06-08T21:21:03Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -184,6 +192,18 @@ public BrokerResponse handleRequest(JsonNode request, @Nullable RequesterIdentit\n       requestStatistics.setErrorCode(QueryException.PQL_PARSING_ERROR_CODE);\n       return new BrokerResponseNative(QueryException.getException(QueryException.PQL_PARSING_ERROR, e));\n     }\n+    if (isLiteralOnlyQuery(brokerRequest)) {\n+      LOGGER.info(\"Request {} contains only Literal, skipping server query: {}\", requestId, query);", "originalCommit": "f0ae0917501a46225fe26c828c276b31db54ec24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzMTg3Nw==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437031877", "bodyText": "Changed this log to debug level.\nFor the code from 376-405, I feel it makes too many assumptions which current broker query doesn't honor(e.g. table name is not a must here). I prefer to keep them separately.", "author": "xiangfu0", "createdAt": "2020-06-08T22:17:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwODQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwODY1NQ==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437008655", "bodyText": "Remove this", "author": "Jackie-Jiang", "createdAt": "2020-06-08T21:21:33Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -435,6 +455,116 @@ static void handleQueryLimitOverride(BrokerRequest brokerRequest, int queryLimit\n     }\n   }\n \n+  /**\n+   * Check if a SQL parsed BrokerRequest is a literal only query.\n+   * @param brokerRequest\n+   * @return true if this query selects only Literals\n+   *\n+   */\n+  @VisibleForTesting\n+  static boolean isLiteralOnlyQuery(BrokerRequest brokerRequest) {\n+    if (brokerRequest.getPinotQuery() != null) {\n+      for (Expression e: brokerRequest.getPinotQuery().getSelectList()) {\n+        if (!CalciteSqlParser.isLiteralOnlyExpression(e)) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Compute BrokerResponse for literal only query.\n+   *\n+   * @param brokerRequest\n+   * @param compilationStartTimeNs\n+   * @param requestStatistics\n+   * @return BrokerResponse\n+   */\n+  private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, long compilationStartTimeNs,\n+      RequestStatistics requestStatistics)\n+      throws IllegalStateException {\n+    System.out.println(\"brokerRequest = \" + brokerRequest.toString());", "originalCommit": "f0ae0917501a46225fe26c828c276b31db54ec24", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwOTAwNQ==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437009005", "bodyText": "Why only catching IllegalStateException?", "author": "Jackie-Jiang", "createdAt": "2020-06-08T21:22:16Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -184,6 +192,18 @@ public BrokerResponse handleRequest(JsonNode request, @Nullable RequesterIdentit\n       requestStatistics.setErrorCode(QueryException.PQL_PARSING_ERROR_CODE);\n       return new BrokerResponseNative(QueryException.getException(QueryException.PQL_PARSING_ERROR, e));\n     }\n+    if (isLiteralOnlyQuery(brokerRequest)) {\n+      LOGGER.info(\"Request {} contains only Literal, skipping server query: {}\", requestId, query);\n+      try {\n+        BrokerResponse brokerResponse =\n+            processLiteralOnlyBrokerRequest(brokerRequest, compilationStartTimeNs, requestStatistics);\n+        return brokerResponse;\n+      } catch (IllegalStateException e) {", "originalCommit": "f0ae0917501a46225fe26c828c276b31db54ec24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNjY2Mw==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437026663", "bodyText": "We only catch the behavior that process literal functions failure.", "author": "xiangfu0", "createdAt": "2020-06-08T22:03:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwOTAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1Njk4Nw==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437756987", "bodyText": "IMO we should catch all Exception and fallback to the old behavior instead of directly failing the query. What if processLiteralOnlyBrokerRequest() somehow throws other type of exceptions?", "author": "Jackie-Jiang", "createdAt": "2020-06-09T22:27:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwOTAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2Njc2Mw==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437766763", "bodyText": "I see. My purpose here is to prevent broken query pushing down to servers for further processing. E.g. Function AS has two arguments first is any expression, second is an identifier, however if it's not, then typically it means the query is not writing correct.\nI'll change it to catch all exceptions and add a TODO for further refinements.", "author": "xiangfu0", "createdAt": "2020-06-09T22:56:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwOTAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAxMTAwMg==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437011002", "bodyText": "BYTE should be modeled as INT", "author": "Jackie-Jiang", "createdAt": "2020-06-08T21:26:45Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -435,6 +455,116 @@ static void handleQueryLimitOverride(BrokerRequest brokerRequest, int queryLimit\n     }\n   }\n \n+  /**\n+   * Check if a SQL parsed BrokerRequest is a literal only query.\n+   * @param brokerRequest\n+   * @return true if this query selects only Literals\n+   *\n+   */\n+  @VisibleForTesting\n+  static boolean isLiteralOnlyQuery(BrokerRequest brokerRequest) {\n+    if (brokerRequest.getPinotQuery() != null) {\n+      for (Expression e: brokerRequest.getPinotQuery().getSelectList()) {\n+        if (!CalciteSqlParser.isLiteralOnlyExpression(e)) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Compute BrokerResponse for literal only query.\n+   *\n+   * @param brokerRequest\n+   * @param compilationStartTimeNs\n+   * @param requestStatistics\n+   * @return BrokerResponse\n+   */\n+  private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, long compilationStartTimeNs,\n+      RequestStatistics requestStatistics)\n+      throws IllegalStateException {\n+    System.out.println(\"brokerRequest = \" + brokerRequest.toString());\n+    BrokerResponseNative brokerResponse = new BrokerResponseNative();\n+    List<String> columnNames = new ArrayList<>();\n+    List<DataSchema.ColumnDataType> columnTypes = new ArrayList<>();\n+    List<Object> row = new ArrayList<>();\n+    for (Expression e : brokerRequest.getPinotQuery().getSelectList()) {\n+      computeResultsForExpression(e, columnNames, columnTypes, row);\n+    }\n+    DataSchema dataSchema =\n+        new DataSchema(columnNames.toArray(new String[0]), columnTypes.toArray(new DataSchema.ColumnDataType[0]));\n+    List<Object[]> rows = new ArrayList<>();\n+    rows.add(row.toArray());\n+    ResultTable resultTable = new ResultTable(dataSchema, rows);\n+    brokerResponse.setResultTable(resultTable);\n+\n+    long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - compilationStartTimeNs);\n+    brokerResponse.setTimeUsedMs(totalTimeMs);\n+    requestStatistics.setQueryProcessingTime(totalTimeMs);\n+    requestStatistics.setStatistics(brokerResponse);\n+    return brokerResponse;\n+  }\n+\n+  private void computeResultsForExpression(Expression e, List<String> columnNames, List<DataSchema.ColumnDataType> columnTypes,\n+      List<Object> row) {\n+    if (e.getType() == ExpressionType.LITERAL) {\n+      computeResultsForLiteral(e.getLiteral(), columnNames, columnTypes, row);\n+    }\n+    if (e.getType() == ExpressionType.FUNCTION) {\n+      if (e.getFunctionCall().getOperator().equalsIgnoreCase(SqlKind.AS.toString())) {\n+        String columnName = e.getFunctionCall().getOperands().get(1).getIdentifier().getName();\n+        computeResultsForExpression(e.getFunctionCall().getOperands().get(0), columnNames, columnTypes, row);\n+        columnNames.set(columnNames.size() - 1, columnName);\n+      } else {\n+        throw new IllegalStateException(\n+            \"No able to compute results for function - \" + e.getFunctionCall().getOperator());\n+      }\n+    }\n+  }\n+\n+  private void computeResultsForLiteral(Literal literal, List<String> columnNames, List<DataSchema.ColumnDataType> columnTypes,\n+      List<Object> row) {\n+    Object fieldValue = literal.getFieldValue();\n+    columnNames.add(fieldValue.toString());\n+    switch (literal.getSetField()) {\n+      case SHORT_VALUE:\n+        columnTypes.add(DataSchema.ColumnDataType.INT);\n+        row.add((int) literal.getShortValue());\n+        break;\n+      case INT_VALUE:\n+        columnTypes.add(DataSchema.ColumnDataType.INT);\n+        row.add(literal.getIntValue());\n+        break;\n+      case LONG_VALUE:\n+        columnTypes.add(DataSchema.ColumnDataType.LONG);\n+        row.add(literal.getLongValue());\n+        break;\n+      case DOUBLE_VALUE:\n+        columnTypes.add(DataSchema.ColumnDataType.DOUBLE);\n+        row.add(literal.getDoubleValue());\n+        break;\n+      case BOOL_VALUE:\n+        columnTypes.add(DataSchema.ColumnDataType.STRING);\n+        row.add(new Boolean(literal.getBoolValue()).toString());\n+        break;\n+      case STRING_VALUE:\n+        columnTypes.add(DataSchema.ColumnDataType.STRING);\n+        System.out.println(\"literal.getStringValue() = \" + literal.getStringValue());\n+        row.add(literal.getStringValue());\n+        break;\n+      case BINARY_VALUE:\n+        columnTypes.add(DataSchema.ColumnDataType.BYTES);\n+        row.add(BytesUtils.toHexString(literal.getBinaryValue()));\n+        break;\n+      case BYTE_VALUE:", "originalCommit": "f0ae0917501a46225fe26c828c276b31db54ec24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzMDQyMw==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437030423", "bodyText": "Make sense!", "author": "xiangfu0", "createdAt": "2020-06-08T22:13:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAxMTAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAxMTg1MQ==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437011851", "bodyText": "For performance:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      selection.addToSelectionColumns(String.format(\"'%s'\", expression.getLiteral().getFieldValue().toString()));\n          \n          \n            \n                      selection.addToSelectionColumns('\\'' + expression.getLiteral().getFieldValue().toString() + '\\'');", "author": "Jackie-Jiang", "createdAt": "2020-06-08T21:28:40Z", "path": "pinot-common/src/main/java/org/apache/pinot/pql/parsers/PinotQuery2BrokerRequestConverter.java", "diffHunk": "@@ -128,7 +128,7 @@ private void convertSelectList(PinotQuery pinotQuery, BrokerRequest brokerReques\n           if (selection == null) {\n             selection = new Selection();\n           }\n-          selection.addToSelectionColumns(expression.getLiteral().getFieldValue().toString());\n+          selection.addToSelectionColumns(String.format(\"'%s'\", expression.getLiteral().getFieldValue().toString()));", "originalCommit": "f0ae0917501a46225fe26c828c276b31db54ec24", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAxMjI3OA==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437012278", "bodyText": "Can this be null? We shouldn't allow query without table name right?\nI would suggest always putting a dummy table name in the test so that production code won't accidentally miss the table name", "author": "Jackie-Jiang", "createdAt": "2020-06-08T21:29:41Z", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -278,7 +278,9 @@ private static PinotQuery compileCalciteSqlToPinotQuery(String sql) {\n           pinotQuery.setOffset(Integer.valueOf(((SqlNumericLiteral) selectSqlNode.getOffset()).toValue()));\n         }\n         DataSource dataSource = new DataSource();\n-        dataSource.setTableName(selectSqlNode.getFrom().toString());\n+        if (selectSqlNode.getFrom() != null) {", "originalCommit": "f0ae0917501a46225fe26c828c276b31db54ec24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyOTg4Mg==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437029882", "bodyText": "From sql standard, it's ok if it's null, the query should not fail if it contains no literals.", "author": "xiangfu0", "createdAt": "2020-06-08T22:11:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAxMjI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1OTY4NA==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437759684", "bodyText": "I don't quite follow. Why should we allow queries without the data source (i.e. table name)?\nHow are we going to execute query SELECT * without FROM?", "author": "Jackie-Jiang", "createdAt": "2020-06-09T22:35:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAxMjI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc3MjQ4Mw==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437772483", "bodyText": "SELECT * is not valid as * is parsed as an identifier.\nif you do SELECT '*' then it's a valid as you are querying for a string literal *\nSee this test:\nhttps://github.com/apache/incubator-pinot/pull/5513/files#diff-b1b494630a336fd5454600f3bcd0973dR52", "author": "xiangfu0", "createdAt": "2020-06-09T23:13:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAxMjI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEzNTE4MQ==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r439135181", "bodyText": "I see. So for literal only query, table name does not matter", "author": "Jackie-Jiang", "createdAt": "2020-06-12T00:07:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAxMjI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAxMTQ3Nw==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437011477", "bodyText": "remove", "author": "kishoreg", "createdAt": "2020-06-08T21:27:45Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -435,6 +455,116 @@ static void handleQueryLimitOverride(BrokerRequest brokerRequest, int queryLimit\n     }\n   }\n \n+  /**\n+   * Check if a SQL parsed BrokerRequest is a literal only query.\n+   * @param brokerRequest\n+   * @return true if this query selects only Literals\n+   *\n+   */\n+  @VisibleForTesting\n+  static boolean isLiteralOnlyQuery(BrokerRequest brokerRequest) {\n+    if (brokerRequest.getPinotQuery() != null) {\n+      for (Expression e: brokerRequest.getPinotQuery().getSelectList()) {\n+        if (!CalciteSqlParser.isLiteralOnlyExpression(e)) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Compute BrokerResponse for literal only query.\n+   *\n+   * @param brokerRequest\n+   * @param compilationStartTimeNs\n+   * @param requestStatistics\n+   * @return BrokerResponse\n+   */\n+  private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, long compilationStartTimeNs,\n+      RequestStatistics requestStatistics)\n+      throws IllegalStateException {\n+    System.out.println(\"brokerRequest = \" + brokerRequest.toString());", "originalCommit": "f0ae0917501a46225fe26c828c276b31db54ec24", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1fabeccca37a88be86b2ba83b1082661f0c38c4b", "url": "https://github.com/apache/pinot/commit/1fabeccca37a88be86b2ba83b1082661f0c38c4b", "message": "Address comments", "committedDate": "2020-06-08T22:39:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1NzY4MQ==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437757681", "bodyText": "(ocd) Can you put this in front of short so that we order them with the size for readability?", "author": "Jackie-Jiang", "createdAt": "2020-06-09T22:29:25Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -435,6 +455,115 @@ static void handleQueryLimitOverride(BrokerRequest brokerRequest, int queryLimit\n     }\n   }\n \n+  /**\n+   * Check if a SQL parsed BrokerRequest is a literal only query.\n+   * @param brokerRequest\n+   * @return true if this query selects only Literals\n+   *\n+   */\n+  @VisibleForTesting\n+  static boolean isLiteralOnlyQuery(BrokerRequest brokerRequest) {\n+    if (brokerRequest.getPinotQuery() != null) {\n+      for (Expression e: brokerRequest.getPinotQuery().getSelectList()) {\n+        if (!CalciteSqlParser.isLiteralOnlyExpression(e)) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Compute BrokerResponse for literal only query.\n+   *\n+   * @param brokerRequest\n+   * @param compilationStartTimeNs\n+   * @param requestStatistics\n+   * @return BrokerResponse\n+   */\n+  private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, long compilationStartTimeNs,\n+      RequestStatistics requestStatistics)\n+      throws IllegalStateException {\n+    BrokerResponseNative brokerResponse = new BrokerResponseNative();\n+    List<String> columnNames = new ArrayList<>();\n+    List<DataSchema.ColumnDataType> columnTypes = new ArrayList<>();\n+    List<Object> row = new ArrayList<>();\n+    for (Expression e : brokerRequest.getPinotQuery().getSelectList()) {\n+      computeResultsForExpression(e, columnNames, columnTypes, row);\n+    }\n+    DataSchema dataSchema =\n+        new DataSchema(columnNames.toArray(new String[0]), columnTypes.toArray(new DataSchema.ColumnDataType[0]));\n+    List<Object[]> rows = new ArrayList<>();\n+    rows.add(row.toArray());\n+    ResultTable resultTable = new ResultTable(dataSchema, rows);\n+    brokerResponse.setResultTable(resultTable);\n+\n+    long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - compilationStartTimeNs);\n+    brokerResponse.setTimeUsedMs(totalTimeMs);\n+    requestStatistics.setQueryProcessingTime(totalTimeMs);\n+    requestStatistics.setStatistics(brokerResponse);\n+    return brokerResponse;\n+  }\n+\n+  private void computeResultsForExpression(Expression e, List<String> columnNames, List<DataSchema.ColumnDataType> columnTypes,\n+      List<Object> row) {\n+    if (e.getType() == ExpressionType.LITERAL) {\n+      computeResultsForLiteral(e.getLiteral(), columnNames, columnTypes, row);\n+    }\n+    if (e.getType() == ExpressionType.FUNCTION) {\n+      if (e.getFunctionCall().getOperator().equalsIgnoreCase(SqlKind.AS.toString())) {\n+        String columnName = e.getFunctionCall().getOperands().get(1).getIdentifier().getName();\n+        computeResultsForExpression(e.getFunctionCall().getOperands().get(0), columnNames, columnTypes, row);\n+        columnNames.set(columnNames.size() - 1, columnName);\n+      } else {\n+        throw new IllegalStateException(\n+            \"No able to compute results for function - \" + e.getFunctionCall().getOperator());\n+      }\n+    }\n+  }\n+\n+  private void computeResultsForLiteral(Literal literal, List<String> columnNames, List<DataSchema.ColumnDataType> columnTypes,\n+      List<Object> row) {\n+    Object fieldValue = literal.getFieldValue();\n+    columnNames.add(fieldValue.toString());\n+    switch (literal.getSetField()) {\n+      case SHORT_VALUE:\n+        columnTypes.add(DataSchema.ColumnDataType.INT);\n+        row.add((int) literal.getShortValue());\n+        break;\n+      case INT_VALUE:\n+        columnTypes.add(DataSchema.ColumnDataType.INT);\n+        row.add(literal.getIntValue());\n+        break;\n+      case BYTE_VALUE:", "originalCommit": "1fabeccca37a88be86b2ba83b1082661f0c38c4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc3MjE1MA==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437772150", "bodyText": "done.", "author": "xiangfu0", "createdAt": "2020-06-09T23:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1NzY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1ODQyMg==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437758422", "bodyText": "Why putting literal String value as column name?\nFor functions, should we put function name here if alias is not provided?", "author": "Jackie-Jiang", "createdAt": "2020-06-09T22:31:32Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -435,6 +455,115 @@ static void handleQueryLimitOverride(BrokerRequest brokerRequest, int queryLimit\n     }\n   }\n \n+  /**\n+   * Check if a SQL parsed BrokerRequest is a literal only query.\n+   * @param brokerRequest\n+   * @return true if this query selects only Literals\n+   *\n+   */\n+  @VisibleForTesting\n+  static boolean isLiteralOnlyQuery(BrokerRequest brokerRequest) {\n+    if (brokerRequest.getPinotQuery() != null) {\n+      for (Expression e: brokerRequest.getPinotQuery().getSelectList()) {\n+        if (!CalciteSqlParser.isLiteralOnlyExpression(e)) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Compute BrokerResponse for literal only query.\n+   *\n+   * @param brokerRequest\n+   * @param compilationStartTimeNs\n+   * @param requestStatistics\n+   * @return BrokerResponse\n+   */\n+  private BrokerResponse processLiteralOnlyBrokerRequest(BrokerRequest brokerRequest, long compilationStartTimeNs,\n+      RequestStatistics requestStatistics)\n+      throws IllegalStateException {\n+    BrokerResponseNative brokerResponse = new BrokerResponseNative();\n+    List<String> columnNames = new ArrayList<>();\n+    List<DataSchema.ColumnDataType> columnTypes = new ArrayList<>();\n+    List<Object> row = new ArrayList<>();\n+    for (Expression e : brokerRequest.getPinotQuery().getSelectList()) {\n+      computeResultsForExpression(e, columnNames, columnTypes, row);\n+    }\n+    DataSchema dataSchema =\n+        new DataSchema(columnNames.toArray(new String[0]), columnTypes.toArray(new DataSchema.ColumnDataType[0]));\n+    List<Object[]> rows = new ArrayList<>();\n+    rows.add(row.toArray());\n+    ResultTable resultTable = new ResultTable(dataSchema, rows);\n+    brokerResponse.setResultTable(resultTable);\n+\n+    long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - compilationStartTimeNs);\n+    brokerResponse.setTimeUsedMs(totalTimeMs);\n+    requestStatistics.setQueryProcessingTime(totalTimeMs);\n+    requestStatistics.setStatistics(brokerResponse);\n+    return brokerResponse;\n+  }\n+\n+  private void computeResultsForExpression(Expression e, List<String> columnNames, List<DataSchema.ColumnDataType> columnTypes,\n+      List<Object> row) {\n+    if (e.getType() == ExpressionType.LITERAL) {\n+      computeResultsForLiteral(e.getLiteral(), columnNames, columnTypes, row);\n+    }\n+    if (e.getType() == ExpressionType.FUNCTION) {\n+      if (e.getFunctionCall().getOperator().equalsIgnoreCase(SqlKind.AS.toString())) {\n+        String columnName = e.getFunctionCall().getOperands().get(1).getIdentifier().getName();\n+        computeResultsForExpression(e.getFunctionCall().getOperands().get(0), columnNames, columnTypes, row);\n+        columnNames.set(columnNames.size() - 1, columnName);\n+      } else {\n+        throw new IllegalStateException(\n+            \"No able to compute results for function - \" + e.getFunctionCall().getOperator());\n+      }\n+    }\n+  }\n+\n+  private void computeResultsForLiteral(Literal literal, List<String> columnNames, List<DataSchema.ColumnDataType> columnTypes,\n+      List<Object> row) {\n+    Object fieldValue = literal.getFieldValue();\n+    columnNames.add(fieldValue.toString());", "originalCommit": "1fabeccca37a88be86b2ba83b1082661f0c38c4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc3NDY0MQ==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437774641", "bodyText": "so if the expression is literal, then the column name can only be literal, unless there is an AS function.", "author": "xiangfu0", "createdAt": "2020-06-09T23:20:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1ODQyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEzNzAzNg==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r439137036", "bodyText": "The problem here is that we already lost the context of the function (e.g. now()). Maybe add a TODO here to pass in the original expression and use that as the column name?", "author": "Jackie-Jiang", "createdAt": "2020-06-12T00:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1ODQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2MDA2NA==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437760064", "bodyText": "Can you also add a function column without alias?", "author": "Jackie-Jiang", "createdAt": "2020-06-09T22:36:19Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/OfflineClusterIntegrationTest.java", "diffHunk": "@@ -318,6 +317,37 @@ public void testTimeFunc()\n     assertEquals(todayStr, expectedTodayStr);\n   }\n \n+  @Test\n+  public void testLiteralOnlyFunc()\n+      throws Exception {\n+    long currentTsMin = System.currentTimeMillis();\n+    String sqlQuery = \"SELECT 1, now() as currentTs, 'abc', toDateTime(now(), 'yyyy-MM-dd z') as today\";", "originalCommit": "1fabeccca37a88be86b2ba83b1082661f0c38c4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc3MTczOQ==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r437771739", "bodyText": "Current Calcite Compiler already computed the results and set as a literal. so the column name will be the literal computed. I think we need to change that logic and do the evaluation here. That can be done in the next PR.", "author": "xiangfu0", "createdAt": "2020-06-09T23:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2MDA2NA=="}], "type": "inlineReview"}, {"oid": "c1da5c027d2148765e9dbd85ed0c67bf3eb21ccc", "url": "https://github.com/apache/pinot/commit/c1da5c027d2148765e9dbd85ed0c67bf3eb21ccc", "message": "Address comments", "committedDate": "2020-06-09T23:09:46Z", "type": "forcePushed"}, {"oid": "09e54fbed89da53d3cf1095ab4313e39a90df50a", "url": "https://github.com/apache/pinot/commit/09e54fbed89da53d3cf1095ab4313e39a90df50a", "message": "Address comments", "committedDate": "2020-06-09T23:11:38Z", "type": "forcePushed"}, {"oid": "a57961276f5fee197c33a3a34b42b1bf487d34d6", "url": "https://github.com/apache/pinot/commit/a57961276f5fee197c33a3a34b42b1bf487d34d6", "message": "Address comments", "committedDate": "2020-06-09T23:26:11Z", "type": "forcePushed"}, {"oid": "c682c95fca412d35a39656c96ce2e577e52fd458", "url": "https://github.com/apache/pinot/commit/c682c95fca412d35a39656c96ce2e577e52fd458", "message": "Address comments", "committedDate": "2020-06-10T03:09:58Z", "type": "forcePushed"}, {"oid": "dbb957feb0511c330b4a8a0fc350982cd2aca3d6", "url": "https://github.com/apache/pinot/commit/dbb957feb0511c330b4a8a0fc350982cd2aca3d6", "message": "Address comments", "committedDate": "2020-06-11T09:00:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEzNjI2OA==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r439136268", "bodyText": "Ideally the column name should be now() right?\nThis is not critical, but better put a TODO?", "author": "Jackie-Jiang", "createdAt": "2020-06-12T00:09:20Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/OfflineClusterIntegrationTest.java", "diffHunk": "@@ -317,6 +317,43 @@ public void testTimeFunc()\n     assertEquals(todayStr, expectedTodayStr);\n   }\n \n+  @Test\n+  public void testLiteralOnlyFunc()\n+      throws Exception {\n+    long currentTsMin = System.currentTimeMillis();\n+    String sqlQuery = \"SELECT 1, now() as currentTs, 'abc', toDateTime(now(), 'yyyy-MM-dd z') as today, now()\";\n+    JsonNode response = postSqlQuery(sqlQuery, _brokerBaseApiUrl);\n+    long currentTsMax = System.currentTimeMillis();\n+\n+    assertEquals(response.get(\"resultTable\").get(\"dataSchema\").get(\"columnNames\").get(0).asText(), \"1\");\n+    assertEquals(response.get(\"resultTable\").get(\"dataSchema\").get(\"columnNames\").get(1).asText(), \"currentTs\");\n+    assertEquals(response.get(\"resultTable\").get(\"dataSchema\").get(\"columnNames\").get(2).asText(), \"abc\");\n+    assertEquals(response.get(\"resultTable\").get(\"dataSchema\").get(\"columnNames\").get(3).asText(), \"today\");\n+    String nowColumnName = response.get(\"resultTable\").get(\"dataSchema\").get(\"columnNames\").get(4).asText();", "originalCommit": "dbb957feb0511c330b4a8a0fc350982cd2aca3d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIwMTE3OA==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r439201178", "bodyText": "Will add a TODO", "author": "xiangfu0", "createdAt": "2020-06-12T04:32:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEzNjI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1NjU4OA==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r439156588", "bodyText": "You need to move this block before the case insensitive handling (line 177) because that requires the table information. If table is not set (e.g. SELECT now()), that part will throw NPE.", "author": "Jackie-Jiang", "createdAt": "2020-06-12T01:15:14Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -184,6 +192,18 @@ public BrokerResponse handleRequest(JsonNode request, @Nullable RequesterIdentit\n       requestStatistics.setErrorCode(QueryException.PQL_PARSING_ERROR_CODE);\n       return new BrokerResponseNative(QueryException.getException(QueryException.PQL_PARSING_ERROR, e));\n     }\n+    if (isLiteralOnlyQuery(brokerRequest)) {", "originalCommit": "dbb957feb0511c330b4a8a0fc350982cd2aca3d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIxNDcxOQ==", "url": "https://github.com/apache/pinot/pull/5513#discussion_r439214719", "bodyText": "make sense, I will check table null in the case sensitive then direct return if it's null.", "author": "xiangfu0", "createdAt": "2020-06-12T05:31:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1NjU4OA=="}], "type": "inlineReview"}, {"oid": "3017e5409f0edcb33b447dfb0286e30767c735c1", "url": "https://github.com/apache/pinot/commit/3017e5409f0edcb33b447dfb0286e30767c735c1", "message": "Support Selection Literal only queries", "committedDate": "2020-06-12T05:31:57Z", "type": "commit"}, {"oid": "1bd4699dcef9681454fd2dd0fb0def112228879e", "url": "https://github.com/apache/pinot/commit/1bd4699dcef9681454fd2dd0fb0def112228879e", "message": "Address comments", "committedDate": "2020-06-12T05:31:57Z", "type": "commit"}, {"oid": "186c73de6d7642762b1feee82678fa9b8e7bad3b", "url": "https://github.com/apache/pinot/commit/186c73de6d7642762b1feee82678fa9b8e7bad3b", "message": "Fixing npe in case sensitive handling", "committedDate": "2020-06-12T05:31:57Z", "type": "commit"}, {"oid": "186c73de6d7642762b1feee82678fa9b8e7bad3b", "url": "https://github.com/apache/pinot/commit/186c73de6d7642762b1feee82678fa9b8e7bad3b", "message": "Fixing npe in case sensitive handling", "committedDate": "2020-06-12T05:31:57Z", "type": "forcePushed"}]}