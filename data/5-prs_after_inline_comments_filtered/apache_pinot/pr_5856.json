{"pr_number": 5856, "pr_title": "[Post-Aggregation] Support post-aggregation in ORDER-BY", "pr_createdAt": "2020-08-13T01:21:07Z", "pr_url": "https://github.com/apache/pinot/pull/5856", "timeline": [{"oid": "c4c4a015cf94c706c538c153c151a5c8c31f10b4", "url": "https://github.com/apache/pinot/commit/c4c4a015cf94c706c538c153c151a5c8c31f10b4", "message": "Support post-aggregation in ORDER-BY", "committedDate": "2020-08-14T20:06:49Z", "type": "forcePushed"}, {"oid": "75c686fbf3eafc357ce9e8d85a3aa7b20dcf5c13", "url": "https://github.com/apache/pinot/commit/75c686fbf3eafc357ce9e8d85a3aa7b20dcf5c13", "message": "Support post-aggregation in ORDER-BY", "committedDate": "2020-08-14T20:07:54Z", "type": "commit"}, {"oid": "75c686fbf3eafc357ce9e8d85a3aa7b20dcf5c13", "url": "https://github.com/apache/pinot/commit/75c686fbf3eafc357ce9e8d85a3aa7b20dcf5c13", "message": "Support post-aggregation in ORDER-BY", "committedDate": "2020-08-14T20:07:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE5MDU0OQ==", "url": "https://github.com/apache/pinot/pull/5856#discussion_r471190549", "bodyText": "what does it mean to have ORDER BY a literal? can you give an example?", "author": "npawar", "createdAt": "2020-08-17T01:33:11Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/table/TableResizer.java", "diffHunk": "@@ -98,14 +93,37 @@\n     };\n   }\n \n+  /**\n+   * Helper method to construct a OrderByValueExtractor based on the given expression.\n+   */\n+  private OrderByValueExtractor getOrderByValueExtractor(ExpressionContext expression) {\n+    if (expression.getType() == ExpressionContext.Type.LITERAL) {", "originalCommit": "75c686fbf3eafc357ce9e8d85a3aa7b20dcf5c13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1MTI5NQ==", "url": "https://github.com/apache/pinot/pull/5856#discussion_r471651295", "bodyText": "Order-by with literal itself does not make a lot of sense, but post-aggregation might contain literal (e.g. ORDER BY SUM(col1) * 2 - SUM(col2))", "author": "Jackie-Jiang", "createdAt": "2020-08-17T17:35:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE5MDU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE5MTE4Ng==", "url": "https://github.com/apache/pinot/pull/5856#discussion_r471191186", "bodyText": "why using assert instead of Preconditions.checkState?", "author": "npawar", "createdAt": "2020-08-17T01:36:44Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/table/TableResizer.java", "diffHunk": "@@ -28,66 +28,61 @@\n import java.util.List;\n import java.util.Map;\n import java.util.PriorityQueue;\n-import java.util.function.Function;\n import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n import org.apache.pinot.core.query.aggregation.function.AggregationFunction;\n+import org.apache.pinot.core.query.postaggregation.PostAggregationFunction;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.FunctionContext;\n import org.apache.pinot.core.query.request.context.OrderByExpressionContext;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+import org.apache.pinot.spi.utils.ByteArray;\n \n \n /**\n  * Helper class for trimming and sorting records in the IndexedTable, based on the order by information\n  */\n @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n public class TableResizer {\n+  private final DataSchema _dataSchema;\n+  private final int _numGroupByExpressions;\n+  private final Map<ExpressionContext, Integer> _groupByExpressionIndexMap;\n+  private final AggregationFunction[] _aggregationFunctions;\n+  private final Map<FunctionContext, Integer> _aggregationFunctionIndexMap;\n+  private final int _numOrderByExpressions;\n   private final OrderByValueExtractor[] _orderByValueExtractors;\n   private final Comparator<IntermediateRecord> _intermediateRecordComparator;\n-  private final int _numOrderByExpressions;\n \n-  TableResizer(DataSchema dataSchema, AggregationFunction[] aggregationFunctions,\n-      List<OrderByExpressionContext> orderByExpressions) {\n+  public TableResizer(DataSchema dataSchema, QueryContext queryContext) {\n+    _dataSchema = dataSchema;\n \n-    // NOTE: the assumption here is that the key columns will appear before the aggregation columns in the data schema\n-    // This is handled in the only in the AggregationGroupByOrderByOperator for now\n+    // NOTE: The data schema will always have group-by expressions in the front, followed by aggregation functions of\n+    //       the same order as in the query context. This is handled in AggregationGroupByOrderByOperator.\n \n-    int numColumns = dataSchema.size();\n-    int numAggregations = aggregationFunctions.length;\n-    int numKeyColumns = numColumns - numAggregations;\n-\n-    Map<String, Integer> columnIndexMap = new HashMap<>();\n-    Map<String, AggregationFunction> aggregationColumnToFunction = new HashMap<>();\n-    for (int i = 0; i < numColumns; i++) {\n-      String columnName = dataSchema.getColumnName(i);\n-      columnIndexMap.put(columnName, i);\n-      if (i >= numKeyColumns) {\n-        aggregationColumnToFunction.put(columnName, aggregationFunctions[i - numKeyColumns]);\n-      }\n+    List<ExpressionContext> groupByExpressions = queryContext.getGroupByExpressions();\n+    assert groupByExpressions != null;", "originalCommit": "75c686fbf3eafc357ce9e8d85a3aa7b20dcf5c13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2MDY0OQ==", "url": "https://github.com/apache/pinot/pull/5856#discussion_r471660649", "bodyText": "I usually use assert to indicate that the value is not possible to be null, which has zero run-time impact, and use checkState to verify certain states", "author": "Jackie-Jiang", "createdAt": "2020-08-17T17:52:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE5MTE4Ng=="}], "type": "inlineReview"}]}