{"pr_number": 5766, "pr_title": "Adding distinct count support based on bitmap", "pr_createdAt": "2020-07-29T00:21:57Z", "pr_url": "https://github.com/apache/pinot/pull/5766", "timeline": [{"oid": "e08ecfe2bf60e72ef8a6163842a6b235493ac74e", "url": "https://github.com/apache/pinot/commit/e08ecfe2bf60e72ef8a6163842a6b235493ac74e", "message": "Add DistinctCountBitmap aggregation function", "committedDate": "2020-07-29T07:34:31Z", "type": "forcePushed"}, {"oid": "a68bfba4537c7d5b5271df668265a26a617d3fc2", "url": "https://github.com/apache/pinot/commit/a68bfba4537c7d5b5271df668265a26a617d3fc2", "message": "Add DistinctCountBitmap aggregation function", "committedDate": "2020-07-29T17:35:11Z", "type": "forcePushed"}, {"oid": "20b6ec5119ed7677fcde5f39348ec9e780eb582a", "url": "https://github.com/apache/pinot/commit/20b6ec5119ed7677fcde5f39348ec9e780eb582a", "message": "Add DistinctCountBitmap aggregation function", "committedDate": "2020-07-30T00:09:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwNjI2MA==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463706260", "bodyText": "javadoc would be good.", "author": "siddharthteotia", "createdAt": "2020-07-31T16:21:20Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapAggregationFunction.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.common.ObjectSerDeUtils;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.segment.index.readers.Dictionary;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n+import org.roaringbitmap.PeekableIntIterator;\n+import org.roaringbitmap.RoaringBitmap;\n+\n+\n+public class DistinctCountBitmapAggregationFunction extends BaseSingleInputAggregationFunction<RoaringBitmap, Integer> {", "originalCommit": "20b6ec5119ed7677fcde5f39348ec9e780eb582a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3MzAwMQ==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463873001", "bodyText": "Added", "author": "Jackie-Jiang", "createdAt": "2020-07-31T22:31:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwNjI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwNzI2MA==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463707260", "bodyText": "So DistinctCount stores dictionaryId in IntHashSet (with your recent change) and here we store them in a bitmap. I am guessing this is more space efficient?", "author": "siddharthteotia", "createdAt": "2020-07-31T16:23:18Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapAggregationFunction.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.common.ObjectSerDeUtils;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.segment.index.readers.Dictionary;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n+import org.roaringbitmap.PeekableIntIterator;\n+import org.roaringbitmap.RoaringBitmap;\n+\n+\n+public class DistinctCountBitmapAggregationFunction extends BaseSingleInputAggregationFunction<RoaringBitmap, Integer> {\n+  protected Dictionary _dictionary;\n+\n+  public DistinctCountBitmapAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.DISTINCTCOUNTBITMAP;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    BlockValSet blockValSet = blockValSetMap.get(_expression);\n+\n+    // Treat BYTES value as serialized RoaringBitmap\n+    DataType valueType = blockValSet.getValueType();\n+    if (valueType == DataType.BYTES) {\n+      byte[][] bytesValues = blockValSet.getBytesValuesSV();\n+      RoaringBitmap bitmap = aggregationResultHolder.getResult();\n+      if (bitmap != null) {\n+        for (int i = 0; i < length; i++) {\n+          bitmap.or(ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[i]));\n+        }\n+      } else {\n+        bitmap = ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[0]);\n+        aggregationResultHolder.setValue(bitmap);\n+        for (int i = 1; i < length; i++) {\n+          bitmap.or(ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[i]));\n+        }\n+      }\n+      return;\n+    }\n+\n+    // For dictionary-encoded expression, store dictionary ids into the bitmap\n+    RoaringBitmap bitmap = getBitmap(aggregationResultHolder);\n+    Dictionary dictionary = blockValSet.getDictionary();\n+    if (dictionary != null) {\n+      _dictionary = dictionary;\n+      int[] dictIds = blockValSet.getDictionaryIdsSV();\n+      bitmap.addN(dictIds, 0, length);\n+      return;\n+    }\n+\n+    // For non-dictionary-encoded expression, store hash code of the values into the bitmap\n+    switch (valueType) {\n+      case INT:\n+        int[] intValues = blockValSet.getIntValuesSV();\n+        bitmap.addN(intValues, 0, length);\n+        break;\n+      case LONG:\n+        long[] longValues = blockValSet.getLongValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          bitmap.add(Long.hashCode(longValues[i]));\n+        }\n+        break;\n+      case FLOAT:\n+        float[] floatValues = blockValSet.getFloatValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          bitmap.add(Float.hashCode(floatValues[i]));\n+        }\n+        break;\n+      case DOUBLE:\n+        double[] doubleValues = blockValSet.getDoubleValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          bitmap.add(Double.hashCode(doubleValues[i]));\n+        }\n+        break;\n+      case STRING:\n+        String[] stringValues = blockValSet.getStringValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          bitmap.add(stringValues[i].hashCode());\n+        }\n+        break;\n+      default:\n+        throw new IllegalStateException(\n+            \"Illegal data type for DISTINCT_COUNT_BITMAP aggregation function: \" + valueType);\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    BlockValSet blockValSet = blockValSetMap.get(_expression);\n+\n+    // Treat BYTES value as serialized RoaringBitmap\n+    DataType valueType = blockValSet.getValueType();\n+    if (valueType == DataType.BYTES) {\n+      byte[][] bytesValues = blockValSet.getBytesValuesSV();\n+      for (int i = 0; i < length; i++) {\n+        RoaringBitmap value = ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[i]);\n+        int groupKey = groupKeyArray[i];\n+        RoaringBitmap bitmap = groupByResultHolder.getResult(groupKey);\n+        if (bitmap != null) {\n+          bitmap.or(value);\n+        } else {\n+          groupByResultHolder.setValueForKey(groupKey, value);\n+        }\n+      }\n+      return;\n+    }\n+\n+    // For dictionary-encoded expression, store dictionary ids into the bitmap\n+    Dictionary dictionary = blockValSet.getDictionary();\n+    if (dictionary != null) {\n+      _dictionary = dictionary;\n+      int[] dictIds = blockValSet.getDictionaryIdsSV();\n+      for (int i = 0; i < length; i++) {\n+        getBitmap(groupByResultHolder, groupKeyArray[i]).add(dictIds[i]);\n+      }\n+      return;\n+    }\n+\n+    // For non-dictionary-encoded expression, store hash code of the values into the bitmap\n+    switch (valueType) {\n+      case INT:\n+        int[] intValues = blockValSet.getIntValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(intValues[i]);\n+        }\n+        break;\n+      case LONG:\n+        long[] longValues = blockValSet.getLongValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(Long.hashCode(longValues[i]));\n+        }\n+        break;\n+      case FLOAT:\n+        float[] floatValues = blockValSet.getFloatValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(Float.hashCode(floatValues[i]));\n+        }\n+        break;\n+      case DOUBLE:\n+        double[] doubleValues = blockValSet.getDoubleValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(Double.hashCode(doubleValues[i]));\n+        }\n+        break;\n+      case STRING:\n+        String[] stringValues = blockValSet.getStringValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(stringValues[i].hashCode());\n+        }\n+        break;\n+      default:\n+        throw new IllegalStateException(\n+            \"Illegal data type for DISTINCT_COUNT_BITMAP aggregation function: \" + valueType);\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    BlockValSet blockValSet = blockValSetMap.get(_expression);\n+\n+    // Treat BYTES value as serialized RoaringBitmap\n+    DataType valueType = blockValSet.getValueType();\n+    if (valueType == DataType.BYTES) {\n+      byte[][] bytesValues = blockValSet.getBytesValuesSV();\n+      for (int i = 0; i < length; i++) {\n+        RoaringBitmap value = ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[i]);\n+        for (int groupKey : groupKeysArray[i]) {\n+          RoaringBitmap bitmap = groupByResultHolder.getResult(groupKey);\n+          if (bitmap != null) {\n+            bitmap.or(value);\n+          } else {\n+            // Clone a bitmap for the group\n+            groupByResultHolder.setValueForKey(groupKey, value.clone());\n+          }\n+        }\n+      }\n+      return;\n+    }\n+\n+    // For dictionary-encoded expression, store dictionary ids into the bitmap\n+    Dictionary dictionary = blockValSet.getDictionary();", "originalCommit": "20b6ec5119ed7677fcde5f39348ec9e780eb582a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4NTc4Ng==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463885786", "bodyText": "Did a performance comparison on IntOpenHashSet vs RoaringBitmap vs BitSet, and find that the performance: BitSet > RoaringBitmap >> IntOpenHashSet. So here we use RoaringBitmap for good performance + good compression.", "author": "Jackie-Jiang", "createdAt": "2020-07-31T23:29:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwNzI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwODU1OA==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463708558", "bodyText": "This doesn't really look like a good use of bitmap for space efficiency purpose. We are storing the hashcodes of real values in the bitmap for result extraction\nSince the range of hashcodes could be arbitrary (as opposed to 0 .. N-1 for dictionaryIds), I wonder if bitmap will end up consuming more space here?", "author": "siddharthteotia", "createdAt": "2020-07-31T16:25:50Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapAggregationFunction.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.common.ObjectSerDeUtils;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.segment.index.readers.Dictionary;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n+import org.roaringbitmap.PeekableIntIterator;\n+import org.roaringbitmap.RoaringBitmap;\n+\n+\n+public class DistinctCountBitmapAggregationFunction extends BaseSingleInputAggregationFunction<RoaringBitmap, Integer> {\n+  protected Dictionary _dictionary;\n+\n+  public DistinctCountBitmapAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.DISTINCTCOUNTBITMAP;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    BlockValSet blockValSet = blockValSetMap.get(_expression);\n+\n+    // Treat BYTES value as serialized RoaringBitmap\n+    DataType valueType = blockValSet.getValueType();\n+    if (valueType == DataType.BYTES) {\n+      byte[][] bytesValues = blockValSet.getBytesValuesSV();\n+      RoaringBitmap bitmap = aggregationResultHolder.getResult();\n+      if (bitmap != null) {\n+        for (int i = 0; i < length; i++) {\n+          bitmap.or(ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[i]));\n+        }\n+      } else {\n+        bitmap = ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[0]);\n+        aggregationResultHolder.setValue(bitmap);\n+        for (int i = 1; i < length; i++) {\n+          bitmap.or(ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[i]));\n+        }\n+      }\n+      return;\n+    }\n+\n+    // For dictionary-encoded expression, store dictionary ids into the bitmap\n+    RoaringBitmap bitmap = getBitmap(aggregationResultHolder);\n+    Dictionary dictionary = blockValSet.getDictionary();\n+    if (dictionary != null) {\n+      _dictionary = dictionary;\n+      int[] dictIds = blockValSet.getDictionaryIdsSV();\n+      bitmap.addN(dictIds, 0, length);\n+      return;\n+    }\n+\n+    // For non-dictionary-encoded expression, store hash code of the values into the bitmap\n+    switch (valueType) {\n+      case INT:\n+        int[] intValues = blockValSet.getIntValuesSV();\n+        bitmap.addN(intValues, 0, length);\n+        break;\n+      case LONG:\n+        long[] longValues = blockValSet.getLongValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          bitmap.add(Long.hashCode(longValues[i]));\n+        }\n+        break;\n+      case FLOAT:\n+        float[] floatValues = blockValSet.getFloatValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          bitmap.add(Float.hashCode(floatValues[i]));\n+        }\n+        break;\n+      case DOUBLE:\n+        double[] doubleValues = blockValSet.getDoubleValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          bitmap.add(Double.hashCode(doubleValues[i]));\n+        }\n+        break;\n+      case STRING:\n+        String[] stringValues = blockValSet.getStringValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          bitmap.add(stringValues[i].hashCode());\n+        }\n+        break;\n+      default:\n+        throw new IllegalStateException(\n+            \"Illegal data type for DISTINCT_COUNT_BITMAP aggregation function: \" + valueType);\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    BlockValSet blockValSet = blockValSetMap.get(_expression);\n+\n+    // Treat BYTES value as serialized RoaringBitmap\n+    DataType valueType = blockValSet.getValueType();\n+    if (valueType == DataType.BYTES) {\n+      byte[][] bytesValues = blockValSet.getBytesValuesSV();\n+      for (int i = 0; i < length; i++) {\n+        RoaringBitmap value = ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[i]);\n+        int groupKey = groupKeyArray[i];\n+        RoaringBitmap bitmap = groupByResultHolder.getResult(groupKey);\n+        if (bitmap != null) {\n+          bitmap.or(value);\n+        } else {\n+          groupByResultHolder.setValueForKey(groupKey, value);\n+        }\n+      }\n+      return;\n+    }\n+\n+    // For dictionary-encoded expression, store dictionary ids into the bitmap\n+    Dictionary dictionary = blockValSet.getDictionary();\n+    if (dictionary != null) {\n+      _dictionary = dictionary;\n+      int[] dictIds = blockValSet.getDictionaryIdsSV();\n+      for (int i = 0; i < length; i++) {\n+        getBitmap(groupByResultHolder, groupKeyArray[i]).add(dictIds[i]);\n+      }\n+      return;\n+    }\n+\n+    // For non-dictionary-encoded expression, store hash code of the values into the bitmap\n+    switch (valueType) {\n+      case INT:\n+        int[] intValues = blockValSet.getIntValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(intValues[i]);\n+        }\n+        break;\n+      case LONG:\n+        long[] longValues = blockValSet.getLongValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(Long.hashCode(longValues[i]));\n+        }\n+        break;\n+      case FLOAT:\n+        float[] floatValues = blockValSet.getFloatValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(Float.hashCode(floatValues[i]));\n+        }\n+        break;\n+      case DOUBLE:\n+        double[] doubleValues = blockValSet.getDoubleValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(Double.hashCode(doubleValues[i]));\n+        }\n+        break;\n+      case STRING:\n+        String[] stringValues = blockValSet.getStringValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(stringValues[i].hashCode());\n+        }\n+        break;\n+      default:\n+        throw new IllegalStateException(\n+            \"Illegal data type for DISTINCT_COUNT_BITMAP aggregation function: \" + valueType);\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    BlockValSet blockValSet = blockValSetMap.get(_expression);\n+\n+    // Treat BYTES value as serialized RoaringBitmap\n+    DataType valueType = blockValSet.getValueType();\n+    if (valueType == DataType.BYTES) {\n+      byte[][] bytesValues = blockValSet.getBytesValuesSV();\n+      for (int i = 0; i < length; i++) {\n+        RoaringBitmap value = ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[i]);\n+        for (int groupKey : groupKeysArray[i]) {\n+          RoaringBitmap bitmap = groupByResultHolder.getResult(groupKey);\n+          if (bitmap != null) {\n+            bitmap.or(value);\n+          } else {\n+            // Clone a bitmap for the group\n+            groupByResultHolder.setValueForKey(groupKey, value.clone());\n+          }\n+        }\n+      }\n+      return;\n+    }\n+\n+    // For dictionary-encoded expression, store dictionary ids into the bitmap\n+    Dictionary dictionary = blockValSet.getDictionary();\n+    if (dictionary != null) {\n+      _dictionary = dictionary;\n+      int[] dictIds = blockValSet.getDictionaryIdsSV();\n+      for (int i = 0; i < length; i++) {\n+        setValueForGroupKeys(groupByResultHolder, groupKeysArray[i], dictIds[i]);\n+      }\n+      return;\n+    }\n+\n+    // For non-dictionary-encoded expression, store hash code of the values into the bitmap\n+    switch (valueType) {\n+      case INT:\n+        int[] intValues = blockValSet.getIntValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          setValueForGroupKeys(groupByResultHolder, groupKeysArray[i], intValues[i]);\n+        }\n+        break;\n+      case LONG:\n+        long[] longValues = blockValSet.getLongValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          setValueForGroupKeys(groupByResultHolder, groupKeysArray[i], Long.hashCode(longValues[i]));\n+        }\n+        break;\n+      case FLOAT:\n+        float[] floatValues = blockValSet.getFloatValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          setValueForGroupKeys(groupByResultHolder, groupKeysArray[i], Float.hashCode(floatValues[i]));\n+        }\n+        break;\n+      case DOUBLE:\n+        double[] doubleValues = blockValSet.getDoubleValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          setValueForGroupKeys(groupByResultHolder, groupKeysArray[i], Double.hashCode(doubleValues[i]));\n+        }\n+        break;\n+      case STRING:\n+        String[] stringValues = blockValSet.getStringValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          setValueForGroupKeys(groupByResultHolder, groupKeysArray[i], stringValues[i].hashCode());\n+        }\n+        break;\n+      default:\n+        throw new IllegalStateException(\n+            \"Illegal data type for DISTINCT_COUNT_BITMAP aggregation function: \" + valueType);\n+    }\n+  }\n+\n+  @Override\n+  public RoaringBitmap extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    RoaringBitmap bitmap = aggregationResultHolder.getResult();\n+    if (bitmap == null) {\n+      return new RoaringBitmap();\n+    }\n+\n+    if (_dictionary != null) {\n+      // For dictionary-encoded expression, convert dictionary ids to hash code of the values\n+      return convertToValueBitmap(bitmap, _dictionary);\n+    } else {\n+      // For serialized RoaringBitmap and non-dictionary-encoded expression, directly return the bitmap\n+      return bitmap;\n+    }\n+  }\n+\n+  @Override\n+  public RoaringBitmap extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    RoaringBitmap bitmap = groupByResultHolder.getResult(groupKey);\n+    if (bitmap == null) {\n+      return new RoaringBitmap();\n+    }\n+\n+    if (_dictionary != null) {\n+      // For dictionary-encoded expression, convert dictionary ids to hash code of the values\n+      return convertToValueBitmap(bitmap, _dictionary);\n+    } else {\n+      // For serialized RoaringBitmap and non-dictionary-encoded expression, directly return the bitmap\n+      return bitmap;\n+    }\n+  }\n+\n+  @Override\n+  public RoaringBitmap merge(RoaringBitmap intermediateResult1, RoaringBitmap intermediateResult2) {\n+    intermediateResult1.or(intermediateResult2);\n+    return intermediateResult1;\n+  }\n+\n+  @Override\n+  public boolean isIntermediateResultComparable() {\n+    return false;\n+  }\n+\n+  @Override\n+  public ColumnDataType getIntermediateResultColumnType() {\n+    return ColumnDataType.OBJECT;\n+  }\n+\n+  @Override\n+  public ColumnDataType getFinalResultColumnType() {\n+    return ColumnDataType.INT;\n+  }\n+\n+  @Override\n+  public Integer extractFinalResult(RoaringBitmap intermediateResult) {\n+    return intermediateResult.getCardinality();\n+  }\n+\n+  /**\n+   * Returns the bitmap from the result holder or creates a new one if it does not exist.\n+   */\n+  protected static RoaringBitmap getBitmap(AggregationResultHolder aggregationResultHolder) {\n+    RoaringBitmap bitmap = aggregationResultHolder.getResult();\n+    if (bitmap == null) {\n+      bitmap = new RoaringBitmap();\n+      aggregationResultHolder.setValue(bitmap);\n+    }\n+    return bitmap;\n+  }\n+\n+  /**\n+   * Returns the bitmap for the given group key or creates a new one if it does not exist.\n+   */\n+  protected static RoaringBitmap getBitmap(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    RoaringBitmap bitmap = groupByResultHolder.getResult(groupKey);\n+    if (bitmap == null) {\n+      bitmap = new RoaringBitmap();\n+      groupByResultHolder.setValueForKey(groupKey, bitmap);\n+    }\n+    return bitmap;\n+  }\n+\n+  /**\n+   * Helper method to set value for the given group keys into the result holder.\n+   */\n+  private void setValueForGroupKeys(GroupByResultHolder groupByResultHolder, int[] groupKeys, int value) {\n+    for (int groupKey : groupKeys) {\n+      getBitmap(groupByResultHolder, groupKey).add(value);\n+    }\n+  }\n+\n+  /**\n+   * Helper method to read dictionary and convert dictionary ids to hash code of the values for dictionary-encoded\n+   * expression.\n+   */\n+  private static RoaringBitmap convertToValueBitmap(RoaringBitmap dictIdBitmap, Dictionary dictionary) {", "originalCommit": "20b6ec5119ed7677fcde5f39348ec9e780eb582a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4NjIwMg==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463886202", "bodyText": "That is exactly the purpose of using RoaringBitmap, which is the well compressed version of the BitSet. The serialized RoaringBitmap size is much smaller than the serialized IntOpenHashSet.", "author": "Jackie-Jiang", "createdAt": "2020-07-31T23:31:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwODU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwODY1NQ==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463708655", "bodyText": "Javadoc would be good", "author": "siddharthteotia", "createdAt": "2020-07-31T16:26:01Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapMVAggregationFunction.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.segment.index.readers.Dictionary;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n+import org.roaringbitmap.RoaringBitmap;\n+\n+\n+public class DistinctCountBitmapMVAggregationFunction extends DistinctCountBitmapAggregationFunction {", "originalCommit": "20b6ec5119ed7677fcde5f39348ec9e780eb582a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4NjIwNw==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463886207", "bodyText": "Added", "author": "Jackie-Jiang", "createdAt": "2020-07-31T23:31:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwODY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwOTExNg==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463709116", "bodyText": "Do we not need to add end-to-end query execution test for the new function without star tree as well", "author": "siddharthteotia", "createdAt": "2020-07-31T16:27:02Z", "path": "pinot-core/src/test/java/org/apache/pinot/core/startree/v2/DistinctCountBitmapStarTreeV2Test.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.startree.v2;", "originalCommit": "20b6ec5119ed7677fcde5f39348ec9e780eb582a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4NjI5MA==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463886290", "bodyText": "Good point, will add", "author": "Jackie-Jiang", "createdAt": "2020-07-31T23:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwOTExNg=="}], "type": "inlineReview"}, {"oid": "1a4405ff7832a77d76b08ab516fd70eaa3463895", "url": "https://github.com/apache/pinot/commit/1a4405ff7832a77d76b08ab516fd70eaa3463895", "message": "Add DistinctCountBitmap aggregation function", "committedDate": "2020-08-01T00:30:42Z", "type": "commit"}, {"oid": "1a4405ff7832a77d76b08ab516fd70eaa3463895", "url": "https://github.com/apache/pinot/commit/1a4405ff7832a77d76b08ab516fd70eaa3463895", "message": "Add DistinctCountBitmap aggregation function", "committedDate": "2020-08-01T00:30:42Z", "type": "forcePushed"}]}