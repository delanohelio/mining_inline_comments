{"pr_number": 5718, "pr_title": "Feature/#5390 segment indexing reload status api", "pr_createdAt": "2020-07-20T00:59:34Z", "pr_url": "https://github.com/apache/pinot/pull/5718", "timeline": [{"oid": "e9a1c935209fd6de065deefbe03352694b43ec7e", "url": "https://github.com/apache/pinot/commit/e9a1c935209fd6de065deefbe03352694b43ec7e", "message": "- initial feature push", "committedDate": "2020-07-20T04:49:22Z", "type": "commit"}, {"oid": "e1aa8980d26a5e5b3d5c61b5a52f8459b68b8ea5", "url": "https://github.com/apache/pinot/commit/e1aa8980d26a5e5b3d5c61b5a52f8459b68b8ea5", "message": "Segment Reload API\n- added a new API endpoint for users to query segment reload status\n\nAPI - Table metadata from Server\n- added a new endpoint to fetch segment metadata\n\n- added helper classes and methods to fetch metadata from the server\n\nTests\n- added test to server API to fetch metadata including indexing information", "committedDate": "2020-07-20T04:55:03Z", "type": "commit"}, {"oid": "422c76a7c7bc3291a41970a21825a4ef2bded208", "url": "https://github.com/apache/pinot/commit/422c76a7c7bc3291a41970a21825a4ef2bded208", "message": "Code Refactor:\n- Moved status classes to logical places\n\nLogs\n- Added logging statements\n\nTests\n- Added unit tests for Pinot Controller reload status and segment metadata API\n- Added unit tests for Pinot Server reload status and segment metadata API\n\nLicense Headers\n- Add license headers to files added to this feature", "committedDate": "2020-07-21T01:49:25Z", "type": "forcePushed"}, {"oid": "7e31c1136090a48823c1a159d8608f37375a0096", "url": "https://github.com/apache/pinot/commit/7e31c1136090a48823c1a159d8608f37375a0096", "message": "Code Refactor:\n- Moved status classes to logical places\n\nLogs\n- Added logging statements\n\nTests\n- Added unit tests for Pinot Controller reload status and segment metadata API\n- Added unit tests for Pinot Server reload status and segment metadata API\n\nLicense Headers\n- Add license headers to files added to this feature", "committedDate": "2020-07-21T02:43:09Z", "type": "commit"}, {"oid": "7e31c1136090a48823c1a159d8608f37375a0096", "url": "https://github.com/apache/pinot/commit/7e31c1136090a48823c1a159d8608f37375a0096", "message": "Code Refactor:\n- Moved status classes to logical places\n\nLogs\n- Added logging statements\n\nTests\n- Added unit tests for Pinot Controller reload status and segment metadata API\n- Added unit tests for Pinot Server reload status and segment metadata API\n\nLicense Headers\n- Add license headers to files added to this feature", "committedDate": "2020-07-21T02:43:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NTI0NA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r459165244", "bodyText": "there seems to be some unnecessary formatting/whitespaces on all methods of this file. Could you revert those? you should be able to auto-format using the IDE\nsame comment for TablesResourceTest file", "author": "npawar", "createdAt": "2020-07-23T01:04:15Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -128,20 +137,33 @@\n @Api(tags = Constants.SEGMENT_TAG)\n @Path(\"/\")\n public class PinotSegmentRestletResource {\n-  private static Logger LOGGER = LoggerFactory.getLogger(PinotSegmentRestletResource.class);\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PinotSegmentRestletResource.class);\n+\n+  @Inject\n+  ControllerConf _controllerConf;\n \n   @Inject\n   PinotHelixResourceManager _pinotHelixResourceManager;\n \n+  @Inject\n+  Executor _executor;\n+\n+  @Inject\n+  HttpConnectionManager _connectionManager;\n+\n+  @Inject\n+  ControllerMetrics _controllerMetrics;\n+\n+\n   @GET\n   @Produces(MediaType.APPLICATION_JSON)\n   @Path(\"/segments/{tableName}\")\n   @ApiOperation(value = \"List all segments\", notes = \"List all segments\")\n   public List<Map<TableType, List<String>>> getSegments(\n-      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ4OTQ2OQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460489469", "bodyText": "Some setting on my IDE got changed for the Pinot checkstyle. Have updated it again. Should be fixed in my next commit.", "author": "guruguha", "createdAt": "2020-07-26T07:07:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NTI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NTU5Ng==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r459165596", "bodyText": "i could spot no change in this method vs same method moved at the bottom. can we keep it here, so that the scope of review stays limited to the actual changes?", "author": "npawar", "createdAt": "2020-07-23T01:05:48Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -246,21 +268,7 @@\n       return segmentMetadata;\n     } else {\n       throw new ControllerApplicationException(LOGGER,\n-          \"Failed to find segment: \" + segmentName + \" in table: \" + tableName, Status.NOT_FOUND);\n-    }\n-  }\n-\n-  @Nullable", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5MjY2NA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460492664", "bodyText": "my bad.", "author": "guruguha", "createdAt": "2020-07-26T07:40:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NTU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ2OTQ2OQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460469469", "bodyText": "is there a better return code for this? NOT_FOUND suggests that the table was not found", "author": "npawar", "createdAt": "2020-07-26T02:38:29Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5MzE3OQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460493179", "bodyText": "since it is a propagated exception, it is better to have the message originally thrown. Updating the same.", "author": "guruguha", "createdAt": "2020-07-26T07:45:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ2OTQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MTMxMg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460471312", "bodyText": "nit: How about String.format for constructing these", "author": "npawar", "createdAt": "2020-07-26T03:07:07Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.pinot.common.http.MultiGetRequest;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.info(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    CompletionService<GetMethod> completionService =\n+            new MultiGetRequest(_executor, _connectionManager).execute(serverURLs, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    for (int i = 0; i < serverURLs.size(); i++) {\n+      GetMethod getMethod = null;\n+      try {\n+        getMethod = completionService.take().get();\n+        URI uri = getMethod.getURI();\n+        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n+        if (getMethod.getStatusCode() >= 300) {\n+          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          continue;\n+        }\n+        JsonNode segmentMetadata =\n+                JsonUtils.inputStreamToJsonNode(getMethod.getResponseBodyAsStream());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+        LOGGER.info(\"Updated segment metadata: {}\", segmentMetadata.size());\n+      } catch (Exception e) {\n+        // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n+        // Log the number of failed servers after gathering all responses\n+      } finally {\n+        if (Objects.nonNull(getMethod)) {\n+          getMethod.releaseConnection();\n+        }\n+      }\n+    }\n+    return segmentsMetadata;\n+  }\n+\n+  private String generateSegmentMetadataServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return \"http://\" + endpoint + \"/tables/\" + tableNameWithType + \"/segments/\" + segmentName + \"/metadata\";\n+  }\n+\n+  private String generateReloadStatusServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return \"http://\" + endpoint + \"/tables/\" + tableNameWithType + \"/segments/\" + segmentName + \"/reload-status\";", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MTM3NQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460471375", "bodyText": "nit: for readability\ns/serversToSegmentsMap/serverToSegments\ns/endpoints/serverToEndpoint", "author": "npawar", "createdAt": "2020-07-26T03:08:17Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.pinot.common.http.MultiGetRequest;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.info(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    CompletionService<GetMethod> completionService =\n+            new MultiGetRequest(_executor, _connectionManager).execute(serverURLs, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    for (int i = 0; i < serverURLs.size(); i++) {\n+      GetMethod getMethod = null;\n+      try {\n+        getMethod = completionService.take().get();\n+        URI uri = getMethod.getURI();\n+        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n+        if (getMethod.getStatusCode() >= 300) {\n+          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          continue;\n+        }\n+        JsonNode segmentMetadata =\n+                JsonUtils.inputStreamToJsonNode(getMethod.getResponseBodyAsStream());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+        LOGGER.info(\"Updated segment metadata: {}\", segmentMetadata.size());\n+      } catch (Exception e) {\n+        // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n+        // Log the number of failed servers after gathering all responses\n+      } finally {\n+        if (Objects.nonNull(getMethod)) {\n+          getMethod.releaseConnection();\n+        }\n+      }\n+    }\n+    return segmentsMetadata;\n+  }\n+\n+  private String generateSegmentMetadataServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return \"http://\" + endpoint + \"/tables/\" + tableNameWithType + \"/segments/\" + segmentName + \"/metadata\";\n+  }\n+\n+  private String generateReloadStatusServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return \"http://\" + endpoint + \"/tables/\" + tableNameWithType + \"/segments/\" + segmentName + \"/reload-status\";\n+  }\n+\n+  public List<SegmentStatus> getSegmentReloadTime(String tableNameWithType,\n+                                                  Map<String, List<String>> serversToSegmentsMap,", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MTYxMA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460471610", "bodyText": "how about logging the message also here?", "author": "npawar", "createdAt": "2020-07-26T03:12:07Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.pinot.common.http.MultiGetRequest;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.info(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    CompletionService<GetMethod> completionService =\n+            new MultiGetRequest(_executor, _connectionManager).execute(serverURLs, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    for (int i = 0; i < serverURLs.size(); i++) {\n+      GetMethod getMethod = null;\n+      try {\n+        getMethod = completionService.take().get();\n+        URI uri = getMethod.getURI();\n+        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n+        if (getMethod.getStatusCode() >= 300) {\n+          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          continue;\n+        }\n+        JsonNode segmentMetadata =\n+                JsonUtils.inputStreamToJsonNode(getMethod.getResponseBodyAsStream());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+        LOGGER.info(\"Updated segment metadata: {}\", segmentMetadata.size());\n+      } catch (Exception e) {\n+        // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n+        // Log the number of failed servers after gathering all responses\n+      } finally {\n+        if (Objects.nonNull(getMethod)) {\n+          getMethod.releaseConnection();\n+        }\n+      }\n+    }\n+    return segmentsMetadata;\n+  }\n+\n+  private String generateSegmentMetadataServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return \"http://\" + endpoint + \"/tables/\" + tableNameWithType + \"/segments/\" + segmentName + \"/metadata\";\n+  }\n+\n+  private String generateReloadStatusServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return \"http://\" + endpoint + \"/tables/\" + tableNameWithType + \"/segments/\" + segmentName + \"/reload-status\";\n+  }\n+\n+  public List<SegmentStatus> getSegmentReloadTime(String tableNameWithType,\n+                                                  Map<String, List<String>> serversToSegmentsMap,\n+                                                  BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.info(\"Reading segment reload status from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateReloadStatusServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    CompletionService<GetMethod> completionService =\n+            new MultiGetRequest(_executor, _connectionManager).execute(serverURLs, timeoutMs);\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    List<SegmentStatus> segmentsStatus = new ArrayList<>();\n+\n+    for (int i = 0; i < serverURLs.size(); i++) {\n+      GetMethod getMethod = null;\n+      try {\n+        getMethod = completionService.take().get();\n+        URI uri = getMethod.getURI();\n+        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n+        if (getMethod.getStatusCode() >= 300) {\n+          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5MDkxOA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460490918", "bodyText": "Would the message be formatted in anyway or will it be a full stack trace?", "author": "guruguha", "createdAt": "2020-07-26T07:22:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MTYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MTg2Mg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460471862", "bodyText": "can tableReloadStatus ever be null? you'll either catch exception above, or have a non-null reload status", "author": "npawar", "createdAt": "2020-07-26T03:15:41Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5NDE1Mw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460494153", "bodyText": "That's true! Will remove the null check.", "author": "guruguha", "createdAt": "2020-07-26T07:56:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MTg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjAxNw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472017", "bodyText": "In the TableReloadStatus, can we also add a message telling the caller how many segments failed to report?", "author": "npawar", "createdAt": "2020-07-26T03:18:21Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjIxNw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472217", "bodyText": "Let's specify that this metadata includes metadata from server. Was this the api name that we finally settled on? It's too similar to the other \"metadata\" endpoint and bound to cause confusion", "author": "npawar", "createdAt": "2020-07-26T03:21:21Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    TableMetadataReader tableMetadataReader =\n+            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n+            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5NTkxNQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460495915", "bodyText": "@kishoreg had mentioned that we will discuss further into the PR on this. So, we're yet to finalize on that.", "author": "guruguha", "createdAt": "2020-07-26T08:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjM2OQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472369", "bodyText": "nit: wrap this in {}", "author": "npawar", "createdAt": "2020-07-26T03:23:29Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    TableMetadataReader tableMetadataReader =\n+            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n+            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME)", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjM5MQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472391", "bodyText": "you already have tableType 3 lines above", "author": "npawar", "createdAt": "2020-07-26T03:24:00Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    TableMetadataReader tableMetadataReader =\n+            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n+            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME)\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjUzNg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472536", "bodyText": "does this call return the CONSUMING (mutable) segments and do we need to skip them here?\nAlso how come we're supporting realtime table in reload-status, but not in metadata? I thought we're only planning to skip the CONSUMING segment in both endpoints", "author": "npawar", "createdAt": "2020-07-26T03:25:45Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5NzQ4Mw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460497483", "bodyText": "You're right, we're skipping CONSUMING segments in both endpoints. Added the check for both endpoints.", "author": "guruguha", "createdAt": "2020-07-26T08:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjUzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU3NDQ4NA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460574484", "bodyText": "REALTIME tables have some CONSUMING segments (Mutable) and some ONLINE segments (Immutable). We want to still process the Immutable segments of the REALTIME table. The current implementation will skip REALTIME entirely. It's okay if you want to take that up in a follow-up. You can mention in description that this is only for OFFLINE as of now", "author": "npawar", "createdAt": "2020-07-26T21:16:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjYzNw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472637", "bodyText": "some validation to check if table was not found?\nsame for the metadata endpoint", "author": "npawar", "createdAt": "2020-07-26T03:27:45Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5Mzk4Nw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460493987", "bodyText": "This is taken care in the getExistingTableNamesWithType method", "author": "guruguha", "createdAt": "2020-07-26T07:54:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3Mjc3Mw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472773", "bodyText": "if table is not found, line 546 itself will throw exception.", "author": "npawar", "createdAt": "2020-07-26T03:30:02Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    TableMetadataReader tableMetadataReader =\n+            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n+            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME)\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, String> segmentsMetadata = null;\n+    try {\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+    } catch (InvalidConfigException e) {\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+    } catch (IOException ioe) {\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+    }\n+    if (segmentsMetadata == null)", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5NTIzNw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460495237", "bodyText": "That exception has been updated to the propagated exception. Also, as mentioned before, the segmentsMetadata will not be null.", "author": "guruguha", "createdAt": "2020-07-26T08:07:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3Mjc3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjgwNw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472807", "bodyText": "nit: remove trace logs?", "author": "npawar", "createdAt": "2020-07-26T03:30:27Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    TableMetadataReader tableMetadataReader =\n+            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n+            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME)\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, String> segmentsMetadata = null;\n+    try {\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+    } catch (InvalidConfigException e) {\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+    } catch (IOException ioe) {\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+    }\n+    if (segmentsMetadata == null)\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+    return segmentsMetadata;\n+  }\n+\n+  private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n+          throws InvalidConfigException, IOException {\n+    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzA3Nw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460473077", "bodyText": "can we move call to fetch serverToSegmentsMap inside this method, so that it's consistent with the getSegmentsMetadata Method?", "author": "npawar", "createdAt": "2020-07-26T03:34:57Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/TableMetadataReader.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.exception.InvalidConfigException;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.controller.api.resources.ServerSegmentMetadataReader;\n+import org.apache.pinot.controller.helix.core.PinotHelixResourceManager;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class TableMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(TableMetadataReader.class);\n+\n+  private final Executor executor;\n+  private final HttpConnectionManager connectionManager;\n+  private final PinotHelixResourceManager pinotHelixResourceManager;\n+\n+  public TableMetadataReader(Executor executor, HttpConnectionManager connectionManager,\n+                             PinotHelixResourceManager helixResourceManager) {\n+    this.executor = executor;\n+    this.connectionManager = connectionManager;\n+    this.pinotHelixResourceManager = helixResourceManager;\n+  }\n+\n+  public TableReloadStatus getReloadStatus(String tableNameWithType, Map<String, List<String>> serverToSegmentsMap,", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5MTQ2OQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460491469", "bodyText": "It is outside in both methods as the \"server side\" classes don't have the resourceManager object. If it is moved to server side classes then the resourceManager object needs to be passed on - which might be overkill?", "author": "guruguha", "createdAt": "2020-07-26T07:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU3MzIwNg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460573206", "bodyText": "oh i meant this call\nfinal Map<String, List<String>> serverToSegments = _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n\nIt is called in the getSegmentsMetadata, but for getReloadStatus, it is being passed from caller", "author": "npawar", "createdAt": "2020-07-26T21:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxMjI0MA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r461312240", "bodyText": "I see, got it. updated the same.", "author": "guruguha", "createdAt": "2020-07-28T04:35:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzIzNA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460473234", "bodyText": "didnt understand why this needs to be copied to another ObjectNode. Can we get it directly from JsonNode?", "author": "npawar", "createdAt": "2020-07-26T03:36:50Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/TableMetadataReader.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.exception.InvalidConfigException;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.controller.api.resources.ServerSegmentMetadataReader;\n+import org.apache.pinot.controller.helix.core.PinotHelixResourceManager;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class TableMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(TableMetadataReader.class);\n+\n+  private final Executor executor;\n+  private final HttpConnectionManager connectionManager;\n+  private final PinotHelixResourceManager pinotHelixResourceManager;\n+\n+  public TableMetadataReader(Executor executor, HttpConnectionManager connectionManager,\n+                             PinotHelixResourceManager helixResourceManager) {\n+    this.executor = executor;\n+    this.connectionManager = connectionManager;\n+    this.pinotHelixResourceManager = helixResourceManager;\n+  }\n+\n+  public TableReloadStatus getReloadStatus(String tableNameWithType, Map<String, List<String>> serverToSegmentsMap,\n+                                           int timeoutMs)\n+          throws InvalidConfigException {\n+    BiMap<String, String> endpoints = pinotHelixResourceManager.getDataInstanceAdminEndpoints(serverToSegmentsMap.keySet());\n+    ServerSegmentMetadataReader serverSegmentMetadataReader = new ServerSegmentMetadataReader(executor, connectionManager);\n+\n+    List<SegmentStatus> segmentStatus = serverSegmentMetadataReader.getSegmentReloadTime(tableNameWithType, serverToSegmentsMap, endpoints, timeoutMs);\n+    TableReloadStatus tableReloadStatus = new TableReloadStatus();\n+    tableReloadStatus._tableName = tableNameWithType;\n+    tableReloadStatus._segmentStatus = segmentStatus;\n+    return tableReloadStatus;\n+  }\n+\n+  public Map<String, String> getSegmentsMetadata(String tableNameWithType, int timeoutMs) throws InvalidConfigException, IOException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    BiMap<String, String> endpoints = pinotHelixResourceManager.getDataInstanceAdminEndpoints(serversToSegmentsMap.keySet());\n+    ServerSegmentMetadataReader serverSegmentMetadataReader = new ServerSegmentMetadataReader(executor, connectionManager);\n+\n+    List<String> segmentsMetadata = serverSegmentMetadataReader.getSegmentMetadataFromServer(tableNameWithType,\n+            serversToSegmentsMap, endpoints, timeoutMs);\n+\n+    Map<String, String> response = new HashMap<>();\n+    for (String segmentMetadata : segmentsMetadata) {\n+      JsonNode responseJson = JsonUtils.stringToJsonNode(segmentMetadata);\n+      ObjectNode objectNode = responseJson.deepCopy();", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5MTYyMw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460491623", "bodyText": "I had it for a different logic - will remove.", "author": "guruguha", "createdAt": "2020-07-26T07:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460473352", "bodyText": "How about moving this also to TableReader just like TableReloadStatus? Also, if  you need the equals and hashcode, use EqualityUtils (look at Schema  class for example)", "author": "npawar", "createdAt": "2020-07-26T03:39:03Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+import java.util.Objects;\n+\n+public class SegmentStatus {", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ4OTc0NA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460489744", "bodyText": "SegmentStatus is used in the server code as well. So, added a class to common for referencing.", "author": "guruguha", "createdAt": "2020-07-26T07:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU3MjU1NQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460572555", "bodyText": "Could you change equals and hashcode to use EqualityUtils? Look at other classes in pinot-api for reference", "author": "npawar", "createdAt": "2020-07-26T20:56:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMwMzkwNg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r461303906", "bodyText": "Working on changing the equals and hashcode. Will commit the changes.", "author": "guruguha", "createdAt": "2020-07-28T04:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxMDUzMQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r461310531", "bodyText": "Actually, we may not need the equality methods yet, removing them.", "author": "guruguha", "createdAt": "2020-07-28T04:28:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0MTA3NQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462441075", "bodyText": "So, you are using this same class in both Controller as well as Server APIs. That is nice but has its pit falls. Imagine a case when we add a new field to this object. We cannot upgrade controllers and servers at the same time. So, there can exist a situation where servers are sending the old object (serialized) and the controller is trying to deserialize them using the new object. Or, vice versa.\nAt the minimum:\n\nWrite a block of comment at the top of the class that this class is upgrade sensitive explaining what may happen if it is changed without regard to upgrade consideration.\nSpecifically mention that fields cannot be removed from the class (I suppose, unless there are proper defaults)\nAdd an annotation to ignore unknown fields at the class level.", "author": "mcvsubbu", "createdAt": "2020-07-29T16:47:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1MzI1Nw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462453257", "bodyText": "I strongly suggest we return a different object to the user instead of returning this one. It will enable us to evolve the internal interface independent of interface exposed to the user.\nAlso, the controller returned status could include other run-time status about a segment. For example:\n\nHelix externalview of the server so we know if it is online or not.\nThe crc, size, date uploaded/refreshed, etc. from segment metadata\nOther info as wee want to add later (e.g. number of times segment was hit/searched/selected since reboot, etc.)", "author": "mcvsubbu", "createdAt": "2020-07-29T17:07:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1NDk3NA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462454974", "bodyText": "Please document each member in this object clearly, what it contains in various situations", "author": "mcvsubbu", "createdAt": "2020-07-29T17:09:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgzODgwMw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r463838803", "bodyText": "Thanks for the suggestions! I will think about how to refactor my code and commit again.", "author": "guruguha", "createdAt": "2020-07-31T21:02:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5MzYwNQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474093605", "bodyText": "Not all comments have been addressed. Please justify the use of the same class to return values to the user. It makes upgrades bad. Add json ignore case so that the pain is at least reduced a bit.", "author": "mcvsubbu", "createdAt": "2020-08-20T15:57:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwMTcwNw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r475101707", "bodyText": "I think we do have that separation. We have a class TableReloadStatus in the controller that can be used to enhance any future requirements. The SegmentLoadStatus class can be then used for specific API - the loadStatus API.\nI have added JSON ignore to the SegmentLoadStatus class.", "author": "guruguha", "createdAt": "2020-08-22T15:30:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzUzOQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460473539", "bodyText": "nit: this log is misleading \"Updated metadata\"", "author": "npawar", "createdAt": "2020-07-26T03:41:30Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.pinot.common.http.MultiGetRequest;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.info(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    CompletionService<GetMethod> completionService =\n+            new MultiGetRequest(_executor, _connectionManager).execute(serverURLs, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    for (int i = 0; i < serverURLs.size(); i++) {\n+      GetMethod getMethod = null;\n+      try {\n+        getMethod = completionService.take().get();\n+        URI uri = getMethod.getURI();\n+        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n+        if (getMethod.getStatusCode() >= 300) {\n+          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          continue;\n+        }\n+        JsonNode segmentMetadata =\n+                JsonUtils.inputStreamToJsonNode(getMethod.getResponseBodyAsStream());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+        LOGGER.info(\"Updated segment metadata: {}\", segmentMetadata.size());", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5MDA3NA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460490074", "bodyText": "changed log message", "author": "guruguha", "createdAt": "2020-07-26T07:13:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3NDMyNA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460474324", "bodyText": "remove comment", "author": "npawar", "createdAt": "2020-07-26T03:52:58Z", "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.server.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.manager.offline.ImmutableSegmentDataManager;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentImpl;\n+import org.apache.pinot.core.segment.index.column.ColumnIndexContainer;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+\n+public class SegmentColumnIndexesFetcher {\n+  public static JsonNode getIndexesForSegmentColumns(SegmentDataManager segmentDataManager, Set<String> columnSet) {\n+    ArrayNode columnsIndexMetadata = JsonUtils.newArrayNode();\n+    if (segmentDataManager instanceof ImmutableSegmentDataManager) {\n+      ImmutableSegmentDataManager immutableSegmentDataManager = (ImmutableSegmentDataManager) segmentDataManager;\n+      ImmutableSegment immutableSegment = immutableSegmentDataManager.getSegment();\n+      if (immutableSegment instanceof ImmutableSegmentImpl) {\n+        ImmutableSegmentImpl immutableSegmentImpl = (ImmutableSegmentImpl) immutableSegment;\n+//        Set<String> columns = immutableSegmentImpl.getSegmentMetadata().getAllColumns();", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3NDUyNQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460474525", "bodyText": "nit: wrap all the if else using {}\ncreate private static final constants for the keys and values that are being put in indexesNode.", "author": "npawar", "createdAt": "2020-07-26T03:55:48Z", "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.server.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.manager.offline.ImmutableSegmentDataManager;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentImpl;\n+import org.apache.pinot.core.segment.index.column.ColumnIndexContainer;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+\n+public class SegmentColumnIndexesFetcher {\n+  public static JsonNode getIndexesForSegmentColumns(SegmentDataManager segmentDataManager, Set<String> columnSet) {\n+    ArrayNode columnsIndexMetadata = JsonUtils.newArrayNode();\n+    if (segmentDataManager instanceof ImmutableSegmentDataManager) {\n+      ImmutableSegmentDataManager immutableSegmentDataManager = (ImmutableSegmentDataManager) segmentDataManager;\n+      ImmutableSegment immutableSegment = immutableSegmentDataManager.getSegment();\n+      if (immutableSegment instanceof ImmutableSegmentImpl) {\n+        ImmutableSegmentImpl immutableSegmentImpl = (ImmutableSegmentImpl) immutableSegment;\n+//        Set<String> columns = immutableSegmentImpl.getSegmentMetadata().getAllColumns();\n+        Map<String, ColumnIndexContainer> columnIndexContainerMap = immutableSegmentImpl.getIndexContainerMap();\n+        columnsIndexMetadata.add(getImmutableSegmentColumnIndexes(columnIndexContainerMap, columnSet));\n+      }\n+    }\n+    return columnsIndexMetadata;\n+  }\n+\n+  private static ObjectNode getImmutableSegmentColumnIndexes(Map<String, ColumnIndexContainer> columnIndexContainerMap,\n+                                                             Set<String> columnSet) {\n+    ObjectNode columnIndexMap = JsonUtils.newObjectNode();\n+\n+    for (Map.Entry<String, ColumnIndexContainer> e : columnIndexContainerMap.entrySet()) {\n+      if (columnSet != null && !columnSet.contains(e.getKey())) {\n+        continue;\n+      }\n+      ColumnIndexContainer columnIndexContainer = e.getValue();\n+      ObjectNode indexesNode = JsonUtils.newObjectNode();", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3NDU1Ng==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460474556", "bodyText": "any reason you're using ObjectNode instead of Map?", "author": "npawar", "createdAt": "2020-07-26T03:56:26Z", "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.server.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.manager.offline.ImmutableSegmentDataManager;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentImpl;\n+import org.apache.pinot.core.segment.index.column.ColumnIndexContainer;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+\n+public class SegmentColumnIndexesFetcher {\n+  public static JsonNode getIndexesForSegmentColumns(SegmentDataManager segmentDataManager, Set<String> columnSet) {\n+    ArrayNode columnsIndexMetadata = JsonUtils.newArrayNode();\n+    if (segmentDataManager instanceof ImmutableSegmentDataManager) {\n+      ImmutableSegmentDataManager immutableSegmentDataManager = (ImmutableSegmentDataManager) segmentDataManager;\n+      ImmutableSegment immutableSegment = immutableSegmentDataManager.getSegment();\n+      if (immutableSegment instanceof ImmutableSegmentImpl) {\n+        ImmutableSegmentImpl immutableSegmentImpl = (ImmutableSegmentImpl) immutableSegment;\n+//        Set<String> columns = immutableSegmentImpl.getSegmentMetadata().getAllColumns();\n+        Map<String, ColumnIndexContainer> columnIndexContainerMap = immutableSegmentImpl.getIndexContainerMap();\n+        columnsIndexMetadata.add(getImmutableSegmentColumnIndexes(columnIndexContainerMap, columnSet));\n+      }\n+    }\n+    return columnsIndexMetadata;\n+  }\n+\n+  private static ObjectNode getImmutableSegmentColumnIndexes(Map<String, ColumnIndexContainer> columnIndexContainerMap,\n+                                                             Set<String> columnSet) {\n+    ObjectNode columnIndexMap = JsonUtils.newObjectNode();\n+\n+    for (Map.Entry<String, ColumnIndexContainer> e : columnIndexContainerMap.entrySet()) {\n+      if (columnSet != null && !columnSet.contains(e.getKey())) {\n+        continue;\n+      }\n+      ColumnIndexContainer columnIndexContainer = e.getValue();\n+      ObjectNode indexesNode = JsonUtils.newObjectNode();\n+      if (Objects.isNull(columnIndexContainer.getBloomFilter())) indexesNode.put(\"bloom-filter\", \"NO\");\n+      else indexesNode.put(\"bloom-filter\", \"YES\");\n+\n+      if (Objects.isNull(columnIndexContainer.getDictionary())) indexesNode.put(\"dictionary\", \"NO\");\n+      else indexesNode.put(\"dictionary\", \"YES\");\n+\n+      if (Objects.isNull(columnIndexContainer.getForwardIndex())) indexesNode.put(\"forward-index\", \"NO\");\n+      else indexesNode.put(\"forward-index\", \"YES\");\n+\n+      if (Objects.isNull(columnIndexContainer.getInvertedIndex())) indexesNode.put(\"inverted-index\", \"NO\");\n+      else indexesNode.put(\"inverted-index\", \"YES\");\n+\n+      if (Objects.isNull(columnIndexContainer.getNullValueVector()))\n+        indexesNode.put(\"null-value-vector-reader\", \"NO\");\n+      else indexesNode.put(\"null-value-vector-reader\", \"YES\");\n+\n+      if (Objects.isNull(columnIndexContainer.getNullValueVector())) indexesNode.put(\"range-index\", \"NO\");\n+      else indexesNode.put(\"range-index\", \"YES\");\n+\n+      columnIndexMap.set(e.getKey(), indexesNode);\n+    }\n+    return columnIndexMap;", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ4OTQxMA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460489410", "bodyText": "The segment metadata is a JsonNode converted to a json string. I thought of using the same object conversion so that it is kept consistent.", "author": "guruguha", "createdAt": "2020-07-26T07:06:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3NDU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3NDgxNg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460474816", "bodyText": "remove all the unnecessary whitespace additions in this file", "author": "npawar", "createdAt": "2020-07-26T04:00:02Z", "path": "pinot-server/src/test/java/org/apache/pinot/server/api/TablesResourceTest.java", "diffHunk": "@@ -44,7 +48,7 @@\n \n   @Test\n   public void getTables()\n-      throws Exception {\n+          throws Exception {", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "url": "https://github.com/apache/pinot/commit/a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "message": "Code Review Changes\n- Updating code as per PR review comments", "committedDate": "2020-07-26T08:38:36Z", "type": "commit"}, {"oid": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1", "url": "https://github.com/apache/pinot/commit/1cea905ee8f4343b2c7f50a0612a53dae6fa34b1", "message": "Adding comments to new classes and methods added as part of this feature\nRemoving SegmentMetadataFetcher as it seemed redundant\nRefactoring code to save failed segment reload status API calls as part of response", "committedDate": "2020-07-28T04:46:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxNDcxMA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r457514710", "bodyText": "Is your IDE set to pinot coding guidelines?", "author": "mcvsubbu", "createdAt": "2020-07-20T15:52:12Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -176,23 +198,23 @@\n   @Produces(MediaType.APPLICATION_JSON)\n   @ApiOperation(value = \"Get a map from server to segments hosted by the server (deprecated, use 'GET /segments/{tableName}/servers' instead)\", notes = \"Get a map from server to segments hosted by the server (deprecated, use 'GET /segments/{tableName}/servers' instead)\")\n   public List<Map<String, String>> getServerToSegmentsMapDeprecated1(\n-      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-      @ApiParam(value = \"MUST be null\") @QueryParam(\"state\") String stateStr,\n-      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr)\n-      throws JsonProcessingException {\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,", "originalCommit": "6914c3249a31572d29a6f00e5b8f378aabfca3e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgyNzY5MQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r463827691", "bodyText": "Yes, there was some issue with my IDE itself. I updated the coding guidelines again and reformatted the files.", "author": "guruguha", "createdAt": "2020-07-31T20:47:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxNDcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxNzkzNA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r457517934", "bodyText": "If you are returning 404 (NOT_FOUND) then please do not use \"Failed\" in the exception message. Since the exception is invalid config, determine what is invalid and throw that exception, may be as 400 (BAD_REQUEST)", "author": "mcvsubbu", "createdAt": "2020-07-20T15:56:08Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);", "originalCommit": "6914c3249a31572d29a6f00e5b8f378aabfca3e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5MjEzNw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r463892137", "bodyText": "Updated in latest commit.", "author": "guruguha", "createdAt": "2020-08-01T00:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxNzkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxODc1NA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r457518754", "bodyText": "The exception message reads as if the table is not found. That is not the case, right?", "author": "mcvsubbu", "createdAt": "2020-07-20T15:57:08Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,", "originalCommit": "6914c3249a31572d29a6f00e5b8f378aabfca3e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxODk2MA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r457518960", "bodyText": "If there are no tables found, then this is the place to throw 404", "author": "mcvsubbu", "createdAt": "2020-07-20T15:57:26Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();", "originalCommit": "6914c3249a31572d29a6f00e5b8f378aabfca3e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUyMTY0Nw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r457521647", "bodyText": "remove these trace logs please", "author": "mcvsubbu", "createdAt": "2020-07-20T16:00:46Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    TableMetadataReader tableMetadataReader =\n+            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n+            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME)\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, String> segmentsMetadata = null;\n+    try {\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+    } catch (InvalidConfigException e) {\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+    } catch (IOException ioe) {\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+    }\n+    if (segmentsMetadata == null)\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+    return segmentsMetadata;\n+  }\n+\n+  private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n+          throws InvalidConfigException, IOException {\n+    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");", "originalCommit": "6914c3249a31572d29a6f00e5b8f378aabfca3e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUyMjkzNg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r457522936", "bodyText": "thy is this class in controller/api/resources? It should be inside controller/util", "author": "mcvsubbu", "createdAt": "2020-07-20T16:02:26Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package org.apache.pinot.controller.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.pinot.common.http.MultiGetRequest;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ServerSegmentMetadataReader {", "originalCommit": "6914c3249a31572d29a6f00e5b8f378aabfca3e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1NDQ2Nw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462454467", "bodyText": "Why is this a \"String\"? Why not 'long'?\nPlease clearly indicate the time unit in the field name. e.g. segmentReloadTimeUTCMs\nWhat is the value in this field if the segment was never reloaded, or the server restarts after the reload? Or, the reload faced an error and failed?", "author": "mcvsubbu", "createdAt": "2020-07-29T17:09:05Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+/**\n+ * Holds segment last reload time status along with any errors for a segment with unsuccessful call to get reload times.\n+ */\n+public class SegmentStatus {\n+  public String _segmentName;\n+  public String _segmentReloadTime;", "originalCommit": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1NjAyNg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462456026", "bodyText": "Let us call it \"loadStatus\" or \"runTimeStatus\" (I think all our APIs are in camel case). And change the comments/String below appropriately", "author": "mcvsubbu", "createdAt": "2020-07-29T17:11:38Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +503,80 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")", "originalCommit": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1NzE4OA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462457188", "bodyText": "Seems like a debug level log.", "author": "mcvsubbu", "createdAt": "2020-07-29T17:13:24Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +503,80 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, ServerSegmentMetadataReader.TableReloadStatus> getReloadStatus(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, ServerSegmentMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      ServerSegmentMetadataReader.TableReloadStatus tableReloadStatus;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n+      }\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private ServerSegmentMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+      throws InvalidConfigException {\n+    TableMetadataReader tableMetadataReader =\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType,\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);", "originalCommit": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1Nzk2OQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462457969", "bodyText": "Indicate the server name here that caused the error (unless that is logged elsewhere)", "author": "mcvsubbu", "createdAt": "2020-07-29T17:14:41Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +503,80 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, ServerSegmentMetadataReader.TableReloadStatus> getReloadStatus(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, ServerSegmentMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      ServerSegmentMetadataReader.TableReloadStatus tableReloadStatus;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n+      }\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private ServerSegmentMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+      throws InvalidConfigException {\n+    TableMetadataReader tableMetadataReader =\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType,\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n+    String tableNameWithType = getExistingTableNamesWithType(tableName, tableType).get(0);\n+    Map<String, String> segmentsMetadata;\n+    try {\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNameWithType);\n+    } catch (InvalidConfigException e) {\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n+    } catch (IOException ioe) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Error parsing Pinot server response: \" + ioe.getMessage(), Status.INTERNAL_SERVER_ERROR, ioe);", "originalCommit": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5NTc1Mg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r463895752", "bodyText": "Yes, is logged in the helper class", "author": "guruguha", "createdAt": "2020-08-01T00:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1Nzk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MDExMg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462460112", "bodyText": "I strongly suggest adding a verbosity level and/or a limit here. Can be added later if you wish. Imagine a table with a million segments. Do we really want to kill the servers trying to query all the segments? Or, output them only to let the client time out?\nAn example could be: limit=100 by default, verbosity=5. A level of 4, 3, 2,1 will show less information for each segment. Maybe 0 will only show how many segments that are online/offline etc.?", "author": "mcvsubbu", "createdAt": "2020-07-29T17:18:11Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +503,80 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")", "originalCommit": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgzMzc0Nw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r463833747", "bodyText": "Thanks for the suggestion. Makes sense to add limit. I did think about this, but then, the issue will be knowing the status of the remaining segments. For a table with say, 1000 segments, how do we let the user know of the status of the rest of the segments?", "author": "guruguha", "createdAt": "2020-07-31T20:55:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MDExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5NTI4Mg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r463895282", "bodyText": "Add an API to get status for a range of segments, maybe? Or, add some sort of start/limit?", "author": "mcvsubbu", "createdAt": "2020-08-01T00:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MDExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5NTYxNg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r463895616", "bodyText": "If you are adding one to get the status of one segment at a time, then the user can (if needed) iterate over the segments and get each segment. Let us evaluate the use case first. Are we talking about a full table reload or a segment reload? If full table reload, maybe we only want to return those segments that DID NOT reload properly?\nThe API definition leaves much discussion to be desired, and a PR is NOT the place to discuss API. If you have a design doc, we will discuss there.", "author": "mcvsubbu", "createdAt": "2020-08-01T00:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MDExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAwNjE0NQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r469006145", "bodyText": "this can be done in another PR. Lets get this in and add the optimizations as we need them. Million segments in a table is not a common use case.", "author": "kishoreg", "createdAt": "2020-08-12T05:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MDExMg=="}], "type": "inlineReview"}, {"oid": "d2d1c84dc301838be3ef8ffa6fb5b8b88056840f", "url": "https://github.com/apache/pinot/commit/d2d1c84dc301838be3ef8ffa6fb5b8b88056840f", "message": "Code refactor to accommodate PR comments\nPinot codestyle corrections\nMoving ServerSegmentMetadataReader to util", "committedDate": "2020-08-12T05:28:00Z", "type": "commit"}, {"oid": "d14f14300ff6053d3f2e2194a88790e636baeead", "url": "https://github.com/apache/pinot/commit/d14f14300ff6053d3f2e2194a88790e636baeead", "message": "Updating API definition for loadStatus", "committedDate": "2020-08-12T05:55:19Z", "type": "commit"}, {"oid": "b5b7d1c56828ea195fb0ceeb2dee0244fe2fe8d8", "url": "https://github.com/apache/pinot/commit/b5b7d1c56828ea195fb0ceeb2dee0244fe2fe8d8", "message": "Code refactor to remove duplicate code", "committedDate": "2020-08-13T20:26:36Z", "type": "commit"}, {"oid": "8ee255fb4bf05af46d0006e6c2c9cb0174820905", "url": "https://github.com/apache/pinot/commit/8ee255fb4bf05af46d0006e6c2c9cb0174820905", "message": "Code refactor to remove duplicate code", "committedDate": "2020-08-13T20:30:03Z", "type": "commit"}, {"oid": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "url": "https://github.com/apache/pinot/commit/2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "message": "Merge remote-tracking branch 'origin/feature/#5390-segment-indexing-reload-status-api' into feature/#5390-segment-indexing-reload-status-api\n\n# Conflicts:\n#\tpinot-controller/src/main/java/org/apache/pinot/controller/util/CompletionServiceHelper.java", "committedDate": "2020-08-13T20:30:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5NzQ5MQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474097491", "bodyText": "Add the server name to this log", "author": "mcvsubbu", "createdAt": "2020-08-20T16:03:14Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerTableSizeReader.java", "diffHunk": "@@ -64,40 +62,25 @@ public ServerTableSizeReader(Executor executor, HttpConnectionManager connection\n       serverUrls.add(tableSizeUri);\n     }\n \n-    // TODO: use some service other than completion service so that we know which server encounters the error\n-    CompletionService<GetMethod> completionService =\n-        new MultiGetRequest(_executor, _connectionManager).execute(serverUrls, timeoutMs);\n+    // Helper service to run a httpget call to the server\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager,\n+        endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverUrls, tableNameWithType, timeoutMs);\n     Map<String, List<SegmentSizeInfo>> serverToSegmentSizeInfoListMap = new HashMap<>();\n-\n-    for (int i = 0; i < numServers; i++) {\n-      GetMethod getMethod = null;\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n       try {\n-        getMethod = completionService.take().get();\n-        URI uri = getMethod.getURI();\n-        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n-        if (getMethod.getStatusCode() >= 300) {\n-          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n-          continue;\n-        }\n         TableSizeInfo tableSizeInfo =\n-            JsonUtils.inputStreamToObject(getMethod.getResponseBodyAsStream(), TableSizeInfo.class);\n-        serverToSegmentSizeInfoListMap.put(instance, tableSizeInfo.segments);\n-      } catch (Exception e) {\n-        // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n-        // Log the number of failed servers after gathering all responses\n-      } finally {\n-        if (getMethod != null) {\n-          getMethod.releaseConnection();\n-        }\n+            JsonUtils.stringToObject(streamResponse.getValue(), TableSizeInfo.class);\n+        serverToSegmentSizeInfoListMap.put(streamResponse.getKey(), tableSizeInfo.segments);\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5OTMyNg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474099326", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOGGER.warn(\"Failed to parse {} segment size info responses from server.\", failedParses);\n          \n          \n            \n                  LOGGER.warn(\"Failed to parse segment size info responses from {} servers.\", failedParses);\n          \n      \n    \n    \n  \n\nIf possible, add the total number of servers to this message as well", "author": "mcvsubbu", "createdAt": "2020-08-20T16:06:00Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerTableSizeReader.java", "diffHunk": "@@ -64,40 +62,25 @@ public ServerTableSizeReader(Executor executor, HttpConnectionManager connection\n       serverUrls.add(tableSizeUri);\n     }\n \n-    // TODO: use some service other than completion service so that we know which server encounters the error\n-    CompletionService<GetMethod> completionService =\n-        new MultiGetRequest(_executor, _connectionManager).execute(serverUrls, timeoutMs);\n+    // Helper service to run a httpget call to the server\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager,\n+        endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverUrls, tableNameWithType, timeoutMs);\n     Map<String, List<SegmentSizeInfo>> serverToSegmentSizeInfoListMap = new HashMap<>();\n-\n-    for (int i = 0; i < numServers; i++) {\n-      GetMethod getMethod = null;\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n       try {\n-        getMethod = completionService.take().get();\n-        URI uri = getMethod.getURI();\n-        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n-        if (getMethod.getStatusCode() >= 300) {\n-          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n-          continue;\n-        }\n         TableSizeInfo tableSizeInfo =\n-            JsonUtils.inputStreamToObject(getMethod.getResponseBodyAsStream(), TableSizeInfo.class);\n-        serverToSegmentSizeInfoListMap.put(instance, tableSizeInfo.segments);\n-      } catch (Exception e) {\n-        // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n-        // Log the number of failed servers after gathering all responses\n-      } finally {\n-        if (getMethod != null) {\n-          getMethod.releaseConnection();\n-        }\n+            JsonUtils.stringToObject(streamResponse.getValue(), TableSizeInfo.class);\n+        serverToSegmentSizeInfoListMap.put(streamResponse.getKey(), tableSizeInfo.segments);\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n       }\n     }\n-\n-    int numServersResponded = serverToSegmentSizeInfoListMap.size();\n-    if (numServersResponded != numServers) {\n-      LOGGER.warn(\"Finish reading segment sizes for table: {} with {}/{} servers responded\", tableNameWithType,\n-          numServersResponded, numServers);\n-    } else {\n-      LOGGER.info(\"Finish reading segment sizes for table: {}\", tableNameWithType);\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment size info responses from server.\", failedParses);", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMDc5Mw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474100793", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      numServersResponded, serverURLs);\n          \n          \n            \n                      numServersResponded, serverURLs.size());", "author": "mcvsubbu", "createdAt": "2020-08-20T16:08:21Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/CompletionServiceHelper.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.pinot.controller.util;\n+\n+import com.google.common.collect.BiMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.pinot.common.http.MultiGetRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that can be used to make HttpGet (MultiGet) calls and get the responses back.\n+ * The responses are returned as a string.\n+ *\n+ * The helper also records number of failed responses so that the caller knows if any of the calls\n+ * failed to respond. The failed instance is logged for debugging.\n+ */\n+public class CompletionServiceHelper {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompletionServiceHelper.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _httpConnectionManager;\n+  private final BiMap<String, String> _endpointsToServers;\n+\n+  public CompletionServiceHelper(Executor executor, HttpConnectionManager httpConnectionManager,\n+                                 BiMap<String, String> endpointsToServers) {\n+    _executor = executor;\n+    _httpConnectionManager = httpConnectionManager;\n+    _endpointsToServers = endpointsToServers;\n+  }\n+\n+  public CompletionServiceResponse doMultiGetRequest(List<String> serverURLs, String tableNameWithType, int timeoutMs) {\n+    CompletionServiceResponse completionServiceResponse = new CompletionServiceResponse();\n+\n+    // TODO: use some service other than completion service so that we know which server encounters the error\n+    CompletionService<GetMethod> completionService =\n+        new MultiGetRequest(_executor, _httpConnectionManager).execute(serverURLs, timeoutMs);\n+    for (int i = 0; i < serverURLs.size(); i++) {\n+      GetMethod getMethod = null;\n+      try {\n+        getMethod = completionService.take().get();\n+        URI uri = getMethod.getURI();\n+        String instance = _endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n+        if (getMethod.getStatusCode() >= 300) {\n+          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          completionServiceResponse._failedResponseCount++;\n+          continue;\n+        }\n+        completionServiceResponse._httpResponses.put(instance, getMethod.getResponseBodyAsString());\n+      } catch (Exception e) {\n+        // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n+        // Log the number of failed servers after gathering all responses\n+      } finally {\n+        if (getMethod != null) {\n+          getMethod.releaseConnection();\n+        }\n+      }\n+    }\n+\n+    int numServersResponded = completionServiceResponse._httpResponses.size();\n+    if (numServersResponded != serverURLs.size()) {\n+      LOGGER.warn(\"Finish reading information for table: {} with {}/{} server responses\", tableNameWithType,\n+          numServersResponded, serverURLs);", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMTU0MQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474101541", "bodyText": "Add server name in the log", "author": "mcvsubbu", "createdAt": "2020-08-20T16:09:30Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch server metadata and the segment reload status\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * This method makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serversToSegmentsMap\n+   * @param endpoints\n+   * @param timeoutMs\n+   * @return list of segments and their metadata as a JSON string\n+   */\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        JsonNode segmentMetadata = JsonUtils.stringToJsonNode(streamResponse.getValue());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMjE0Mw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474102143", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOGGER.warn(\"Failed to parse {} segment metadata responses from server.\", failedParses);\n          \n          \n            \n                  LOGGER.warn(\"Failed to parse segment metadata responses from {} servers.\", failedParses);\n          \n      \n    \n    \n  \n\nIf possible add total number of servers to this message as well", "author": "mcvsubbu", "createdAt": "2020-08-20T16:10:22Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch server metadata and the segment reload status\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * This method makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serversToSegmentsMap\n+   * @param endpoints\n+   * @param timeoutMs\n+   * @return list of segments and their metadata as a JSON string\n+   */\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        JsonNode segmentMetadata = JsonUtils.stringToJsonNode(streamResponse.getValue());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment metadata responses from server.\", failedParses);", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMjk4MQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474102981", "bodyText": "add the number of servers to this log message", "author": "mcvsubbu", "createdAt": "2020-08-20T16:11:40Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch server metadata and the segment reload status\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * This method makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serversToSegmentsMap\n+   * @param endpoints\n+   * @param timeoutMs\n+   * @return list of segments and their metadata as a JSON string\n+   */\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        JsonNode segmentMetadata = JsonUtils.stringToJsonNode(streamResponse.getValue());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment metadata responses from server.\", failedParses);\n+    }\n+\n+    LOGGER.debug(\"Retrieved segment metadata from servers.\");", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMzM4Ng==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474103386", "bodyText": "add server name", "author": "mcvsubbu", "createdAt": "2020-08-20T16:12:15Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch server metadata and the segment reload status\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * This method makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serversToSegmentsMap\n+   * @param endpoints\n+   * @param timeoutMs\n+   * @return list of segments and their metadata as a JSON string\n+   */\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        JsonNode segmentMetadata = JsonUtils.stringToJsonNode(streamResponse.getValue());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment metadata responses from server.\", failedParses);\n+    }\n+\n+    LOGGER.debug(\"Retrieved segment metadata from servers.\");\n+    return segmentsMetadata;\n+  }\n+\n+  private String generateSegmentMetadataServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/segments/%s/metadata\", endpoint, tableNameWithType, segmentName);\n+  }\n+\n+  private String generateReloadStatusServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/segments/%s/loadStatus\", endpoint, tableNameWithType, segmentName);\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * It makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serverToSegments\n+   * @param serverToEndpoint\n+   * @param timeoutMs\n+   * @return list of segments along with their last reload times\n+   */\n+  public TableReloadStatus getSegmentReloadTime(String tableNameWithType,\n+                                                Map<String, List<String>> serverToSegments,\n+                                                BiMap<String, String> serverToEndpoint, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment reload status from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegmentsEntry : serverToSegments.entrySet()) {\n+      List<String> segments = serverToSegmentsEntry.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateReloadStatusServerURL(tableNameWithType, segment, serverToEndpoint.get(serverToSegmentsEntry.getKey())));\n+      }\n+    }\n+\n+    BiMap<String, String> endpointsToServers = serverToEndpoint.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<SegmentStatus> segmentsStatus = new ArrayList<>();\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        SegmentStatus segmentStatus = JsonUtils.stringToObject(streamResponse.getValue(), SegmentStatus.class);\n+        segmentsStatus.add(segmentStatus);\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMzU2MQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474103561", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOGGER.warn(\"Failed to parse {} segment load status responses from server.\", failedParses);\n          \n          \n            \n                  LOGGER.warn(\"Failed to parse segment load status responses from {} servers.\", failedParses);", "author": "mcvsubbu", "createdAt": "2020-08-20T16:12:32Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch server metadata and the segment reload status\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * This method makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serversToSegmentsMap\n+   * @param endpoints\n+   * @param timeoutMs\n+   * @return list of segments and their metadata as a JSON string\n+   */\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        JsonNode segmentMetadata = JsonUtils.stringToJsonNode(streamResponse.getValue());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment metadata responses from server.\", failedParses);\n+    }\n+\n+    LOGGER.debug(\"Retrieved segment metadata from servers.\");\n+    return segmentsMetadata;\n+  }\n+\n+  private String generateSegmentMetadataServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/segments/%s/metadata\", endpoint, tableNameWithType, segmentName);\n+  }\n+\n+  private String generateReloadStatusServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/segments/%s/loadStatus\", endpoint, tableNameWithType, segmentName);\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * It makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serverToSegments\n+   * @param serverToEndpoint\n+   * @param timeoutMs\n+   * @return list of segments along with their last reload times\n+   */\n+  public TableReloadStatus getSegmentReloadTime(String tableNameWithType,\n+                                                Map<String, List<String>> serverToSegments,\n+                                                BiMap<String, String> serverToEndpoint, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment reload status from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegmentsEntry : serverToSegments.entrySet()) {\n+      List<String> segments = serverToSegmentsEntry.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateReloadStatusServerURL(tableNameWithType, segment, serverToEndpoint.get(serverToSegmentsEntry.getKey())));\n+      }\n+    }\n+\n+    BiMap<String, String> endpointsToServers = serverToEndpoint.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<SegmentStatus> segmentsStatus = new ArrayList<>();\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        SegmentStatus segmentStatus = JsonUtils.stringToObject(streamResponse.getValue(), SegmentStatus.class);\n+        segmentsStatus.add(segmentStatus);\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment load status responses from server.\", failedParses);", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMzcyMA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474103720", "bodyText": "nit: typo", "author": "mcvsubbu", "createdAt": "2020-08-20T16:12:47Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch server metadata and the segment reload status\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * This method makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serversToSegmentsMap\n+   * @param endpoints\n+   * @param timeoutMs\n+   * @return list of segments and their metadata as a JSON string\n+   */\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        JsonNode segmentMetadata = JsonUtils.stringToJsonNode(streamResponse.getValue());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment metadata responses from server.\", failedParses);\n+    }\n+\n+    LOGGER.debug(\"Retrieved segment metadata from servers.\");\n+    return segmentsMetadata;\n+  }\n+\n+  private String generateSegmentMetadataServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/segments/%s/metadata\", endpoint, tableNameWithType, segmentName);\n+  }\n+\n+  private String generateReloadStatusServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/segments/%s/loadStatus\", endpoint, tableNameWithType, segmentName);\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * It makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serverToSegments\n+   * @param serverToEndpoint\n+   * @param timeoutMs\n+   * @return list of segments along with their last reload times\n+   */\n+  public TableReloadStatus getSegmentReloadTime(String tableNameWithType,\n+                                                Map<String, List<String>> serverToSegments,\n+                                                BiMap<String, String> serverToEndpoint, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment reload status from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegmentsEntry : serverToSegments.entrySet()) {\n+      List<String> segments = serverToSegmentsEntry.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateReloadStatusServerURL(tableNameWithType, segment, serverToEndpoint.get(serverToSegmentsEntry.getKey())));\n+      }\n+    }\n+\n+    BiMap<String, String> endpointsToServers = serverToEndpoint.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<SegmentStatus> segmentsStatus = new ArrayList<>();\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        SegmentStatus segmentStatus = JsonUtils.stringToObject(streamResponse.getValue(), SegmentStatus.class);\n+        segmentsStatus.add(segmentStatus);\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment load status responses from server.\", failedParses);\n+    }\n+\n+    TableReloadStatus tableReloadStatus = new TableReloadStatus();\n+    tableReloadStatus._tableName = tableNameWithType;\n+    tableReloadStatus._segmentStatus = segmentsStatus;\n+    tableReloadStatus._numSegmentsFailed = serviceResponse._failedResponseCount;\n+    return tableReloadStatus;\n+  }\n+\n+  /**\n+   * Structure to hold the reload statsus for all segments of a given table.", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwNDg3NQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474104875", "bodyText": "Why is this a String and not long?", "author": "mcvsubbu", "createdAt": "2020-08-20T16:14:41Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+/**\n+ * Holds segment last reload time status along with any errors for a segment with unsuccessful call to get reload times.\n+ *\n+ * NOTE: This class is being used in both the controller and the server. There is tight coupling between them.\n+ * So, the API contract cannot be changed without changing or refactoring this class.\n+ *\n+ * TODO: refactor this class to be handled better. Make sure to have an extensible design that helps add more\n+ */\n+public class SegmentStatus {\n+  // Name of the segment itself\n+  public String _segmentName;\n+  // The last segment reload time in ISO date format (yyyy-MM-dd HH:mm:ss:SSS UTC)\n+  // If the segment reload failed for a segment, then the value will be the previous segment reload was successful\n+  public String _segmentReloadTimeUTC;", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwMTkwNA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r475101904", "bodyText": "The date is in string format: ISO date format (yyyy-MM-dd HH:mm:ss:SSS UTC)", "author": "guruguha", "createdAt": "2020-08-22T15:33:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwNDg3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUxODc3Mg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r479518772", "bodyText": "I have updated the API to return long instead of String", "author": "guruguha", "createdAt": "2020-08-28T20:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwNDg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwNTYzMA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474105630", "bodyText": "Ideally we should have timeout declared in milliseconds, so that we can configure sub-second values for fast responses. I suppose you are re-using a previously declared config here?", "author": "mcvsubbu", "createdAt": "2020-08-20T16:15:54Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +504,80 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/loadStatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Load status of a table segment\", notes = \"Load status of a table segment\")\n+  public Map<String, ServerSegmentMetadataReader.TableReloadStatus> getReloadStatus(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, ServerSegmentMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      ServerSegmentMetadataReader.TableReloadStatus tableReloadStatus;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n+      }\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private ServerSegmentMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+      throws InvalidConfigException {\n+    TableMetadataReader tableMetadataReader =\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType,\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwMTk5Mw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r475101993", "bodyText": "Yes, it was previously used in another code segment. Referred the same here as well.", "author": "guruguha", "createdAt": "2020-08-22T15:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwNTYzMA=="}], "type": "inlineReview"}, {"oid": "6e03c9b384d0eb1ab668bb01228885b26105d2a4", "url": "https://github.com/apache/pinot/commit/6e03c9b384d0eb1ab668bb01228885b26105d2a4", "message": "Code refactor as per PR comments", "committedDate": "2020-08-22T15:32:50Z", "type": "commit"}, {"oid": "6e03c9b384d0eb1ab668bb01228885b26105d2a4", "url": "https://github.com/apache/pinot/commit/6e03c9b384d0eb1ab668bb01228885b26105d2a4", "message": "Code refactor as per PR comments", "committedDate": "2020-08-22T15:32:50Z", "type": "forcePushed"}, {"oid": "2a1cc16e2e871d8b47c71d9ba37ca38e3733037f", "url": "https://github.com/apache/pinot/commit/2a1cc16e2e871d8b47c71d9ba37ca38e3733037f", "message": "Updating segment loadStatus API to return long time than readable string", "committedDate": "2020-08-28T20:21:27Z", "type": "commit"}, {"oid": "563e56c9555250f2020efa016f43a069c2534d8f", "url": "https://github.com/apache/pinot/commit/563e56c9555250f2020efa016f43a069c2534d8f", "message": "- Bug fix on the server API endpoint", "committedDate": "2020-08-29T02:26:55Z", "type": "commit"}, {"oid": "d23434502cc83f96aa72f086fe936a0689c83079", "url": "https://github.com/apache/pinot/commit/d23434502cc83f96aa72f086fe936a0689c83079", "message": "Adding pretty print for server metadata response", "committedDate": "2020-08-29T02:37:16Z", "type": "commit"}, {"oid": "d13c91e180fb80a0b1770122c16a4250c7c8c36e", "url": "https://github.com/apache/pinot/commit/d13c91e180fb80a0b1770122c16a4250c7c8c36e", "message": "Reverting incorrect filename refactoring\nUpdating variable names to reflect their value type", "committedDate": "2020-09-01T02:56:41Z", "type": "commit"}, {"oid": "ac98a410431f598e3b60f4980fc40b63f32c8e2b", "url": "https://github.com/apache/pinot/commit/ac98a410431f598e3b60f4980fc40b63f32c8e2b", "message": "removing unused method variable", "committedDate": "2020-09-02T04:16:59Z", "type": "commit"}, {"oid": "ac98a410431f598e3b60f4980fc40b63f32c8e2b", "url": "https://github.com/apache/pinot/commit/ac98a410431f598e3b60f4980fc40b63f32c8e2b", "message": "removing unused method variable", "committedDate": "2020-09-02T04:16:59Z", "type": "forcePushed"}, {"oid": "2cf562909c7465b428df3a0a8b1d5ef5421b83d2", "url": "https://github.com/apache/pinot/commit/2cf562909c7465b428df3a0a8b1d5ef5421b83d2", "message": "Enabling Pretty print of server response.\nCode refactor to clean up lines that went beyond line length", "committedDate": "2020-09-09T01:06:26Z", "type": "commit"}, {"oid": "b36d4cf84d880efee931c8f8c4aa379311da7880", "url": "https://github.com/apache/pinot/commit/b36d4cf84d880efee931c8f8c4aa379311da7880", "message": "Removing reload status API", "committedDate": "2020-09-09T03:08:00Z", "type": "commit"}, {"oid": "3f98c9949a7a280bc52b29488e6d8800f90e5852", "url": "https://github.com/apache/pinot/commit/3f98c9949a7a280bc52b29488e6d8800f90e5852", "message": "Pretty print result", "committedDate": "2020-09-11T23:33:16Z", "type": "commit"}, {"oid": "ec3603b051f92369402743bb48b7b8c88ce74ac7", "url": "https://github.com/apache/pinot/commit/ec3603b051f92369402743bb48b7b8c88ce74ac7", "message": "Fix test", "committedDate": "2020-09-12T00:32:15Z", "type": "commit"}, {"oid": "ec3603b051f92369402743bb48b7b8c88ce74ac7", "url": "https://github.com/apache/pinot/commit/ec3603b051f92369402743bb48b7b8c88ce74ac7", "message": "Fix test", "committedDate": "2020-09-12T00:32:15Z", "type": "forcePushed"}]}