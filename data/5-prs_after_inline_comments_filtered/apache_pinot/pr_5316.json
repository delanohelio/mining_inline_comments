{"pr_number": 5316, "pr_title": "Initial implementation for support Theta Sketches (WIP).", "pr_createdAt": "2020-04-29T05:40:00Z", "pr_url": "https://github.com/apache/pinot/pull/5316", "timeline": [{"oid": "7f74fbdae55b31813a3d0795eed7278e3ee1fc37", "url": "https://github.com/apache/pinot/commit/7f74fbdae55b31813a3d0795eed7278e3ee1fc37", "message": "Initial implementation for support Theta Sketches (WIP).\n\n1. Added an initial implementation for theta-sketch based distinct count\n   aggregation function, which can be invoked as follows:\n   `select distinctCountThetaSketch(thetaSketchColumn, p1, p2..pn, postAggrExpression)`\n    - thetaSketchColumn is the column of type BYTES that stores serialized theta sketches.\n    - p1, p2 etc are filter predicates that make up the postAggregationExpression\n    - postAggrExpression is the expression built with AND/OR on predicates p1..pn.\n    Example:\n    `select distinctCountThetaSketch(tsCol, \"dim1='foo', dim2='bar', \"dim1 = 'foo and dim2='bar') from table where dim1 = 'foo' or dim2 = 'bar'`\n\n2. The aggregation function works as follows:\n   - The postAggrExpression is basically an expression that AND/OR's some predicates,\n     these predicates are expected to be specified as part of aggregation function.\n   - The aggregation goes over all values in the blockValSet and applies each predicate\n     on the values. If the predicate is satisfied, the theta-sketch is aggregated and stored\n     as value in a map, where the key is the predicate.\n   - Once all theta-sketches corresponding to all predicates are evaluated, across all segments\n     and servers, the final result is computed by evaluating the postAggrFunction, by performing\n     set operations on predicate theta-sketches (AND = intersection, OR = union).\n\n3. The Theta-Sketch library being used is from org.apache.datasketches.\n\n4. Now that more than one aggregation functions take multiple arguments, generalized handling of\n   multiple args, and removed special casing of Distinct.\n\n5. Refactored methods from PinotQuery2BrokerRequestConverter to reusable utility class ParserUtils.\n\n6. Added unit tests for new code.\n\nTODO:\n1. Performance tuning to ensure the aggregation function works at par.\n2. Evaluate theta-sketch creation params, and pick default or come up with ways\n   to configure (by user).\n3. MultiValue aggregation support.\n4. Auto derive predicates that make up postAggrExpression, so they don't need to be specified\n   in the aggregation function.\n5. Auto sharding of Sketches with high cardinality into smaller ones to improve accuracy.\n6. Pql2Compiler.compileToExpressionTree does not seem to handle parenthesized expressions,\n   e.g., ((col1 = 1 and col2 = 2) or col3 = 3).", "committedDate": "2020-04-29T05:41:01Z", "type": "forcePushed"}, {"oid": "4d26bfb9f2755109229737727b73516b3c65ea23", "url": "https://github.com/apache/pinot/commit/4d26bfb9f2755109229737727b73516b3c65ea23", "message": "Initial implementation for support Theta Sketches (WIP).\n\n1. Added an initial implementation for theta-sketch based distinct count\n   aggregation function, which can be invoked as follows:\n   `select distinctCountThetaSketch(thetaSketchColumn, p1, p2..pn, postAggrExpression)`\n    - thetaSketchColumn is the column of type BYTES that stores serialized theta sketches.\n    - p1, p2 etc are filter predicates that make up the postAggregationExpression\n    - postAggrExpression is the expression built with AND/OR on predicates p1..pn.\n    Example:\n    `select distinctCountThetaSketch(tsCol, \"dim1='foo', dim2='bar', \"dim1 = 'foo and dim2='bar') from table where dim1 = 'foo' or dim2 = 'bar'`\n\n2. The aggregation function works as follows:\n   - The postAggrExpression is basically an expression that AND/OR's some predicates,\n     these predicates are expected to be specified as part of aggregation function.\n   - The aggregation goes over all values in the blockValSet and applies each predicate\n     on the values. If the predicate is satisfied, the theta-sketch is aggregated and stored\n     as value in a map, where the key is the predicate.\n   - Once all theta-sketches corresponding to all predicates are evaluated, across all segments\n     and servers, the final result is computed by evaluating the postAggrFunction, by performing\n     set operations on predicate theta-sketches (AND = intersection, OR = union).\n\n3. The Theta-Sketch library being used is from org.apache.datasketches.\n\n4. Now that more than one aggregation functions take multiple arguments, generalized handling of\n   multiple args, and removed special casing of Distinct.\n\n5. Refactored methods from PinotQuery2BrokerRequestConverter to reusable utility class ParserUtils.\n\n6. Added unit tests for new code.\n\nTODO:\n1. Performance tuning to ensure the aggregation function works at par.\n2. Evaluate theta-sketch creation params, and pick default or come up with ways\n   to configure (by user).\n3. MultiValue aggregation support.\n4. Auto derive predicates that make up postAggrExpression, so they don't need to be specified\n   in the aggregation function.\n5. Auto sharding of Sketches with high cardinality into smaller ones to improve accuracy.\n6. Pql2Compiler.compileToExpressionTree does not seem to handle parenthesized expressions,\n   e.g., ((col1 = 1 and col2 = 2) or col3 = 3).", "committedDate": "2020-04-30T02:44:34Z", "type": "forcePushed"}, {"oid": "3ddb496897bd92607a00dacbb694763351e0e656", "url": "https://github.com/apache/pinot/commit/3ddb496897bd92607a00dacbb694763351e0e656", "message": "Initial implementation for support Theta Sketches (WIP).\n\n1. Added an initial implementation for theta-sketch based distinct count\n   aggregation function, which can be invoked as follows:\n   `select distinctCountThetaSketch(thetaSketchColumn, p1, p2..pn, postAggrExpression)`\n    - thetaSketchColumn is the column of type BYTES that stores serialized theta sketches.\n    - p1, p2 etc are filter predicates that make up the postAggregationExpression\n    - postAggrExpression is the expression built with AND/OR on predicates p1..pn.\n    Example:\n    `select distinctCountThetaSketch(tsCol, \"dim1='foo', dim2='bar', \"dim1 = 'foo and dim2='bar') from table where dim1 = 'foo' or dim2 = 'bar'`\n\n2. The aggregation function works as follows:\n   - The postAggrExpression is basically an expression that AND/OR's some predicates,\n     these predicates are expected to be specified as part of aggregation function.\n   - The aggregation goes over all values in the blockValSet and applies each predicate\n     on the values. If the predicate is satisfied, the theta-sketch is aggregated and stored\n     as value in a map, where the key is the predicate.\n   - Once all theta-sketches corresponding to all predicates are evaluated, across all segments\n     and servers, the final result is computed by evaluating the postAggrFunction, by performing\n     set operations on predicate theta-sketches (AND = intersection, OR = union).\n\n3. The Theta-Sketch library being used is from org.apache.datasketches.\n\n4. Now that more than one aggregation functions take multiple arguments, generalized handling of\n   multiple args, and removed special casing of Distinct.\n\n5. Refactored methods from PinotQuery2BrokerRequestConverter to reusable utility class ParserUtils.\n\n6. Added unit tests for new code.\n\nTODO:\n1. Performance tuning to ensure the aggregation function works at par.\n2. Evaluate theta-sketch creation params, and pick default or come up with ways\n   to configure (by user).\n3. MultiValue aggregation support.\n4. Auto derive predicates that make up postAggrExpression, so they don't need to be specified\n   in the aggregation function.\n5. Auto sharding of Sketches with high cardinality into smaller ones to improve accuracy.\n6. Pql2Compiler.compileToExpressionTree does not seem to handle parenthesized expressions,\n   e.g., ((col1 = 1 and col2 = 2) or col3 = 3).", "committedDate": "2020-05-07T05:20:37Z", "type": "forcePushed"}, {"oid": "90c1ea1faa4ac03a4fda5a83919a2b949906eb8a", "url": "https://github.com/apache/pinot/commit/90c1ea1faa4ac03a4fda5a83919a2b949906eb8a", "message": "Initial implementation for support Theta Sketches (WIP).\n\n1. Added an initial implementation for theta-sketch based distinct count\n   aggregation function, which can be invoked as follows:\n   `select distinctCountThetaSketch(thetaSketchColumn, p1, p2..pn, postAggrExpression)`\n    - thetaSketchColumn is the column of type BYTES that stores serialized theta sketches.\n    - p1, p2 etc are filter predicates that make up the postAggregationExpression\n    - postAggrExpression is the expression built with AND/OR on predicates p1..pn.\n    Example:\n    `select distinctCountThetaSketch(tsCol, \"nominalEntries=1024\", \"dim1='foo', dim2='bar', \"dim1 = 'foo and dim2='bar') from table where dim1 = 'foo' or dim2 = 'bar'`\n\n2. The aggregation function works as follows:\n   - The postAggrExpression is basically an expression that AND/OR's some predicates,\n     these predicates are expected to be specified as part of aggregation function.\n   - The aggregation goes over all values in the blockValSet and applies each predicate\n     on the values. If the predicate is satisfied, the theta-sketch is aggregated and stored\n     as value in a map, where the key is the predicate.\n   - Once all theta-sketches corresponding to all predicates are evaluated, across all segments\n     and servers, the final result is computed by evaluating the postAggrFunction, by performing\n     set operations on predicate theta-sketches (AND = intersection, OR = union).\n\n3. The Theta-Sketch library being used is from org.apache.datasketches.\n\n4. Now that more than one aggregation functions take multiple arguments, generalized handling of\n   multiple args, and removed special casing of Distinct.\n\n5. Refactored methods from PinotQuery2BrokerRequestConverter to reusable utility class ParserUtils.\n\n6. Added unit tests for new code.\n\nTODO:\n1. Performance tuning to ensure the aggregation function works at par.\n2. Evaluate theta-sketch creation params, and pick default or come up with ways\n   to configure (by user).\n3. MultiValue aggregation support.\n4. Auto derive predicates that make up postAggrExpression, so they don't need to be specified\n   in the aggregation function.\n5. Auto sharding of Sketches with high cardinality into smaller ones to improve accuracy.\n6. Pql2Compiler.compileToExpressionTree does not seem to handle parenthesized expressions,\n   e.g., ((col1 = 1 and col2 = 2) or col3 = 3).", "committedDate": "2020-05-07T05:26:38Z", "type": "forcePushed"}, {"oid": "7aa2436061d2de3f00d54321d44dbe8b2d5f8a2d", "url": "https://github.com/apache/pinot/commit/7aa2436061d2de3f00d54321d44dbe8b2d5f8a2d", "message": "Initial implementation for support Theta Sketches (WIP).\n\n1. Added an initial implementation for theta-sketch based distinct count\n   aggregation function, which can be invoked as follows:\n   `select distinctCountThetaSketch(thetaSketchColumn, p1, p2..pn, postAggrExpression)`\n    - thetaSketchColumn is the column of type BYTES that stores serialized theta sketches.\n    - p1, p2 etc are filter predicates that make up the postAggregationExpression\n    - postAggrExpression is the expression built with AND/OR on predicates p1..pn.\n    Example:\n    `select distinctCountThetaSketch(tsCol, \"nominalEntries=1024\", \"dim1='foo', dim2='bar', \"dim1 = 'foo and dim2='bar') from table where dim1 = 'foo' or dim2 = 'bar'`\n\n2. The aggregation function works as follows:\n   - The postAggrExpression is basically an expression that AND/OR's some predicates,\n     these predicates are expected to be specified as part of aggregation function.\n   - The aggregation goes over all values in the blockValSet and applies each predicate\n     on the values. If the predicate is satisfied, the theta-sketch is aggregated and stored\n     as value in a map, where the key is the predicate.\n   - Once all theta-sketches corresponding to all predicates are evaluated, across all segments\n     and servers, the final result is computed by evaluating the postAggrFunction, by performing\n     set operations on predicate theta-sketches (AND = intersection, OR = union).\n\n3. The Theta-Sketch library being used is from org.apache.datasketches.\n\n4. Now that more than one aggregation functions take multiple arguments, generalized handling of\n   multiple args, and removed special casing of Distinct.\n\n5. Refactored methods from PinotQuery2BrokerRequestConverter to reusable utility class ParserUtils.\n\n6. Added unit tests for new code.\n\nTODO:\n1. Performance tuning to ensure the aggregation function works at par.\n2. Evaluate theta-sketch creation params, and pick default or come up with ways\n   to configure (by user).\n3. MultiValue aggregation support.\n4. Auto derive predicates that make up postAggrExpression, so they don't need to be specified\n   in the aggregation function.\n5. Auto sharding of Sketches with high cardinality into smaller ones to improve accuracy.\n6. Pql2Compiler.compileToExpressionTree does not seem to handle parenthesized expressions,\n   e.g., ((col1 = 1 and col2 = 2) or col3 = 3).", "committedDate": "2020-05-07T05:38:15Z", "type": "forcePushed"}, {"oid": "212b2a8088e016ab32ff354bb32246e27999fab6", "url": "https://github.com/apache/pinot/commit/212b2a8088e016ab32ff354bb32246e27999fab6", "message": "Initial implementation for support Theta Sketches (WIP).\n\n1. Added an initial implementation for theta-sketch based distinct count\n   aggregation function, which can be invoked as follows:\n   `select distinctCountThetaSketch(thetaSketchColumn, p1, p2..pn, postAggrExpression)`\n    - thetaSketchColumn is the column of type BYTES that stores serialized theta sketches.\n    - p1, p2 etc are filter predicates that make up the postAggregationExpression\n    - postAggrExpression is the expression built with AND/OR on predicates p1..pn.\n    Example:\n    `select distinctCountThetaSketch(tsCol, \"nominalEntries=1024\", \"dim1='foo', dim2='bar', \"dim1 = 'foo and dim2='bar') from table where dim1 = 'foo' or dim2 = 'bar'`\n\n2. The aggregation function works as follows:\n   - The postAggrExpression is basically an expression that AND/OR's some predicates,\n     these predicates are expected to be specified as part of aggregation function.\n   - The aggregation goes over all values in the blockValSet and applies each predicate\n     on the values. If the predicate is satisfied, the theta-sketch is aggregated and stored\n     as value in a map, where the key is the predicate.\n   - Once all theta-sketches corresponding to all predicates are evaluated, across all segments\n     and servers, the final result is computed by evaluating the postAggrFunction, by performing\n     set operations on predicate theta-sketches (AND = intersection, OR = union).\n\n3. The Theta-Sketch library being used is from org.apache.datasketches.\n\n4. Now that more than one aggregation functions take multiple arguments, generalized handling of\n   multiple args, and removed special casing of Distinct.\n\n5. Refactored methods from PinotQuery2BrokerRequestConverter to reusable utility class ParserUtils.\n\n6. Added unit tests for new code.\n\nTODO:\n1. Performance tuning to ensure the aggregation function works at par.\n2. Evaluate theta-sketch creation params, and pick default or come up with ways\n   to configure (by user).\n3. MultiValue aggregation support.\n4. Auto derive predicates that make up postAggrExpression, so they don't need to be specified\n   in the aggregation function.\n5. Auto sharding of Sketches with high cardinality into smaller ones to improve accuracy.\n6. Pql2Compiler.compileToExpressionTree does not seem to handle parenthesized expressions,\n   e.g., ((col1 = 1 and col2 = 2) or col3 = 3).", "committedDate": "2020-05-07T15:06:08Z", "type": "forcePushed"}, {"oid": "4f87384f5b8065d4d4ff14fa38d122a1a13ee95c", "url": "https://github.com/apache/pinot/commit/4f87384f5b8065d4d4ff14fa38d122a1a13ee95c", "message": "Initial implementation for support Theta Sketches (WIP).\n\n1. Added an initial implementation for theta-sketch based distinct count\n   aggregation function, which can be invoked as follows:\n   `select distinctCountThetaSketch(thetaSketchColumn, p1, p2..pn, postAggrExpression)`\n    - thetaSketchColumn is the column of type BYTES that stores serialized theta sketches.\n    - p1, p2 etc are filter predicates that make up the postAggregationExpression\n    - postAggrExpression is the expression built with AND/OR on predicates p1..pn.\n    Example:\n    `select distinctCountThetaSketch(tsCol, \"nominalEntries=1024\", \"dim1='foo', dim2='bar', \"dim1 = 'foo and dim2='bar') from table where dim1 = 'foo' or dim2 = 'bar'`\n\n2. The aggregation function works as follows:\n   - The postAggrExpression is basically an expression that AND/OR's some predicates,\n     these predicates are expected to be specified as part of aggregation function.\n   - The aggregation goes over all values in the blockValSet and applies each predicate\n     on the values. If the predicate is satisfied, the theta-sketch is aggregated and stored\n     as value in a map, where the key is the predicate.\n   - Once all theta-sketches corresponding to all predicates are evaluated, across all segments\n     and servers, the final result is computed by evaluating the postAggrFunction, by performing\n     set operations on predicate theta-sketches (AND = intersection, OR = union).\n\n3. The Theta-Sketch library being used is from org.apache.datasketches.\n\n4. Now that more than one aggregation functions take multiple arguments, generalized handling of\n   multiple args, and removed special casing of Distinct.\n\n5. Refactored methods from PinotQuery2BrokerRequestConverter to reusable utility class ParserUtils.\n\n6. Added unit tests for new code.\n\nTODO:\n1. Performance tuning to ensure the aggregation function works at par.\n2. Evaluate theta-sketch creation params, and pick default or come up with ways\n   to configure (by user).\n3. MultiValue aggregation support.\n4. Auto derive predicates that make up postAggrExpression, so they don't need to be specified\n   in the aggregation function.\n5. Auto sharding of Sketches with high cardinality into smaller ones to improve accuracy.\n6. Pql2Compiler.compileToExpressionTree does not seem to handle parenthesized expressions,\n   e.g., ((col1 = 1 and col2 = 2) or col3 = 3).", "committedDate": "2020-05-07T16:21:12Z", "type": "forcePushed"}, {"oid": "1b79ea990649b860355198cc26977f7607236dd6", "url": "https://github.com/apache/pinot/commit/1b79ea990649b860355198cc26977f7607236dd6", "message": "Initial implementation for support Theta Sketches (WIP).\n\n1. Added an initial implementation for theta-sketch based distinct count\n   aggregation function, which can be invoked as follows:\n   `select distinctCountThetaSketch(thetaSketchColumn, thetaSketchParams, p1, p2..pn, postAggrExpression)`\n    - Required: thetaSketchColumn is the column of type BYTES that stores serialized theta sketches.\n    - Required: thetaSketchParams in the form \"param1=v1;param2=v2..\", pass empty literal '' if no params.\n    - Optional: p1, p2 etc are filter predicates that make up the postAggregationExpression\n    - Required: postAggrExpression is the expression built with AND/OR on predicates p1..pn.\n    Example:\n    `select distinctCountThetaSketch(tsCol, \"nominalEntries=1024\", \"dim1='foo', dim2='bar', \"dim1 = 'foo and dim2='bar') from table where dim1 = 'foo' or dim2 = 'bar'`\n\n2. The aggregation function works as follows:\n   - The postAggrExpression is basically an expression that AND/OR's some predicates,\n     these predicates are expected to be specified as part of aggregation function.\n   - The aggregation goes over all values in the blockValSet and applies each predicate\n     on the values. If the predicate is satisfied, the theta-sketch is aggregated and stored\n     as value in a map, where the key is the predicate.\n   - Once all theta-sketches corresponding to all predicates are evaluated, across all segments\n     and servers, the final result is computed by evaluating the postAggrFunction, by performing\n     set operations on predicate theta-sketches (AND = intersection, OR = union).\n\n3. The Theta-Sketch library being used is from org.apache.datasketches.\n\n4. Now that more than one aggregation functions take multiple arguments, generalized handling of\n   multiple args, and removed special casing of Distinct.\n\n5. Refactored methods from PinotQuery2BrokerRequestConverter to reusable utility class ParserUtils.\n\n6. Added unit tests for new code.\n\nTODO:\n1. Performance tuning to ensure the aggregation function works at par.\n2. Support complex predicates p1, p2, p3, current PR only supports predicates of form like `LHS = RHS`, `LHS IN (...)`, etc.\n2. Evaluate theta-sketch creation params, and pick default or come up with ways\n   to configure (by user).\n3. MultiValue aggregation support.\n4. Auto derive predicates that make up postAggrExpression, so they don't need to be specified\n   in the aggregation function.\n5. Auto sharding of Sketches with high cardinality into smaller ones to improve accuracy.\n6. Pql2Compiler.compileToExpressionTree does not seem to handle parenthesized expressions,\n   e.g., ((col1 = 1 and col2 = 2) or col3 = 3).", "committedDate": "2020-05-08T15:11:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyNzA4OQ==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423327089", "bodyText": "Let's not change the naming convention (first letter lower case).\nAlso I would recommend moving it next to FASTHLL", "author": "Jackie-Jiang", "createdAt": "2020-05-11T21:20:55Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/AggregationFunctionType.java", "diffHunk": "@@ -33,6 +33,8 @@\n   PERCENTILE(\"percentile\"),\n   PERCENTILEEST(\"percentileEst\"),\n   PERCENTILETDIGEST(\"percentileTDigest\"),\n+  DISTINCTCOUNTTHETASKETCH(\"DistinctCountThetaSketch\"),", "originalCommit": "1b79ea990649b860355198cc26977f7607236dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NDgwMA==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423354800", "bodyText": "\ud83d\udc4d", "author": "mayankshriv", "createdAt": "2020-05-11T22:25:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyNzA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyNzgwMQ==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423327801", "bodyText": "(Naming convention)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              static Map<FilterKind, FilterOperator> filterOperatorMapping;\n          \n          \n            \n              private static final Map<FilterKind, FilterOperator> FILTER_OPERATOR_MAP;", "author": "Jackie-Jiang", "createdAt": "2020-05-11T21:22:33Z", "path": "pinot-common/src/main/java/org/apache/pinot/parsers/utils/ParserUtils.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.parsers.utils;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.request.Expression;\n+import org.apache.pinot.common.request.FilterOperator;\n+import org.apache.pinot.common.request.Function;\n+import org.apache.pinot.common.request.Literal;\n+import org.apache.pinot.pql.parsers.pql2.ast.FilterKind;\n+\n+\n+/**\n+ * Class for holding Parser specific utility functions.\n+ */\n+public class ParserUtils {\n+  static Map<FilterKind, FilterOperator> filterOperatorMapping;", "originalCommit": "1b79ea990649b860355198cc26977f7607236dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NTQyOQ==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423355429", "bodyText": "\ud83d\udc4d", "author": "mayankshriv", "createdAt": "2020-05-11T22:26:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyNzgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyODYwMw==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423328603", "bodyText": "(nit, your choice) I usually put this next to the class definition (line 35) so that it is very clear this is a pure util class.", "author": "Jackie-Jiang", "createdAt": "2020-05-11T21:24:10Z", "path": "pinot-common/src/main/java/org/apache/pinot/parsers/utils/ParserUtils.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.parsers.utils;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.request.Expression;\n+import org.apache.pinot.common.request.FilterOperator;\n+import org.apache.pinot.common.request.Function;\n+import org.apache.pinot.common.request.Literal;\n+import org.apache.pinot.pql.parsers.pql2.ast.FilterKind;\n+\n+\n+/**\n+ * Class for holding Parser specific utility functions.\n+ */\n+public class ParserUtils {\n+  static Map<FilterKind, FilterOperator> filterOperatorMapping;\n+\n+  static {\n+    filterOperatorMapping = new HashMap<>();\n+    filterOperatorMapping.put(FilterKind.AND, FilterOperator.AND);\n+    filterOperatorMapping.put(FilterKind.OR, FilterOperator.OR);\n+    filterOperatorMapping.put(FilterKind.EQUALS, FilterOperator.EQUALITY);\n+    filterOperatorMapping.put(FilterKind.NOT_EQUALS, FilterOperator.NOT);\n+    filterOperatorMapping.put(FilterKind.GREATER_THAN, FilterOperator.RANGE);\n+    filterOperatorMapping.put(FilterKind.LESS_THAN, FilterOperator.RANGE);\n+    filterOperatorMapping.put(FilterKind.GREATER_THAN_OR_EQUAL, FilterOperator.RANGE);\n+    filterOperatorMapping.put(FilterKind.LESS_THAN_OR_EQUAL, FilterOperator.RANGE);\n+    filterOperatorMapping.put(FilterKind.BETWEEN, FilterOperator.RANGE);\n+    filterOperatorMapping.put(FilterKind.IN, FilterOperator.IN);\n+    filterOperatorMapping.put(FilterKind.NOT_IN, FilterOperator.NOT_IN);\n+    filterOperatorMapping.put(FilterKind.REGEXP_LIKE, FilterOperator.REGEXP_LIKE);\n+    filterOperatorMapping.put(FilterKind.TEXT_MATCH, FilterOperator.TEXT_MATCH);\n+  }\n+\n+  // Private constructor to disable instantiation.\n+  private ParserUtils() {", "originalCommit": "1b79ea990649b860355198cc26977f7607236dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1NTY2Mw==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423355663", "bodyText": "\ud83d\udc4d", "author": "mayankshriv", "createdAt": "2020-05-11T22:27:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyODYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyODg4MA==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423328880", "bodyText": "javadoc?\nHow about expression with multiple operands?", "author": "Jackie-Jiang", "createdAt": "2020-05-11T21:24:47Z", "path": "pinot-common/src/main/java/org/apache/pinot/parsers/utils/ParserUtils.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.parsers.utils;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.request.Expression;\n+import org.apache.pinot.common.request.FilterOperator;\n+import org.apache.pinot.common.request.Function;\n+import org.apache.pinot.common.request.Literal;\n+import org.apache.pinot.pql.parsers.pql2.ast.FilterKind;\n+\n+\n+/**\n+ * Class for holding Parser specific utility functions.\n+ */\n+public class ParserUtils {\n+  static Map<FilterKind, FilterOperator> filterOperatorMapping;\n+\n+  static {\n+    filterOperatorMapping = new HashMap<>();\n+    filterOperatorMapping.put(FilterKind.AND, FilterOperator.AND);\n+    filterOperatorMapping.put(FilterKind.OR, FilterOperator.OR);\n+    filterOperatorMapping.put(FilterKind.EQUALS, FilterOperator.EQUALITY);\n+    filterOperatorMapping.put(FilterKind.NOT_EQUALS, FilterOperator.NOT);\n+    filterOperatorMapping.put(FilterKind.GREATER_THAN, FilterOperator.RANGE);\n+    filterOperatorMapping.put(FilterKind.LESS_THAN, FilterOperator.RANGE);\n+    filterOperatorMapping.put(FilterKind.GREATER_THAN_OR_EQUAL, FilterOperator.RANGE);\n+    filterOperatorMapping.put(FilterKind.LESS_THAN_OR_EQUAL, FilterOperator.RANGE);\n+    filterOperatorMapping.put(FilterKind.BETWEEN, FilterOperator.RANGE);\n+    filterOperatorMapping.put(FilterKind.IN, FilterOperator.IN);\n+    filterOperatorMapping.put(FilterKind.NOT_IN, FilterOperator.NOT_IN);\n+    filterOperatorMapping.put(FilterKind.REGEXP_LIKE, FilterOperator.REGEXP_LIKE);\n+    filterOperatorMapping.put(FilterKind.TEXT_MATCH, FilterOperator.TEXT_MATCH);\n+  }\n+\n+  // Private constructor to disable instantiation.\n+  private ParserUtils() {\n+\n+  }\n+\n+  /**\n+   * Utility method that returns the {@link FilterOperator} for a given expression.\n+   * Assumes that the passed in expression is a filter expression.\n+   *\n+   * @param expression Expression for which to get the filter type\n+   * @return Filter Operator for the given Expression.\n+   */\n+  public static FilterOperator getFilterType(Expression expression) {\n+    String operator = expression.getFunctionCall().getOperator();\n+    return filterKindToOperator(FilterKind.valueOf(operator));\n+  }\n+\n+  /**\n+   * Utility method to map {@link FilterKind} to {@link FilterOperator}.\n+   *\n+   * @param filterKind Filter kind for which to get the Filter Operator\n+   * @return Filter Operator for the given Filter kind\n+   */\n+  public static FilterOperator filterKindToOperator(FilterKind filterKind) {\n+    return filterOperatorMapping.get(filterKind);\n+  }\n+\n+  public static String getFilterColumn(Expression expression) {", "originalCommit": "1b79ea990649b860355198cc26977f7607236dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1ODQyMQ==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423358421", "bodyText": "Updated with javadoc, and specify that it only supports single LHS column.", "author": "mayankshriv", "createdAt": "2020-05-11T22:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyODg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzMzIxMQ==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423333211", "bodyText": "Why using ordinal?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                int ordinal = this.ordinal();\n          \n          \n            \n                return this == GREATER_THAN || this == GREATER_THEN_OR_EQUAL || this == LESS_THEN || this == LESS_THAN_OR_EQUAL || this == BETWEEN;", "author": "Jackie-Jiang", "createdAt": "2020-05-11T21:34:07Z", "path": "pinot-common/src/main/java/org/apache/pinot/pql/parsers/pql2/ast/FilterKind.java", "diffHunk": "@@ -33,5 +33,16 @@\n   REGEXP_LIKE,\n   IS_NULL,\n   IS_NOT_NULL,\n-  TEXT_MATCH\n+  TEXT_MATCH;\n+\n+  /**\n+   * Helper method that returns true if the enum maps to a Range.\n+   *\n+   * @return True if the enum is of Range type, false otherwise.\n+   */\n+  public boolean isRange() {\n+    int ordinal = this.ordinal();", "originalCommit": "1b79ea990649b860355198cc26977f7607236dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1OTUwNg==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423359506", "bodyText": "\ud83d\udc4d", "author": "mayankshriv", "createdAt": "2020-05-11T22:37:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzMzIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzNDg2Ng==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423334866", "bodyText": "(nit) new line", "author": "Jackie-Jiang", "createdAt": "2020-05-11T21:37:46Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/ThetaSketchParams.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+\n+\n+/**\n+ * Class to hold Theta Sketch Params, and is Json serializable.\n+ */\n+@SuppressWarnings(\"unused\")\n+public class ThetaSketchParams {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+  private static final String PARAMS_DELIMITER = \";\";\n+  private static final String PARAM_KEY_VALUE_SEPARATOR = \"=\";\n+\n+  @JsonProperty(\"nominalEntries\")\n+  private int _nominalEntries;\n+\n+  public int getNominalEntries() {\n+    return _nominalEntries;\n+  }\n+\n+  public void setNominalEntries(int nominalEntries) {\n+    _nominalEntries = nominalEntries;\n+  }\n+\n+  /**\n+   * Creates a ThetaSketchParams object from the specified string. The specified string is\n+   * expected to be of form: \"key1 = value1; key2 = value2..\"\n+   * @param paramsString Param in string form\n+   * @return Param object, null if string is null or empty\n+   */\n+  public static ThetaSketchParams fromString(String paramsString) {\n+    if (paramsString == null || paramsString.isEmpty()) {\n+      return null;\n+    }\n+\n+    ObjectNode objectNode = JsonUtils.newObjectNode();\n+    for (String pair : paramsString.split(PARAMS_DELIMITER)) {\n+      String[] keyValue = pair.split(PARAM_KEY_VALUE_SEPARATOR);\n+      objectNode.put(keyValue[0].replaceAll(\"\\\\s\", \"\"), keyValue[1].replaceAll(\"\\\\s\", \"\"));\n+    }\n+\n+    return OBJECT_MAPPER.convertValue(objectNode, ThetaSketchParams.class);\n+  }\n+}", "originalCommit": "1b79ea990649b860355198cc26977f7607236dd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzNTk4Ng==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423335986", "bodyText": "(nit) new line", "author": "Jackie-Jiang", "createdAt": "2020-05-11T21:40:21Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.calcite.sql.parser.SqlParseException;\n+import org.apache.datasketches.memory.Memory;\n+import org.apache.datasketches.theta.Intersection;\n+import org.apache.datasketches.theta.SetOperation;\n+import org.apache.datasketches.theta.SetOperationBuilder;\n+import org.apache.datasketches.theta.Sketch;\n+import org.apache.datasketches.theta.Union;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.request.Expression;\n+import org.apache.pinot.common.request.ExpressionType;\n+import org.apache.pinot.common.request.Function;\n+import org.apache.pinot.common.request.transform.TransformExpressionTree;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.common.Predicate;\n+import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluator;\n+import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluatorProvider;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ThetaSketchParams;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.parsers.utils.ParserUtils;\n+import org.apache.pinot.pql.parsers.pql2.ast.FilterKind;\n+import org.apache.pinot.pql.parsers.pql2.ast.IdentifierAstNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.sql.parsers.CalciteSqlParser;\n+\n+\n+/**\n+ * Implementation of {@link AggregationFunction} to perform the distinct count aggregation using\n+ * Theta Sketches.\n+ */\n+@SuppressWarnings(\"Duplicates\")\n+public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Integer> {\n+\n+  private String _thetaSketchColumn;\n+  private Set<String> _predicateStrings;\n+  private Expression _postAggregationExpression;\n+  private Set<PredicateInfo> _predicateInfoSet;\n+  private Map<Expression, String> _expressionMap;\n+  private ThetaSketchParams _thetaSketchParams;\n+  private List<TransformExpressionTree> _inputExpressions;\n+\n+  /**\n+   * Constructor for the class.\n+   * @param arguments List of parameters as arguments strings. At least three arguments are expected:\n+   *                    <ul>\n+   *                    <li> Required: First expression is interpreted as theta sketch column to aggregate on. </li>\n+   *                    <li> Required: Second argument is the thetaSketchParams. </li>\n+   *                    <li> Optional: Second to penultimate are predicates with LHS and RHS. </li>\n+   *                    <li> Required: Last expression is the one that will be evaluated to compute final result. </li>\n+   *                    </ul>\n+   */\n+  public DistinctCountThetaSketchAggregationFunction(List<String> arguments)\n+      throws SqlParseException {\n+    int numExpressions = arguments.size();\n+\n+    // This function expects at least 3 arguments: Theta Sketch Column, Predicates & final aggregation expression.\n+    Preconditions.checkArgument(numExpressions >= 3, \"DistinctCountThetaSketch expects at least three arguments, got: \",\n+        numExpressions);\n+\n+    // Initialize all the internal state.\n+    init(arguments);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.DISTINCTCOUNTTHETASKETCH;\n+  }\n+\n+  @Override\n+  public String getColumnName() {\n+    return AggregationFunctionType.DISTINCTCOUNTTHETASKETCH.getName() + \"_\" + _thetaSketchColumn;\n+  }\n+\n+  @Override\n+  public String getResultColumnName() {\n+    return AggregationFunctionType.DISTINCTCOUNTTHETASKETCH.getName().toLowerCase() + \"(\" + _thetaSketchColumn + \")\";\n+  }\n+\n+  @Override\n+  public List<TransformExpressionTree> getInputExpressions() {\n+    return _inputExpressions;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<String, BlockValSet> blockValSetMap) {\n+\n+    Map<String, Union> result = getDefaultResult(aggregationResultHolder, _predicateStrings);\n+    Sketch[] sketches = deserializeSketches(blockValSetMap.get(_thetaSketchColumn).getBytesValuesSV(), length);\n+\n+    for (PredicateInfo predicateInfo : _predicateInfoSet) {\n+      String predicate = predicateInfo.getStringVal();\n+\n+      BlockValSet blockValSet = blockValSetMap.get(predicateInfo.getColumn());\n+      FieldSpec.DataType valueType = blockValSet.getValueType();\n+      PredicateEvaluator predicateEvaluator = predicateInfo.getPredicateEvaluator(valueType);\n+\n+      Union union = result.get(predicate);\n+      switch (valueType) {\n+        case INT:\n+        case LONG:\n+          long[] longValues = blockValSet.getLongValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(longValues[i])) {\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case FLOAT:\n+        case DOUBLE:\n+          double[] doubleValues = blockValSet.getDoubleValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(doubleValues[i])) {\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case STRING:\n+          String[] stringValues = blockValSet.getStringValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(stringValues[i])) {\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        default: // Predicates on BYTES is not allowed.\n+          throw new IllegalStateException(\"Illegal data type for \" + getType() + \" aggregation function: \" + valueType);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<String, BlockValSet> blockValSetMap) {\n+    Sketch[] sketches = deserializeSketches(blockValSetMap.get(_thetaSketchColumn).getBytesValuesSV(), length);\n+\n+    for (PredicateInfo predicateInfo : _predicateInfoSet) {\n+      String predicate = predicateInfo.getStringVal();\n+\n+      BlockValSet blockValSet = blockValSetMap.get(predicateInfo.getColumn());\n+      FieldSpec.DataType valueType = blockValSet.getValueType();\n+      PredicateEvaluator predicateEvaluator = predicateInfo.getPredicateEvaluator(valueType);\n+\n+      Map<String, Union> result;\n+      switch (valueType) {\n+        case INT:\n+        case LONG:\n+          long[] longValues = blockValSet.getLongValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(longValues[i])) {\n+              result = getDefaultResult(groupByResultHolder, groupKeyArray[i], _predicateStrings);\n+              Union union = result.get(predicate);\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case FLOAT:\n+        case DOUBLE:\n+          double[] doubleValues = blockValSet.getDoubleValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(doubleValues[i])) {\n+              result = getDefaultResult(groupByResultHolder, groupKeyArray[i], _predicateStrings);\n+              Union union = result.get(predicate);\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case STRING:\n+          String[] stringValues = blockValSet.getStringValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(stringValues[i])) {\n+              result = getDefaultResult(groupByResultHolder, groupKeyArray[i], _predicateStrings);\n+              Union union = result.get(predicate);\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        default: // Predicates on BYTES is not allowed.\n+          throw new IllegalStateException(\"Illegal data type for \" + getType() + \" aggregation function: \" + valueType);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<String, BlockValSet> blockValSetMap) {\n+    Sketch[] sketches = deserializeSketches(blockValSetMap.get(_thetaSketchColumn).getBytesValuesSV(), length);\n+\n+    for (PredicateInfo predicateInfo : _predicateInfoSet) {\n+      String predicate = predicateInfo.getStringVal();\n+\n+      BlockValSet blockValSet = blockValSetMap.get(predicateInfo.getColumn());\n+      FieldSpec.DataType valueType = blockValSet.getValueType();\n+      PredicateEvaluator predicateEvaluator = predicateInfo.getPredicateEvaluator(valueType);\n+\n+      Map<String, Union> result;\n+      switch (valueType) {\n+        case INT:\n+        case LONG:\n+          long[] longValues = blockValSet.getLongValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(longValues[i])) {\n+\n+              for (int groupKey : groupKeysArray[i]) {\n+                result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+                Union union = result.get(predicate);\n+                union.update(sketches[i]);\n+              }\n+            }\n+          }\n+          break;\n+\n+        case FLOAT:\n+        case DOUBLE:\n+          double[] doubleValues = blockValSet.getDoubleValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(doubleValues[i])) {\n+\n+              for (int groupKey : groupKeysArray[i]) {\n+                result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+                Union union = result.get(predicate);\n+                union.update(sketches[i]);\n+              }\n+            }\n+          }\n+          break;\n+\n+        case STRING:\n+          String[] stringValues = blockValSet.getStringValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(stringValues[i])) {\n+\n+              for (int groupKey : groupKeysArray[i]) {\n+                result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+                Union union = result.get(predicate);\n+                union.update(sketches[i]);\n+              }\n+            }\n+          }\n+          break;\n+\n+        default: // Predicates on BYTES is not allowed.\n+          throw new IllegalStateException(\"Illegal data type for \" + getType() + \" aggregation function: \" + valueType);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Map<String, Sketch> extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    Map<String, Union> result = aggregationResultHolder.getResult();\n+    if (result == null) {\n+      result = getDefaultResult(aggregationResultHolder, _predicateStrings);\n+    }\n+\n+    return result.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().getResult()));\n+  }\n+\n+  @Override\n+  public Map<String, Sketch> extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    Map<String, Union> result = groupByResultHolder.getResult(groupKey);\n+    if (result == null) {\n+      result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+    }\n+\n+    return result.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().getResult()));\n+  }\n+\n+  @Override\n+  public Map<String, Sketch> merge(Map<String, Sketch> intermediateResult1, Map<String, Sketch> intermediateResult2) {\n+    if (intermediateResult1 == null) {\n+      return intermediateResult2;\n+    } else if (intermediateResult2 == null) {\n+      return intermediateResult1;\n+    }\n+\n+    for (Map.Entry<String, Sketch> entry : intermediateResult1.entrySet()) {\n+      String predicate = entry.getKey();\n+      Union union = getSetOperationBuilder().buildUnion();\n+      union.update(entry.getValue());\n+      union.update(intermediateResult2.get(predicate));\n+      intermediateResult1.put(predicate, union.getResult());\n+    }\n+    return intermediateResult1;\n+  }\n+\n+  @Override\n+  public boolean isIntermediateResultComparable() {\n+    return false;\n+  }\n+\n+  @Override\n+  public DataSchema.ColumnDataType getIntermediateResultColumnType() {\n+    return DataSchema.ColumnDataType.OBJECT;\n+  }\n+\n+  @Override\n+  public DataSchema.ColumnDataType getFinalResultColumnType() {\n+    return DataSchema.ColumnDataType.INT;\n+  }\n+\n+  @Override\n+  public Integer extractFinalResult(Map<String, Sketch> intermediateResult) {\n+    // Compute the post aggregation expression and return the result.\n+    Sketch finalSketch = evalPostAggregationExpression(_postAggregationExpression, intermediateResult);\n+    return (int) Math.round(finalSketch.getEstimate());\n+  }\n+\n+  /**\n+   * Returns the Default result for the given expression.\n+   *\n+   * @param aggregationResultHolder Aggregation result holder\n+   * @param expressions Set of expressions that are expected in the result holder\n+   * @return Default result\n+   */\n+  private Map<String, Union> getDefaultResult(AggregationResultHolder aggregationResultHolder,\n+      Set<String> expressions) {\n+    Map<String, Union> result = aggregationResultHolder.getResult();\n+\n+    if (result == null) {\n+      result = new HashMap<>();\n+      aggregationResultHolder.setValue(result);\n+    }\n+\n+    for (String expression : expressions) {\n+      result.putIfAbsent(expression, getSetOperationBuilder().buildUnion());\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the Default result for the given group key if exists, or creates a new one.\n+   *\n+   * @param groupByResultHolder Result holder\n+   * @param groupKey Group key for which to return the default result\n+   * @param expressions Set of expressions that are expected in the result holder\n+   *\n+   * @return Default result for the group-key\n+   */\n+  private Map<String, Union> getDefaultResult(GroupByResultHolder groupByResultHolder, int groupKey,\n+      Set<String> expressions) {\n+    Map<String, Union> result = groupByResultHolder.getResult(groupKey);\n+\n+    if (result == null) {\n+      result = new HashMap<>();\n+      groupByResultHolder.setValueForKey(groupKey, result);\n+    }\n+\n+    for (String expression : expressions) {\n+      result.putIfAbsent(expression, getSetOperationBuilder().buildUnion());\n+    }\n+    return result;\n+  }\n+\n+  private Sketch[] deserializeSketches(byte[][] serializedSketches, int length) {\n+    Sketch[] sketches = new Sketch[length];\n+    for (int i = 0; i < length; i++) {\n+      sketches[i] = Sketch.wrap(Memory.wrap(serializedSketches[i]));\n+    }\n+    return sketches;\n+  }\n+\n+  private void init(List<String> arguments)\n+      throws SqlParseException {\n+\n+    // Predicate Strings are optional. When not specified, they are derived from postAggregationExpression\n+    boolean predicatesSpecified = arguments.size() > 3;\n+\n+    // Initialize the Theta-Sketch Column.\n+    _thetaSketchColumn = arguments.get(0);\n+\n+    // Initialize input expressions. It is expected they are covered between the theta-sketch column and the predicates.\n+    _inputExpressions = new ArrayList<>();\n+    _inputExpressions.add(TransformExpressionTree.compileToExpressionTree(_thetaSketchColumn));\n+\n+    // Initialize thetaSketchParams\n+    String paramsString = arguments.get(1);\n+    _thetaSketchParams = ThetaSketchParams.fromString(paramsString);\n+\n+    String postAggrExpressionString = arguments.get(arguments.size() - 1);\n+    _postAggregationExpression = CalciteSqlParser.compileToExpression(postAggrExpressionString);\n+\n+    _predicateInfoSet = new LinkedHashSet<>();\n+    _predicateStrings = new LinkedHashSet<>(arguments.subList(2, arguments.size() - 1));\n+    _expressionMap = new HashMap<>();\n+\n+    if (predicatesSpecified) {\n+      for (String predicateString : _predicateStrings) {\n+        Expression expression = CalciteSqlParser.compileToExpression(predicateString);\n+\n+        // TODO: Add support for complex predicates with AND/OR.\n+        String filterColumn = ParserUtils.getFilterColumn(expression);\n+        Predicate predicate = Predicate.newPredicate(ParserUtils.getFilterType(expression), filterColumn, ParserUtils.getFilterValues(expression));\n+\n+        _predicateInfoSet.add(new PredicateInfo(predicateString, filterColumn, predicate));\n+        _expressionMap.put(expression, predicateString);\n+        _inputExpressions.add(new TransformExpressionTree(new IdentifierAstNode(filterColumn)));\n+      }\n+    } else {\n+      // Auto-derive predicates from postAggregationExpression.\n+      Set<Expression> predicateExpressions = extractPredicatesFromString(postAggrExpressionString);\n+      for (Expression predicateExpression : predicateExpressions) {\n+        String filterColumn = ParserUtils.getFilterColumn(predicateExpression);\n+        Predicate predicate = Predicate\n+            .newPredicate(ParserUtils.getFilterType(predicateExpression), filterColumn, ParserUtils.getFilterValues(predicateExpression));\n+\n+        String predicateString = ParserUtils.standardizeExpression(predicateExpression, false);\n+        _predicateStrings.add(predicateString);\n+        _predicateInfoSet.add(new PredicateInfo(predicateString, filterColumn, predicate));\n+        _expressionMap.put(predicateExpression, predicateString);\n+        _inputExpressions.add(new TransformExpressionTree(new IdentifierAstNode(filterColumn)));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Given a post aggregation String of form like ((p1 and p2) or (p3 and p4)), returns the individual\n+   * predicates p1, p2, p3, p4.\n+   *\n+   * @param postAggrExpressionString Post aggregation expression String input\n+   * @return Set of predicates that compose the input expression\n+   * @throws SqlParseException If invalid expression String specified\n+   */\n+  private Set<Expression> extractPredicatesFromString(String postAggrExpressionString)\n+      throws SqlParseException {\n+    Set<Expression> predicates = new LinkedHashSet<>();\n+    _postAggregationExpression = CalciteSqlParser.compileToExpression(postAggrExpressionString);\n+    extractPredicatesFromExpression(_postAggregationExpression, predicates);\n+    return predicates;\n+  }\n+\n+  private void extractPredicatesFromExpression(Expression expression, Set<Expression> predicates) {\n+    ExpressionType type = expression.getType();\n+\n+    if (type.equals(ExpressionType.FUNCTION)) {\n+      Function function = expression.getFunctionCall();\n+      FilterKind filterKind = FilterKind.valueOf(function.getOperator());\n+\n+      List<Expression> operands = function.getOperands();\n+      if (filterKind.equals(FilterKind.AND) || filterKind.equals(FilterKind.OR)) {\n+        for (Expression operand : operands) {\n+          extractPredicatesFromExpression(operand, predicates);\n+        }\n+      } else {\n+        predicates.add(expression);\n+      }\n+    } // else do nothing\n+  }\n+\n+  /**\n+   * Evaluates the theta-sketch post-aggregation expression, which is composed by performing AND/OR on top of\n+   * pre-defined predicates. These predicates are evaluated during the aggregation phase, and the cached\n+   * result is passed to this method to be used when evaluating the expression.\n+   *\n+   * @param expression Expression to evaluate, this is built by applying AND/OR on precomputed sketches\n+   * @param intermediateResult Precomputed sketches for predicates that are part of the expression.\n+   * @return Overall evaluated sketch for the expression.\n+   */\n+  private Sketch evalPostAggregationExpression(Expression expression, Map<String, Sketch> intermediateResult) {\n+    Function functionCall = expression.getFunctionCall();\n+    FilterKind kind = FilterKind.valueOf(functionCall.getOperator());\n+    Sketch result;\n+\n+    switch (kind) {\n+      case AND:\n+        Intersection intersection = getSetOperationBuilder().buildIntersection();\n+        for (Expression operand : functionCall.getOperands()) {\n+          intersection.update(evalPostAggregationExpression(operand, intermediateResult));\n+        }\n+        result = intersection.getResult();\n+        break;\n+\n+      case OR:\n+        Union union = getSetOperationBuilder().buildUnion();\n+        for (Expression operand : functionCall.getOperands()) {\n+          union.update(evalPostAggregationExpression(operand, intermediateResult));\n+        }\n+        result = union.getResult();\n+        break;\n+\n+      default:\n+        String predicate = _expressionMap.get(expression);\n+        result = intermediateResult.get(predicate);\n+        Preconditions.checkState(result != null, \"Precomputed sketch for predicate not provided: \" + predicate);\n+        break;\n+    }\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the theta-sketch SetOperation builder properly configured.\n+   * Currently, only setting of nominalEntries is supported.\n+   * @return SetOperationBuilder\n+   */\n+  private SetOperationBuilder getSetOperationBuilder() {\n+    return (_thetaSketchParams == null) ? SetOperation.builder()\n+        : SetOperation.builder().setNominalEntries(_thetaSketchParams.getNominalEntries());\n+  }\n+\n+  /**\n+   * Helper class to store predicate related information:\n+   * <ul>\n+   *   <li> String representation of the predicate. </li>\n+   *   <li> LHS column of the predicate. </li>\n+   *   <li> Complied {@link Predicate}. </li>\n+   *   <li> Predicate Evaluator. </li>\n+   * </ul>\n+   *\n+   */\n+  private static class PredicateInfo {\n+\n+    private final String _stringVal;\n+    private final String _column; // LHS\n+    private final Predicate _predicate;\n+    private PredicateEvaluator _predicateEvaluator;\n+\n+    private PredicateInfo(String stringVal, String column, Predicate predicate) {\n+      _stringVal = stringVal;\n+      _column = column;\n+      _predicate = predicate;\n+      _predicateEvaluator = null; // Initialized lazily\n+    }\n+\n+    public String getStringVal() {\n+      return _stringVal;\n+    }\n+\n+    public String getColumn() {\n+      return _column;\n+    }\n+\n+    public Predicate getPredicate() {\n+      return _predicate;\n+    }\n+\n+    /**\n+     * Since PredicateEvaluator requires data-type, it is initialized lazily.\n+     *\n+     * @param dataType Data type for RHS of the predicate\n+     * @return Predicate Evaluator\n+     */\n+    public PredicateEvaluator getPredicateEvaluator(FieldSpec.DataType dataType) {\n+      if (_predicateEvaluator != null) {\n+        return _predicateEvaluator;\n+      }\n+\n+      // Theta-sketches work on long and double.\n+      if (dataType == FieldSpec.DataType.INT) {\n+        dataType = FieldSpec.DataType.LONG;\n+      } else if (dataType == FieldSpec.DataType.FLOAT) {\n+        dataType = FieldSpec.DataType.DOUBLE;\n+      }\n+\n+      _predicateEvaluator = PredicateEvaluatorProvider.getPredicateEvaluator(_predicate, null, dataType);\n+      return _predicateEvaluator;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      PredicateInfo that = (PredicateInfo) o;\n+      return Objects.equals(_stringVal, that._stringVal) && Objects.equals(_column, that._column) && Objects\n+          .equals(_predicate, that._predicate) && Objects.equals(_predicateEvaluator, that._predicateEvaluator);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(_stringVal, _column, _predicate, _predicateEvaluator);\n+    }\n+  }\n+}", "originalCommit": "1b79ea990649b860355198cc26977f7607236dd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzNjk1MA==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423336950", "bodyText": "Recommend having all types instead of grouping INT and LONG, FLOAT and DOUBLE to prevent unnecessary type conversion.", "author": "Jackie-Jiang", "createdAt": "2020-05-11T21:42:31Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.calcite.sql.parser.SqlParseException;\n+import org.apache.datasketches.memory.Memory;\n+import org.apache.datasketches.theta.Intersection;\n+import org.apache.datasketches.theta.SetOperation;\n+import org.apache.datasketches.theta.SetOperationBuilder;\n+import org.apache.datasketches.theta.Sketch;\n+import org.apache.datasketches.theta.Union;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.request.Expression;\n+import org.apache.pinot.common.request.ExpressionType;\n+import org.apache.pinot.common.request.Function;\n+import org.apache.pinot.common.request.transform.TransformExpressionTree;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.common.Predicate;\n+import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluator;\n+import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluatorProvider;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ThetaSketchParams;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.parsers.utils.ParserUtils;\n+import org.apache.pinot.pql.parsers.pql2.ast.FilterKind;\n+import org.apache.pinot.pql.parsers.pql2.ast.IdentifierAstNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.sql.parsers.CalciteSqlParser;\n+\n+\n+/**\n+ * Implementation of {@link AggregationFunction} to perform the distinct count aggregation using\n+ * Theta Sketches.\n+ */\n+@SuppressWarnings(\"Duplicates\")\n+public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Integer> {\n+\n+  private String _thetaSketchColumn;\n+  private Set<String> _predicateStrings;\n+  private Expression _postAggregationExpression;\n+  private Set<PredicateInfo> _predicateInfoSet;\n+  private Map<Expression, String> _expressionMap;\n+  private ThetaSketchParams _thetaSketchParams;\n+  private List<TransformExpressionTree> _inputExpressions;\n+\n+  /**\n+   * Constructor for the class.\n+   * @param arguments List of parameters as arguments strings. At least three arguments are expected:\n+   *                    <ul>\n+   *                    <li> Required: First expression is interpreted as theta sketch column to aggregate on. </li>\n+   *                    <li> Required: Second argument is the thetaSketchParams. </li>\n+   *                    <li> Optional: Second to penultimate are predicates with LHS and RHS. </li>\n+   *                    <li> Required: Last expression is the one that will be evaluated to compute final result. </li>\n+   *                    </ul>\n+   */\n+  public DistinctCountThetaSketchAggregationFunction(List<String> arguments)\n+      throws SqlParseException {\n+    int numExpressions = arguments.size();\n+\n+    // This function expects at least 3 arguments: Theta Sketch Column, Predicates & final aggregation expression.\n+    Preconditions.checkArgument(numExpressions >= 3, \"DistinctCountThetaSketch expects at least three arguments, got: \",\n+        numExpressions);\n+\n+    // Initialize all the internal state.\n+    init(arguments);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.DISTINCTCOUNTTHETASKETCH;\n+  }\n+\n+  @Override\n+  public String getColumnName() {\n+    return AggregationFunctionType.DISTINCTCOUNTTHETASKETCH.getName() + \"_\" + _thetaSketchColumn;\n+  }\n+\n+  @Override\n+  public String getResultColumnName() {\n+    return AggregationFunctionType.DISTINCTCOUNTTHETASKETCH.getName().toLowerCase() + \"(\" + _thetaSketchColumn + \")\";\n+  }\n+\n+  @Override\n+  public List<TransformExpressionTree> getInputExpressions() {\n+    return _inputExpressions;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<String, BlockValSet> blockValSetMap) {\n+\n+    Map<String, Union> result = getDefaultResult(aggregationResultHolder, _predicateStrings);\n+    Sketch[] sketches = deserializeSketches(blockValSetMap.get(_thetaSketchColumn).getBytesValuesSV(), length);\n+\n+    for (PredicateInfo predicateInfo : _predicateInfoSet) {\n+      String predicate = predicateInfo.getStringVal();\n+\n+      BlockValSet blockValSet = blockValSetMap.get(predicateInfo.getColumn());\n+      FieldSpec.DataType valueType = blockValSet.getValueType();\n+      PredicateEvaluator predicateEvaluator = predicateInfo.getPredicateEvaluator(valueType);\n+\n+      Union union = result.get(predicate);\n+      switch (valueType) {\n+        case INT:\n+        case LONG:\n+          long[] longValues = blockValSet.getLongValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(longValues[i])) {\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case FLOAT:\n+        case DOUBLE:\n+          double[] doubleValues = blockValSet.getDoubleValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(doubleValues[i])) {\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case STRING:\n+          String[] stringValues = blockValSet.getStringValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(stringValues[i])) {\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        default: // Predicates on BYTES is not allowed.\n+          throw new IllegalStateException(\"Illegal data type for \" + getType() + \" aggregation function: \" + valueType);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<String, BlockValSet> blockValSetMap) {\n+    Sketch[] sketches = deserializeSketches(blockValSetMap.get(_thetaSketchColumn).getBytesValuesSV(), length);\n+\n+    for (PredicateInfo predicateInfo : _predicateInfoSet) {\n+      String predicate = predicateInfo.getStringVal();\n+\n+      BlockValSet blockValSet = blockValSetMap.get(predicateInfo.getColumn());\n+      FieldSpec.DataType valueType = blockValSet.getValueType();\n+      PredicateEvaluator predicateEvaluator = predicateInfo.getPredicateEvaluator(valueType);\n+\n+      Map<String, Union> result;\n+      switch (valueType) {\n+        case INT:\n+        case LONG:\n+          long[] longValues = blockValSet.getLongValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(longValues[i])) {\n+              result = getDefaultResult(groupByResultHolder, groupKeyArray[i], _predicateStrings);\n+              Union union = result.get(predicate);\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case FLOAT:\n+        case DOUBLE:\n+          double[] doubleValues = blockValSet.getDoubleValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(doubleValues[i])) {\n+              result = getDefaultResult(groupByResultHolder, groupKeyArray[i], _predicateStrings);\n+              Union union = result.get(predicate);\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case STRING:\n+          String[] stringValues = blockValSet.getStringValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(stringValues[i])) {\n+              result = getDefaultResult(groupByResultHolder, groupKeyArray[i], _predicateStrings);\n+              Union union = result.get(predicate);\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        default: // Predicates on BYTES is not allowed.\n+          throw new IllegalStateException(\"Illegal data type for \" + getType() + \" aggregation function: \" + valueType);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<String, BlockValSet> blockValSetMap) {\n+    Sketch[] sketches = deserializeSketches(blockValSetMap.get(_thetaSketchColumn).getBytesValuesSV(), length);\n+\n+    for (PredicateInfo predicateInfo : _predicateInfoSet) {\n+      String predicate = predicateInfo.getStringVal();\n+\n+      BlockValSet blockValSet = blockValSetMap.get(predicateInfo.getColumn());\n+      FieldSpec.DataType valueType = blockValSet.getValueType();\n+      PredicateEvaluator predicateEvaluator = predicateInfo.getPredicateEvaluator(valueType);\n+\n+      Map<String, Union> result;\n+      switch (valueType) {\n+        case INT:\n+        case LONG:\n+          long[] longValues = blockValSet.getLongValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(longValues[i])) {\n+\n+              for (int groupKey : groupKeysArray[i]) {\n+                result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+                Union union = result.get(predicate);\n+                union.update(sketches[i]);\n+              }\n+            }\n+          }\n+          break;\n+\n+        case FLOAT:\n+        case DOUBLE:\n+          double[] doubleValues = blockValSet.getDoubleValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(doubleValues[i])) {\n+\n+              for (int groupKey : groupKeysArray[i]) {\n+                result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+                Union union = result.get(predicate);\n+                union.update(sketches[i]);\n+              }\n+            }\n+          }\n+          break;\n+\n+        case STRING:\n+          String[] stringValues = blockValSet.getStringValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(stringValues[i])) {\n+\n+              for (int groupKey : groupKeysArray[i]) {\n+                result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+                Union union = result.get(predicate);\n+                union.update(sketches[i]);\n+              }\n+            }\n+          }\n+          break;\n+\n+        default: // Predicates on BYTES is not allowed.\n+          throw new IllegalStateException(\"Illegal data type for \" + getType() + \" aggregation function: \" + valueType);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Map<String, Sketch> extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    Map<String, Union> result = aggregationResultHolder.getResult();\n+    if (result == null) {\n+      result = getDefaultResult(aggregationResultHolder, _predicateStrings);\n+    }\n+\n+    return result.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().getResult()));\n+  }\n+\n+  @Override\n+  public Map<String, Sketch> extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    Map<String, Union> result = groupByResultHolder.getResult(groupKey);\n+    if (result == null) {\n+      result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+    }\n+\n+    return result.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().getResult()));\n+  }\n+\n+  @Override\n+  public Map<String, Sketch> merge(Map<String, Sketch> intermediateResult1, Map<String, Sketch> intermediateResult2) {\n+    if (intermediateResult1 == null) {\n+      return intermediateResult2;\n+    } else if (intermediateResult2 == null) {\n+      return intermediateResult1;\n+    }\n+\n+    for (Map.Entry<String, Sketch> entry : intermediateResult1.entrySet()) {\n+      String predicate = entry.getKey();\n+      Union union = getSetOperationBuilder().buildUnion();\n+      union.update(entry.getValue());\n+      union.update(intermediateResult2.get(predicate));\n+      intermediateResult1.put(predicate, union.getResult());\n+    }\n+    return intermediateResult1;\n+  }\n+\n+  @Override\n+  public boolean isIntermediateResultComparable() {\n+    return false;\n+  }\n+\n+  @Override\n+  public DataSchema.ColumnDataType getIntermediateResultColumnType() {\n+    return DataSchema.ColumnDataType.OBJECT;\n+  }\n+\n+  @Override\n+  public DataSchema.ColumnDataType getFinalResultColumnType() {\n+    return DataSchema.ColumnDataType.INT;\n+  }\n+\n+  @Override\n+  public Integer extractFinalResult(Map<String, Sketch> intermediateResult) {\n+    // Compute the post aggregation expression and return the result.\n+    Sketch finalSketch = evalPostAggregationExpression(_postAggregationExpression, intermediateResult);\n+    return (int) Math.round(finalSketch.getEstimate());\n+  }\n+\n+  /**\n+   * Returns the Default result for the given expression.\n+   *\n+   * @param aggregationResultHolder Aggregation result holder\n+   * @param expressions Set of expressions that are expected in the result holder\n+   * @return Default result\n+   */\n+  private Map<String, Union> getDefaultResult(AggregationResultHolder aggregationResultHolder,\n+      Set<String> expressions) {\n+    Map<String, Union> result = aggregationResultHolder.getResult();\n+\n+    if (result == null) {\n+      result = new HashMap<>();\n+      aggregationResultHolder.setValue(result);\n+    }\n+\n+    for (String expression : expressions) {\n+      result.putIfAbsent(expression, getSetOperationBuilder().buildUnion());\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the Default result for the given group key if exists, or creates a new one.\n+   *\n+   * @param groupByResultHolder Result holder\n+   * @param groupKey Group key for which to return the default result\n+   * @param expressions Set of expressions that are expected in the result holder\n+   *\n+   * @return Default result for the group-key\n+   */\n+  private Map<String, Union> getDefaultResult(GroupByResultHolder groupByResultHolder, int groupKey,\n+      Set<String> expressions) {\n+    Map<String, Union> result = groupByResultHolder.getResult(groupKey);\n+\n+    if (result == null) {\n+      result = new HashMap<>();\n+      groupByResultHolder.setValueForKey(groupKey, result);\n+    }\n+\n+    for (String expression : expressions) {\n+      result.putIfAbsent(expression, getSetOperationBuilder().buildUnion());\n+    }\n+    return result;\n+  }\n+\n+  private Sketch[] deserializeSketches(byte[][] serializedSketches, int length) {\n+    Sketch[] sketches = new Sketch[length];\n+    for (int i = 0; i < length; i++) {\n+      sketches[i] = Sketch.wrap(Memory.wrap(serializedSketches[i]));\n+    }\n+    return sketches;\n+  }\n+\n+  private void init(List<String> arguments)\n+      throws SqlParseException {\n+\n+    // Predicate Strings are optional. When not specified, they are derived from postAggregationExpression\n+    boolean predicatesSpecified = arguments.size() > 3;\n+\n+    // Initialize the Theta-Sketch Column.\n+    _thetaSketchColumn = arguments.get(0);\n+\n+    // Initialize input expressions. It is expected they are covered between the theta-sketch column and the predicates.\n+    _inputExpressions = new ArrayList<>();\n+    _inputExpressions.add(TransformExpressionTree.compileToExpressionTree(_thetaSketchColumn));\n+\n+    // Initialize thetaSketchParams\n+    String paramsString = arguments.get(1);\n+    _thetaSketchParams = ThetaSketchParams.fromString(paramsString);\n+\n+    String postAggrExpressionString = arguments.get(arguments.size() - 1);\n+    _postAggregationExpression = CalciteSqlParser.compileToExpression(postAggrExpressionString);\n+\n+    _predicateInfoSet = new LinkedHashSet<>();\n+    _predicateStrings = new LinkedHashSet<>(arguments.subList(2, arguments.size() - 1));\n+    _expressionMap = new HashMap<>();\n+\n+    if (predicatesSpecified) {\n+      for (String predicateString : _predicateStrings) {\n+        Expression expression = CalciteSqlParser.compileToExpression(predicateString);\n+\n+        // TODO: Add support for complex predicates with AND/OR.\n+        String filterColumn = ParserUtils.getFilterColumn(expression);\n+        Predicate predicate = Predicate.newPredicate(ParserUtils.getFilterType(expression), filterColumn, ParserUtils.getFilterValues(expression));\n+\n+        _predicateInfoSet.add(new PredicateInfo(predicateString, filterColumn, predicate));\n+        _expressionMap.put(expression, predicateString);\n+        _inputExpressions.add(new TransformExpressionTree(new IdentifierAstNode(filterColumn)));\n+      }\n+    } else {\n+      // Auto-derive predicates from postAggregationExpression.\n+      Set<Expression> predicateExpressions = extractPredicatesFromString(postAggrExpressionString);\n+      for (Expression predicateExpression : predicateExpressions) {\n+        String filterColumn = ParserUtils.getFilterColumn(predicateExpression);\n+        Predicate predicate = Predicate\n+            .newPredicate(ParserUtils.getFilterType(predicateExpression), filterColumn, ParserUtils.getFilterValues(predicateExpression));\n+\n+        String predicateString = ParserUtils.standardizeExpression(predicateExpression, false);\n+        _predicateStrings.add(predicateString);\n+        _predicateInfoSet.add(new PredicateInfo(predicateString, filterColumn, predicate));\n+        _expressionMap.put(predicateExpression, predicateString);\n+        _inputExpressions.add(new TransformExpressionTree(new IdentifierAstNode(filterColumn)));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Given a post aggregation String of form like ((p1 and p2) or (p3 and p4)), returns the individual\n+   * predicates p1, p2, p3, p4.\n+   *\n+   * @param postAggrExpressionString Post aggregation expression String input\n+   * @return Set of predicates that compose the input expression\n+   * @throws SqlParseException If invalid expression String specified\n+   */\n+  private Set<Expression> extractPredicatesFromString(String postAggrExpressionString)\n+      throws SqlParseException {\n+    Set<Expression> predicates = new LinkedHashSet<>();\n+    _postAggregationExpression = CalciteSqlParser.compileToExpression(postAggrExpressionString);\n+    extractPredicatesFromExpression(_postAggregationExpression, predicates);\n+    return predicates;\n+  }\n+\n+  private void extractPredicatesFromExpression(Expression expression, Set<Expression> predicates) {\n+    ExpressionType type = expression.getType();\n+\n+    if (type.equals(ExpressionType.FUNCTION)) {\n+      Function function = expression.getFunctionCall();\n+      FilterKind filterKind = FilterKind.valueOf(function.getOperator());\n+\n+      List<Expression> operands = function.getOperands();\n+      if (filterKind.equals(FilterKind.AND) || filterKind.equals(FilterKind.OR)) {\n+        for (Expression operand : operands) {\n+          extractPredicatesFromExpression(operand, predicates);\n+        }\n+      } else {\n+        predicates.add(expression);\n+      }\n+    } // else do nothing\n+  }\n+\n+  /**\n+   * Evaluates the theta-sketch post-aggregation expression, which is composed by performing AND/OR on top of\n+   * pre-defined predicates. These predicates are evaluated during the aggregation phase, and the cached\n+   * result is passed to this method to be used when evaluating the expression.\n+   *\n+   * @param expression Expression to evaluate, this is built by applying AND/OR on precomputed sketches\n+   * @param intermediateResult Precomputed sketches for predicates that are part of the expression.\n+   * @return Overall evaluated sketch for the expression.\n+   */\n+  private Sketch evalPostAggregationExpression(Expression expression, Map<String, Sketch> intermediateResult) {\n+    Function functionCall = expression.getFunctionCall();\n+    FilterKind kind = FilterKind.valueOf(functionCall.getOperator());\n+    Sketch result;\n+\n+    switch (kind) {\n+      case AND:\n+        Intersection intersection = getSetOperationBuilder().buildIntersection();\n+        for (Expression operand : functionCall.getOperands()) {\n+          intersection.update(evalPostAggregationExpression(operand, intermediateResult));\n+        }\n+        result = intersection.getResult();\n+        break;\n+\n+      case OR:\n+        Union union = getSetOperationBuilder().buildUnion();\n+        for (Expression operand : functionCall.getOperands()) {\n+          union.update(evalPostAggregationExpression(operand, intermediateResult));\n+        }\n+        result = union.getResult();\n+        break;\n+\n+      default:\n+        String predicate = _expressionMap.get(expression);\n+        result = intermediateResult.get(predicate);\n+        Preconditions.checkState(result != null, \"Precomputed sketch for predicate not provided: \" + predicate);\n+        break;\n+    }\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the theta-sketch SetOperation builder properly configured.\n+   * Currently, only setting of nominalEntries is supported.\n+   * @return SetOperationBuilder\n+   */\n+  private SetOperationBuilder getSetOperationBuilder() {\n+    return (_thetaSketchParams == null) ? SetOperation.builder()\n+        : SetOperation.builder().setNominalEntries(_thetaSketchParams.getNominalEntries());\n+  }\n+\n+  /**\n+   * Helper class to store predicate related information:\n+   * <ul>\n+   *   <li> String representation of the predicate. </li>\n+   *   <li> LHS column of the predicate. </li>\n+   *   <li> Complied {@link Predicate}. </li>\n+   *   <li> Predicate Evaluator. </li>\n+   * </ul>\n+   *\n+   */\n+  private static class PredicateInfo {\n+\n+    private final String _stringVal;\n+    private final String _column; // LHS\n+    private final Predicate _predicate;\n+    private PredicateEvaluator _predicateEvaluator;\n+\n+    private PredicateInfo(String stringVal, String column, Predicate predicate) {\n+      _stringVal = stringVal;\n+      _column = column;\n+      _predicate = predicate;\n+      _predicateEvaluator = null; // Initialized lazily\n+    }\n+\n+    public String getStringVal() {\n+      return _stringVal;\n+    }\n+\n+    public String getColumn() {\n+      return _column;\n+    }\n+\n+    public Predicate getPredicate() {\n+      return _predicate;\n+    }\n+\n+    /**\n+     * Since PredicateEvaluator requires data-type, it is initialized lazily.\n+     *\n+     * @param dataType Data type for RHS of the predicate\n+     * @return Predicate Evaluator\n+     */\n+    public PredicateEvaluator getPredicateEvaluator(FieldSpec.DataType dataType) {", "originalCommit": "1b79ea990649b860355198cc26977f7607236dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2MDU4NA==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423360584", "bodyText": "Theta-Sketch api's don't support int/float.", "author": "mayankshriv", "createdAt": "2020-05-11T22:40:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzNjk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2NjExMQ==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423366111", "bodyText": "This part is for predicate evaluation right? Theta-sketch should always be BYTES type", "author": "Jackie-Jiang", "createdAt": "2020-05-11T22:56:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzNjk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzNzQ3Mw==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423337473", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (o == null || getClass() != o.getClass()) {\n          \n          \n            \n                  if (o instanceof PredicateEvaluator) {", "author": "Jackie-Jiang", "createdAt": "2020-05-11T21:43:34Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.calcite.sql.parser.SqlParseException;\n+import org.apache.datasketches.memory.Memory;\n+import org.apache.datasketches.theta.Intersection;\n+import org.apache.datasketches.theta.SetOperation;\n+import org.apache.datasketches.theta.SetOperationBuilder;\n+import org.apache.datasketches.theta.Sketch;\n+import org.apache.datasketches.theta.Union;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.request.Expression;\n+import org.apache.pinot.common.request.ExpressionType;\n+import org.apache.pinot.common.request.Function;\n+import org.apache.pinot.common.request.transform.TransformExpressionTree;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.common.Predicate;\n+import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluator;\n+import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluatorProvider;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ThetaSketchParams;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.parsers.utils.ParserUtils;\n+import org.apache.pinot.pql.parsers.pql2.ast.FilterKind;\n+import org.apache.pinot.pql.parsers.pql2.ast.IdentifierAstNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.sql.parsers.CalciteSqlParser;\n+\n+\n+/**\n+ * Implementation of {@link AggregationFunction} to perform the distinct count aggregation using\n+ * Theta Sketches.\n+ */\n+@SuppressWarnings(\"Duplicates\")\n+public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Integer> {\n+\n+  private String _thetaSketchColumn;\n+  private Set<String> _predicateStrings;\n+  private Expression _postAggregationExpression;\n+  private Set<PredicateInfo> _predicateInfoSet;\n+  private Map<Expression, String> _expressionMap;\n+  private ThetaSketchParams _thetaSketchParams;\n+  private List<TransformExpressionTree> _inputExpressions;\n+\n+  /**\n+   * Constructor for the class.\n+   * @param arguments List of parameters as arguments strings. At least three arguments are expected:\n+   *                    <ul>\n+   *                    <li> Required: First expression is interpreted as theta sketch column to aggregate on. </li>\n+   *                    <li> Required: Second argument is the thetaSketchParams. </li>\n+   *                    <li> Optional: Second to penultimate are predicates with LHS and RHS. </li>\n+   *                    <li> Required: Last expression is the one that will be evaluated to compute final result. </li>\n+   *                    </ul>\n+   */\n+  public DistinctCountThetaSketchAggregationFunction(List<String> arguments)\n+      throws SqlParseException {\n+    int numExpressions = arguments.size();\n+\n+    // This function expects at least 3 arguments: Theta Sketch Column, Predicates & final aggregation expression.\n+    Preconditions.checkArgument(numExpressions >= 3, \"DistinctCountThetaSketch expects at least three arguments, got: \",\n+        numExpressions);\n+\n+    // Initialize all the internal state.\n+    init(arguments);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.DISTINCTCOUNTTHETASKETCH;\n+  }\n+\n+  @Override\n+  public String getColumnName() {\n+    return AggregationFunctionType.DISTINCTCOUNTTHETASKETCH.getName() + \"_\" + _thetaSketchColumn;\n+  }\n+\n+  @Override\n+  public String getResultColumnName() {\n+    return AggregationFunctionType.DISTINCTCOUNTTHETASKETCH.getName().toLowerCase() + \"(\" + _thetaSketchColumn + \")\";\n+  }\n+\n+  @Override\n+  public List<TransformExpressionTree> getInputExpressions() {\n+    return _inputExpressions;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<String, BlockValSet> blockValSetMap) {\n+\n+    Map<String, Union> result = getDefaultResult(aggregationResultHolder, _predicateStrings);\n+    Sketch[] sketches = deserializeSketches(blockValSetMap.get(_thetaSketchColumn).getBytesValuesSV(), length);\n+\n+    for (PredicateInfo predicateInfo : _predicateInfoSet) {\n+      String predicate = predicateInfo.getStringVal();\n+\n+      BlockValSet blockValSet = blockValSetMap.get(predicateInfo.getColumn());\n+      FieldSpec.DataType valueType = blockValSet.getValueType();\n+      PredicateEvaluator predicateEvaluator = predicateInfo.getPredicateEvaluator(valueType);\n+\n+      Union union = result.get(predicate);\n+      switch (valueType) {\n+        case INT:\n+        case LONG:\n+          long[] longValues = blockValSet.getLongValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(longValues[i])) {\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case FLOAT:\n+        case DOUBLE:\n+          double[] doubleValues = blockValSet.getDoubleValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(doubleValues[i])) {\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case STRING:\n+          String[] stringValues = blockValSet.getStringValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(stringValues[i])) {\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        default: // Predicates on BYTES is not allowed.\n+          throw new IllegalStateException(\"Illegal data type for \" + getType() + \" aggregation function: \" + valueType);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<String, BlockValSet> blockValSetMap) {\n+    Sketch[] sketches = deserializeSketches(blockValSetMap.get(_thetaSketchColumn).getBytesValuesSV(), length);\n+\n+    for (PredicateInfo predicateInfo : _predicateInfoSet) {\n+      String predicate = predicateInfo.getStringVal();\n+\n+      BlockValSet blockValSet = blockValSetMap.get(predicateInfo.getColumn());\n+      FieldSpec.DataType valueType = blockValSet.getValueType();\n+      PredicateEvaluator predicateEvaluator = predicateInfo.getPredicateEvaluator(valueType);\n+\n+      Map<String, Union> result;\n+      switch (valueType) {\n+        case INT:\n+        case LONG:\n+          long[] longValues = blockValSet.getLongValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(longValues[i])) {\n+              result = getDefaultResult(groupByResultHolder, groupKeyArray[i], _predicateStrings);\n+              Union union = result.get(predicate);\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case FLOAT:\n+        case DOUBLE:\n+          double[] doubleValues = blockValSet.getDoubleValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(doubleValues[i])) {\n+              result = getDefaultResult(groupByResultHolder, groupKeyArray[i], _predicateStrings);\n+              Union union = result.get(predicate);\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case STRING:\n+          String[] stringValues = blockValSet.getStringValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(stringValues[i])) {\n+              result = getDefaultResult(groupByResultHolder, groupKeyArray[i], _predicateStrings);\n+              Union union = result.get(predicate);\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        default: // Predicates on BYTES is not allowed.\n+          throw new IllegalStateException(\"Illegal data type for \" + getType() + \" aggregation function: \" + valueType);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<String, BlockValSet> blockValSetMap) {\n+    Sketch[] sketches = deserializeSketches(blockValSetMap.get(_thetaSketchColumn).getBytesValuesSV(), length);\n+\n+    for (PredicateInfo predicateInfo : _predicateInfoSet) {\n+      String predicate = predicateInfo.getStringVal();\n+\n+      BlockValSet blockValSet = blockValSetMap.get(predicateInfo.getColumn());\n+      FieldSpec.DataType valueType = blockValSet.getValueType();\n+      PredicateEvaluator predicateEvaluator = predicateInfo.getPredicateEvaluator(valueType);\n+\n+      Map<String, Union> result;\n+      switch (valueType) {\n+        case INT:\n+        case LONG:\n+          long[] longValues = blockValSet.getLongValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(longValues[i])) {\n+\n+              for (int groupKey : groupKeysArray[i]) {\n+                result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+                Union union = result.get(predicate);\n+                union.update(sketches[i]);\n+              }\n+            }\n+          }\n+          break;\n+\n+        case FLOAT:\n+        case DOUBLE:\n+          double[] doubleValues = blockValSet.getDoubleValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(doubleValues[i])) {\n+\n+              for (int groupKey : groupKeysArray[i]) {\n+                result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+                Union union = result.get(predicate);\n+                union.update(sketches[i]);\n+              }\n+            }\n+          }\n+          break;\n+\n+        case STRING:\n+          String[] stringValues = blockValSet.getStringValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(stringValues[i])) {\n+\n+              for (int groupKey : groupKeysArray[i]) {\n+                result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+                Union union = result.get(predicate);\n+                union.update(sketches[i]);\n+              }\n+            }\n+          }\n+          break;\n+\n+        default: // Predicates on BYTES is not allowed.\n+          throw new IllegalStateException(\"Illegal data type for \" + getType() + \" aggregation function: \" + valueType);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Map<String, Sketch> extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    Map<String, Union> result = aggregationResultHolder.getResult();\n+    if (result == null) {\n+      result = getDefaultResult(aggregationResultHolder, _predicateStrings);\n+    }\n+\n+    return result.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().getResult()));\n+  }\n+\n+  @Override\n+  public Map<String, Sketch> extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    Map<String, Union> result = groupByResultHolder.getResult(groupKey);\n+    if (result == null) {\n+      result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+    }\n+\n+    return result.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().getResult()));\n+  }\n+\n+  @Override\n+  public Map<String, Sketch> merge(Map<String, Sketch> intermediateResult1, Map<String, Sketch> intermediateResult2) {\n+    if (intermediateResult1 == null) {\n+      return intermediateResult2;\n+    } else if (intermediateResult2 == null) {\n+      return intermediateResult1;\n+    }\n+\n+    for (Map.Entry<String, Sketch> entry : intermediateResult1.entrySet()) {\n+      String predicate = entry.getKey();\n+      Union union = getSetOperationBuilder().buildUnion();\n+      union.update(entry.getValue());\n+      union.update(intermediateResult2.get(predicate));\n+      intermediateResult1.put(predicate, union.getResult());\n+    }\n+    return intermediateResult1;\n+  }\n+\n+  @Override\n+  public boolean isIntermediateResultComparable() {\n+    return false;\n+  }\n+\n+  @Override\n+  public DataSchema.ColumnDataType getIntermediateResultColumnType() {\n+    return DataSchema.ColumnDataType.OBJECT;\n+  }\n+\n+  @Override\n+  public DataSchema.ColumnDataType getFinalResultColumnType() {\n+    return DataSchema.ColumnDataType.INT;\n+  }\n+\n+  @Override\n+  public Integer extractFinalResult(Map<String, Sketch> intermediateResult) {\n+    // Compute the post aggregation expression and return the result.\n+    Sketch finalSketch = evalPostAggregationExpression(_postAggregationExpression, intermediateResult);\n+    return (int) Math.round(finalSketch.getEstimate());\n+  }\n+\n+  /**\n+   * Returns the Default result for the given expression.\n+   *\n+   * @param aggregationResultHolder Aggregation result holder\n+   * @param expressions Set of expressions that are expected in the result holder\n+   * @return Default result\n+   */\n+  private Map<String, Union> getDefaultResult(AggregationResultHolder aggregationResultHolder,\n+      Set<String> expressions) {\n+    Map<String, Union> result = aggregationResultHolder.getResult();\n+\n+    if (result == null) {\n+      result = new HashMap<>();\n+      aggregationResultHolder.setValue(result);\n+    }\n+\n+    for (String expression : expressions) {\n+      result.putIfAbsent(expression, getSetOperationBuilder().buildUnion());\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the Default result for the given group key if exists, or creates a new one.\n+   *\n+   * @param groupByResultHolder Result holder\n+   * @param groupKey Group key for which to return the default result\n+   * @param expressions Set of expressions that are expected in the result holder\n+   *\n+   * @return Default result for the group-key\n+   */\n+  private Map<String, Union> getDefaultResult(GroupByResultHolder groupByResultHolder, int groupKey,\n+      Set<String> expressions) {\n+    Map<String, Union> result = groupByResultHolder.getResult(groupKey);\n+\n+    if (result == null) {\n+      result = new HashMap<>();\n+      groupByResultHolder.setValueForKey(groupKey, result);\n+    }\n+\n+    for (String expression : expressions) {\n+      result.putIfAbsent(expression, getSetOperationBuilder().buildUnion());\n+    }\n+    return result;\n+  }\n+\n+  private Sketch[] deserializeSketches(byte[][] serializedSketches, int length) {\n+    Sketch[] sketches = new Sketch[length];\n+    for (int i = 0; i < length; i++) {\n+      sketches[i] = Sketch.wrap(Memory.wrap(serializedSketches[i]));\n+    }\n+    return sketches;\n+  }\n+\n+  private void init(List<String> arguments)\n+      throws SqlParseException {\n+\n+    // Predicate Strings are optional. When not specified, they are derived from postAggregationExpression\n+    boolean predicatesSpecified = arguments.size() > 3;\n+\n+    // Initialize the Theta-Sketch Column.\n+    _thetaSketchColumn = arguments.get(0);\n+\n+    // Initialize input expressions. It is expected they are covered between the theta-sketch column and the predicates.\n+    _inputExpressions = new ArrayList<>();\n+    _inputExpressions.add(TransformExpressionTree.compileToExpressionTree(_thetaSketchColumn));\n+\n+    // Initialize thetaSketchParams\n+    String paramsString = arguments.get(1);\n+    _thetaSketchParams = ThetaSketchParams.fromString(paramsString);\n+\n+    String postAggrExpressionString = arguments.get(arguments.size() - 1);\n+    _postAggregationExpression = CalciteSqlParser.compileToExpression(postAggrExpressionString);\n+\n+    _predicateInfoSet = new LinkedHashSet<>();\n+    _predicateStrings = new LinkedHashSet<>(arguments.subList(2, arguments.size() - 1));\n+    _expressionMap = new HashMap<>();\n+\n+    if (predicatesSpecified) {\n+      for (String predicateString : _predicateStrings) {\n+        Expression expression = CalciteSqlParser.compileToExpression(predicateString);\n+\n+        // TODO: Add support for complex predicates with AND/OR.\n+        String filterColumn = ParserUtils.getFilterColumn(expression);\n+        Predicate predicate = Predicate.newPredicate(ParserUtils.getFilterType(expression), filterColumn, ParserUtils.getFilterValues(expression));\n+\n+        _predicateInfoSet.add(new PredicateInfo(predicateString, filterColumn, predicate));\n+        _expressionMap.put(expression, predicateString);\n+        _inputExpressions.add(new TransformExpressionTree(new IdentifierAstNode(filterColumn)));\n+      }\n+    } else {\n+      // Auto-derive predicates from postAggregationExpression.\n+      Set<Expression> predicateExpressions = extractPredicatesFromString(postAggrExpressionString);\n+      for (Expression predicateExpression : predicateExpressions) {\n+        String filterColumn = ParserUtils.getFilterColumn(predicateExpression);\n+        Predicate predicate = Predicate\n+            .newPredicate(ParserUtils.getFilterType(predicateExpression), filterColumn, ParserUtils.getFilterValues(predicateExpression));\n+\n+        String predicateString = ParserUtils.standardizeExpression(predicateExpression, false);\n+        _predicateStrings.add(predicateString);\n+        _predicateInfoSet.add(new PredicateInfo(predicateString, filterColumn, predicate));\n+        _expressionMap.put(predicateExpression, predicateString);\n+        _inputExpressions.add(new TransformExpressionTree(new IdentifierAstNode(filterColumn)));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Given a post aggregation String of form like ((p1 and p2) or (p3 and p4)), returns the individual\n+   * predicates p1, p2, p3, p4.\n+   *\n+   * @param postAggrExpressionString Post aggregation expression String input\n+   * @return Set of predicates that compose the input expression\n+   * @throws SqlParseException If invalid expression String specified\n+   */\n+  private Set<Expression> extractPredicatesFromString(String postAggrExpressionString)\n+      throws SqlParseException {\n+    Set<Expression> predicates = new LinkedHashSet<>();\n+    _postAggregationExpression = CalciteSqlParser.compileToExpression(postAggrExpressionString);\n+    extractPredicatesFromExpression(_postAggregationExpression, predicates);\n+    return predicates;\n+  }\n+\n+  private void extractPredicatesFromExpression(Expression expression, Set<Expression> predicates) {\n+    ExpressionType type = expression.getType();\n+\n+    if (type.equals(ExpressionType.FUNCTION)) {\n+      Function function = expression.getFunctionCall();\n+      FilterKind filterKind = FilterKind.valueOf(function.getOperator());\n+\n+      List<Expression> operands = function.getOperands();\n+      if (filterKind.equals(FilterKind.AND) || filterKind.equals(FilterKind.OR)) {\n+        for (Expression operand : operands) {\n+          extractPredicatesFromExpression(operand, predicates);\n+        }\n+      } else {\n+        predicates.add(expression);\n+      }\n+    } // else do nothing\n+  }\n+\n+  /**\n+   * Evaluates the theta-sketch post-aggregation expression, which is composed by performing AND/OR on top of\n+   * pre-defined predicates. These predicates are evaluated during the aggregation phase, and the cached\n+   * result is passed to this method to be used when evaluating the expression.\n+   *\n+   * @param expression Expression to evaluate, this is built by applying AND/OR on precomputed sketches\n+   * @param intermediateResult Precomputed sketches for predicates that are part of the expression.\n+   * @return Overall evaluated sketch for the expression.\n+   */\n+  private Sketch evalPostAggregationExpression(Expression expression, Map<String, Sketch> intermediateResult) {\n+    Function functionCall = expression.getFunctionCall();\n+    FilterKind kind = FilterKind.valueOf(functionCall.getOperator());\n+    Sketch result;\n+\n+    switch (kind) {\n+      case AND:\n+        Intersection intersection = getSetOperationBuilder().buildIntersection();\n+        for (Expression operand : functionCall.getOperands()) {\n+          intersection.update(evalPostAggregationExpression(operand, intermediateResult));\n+        }\n+        result = intersection.getResult();\n+        break;\n+\n+      case OR:\n+        Union union = getSetOperationBuilder().buildUnion();\n+        for (Expression operand : functionCall.getOperands()) {\n+          union.update(evalPostAggregationExpression(operand, intermediateResult));\n+        }\n+        result = union.getResult();\n+        break;\n+\n+      default:\n+        String predicate = _expressionMap.get(expression);\n+        result = intermediateResult.get(predicate);\n+        Preconditions.checkState(result != null, \"Precomputed sketch for predicate not provided: \" + predicate);\n+        break;\n+    }\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the theta-sketch SetOperation builder properly configured.\n+   * Currently, only setting of nominalEntries is supported.\n+   * @return SetOperationBuilder\n+   */\n+  private SetOperationBuilder getSetOperationBuilder() {\n+    return (_thetaSketchParams == null) ? SetOperation.builder()\n+        : SetOperation.builder().setNominalEntries(_thetaSketchParams.getNominalEntries());\n+  }\n+\n+  /**\n+   * Helper class to store predicate related information:\n+   * <ul>\n+   *   <li> String representation of the predicate. </li>\n+   *   <li> LHS column of the predicate. </li>\n+   *   <li> Complied {@link Predicate}. </li>\n+   *   <li> Predicate Evaluator. </li>\n+   * </ul>\n+   *\n+   */\n+  private static class PredicateInfo {\n+\n+    private final String _stringVal;\n+    private final String _column; // LHS\n+    private final Predicate _predicate;\n+    private PredicateEvaluator _predicateEvaluator;\n+\n+    private PredicateInfo(String stringVal, String column, Predicate predicate) {\n+      _stringVal = stringVal;\n+      _column = column;\n+      _predicate = predicate;\n+      _predicateEvaluator = null; // Initialized lazily\n+    }\n+\n+    public String getStringVal() {\n+      return _stringVal;\n+    }\n+\n+    public String getColumn() {\n+      return _column;\n+    }\n+\n+    public Predicate getPredicate() {\n+      return _predicate;\n+    }\n+\n+    /**\n+     * Since PredicateEvaluator requires data-type, it is initialized lazily.\n+     *\n+     * @param dataType Data type for RHS of the predicate\n+     * @return Predicate Evaluator\n+     */\n+    public PredicateEvaluator getPredicateEvaluator(FieldSpec.DataType dataType) {\n+      if (_predicateEvaluator != null) {\n+        return _predicateEvaluator;\n+      }\n+\n+      // Theta-sketches work on long and double.\n+      if (dataType == FieldSpec.DataType.INT) {\n+        dataType = FieldSpec.DataType.LONG;\n+      } else if (dataType == FieldSpec.DataType.FLOAT) {\n+        dataType = FieldSpec.DataType.DOUBLE;\n+      }\n+\n+      _predicateEvaluator = PredicateEvaluatorProvider.getPredicateEvaluator(_predicate, null, dataType);\n+      return _predicateEvaluator;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {", "originalCommit": "1b79ea990649b860355198cc26977f7607236dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2MTA0Mw==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423361043", "bodyText": "Auto-generated code, but will change.", "author": "mayankshriv", "createdAt": "2020-05-11T22:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzNzQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzODkzNA==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423338934", "bodyText": "For equals() and hashCode(), if _predicateEvaluator is lazily set, you should not include it into the comparison or hash code calculation.", "author": "Jackie-Jiang", "createdAt": "2020-05-11T21:46:47Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.calcite.sql.parser.SqlParseException;\n+import org.apache.datasketches.memory.Memory;\n+import org.apache.datasketches.theta.Intersection;\n+import org.apache.datasketches.theta.SetOperation;\n+import org.apache.datasketches.theta.SetOperationBuilder;\n+import org.apache.datasketches.theta.Sketch;\n+import org.apache.datasketches.theta.Union;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.request.Expression;\n+import org.apache.pinot.common.request.ExpressionType;\n+import org.apache.pinot.common.request.Function;\n+import org.apache.pinot.common.request.transform.TransformExpressionTree;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.common.Predicate;\n+import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluator;\n+import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluatorProvider;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ThetaSketchParams;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.parsers.utils.ParserUtils;\n+import org.apache.pinot.pql.parsers.pql2.ast.FilterKind;\n+import org.apache.pinot.pql.parsers.pql2.ast.IdentifierAstNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.sql.parsers.CalciteSqlParser;\n+\n+\n+/**\n+ * Implementation of {@link AggregationFunction} to perform the distinct count aggregation using\n+ * Theta Sketches.\n+ */\n+@SuppressWarnings(\"Duplicates\")\n+public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Integer> {\n+\n+  private String _thetaSketchColumn;\n+  private Set<String> _predicateStrings;\n+  private Expression _postAggregationExpression;\n+  private Set<PredicateInfo> _predicateInfoSet;\n+  private Map<Expression, String> _expressionMap;\n+  private ThetaSketchParams _thetaSketchParams;\n+  private List<TransformExpressionTree> _inputExpressions;\n+\n+  /**\n+   * Constructor for the class.\n+   * @param arguments List of parameters as arguments strings. At least three arguments are expected:\n+   *                    <ul>\n+   *                    <li> Required: First expression is interpreted as theta sketch column to aggregate on. </li>\n+   *                    <li> Required: Second argument is the thetaSketchParams. </li>\n+   *                    <li> Optional: Second to penultimate are predicates with LHS and RHS. </li>\n+   *                    <li> Required: Last expression is the one that will be evaluated to compute final result. </li>\n+   *                    </ul>\n+   */\n+  public DistinctCountThetaSketchAggregationFunction(List<String> arguments)\n+      throws SqlParseException {\n+    int numExpressions = arguments.size();\n+\n+    // This function expects at least 3 arguments: Theta Sketch Column, Predicates & final aggregation expression.\n+    Preconditions.checkArgument(numExpressions >= 3, \"DistinctCountThetaSketch expects at least three arguments, got: \",\n+        numExpressions);\n+\n+    // Initialize all the internal state.\n+    init(arguments);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.DISTINCTCOUNTTHETASKETCH;\n+  }\n+\n+  @Override\n+  public String getColumnName() {\n+    return AggregationFunctionType.DISTINCTCOUNTTHETASKETCH.getName() + \"_\" + _thetaSketchColumn;\n+  }\n+\n+  @Override\n+  public String getResultColumnName() {\n+    return AggregationFunctionType.DISTINCTCOUNTTHETASKETCH.getName().toLowerCase() + \"(\" + _thetaSketchColumn + \")\";\n+  }\n+\n+  @Override\n+  public List<TransformExpressionTree> getInputExpressions() {\n+    return _inputExpressions;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<String, BlockValSet> blockValSetMap) {\n+\n+    Map<String, Union> result = getDefaultResult(aggregationResultHolder, _predicateStrings);\n+    Sketch[] sketches = deserializeSketches(blockValSetMap.get(_thetaSketchColumn).getBytesValuesSV(), length);\n+\n+    for (PredicateInfo predicateInfo : _predicateInfoSet) {\n+      String predicate = predicateInfo.getStringVal();\n+\n+      BlockValSet blockValSet = blockValSetMap.get(predicateInfo.getColumn());\n+      FieldSpec.DataType valueType = blockValSet.getValueType();\n+      PredicateEvaluator predicateEvaluator = predicateInfo.getPredicateEvaluator(valueType);\n+\n+      Union union = result.get(predicate);\n+      switch (valueType) {\n+        case INT:\n+        case LONG:\n+          long[] longValues = blockValSet.getLongValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(longValues[i])) {\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case FLOAT:\n+        case DOUBLE:\n+          double[] doubleValues = blockValSet.getDoubleValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(doubleValues[i])) {\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case STRING:\n+          String[] stringValues = blockValSet.getStringValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(stringValues[i])) {\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        default: // Predicates on BYTES is not allowed.\n+          throw new IllegalStateException(\"Illegal data type for \" + getType() + \" aggregation function: \" + valueType);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<String, BlockValSet> blockValSetMap) {\n+    Sketch[] sketches = deserializeSketches(blockValSetMap.get(_thetaSketchColumn).getBytesValuesSV(), length);\n+\n+    for (PredicateInfo predicateInfo : _predicateInfoSet) {\n+      String predicate = predicateInfo.getStringVal();\n+\n+      BlockValSet blockValSet = blockValSetMap.get(predicateInfo.getColumn());\n+      FieldSpec.DataType valueType = blockValSet.getValueType();\n+      PredicateEvaluator predicateEvaluator = predicateInfo.getPredicateEvaluator(valueType);\n+\n+      Map<String, Union> result;\n+      switch (valueType) {\n+        case INT:\n+        case LONG:\n+          long[] longValues = blockValSet.getLongValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(longValues[i])) {\n+              result = getDefaultResult(groupByResultHolder, groupKeyArray[i], _predicateStrings);\n+              Union union = result.get(predicate);\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case FLOAT:\n+        case DOUBLE:\n+          double[] doubleValues = blockValSet.getDoubleValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(doubleValues[i])) {\n+              result = getDefaultResult(groupByResultHolder, groupKeyArray[i], _predicateStrings);\n+              Union union = result.get(predicate);\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case STRING:\n+          String[] stringValues = blockValSet.getStringValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(stringValues[i])) {\n+              result = getDefaultResult(groupByResultHolder, groupKeyArray[i], _predicateStrings);\n+              Union union = result.get(predicate);\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        default: // Predicates on BYTES is not allowed.\n+          throw new IllegalStateException(\"Illegal data type for \" + getType() + \" aggregation function: \" + valueType);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<String, BlockValSet> blockValSetMap) {\n+    Sketch[] sketches = deserializeSketches(blockValSetMap.get(_thetaSketchColumn).getBytesValuesSV(), length);\n+\n+    for (PredicateInfo predicateInfo : _predicateInfoSet) {\n+      String predicate = predicateInfo.getStringVal();\n+\n+      BlockValSet blockValSet = blockValSetMap.get(predicateInfo.getColumn());\n+      FieldSpec.DataType valueType = blockValSet.getValueType();\n+      PredicateEvaluator predicateEvaluator = predicateInfo.getPredicateEvaluator(valueType);\n+\n+      Map<String, Union> result;\n+      switch (valueType) {\n+        case INT:\n+        case LONG:\n+          long[] longValues = blockValSet.getLongValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(longValues[i])) {\n+\n+              for (int groupKey : groupKeysArray[i]) {\n+                result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+                Union union = result.get(predicate);\n+                union.update(sketches[i]);\n+              }\n+            }\n+          }\n+          break;\n+\n+        case FLOAT:\n+        case DOUBLE:\n+          double[] doubleValues = blockValSet.getDoubleValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(doubleValues[i])) {\n+\n+              for (int groupKey : groupKeysArray[i]) {\n+                result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+                Union union = result.get(predicate);\n+                union.update(sketches[i]);\n+              }\n+            }\n+          }\n+          break;\n+\n+        case STRING:\n+          String[] stringValues = blockValSet.getStringValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(stringValues[i])) {\n+\n+              for (int groupKey : groupKeysArray[i]) {\n+                result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+                Union union = result.get(predicate);\n+                union.update(sketches[i]);\n+              }\n+            }\n+          }\n+          break;\n+\n+        default: // Predicates on BYTES is not allowed.\n+          throw new IllegalStateException(\"Illegal data type for \" + getType() + \" aggregation function: \" + valueType);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Map<String, Sketch> extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    Map<String, Union> result = aggregationResultHolder.getResult();\n+    if (result == null) {\n+      result = getDefaultResult(aggregationResultHolder, _predicateStrings);\n+    }\n+\n+    return result.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().getResult()));\n+  }\n+\n+  @Override\n+  public Map<String, Sketch> extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    Map<String, Union> result = groupByResultHolder.getResult(groupKey);\n+    if (result == null) {\n+      result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+    }\n+\n+    return result.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().getResult()));\n+  }\n+\n+  @Override\n+  public Map<String, Sketch> merge(Map<String, Sketch> intermediateResult1, Map<String, Sketch> intermediateResult2) {\n+    if (intermediateResult1 == null) {\n+      return intermediateResult2;\n+    } else if (intermediateResult2 == null) {\n+      return intermediateResult1;\n+    }\n+\n+    for (Map.Entry<String, Sketch> entry : intermediateResult1.entrySet()) {\n+      String predicate = entry.getKey();\n+      Union union = getSetOperationBuilder().buildUnion();\n+      union.update(entry.getValue());\n+      union.update(intermediateResult2.get(predicate));\n+      intermediateResult1.put(predicate, union.getResult());\n+    }\n+    return intermediateResult1;\n+  }\n+\n+  @Override\n+  public boolean isIntermediateResultComparable() {\n+    return false;\n+  }\n+\n+  @Override\n+  public DataSchema.ColumnDataType getIntermediateResultColumnType() {\n+    return DataSchema.ColumnDataType.OBJECT;\n+  }\n+\n+  @Override\n+  public DataSchema.ColumnDataType getFinalResultColumnType() {\n+    return DataSchema.ColumnDataType.INT;\n+  }\n+\n+  @Override\n+  public Integer extractFinalResult(Map<String, Sketch> intermediateResult) {\n+    // Compute the post aggregation expression and return the result.\n+    Sketch finalSketch = evalPostAggregationExpression(_postAggregationExpression, intermediateResult);\n+    return (int) Math.round(finalSketch.getEstimate());\n+  }\n+\n+  /**\n+   * Returns the Default result for the given expression.\n+   *\n+   * @param aggregationResultHolder Aggregation result holder\n+   * @param expressions Set of expressions that are expected in the result holder\n+   * @return Default result\n+   */\n+  private Map<String, Union> getDefaultResult(AggregationResultHolder aggregationResultHolder,\n+      Set<String> expressions) {\n+    Map<String, Union> result = aggregationResultHolder.getResult();\n+\n+    if (result == null) {\n+      result = new HashMap<>();\n+      aggregationResultHolder.setValue(result);\n+    }\n+\n+    for (String expression : expressions) {\n+      result.putIfAbsent(expression, getSetOperationBuilder().buildUnion());\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the Default result for the given group key if exists, or creates a new one.\n+   *\n+   * @param groupByResultHolder Result holder\n+   * @param groupKey Group key for which to return the default result\n+   * @param expressions Set of expressions that are expected in the result holder\n+   *\n+   * @return Default result for the group-key\n+   */\n+  private Map<String, Union> getDefaultResult(GroupByResultHolder groupByResultHolder, int groupKey,\n+      Set<String> expressions) {\n+    Map<String, Union> result = groupByResultHolder.getResult(groupKey);\n+\n+    if (result == null) {\n+      result = new HashMap<>();\n+      groupByResultHolder.setValueForKey(groupKey, result);\n+    }\n+\n+    for (String expression : expressions) {\n+      result.putIfAbsent(expression, getSetOperationBuilder().buildUnion());\n+    }\n+    return result;\n+  }\n+\n+  private Sketch[] deserializeSketches(byte[][] serializedSketches, int length) {\n+    Sketch[] sketches = new Sketch[length];\n+    for (int i = 0; i < length; i++) {\n+      sketches[i] = Sketch.wrap(Memory.wrap(serializedSketches[i]));\n+    }\n+    return sketches;\n+  }\n+\n+  private void init(List<String> arguments)\n+      throws SqlParseException {\n+\n+    // Predicate Strings are optional. When not specified, they are derived from postAggregationExpression\n+    boolean predicatesSpecified = arguments.size() > 3;\n+\n+    // Initialize the Theta-Sketch Column.\n+    _thetaSketchColumn = arguments.get(0);\n+\n+    // Initialize input expressions. It is expected they are covered between the theta-sketch column and the predicates.\n+    _inputExpressions = new ArrayList<>();\n+    _inputExpressions.add(TransformExpressionTree.compileToExpressionTree(_thetaSketchColumn));\n+\n+    // Initialize thetaSketchParams\n+    String paramsString = arguments.get(1);\n+    _thetaSketchParams = ThetaSketchParams.fromString(paramsString);\n+\n+    String postAggrExpressionString = arguments.get(arguments.size() - 1);\n+    _postAggregationExpression = CalciteSqlParser.compileToExpression(postAggrExpressionString);\n+\n+    _predicateInfoSet = new LinkedHashSet<>();\n+    _predicateStrings = new LinkedHashSet<>(arguments.subList(2, arguments.size() - 1));\n+    _expressionMap = new HashMap<>();\n+\n+    if (predicatesSpecified) {\n+      for (String predicateString : _predicateStrings) {\n+        Expression expression = CalciteSqlParser.compileToExpression(predicateString);\n+\n+        // TODO: Add support for complex predicates with AND/OR.\n+        String filterColumn = ParserUtils.getFilterColumn(expression);\n+        Predicate predicate = Predicate.newPredicate(ParserUtils.getFilterType(expression), filterColumn, ParserUtils.getFilterValues(expression));\n+\n+        _predicateInfoSet.add(new PredicateInfo(predicateString, filterColumn, predicate));\n+        _expressionMap.put(expression, predicateString);\n+        _inputExpressions.add(new TransformExpressionTree(new IdentifierAstNode(filterColumn)));\n+      }\n+    } else {\n+      // Auto-derive predicates from postAggregationExpression.\n+      Set<Expression> predicateExpressions = extractPredicatesFromString(postAggrExpressionString);\n+      for (Expression predicateExpression : predicateExpressions) {\n+        String filterColumn = ParserUtils.getFilterColumn(predicateExpression);\n+        Predicate predicate = Predicate\n+            .newPredicate(ParserUtils.getFilterType(predicateExpression), filterColumn, ParserUtils.getFilterValues(predicateExpression));\n+\n+        String predicateString = ParserUtils.standardizeExpression(predicateExpression, false);\n+        _predicateStrings.add(predicateString);\n+        _predicateInfoSet.add(new PredicateInfo(predicateString, filterColumn, predicate));\n+        _expressionMap.put(predicateExpression, predicateString);\n+        _inputExpressions.add(new TransformExpressionTree(new IdentifierAstNode(filterColumn)));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Given a post aggregation String of form like ((p1 and p2) or (p3 and p4)), returns the individual\n+   * predicates p1, p2, p3, p4.\n+   *\n+   * @param postAggrExpressionString Post aggregation expression String input\n+   * @return Set of predicates that compose the input expression\n+   * @throws SqlParseException If invalid expression String specified\n+   */\n+  private Set<Expression> extractPredicatesFromString(String postAggrExpressionString)\n+      throws SqlParseException {\n+    Set<Expression> predicates = new LinkedHashSet<>();\n+    _postAggregationExpression = CalciteSqlParser.compileToExpression(postAggrExpressionString);\n+    extractPredicatesFromExpression(_postAggregationExpression, predicates);\n+    return predicates;\n+  }\n+\n+  private void extractPredicatesFromExpression(Expression expression, Set<Expression> predicates) {\n+    ExpressionType type = expression.getType();\n+\n+    if (type.equals(ExpressionType.FUNCTION)) {\n+      Function function = expression.getFunctionCall();\n+      FilterKind filterKind = FilterKind.valueOf(function.getOperator());\n+\n+      List<Expression> operands = function.getOperands();\n+      if (filterKind.equals(FilterKind.AND) || filterKind.equals(FilterKind.OR)) {\n+        for (Expression operand : operands) {\n+          extractPredicatesFromExpression(operand, predicates);\n+        }\n+      } else {\n+        predicates.add(expression);\n+      }\n+    } // else do nothing\n+  }\n+\n+  /**\n+   * Evaluates the theta-sketch post-aggregation expression, which is composed by performing AND/OR on top of\n+   * pre-defined predicates. These predicates are evaluated during the aggregation phase, and the cached\n+   * result is passed to this method to be used when evaluating the expression.\n+   *\n+   * @param expression Expression to evaluate, this is built by applying AND/OR on precomputed sketches\n+   * @param intermediateResult Precomputed sketches for predicates that are part of the expression.\n+   * @return Overall evaluated sketch for the expression.\n+   */\n+  private Sketch evalPostAggregationExpression(Expression expression, Map<String, Sketch> intermediateResult) {\n+    Function functionCall = expression.getFunctionCall();\n+    FilterKind kind = FilterKind.valueOf(functionCall.getOperator());\n+    Sketch result;\n+\n+    switch (kind) {\n+      case AND:\n+        Intersection intersection = getSetOperationBuilder().buildIntersection();\n+        for (Expression operand : functionCall.getOperands()) {\n+          intersection.update(evalPostAggregationExpression(operand, intermediateResult));\n+        }\n+        result = intersection.getResult();\n+        break;\n+\n+      case OR:\n+        Union union = getSetOperationBuilder().buildUnion();\n+        for (Expression operand : functionCall.getOperands()) {\n+          union.update(evalPostAggregationExpression(operand, intermediateResult));\n+        }\n+        result = union.getResult();\n+        break;\n+\n+      default:\n+        String predicate = _expressionMap.get(expression);\n+        result = intermediateResult.get(predicate);\n+        Preconditions.checkState(result != null, \"Precomputed sketch for predicate not provided: \" + predicate);\n+        break;\n+    }\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the theta-sketch SetOperation builder properly configured.\n+   * Currently, only setting of nominalEntries is supported.\n+   * @return SetOperationBuilder\n+   */\n+  private SetOperationBuilder getSetOperationBuilder() {\n+    return (_thetaSketchParams == null) ? SetOperation.builder()\n+        : SetOperation.builder().setNominalEntries(_thetaSketchParams.getNominalEntries());\n+  }\n+\n+  /**\n+   * Helper class to store predicate related information:\n+   * <ul>\n+   *   <li> String representation of the predicate. </li>\n+   *   <li> LHS column of the predicate. </li>\n+   *   <li> Complied {@link Predicate}. </li>\n+   *   <li> Predicate Evaluator. </li>\n+   * </ul>\n+   *\n+   */\n+  private static class PredicateInfo {\n+\n+    private final String _stringVal;\n+    private final String _column; // LHS\n+    private final Predicate _predicate;\n+    private PredicateEvaluator _predicateEvaluator;\n+\n+    private PredicateInfo(String stringVal, String column, Predicate predicate) {\n+      _stringVal = stringVal;\n+      _column = column;\n+      _predicate = predicate;\n+      _predicateEvaluator = null; // Initialized lazily\n+    }\n+\n+    public String getStringVal() {\n+      return _stringVal;\n+    }\n+\n+    public String getColumn() {\n+      return _column;\n+    }\n+\n+    public Predicate getPredicate() {\n+      return _predicate;\n+    }\n+\n+    /**\n+     * Since PredicateEvaluator requires data-type, it is initialized lazily.\n+     *\n+     * @param dataType Data type for RHS of the predicate\n+     * @return Predicate Evaluator\n+     */\n+    public PredicateEvaluator getPredicateEvaluator(FieldSpec.DataType dataType) {\n+      if (_predicateEvaluator != null) {\n+        return _predicateEvaluator;\n+      }\n+\n+      // Theta-sketches work on long and double.\n+      if (dataType == FieldSpec.DataType.INT) {\n+        dataType = FieldSpec.DataType.LONG;\n+      } else if (dataType == FieldSpec.DataType.FLOAT) {\n+        dataType = FieldSpec.DataType.DOUBLE;\n+      }\n+\n+      _predicateEvaluator = PredicateEvaluatorProvider.getPredicateEvaluator(_predicate, null, dataType);\n+      return _predicateEvaluator;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {", "originalCommit": "1b79ea990649b860355198cc26977f7607236dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2MTg0Ng==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423361846", "bodyText": "Yeah, the lazily setting was a change made later on. Good catch.", "author": "mayankshriv", "createdAt": "2020-05-11T22:43:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzODkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0MjUzMA==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423342530", "bodyText": "Cache arguments.size()", "author": "Jackie-Jiang", "createdAt": "2020-05-11T21:54:44Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.calcite.sql.parser.SqlParseException;\n+import org.apache.datasketches.memory.Memory;\n+import org.apache.datasketches.theta.Intersection;\n+import org.apache.datasketches.theta.SetOperation;\n+import org.apache.datasketches.theta.SetOperationBuilder;\n+import org.apache.datasketches.theta.Sketch;\n+import org.apache.datasketches.theta.Union;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.request.Expression;\n+import org.apache.pinot.common.request.ExpressionType;\n+import org.apache.pinot.common.request.Function;\n+import org.apache.pinot.common.request.transform.TransformExpressionTree;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.common.Predicate;\n+import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluator;\n+import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluatorProvider;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ThetaSketchParams;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.parsers.utils.ParserUtils;\n+import org.apache.pinot.pql.parsers.pql2.ast.FilterKind;\n+import org.apache.pinot.pql.parsers.pql2.ast.IdentifierAstNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.sql.parsers.CalciteSqlParser;\n+\n+\n+/**\n+ * Implementation of {@link AggregationFunction} to perform the distinct count aggregation using\n+ * Theta Sketches.\n+ */\n+@SuppressWarnings(\"Duplicates\")\n+public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Integer> {\n+\n+  private String _thetaSketchColumn;\n+  private Set<String> _predicateStrings;\n+  private Expression _postAggregationExpression;\n+  private Set<PredicateInfo> _predicateInfoSet;\n+  private Map<Expression, String> _expressionMap;\n+  private ThetaSketchParams _thetaSketchParams;\n+  private List<TransformExpressionTree> _inputExpressions;\n+\n+  /**\n+   * Constructor for the class.\n+   * @param arguments List of parameters as arguments strings. At least three arguments are expected:\n+   *                    <ul>\n+   *                    <li> Required: First expression is interpreted as theta sketch column to aggregate on. </li>\n+   *                    <li> Required: Second argument is the thetaSketchParams. </li>\n+   *                    <li> Optional: Second to penultimate are predicates with LHS and RHS. </li>\n+   *                    <li> Required: Last expression is the one that will be evaluated to compute final result. </li>\n+   *                    </ul>\n+   */\n+  public DistinctCountThetaSketchAggregationFunction(List<String> arguments)\n+      throws SqlParseException {\n+    int numExpressions = arguments.size();\n+\n+    // This function expects at least 3 arguments: Theta Sketch Column, Predicates & final aggregation expression.\n+    Preconditions.checkArgument(numExpressions >= 3, \"DistinctCountThetaSketch expects at least three arguments, got: \",\n+        numExpressions);\n+\n+    // Initialize all the internal state.\n+    init(arguments);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.DISTINCTCOUNTTHETASKETCH;\n+  }\n+\n+  @Override\n+  public String getColumnName() {\n+    return AggregationFunctionType.DISTINCTCOUNTTHETASKETCH.getName() + \"_\" + _thetaSketchColumn;\n+  }\n+\n+  @Override\n+  public String getResultColumnName() {\n+    return AggregationFunctionType.DISTINCTCOUNTTHETASKETCH.getName().toLowerCase() + \"(\" + _thetaSketchColumn + \")\";\n+  }\n+\n+  @Override\n+  public List<TransformExpressionTree> getInputExpressions() {\n+    return _inputExpressions;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<String, BlockValSet> blockValSetMap) {\n+\n+    Map<String, Union> result = getDefaultResult(aggregationResultHolder, _predicateStrings);\n+    Sketch[] sketches = deserializeSketches(blockValSetMap.get(_thetaSketchColumn).getBytesValuesSV(), length);\n+\n+    for (PredicateInfo predicateInfo : _predicateInfoSet) {\n+      String predicate = predicateInfo.getStringVal();\n+\n+      BlockValSet blockValSet = blockValSetMap.get(predicateInfo.getColumn());\n+      FieldSpec.DataType valueType = blockValSet.getValueType();\n+      PredicateEvaluator predicateEvaluator = predicateInfo.getPredicateEvaluator(valueType);\n+\n+      Union union = result.get(predicate);\n+      switch (valueType) {\n+        case INT:\n+        case LONG:\n+          long[] longValues = blockValSet.getLongValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(longValues[i])) {\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case FLOAT:\n+        case DOUBLE:\n+          double[] doubleValues = blockValSet.getDoubleValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(doubleValues[i])) {\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case STRING:\n+          String[] stringValues = blockValSet.getStringValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(stringValues[i])) {\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        default: // Predicates on BYTES is not allowed.\n+          throw new IllegalStateException(\"Illegal data type for \" + getType() + \" aggregation function: \" + valueType);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<String, BlockValSet> blockValSetMap) {\n+    Sketch[] sketches = deserializeSketches(blockValSetMap.get(_thetaSketchColumn).getBytesValuesSV(), length);\n+\n+    for (PredicateInfo predicateInfo : _predicateInfoSet) {\n+      String predicate = predicateInfo.getStringVal();\n+\n+      BlockValSet blockValSet = blockValSetMap.get(predicateInfo.getColumn());\n+      FieldSpec.DataType valueType = blockValSet.getValueType();\n+      PredicateEvaluator predicateEvaluator = predicateInfo.getPredicateEvaluator(valueType);\n+\n+      Map<String, Union> result;\n+      switch (valueType) {\n+        case INT:\n+        case LONG:\n+          long[] longValues = blockValSet.getLongValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(longValues[i])) {\n+              result = getDefaultResult(groupByResultHolder, groupKeyArray[i], _predicateStrings);\n+              Union union = result.get(predicate);\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case FLOAT:\n+        case DOUBLE:\n+          double[] doubleValues = blockValSet.getDoubleValuesSV();\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(doubleValues[i])) {\n+              result = getDefaultResult(groupByResultHolder, groupKeyArray[i], _predicateStrings);\n+              Union union = result.get(predicate);\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        case STRING:\n+          String[] stringValues = blockValSet.getStringValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(stringValues[i])) {\n+              result = getDefaultResult(groupByResultHolder, groupKeyArray[i], _predicateStrings);\n+              Union union = result.get(predicate);\n+              union.update(sketches[i]);\n+            }\n+          }\n+          break;\n+\n+        default: // Predicates on BYTES is not allowed.\n+          throw new IllegalStateException(\"Illegal data type for \" + getType() + \" aggregation function: \" + valueType);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<String, BlockValSet> blockValSetMap) {\n+    Sketch[] sketches = deserializeSketches(blockValSetMap.get(_thetaSketchColumn).getBytesValuesSV(), length);\n+\n+    for (PredicateInfo predicateInfo : _predicateInfoSet) {\n+      String predicate = predicateInfo.getStringVal();\n+\n+      BlockValSet blockValSet = blockValSetMap.get(predicateInfo.getColumn());\n+      FieldSpec.DataType valueType = blockValSet.getValueType();\n+      PredicateEvaluator predicateEvaluator = predicateInfo.getPredicateEvaluator(valueType);\n+\n+      Map<String, Union> result;\n+      switch (valueType) {\n+        case INT:\n+        case LONG:\n+          long[] longValues = blockValSet.getLongValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(longValues[i])) {\n+\n+              for (int groupKey : groupKeysArray[i]) {\n+                result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+                Union union = result.get(predicate);\n+                union.update(sketches[i]);\n+              }\n+            }\n+          }\n+          break;\n+\n+        case FLOAT:\n+        case DOUBLE:\n+          double[] doubleValues = blockValSet.getDoubleValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(doubleValues[i])) {\n+\n+              for (int groupKey : groupKeysArray[i]) {\n+                result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+                Union union = result.get(predicate);\n+                union.update(sketches[i]);\n+              }\n+            }\n+          }\n+          break;\n+\n+        case STRING:\n+          String[] stringValues = blockValSet.getStringValuesSV();\n+\n+          for (int i = 0; i < length; i++) {\n+            if (predicateEvaluator.applySV(stringValues[i])) {\n+\n+              for (int groupKey : groupKeysArray[i]) {\n+                result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+                Union union = result.get(predicate);\n+                union.update(sketches[i]);\n+              }\n+            }\n+          }\n+          break;\n+\n+        default: // Predicates on BYTES is not allowed.\n+          throw new IllegalStateException(\"Illegal data type for \" + getType() + \" aggregation function: \" + valueType);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Map<String, Sketch> extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    Map<String, Union> result = aggregationResultHolder.getResult();\n+    if (result == null) {\n+      result = getDefaultResult(aggregationResultHolder, _predicateStrings);\n+    }\n+\n+    return result.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().getResult()));\n+  }\n+\n+  @Override\n+  public Map<String, Sketch> extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    Map<String, Union> result = groupByResultHolder.getResult(groupKey);\n+    if (result == null) {\n+      result = getDefaultResult(groupByResultHolder, groupKey, _predicateStrings);\n+    }\n+\n+    return result.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().getResult()));\n+  }\n+\n+  @Override\n+  public Map<String, Sketch> merge(Map<String, Sketch> intermediateResult1, Map<String, Sketch> intermediateResult2) {\n+    if (intermediateResult1 == null) {\n+      return intermediateResult2;\n+    } else if (intermediateResult2 == null) {\n+      return intermediateResult1;\n+    }\n+\n+    for (Map.Entry<String, Sketch> entry : intermediateResult1.entrySet()) {\n+      String predicate = entry.getKey();\n+      Union union = getSetOperationBuilder().buildUnion();\n+      union.update(entry.getValue());\n+      union.update(intermediateResult2.get(predicate));\n+      intermediateResult1.put(predicate, union.getResult());\n+    }\n+    return intermediateResult1;\n+  }\n+\n+  @Override\n+  public boolean isIntermediateResultComparable() {\n+    return false;\n+  }\n+\n+  @Override\n+  public DataSchema.ColumnDataType getIntermediateResultColumnType() {\n+    return DataSchema.ColumnDataType.OBJECT;\n+  }\n+\n+  @Override\n+  public DataSchema.ColumnDataType getFinalResultColumnType() {\n+    return DataSchema.ColumnDataType.INT;\n+  }\n+\n+  @Override\n+  public Integer extractFinalResult(Map<String, Sketch> intermediateResult) {\n+    // Compute the post aggregation expression and return the result.\n+    Sketch finalSketch = evalPostAggregationExpression(_postAggregationExpression, intermediateResult);\n+    return (int) Math.round(finalSketch.getEstimate());\n+  }\n+\n+  /**\n+   * Returns the Default result for the given expression.\n+   *\n+   * @param aggregationResultHolder Aggregation result holder\n+   * @param expressions Set of expressions that are expected in the result holder\n+   * @return Default result\n+   */\n+  private Map<String, Union> getDefaultResult(AggregationResultHolder aggregationResultHolder,\n+      Set<String> expressions) {\n+    Map<String, Union> result = aggregationResultHolder.getResult();\n+\n+    if (result == null) {\n+      result = new HashMap<>();\n+      aggregationResultHolder.setValue(result);\n+    }\n+\n+    for (String expression : expressions) {\n+      result.putIfAbsent(expression, getSetOperationBuilder().buildUnion());\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the Default result for the given group key if exists, or creates a new one.\n+   *\n+   * @param groupByResultHolder Result holder\n+   * @param groupKey Group key for which to return the default result\n+   * @param expressions Set of expressions that are expected in the result holder\n+   *\n+   * @return Default result for the group-key\n+   */\n+  private Map<String, Union> getDefaultResult(GroupByResultHolder groupByResultHolder, int groupKey,\n+      Set<String> expressions) {\n+    Map<String, Union> result = groupByResultHolder.getResult(groupKey);\n+\n+    if (result == null) {\n+      result = new HashMap<>();\n+      groupByResultHolder.setValueForKey(groupKey, result);\n+    }\n+\n+    for (String expression : expressions) {\n+      result.putIfAbsent(expression, getSetOperationBuilder().buildUnion());\n+    }\n+    return result;\n+  }\n+\n+  private Sketch[] deserializeSketches(byte[][] serializedSketches, int length) {\n+    Sketch[] sketches = new Sketch[length];\n+    for (int i = 0; i < length; i++) {\n+      sketches[i] = Sketch.wrap(Memory.wrap(serializedSketches[i]));\n+    }\n+    return sketches;\n+  }\n+\n+  private void init(List<String> arguments)\n+      throws SqlParseException {\n+\n+    // Predicate Strings are optional. When not specified, they are derived from postAggregationExpression\n+    boolean predicatesSpecified = arguments.size() > 3;", "originalCommit": "1b79ea990649b860355198cc26977f7607236dd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0MzE2MQ==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423343161", "bodyText": "Third?\nAlso, is this optional?", "author": "Jackie-Jiang", "createdAt": "2020-05-11T21:56:24Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.calcite.sql.parser.SqlParseException;\n+import org.apache.datasketches.memory.Memory;\n+import org.apache.datasketches.theta.Intersection;\n+import org.apache.datasketches.theta.SetOperation;\n+import org.apache.datasketches.theta.SetOperationBuilder;\n+import org.apache.datasketches.theta.Sketch;\n+import org.apache.datasketches.theta.Union;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.request.Expression;\n+import org.apache.pinot.common.request.ExpressionType;\n+import org.apache.pinot.common.request.Function;\n+import org.apache.pinot.common.request.transform.TransformExpressionTree;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.common.Predicate;\n+import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluator;\n+import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluatorProvider;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ThetaSketchParams;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.parsers.utils.ParserUtils;\n+import org.apache.pinot.pql.parsers.pql2.ast.FilterKind;\n+import org.apache.pinot.pql.parsers.pql2.ast.IdentifierAstNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.sql.parsers.CalciteSqlParser;\n+\n+\n+/**\n+ * Implementation of {@link AggregationFunction} to perform the distinct count aggregation using\n+ * Theta Sketches.\n+ */\n+@SuppressWarnings(\"Duplicates\")\n+public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Integer> {\n+\n+  private String _thetaSketchColumn;\n+  private Set<String> _predicateStrings;\n+  private Expression _postAggregationExpression;\n+  private Set<PredicateInfo> _predicateInfoSet;\n+  private Map<Expression, String> _expressionMap;\n+  private ThetaSketchParams _thetaSketchParams;\n+  private List<TransformExpressionTree> _inputExpressions;\n+\n+  /**\n+   * Constructor for the class.\n+   * @param arguments List of parameters as arguments strings. At least three arguments are expected:\n+   *                    <ul>\n+   *                    <li> Required: First expression is interpreted as theta sketch column to aggregate on. </li>\n+   *                    <li> Required: Second argument is the thetaSketchParams. </li>\n+   *                    <li> Optional: Second to penultimate are predicates with LHS and RHS. </li>", "originalCommit": "1b79ea990649b860355198cc26977f7607236dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2MjQ1Ng==", "url": "https://github.com/apache/pinot/pull/5316#discussion_r423362456", "bodyText": "yes, I had updated the PR to make individual predicates optional.", "author": "mayankshriv", "createdAt": "2020-05-11T22:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0MzE2MQ=="}], "type": "inlineReview"}, {"oid": "e85b31c74086d6435bc7141c6447d6ba18517d66", "url": "https://github.com/apache/pinot/commit/e85b31c74086d6435bc7141c6447d6ba18517d66", "message": "Initial implementation for support Theta Sketches (WIP).\n\n1. Added an initial implementation for theta-sketch based distinct count\n   aggregation function, which can be invoked as follows:\n   `select distinctCountThetaSketch(thetaSketchColumn, thetaSketchParams, p1, p2..pn, postAggrExpression)`\n    - Required: thetaSketchColumn is the column of type BYTES that stores serialized theta sketches.\n    - Required: thetaSketchParams in the form \"param1=v1;param2=v2..\", pass empty literal '' if no params.\n    - Optional: p1, p2 etc are filter predicates that make up the postAggregationExpression\n    - Required: postAggrExpression is the expression built with AND/OR on predicates p1..pn.\n    Example:\n    `select distinctCountThetaSketch(tsCol, \"nominalEntries=1024\", \"dim1='foo', dim2='bar', \"dim1 = 'foo and dim2='bar') from table where dim1 = 'foo' or dim2 = 'bar'`\n\n2. The aggregation function works as follows:\n   - The postAggrExpression is basically an expression that AND/OR's some predicates,\n     these predicates are expected to be specified as part of aggregation function.\n   - The aggregation goes over all values in the blockValSet and applies each predicate\n     on the values. If the predicate is satisfied, the theta-sketch is aggregated and stored\n     as value in a map, where the key is the predicate.\n   - Once all theta-sketches corresponding to all predicates are evaluated, across all segments\n     and servers, the final result is computed by evaluating the postAggrFunction, by performing\n     set operations on predicate theta-sketches (AND = intersection, OR = union).\n\n3. The Theta-Sketch library being used is from org.apache.datasketches.\n\n4. Now that more than one aggregation functions take multiple arguments, generalized handling of\n   multiple args, and removed special casing of Distinct.\n\n5. Refactored methods from PinotQuery2BrokerRequestConverter to reusable utility class ParserUtils.\n\n6. Added unit tests for new code.\n\nTODO:\n1. Performance tuning to ensure the aggregation function works at par.\n2. Support complex predicates p1, p2, p3, current PR only supports predicates of form like `LHS = RHS`, `LHS IN (...)`, etc.\n2. Evaluate theta-sketch creation params, and pick default or come up with ways\n   to configure (by user).\n3. MultiValue aggregation support.\n4. Auto derive predicates that make up postAggrExpression, so they don't need to be specified\n   in the aggregation function.\n5. Auto sharding of Sketches with high cardinality into smaller ones to improve accuracy.\n6. Pql2Compiler.compileToExpressionTree does not seem to handle parenthesized expressions,\n   e.g., ((col1 = 1 and col2 = 2) or col3 = 3).", "committedDate": "2020-05-11T22:52:11Z", "type": "forcePushed"}, {"oid": "ec51ad78d65b0a7668a39a89f6bdfd2d2410c8c2", "url": "https://github.com/apache/pinot/commit/ec51ad78d65b0a7668a39a89f6bdfd2d2410c8c2", "message": "Initial implementation for support Theta Sketches (WIP).\n\n1. Added an initial implementation for theta-sketch based distinct count\n   aggregation function, which can be invoked as follows:\n   `select distinctCountThetaSketch(thetaSketchColumn, thetaSketchParams, p1, p2..pn, postAggrExpression)`\n    - Required: thetaSketchColumn is the column of type BYTES that stores serialized theta sketches.\n    - Required: thetaSketchParams in the form \"param1=v1;param2=v2..\", pass empty literal '' if no params.\n    - Optional: p1, p2 etc are filter predicates that make up the postAggregationExpression\n    - Required: postAggrExpression is the expression built with AND/OR on predicates p1..pn.\n    Example:\n    `select distinctCountThetaSketch(tsCol, \"nominalEntries=1024\", \"dim1='foo', dim2='bar', \"dim1 = 'foo and dim2='bar') from table where dim1 = 'foo' or dim2 = 'bar'`\n\n2. The aggregation function works as follows:\n   - The postAggrExpression is basically an expression that AND/OR's some predicates,\n     these predicates are expected to be specified as part of aggregation function.\n   - The aggregation goes over all values in the blockValSet and applies each predicate\n     on the values. If the predicate is satisfied, the theta-sketch is aggregated and stored\n     as value in a map, where the key is the predicate.\n   - Once all theta-sketches corresponding to all predicates are evaluated, across all segments\n     and servers, the final result is computed by evaluating the postAggrFunction, by performing\n     set operations on predicate theta-sketches (AND = intersection, OR = union).\n\n3. The Theta-Sketch library being used is from org.apache.datasketches.\n\n4. Now that more than one aggregation functions take multiple arguments, generalized handling of\n   multiple args, and removed special casing of Distinct.\n\n5. Refactored methods from PinotQuery2BrokerRequestConverter to reusable utility class ParserUtils.\n\n6. Added unit tests for new code.\n\nTODO:\n1. Performance tuning to ensure the aggregation function works at par.\n2. Support complex predicates p1, p2, p3, current PR only supports predicates of form like `LHS = RHS`, `LHS IN (...)`, etc.\n2. Evaluate theta-sketch creation params, and pick default or come up with ways\n   to configure (by user).\n3. MultiValue aggregation support.\n4. Auto derive predicates that make up postAggrExpression, so they don't need to be specified\n   in the aggregation function.\n5. Auto sharding of Sketches with high cardinality into smaller ones to improve accuracy.\n6. Pql2Compiler.compileToExpressionTree does not seem to handle parenthesized expressions,\n   e.g., ((col1 = 1 and col2 = 2) or col3 = 3).", "committedDate": "2020-05-12T00:12:56Z", "type": "forcePushed"}, {"oid": "1587d88fd1f2590b0774bfef0b44259109837b29", "url": "https://github.com/apache/pinot/commit/1587d88fd1f2590b0774bfef0b44259109837b29", "message": "Initial implementation for support Theta Sketches (WIP).\n\n1. Added an initial implementation for theta-sketch based distinct count\n   aggregation function, which can be invoked as follows:\n   `select distinctCountThetaSketch(thetaSketchColumn, thetaSketchParams, p1, p2..pn, postAggrExpression)`\n    - Required: thetaSketchColumn is the column of type BYTES that stores serialized theta sketches.\n    - Required: thetaSketchParams in the form \"param1=v1;param2=v2..\", pass empty literal '' if no params.\n    - Optional: p1, p2 etc are filter predicates that make up the postAggregationExpression\n    - Required: postAggrExpression is the expression built with AND/OR on predicates p1..pn.\n    Example:\n    `select distinctCountThetaSketch(tsCol, \"nominalEntries=1024\", \"dim1='foo', dim2='bar', \"dim1 = 'foo and dim2='bar') from table where dim1 = 'foo' or dim2 = 'bar'`\n\n2. The aggregation function works as follows:\n   - The postAggrExpression is basically an expression that AND/OR's some predicates,\n     these predicates are expected to be specified as part of aggregation function.\n   - The aggregation goes over all values in the blockValSet and applies each predicate\n     on the values. If the predicate is satisfied, the theta-sketch is aggregated and stored\n     as value in a map, where the key is the predicate.\n   - Once all theta-sketches corresponding to all predicates are evaluated, across all segments\n     and servers, the final result is computed by evaluating the postAggrFunction, by performing\n     set operations on predicate theta-sketches (AND = intersection, OR = union).\n\n3. The Theta-Sketch library being used is from org.apache.datasketches.\n\n4. Now that more than one aggregation functions take multiple arguments, generalized handling of\n   multiple args, and removed special casing of Distinct.\n\n5. Refactored methods from PinotQuery2BrokerRequestConverter to reusable utility class ParserUtils.\n\n6. Added unit tests for new code.\n\nTODO:\n1. Performance tuning to ensure the aggregation function works at par.\n2. Support complex predicates p1, p2, p3, current PR only supports predicates of form like `LHS = RHS`, `LHS IN (...)`, etc.\n2. Evaluate theta-sketch creation params, and pick default or come up with ways\n   to configure (by user).\n3. MultiValue aggregation support.\n4. Auto derive predicates that make up postAggrExpression, so they don't need to be specified\n   in the aggregation function.\n5. Auto sharding of Sketches with high cardinality into smaller ones to improve accuracy.\n6. Pql2Compiler.compileToExpressionTree does not seem to handle parenthesized expressions,\n   e.g., ((col1 = 1 and col2 = 2) or col3 = 3).", "committedDate": "2020-05-12T01:04:22Z", "type": "commit"}, {"oid": "1587d88fd1f2590b0774bfef0b44259109837b29", "url": "https://github.com/apache/pinot/commit/1587d88fd1f2590b0774bfef0b44259109837b29", "message": "Initial implementation for support Theta Sketches (WIP).\n\n1. Added an initial implementation for theta-sketch based distinct count\n   aggregation function, which can be invoked as follows:\n   `select distinctCountThetaSketch(thetaSketchColumn, thetaSketchParams, p1, p2..pn, postAggrExpression)`\n    - Required: thetaSketchColumn is the column of type BYTES that stores serialized theta sketches.\n    - Required: thetaSketchParams in the form \"param1=v1;param2=v2..\", pass empty literal '' if no params.\n    - Optional: p1, p2 etc are filter predicates that make up the postAggregationExpression\n    - Required: postAggrExpression is the expression built with AND/OR on predicates p1..pn.\n    Example:\n    `select distinctCountThetaSketch(tsCol, \"nominalEntries=1024\", \"dim1='foo', dim2='bar', \"dim1 = 'foo and dim2='bar') from table where dim1 = 'foo' or dim2 = 'bar'`\n\n2. The aggregation function works as follows:\n   - The postAggrExpression is basically an expression that AND/OR's some predicates,\n     these predicates are expected to be specified as part of aggregation function.\n   - The aggregation goes over all values in the blockValSet and applies each predicate\n     on the values. If the predicate is satisfied, the theta-sketch is aggregated and stored\n     as value in a map, where the key is the predicate.\n   - Once all theta-sketches corresponding to all predicates are evaluated, across all segments\n     and servers, the final result is computed by evaluating the postAggrFunction, by performing\n     set operations on predicate theta-sketches (AND = intersection, OR = union).\n\n3. The Theta-Sketch library being used is from org.apache.datasketches.\n\n4. Now that more than one aggregation functions take multiple arguments, generalized handling of\n   multiple args, and removed special casing of Distinct.\n\n5. Refactored methods from PinotQuery2BrokerRequestConverter to reusable utility class ParserUtils.\n\n6. Added unit tests for new code.\n\nTODO:\n1. Performance tuning to ensure the aggregation function works at par.\n2. Support complex predicates p1, p2, p3, current PR only supports predicates of form like `LHS = RHS`, `LHS IN (...)`, etc.\n2. Evaluate theta-sketch creation params, and pick default or come up with ways\n   to configure (by user).\n3. MultiValue aggregation support.\n4. Auto derive predicates that make up postAggrExpression, so they don't need to be specified\n   in the aggregation function.\n5. Auto sharding of Sketches with high cardinality into smaller ones to improve accuracy.\n6. Pql2Compiler.compileToExpressionTree does not seem to handle parenthesized expressions,\n   e.g., ((col1 = 1 and col2 = 2) or col3 = 3).", "committedDate": "2020-05-12T01:04:22Z", "type": "forcePushed"}]}