{"pr_number": 5240, "pr_title": "Supporting range queries using indexes", "pr_createdAt": "2020-04-11T06:06:05Z", "pr_url": "https://github.com/apache/pinot/pull/5240", "timeline": [{"oid": "8c2874b0614da963251b9f5ba565bf49014391b9", "url": "https://github.com/apache/pinot/commit/8c2874b0614da963251b9f5ba565bf49014391b9", "message": "Adding range index support", "committedDate": "2020-04-24T00:04:15Z", "type": "commit"}, {"oid": "8c2874b0614da963251b9f5ba565bf49014391b9", "url": "https://github.com/apache/pinot/commit/8c2874b0614da963251b9f5ba565bf49014391b9", "message": "Adding range index support", "committedDate": "2020-04-24T00:04:15Z", "type": "forcePushed"}, {"oid": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "url": "https://github.com/apache/pinot/commit/af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "message": "Fixing ByteBuffer issue", "committedDate": "2020-04-24T06:15:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NTY1NA==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419565654", "bodyText": "We should not make a change to IndexingConfig. Let's start using FieldConfig.\nIndexLoadingConfig can then be derived from FieldConfig", "author": "siddharthteotia", "createdAt": "2020-05-04T16:30:37Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/config/table/IndexingConfig.java", "diffHunk": "@@ -27,6 +27,7 @@\n \n public class IndexingConfig extends BaseJsonConfig {\n   private List<String> _invertedIndexColumns;\n+  private List<String> _rangeIndexColumns;", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3MjU3MQ==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419572571", "bodyText": "Similar to how we do it for text index.", "author": "siddharthteotia", "createdAt": "2020-05-04T16:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NTY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU0NzI2Nw==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r422547267", "bodyText": "I agree. will have to do this as part of another PR.", "author": "kishoreg", "createdAt": "2020-05-09T21:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NTY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2Njg5Ng==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r423166896", "bodyText": "Let's please add a TODO", "author": "siddharthteotia", "createdAt": "2020-05-11T16:32:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NTY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NjQ5Mw==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419566493", "bodyText": "Can we add a TODO here to indicate that for now we are doing a linear scan to find the corresponding range for a given dictId. If the number of ranges is high, we may want to do binary search?", "author": "siddharthteotia", "createdAt": "2020-05-04T16:31:50Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/RangeIndexReader.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.index.readers;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import java.io.IOException;\n+import java.lang.ref.SoftReference;\n+import java.nio.ByteBuffer;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class RangeIndexReader implements InvertedIndexReader<ImmutableRoaringBitmap> {\n+  public static final Logger LOGGER = LoggerFactory.getLogger(RangeIndexReader.class);\n+\n+  private final PinotDataBuffer _buffer;\n+  private final int _version;\n+  private final FieldSpec.DataType _valueType;\n+  private final int _numRanges;\n+  final long _bitmapIndexOffset;\n+  private final Number[] _rangeStartArray;\n+\n+  private volatile SoftReference<SoftReference<ImmutableRoaringBitmap>[]> _bitmaps = null;\n+\n+  /**\n+   * Constructs an inverted index with the specified size.\n+   * @param indexDataBuffer data buffer for the inverted index.\n+   */\n+  public RangeIndexReader(PinotDataBuffer indexDataBuffer) {\n+    long offset = 0;\n+    _buffer = indexDataBuffer;\n+    //READER VERSION\n+    _version = _buffer.getInt(offset);\n+    offset += Integer.BYTES;\n+\n+    //READ THE VALUE TYPE (INT, LONG, DOUBLE, FLOAT)\n+    int valueTypeBytesLength = _buffer.getInt(offset);\n+    offset += Integer.BYTES;\n+    byte[] valueTypeBytes = new byte[valueTypeBytesLength];\n+    _buffer.copyTo(offset, valueTypeBytes);\n+    offset += valueTypeBytesLength;\n+    _valueType = FieldSpec.DataType.valueOf(new String(valueTypeBytes));\n+\n+    //READ THE NUMBER OF RANGES\n+    _numRanges = _buffer.getInt(offset);\n+    offset += Integer.BYTES;\n+    long rangeArrayStartOffset = offset;\n+\n+    _rangeStartArray = new Number[_numRanges];\n+\n+    final long firstOffset = _buffer.getLong(offset + _numRanges * _valueType.size());\n+    final long lastOffset = _buffer.getLong(offset + _numRanges * _valueType.size() + _numRanges * Long.BYTES);\n+\n+    _bitmapIndexOffset = offset + _numRanges * _valueType.size();\n+\n+    Preconditions.checkState(lastOffset == _buffer.size(),\n+        \"The last offset should be equal to buffer size! Current lastOffset: \" + lastOffset + \", buffer size: \"\n+            + _buffer.size());\n+    switch (_valueType) {\n+      case INT:\n+        for (int i = 0; i < _numRanges; i++) {\n+          _rangeStartArray[i] = _buffer.getInt(rangeArrayStartOffset + i * Integer.BYTES);\n+        }\n+        break;\n+      case LONG:\n+        for (int i = 0; i < _numRanges; i++) {\n+          _rangeStartArray[i] = _buffer.getLong(rangeArrayStartOffset + i * Long.BYTES);\n+        }\n+        break;\n+      case FLOAT:\n+        for (int i = 0; i < _numRanges; i++) {\n+          _rangeStartArray[i] = _buffer.getFloat(rangeArrayStartOffset + i * Float.BYTES);\n+        }\n+        break;\n+      case DOUBLE:\n+        for (int i = 0; i < _numRanges; i++) {\n+          _rangeStartArray[i] = _buffer.getDouble(rangeArrayStartOffset + i * Double.BYTES);\n+        }\n+        break;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public Number[] getRangeStartArray() {\n+    return _rangeStartArray;\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Override\n+  public ImmutableRoaringBitmap getDocIds(int rangeId) {\n+    SoftReference<ImmutableRoaringBitmap>[] bitmapArrayReference = null;\n+    // Return the bitmap if it's still on heap\n+    if (_bitmaps != null) {\n+      bitmapArrayReference = _bitmaps.get();\n+      if (bitmapArrayReference != null) {\n+        SoftReference<ImmutableRoaringBitmap> bitmapReference = bitmapArrayReference[rangeId];\n+        if (bitmapReference != null) {\n+          ImmutableRoaringBitmap value = bitmapReference.get();\n+          if (value != null) {\n+            return value;\n+          }\n+        }\n+      } else {\n+        bitmapArrayReference = new SoftReference[_numRanges];\n+        _bitmaps = new SoftReference<SoftReference<ImmutableRoaringBitmap>[]>(bitmapArrayReference);\n+      }\n+    } else {\n+      bitmapArrayReference = new SoftReference[_numRanges];\n+      _bitmaps = new SoftReference<SoftReference<ImmutableRoaringBitmap>[]>(bitmapArrayReference);\n+    }\n+    synchronized (this) {\n+      ImmutableRoaringBitmap value;\n+      if (bitmapArrayReference[rangeId] == null || bitmapArrayReference[rangeId].get() == null) {\n+        value = buildRoaringBitmapForIndex(rangeId);\n+        bitmapArrayReference[rangeId] = new SoftReference<ImmutableRoaringBitmap>(value);\n+      } else {\n+        value = bitmapArrayReference[rangeId].get();\n+      }\n+      return value;\n+    }\n+  }\n+\n+  @Override\n+  public ImmutableRoaringBitmap getDocIds(Object value) {\n+    // This should not be called from anywhere. If it happens, there is a bug\n+    // and that's why we throw illegal state exception\n+    throw new IllegalStateException(\"bitmap inverted index reader supports lookup only on dictionary id\");\n+  }\n+\n+  private synchronized ImmutableRoaringBitmap buildRoaringBitmapForIndex(final int rangeId) {\n+    final long currentOffset = getOffset(rangeId);\n+    final long nextOffset = getOffset(rangeId + 1);\n+    final int bufferLength = (int) (nextOffset - currentOffset);\n+\n+    // Slice the buffer appropriately for Roaring Bitmap\n+    ByteBuffer bb = _buffer.toDirectByteBuffer(currentOffset, bufferLength);\n+    return new ImmutableRoaringBitmap(bb);\n+  }\n+\n+  private long getOffset(final int rangeId) {\n+    return _buffer.getLong(_bitmapIndexOffset + rangeId * Long.BYTES);\n+  }\n+\n+  @Override\n+  public void close()\n+      throws IOException {\n+    _buffer.close();\n+  }\n+\n+  public int findRangeId(int value) {", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NjUzNw==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419566537", "bodyText": "Change the exception", "author": "siddharthteotia", "createdAt": "2020-05-04T16:31:54Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/RangeIndexReader.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.index.readers;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import java.io.IOException;\n+import java.lang.ref.SoftReference;\n+import java.nio.ByteBuffer;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class RangeIndexReader implements InvertedIndexReader<ImmutableRoaringBitmap> {\n+  public static final Logger LOGGER = LoggerFactory.getLogger(RangeIndexReader.class);\n+\n+  private final PinotDataBuffer _buffer;\n+  private final int _version;\n+  private final FieldSpec.DataType _valueType;\n+  private final int _numRanges;\n+  final long _bitmapIndexOffset;\n+  private final Number[] _rangeStartArray;\n+\n+  private volatile SoftReference<SoftReference<ImmutableRoaringBitmap>[]> _bitmaps = null;\n+\n+  /**\n+   * Constructs an inverted index with the specified size.\n+   * @param indexDataBuffer data buffer for the inverted index.\n+   */\n+  public RangeIndexReader(PinotDataBuffer indexDataBuffer) {\n+    long offset = 0;\n+    _buffer = indexDataBuffer;\n+    //READER VERSION\n+    _version = _buffer.getInt(offset);\n+    offset += Integer.BYTES;\n+\n+    //READ THE VALUE TYPE (INT, LONG, DOUBLE, FLOAT)\n+    int valueTypeBytesLength = _buffer.getInt(offset);\n+    offset += Integer.BYTES;\n+    byte[] valueTypeBytes = new byte[valueTypeBytesLength];\n+    _buffer.copyTo(offset, valueTypeBytes);\n+    offset += valueTypeBytesLength;\n+    _valueType = FieldSpec.DataType.valueOf(new String(valueTypeBytes));\n+\n+    //READ THE NUMBER OF RANGES\n+    _numRanges = _buffer.getInt(offset);\n+    offset += Integer.BYTES;\n+    long rangeArrayStartOffset = offset;\n+\n+    _rangeStartArray = new Number[_numRanges];\n+\n+    final long firstOffset = _buffer.getLong(offset + _numRanges * _valueType.size());\n+    final long lastOffset = _buffer.getLong(offset + _numRanges * _valueType.size() + _numRanges * Long.BYTES);\n+\n+    _bitmapIndexOffset = offset + _numRanges * _valueType.size();\n+\n+    Preconditions.checkState(lastOffset == _buffer.size(),\n+        \"The last offset should be equal to buffer size! Current lastOffset: \" + lastOffset + \", buffer size: \"\n+            + _buffer.size());\n+    switch (_valueType) {\n+      case INT:\n+        for (int i = 0; i < _numRanges; i++) {\n+          _rangeStartArray[i] = _buffer.getInt(rangeArrayStartOffset + i * Integer.BYTES);\n+        }\n+        break;\n+      case LONG:\n+        for (int i = 0; i < _numRanges; i++) {\n+          _rangeStartArray[i] = _buffer.getLong(rangeArrayStartOffset + i * Long.BYTES);\n+        }\n+        break;\n+      case FLOAT:\n+        for (int i = 0; i < _numRanges; i++) {\n+          _rangeStartArray[i] = _buffer.getFloat(rangeArrayStartOffset + i * Float.BYTES);\n+        }\n+        break;\n+      case DOUBLE:\n+        for (int i = 0; i < _numRanges; i++) {\n+          _rangeStartArray[i] = _buffer.getDouble(rangeArrayStartOffset + i * Double.BYTES);\n+        }\n+        break;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public Number[] getRangeStartArray() {\n+    return _rangeStartArray;\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Override\n+  public ImmutableRoaringBitmap getDocIds(int rangeId) {\n+    SoftReference<ImmutableRoaringBitmap>[] bitmapArrayReference = null;\n+    // Return the bitmap if it's still on heap\n+    if (_bitmaps != null) {\n+      bitmapArrayReference = _bitmaps.get();\n+      if (bitmapArrayReference != null) {\n+        SoftReference<ImmutableRoaringBitmap> bitmapReference = bitmapArrayReference[rangeId];\n+        if (bitmapReference != null) {\n+          ImmutableRoaringBitmap value = bitmapReference.get();\n+          if (value != null) {\n+            return value;\n+          }\n+        }\n+      } else {\n+        bitmapArrayReference = new SoftReference[_numRanges];\n+        _bitmaps = new SoftReference<SoftReference<ImmutableRoaringBitmap>[]>(bitmapArrayReference);\n+      }\n+    } else {\n+      bitmapArrayReference = new SoftReference[_numRanges];\n+      _bitmaps = new SoftReference<SoftReference<ImmutableRoaringBitmap>[]>(bitmapArrayReference);\n+    }\n+    synchronized (this) {\n+      ImmutableRoaringBitmap value;\n+      if (bitmapArrayReference[rangeId] == null || bitmapArrayReference[rangeId].get() == null) {\n+        value = buildRoaringBitmapForIndex(rangeId);\n+        bitmapArrayReference[rangeId] = new SoftReference<ImmutableRoaringBitmap>(value);\n+      } else {\n+        value = bitmapArrayReference[rangeId].get();\n+      }\n+      return value;\n+    }\n+  }\n+\n+  @Override\n+  public ImmutableRoaringBitmap getDocIds(Object value) {\n+    // This should not be called from anywhere. If it happens, there is a bug\n+    // and that's why we throw illegal state exception\n+    throw new IllegalStateException(\"bitmap inverted index reader supports lookup only on dictionary id\");", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MTg0NA==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r423171844", "bodyText": "Please change the exception", "author": "siddharthteotia", "createdAt": "2020-05-11T16:40:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NjUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NjU4NQ==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419566585", "bodyText": "Please add javadoc", "author": "siddharthteotia", "createdAt": "2020-05-04T16:32:00Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/RangeIndexReader.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.index.readers;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import java.io.IOException;\n+import java.lang.ref.SoftReference;\n+import java.nio.ByteBuffer;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class RangeIndexReader implements InvertedIndexReader<ImmutableRoaringBitmap> {", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2Njc3MQ==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419566771", "bodyText": "Please add javadoc", "author": "siddharthteotia", "createdAt": "2020-05-04T16:32:20Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/RangeIndexHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.index.loader.invertedindex;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.annotation.Nonnull;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.io.reader.DataFileReader;\n+import org.apache.pinot.core.io.reader.SingleColumnMultiValueReader;\n+import org.apache.pinot.core.io.reader.impl.v1.FixedBitMultiValueReader;\n+import org.apache.pinot.core.io.reader.impl.v1.FixedBitSingleValueReader;\n+import org.apache.pinot.core.segment.creator.impl.V1Constants;\n+import org.apache.pinot.core.segment.creator.impl.inv.RangeIndexCreator;\n+import org.apache.pinot.core.segment.index.column.PhysicalColumnIndexContainer;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.core.segment.index.loader.LoaderUtils;\n+import org.apache.pinot.core.segment.index.metadata.ColumnMetadata;\n+import org.apache.pinot.core.segment.index.metadata.SegmentMetadataImpl;\n+import org.apache.pinot.core.segment.index.readers.BaseImmutableDictionary;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.segment.store.ColumnIndexType;\n+import org.apache.pinot.core.segment.store.SegmentDirectory;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class RangeIndexHandler {", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2Njg2MA==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419566860", "bodyText": "We should use FieldConfig -- this is another index type", "author": "siddharthteotia", "createdAt": "2020-05-04T16:32:30Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/IndexLoadingConfig.java", "diffHunk": "@@ -86,6 +87,11 @@ private void extractFromTableConfig(@Nonnull TableConfig tableConfig) {\n       _invertedIndexColumns.addAll(invertedIndexColumns);\n     }\n \n+    List<String> rangeIndexColumns = indexingConfig.getRangeIndexColumns();", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NjkxMQ==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419566911", "bodyText": "This should be if not else-if", "author": "siddharthteotia", "createdAt": "2020-05-04T16:32:34Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/column/PhysicalColumnIndexContainer.java", "diffHunk": "@@ -124,14 +129,21 @@ public PhysicalColumnIndexContainer(SegmentDirectory.Reader segmentReader, Colum\n         _invertedIndex =\n             new BitmapInvertedIndexReader(segmentReader.getIndexFor(columnName, ColumnIndexType.INVERTED_INDEX),\n                 metadata.getCardinality());\n+        _rangeIndex = null;\n+      } else if (loadRangeIndex) {", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2Njk4Mw==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419566983", "bodyText": "Not sure if the if-else blocks here can be simplified", "author": "siddharthteotia", "createdAt": "2020-05-04T16:32:40Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/column/PhysicalColumnIndexContainer.java", "diffHunk": "@@ -124,14 +129,21 @@ public PhysicalColumnIndexContainer(SegmentDirectory.Reader segmentReader, Colum\n         _invertedIndex =\n             new BitmapInvertedIndexReader(segmentReader.getIndexFor(columnName, ColumnIndexType.INVERTED_INDEX),\n                 metadata.getCardinality());\n+        _rangeIndex = null;", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MDU3MQ==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r422460571", "bodyText": "I hope so but dint want to do that as part of this PR.", "author": "kishoreg", "createdAt": "2020-05-09T06:48:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2Njk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzAzNg==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419567036", "bodyText": "Using constants for << 2, << 3 would be better for readability. Something like INT_SIZE_BYTES, DOUBLE_SIZE_BYTES etc", "author": "siddharthteotia", "createdAt": "2020-05-04T16:32:44Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/RangeIndexCreator.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv;\n+\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.Arrays;\n+import it.unimi.dsi.fastutil.Swapper;\n+import it.unimi.dsi.fastutil.ints.IntComparator;\n+import java.io.BufferedOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.Constants;\n+import org.apache.pinot.core.query.utils.Pair;\n+import org.apache.pinot.core.segment.creator.InvertedIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.BITMAP_RANGE_INDEX_FILE_EXTENSION;\n+\n+\n+/**\n+ * Implementation of {@link InvertedIndexCreator} that uses off-heap memory.\n+ * <p>We use 2 passes to create the range index.\n+ * <ul>\n+ *\n+ *   <li>\n+ *     A\n+ *   </li>\n+ *   <li>\n+ *     In the first pass (adding values phase), when add() method is called, store the raw values into the forward index\n+ *     value buffer (for multi-valued column also store number of values for each docId into forward index length\n+ *     buffer). We also compute the inverted index length for each dictId while adding values.\n+ *   </li>\n+ *   <li>\n+ *     In the second pass (processing values phase), when seal() method is called, all the dictIds should already been\n+ *     added. We first reorder the values into the inverted index buffers by going over the dictIds in forward index\n+ *     value buffer (for multi-valued column we also need forward index length buffer to get the docId for each dictId).\n+ *     <p>Once we have the inverted index buffers, we simply go over them and create the bitmap for each dictId and\n+ *     serialize them into a file.\n+ *   </li>\n+ * </ul>\n+ * <p>Based on the number of values we need to store, we use direct memory or MMap file to allocate the buffer.\n+ */\n+public final class RangeIndexCreator implements InvertedIndexCreator {\n+\n+  private static final int RANGE_INDEX_VERSION = 1;\n+\n+  // Use MMapBuffer if the value buffer size is larger than 2G\n+  private static final int NUM_VALUES_THRESHOLD_FOR_MMAP_BUFFER = 500_000_000;\n+  private static final int DEFAULT_NUM_RANGES = 20;\n+\n+  private static final String FORWARD_INDEX_VALUE_BUFFER_SUFFIX = \".fwd.idx.val.buf\";\n+  private static final String DOC_ID_VALUE_BUFFER_SUFFIX = \".doc.id.val.buf\";\n+\n+  private final File _invertedIndexFile;\n+  private final File _forwardIndexValueBufferFile;\n+  private final File _docIdBufferFileForSorting;\n+  private final int _numValues;\n+  private final boolean _useMMapBuffer;\n+\n+  // Forward index buffers (from docId to dictId)\n+  private int _nextDocId;\n+  private PinotDataBuffer _forwardIndexValueBuffer;\n+  private NumberValueBuffer _valueBuffer;\n+  //for sorting\n+  private PinotDataBuffer _docIdValueBuffer;\n+  private IntValueBuffer _docIdBuffer;\n+  // For multi-valued column only because each docId can have multiple dictIds\n+  private int _nextValueId;\n+  private int _numDocsPerRange;\n+  private FieldSpec.DataType _valueType;\n+\n+  public RangeIndexCreator(File indexDir, FieldSpec fieldSpec, FieldSpec.DataType valueType, int numRanges, int numDocsPerRange, int numDocs, int numValues)\n+      throws IOException {\n+    _valueType = valueType;\n+    String columnName = fieldSpec.getName();\n+    _invertedIndexFile = new File(indexDir, columnName + BITMAP_RANGE_INDEX_FILE_EXTENSION);\n+    _forwardIndexValueBufferFile = new File(indexDir, columnName + FORWARD_INDEX_VALUE_BUFFER_SUFFIX);\n+    _docIdBufferFileForSorting = new File(indexDir, columnName + DOC_ID_VALUE_BUFFER_SUFFIX);\n+    _numValues = fieldSpec.isSingleValueField() ? numDocs : numValues;\n+    _useMMapBuffer = _numValues > NUM_VALUES_THRESHOLD_FOR_MMAP_BUFFER;\n+    int valueSize = valueType.size();\n+    try {\n+      //use DEFAULT_NUM_RANGES if numRanges is not set\n+      if(numRanges < 0) {\n+        numRanges = DEFAULT_NUM_RANGES;\n+      }\n+      if(numDocsPerRange < 0) {\n+        _numDocsPerRange = (int) Math.ceil(_numValues / numRanges);\n+      }\n+\n+      //FORWARD INDEX - stores the actual values added\n+      _forwardIndexValueBuffer = createTempBuffer((long) _numValues * valueSize, _forwardIndexValueBufferFile);\n+\n+      switch (_valueType) {\n+        case INT:\n+          _valueBuffer = new IntValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        case FLOAT:\n+          _valueBuffer = new FloatValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        case LONG:\n+          _valueBuffer = new LongValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        case DOUBLE:\n+          _valueBuffer = new DoubleValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        default:\n+          throw new UnsupportedOperationException(\"Range index is not supported for columns of data type:\" + valueType);\n+      }\n+\n+      //Stores the docId - this will be sorted based on the values in FORWARD INDEX in the end\n+      _docIdValueBuffer = createTempBuffer((long) _numValues * Integer.BYTES, _forwardIndexValueBufferFile);\n+      _docIdBuffer = new IntValueBuffer(_docIdValueBuffer);\n+    } catch (Exception e) {\n+      destroyBuffer(_forwardIndexValueBuffer, _forwardIndexValueBufferFile);\n+      destroyBuffer(_forwardIndexValueBuffer, _docIdBufferFileForSorting);\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public void add(int dictId) {\n+    _valueBuffer.put(_nextDocId, dictId);\n+    _docIdBuffer.put(_nextDocId, _nextDocId);\n+    _nextDocId = _nextDocId + 1;\n+  }\n+\n+  @Override\n+  public void add(int[] dictIds, int length) {\n+    for (int i = 0; i < length; i++) {\n+      int dictId = dictIds[i];\n+      _valueBuffer.put(_nextDocId, dictId);\n+      _docIdBuffer.put(_nextValueId, _nextDocId);\n+      _nextValueId = _nextValueId + 1;\n+    }\n+  }\n+\n+  @Override\n+  public void addDoc(Object document, int docIdCounter) {\n+    throw new IllegalStateException(\"Bitmap inverted index creator does not support Object type currently\");\n+  }\n+\n+  @Override\n+  public void seal()\n+      throws IOException {\n+    //sort the forward index copy\n+    //go over the sorted value to compute ranges\n+    IntComparator comparator = (i, j) -> {\n+      Number val1 = _valueBuffer.get(_docIdBuffer.get(i).intValue());\n+      Number val2 = _valueBuffer.get(_docIdBuffer.get(j).intValue());\n+      return _valueBuffer.compare(val1, val2);\n+    };\n+    Swapper swapper = (i, j) -> {\n+      Number temp = _docIdBuffer.get(i).intValue();\n+      _docIdBuffer.put(i, _docIdBuffer.get(j).intValue());\n+      _docIdBuffer.put(j, temp);\n+    };\n+    Arrays.quickSort(0, _numValues, comparator, swapper);\n+\n+//    dump();\n+    //FIND THE RANGES\n+    List<Pair<Integer, Integer>> ranges = new ArrayList<>();\n+\n+    int boundary = _numDocsPerRange;\n+    int start = 0;\n+    for (int i = 0; i < _numValues; i++) {\n+      if (i > start + boundary) {\n+        if (comparator.compare(i, i - 1) != 0) {\n+          ranges.add(new Pair(start, i - 1));\n+          start = i;\n+        }\n+      }\n+    }\n+    ranges.add(new Pair(start, _numValues - 1));\n+\n+    // Create bitmaps from inverted index buffers and serialize them to file\n+    //HEADER\n+    //   # VERSION (INT)\n+    //   # DATA_TYPE (String -> INT (length) (ACTUAL BYTES)\n+    //   # OF RANGES (INT)\n+    //   <RANGE START VALUE BUFFER> #R & ValueSize\n+    //   Range Start 0\n+    //    .........\n+    //   Range Start R - 1\n+    //   Bitmap for Range 0 Start Offset\n+    //      .....\n+    //   Bitmap for Range R Start Offset\n+    //BODY\n+    //   Bitmap for range 0\n+    //   Bitmap for range 2\n+    //    ......\n+    //   Bitmap for range R - 1\n+    long bytesWritten = 0;\n+    try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(_invertedIndexFile));\n+        DataOutputStream header = new DataOutputStream(bos);\n+        FileOutputStream fos = new FileOutputStream(_invertedIndexFile);\n+        DataOutputStream dataOutputStream = new DataOutputStream(new BufferedOutputStream(fos))) {\n+\n+      //VERSION\n+      header.writeInt(RANGE_INDEX_VERSION);\n+\n+      bytesWritten += Integer.BYTES;\n+\n+      //value data type\n+      byte[] valueDataTypeBytes = _valueType.name().getBytes(UTF_8);\n+      header.writeInt(valueDataTypeBytes.length);\n+      bytesWritten += Integer.BYTES;\n+\n+      header.write(valueDataTypeBytes);\n+      bytesWritten += valueDataTypeBytes.length;\n+\n+      //Write the Range values\n+      header.writeInt(ranges.size());\n+      bytesWritten += Integer.BYTES;\n+\n+      for (Pair<Integer, Integer> range : ranges) {\n+        Number value = _valueBuffer.get(_docIdBuffer.get(range.getFirst()).intValue());\n+        switch (_valueType) {\n+          case INT:\n+            header.writeInt(value.intValue());\n+            break;\n+          case LONG:\n+            header.writeLong(value.longValue());\n+            break;\n+          case FLOAT:\n+            header.writeFloat(value.floatValue());\n+            break;\n+          case DOUBLE:\n+            header.writeDouble(value.doubleValue());\n+            break;\n+          default:\n+            throw new RuntimeException(\"Range index not supported for dataType: \" + _valueType);\n+        }\n+      }\n+\n+      bytesWritten += (ranges.size()) * _valueType.size(); // Range start values\n+\n+      //compute the offset where the bitmap for the first range would be written\n+      //bitmap start offset for each range, one extra to make it easy to get the length for last one.\n+      long bitmapOffsetHeaderSize = (ranges.size() + 1) * Long.BYTES;\n+\n+      long bitmapOffset = bytesWritten + bitmapOffsetHeaderSize;\n+      header.writeLong(bitmapOffset);\n+      bytesWritten += Long.BYTES;\n+      fos.getChannel().position(bitmapOffset);\n+\n+      for (int i = 0; i < ranges.size(); i++) {\n+        Pair<Integer, Integer> range = ranges.get(i);\n+        MutableRoaringBitmap bitmap = new MutableRoaringBitmap();\n+        for (int index = range.getFirst(); index <= range.getSecond(); index++) {\n+          bitmap.add(_docIdBuffer.get(index).intValue());\n+        }\n+        // Write offset and bitmap into file\n+        int sizeInBytes = bitmap.serializedSizeInBytes();\n+        bitmapOffset += sizeInBytes;\n+\n+        // Check for int overflow\n+        Preconditions.checkState(bitmapOffset > 0, \"Inverted index file: %s exceeds 2GB limit\", _invertedIndexFile);\n+\n+        header.writeLong(bitmapOffset);\n+        bytesWritten += Long.BYTES;\n+\n+        byte[] bytes = new byte[sizeInBytes];\n+        bitmap.serialize(ByteBuffer.wrap(bytes));\n+        dataOutputStream.write(bytes);\n+        bytesWritten += bytes.length;\n+      }\n+    } catch (IOException e) {\n+      FileUtils.deleteQuietly(_invertedIndexFile);\n+      throw e;\n+    }\n+    Preconditions.checkState(bytesWritten == _invertedIndexFile.length(),\n+        \"Length of inverted index file: \" + _invertedIndexFile.length()\n+            + \" does not match the number of bytes written: \" + bytesWritten);\n+  }\n+\n+  @Override\n+  public void close()\n+      throws IOException {\n+    org.apache.pinot.common.utils.FileUtils\n+        .close(new DataBufferAndFile(_forwardIndexValueBuffer, _forwardIndexValueBufferFile),\n+            new DataBufferAndFile(_docIdValueBuffer, _docIdBufferFileForSorting));\n+  }\n+\n+  private class DataBufferAndFile implements Closeable {\n+    private final PinotDataBuffer _dataBuffer;\n+    private final File _file;\n+\n+    DataBufferAndFile(final PinotDataBuffer buffer, final File file) {\n+      _dataBuffer = buffer;\n+      _file = file;\n+    }\n+\n+    @Override\n+    public void close()\n+        throws IOException {\n+      destroyBuffer(_dataBuffer, _file);\n+    }\n+  }\n+\n+  void dump() {\n+    System.out.print(\"[ \");\n+    for (int i = 0; i < _numValues; i++) {\n+      System.out.print(_valueBuffer.get(_docIdBuffer.get(i).intValue()) + \", \");\n+    }\n+    System.out.println(\"]\");\n+  }\n+\n+  private PinotDataBuffer createTempBuffer(long size, File mmapFile)\n+      throws IOException {\n+    if (_useMMapBuffer) {\n+      return PinotDataBuffer.mapFile(mmapFile, false, 0, size, PinotDataBuffer.NATIVE_ORDER,\n+          \"OffHeapBitmapInvertedIndexCreator: temp buffer\");\n+    } else {\n+      return PinotDataBuffer.allocateDirect(size, PinotDataBuffer.NATIVE_ORDER,\n+          \"OffHeapBitmapInvertedIndexCreator: temp buffer for \" + mmapFile.getName());\n+    }\n+  }\n+\n+  private void destroyBuffer(PinotDataBuffer buffer, File mmapFile)\n+      throws IOException {\n+    if (buffer != null) {\n+      buffer.close();\n+      if (mmapFile.exists()) {\n+        FileUtils.forceDelete(mmapFile);\n+      }\n+    }\n+  }\n+\n+  interface NumberValueBuffer {\n+\n+    void put(int position, Number value);\n+\n+    Number get(int position);\n+\n+    int compare(Number val1, Number val2);\n+  }\n+\n+  class IntValueBuffer implements NumberValueBuffer {\n+\n+    private PinotDataBuffer _buffer;\n+\n+    IntValueBuffer(PinotDataBuffer buffer) {\n+\n+      _buffer = buffer;\n+    }\n+\n+    @Override\n+    public void put(int position, Number value) {\n+      _buffer.putInt(position << 2, value.intValue());\n+    }", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzA3OQ==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419567079", "bodyText": "I don't see _forwardIndexValueBuffer being used", "author": "siddharthteotia", "createdAt": "2020-05-04T16:32:49Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/RangeIndexCreator.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv;\n+\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.Arrays;\n+import it.unimi.dsi.fastutil.Swapper;\n+import it.unimi.dsi.fastutil.ints.IntComparator;\n+import java.io.BufferedOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.Constants;\n+import org.apache.pinot.core.query.utils.Pair;\n+import org.apache.pinot.core.segment.creator.InvertedIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.BITMAP_RANGE_INDEX_FILE_EXTENSION;\n+\n+\n+/**\n+ * Implementation of {@link InvertedIndexCreator} that uses off-heap memory.\n+ * <p>We use 2 passes to create the range index.\n+ * <ul>\n+ *\n+ *   <li>\n+ *     A\n+ *   </li>\n+ *   <li>\n+ *     In the first pass (adding values phase), when add() method is called, store the raw values into the forward index\n+ *     value buffer (for multi-valued column also store number of values for each docId into forward index length\n+ *     buffer). We also compute the inverted index length for each dictId while adding values.\n+ *   </li>\n+ *   <li>\n+ *     In the second pass (processing values phase), when seal() method is called, all the dictIds should already been\n+ *     added. We first reorder the values into the inverted index buffers by going over the dictIds in forward index\n+ *     value buffer (for multi-valued column we also need forward index length buffer to get the docId for each dictId).\n+ *     <p>Once we have the inverted index buffers, we simply go over them and create the bitmap for each dictId and\n+ *     serialize them into a file.\n+ *   </li>\n+ * </ul>\n+ * <p>Based on the number of values we need to store, we use direct memory or MMap file to allocate the buffer.\n+ */\n+public final class RangeIndexCreator implements InvertedIndexCreator {\n+\n+  private static final int RANGE_INDEX_VERSION = 1;\n+\n+  // Use MMapBuffer if the value buffer size is larger than 2G\n+  private static final int NUM_VALUES_THRESHOLD_FOR_MMAP_BUFFER = 500_000_000;\n+  private static final int DEFAULT_NUM_RANGES = 20;\n+\n+  private static final String FORWARD_INDEX_VALUE_BUFFER_SUFFIX = \".fwd.idx.val.buf\";\n+  private static final String DOC_ID_VALUE_BUFFER_SUFFIX = \".doc.id.val.buf\";\n+\n+  private final File _invertedIndexFile;\n+  private final File _forwardIndexValueBufferFile;\n+  private final File _docIdBufferFileForSorting;\n+  private final int _numValues;\n+  private final boolean _useMMapBuffer;\n+\n+  // Forward index buffers (from docId to dictId)\n+  private int _nextDocId;\n+  private PinotDataBuffer _forwardIndexValueBuffer;\n+  private NumberValueBuffer _valueBuffer;\n+  //for sorting\n+  private PinotDataBuffer _docIdValueBuffer;\n+  private IntValueBuffer _docIdBuffer;\n+  // For multi-valued column only because each docId can have multiple dictIds\n+  private int _nextValueId;\n+  private int _numDocsPerRange;\n+  private FieldSpec.DataType _valueType;\n+\n+  public RangeIndexCreator(File indexDir, FieldSpec fieldSpec, FieldSpec.DataType valueType, int numRanges, int numDocsPerRange, int numDocs, int numValues)\n+      throws IOException {\n+    _valueType = valueType;\n+    String columnName = fieldSpec.getName();\n+    _invertedIndexFile = new File(indexDir, columnName + BITMAP_RANGE_INDEX_FILE_EXTENSION);\n+    _forwardIndexValueBufferFile = new File(indexDir, columnName + FORWARD_INDEX_VALUE_BUFFER_SUFFIX);\n+    _docIdBufferFileForSorting = new File(indexDir, columnName + DOC_ID_VALUE_BUFFER_SUFFIX);\n+    _numValues = fieldSpec.isSingleValueField() ? numDocs : numValues;\n+    _useMMapBuffer = _numValues > NUM_VALUES_THRESHOLD_FOR_MMAP_BUFFER;\n+    int valueSize = valueType.size();\n+    try {\n+      //use DEFAULT_NUM_RANGES if numRanges is not set\n+      if(numRanges < 0) {\n+        numRanges = DEFAULT_NUM_RANGES;\n+      }\n+      if(numDocsPerRange < 0) {\n+        _numDocsPerRange = (int) Math.ceil(_numValues / numRanges);\n+      }\n+\n+      //FORWARD INDEX - stores the actual values added\n+      _forwardIndexValueBuffer = createTempBuffer((long) _numValues * valueSize, _forwardIndexValueBufferFile);\n+\n+      switch (_valueType) {\n+        case INT:\n+          _valueBuffer = new IntValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        case FLOAT:\n+          _valueBuffer = new FloatValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        case LONG:\n+          _valueBuffer = new LongValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        case DOUBLE:\n+          _valueBuffer = new DoubleValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        default:\n+          throw new UnsupportedOperationException(\"Range index is not supported for columns of data type:\" + valueType);\n+      }\n+\n+      //Stores the docId - this will be sorted based on the values in FORWARD INDEX in the end\n+      _docIdValueBuffer = createTempBuffer((long) _numValues * Integer.BYTES, _forwardIndexValueBufferFile);\n+      _docIdBuffer = new IntValueBuffer(_docIdValueBuffer);\n+    } catch (Exception e) {\n+      destroyBuffer(_forwardIndexValueBuffer, _forwardIndexValueBufferFile);\n+      destroyBuffer(_forwardIndexValueBuffer, _docIdBufferFileForSorting);\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public void add(int dictId) {\n+    _valueBuffer.put(_nextDocId, dictId);\n+    _docIdBuffer.put(_nextDocId, _nextDocId);\n+    _nextDocId = _nextDocId + 1;\n+  }\n+\n+  @Override\n+  public void add(int[] dictIds, int length) {\n+    for (int i = 0; i < length; i++) {\n+      int dictId = dictIds[i];\n+      _valueBuffer.put(_nextDocId, dictId);\n+      _docIdBuffer.put(_nextValueId, _nextDocId);\n+      _nextValueId = _nextValueId + 1;\n+    }\n+  }\n+\n+  @Override\n+  public void addDoc(Object document, int docIdCounter) {\n+    throw new IllegalStateException(\"Bitmap inverted index creator does not support Object type currently\");\n+  }\n+\n+  @Override\n+  public void seal()\n+      throws IOException {\n+    //sort the forward index copy\n+    //go over the sorted value to compute ranges\n+    IntComparator comparator = (i, j) -> {\n+      Number val1 = _valueBuffer.get(_docIdBuffer.get(i).intValue());\n+      Number val2 = _valueBuffer.get(_docIdBuffer.get(j).intValue());\n+      return _valueBuffer.compare(val1, val2);\n+    };\n+    Swapper swapper = (i, j) -> {\n+      Number temp = _docIdBuffer.get(i).intValue();\n+      _docIdBuffer.put(i, _docIdBuffer.get(j).intValue());\n+      _docIdBuffer.put(j, temp);\n+    };\n+    Arrays.quickSort(0, _numValues, comparator, swapper);\n+\n+//    dump();\n+    //FIND THE RANGES\n+    List<Pair<Integer, Integer>> ranges = new ArrayList<>();\n+\n+    int boundary = _numDocsPerRange;\n+    int start = 0;\n+    for (int i = 0; i < _numValues; i++) {\n+      if (i > start + boundary) {\n+        if (comparator.compare(i, i - 1) != 0) {\n+          ranges.add(new Pair(start, i - 1));\n+          start = i;\n+        }\n+      }\n+    }\n+    ranges.add(new Pair(start, _numValues - 1));\n+\n+    // Create bitmaps from inverted index buffers and serialize them to file\n+    //HEADER\n+    //   # VERSION (INT)\n+    //   # DATA_TYPE (String -> INT (length) (ACTUAL BYTES)\n+    //   # OF RANGES (INT)\n+    //   <RANGE START VALUE BUFFER> #R & ValueSize\n+    //   Range Start 0\n+    //    .........\n+    //   Range Start R - 1\n+    //   Bitmap for Range 0 Start Offset\n+    //      .....\n+    //   Bitmap for Range R Start Offset\n+    //BODY\n+    //   Bitmap for range 0\n+    //   Bitmap for range 2\n+    //    ......\n+    //   Bitmap for range R - 1\n+    long bytesWritten = 0;", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MDY0MA==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r422460640", "bodyText": "we dont need that right?", "author": "kishoreg", "createdAt": "2020-05-09T06:49:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzEyMQ==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419567121", "bodyText": "Looks like we are doing in-place sorting on _docIdBuffer. Why do we need _docIdValueBuffer?", "author": "siddharthteotia", "createdAt": "2020-05-04T16:32:53Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/RangeIndexCreator.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv;\n+\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.Arrays;\n+import it.unimi.dsi.fastutil.Swapper;\n+import it.unimi.dsi.fastutil.ints.IntComparator;\n+import java.io.BufferedOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.Constants;\n+import org.apache.pinot.core.query.utils.Pair;\n+import org.apache.pinot.core.segment.creator.InvertedIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.BITMAP_RANGE_INDEX_FILE_EXTENSION;\n+\n+\n+/**\n+ * Implementation of {@link InvertedIndexCreator} that uses off-heap memory.\n+ * <p>We use 2 passes to create the range index.\n+ * <ul>\n+ *\n+ *   <li>\n+ *     A\n+ *   </li>\n+ *   <li>\n+ *     In the first pass (adding values phase), when add() method is called, store the raw values into the forward index\n+ *     value buffer (for multi-valued column also store number of values for each docId into forward index length\n+ *     buffer). We also compute the inverted index length for each dictId while adding values.\n+ *   </li>\n+ *   <li>\n+ *     In the second pass (processing values phase), when seal() method is called, all the dictIds should already been\n+ *     added. We first reorder the values into the inverted index buffers by going over the dictIds in forward index\n+ *     value buffer (for multi-valued column we also need forward index length buffer to get the docId for each dictId).\n+ *     <p>Once we have the inverted index buffers, we simply go over them and create the bitmap for each dictId and\n+ *     serialize them into a file.\n+ *   </li>\n+ * </ul>\n+ * <p>Based on the number of values we need to store, we use direct memory or MMap file to allocate the buffer.\n+ */\n+public final class RangeIndexCreator implements InvertedIndexCreator {\n+\n+  private static final int RANGE_INDEX_VERSION = 1;\n+\n+  // Use MMapBuffer if the value buffer size is larger than 2G\n+  private static final int NUM_VALUES_THRESHOLD_FOR_MMAP_BUFFER = 500_000_000;\n+  private static final int DEFAULT_NUM_RANGES = 20;\n+\n+  private static final String FORWARD_INDEX_VALUE_BUFFER_SUFFIX = \".fwd.idx.val.buf\";\n+  private static final String DOC_ID_VALUE_BUFFER_SUFFIX = \".doc.id.val.buf\";\n+\n+  private final File _invertedIndexFile;\n+  private final File _forwardIndexValueBufferFile;\n+  private final File _docIdBufferFileForSorting;\n+  private final int _numValues;\n+  private final boolean _useMMapBuffer;\n+\n+  // Forward index buffers (from docId to dictId)\n+  private int _nextDocId;\n+  private PinotDataBuffer _forwardIndexValueBuffer;\n+  private NumberValueBuffer _valueBuffer;\n+  //for sorting\n+  private PinotDataBuffer _docIdValueBuffer;\n+  private IntValueBuffer _docIdBuffer;\n+  // For multi-valued column only because each docId can have multiple dictIds\n+  private int _nextValueId;\n+  private int _numDocsPerRange;\n+  private FieldSpec.DataType _valueType;\n+\n+  public RangeIndexCreator(File indexDir, FieldSpec fieldSpec, FieldSpec.DataType valueType, int numRanges, int numDocsPerRange, int numDocs, int numValues)\n+      throws IOException {\n+    _valueType = valueType;\n+    String columnName = fieldSpec.getName();\n+    _invertedIndexFile = new File(indexDir, columnName + BITMAP_RANGE_INDEX_FILE_EXTENSION);\n+    _forwardIndexValueBufferFile = new File(indexDir, columnName + FORWARD_INDEX_VALUE_BUFFER_SUFFIX);\n+    _docIdBufferFileForSorting = new File(indexDir, columnName + DOC_ID_VALUE_BUFFER_SUFFIX);\n+    _numValues = fieldSpec.isSingleValueField() ? numDocs : numValues;\n+    _useMMapBuffer = _numValues > NUM_VALUES_THRESHOLD_FOR_MMAP_BUFFER;\n+    int valueSize = valueType.size();\n+    try {\n+      //use DEFAULT_NUM_RANGES if numRanges is not set\n+      if(numRanges < 0) {\n+        numRanges = DEFAULT_NUM_RANGES;\n+      }\n+      if(numDocsPerRange < 0) {\n+        _numDocsPerRange = (int) Math.ceil(_numValues / numRanges);\n+      }\n+\n+      //FORWARD INDEX - stores the actual values added\n+      _forwardIndexValueBuffer = createTempBuffer((long) _numValues * valueSize, _forwardIndexValueBufferFile);\n+\n+      switch (_valueType) {\n+        case INT:\n+          _valueBuffer = new IntValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        case FLOAT:\n+          _valueBuffer = new FloatValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        case LONG:\n+          _valueBuffer = new LongValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        case DOUBLE:\n+          _valueBuffer = new DoubleValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        default:\n+          throw new UnsupportedOperationException(\"Range index is not supported for columns of data type:\" + valueType);\n+      }\n+\n+      //Stores the docId - this will be sorted based on the values in FORWARD INDEX in the end\n+      _docIdValueBuffer = createTempBuffer((long) _numValues * Integer.BYTES, _forwardIndexValueBufferFile);\n+      _docIdBuffer = new IntValueBuffer(_docIdValueBuffer);\n+    } catch (Exception e) {\n+      destroyBuffer(_forwardIndexValueBuffer, _forwardIndexValueBufferFile);\n+      destroyBuffer(_forwardIndexValueBuffer, _docIdBufferFileForSorting);\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public void add(int dictId) {\n+    _valueBuffer.put(_nextDocId, dictId);\n+    _docIdBuffer.put(_nextDocId, _nextDocId);\n+    _nextDocId = _nextDocId + 1;\n+  }\n+\n+  @Override\n+  public void add(int[] dictIds, int length) {\n+    for (int i = 0; i < length; i++) {\n+      int dictId = dictIds[i];\n+      _valueBuffer.put(_nextDocId, dictId);\n+      _docIdBuffer.put(_nextValueId, _nextDocId);\n+      _nextValueId = _nextValueId + 1;\n+    }\n+  }\n+\n+  @Override\n+  public void addDoc(Object document, int docIdCounter) {\n+    throw new IllegalStateException(\"Bitmap inverted index creator does not support Object type currently\");\n+  }\n+\n+  @Override\n+  public void seal()\n+      throws IOException {\n+    //sort the forward index copy\n+    //go over the sorted value to compute ranges\n+    IntComparator comparator = (i, j) -> {\n+      Number val1 = _valueBuffer.get(_docIdBuffer.get(i).intValue());\n+      Number val2 = _valueBuffer.get(_docIdBuffer.get(j).intValue());\n+      return _valueBuffer.compare(val1, val2);\n+    };\n+    Swapper swapper = (i, j) -> {\n+      Number temp = _docIdBuffer.get(i).intValue();", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MDcwMg==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r422460702", "bodyText": "to sort the forward index, instead of sorting the actual forward index, I sort the position array", "author": "kishoreg", "createdAt": "2020-05-09T06:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzEyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU2MzY3Nw==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r422563677", "bodyText": "Got it. Thanks.", "author": "siddharthteotia", "createdAt": "2020-05-10T00:18:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzE3Mw==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419567173", "bodyText": "So this is either going to sort raw values or dictIds. Correct?", "author": "siddharthteotia", "createdAt": "2020-05-04T16:32:59Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/RangeIndexCreator.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv;\n+\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.Arrays;\n+import it.unimi.dsi.fastutil.Swapper;\n+import it.unimi.dsi.fastutil.ints.IntComparator;\n+import java.io.BufferedOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.Constants;\n+import org.apache.pinot.core.query.utils.Pair;\n+import org.apache.pinot.core.segment.creator.InvertedIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.BITMAP_RANGE_INDEX_FILE_EXTENSION;\n+\n+\n+/**\n+ * Implementation of {@link InvertedIndexCreator} that uses off-heap memory.\n+ * <p>We use 2 passes to create the range index.\n+ * <ul>\n+ *\n+ *   <li>\n+ *     A\n+ *   </li>\n+ *   <li>\n+ *     In the first pass (adding values phase), when add() method is called, store the raw values into the forward index\n+ *     value buffer (for multi-valued column also store number of values for each docId into forward index length\n+ *     buffer). We also compute the inverted index length for each dictId while adding values.\n+ *   </li>\n+ *   <li>\n+ *     In the second pass (processing values phase), when seal() method is called, all the dictIds should already been\n+ *     added. We first reorder the values into the inverted index buffers by going over the dictIds in forward index\n+ *     value buffer (for multi-valued column we also need forward index length buffer to get the docId for each dictId).\n+ *     <p>Once we have the inverted index buffers, we simply go over them and create the bitmap for each dictId and\n+ *     serialize them into a file.\n+ *   </li>\n+ * </ul>\n+ * <p>Based on the number of values we need to store, we use direct memory or MMap file to allocate the buffer.\n+ */\n+public final class RangeIndexCreator implements InvertedIndexCreator {\n+\n+  private static final int RANGE_INDEX_VERSION = 1;\n+\n+  // Use MMapBuffer if the value buffer size is larger than 2G\n+  private static final int NUM_VALUES_THRESHOLD_FOR_MMAP_BUFFER = 500_000_000;\n+  private static final int DEFAULT_NUM_RANGES = 20;\n+\n+  private static final String FORWARD_INDEX_VALUE_BUFFER_SUFFIX = \".fwd.idx.val.buf\";\n+  private static final String DOC_ID_VALUE_BUFFER_SUFFIX = \".doc.id.val.buf\";\n+\n+  private final File _invertedIndexFile;\n+  private final File _forwardIndexValueBufferFile;\n+  private final File _docIdBufferFileForSorting;\n+  private final int _numValues;\n+  private final boolean _useMMapBuffer;\n+\n+  // Forward index buffers (from docId to dictId)\n+  private int _nextDocId;\n+  private PinotDataBuffer _forwardIndexValueBuffer;\n+  private NumberValueBuffer _valueBuffer;\n+  //for sorting\n+  private PinotDataBuffer _docIdValueBuffer;\n+  private IntValueBuffer _docIdBuffer;\n+  // For multi-valued column only because each docId can have multiple dictIds\n+  private int _nextValueId;\n+  private int _numDocsPerRange;\n+  private FieldSpec.DataType _valueType;\n+\n+  public RangeIndexCreator(File indexDir, FieldSpec fieldSpec, FieldSpec.DataType valueType, int numRanges, int numDocsPerRange, int numDocs, int numValues)\n+      throws IOException {\n+    _valueType = valueType;\n+    String columnName = fieldSpec.getName();\n+    _invertedIndexFile = new File(indexDir, columnName + BITMAP_RANGE_INDEX_FILE_EXTENSION);\n+    _forwardIndexValueBufferFile = new File(indexDir, columnName + FORWARD_INDEX_VALUE_BUFFER_SUFFIX);\n+    _docIdBufferFileForSorting = new File(indexDir, columnName + DOC_ID_VALUE_BUFFER_SUFFIX);\n+    _numValues = fieldSpec.isSingleValueField() ? numDocs : numValues;\n+    _useMMapBuffer = _numValues > NUM_VALUES_THRESHOLD_FOR_MMAP_BUFFER;\n+    int valueSize = valueType.size();\n+    try {\n+      //use DEFAULT_NUM_RANGES if numRanges is not set\n+      if(numRanges < 0) {\n+        numRanges = DEFAULT_NUM_RANGES;\n+      }\n+      if(numDocsPerRange < 0) {\n+        _numDocsPerRange = (int) Math.ceil(_numValues / numRanges);\n+      }\n+\n+      //FORWARD INDEX - stores the actual values added\n+      _forwardIndexValueBuffer = createTempBuffer((long) _numValues * valueSize, _forwardIndexValueBufferFile);\n+\n+      switch (_valueType) {\n+        case INT:\n+          _valueBuffer = new IntValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        case FLOAT:\n+          _valueBuffer = new FloatValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        case LONG:\n+          _valueBuffer = new LongValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        case DOUBLE:\n+          _valueBuffer = new DoubleValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        default:\n+          throw new UnsupportedOperationException(\"Range index is not supported for columns of data type:\" + valueType);\n+      }\n+\n+      //Stores the docId - this will be sorted based on the values in FORWARD INDEX in the end\n+      _docIdValueBuffer = createTempBuffer((long) _numValues * Integer.BYTES, _forwardIndexValueBufferFile);\n+      _docIdBuffer = new IntValueBuffer(_docIdValueBuffer);\n+    } catch (Exception e) {\n+      destroyBuffer(_forwardIndexValueBuffer, _forwardIndexValueBufferFile);\n+      destroyBuffer(_forwardIndexValueBuffer, _docIdBufferFileForSorting);\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public void add(int dictId) {\n+    _valueBuffer.put(_nextDocId, dictId);\n+    _docIdBuffer.put(_nextDocId, _nextDocId);\n+    _nextDocId = _nextDocId + 1;\n+  }\n+\n+  @Override\n+  public void add(int[] dictIds, int length) {\n+    for (int i = 0; i < length; i++) {\n+      int dictId = dictIds[i];\n+      _valueBuffer.put(_nextDocId, dictId);\n+      _docIdBuffer.put(_nextValueId, _nextDocId);\n+      _nextValueId = _nextValueId + 1;\n+    }\n+  }\n+\n+  @Override\n+  public void addDoc(Object document, int docIdCounter) {\n+    throw new IllegalStateException(\"Bitmap inverted index creator does not support Object type currently\");\n+  }\n+\n+  @Override\n+  public void seal()\n+      throws IOException {\n+    //sort the forward index copy\n+    //go over the sorted value to compute ranges\n+    IntComparator comparator = (i, j) -> {", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MDc3MQ==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r422460771", "bodyText": "The actual sort happens on docIdBuffer but uses forward index for sorting", "author": "kishoreg", "createdAt": "2020-05-09T06:51:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU2MzMxMA==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r422563310", "bodyText": "Let's not call it forward index. Let's call it keys?", "author": "siddharthteotia", "createdAt": "2020-05-10T00:14:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzIyMA==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419567220", "bodyText": "Change the exception", "author": "siddharthteotia", "createdAt": "2020-05-04T16:33:03Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/RangeIndexCreator.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv;\n+\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.Arrays;\n+import it.unimi.dsi.fastutil.Swapper;\n+import it.unimi.dsi.fastutil.ints.IntComparator;\n+import java.io.BufferedOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.Constants;\n+import org.apache.pinot.core.query.utils.Pair;\n+import org.apache.pinot.core.segment.creator.InvertedIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.BITMAP_RANGE_INDEX_FILE_EXTENSION;\n+\n+\n+/**\n+ * Implementation of {@link InvertedIndexCreator} that uses off-heap memory.\n+ * <p>We use 2 passes to create the range index.\n+ * <ul>\n+ *\n+ *   <li>\n+ *     A\n+ *   </li>\n+ *   <li>\n+ *     In the first pass (adding values phase), when add() method is called, store the raw values into the forward index\n+ *     value buffer (for multi-valued column also store number of values for each docId into forward index length\n+ *     buffer). We also compute the inverted index length for each dictId while adding values.\n+ *   </li>\n+ *   <li>\n+ *     In the second pass (processing values phase), when seal() method is called, all the dictIds should already been\n+ *     added. We first reorder the values into the inverted index buffers by going over the dictIds in forward index\n+ *     value buffer (for multi-valued column we also need forward index length buffer to get the docId for each dictId).\n+ *     <p>Once we have the inverted index buffers, we simply go over them and create the bitmap for each dictId and\n+ *     serialize them into a file.\n+ *   </li>\n+ * </ul>\n+ * <p>Based on the number of values we need to store, we use direct memory or MMap file to allocate the buffer.\n+ */\n+public final class RangeIndexCreator implements InvertedIndexCreator {\n+\n+  private static final int RANGE_INDEX_VERSION = 1;\n+\n+  // Use MMapBuffer if the value buffer size is larger than 2G\n+  private static final int NUM_VALUES_THRESHOLD_FOR_MMAP_BUFFER = 500_000_000;\n+  private static final int DEFAULT_NUM_RANGES = 20;\n+\n+  private static final String FORWARD_INDEX_VALUE_BUFFER_SUFFIX = \".fwd.idx.val.buf\";\n+  private static final String DOC_ID_VALUE_BUFFER_SUFFIX = \".doc.id.val.buf\";\n+\n+  private final File _invertedIndexFile;\n+  private final File _forwardIndexValueBufferFile;\n+  private final File _docIdBufferFileForSorting;\n+  private final int _numValues;\n+  private final boolean _useMMapBuffer;\n+\n+  // Forward index buffers (from docId to dictId)\n+  private int _nextDocId;\n+  private PinotDataBuffer _forwardIndexValueBuffer;\n+  private NumberValueBuffer _valueBuffer;\n+  //for sorting\n+  private PinotDataBuffer _docIdValueBuffer;\n+  private IntValueBuffer _docIdBuffer;\n+  // For multi-valued column only because each docId can have multiple dictIds\n+  private int _nextValueId;\n+  private int _numDocsPerRange;\n+  private FieldSpec.DataType _valueType;\n+\n+  public RangeIndexCreator(File indexDir, FieldSpec fieldSpec, FieldSpec.DataType valueType, int numRanges, int numDocsPerRange, int numDocs, int numValues)\n+      throws IOException {\n+    _valueType = valueType;\n+    String columnName = fieldSpec.getName();\n+    _invertedIndexFile = new File(indexDir, columnName + BITMAP_RANGE_INDEX_FILE_EXTENSION);\n+    _forwardIndexValueBufferFile = new File(indexDir, columnName + FORWARD_INDEX_VALUE_BUFFER_SUFFIX);\n+    _docIdBufferFileForSorting = new File(indexDir, columnName + DOC_ID_VALUE_BUFFER_SUFFIX);\n+    _numValues = fieldSpec.isSingleValueField() ? numDocs : numValues;\n+    _useMMapBuffer = _numValues > NUM_VALUES_THRESHOLD_FOR_MMAP_BUFFER;\n+    int valueSize = valueType.size();\n+    try {\n+      //use DEFAULT_NUM_RANGES if numRanges is not set\n+      if(numRanges < 0) {\n+        numRanges = DEFAULT_NUM_RANGES;\n+      }\n+      if(numDocsPerRange < 0) {\n+        _numDocsPerRange = (int) Math.ceil(_numValues / numRanges);\n+      }\n+\n+      //FORWARD INDEX - stores the actual values added\n+      _forwardIndexValueBuffer = createTempBuffer((long) _numValues * valueSize, _forwardIndexValueBufferFile);\n+\n+      switch (_valueType) {\n+        case INT:\n+          _valueBuffer = new IntValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        case FLOAT:\n+          _valueBuffer = new FloatValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        case LONG:\n+          _valueBuffer = new LongValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        case DOUBLE:\n+          _valueBuffer = new DoubleValueBuffer(_forwardIndexValueBuffer);\n+          break;\n+        default:\n+          throw new UnsupportedOperationException(\"Range index is not supported for columns of data type:\" + valueType);\n+      }\n+\n+      //Stores the docId - this will be sorted based on the values in FORWARD INDEX in the end\n+      _docIdValueBuffer = createTempBuffer((long) _numValues * Integer.BYTES, _forwardIndexValueBufferFile);\n+      _docIdBuffer = new IntValueBuffer(_docIdValueBuffer);\n+    } catch (Exception e) {\n+      destroyBuffer(_forwardIndexValueBuffer, _forwardIndexValueBufferFile);\n+      destroyBuffer(_forwardIndexValueBuffer, _docIdBufferFileForSorting);\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public void add(int dictId) {\n+    _valueBuffer.put(_nextDocId, dictId);\n+    _docIdBuffer.put(_nextDocId, _nextDocId);\n+    _nextDocId = _nextDocId + 1;\n+  }\n+\n+  @Override\n+  public void add(int[] dictIds, int length) {\n+    for (int i = 0; i < length; i++) {\n+      int dictId = dictIds[i];\n+      _valueBuffer.put(_nextDocId, dictId);\n+      _docIdBuffer.put(_nextValueId, _nextDocId);\n+      _nextValueId = _nextValueId + 1;\n+    }\n+  }\n+\n+  @Override\n+  public void addDoc(Object document, int docIdCounter) {\n+    throw new IllegalStateException(\"Bitmap inverted index creator does not support Object type currently\");", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2NTA4NA==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r423165084", "bodyText": "Please fix this exception", "author": "siddharthteotia", "createdAt": "2020-05-11T16:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzI4Nw==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419567287", "bodyText": "This buffer will either store dictIds or raw values. Correct?", "author": "siddharthteotia", "createdAt": "2020-05-04T16:33:08Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/RangeIndexCreator.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv;\n+\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.Arrays;\n+import it.unimi.dsi.fastutil.Swapper;\n+import it.unimi.dsi.fastutil.ints.IntComparator;\n+import java.io.BufferedOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.Constants;\n+import org.apache.pinot.core.query.utils.Pair;\n+import org.apache.pinot.core.segment.creator.InvertedIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.BITMAP_RANGE_INDEX_FILE_EXTENSION;\n+\n+\n+/**\n+ * Implementation of {@link InvertedIndexCreator} that uses off-heap memory.\n+ * <p>We use 2 passes to create the range index.\n+ * <ul>\n+ *\n+ *   <li>\n+ *     A\n+ *   </li>\n+ *   <li>\n+ *     In the first pass (adding values phase), when add() method is called, store the raw values into the forward index\n+ *     value buffer (for multi-valued column also store number of values for each docId into forward index length\n+ *     buffer). We also compute the inverted index length for each dictId while adding values.\n+ *   </li>\n+ *   <li>\n+ *     In the second pass (processing values phase), when seal() method is called, all the dictIds should already been\n+ *     added. We first reorder the values into the inverted index buffers by going over the dictIds in forward index\n+ *     value buffer (for multi-valued column we also need forward index length buffer to get the docId for each dictId).\n+ *     <p>Once we have the inverted index buffers, we simply go over them and create the bitmap for each dictId and\n+ *     serialize them into a file.\n+ *   </li>\n+ * </ul>\n+ * <p>Based on the number of values we need to store, we use direct memory or MMap file to allocate the buffer.\n+ */\n+public final class RangeIndexCreator implements InvertedIndexCreator {\n+\n+  private static final int RANGE_INDEX_VERSION = 1;\n+\n+  // Use MMapBuffer if the value buffer size is larger than 2G\n+  private static final int NUM_VALUES_THRESHOLD_FOR_MMAP_BUFFER = 500_000_000;\n+  private static final int DEFAULT_NUM_RANGES = 20;\n+\n+  private static final String FORWARD_INDEX_VALUE_BUFFER_SUFFIX = \".fwd.idx.val.buf\";\n+  private static final String DOC_ID_VALUE_BUFFER_SUFFIX = \".doc.id.val.buf\";\n+\n+  private final File _invertedIndexFile;\n+  private final File _forwardIndexValueBufferFile;\n+  private final File _docIdBufferFileForSorting;\n+  private final int _numValues;\n+  private final boolean _useMMapBuffer;\n+\n+  // Forward index buffers (from docId to dictId)\n+  private int _nextDocId;\n+  private PinotDataBuffer _forwardIndexValueBuffer;\n+  private NumberValueBuffer _valueBuffer;", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MDc5Mw==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r422460793", "bodyText": "right", "author": "kishoreg", "createdAt": "2020-05-09T06:51:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzI4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU2MjYxMw==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r422562613", "bodyText": "Let's please rename it indexKeyBuffer?", "author": "siddharthteotia", "createdAt": "2020-05-10T00:05:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzMyMA==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419567320", "bodyText": "Can we add some short comments (one line is enough) about each buffer type?", "author": "siddharthteotia", "createdAt": "2020-05-04T16:33:11Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/RangeIndexCreator.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv;\n+\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.Arrays;\n+import it.unimi.dsi.fastutil.Swapper;\n+import it.unimi.dsi.fastutil.ints.IntComparator;\n+import java.io.BufferedOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.Constants;\n+import org.apache.pinot.core.query.utils.Pair;\n+import org.apache.pinot.core.segment.creator.InvertedIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.BITMAP_RANGE_INDEX_FILE_EXTENSION;\n+\n+\n+/**\n+ * Implementation of {@link InvertedIndexCreator} that uses off-heap memory.\n+ * <p>We use 2 passes to create the range index.\n+ * <ul>\n+ *\n+ *   <li>\n+ *     A\n+ *   </li>\n+ *   <li>\n+ *     In the first pass (adding values phase), when add() method is called, store the raw values into the forward index\n+ *     value buffer (for multi-valued column also store number of values for each docId into forward index length\n+ *     buffer). We also compute the inverted index length for each dictId while adding values.\n+ *   </li>\n+ *   <li>\n+ *     In the second pass (processing values phase), when seal() method is called, all the dictIds should already been\n+ *     added. We first reorder the values into the inverted index buffers by going over the dictIds in forward index\n+ *     value buffer (for multi-valued column we also need forward index length buffer to get the docId for each dictId).\n+ *     <p>Once we have the inverted index buffers, we simply go over them and create the bitmap for each dictId and\n+ *     serialize them into a file.\n+ *   </li>\n+ * </ul>\n+ * <p>Based on the number of values we need to store, we use direct memory or MMap file to allocate the buffer.\n+ */\n+public final class RangeIndexCreator implements InvertedIndexCreator {\n+\n+  private static final int RANGE_INDEX_VERSION = 1;\n+\n+  // Use MMapBuffer if the value buffer size is larger than 2G\n+  private static final int NUM_VALUES_THRESHOLD_FOR_MMAP_BUFFER = 500_000_000;\n+  private static final int DEFAULT_NUM_RANGES = 20;\n+\n+  private static final String FORWARD_INDEX_VALUE_BUFFER_SUFFIX = \".fwd.idx.val.buf\";\n+  private static final String DOC_ID_VALUE_BUFFER_SUFFIX = \".doc.id.val.buf\";\n+\n+  private final File _invertedIndexFile;\n+  private final File _forwardIndexValueBufferFile;\n+  private final File _docIdBufferFileForSorting;\n+  private final int _numValues;\n+  private final boolean _useMMapBuffer;\n+\n+  // Forward index buffers (from docId to dictId)\n+  private int _nextDocId;\n+  private PinotDataBuffer _forwardIndexValueBuffer;", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzQxMg==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419567412", "bodyText": "Why are we creating the forward index for the column as part of creating range index? The loop in SegmentColumnarIndexCreator that goes over each GenericRow takes care of that.", "author": "siddharthteotia", "createdAt": "2020-05-04T16:33:20Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/RangeIndexCreator.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv;\n+\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.Arrays;\n+import it.unimi.dsi.fastutil.Swapper;\n+import it.unimi.dsi.fastutil.ints.IntComparator;\n+import java.io.BufferedOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.Constants;\n+import org.apache.pinot.core.query.utils.Pair;\n+import org.apache.pinot.core.segment.creator.InvertedIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.BITMAP_RANGE_INDEX_FILE_EXTENSION;\n+\n+\n+/**\n+ * Implementation of {@link InvertedIndexCreator} that uses off-heap memory.\n+ * <p>We use 2 passes to create the range index.\n+ * <ul>\n+ *\n+ *   <li>\n+ *     A\n+ *   </li>\n+ *   <li>\n+ *     In the first pass (adding values phase), when add() method is called, store the raw values into the forward index\n+ *     value buffer (for multi-valued column also store number of values for each docId into forward index length\n+ *     buffer). We also compute the inverted index length for each dictId while adding values.\n+ *   </li>\n+ *   <li>\n+ *     In the second pass (processing values phase), when seal() method is called, all the dictIds should already been\n+ *     added. We first reorder the values into the inverted index buffers by going over the dictIds in forward index\n+ *     value buffer (for multi-valued column we also need forward index length buffer to get the docId for each dictId).\n+ *     <p>Once we have the inverted index buffers, we simply go over them and create the bitmap for each dictId and\n+ *     serialize them into a file.\n+ *   </li>\n+ * </ul>\n+ * <p>Based on the number of values we need to store, we use direct memory or MMap file to allocate the buffer.\n+ */\n+public final class RangeIndexCreator implements InvertedIndexCreator {\n+\n+  private static final int RANGE_INDEX_VERSION = 1;\n+\n+  // Use MMapBuffer if the value buffer size is larger than 2G\n+  private static final int NUM_VALUES_THRESHOLD_FOR_MMAP_BUFFER = 500_000_000;\n+  private static final int DEFAULT_NUM_RANGES = 20;\n+\n+  private static final String FORWARD_INDEX_VALUE_BUFFER_SUFFIX = \".fwd.idx.val.buf\";\n+  private static final String DOC_ID_VALUE_BUFFER_SUFFIX = \".doc.id.val.buf\";\n+\n+  private final File _invertedIndexFile;\n+  private final File _forwardIndexValueBufferFile;\n+  private final File _docIdBufferFileForSorting;\n+  private final int _numValues;\n+  private final boolean _useMMapBuffer;\n+\n+  // Forward index buffers (from docId to dictId)", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MDgzNQ==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r422460835", "bodyText": "its a temp buffer, will renaming it to valueBuffer help?", "author": "kishoreg", "createdAt": "2020-05-09T06:52:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzQxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU2MTk1Nw==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r422561957", "bodyText": "Let's not use the term forward index inside range index creator. Can we please call it keyBuffer. The key that are stored could be dictIds or raw values.", "author": "siddharthteotia", "createdAt": "2020-05-09T23:57:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzQzOQ==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419567439", "bodyText": "I think the problem with treating this as another inverted index by overriding InvertedIndexCreator and InvertedIndexReader interfaces, is that we are inherently making this work only on dictionary encoded columns because these interfaces and their APIs are written to work only on dictIds\nHowever, for text index (which also implements the same interface), we added a docId based API but that takes an object value. May be we can expand that API for each primitive type and that way we can support raw value based inverted index as well. I think we should decide on this sooner because this question will pop up for every new index type that we may add.\nAnother alternative would be to change the inheritance hierarchy by introducing a mid layer of interfaces -- DictionaryBasedInvertedIndexCreator, RawValueBasedInvertedIndexCreator. Move all the dictId based APIs to former and raw value based to latter", "author": "siddharthteotia", "createdAt": "2020-05-04T16:33:23Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/RangeIndexCreator.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv;\n+\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.Arrays;\n+import it.unimi.dsi.fastutil.Swapper;\n+import it.unimi.dsi.fastutil.ints.IntComparator;\n+import java.io.BufferedOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.Constants;\n+import org.apache.pinot.core.query.utils.Pair;\n+import org.apache.pinot.core.segment.creator.InvertedIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.BITMAP_RANGE_INDEX_FILE_EXTENSION;\n+\n+\n+/**\n+ * Implementation of {@link InvertedIndexCreator} that uses off-heap memory.\n+ * <p>We use 2 passes to create the range index.\n+ * <ul>\n+ *\n+ *   <li>\n+ *     A\n+ *   </li>\n+ *   <li>\n+ *     In the first pass (adding values phase), when add() method is called, store the raw values into the forward index\n+ *     value buffer (for multi-valued column also store number of values for each docId into forward index length\n+ *     buffer). We also compute the inverted index length for each dictId while adding values.\n+ *   </li>\n+ *   <li>\n+ *     In the second pass (processing values phase), when seal() method is called, all the dictIds should already been\n+ *     added. We first reorder the values into the inverted index buffers by going over the dictIds in forward index\n+ *     value buffer (for multi-valued column we also need forward index length buffer to get the docId for each dictId).\n+ *     <p>Once we have the inverted index buffers, we simply go over them and create the bitmap for each dictId and\n+ *     serialize them into a file.\n+ *   </li>\n+ * </ul>\n+ * <p>Based on the number of values we need to store, we use direct memory or MMap file to allocate the buffer.\n+ */\n+public final class RangeIndexCreator implements InvertedIndexCreator {", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MTAyNw==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r422461027", "bodyText": "yes, Jackie and I discussed about it and concluded the same. Jackie will clean this up at some point.", "author": "kishoreg", "createdAt": "2020-05-09T06:54:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzQ4MA==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419567480", "bodyText": "This doesn't sound right. We don't create a bitmap for each dictId. I believe there is a bitmap for a contiguous range of dictIds", "author": "siddharthteotia", "createdAt": "2020-05-04T16:33:27Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/RangeIndexCreator.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv;\n+\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.Arrays;\n+import it.unimi.dsi.fastutil.Swapper;\n+import it.unimi.dsi.fastutil.ints.IntComparator;\n+import java.io.BufferedOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.Constants;\n+import org.apache.pinot.core.query.utils.Pair;\n+import org.apache.pinot.core.segment.creator.InvertedIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.BITMAP_RANGE_INDEX_FILE_EXTENSION;\n+\n+\n+/**\n+ * Implementation of {@link InvertedIndexCreator} that uses off-heap memory.\n+ * <p>We use 2 passes to create the range index.\n+ * <ul>\n+ *\n+ *   <li>\n+ *     A\n+ *   </li>\n+ *   <li>\n+ *     In the first pass (adding values phase), when add() method is called, store the raw values into the forward index\n+ *     value buffer (for multi-valued column also store number of values for each docId into forward index length\n+ *     buffer). We also compute the inverted index length for each dictId while adding values.\n+ *   </li>\n+ *   <li>\n+ *     In the second pass (processing values phase), when seal() method is called, all the dictIds should already been\n+ *     added. We first reorder the values into the inverted index buffers by going over the dictIds in forward index\n+ *     value buffer (for multi-valued column we also need forward index length buffer to get the docId for each dictId).\n+ *     <p>Once we have the inverted index buffers, we simply go over them and create the bitmap for each dictId and", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MTA2MA==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r422461060", "bodyText": "sorry, this is copy paste error from bitmap index", "author": "kishoreg", "createdAt": "2020-05-09T06:55:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzUxNQ==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419567515", "bodyText": "You mean store the dictionary Ids?", "author": "siddharthteotia", "createdAt": "2020-05-04T16:33:30Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/RangeIndexCreator.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv;\n+\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.Arrays;\n+import it.unimi.dsi.fastutil.Swapper;\n+import it.unimi.dsi.fastutil.ints.IntComparator;\n+import java.io.BufferedOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.Constants;\n+import org.apache.pinot.core.query.utils.Pair;\n+import org.apache.pinot.core.segment.creator.InvertedIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.BITMAP_RANGE_INDEX_FILE_EXTENSION;\n+\n+\n+/**\n+ * Implementation of {@link InvertedIndexCreator} that uses off-heap memory.\n+ * <p>We use 2 passes to create the range index.\n+ * <ul>\n+ *\n+ *   <li>\n+ *     A\n+ *   </li>\n+ *   <li>\n+ *     In the first pass (adding values phase), when add() method is called, store the raw values into the forward index", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzU3NQ==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419567575", "bodyText": "remove?", "author": "siddharthteotia", "createdAt": "2020-05-04T16:33:35Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/PredicateEvaluator.java", "diffHunk": "@@ -22,6 +22,8 @@\n \n \n public interface PredicateEvaluator {\n+", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzYxNg==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419567616", "bodyText": "Let's add a TODO for supporting this on raw columns", "author": "siddharthteotia", "createdAt": "2020-05-04T16:33:39Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/RangeFilterOperator.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.filter;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.pinot.core.common.BlockDocIdIterator;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.common.Predicate;\n+import org.apache.pinot.core.operator.blocks.FilterBlock;\n+import org.apache.pinot.core.operator.dociditerators.MVScanDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.SVScanDocIdIterator;\n+import org.apache.pinot.core.operator.docidsets.BitmapDocIdSet;\n+import org.apache.pinot.core.operator.docidsets.FilterBlockDocIdSet;\n+import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluator;\n+import org.apache.pinot.core.operator.filter.predicate.RangePredicateEvaluatorFactory;\n+import org.apache.pinot.core.segment.index.readers.RangeIndexReader;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+\n+public class RangeFilterOperator extends BaseFilterOperator {\n+  private static final String OPERATOR_NAME = \"RangeFilterOperator\";\n+\n+  private final PredicateEvaluator _predicateEvaluator;\n+  private final DataSource _dataSource;\n+  private final int _startDocId;\n+  private final int _endDocId;\n+  private final boolean _exclusive;\n+\n+  public RangeFilterOperator(PredicateEvaluator predicateEvaluator, DataSource dataSource, int startDocId,\n+      int endDocId) {\n+    // NOTE:\n+    // Predicate that is always evaluated as true or false should not be passed into the BitmapBasedFilterOperator for\n+    // performance concern.\n+    // If predicate is always evaluated as true, use MatchAllFilterOperator; if predicate is always evaluated as false,\n+    // use EmptyFilterOperator.\n+    Preconditions.checkArgument(!predicateEvaluator.isAlwaysTrue() && !predicateEvaluator.isAlwaysFalse());\n+\n+    _predicateEvaluator = predicateEvaluator;\n+    _dataSource = dataSource;\n+    _startDocId = startDocId;\n+    _endDocId = endDocId;\n+    _exclusive = predicateEvaluator.isExclusive();\n+  }\n+\n+  @Override\n+  protected FilterBlock getNextBlock() {\n+\n+    //only dictionary based is supported for now", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzY1MA==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419567650", "bodyText": "please add javadoc", "author": "siddharthteotia", "createdAt": "2020-05-04T16:33:42Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/RangeFilterOperator.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.filter;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.pinot.core.common.BlockDocIdIterator;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.common.Predicate;\n+import org.apache.pinot.core.operator.blocks.FilterBlock;\n+import org.apache.pinot.core.operator.dociditerators.MVScanDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.SVScanDocIdIterator;\n+import org.apache.pinot.core.operator.docidsets.BitmapDocIdSet;\n+import org.apache.pinot.core.operator.docidsets.FilterBlockDocIdSet;\n+import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluator;\n+import org.apache.pinot.core.operator.filter.predicate.RangePredicateEvaluatorFactory;\n+import org.apache.pinot.core.segment.index.readers.RangeIndexReader;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+\n+public class RangeFilterOperator extends BaseFilterOperator {", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzkxMg==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419567912", "bodyText": "Why only dictionary encoded? For raw columns, each range could be a range of start and end raw values instead of dictIds. The data structure could be sorted on start raw values (just like it is on start dictIds)", "author": "siddharthteotia", "createdAt": "2020-05-04T16:34:04Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/FilterOperatorUtils.java", "diffHunk": "@@ -54,6 +54,12 @@ public static BaseFilterOperator getLeafFilterOperator(PredicateEvaluator predic\n \n     Predicate.Type predicateType = predicateEvaluator.getPredicateType();\n \n+    //Only for dictionary encoded columns and offline data sources\n+    if (predicateType == Predicate.Type.RANGE && dataSource.getDictionary() != null", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3MzgxNg==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419573816", "bodyText": "Let's add a TODO", "author": "siddharthteotia", "createdAt": "2020-05-04T16:43:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2ODIxMw==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419568213", "bodyText": "Please add javadoc", "author": "siddharthteotia", "createdAt": "2020-05-04T16:34:32Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/docvaliterators/DictionaryBasedSingleValueIterator.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.docvaliterators;\n+\n+import org.apache.pinot.core.common.BlockSingleValIterator;\n+import org.apache.pinot.core.io.reader.ReaderContext;\n+import org.apache.pinot.core.io.reader.SingleColumnSingleValueReader;\n+import org.apache.pinot.core.segment.index.readers.Dictionary;\n+\n+\n+@SuppressWarnings(\"unchecked\")\n+public final class DictionaryBasedSingleValueIterator extends BlockSingleValIterator {", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2ODMxMw==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419568313", "bodyText": "Please add javadoc", "author": "siddharthteotia", "createdAt": "2020-05-04T16:34:40Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/docvaliterators/DictionaryBasedMultiValueIterator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.docvaliterators;\n+\n+import org.apache.pinot.core.common.BlockMultiValIterator;\n+import org.apache.pinot.core.common.BlockSingleValIterator;\n+import org.apache.pinot.core.io.reader.ReaderContext;\n+import org.apache.pinot.core.io.reader.SingleColumnMultiValueReader;\n+import org.apache.pinot.core.io.reader.SingleColumnSingleValueReader;\n+import org.apache.pinot.core.segment.index.readers.Dictionary;\n+\n+\n+@SuppressWarnings(\"unchecked\")\n+public final class DictionaryBasedMultiValueIterator extends BlockMultiValIterator {", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2ODg0NA==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419568844", "bodyText": "Also, why do we have to implement two new iterators?", "author": "siddharthteotia", "createdAt": "2020-05-04T16:35:28Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/docvaliterators/DictionaryBasedSingleValueIterator.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.docvaliterators;\n+\n+import org.apache.pinot.core.common.BlockSingleValIterator;\n+import org.apache.pinot.core.io.reader.ReaderContext;\n+import org.apache.pinot.core.io.reader.SingleColumnSingleValueReader;\n+import org.apache.pinot.core.segment.index.readers.Dictionary;\n+\n+\n+@SuppressWarnings(\"unchecked\")\n+public final class DictionaryBasedSingleValueIterator extends BlockSingleValIterator {\n+\n+  private final SingleColumnSingleValueReader _reader;\n+  private final int _numDocs;\n+  private final ReaderContext _context;\n+  private final Dictionary _dictionary;\n+\n+  private int _nextDocId;\n+\n+  public DictionaryBasedSingleValueIterator(SingleColumnSingleValueReader reader, Dictionary dictionary, int numDocs) {", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3MTg4OA==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r419571888", "bodyText": "This is not about optimization. Won't this impact correctness?\nFor a given startDictId and endDictId, we find the matching ranges represented by startRangeId and endRangeId.\nSome/all ranges between these could be a full match and some/all could be a partial match. Right?\nI understand that all full matches can be ORed but how can we assume that everything from startRangeId + 1 to endRangeId - 1 will be a full match?", "author": "siddharthteotia", "createdAt": "2020-05-04T16:40:18Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/RangeFilterOperator.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.filter;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.pinot.core.common.BlockDocIdIterator;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.common.Predicate;\n+import org.apache.pinot.core.operator.blocks.FilterBlock;\n+import org.apache.pinot.core.operator.dociditerators.MVScanDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.SVScanDocIdIterator;\n+import org.apache.pinot.core.operator.docidsets.BitmapDocIdSet;\n+import org.apache.pinot.core.operator.docidsets.FilterBlockDocIdSet;\n+import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluator;\n+import org.apache.pinot.core.operator.filter.predicate.RangePredicateEvaluatorFactory;\n+import org.apache.pinot.core.segment.index.readers.RangeIndexReader;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+\n+public class RangeFilterOperator extends BaseFilterOperator {\n+  private static final String OPERATOR_NAME = \"RangeFilterOperator\";\n+\n+  private final PredicateEvaluator _predicateEvaluator;\n+  private final DataSource _dataSource;\n+  private final int _startDocId;\n+  private final int _endDocId;\n+  private final boolean _exclusive;\n+\n+  public RangeFilterOperator(PredicateEvaluator predicateEvaluator, DataSource dataSource, int startDocId,\n+      int endDocId) {\n+    // NOTE:\n+    // Predicate that is always evaluated as true or false should not be passed into the BitmapBasedFilterOperator for\n+    // performance concern.\n+    // If predicate is always evaluated as true, use MatchAllFilterOperator; if predicate is always evaluated as false,\n+    // use EmptyFilterOperator.\n+    Preconditions.checkArgument(!predicateEvaluator.isAlwaysTrue() && !predicateEvaluator.isAlwaysFalse());\n+\n+    _predicateEvaluator = predicateEvaluator;\n+    _dataSource = dataSource;\n+    _startDocId = startDocId;\n+    _endDocId = endDocId;\n+    _exclusive = predicateEvaluator.isExclusive();\n+  }\n+\n+  @Override\n+  protected FilterBlock getNextBlock() {\n+\n+    //only dictionary based is supported for now\n+    Preconditions.checkState(_predicateEvaluator instanceof RangePredicateEvaluatorFactory.OfflineDictionaryBasedRangePredicateEvaluator);\n+\n+    RangePredicateEvaluatorFactory.OfflineDictionaryBasedRangePredicateEvaluator evaluator =\n+        (RangePredicateEvaluatorFactory.OfflineDictionaryBasedRangePredicateEvaluator) _predicateEvaluator;\n+\n+    RangeIndexReader rangeIndexReader = (RangeIndexReader) _dataSource.getRangeIndex();\n+    int startRangeId = rangeIndexReader.findRangeId(evaluator.getStartDictId());\n+    int endRangeId = rangeIndexReader.findRangeId(evaluator.getEndDictId());\n+    //Handle Matching Ranges - some ranges match fully but some partially\n+    //below code assumes first and last range always match partially which may not be the case always //todo: optimize it", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MTIwNQ==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r422461205", "bodyText": "why not?", "author": "kishoreg", "createdAt": "2020-05-09T06:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3MTg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU2MjQ3Nw==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r422562477", "bodyText": "This is very confusing. _docIdBuffer stores docIds. What does _docIdValueBuffer store?", "author": "siddharthteotia", "createdAt": "2020-05-10T00:03:55Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/RangeIndexCreator.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv;\n+\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.Arrays;\n+import it.unimi.dsi.fastutil.Swapper;\n+import it.unimi.dsi.fastutil.ints.IntComparator;\n+import java.io.BufferedOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.Constants;\n+import org.apache.pinot.core.query.utils.Pair;\n+import org.apache.pinot.core.segment.creator.InvertedIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.MetricFieldSpec;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.BITMAP_RANGE_INDEX_FILE_EXTENSION;\n+\n+\n+/**\n+ * Implementation of {@link InvertedIndexCreator} that uses off-heap memory.\n+ * <p>We use 2 passes to create the range index.\n+ * <ul>\n+ *\n+ *   <li>\n+ *     A\n+ *   </li>\n+ *   <li>\n+ *     In the first pass (adding values phase), when add() method is called, store the raw values into the forward index\n+ *     value buffer (for multi-valued column also store number of values for each docId into forward index length\n+ *     buffer). We also compute the inverted index length for each dictId while adding values.\n+ *   </li>\n+ *   <li>\n+ *     In the second pass (processing values phase), when seal() method is called, all the dictIds should already been\n+ *     added. We first reorder the values into the inverted index buffers by going over the dictIds in forward index\n+ *     value buffer (for multi-valued column we also need forward index length buffer to get the docId for each dictId).\n+ *     <p>Once we have the inverted index buffers, we simply go over them and create the bitmap for each dictId and\n+ *     serialize them into a file.\n+ *   </li>\n+ * </ul>\n+ * <p>Based on the number of values we need to store, we use direct memory or MMap file to allocate the buffer.\n+ */\n+public final class RangeIndexCreator implements InvertedIndexCreator {\n+\n+  private static final int RANGE_INDEX_VERSION = 1;\n+\n+  // Use MMapBuffer if the value buffer size is larger than 2G\n+  private static final int NUM_VALUES_THRESHOLD_FOR_MMAP_BUFFER = 500_000_000;\n+  private static final int DEFAULT_NUM_RANGES = 20;\n+\n+  private static final String FORWARD_INDEX_VALUE_BUFFER_SUFFIX = \".fwd.idx.val.buf\";\n+  private static final String DOC_ID_VALUE_BUFFER_SUFFIX = \".doc.id.val.buf\";\n+\n+  private final File _invertedIndexFile;\n+  private final File _forwardIndexValueBufferFile;\n+  private final File _docIdBufferFileForSorting;\n+  private final int _numValues;\n+  private final boolean _useMMapBuffer;\n+\n+  // Forward index buffers (from docId to dictId)\n+  private int _nextDocId;\n+  private PinotDataBuffer _forwardIndexValueBuffer;\n+  private NumberValueBuffer _valueBuffer;\n+  //for sorting\n+  private PinotDataBuffer _docIdValueBuffer;\n+  private IntValueBuffer _docIdBuffer;", "originalCommit": "af8ef5d42ccd2f62f08afb465a5d3765ba446e31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e8d3284f3ce57c7ac5f649b97405aff420e8cbce", "url": "https://github.com/apache/pinot/commit/e8d3284f3ce57c7ac5f649b97405aff420e8cbce", "message": "Adding comments", "committedDate": "2020-05-10T23:48:58Z", "type": "commit"}, {"oid": "e8d3284f3ce57c7ac5f649b97405aff420e8cbce", "url": "https://github.com/apache/pinot/commit/e8d3284f3ce57c7ac5f649b97405aff420e8cbce", "message": "Adding comments", "committedDate": "2020-05-10T23:48:58Z", "type": "forcePushed"}, {"oid": "34267be0e7290980418128cdcb9ffa1880f0ccd7", "url": "https://github.com/apache/pinot/commit/34267be0e7290980418128cdcb9ffa1880f0ccd7", "message": "Make range index to store start of all ranges and end of last range", "committedDate": "2020-05-11T08:48:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MTMxMA==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r423161310", "bodyText": "Let's rename _docIdValueBuffer to _docIdBuffer and _docIdBuffer to _docIdBufferWrapperForSorting?", "author": "siddharthteotia", "createdAt": "2020-05-11T16:23:25Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/RangeIndexCreator.java", "diffHunk": "@@ -0,0 +1,506 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv;\n+\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.Arrays;\n+import it.unimi.dsi.fastutil.Swapper;\n+import it.unimi.dsi.fastutil.ints.IntComparator;\n+import java.io.BufferedOutputStream;\n+import java.io.Closeable;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.query.utils.Pair;\n+import org.apache.pinot.core.segment.creator.InvertedIndexCreator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentColumnarIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.BITMAP_RANGE_INDEX_FILE_EXTENSION;\n+\n+\n+/**\n+ * Implementation of {@link InvertedIndexCreator} that uses off-heap memory.\n+ * <p>We use 2 passes to create the range index.\n+ * <ul>\n+ *\n+ *   <li>\n+ *     A\n+ *   </li>\n+ *   <li>\n+ *     In the first pass (adding values phase), when add() method is called, store the raw values into the\n+ *     value buffer (for multi-valued column we flatten the values).\n+ *     We also store the corresponding docId in docIdBuffer which will be sorted in the next phase based on the value in valueBuffer.\n+ *\n+ *   </li>\n+ *   <li>\n+ *     In the second pass (processing values phase), when seal() method is called, we sort the docIdBuffer based on the value in valueBuffer.\n+ *     We then iterate over the sorted docIdBuffer and create ranges such that each range comprises of _numDocsPerRange.\n+ *     While\n+ *   </li>\n+ * </ul>\n+ */\n+public final class RangeIndexCreator implements InvertedIndexCreator {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RangeIndexCreator.class);\n+\n+  //This will dump the content of temp buffers and ranges\n+  private static final boolean TRACE = false;\n+\n+  private static final int RANGE_INDEX_VERSION = 1;\n+\n+  private static final int DEFAULT_NUM_RANGES = 20;\n+\n+  private static final String VALUE_BUFFER_SUFFIX = \"val.buf\";\n+  private static final String DOC_ID_VALUE_BUFFER_SUFFIX = \".doc.id.buf\";\n+\n+  private final File _rangeIndexFile;\n+\n+  private final File _tempValueBufferFile;\n+  private PinotDataBuffer _tempValueBuffer;\n+  private NumberValueBuffer _numberValueBuffer;\n+\n+  private final File _tempDocIdBufferFile;\n+  private PinotDataBuffer _docIdValueBuffer;", "originalCommit": "34267be0e7290980418128cdcb9ffa1880f0ccd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2OTMzMA==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r423169330", "bodyText": "Let'a add comments explaining purpose of each buffer.", "author": "siddharthteotia", "createdAt": "2020-05-11T16:36:15Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/RangeIndexCreator.java", "diffHunk": "@@ -0,0 +1,506 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv;\n+\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.Arrays;\n+import it.unimi.dsi.fastutil.Swapper;\n+import it.unimi.dsi.fastutil.ints.IntComparator;\n+import java.io.BufferedOutputStream;\n+import java.io.Closeable;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.query.utils.Pair;\n+import org.apache.pinot.core.segment.creator.InvertedIndexCreator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentColumnarIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.BITMAP_RANGE_INDEX_FILE_EXTENSION;\n+\n+\n+/**\n+ * Implementation of {@link InvertedIndexCreator} that uses off-heap memory.\n+ * <p>We use 2 passes to create the range index.\n+ * <ul>\n+ *\n+ *   <li>\n+ *     A\n+ *   </li>\n+ *   <li>\n+ *     In the first pass (adding values phase), when add() method is called, store the raw values into the\n+ *     value buffer (for multi-valued column we flatten the values).\n+ *     We also store the corresponding docId in docIdBuffer which will be sorted in the next phase based on the value in valueBuffer.\n+ *\n+ *   </li>\n+ *   <li>\n+ *     In the second pass (processing values phase), when seal() method is called, we sort the docIdBuffer based on the value in valueBuffer.\n+ *     We then iterate over the sorted docIdBuffer and create ranges such that each range comprises of _numDocsPerRange.\n+ *     While\n+ *   </li>\n+ * </ul>\n+ */\n+public final class RangeIndexCreator implements InvertedIndexCreator {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RangeIndexCreator.class);\n+\n+  //This will dump the content of temp buffers and ranges\n+  private static final boolean TRACE = false;\n+\n+  private static final int RANGE_INDEX_VERSION = 1;\n+\n+  private static final int DEFAULT_NUM_RANGES = 20;\n+\n+  private static final String VALUE_BUFFER_SUFFIX = \"val.buf\";\n+  private static final String DOC_ID_VALUE_BUFFER_SUFFIX = \".doc.id.buf\";\n+\n+  private final File _rangeIndexFile;\n+\n+  private final File _tempValueBufferFile;", "originalCommit": "34267be0e7290980418128cdcb9ffa1880f0ccd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MDQyOQ==", "url": "https://github.com/apache/pinot/pull/5240#discussion_r423170429", "bodyText": "Let's add a diagram here showing the contents of _numberValueBuffer and _docIdBuffer before and after sorting to explain the process.", "author": "siddharthteotia", "createdAt": "2020-05-11T16:38:03Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/RangeIndexCreator.java", "diffHunk": "@@ -0,0 +1,506 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv;\n+\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.Arrays;\n+import it.unimi.dsi.fastutil.Swapper;\n+import it.unimi.dsi.fastutil.ints.IntComparator;\n+import java.io.BufferedOutputStream;\n+import java.io.Closeable;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.query.utils.Pair;\n+import org.apache.pinot.core.segment.creator.InvertedIndexCreator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentColumnarIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.google.common.base.Charsets.UTF_8;\n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.BITMAP_RANGE_INDEX_FILE_EXTENSION;\n+\n+\n+/**\n+ * Implementation of {@link InvertedIndexCreator} that uses off-heap memory.\n+ * <p>We use 2 passes to create the range index.\n+ * <ul>\n+ *\n+ *   <li>\n+ *     A\n+ *   </li>\n+ *   <li>\n+ *     In the first pass (adding values phase), when add() method is called, store the raw values into the\n+ *     value buffer (for multi-valued column we flatten the values).\n+ *     We also store the corresponding docId in docIdBuffer which will be sorted in the next phase based on the value in valueBuffer.\n+ *\n+ *   </li>\n+ *   <li>\n+ *     In the second pass (processing values phase), when seal() method is called, we sort the docIdBuffer based on the value in valueBuffer.\n+ *     We then iterate over the sorted docIdBuffer and create ranges such that each range comprises of _numDocsPerRange.\n+ *     While\n+ *   </li>\n+ * </ul>\n+ */\n+public final class RangeIndexCreator implements InvertedIndexCreator {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(RangeIndexCreator.class);\n+\n+  //This will dump the content of temp buffers and ranges\n+  private static final boolean TRACE = false;\n+\n+  private static final int RANGE_INDEX_VERSION = 1;\n+\n+  private static final int DEFAULT_NUM_RANGES = 20;\n+\n+  private static final String VALUE_BUFFER_SUFFIX = \"val.buf\";\n+  private static final String DOC_ID_VALUE_BUFFER_SUFFIX = \".doc.id.buf\";\n+\n+  private final File _rangeIndexFile;\n+\n+  private final File _tempValueBufferFile;\n+  private PinotDataBuffer _tempValueBuffer;\n+  private NumberValueBuffer _numberValueBuffer;\n+\n+  private final File _tempDocIdBufferFile;\n+  private PinotDataBuffer _docIdValueBuffer;\n+  private IntValueBuffer _docIdBuffer;\n+\n+  private final int _numValues;\n+  private int _nextDocId;\n+  private int _nextValueId;\n+  private int _numDocsPerRange;\n+  private FieldSpec.DataType _valueType;\n+\n+  public RangeIndexCreator(File indexDir, FieldSpec fieldSpec, FieldSpec.DataType valueType, int numRanges,\n+      int numDocsPerRange, int numDocs, int numValues)\n+      throws IOException {\n+    _valueType = valueType;\n+    String columnName = fieldSpec.getName();\n+    _rangeIndexFile = new File(indexDir, columnName + BITMAP_RANGE_INDEX_FILE_EXTENSION);\n+    _tempValueBufferFile = new File(indexDir, columnName + VALUE_BUFFER_SUFFIX);\n+    _tempDocIdBufferFile = new File(indexDir, columnName + DOC_ID_VALUE_BUFFER_SUFFIX);\n+    _numValues = fieldSpec.isSingleValueField() ? numDocs : numValues;\n+    int valueSize = valueType.size();\n+    try {\n+      //use DEFAULT_NUM_RANGES if numRanges is not set\n+      if (numRanges < 0) {\n+        numRanges = DEFAULT_NUM_RANGES;\n+      }\n+      if (numDocsPerRange < 0) {\n+        _numDocsPerRange = (int) Math.ceil(_numValues / numRanges);\n+      }\n+\n+      //Value buffer to store the actual values added\n+      _tempValueBuffer = createTempBuffer((long) _numValues * valueSize, _tempValueBufferFile);\n+\n+      switch (_valueType) {\n+        case INT:\n+          _numberValueBuffer = new IntValueBuffer(_tempValueBuffer);\n+          break;\n+        case FLOAT:\n+          _numberValueBuffer = new FloatValueBuffer(_tempValueBuffer);\n+          break;\n+        case LONG:\n+          _numberValueBuffer = new LongValueBuffer(_tempValueBuffer);\n+          break;\n+        case DOUBLE:\n+          _numberValueBuffer = new DoubleValueBuffer(_tempValueBuffer);\n+          break;\n+        default:\n+          throw new UnsupportedOperationException(\"Range index is not supported for columns of data type:\" + valueType);\n+      }\n+\n+      //docId  Buffer\n+      _docIdValueBuffer = createTempBuffer((long) _numValues * Integer.BYTES, _tempDocIdBufferFile);\n+      _docIdBuffer = new IntValueBuffer(_docIdValueBuffer);\n+    } catch (Exception e) {\n+      destroyBuffer(_tempValueBuffer, _tempValueBufferFile);\n+      destroyBuffer(_tempValueBuffer, _tempDocIdBufferFile);\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public void add(int dictId) {\n+    _numberValueBuffer.put(_nextDocId, dictId);\n+    _docIdBuffer.put(_nextDocId, _nextDocId);\n+    _nextDocId = _nextDocId + 1;\n+  }\n+\n+  @Override\n+  public void add(int[] dictIds, int length) {\n+    for (int i = 0; i < length; i++) {\n+      int dictId = dictIds[i];\n+      _numberValueBuffer.put(_nextValueId, dictId);\n+      _docIdBuffer.put(_nextValueId, _nextDocId);\n+      _nextValueId = _nextValueId + 1;\n+    }\n+    _nextDocId = _nextDocId + 1;\n+  }\n+\n+  @Override\n+  public void addDoc(Object document, int docIdCounter) {\n+    throw new IllegalStateException(\"Bitmap inverted index creator does not support Object type currently\");\n+  }\n+\n+  @Override\n+  public void seal()\n+      throws IOException {\n+    if (TRACE) {\n+      LOGGER.info(\"Before sorting\");\n+      dump();\n+    }\n+\n+    //sort the value buffer, change the docId buffer to maintain the mapping", "originalCommit": "34267be0e7290980418128cdcb9ffa1880f0ccd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5872b712522691f9a2b9e6bc3be0a179dc9eed18", "url": "https://github.com/apache/pinot/commit/5872b712522691f9a2b9e6bc3be0a179dc9eed18", "message": "Adding comments and fixing broken tests", "committedDate": "2020-05-11T19:57:14Z", "type": "commit"}, {"oid": "66eac58d83ce49208640006c04b70eea5e5843af", "url": "https://github.com/apache/pinot/commit/66eac58d83ce49208640006c04b70eea5e5843af", "message": "More comments", "committedDate": "2020-05-11T22:22:43Z", "type": "commit"}]}