{"pr_number": 5712, "pr_title": "Add startReplaceSegments, endReplaceSegments controller API", "pr_createdAt": "2020-07-17T16:55:11Z", "pr_url": "https://github.com/apache/pinot/pull/5712", "timeline": [{"oid": "f0e8938c2e149d5044989e79e19c1a690a1415b2", "url": "https://github.com/apache/pinot/commit/f0e8938c2e149d5044989e79e19c1a690a1415b2", "message": "Add startBatchUpload, endBatchUpload controller API\n\nThese APIs are the building block to achieve atomically replacing\nm segments into n segments. Segment selection algorithm will be the\nnext PR.\n\n1. Added startBatchUplad, endBatchUPload controller API\n2. Added unit tests", "committedDate": "2020-07-17T17:01:33Z", "type": "forcePushed"}, {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f", "url": "https://github.com/apache/pinot/commit/66b4f190c784bf2d9ec50ffbca5d7311b997d91f", "message": "Add startBatchUpload, endBatchUpload controller API\n\nThese APIs are the building block to achieve atomically replacing\nm segments into n segments. Segment selection algorithm will be the\nnext PR.\n\n1. Added startBatchUplad, endBatchUPload controller API\n2. Added unit tests", "committedDate": "2020-07-17T23:04:22Z", "type": "commit"}, {"oid": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f", "url": "https://github.com/apache/pinot/commit/66b4f190c784bf2d9ec50ffbca5d7311b997d91f", "message": "Add startBatchUpload, endBatchUpload controller API\n\nThese APIs are the building block to achieve atomically replacing\nm segments into n segments. Segment selection algorithm will be the\nnext PR.\n\n1. Added startBatchUplad, endBatchUPload controller API\n2. Added unit tests", "committedDate": "2020-07-17T23:04:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyMTA3Mw==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456721073", "bodyText": "Can segmentsFromStr be null?\nAlso avoid using the regex split\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  String segmentsFromStr = value.get(0);\n          \n          \n            \n                  List<String> segmentsFrom = (segmentsFromStr == null || segmentsFromStr.length() == 0) ? new ArrayList<>()\n          \n          \n            \n                      : Arrays.asList(value.get(0).split(COMMA_SEPARATOR));\n          \n          \n            \n                  List<String> segmentsTo = Arrays.asList(value.get(1).split(COMMA_SEPARATOR));\n          \n          \n            \n                  List<String> segmentsFrom = Arrays.asList(StringUtils.split(value.get(0), ','));\n          \n          \n            \n                  List<String> segmentsTo = Arrays.asList(StringUtils.split(value.get(1), ','));", "author": "Jackie-Jiang", "createdAt": "2020-07-18T00:06:01Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/lineage/SegmentLineage.java", "diffHunk": "@@ -108,7 +120,9 @@ public static SegmentLineage fromZNRecord(ZNRecord record) {\n       String lineageId = listField.getKey();\n       List<String> value = listField.getValue();\n       Preconditions.checkState(value.size() == 4);\n-      List<String> segmentsFrom = Arrays.asList(value.get(0).split(COMMA_SEPARATOR));\n+      String segmentsFromStr = value.get(0);\n+      List<String> segmentsFrom = (segmentsFromStr == null || segmentsFromStr.length() == 0) ? new ArrayList<>()\n+          : Arrays.asList(value.get(0).split(COMMA_SEPARATOR));\n       List<String> segmentsTo = Arrays.asList(value.get(1).split(COMMA_SEPARATOR));", "originalCommit": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyNTM5Mw==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457825393", "bodyText": "changed to StringUtils.split().", "author": "snleee", "createdAt": "2020-07-21T04:13:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyMTA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyMTgxMg==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456721812", "bodyText": "Keep only String addLineageEntry(LineageEntry lineageEntry) or void addLineageEntry(String lineageEntryId, LineageEntry lineageEntry), don't keep both because it will be confusing. In other world, always generate UUID inside or outside of this class.\nMy suggestion is keeping String addLineageEntry(LineageEntry lineageEntry), you can check existence of the lineageId (or not because UUID collision change is too low)\nIn order to update the lineage entry, you can add a method void updateLineageEntry(String lineageEntryId, LineageEntry lineageEntry)", "author": "Jackie-Jiang", "createdAt": "2020-07-18T00:10:33Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/lineage/SegmentLineage.java", "diffHunk": "@@ -70,6 +71,17 @@ public String addLineageEntry(LineageEntry lineageEntry) {\n     return lineageId;\n   }\n \n+  /**\n+   * Add lineage entry to the segment lineage metadata with the given lineage entry id\n+   * @param lineageEntryId the id for the lineage entry\n+   * @param lineageEntry a lineage entry\n+   * @return the id for the input lineage entry for the access\n+   */\n+  public String addLineageEntry(String lineageEntryId, LineageEntry lineageEntry) {", "originalCommit": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzODgzNQ==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457838835", "bodyText": "One reason I added void addLineageEntry(String lineageEntryId, LineageEntry lineageEntry) was because there's no easy way to pass lineageEntryId outside of the retry policy block. (lineageEntryId  is generated within retry function and it needs to be passed back to the top caller)\nDue to the above reason, I have removed String addLineageEntry(LineageEntry lineageEntry) and kept void addLineageEntry(String lineageEntryId, LineageEntry lineageEntry).\nI also added void updateLineageEntry(String lineageEntryId, LineageEntry lineageEntry)", "author": "snleee", "createdAt": "2020-07-21T05:06:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyMTgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyMjM5Mw==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456722393", "bodyText": "Any reason introducing this object? I feel it will be easier to use if we directly use string batch id instead of json batch id", "author": "Jackie-Jiang", "createdAt": "2020-07-18T00:13:55Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/BatchId.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+\n+public class BatchId {", "originalCommit": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyNTc0Mg==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457825742", "bodyText": "removed", "author": "snleee", "createdAt": "2020-07-21T04:15:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyMjM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNDU1MQ==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456724551", "bodyText": "Put default or check they cannot be null?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T00:27:01Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/StartBatchUploadRequest.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.List;\n+\n+\n+public class StartBatchUploadRequest {\n+  private List<String> _segmentsFrom;\n+  private List<String> _segmentsTo;\n+\n+  public StartBatchUploadRequest(@JsonProperty(\"segmentsFrom\") List<String> segmentsFrom,", "originalCommit": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg0Mjg2OA==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457842868", "bodyText": "added default & null check", "author": "snleee", "createdAt": "2020-07-21T05:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNDU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNDYxNg==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456724616", "bodyText": "You can directly put StartBatchUploadRequest as the parameter\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr, String body)\n          \n          \n            \n                  @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr, StartBatchUploadRequest request)", "author": "Jackie-Jiang", "createdAt": "2020-07-18T00:27:29Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentUploadDownloadRestletResource.java", "diffHunk": "@@ -455,6 +459,45 @@ public void uploadSegmentAsMultiPartV2(FormDataMultiPart multiPart,\n     }\n   }\n \n+  @POST\n+  @Path(\"segments/{tableName}/startBatchUpload\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Start the batch upload\", notes = \"Start the batch upload\")\n+  public Response startBatchUpload(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr, String body)", "originalCommit": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg0MzEwNg==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457843106", "bodyText": "fixed", "author": "snleee", "createdAt": "2020-07-21T05:21:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNDYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNDY5Mg==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456724692", "bodyText": "Send batchId as query param?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T00:28:04Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentUploadDownloadRestletResource.java", "diffHunk": "@@ -455,6 +459,45 @@ public void uploadSegmentAsMultiPartV2(FormDataMultiPart multiPart,\n     }\n   }\n \n+  @POST\n+  @Path(\"segments/{tableName}/startBatchUpload\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Start the batch upload\", notes = \"Start the batch upload\")\n+  public Response startBatchUpload(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr, String body)\n+      throws IOException {\n+    StartBatchUploadRequest request = JsonUtils.stringToObject(body, StartBatchUploadRequest.class);\n+    String tableNameWithType =\n+        TableNameBuilder.forType(TableType.valueOf(tableTypeStr.toUpperCase())).tableNameWithType(tableName);\n+    try {\n+      String batchId = _pinotHelixResourceManager\n+          .startBatchUpload(tableNameWithType, request.getSegmentsFrom(), request.getSegmentsTo());\n+      return Response.ok(new BatchId(batchId)).build();\n+    } catch (Exception e) {\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.INTERNAL_SERVER_ERROR, e);\n+    }\n+  }\n+\n+  @POST\n+  @Path(\"segments/{tableName}/endBatchUpload\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"End the batch upload\", notes = \"End the batch upload\")\n+  public Response endBatchUpload(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr, String body)", "originalCommit": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg0MDI5Ng==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457840296", "bodyText": "fixed", "author": "snleee", "createdAt": "2020-07-21T05:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNDY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNTA3OA==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456725078", "bodyText": "Perform null check within the request?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T00:30:39Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,190 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    if (segmentsTo == null || segmentsTo.isEmpty()) {\n+      String errorMsg = String\n+          .format(\"'segmentsTo' cannot be null or empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    // segmentsFrom can be empty in case of the initial upload\n+    if (segmentsFrom == null) {", "originalCommit": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNTE0Ng==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456725146", "bodyText": "Can be simplified with Preconditions.checkArgument()", "author": "Jackie-Jiang", "createdAt": "2020-07-18T00:31:09Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,190 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    if (segmentsTo == null || segmentsTo.isEmpty()) {", "originalCommit": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg0NTg0Mg==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457845842", "bodyText": "I have changed all checks to use Preconditions", "author": "snleee", "createdAt": "2020-07-21T05:30:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNTE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNTIxNw==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456725217", "bodyText": "Can be simplified with Preconditions.checkArgument(), same for other validation checks", "author": "Jackie-Jiang", "createdAt": "2020-07-18T00:31:46Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,190 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    if (segmentsTo == null || segmentsTo.isEmpty()) {\n+      String errorMsg = String\n+          .format(\"'segmentsTo' cannot be null or empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    // segmentsFrom can be empty in case of the initial upload\n+    if (segmentsFrom == null) {\n+      segmentsFrom = new ArrayList<>();\n+    }\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    if (!segmentsForTable.containsAll(segmentsFrom)) {", "originalCommit": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNjE1MQ==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456726151", "bodyText": "For readability\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      if (lineageEntry.getSegmentsFrom().stream().anyMatch(finalSegmentsFrom::contains)) {\n          \n          \n            \n                      Preconditions.checkArgument(Collections.disjoint(lineageEntry.getSegmentsFrom(), finalSegmentsFrom), ...)", "author": "Jackie-Jiang", "createdAt": "2020-07-18T00:38:26Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,190 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    if (segmentsTo == null || segmentsTo.isEmpty()) {\n+      String errorMsg = String\n+          .format(\"'segmentsTo' cannot be null or empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    // segmentsFrom can be empty in case of the initial upload\n+    if (segmentsFrom == null) {\n+      segmentsFrom = new ArrayList<>();\n+    }\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    if (!segmentsForTable.containsAll(segmentsFrom)) {\n+      String errorMsg = String.format(\n+          \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+              + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+          segmentsForTable);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        if (segmentLineage.getLineageEntry(batchId) != null) {\n+          String errorMsg = String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear on the left side.\n+          if (lineageEntry.getSegmentsFrom().stream().anyMatch(finalSegmentsFrom::contains)) {", "originalCommit": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg0NTY1OQ==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457845659", "bodyText": "changed to Collections.disjoint", "author": "snleee", "createdAt": "2020-07-21T05:30:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNjE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNjg0MQ==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456726841", "bodyText": "Need to check both Collections.disjoint(lineageEntry.getSegmentsFrom(), segmentsTo)) and Collections.disjoint(lineageEntry.getSegmentsTo(), segmentsTo))", "author": "Jackie-Jiang", "createdAt": "2020-07-18T00:42:35Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,190 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    if (segmentsTo == null || segmentsTo.isEmpty()) {\n+      String errorMsg = String\n+          .format(\"'segmentsTo' cannot be null or empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    // segmentsFrom can be empty in case of the initial upload\n+    if (segmentsFrom == null) {\n+      segmentsFrom = new ArrayList<>();\n+    }\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    if (!segmentsForTable.containsAll(segmentsFrom)) {\n+      String errorMsg = String.format(\n+          \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+              + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+          segmentsForTable);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        if (segmentLineage.getLineageEntry(batchId) != null) {\n+          String errorMsg = String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear on the left side.\n+          if (lineageEntry.getSegmentsFrom().stream().anyMatch(finalSegmentsFrom::contains)) {\n+            String errorMsg = String.format(\n+                \"It is not allowed to merge segments that are already merged. (tableName = %s, segmentsFrom from \"\n+                    + \"existing lineage entry = %s, requested segmentsFrom = %s)\", tableNameWithType,\n+                lineageEntry.getSegmentsFrom(), finalSegmentsFrom);\n+            throw new IllegalArgumentException(errorMsg);\n+          }\n+\n+          // Check that merged segments name cannot be the same for different lineage entry\n+          if (lineageEntry.getSegmentsTo().stream().anyMatch(segmentsTo::contains)) {", "originalCommit": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg0NTcxMw==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457845713", "bodyText": "yes, we need to check both.", "author": "snleee", "createdAt": "2020-07-21T05:30:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNjg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNzY0Ng==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456727646", "bodyText": "Probably WARN? This is unexpected. Also, move this in front of the segments check", "author": "Jackie-Jiang", "createdAt": "2020-07-18T00:48:17Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,190 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    if (segmentsTo == null || segmentsTo.isEmpty()) {\n+      String errorMsg = String\n+          .format(\"'segmentsTo' cannot be null or empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    // segmentsFrom can be empty in case of the initial upload\n+    if (segmentsFrom == null) {\n+      segmentsFrom = new ArrayList<>();\n+    }\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    if (!segmentsForTable.containsAll(segmentsFrom)) {\n+      String errorMsg = String.format(\n+          \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+              + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+          segmentsForTable);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        if (segmentLineage.getLineageEntry(batchId) != null) {\n+          String errorMsg = String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear on the left side.\n+          if (lineageEntry.getSegmentsFrom().stream().anyMatch(finalSegmentsFrom::contains)) {\n+            String errorMsg = String.format(\n+                \"It is not allowed to merge segments that are already merged. (tableName = %s, segmentsFrom from \"\n+                    + \"existing lineage entry = %s, requested segmentsFrom = %s)\", tableNameWithType,\n+                lineageEntry.getSegmentsFrom(), finalSegmentsFrom);\n+            throw new IllegalArgumentException(errorMsg);\n+          }\n+\n+          // Check that merged segments name cannot be the same for different lineage entry\n+          if (lineageEntry.getSegmentsTo().stream().anyMatch(segmentsTo::contains)) {\n+            String errorMsg = String.format(\n+                \"It is not allowed to have the same segment name for merged segments. (tableName = %s, segmentsTo from \"\n+                    + \"existing lineage entry = %s, requested segmentsTo = %s)\", tableNameWithType,\n+                lineageEntry.getSegmentsTo(), segmentsTo);\n+            throw new IllegalArgumentException(errorMsg);\n+          }\n+        }\n+\n+        // Update lineage entry\n+        segmentLineage.addLineageEntry(batchId,\n+            new LineageEntry(finalSegmentsFrom, segmentsTo, LineageEntryState.IN_PROGRESS, System.currentTimeMillis()));\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper.writeSegmentLineage(_propertyStore, segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String\n+          .format(\"Failed while updating the segment lineage. (tableName = %s, segmentsFrom = %s, segmentsTo = %s)\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }\n+\n+    // Only successful attempt can reach here\n+    LOGGER.info(\"startBatchUpload is successfully processed. (tableNameWithType = {}, segmentsFrom = {}, \"\n+        + \"segmentsTo = {}, batchId = {})\", tableNameWithType, segmentsFrom, segmentsTo, batchId);\n+    return batchId;\n+  }\n+\n+  /**\n+   * Computes the end batch upload phase\n+   *\n+   * 1. Compute validation\n+   * 2. Update the lineage entry state to \"COMPLETED\" and write metadata to the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType\n+   * @param batchId\n+   */\n+  public void endBatchUpload(String tableNameWithType, String batchId) {\n+    // Check that the batch id is valid\n+    if (batchId == null || batchId.isEmpty()) {\n+      throw new IllegalArgumentException(\"'batchId' cannot be null or empty\");\n+    }\n+\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          String errorMsg = String\n+              .format(\"Segment lineage does not exist. (tableNameWithType = '%s', batchId = '%s')\", tableNameWithType,\n+                  batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Look up the lineage entry based on the batch id\n+        LineageEntry lineageEntry = segmentLineage.getLineageEntry(batchId);\n+        if (lineageEntry == null) {\n+          String errorMsg =\n+              String.format(\"Invalid batch id (tableName='%s', batchId='%s')\", tableNameWithType, batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        // Check that all the segments from 'segmentsTo' exist in the table\n+        Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+        if (!segmentsForTable.containsAll(lineageEntry.getSegmentsTo())) {\n+          String errorMsg = String.format(\n+              \"Not all segments from 'segmentsTo' are available in the table. (tableName = '%s', segmentsTo = '%s', \"\n+                  + \"segmentsFromTable = '%s')\", tableNameWithType, lineageEntry.getSegmentsTo(), segmentsForTable);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        // NO-OPS if the entry is already completed\n+        if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+          LOGGER.info(\"Lineage entry state is already COMPLETED. Nothing to update. (tableNameWithType={}, batchId={})\",", "originalCommit": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyODM5MQ==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r456728391", "bodyText": "Log something after it succeeds?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T00:53:41Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,190 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    if (segmentsTo == null || segmentsTo.isEmpty()) {\n+      String errorMsg = String\n+          .format(\"'segmentsTo' cannot be null or empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    // segmentsFrom can be empty in case of the initial upload\n+    if (segmentsFrom == null) {\n+      segmentsFrom = new ArrayList<>();\n+    }\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    if (!segmentsForTable.containsAll(segmentsFrom)) {\n+      String errorMsg = String.format(\n+          \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+              + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+          segmentsForTable);\n+      throw new IllegalArgumentException(errorMsg);\n+    }\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        if (segmentLineage.getLineageEntry(batchId) != null) {\n+          String errorMsg = String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear on the left side.\n+          if (lineageEntry.getSegmentsFrom().stream().anyMatch(finalSegmentsFrom::contains)) {\n+            String errorMsg = String.format(\n+                \"It is not allowed to merge segments that are already merged. (tableName = %s, segmentsFrom from \"\n+                    + \"existing lineage entry = %s, requested segmentsFrom = %s)\", tableNameWithType,\n+                lineageEntry.getSegmentsFrom(), finalSegmentsFrom);\n+            throw new IllegalArgumentException(errorMsg);\n+          }\n+\n+          // Check that merged segments name cannot be the same for different lineage entry\n+          if (lineageEntry.getSegmentsTo().stream().anyMatch(segmentsTo::contains)) {\n+            String errorMsg = String.format(\n+                \"It is not allowed to have the same segment name for merged segments. (tableName = %s, segmentsTo from \"\n+                    + \"existing lineage entry = %s, requested segmentsTo = %s)\", tableNameWithType,\n+                lineageEntry.getSegmentsTo(), segmentsTo);\n+            throw new IllegalArgumentException(errorMsg);\n+          }\n+        }\n+\n+        // Update lineage entry\n+        segmentLineage.addLineageEntry(batchId,\n+            new LineageEntry(finalSegmentsFrom, segmentsTo, LineageEntryState.IN_PROGRESS, System.currentTimeMillis()));\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper.writeSegmentLineage(_propertyStore, segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String\n+          .format(\"Failed while updating the segment lineage. (tableName = %s, segmentsFrom = %s, segmentsTo = %s)\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }\n+\n+    // Only successful attempt can reach here\n+    LOGGER.info(\"startBatchUpload is successfully processed. (tableNameWithType = {}, segmentsFrom = {}, \"\n+        + \"segmentsTo = {}, batchId = {})\", tableNameWithType, segmentsFrom, segmentsTo, batchId);\n+    return batchId;\n+  }\n+\n+  /**\n+   * Computes the end batch upload phase\n+   *\n+   * 1. Compute validation\n+   * 2. Update the lineage entry state to \"COMPLETED\" and write metadata to the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType\n+   * @param batchId\n+   */\n+  public void endBatchUpload(String tableNameWithType, String batchId) {\n+    // Check that the batch id is valid\n+    if (batchId == null || batchId.isEmpty()) {\n+      throw new IllegalArgumentException(\"'batchId' cannot be null or empty\");\n+    }\n+\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          String errorMsg = String\n+              .format(\"Segment lineage does not exist. (tableNameWithType = '%s', batchId = '%s')\", tableNameWithType,\n+                  batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Look up the lineage entry based on the batch id\n+        LineageEntry lineageEntry = segmentLineage.getLineageEntry(batchId);\n+        if (lineageEntry == null) {\n+          String errorMsg =\n+              String.format(\"Invalid batch id (tableName='%s', batchId='%s')\", tableNameWithType, batchId);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        // Check that all the segments from 'segmentsTo' exist in the table\n+        Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+        if (!segmentsForTable.containsAll(lineageEntry.getSegmentsTo())) {\n+          String errorMsg = String.format(\n+              \"Not all segments from 'segmentsTo' are available in the table. (tableName = '%s', segmentsTo = '%s', \"\n+                  + \"segmentsFromTable = '%s')\", tableNameWithType, lineageEntry.getSegmentsTo(), segmentsForTable);\n+          throw new IllegalArgumentException(errorMsg);\n+        }\n+\n+        // NO-OPS if the entry is already completed\n+        if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+          LOGGER.info(\"Lineage entry state is already COMPLETED. Nothing to update. (tableNameWithType={}, batchId={})\",\n+              tableNameWithType, batchId);\n+          return true;\n+        }\n+\n+        // Update lineage entry\n+        LineageEntry newLineageEntry =\n+            new LineageEntry(lineageEntry.getSegmentsFrom(), lineageEntry.getSegmentsTo(), LineageEntryState.COMPLETED,\n+                System.currentTimeMillis());\n+        segmentLineage.addLineageEntry(batchId, newLineageEntry);\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper.writeSegmentLineage(_propertyStore, segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String\n+          .format(\"Failed to update the segment lineage. (tableName = %s, batchId = %s)\", tableNameWithType, batchId);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }", "originalCommit": "66b4f190c784bf2d9ec50ffbca5d7311b997d91f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg0MzUxMA==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r457843510", "bodyText": "added", "author": "snleee", "createdAt": "2020-07-21T05:22:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyODM5MQ=="}], "type": "inlineReview"}, {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf", "url": "https://github.com/apache/pinot/commit/0432763e9f1c2b68c60d765e5cde27a2118b9adf", "message": "Addressing comments", "committedDate": "2020-07-21T07:03:23Z", "type": "commit"}, {"oid": "0432763e9f1c2b68c60d765e5cde27a2118b9adf", "url": "https://github.com/apache/pinot/commit/0432763e9f1c2b68c60d765e5cde27a2118b9adf", "message": "Addressing comments", "committedDate": "2020-07-21T07:03:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwODc3MA==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458208770", "bodyText": "Will minion reference \"batchId\"  to do automatic merges? In that case, it is useful to add this to CommonConstants. Even otherwise, if we are building any client software to interact with the controller, it is useful, so I would suggest to move it to common constants.", "author": "mcvsubbu", "createdAt": "2020-07-21T15:57:35Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentUploadDownloadRestletResource.java", "diffHunk": "@@ -455,6 +460,46 @@ public void uploadSegmentAsMultiPartV2(FormDataMultiPart multiPart,\n     }\n   }\n \n+  @POST\n+  @Path(\"segments/{tableName}/startBatchUpload\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Start the batch upload\", notes = \"Start the batch upload\")\n+  public Response startBatchUpload(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr,\n+      StartBatchUploadRequest startBatchUploadRequest) {\n+    try {\n+      String tableNameWithType =\n+          TableNameBuilder.forType(TableType.valueOf(tableTypeStr.toUpperCase())).tableNameWithType(tableName);\n+      String batchId = _pinotHelixResourceManager\n+          .startBatchUpload(tableNameWithType, startBatchUploadRequest.getSegmentsFrom(),\n+              startBatchUploadRequest.getSegmentsTo());\n+      return Response.ok(JsonUtils.newObjectNode().put(\"batchId\", batchId)).build();", "originalCommit": "0432763e9f1c2b68c60d765e5cde27a2118b9adf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwOTUwMw==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458209503", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  Preconditions.checkNotNull(batchId, \"'batchId' cannot be null\");\n          \n          \n            \n                  Preconditions.checkNotNull(batchId, \"'batchId' should not be null\");", "author": "mcvsubbu", "createdAt": "2020-07-21T15:58:28Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentUploadDownloadRestletResource.java", "diffHunk": "@@ -455,6 +460,46 @@ public void uploadSegmentAsMultiPartV2(FormDataMultiPart multiPart,\n     }\n   }\n \n+  @POST\n+  @Path(\"segments/{tableName}/startBatchUpload\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Start the batch upload\", notes = \"Start the batch upload\")\n+  public Response startBatchUpload(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr,\n+      StartBatchUploadRequest startBatchUploadRequest) {\n+    try {\n+      String tableNameWithType =\n+          TableNameBuilder.forType(TableType.valueOf(tableTypeStr.toUpperCase())).tableNameWithType(tableName);\n+      String batchId = _pinotHelixResourceManager\n+          .startBatchUpload(tableNameWithType, startBatchUploadRequest.getSegmentsFrom(),\n+              startBatchUploadRequest.getSegmentsTo());\n+      return Response.ok(JsonUtils.newObjectNode().put(\"batchId\", batchId)).build();\n+    } catch (Exception e) {\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.INTERNAL_SERVER_ERROR, e);\n+    }\n+  }\n+\n+  @POST\n+  @Path(\"segments/{tableName}/endBatchUpload\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"End the batch upload\", notes = \"End the batch upload\")\n+  public Response endBatchUpload(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr,\n+      @ApiParam(value = \"Batch Id returned by startBatchUpload API\") @QueryParam(\"batchId\") String batchId) {\n+    try {\n+      String tableNameWithType =\n+          TableNameBuilder.forType(TableType.valueOf(tableTypeStr.toUpperCase())).tableNameWithType(tableName);\n+      // Check that the batch id is valid\n+      Preconditions.checkNotNull(batchId, \"'batchId' cannot be null\");", "originalCommit": "0432763e9f1c2b68c60d765e5cde27a2118b9adf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQxMjU1MQ==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458412551", "bodyText": "fixed", "author": "snleee", "createdAt": "2020-07-21T21:57:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwOTUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMDQ0NA==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458210444", "bodyText": "Can we move this check to the caller? Or, do you expect multiple callers to this API?", "author": "mcvsubbu", "createdAt": "2020-07-21T15:59:49Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String", "originalCommit": "0432763e9f1c2b68c60d765e5cde27a2118b9adf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwODYwNQ==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458408605", "bodyText": "I moved this to the constructor of StartBatchUploadRequest", "author": "snleee", "createdAt": "2020-07-21T21:49:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMDQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMzU5MQ==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458213591", "bodyText": "Do you want to include lineage in the log?", "author": "mcvsubbu", "createdAt": "2020-07-21T16:04:22Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String\n+        .format(\"'segmentsTo' cannot be empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+            tableNameWithType, segmentsFrom, segmentsTo));\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        Preconditions.checkArgument(segmentLineage.getLineageEntry(batchId) == null,\n+            String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId));\n+\n+        // Check\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear twice.\n+          Preconditions.checkArgument(Collections.disjoint(lineageEntry.getSegmentsFrom(), finalSegmentsFrom), String\n+              .format(\"It is not allowed to merge segments that are already merged. (tableName = %s, segmentsFrom from \"\n+                      + \"existing lineage entry = %s, requested segmentsFrom = %s)\", tableNameWithType,\n+                  lineageEntry.getSegmentsFrom(), finalSegmentsFrom));\n+\n+          // Check that merged segments name cannot be the same.\n+          Preconditions.checkArgument(Collections.disjoint(lineageEntry.getSegmentsTo(), segmentsTo), String.format(\n+              \"It is not allowed to have the same segment name for merged segments. (tableName = %s, segmentsTo from \"\n+                  + \"existing lineage entry = %s, requested segmentsTo = %s)\", tableNameWithType,\n+              lineageEntry.getSegmentsTo(), segmentsTo));\n+        }\n+\n+        // Update lineage entry\n+        segmentLineage.addLineageEntry(batchId,\n+            new LineageEntry(finalSegmentsFrom, segmentsTo, LineageEntryState.IN_PROGRESS, System.currentTimeMillis()));\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper.writeSegmentLineage(_propertyStore, segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String\n+          .format(\"Failed while updating the segment lineage. (tableName = %s, segmentsFrom = %s, segmentsTo = %s)\",\n+              tableNameWithType, segmentsFrom, segmentsTo);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }\n+\n+    // Only successful attempt can reach here\n+    LOGGER.info(\"startBatchUpload is successfully processed. (tableNameWithType = {}, segmentsFrom = {}, \"\n+        + \"segmentsTo = {}, batchId = {})\", tableNameWithType, segmentsFrom, segmentsTo, batchId);\n+    return batchId;\n+  }\n+\n+  /**\n+   * Computes the end batch upload phase\n+   *\n+   * 1. Compute validation\n+   * 2. Update the lineage entry state to \"COMPLETED\" and write metadata to the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType\n+   * @param batchId\n+   */\n+  public void endBatchUpload(String tableNameWithType, String batchId) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        Preconditions.checkArgument(segmentLineageZNRecord != null, String\n+            .format(\"Segment lineage does not exist. (tableNameWithType = '%s', batchId = '%s')\", tableNameWithType,\n+                batchId));\n+        segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Look up the lineage entry based on the batch id\n+        LineageEntry lineageEntry = segmentLineage.getLineageEntry(batchId);\n+        Preconditions.checkArgument(lineageEntry != null,\n+            String.format(\"Invalid batch id (tableName='%s', batchId='%s')\", tableNameWithType, batchId));\n+\n+        // Check that all the segments from 'segmentsTo' exist in the table\n+        Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+        Preconditions.checkArgument(segmentsForTable.containsAll(lineageEntry.getSegmentsTo()), String.format(\n+            \"Not all segments from 'segmentsTo' are available in the table. (tableName = '%s', segmentsTo = '%s', \"\n+                + \"segmentsFromTable = '%s')\", tableNameWithType, lineageEntry.getSegmentsTo(), segmentsForTable));\n+\n+        // NO-OPS if the entry is already completed\n+        if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+          LOGGER.warn(\"Lineage entry state is already COMPLETED. Nothing to update. (tableNameWithType={}, batchId={})\",\n+              tableNameWithType, batchId);\n+          return true;\n+        }\n+\n+        // Update lineage entry\n+        LineageEntry newLineageEntry =\n+            new LineageEntry(lineageEntry.getSegmentsFrom(), lineageEntry.getSegmentsTo(), LineageEntryState.COMPLETED,\n+                System.currentTimeMillis());\n+        segmentLineage.updateLineageEntry(batchId, newLineageEntry);\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper.writeSegmentLineage(_propertyStore, segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String\n+          .format(\"Failed to update the segment lineage. (tableName = %s, batchId = %s)\", tableNameWithType, batchId);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }\n+\n+    // Only successful attempt can reach here\n+    LOGGER.info(\"endBatchUpload is successfully processed. (tableNameWithType = {}, batchId = {})\", tableNameWithType,", "originalCommit": "0432763e9f1c2b68c60d765e5cde27a2118b9adf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwNzg1NQ==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458407855", "bodyText": "We can easily find the lineage info from zookeeper (and we can also add an API that fetches lineage entry given batchId if we need to fetch lineage info frequently).", "author": "snleee", "createdAt": "2020-07-21T21:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMzU5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNjQ1MA==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458336450", "bodyText": "Let's use lang3\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import org.apache.commons.lang.StringUtils;\n          \n          \n            \n            import org.apache.commons.lang3.StringUtils;", "author": "Jackie-Jiang", "createdAt": "2020-07-21T19:28:07Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/lineage/SegmentLineage.java", "diffHunk": "@@ -24,7 +24,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-import java.util.UUID;\n+import org.apache.commons.lang.StringUtils;", "originalCommit": "0432763e9f1c2b68c60d765e5cde27a2118b9adf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNzI3Mw==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458337273", "bodyText": "(nit) Use constant?", "author": "Jackie-Jiang", "createdAt": "2020-07-21T19:29:42Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/lineage/SegmentLineage.java", "diffHunk": "@@ -108,8 +119,8 @@ public static SegmentLineage fromZNRecord(ZNRecord record) {\n       String lineageId = listField.getKey();\n       List<String> value = listField.getValue();\n       Preconditions.checkState(value.size() == 4);\n-      List<String> segmentsFrom = Arrays.asList(value.get(0).split(COMMA_SEPARATOR));\n-      List<String> segmentsTo = Arrays.asList(value.get(1).split(COMMA_SEPARATOR));\n+      List<String> segmentsFrom = Arrays.asList(StringUtils.split(value.get(0), ','));", "originalCommit": "0432763e9f1c2b68c60d765e5cde27a2118b9adf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNzYxOA==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458337618", "bodyText": "(nit) SegmentLineageUtils\nAlso add a private constructor", "author": "Jackie-Jiang", "createdAt": "2020-07-21T19:30:23Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/lineage/SegmentLineageUtil.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.lineage;\n+\n+import java.util.UUID;\n+\n+\n+/**\n+ * Util class for Segment Lineage\n+ */\n+public class SegmentLineageUtil {", "originalCommit": "0432763e9f1c2b68c60d765e5cde27a2118b9adf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzOTg1Ng==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458339856", "bodyText": "(nit)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                _segmentsFrom = (segmentsFrom == null) ? new ArrayList<>() : segmentsFrom;\n          \n          \n            \n                _segmentsFrom = (segmentsFrom == null) ? Collections.emptyList() : segmentsFrom;", "author": "Jackie-Jiang", "createdAt": "2020-07-21T19:34:57Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/StartBatchUploadRequest.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Request object for startBatchUpload API.\n+ *\n+ * 1. segmentsFrom : original segments. This field can be empty in case the user tries to upload the original segments\n+ *    and wants to achieve the atomic update of multiple segments.\n+ * 2. segmentsTo : merged segments.\n+ */\n+public class StartBatchUploadRequest {\n+  private List<String> _segmentsFrom;\n+  private List<String> _segmentsTo;\n+\n+  public StartBatchUploadRequest(@JsonProperty(\"segmentsFrom\") @Nullable List<String> segmentsFrom,\n+      @JsonProperty(\"segmentsTo\") List<String> segmentsTo) {\n+    _segmentsFrom = (segmentsFrom == null) ? new ArrayList<>() : segmentsFrom;", "originalCommit": "0432763e9f1c2b68c60d765e5cde27a2118b9adf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyMzE0MQ==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458423141", "bodyText": "Use the SegmentLineageUtils and move it into the retry logic so that it handles the case of collision", "author": "Jackie-Jiang", "createdAt": "2020-07-21T22:22:38Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();", "originalCommit": "0432763e9f1c2b68c60d765e5cde27a2118b9adf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4Njk1Nw==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458486957", "bodyText": "good catch!", "author": "snleee", "createdAt": "2020-07-22T01:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyMzE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyMzcyMA==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458423720", "bodyText": "(nit) I don't think you need to have this extra finalSegmentsFrom because segmentsFrom is never changed", "author": "Jackie-Jiang", "createdAt": "2020-07-21T22:24:07Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String\n+        .format(\"'segmentsTo' cannot be empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+            tableNameWithType, segmentsFrom, segmentsTo));\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;", "originalCommit": "0432763e9f1c2b68c60d765e5cde27a2118b9adf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4ODQ5Ng==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458488496", "bodyText": "Yes you're right. Previous code needed it because I reassigned the value after some validation but this is no longer needed.", "author": "snleee", "createdAt": "2020-07-22T01:57:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyMzcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyNTA5OQ==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458425099", "bodyText": "Don't directly throw exception as it will abort the retry.\nYou can keep generating batchId until get a new one (in most case there is no collision)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Check that the batchId doesn't exists in the segment lineage\n          \n          \n            \n                    Preconditions.checkArgument(segmentLineage.getLineageEntry(batchId) == null,\n          \n          \n            \n                        String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId));\n          \n          \n            \n                    String batchId = SegmentLineageUtils. generateLineageEntryId();\n          \n          \n            \n                    while (segmentLineage.getLineageEntry(batchId) != null) {\n          \n          \n            \n                      batchId = SegmentLineageUtils. generateLineageEntryId();\n          \n          \n            \n                    }", "author": "Jackie-Jiang", "createdAt": "2020-07-21T22:27:27Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String\n+        .format(\"'segmentsTo' cannot be empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+            tableNameWithType, segmentsFrom, segmentsTo));\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        Preconditions.checkArgument(segmentLineage.getLineageEntry(batchId) == null,\n+            String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId));", "originalCommit": "0432763e9f1c2b68c60d765e5cde27a2118b9adf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUwMzMyMg==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458503322", "bodyText": "The reason why I generate batchId outside of retry block is that it's a bit hard to pass some information from retry block to the caller based on the current RetryPolicy interface. For now, let's not deal with the id collision. Throwing exception should be fine. Once this part shows up frequently (likely not because it's extremely hard to observe UUID collision), we can deal with this by improving retry policy interface to allow pass information back to the caller.", "author": "snleee", "createdAt": "2020-07-22T02:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyNTA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyNzIwMg==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458427202", "bodyText": "You need to catch the exception in order to do retries. Same for other places that can throw exception", "author": "Jackie-Jiang", "createdAt": "2020-07-21T22:32:35Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String\n+        .format(\"'segmentsTo' cannot be empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+            tableNameWithType, segmentsFrom, segmentsTo));\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        Preconditions.checkArgument(segmentLineage.getLineageEntry(batchId) == null,\n+            String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId));\n+\n+        // Check\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear twice.\n+          Preconditions.checkArgument(Collections.disjoint(lineageEntry.getSegmentsFrom(), finalSegmentsFrom), String", "originalCommit": "0432763e9f1c2b68c60d765e5cde27a2118b9adf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5MTkyMw==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458491923", "bodyText": "Do we want to retry for the validation check failure? I thought that we can kill the process if validation fails and retries if zk update fails. How do you think?", "author": "snleee", "createdAt": "2020-07-22T02:10:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyNzIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyNzM0Mw==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458427343", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Check\n          \n          \n            \n                    // Check ...", "author": "Jackie-Jiang", "createdAt": "2020-07-21T22:32:59Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String\n+        .format(\"'segmentsTo' cannot be empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+            tableNameWithType, segmentsFrom, segmentsTo));\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        Preconditions.checkArgument(segmentLineage.getLineageEntry(batchId) == null,\n+            String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId));\n+\n+        // Check", "originalCommit": "0432763e9f1c2b68c60d765e5cde27a2118b9adf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5MjA2Mg==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458492062", "bodyText": "removed", "author": "snleee", "createdAt": "2020-07-22T02:10:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyNzM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyODAzNQ==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458428035", "bodyText": "segmentsTo must not be any of the existing segmentsFrom as well", "author": "Jackie-Jiang", "createdAt": "2020-07-21T22:34:52Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,167 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start batch upload phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Bath Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startBatchUpload(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = UUID.randomUUID().toString();\n+\n+    // Check that segmentsTo is not empty.\n+    Preconditions.checkArgument(!segmentsTo.isEmpty(), String\n+        .format(\"'segmentsTo' cannot be empty (tableName = '%s', segmentsFrom = '%s', segmentsTo = '%s'\",\n+            tableNameWithType, segmentsFrom, segmentsTo));\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+\n+    try {\n+      final List<String> finalSegmentsFrom = segmentsFrom;\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch the segment lineage metadata\n+        ZNRecord segmentLineageZNRecord =\n+            SegmentLineageAccessHelper.getSegmentLineageZNRecord(_propertyStore, tableNameWithType);\n+        SegmentLineage segmentLineage;\n+        int expectedVersion = -1;\n+        if (segmentLineageZNRecord == null) {\n+          segmentLineage = new SegmentLineage(tableNameWithType);\n+        } else {\n+          segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+          expectedVersion = segmentLineageZNRecord.getVersion();\n+        }\n+\n+        // Check that the batchId doesn't exists in the segment lineage\n+        Preconditions.checkArgument(segmentLineage.getLineageEntry(batchId) == null,\n+            String.format(\"BatchId (%s) already exists in the segment lineage.\", batchId));\n+\n+        // Check\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+\n+          // Check that any segment from 'segmentsFrom' does not appear twice.\n+          Preconditions.checkArgument(Collections.disjoint(lineageEntry.getSegmentsFrom(), finalSegmentsFrom), String\n+              .format(\"It is not allowed to merge segments that are already merged. (tableName = %s, segmentsFrom from \"\n+                      + \"existing lineage entry = %s, requested segmentsFrom = %s)\", tableNameWithType,\n+                  lineageEntry.getSegmentsFrom(), finalSegmentsFrom));\n+\n+          // Check that merged segments name cannot be the same.\n+          Preconditions.checkArgument(Collections.disjoint(lineageEntry.getSegmentsTo(), segmentsTo), String.format(\n+              \"It is not allowed to have the same segment name for merged segments. (tableName = %s, segmentsTo from \"\n+                  + \"existing lineage entry = %s, requested segmentsTo = %s)\", tableNameWithType,\n+              lineageEntry.getSegmentsTo(), segmentsTo));\n+        }\n+", "originalCommit": "0432763e9f1c2b68c60d765e5cde27a2118b9adf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUwNjY4Mw==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458506683", "bodyText": "This check is actually covered by the initial validation\n    // Check that all the segments from 'segmentsFrom' exist in the table\n    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom));\n\n    // Check that all the segments from 'segmentTo' does not exist in the table.\n    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo));\n\nsegmentsForTable is superset of segmentFrom, so checking Collections.disjoint(segmentsForTable, segmentsTo) includes the check of Collection.disjoint(segmentsTo, segmentsFrom)\nI will add the test case for this.", "author": "snleee", "createdAt": "2020-07-22T03:06:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyODAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk5NzE1Ng==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r458997156", "bodyText": "Do you also need to check that any of the segmentsFrom are not in another merge that has been started (but not finished)?", "author": "mcvsubbu", "createdAt": "2020-07-22T18:28:18Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -2164,6 +2168,160 @@ public boolean instanceExists(String instanceName) {\n     return tableNamesWithType;\n   }\n \n+  /**\n+   * Computes the start segment replace phase\n+   *\n+   * 1. Generate a batch id\n+   * 2. Compute validation on the user inputs\n+   * 3. Add the new lineage entry to the segment lineage metadata in the property store\n+   *\n+   * Update is done with retry logic along with read-modify-write block for achieving atomic update of the lineage\n+   * metadata.\n+   *\n+   * @param tableNameWithType Table name with type\n+   * @param segmentsFrom a list of segments to be merged\n+   * @param segmentsTo a list of merged segments\n+   * @return Batch Id\n+   *\n+   * @throws InvalidConfigException\n+   */\n+  public String startReplaceSegments(String tableNameWithType, List<String> segmentsFrom, List<String> segmentsTo) {\n+    // Create a batch id\n+    String batchId = SegmentLineageUtils.generateLineageEntryId();\n+\n+    // Check that all the segments from 'segmentsFrom' exist in the table\n+    Set<String> segmentsForTable = new HashSet<>(getSegmentsFor(tableNameWithType));\n+    Preconditions.checkArgument(segmentsForTable.containsAll(segmentsFrom), String.format(\n+        \"Not all segments from 'segmentsFrom' are available in the table. (tableName = '%s', segmentsFrom = '%s', \"\n+            + \"segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom, segmentsTo,\n+        segmentsForTable));\n+\n+    // Check that all the segments from 'segmentTo' does not exist in the table.\n+    Preconditions.checkArgument(Collections.disjoint(segmentsForTable, segmentsTo), String.format(\n+        \"Any segments from 'segmentsTo' should not be available in the table at this point. (tableName = '%s', \"\n+            + \"segmentsFrom = '%s', segmentsTo = '%s', segmentsFromTable = '%s')\", tableNameWithType, segmentsFrom,\n+        segmentsTo, segmentsForTable));\n+", "originalCommit": "e8a51381dc08d8cebb191d09c8f648f8f9a3a002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MjgxNg==", "url": "https://github.com/apache/pinot/pull/5712#discussion_r459142816", "bodyText": "Good point. It's very important that for any segment, it should appear on segmentsFrom at most once because we will have the issue with double-counting otherwise. In order to prevent that, we will do the following:\n\nMerge task scheduler will check the segments that are running (started but not finished) not to schedule the segments that are already scheduled.\nDuring the \"startReplaceSegments\", we reject if the input segmentFrom appears any of segmentFrom field in the segment lineage.", "author": "snleee", "createdAt": "2020-07-22T23:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk5NzE1Ng=="}], "type": "inlineReview"}, {"oid": "1f3ed34c3930ccea30f5da6932dc407da03aa4ae", "url": "https://github.com/apache/pinot/commit/1f3ed34c3930ccea30f5da6932dc407da03aa4ae", "message": "Addressing comments and change the API name to \"ReplaceSegments\"", "committedDate": "2020-07-23T05:39:21Z", "type": "forcePushed"}, {"oid": "92a5e085a9a52d90b7a94d1d5d24f59a5b874d3e", "url": "https://github.com/apache/pinot/commit/92a5e085a9a52d90b7a94d1d5d24f59a5b874d3e", "message": "Addressing comments and change the API name to \"ReplaceSegments\"", "committedDate": "2020-07-23T05:45:13Z", "type": "commit"}, {"oid": "92a5e085a9a52d90b7a94d1d5d24f59a5b874d3e", "url": "https://github.com/apache/pinot/commit/92a5e085a9a52d90b7a94d1d5d24f59a5b874d3e", "message": "Addressing comments and change the API name to \"ReplaceSegments\"", "committedDate": "2020-07-23T05:45:13Z", "type": "forcePushed"}]}