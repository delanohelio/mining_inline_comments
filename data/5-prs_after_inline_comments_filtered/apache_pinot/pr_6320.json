{"pr_number": 6320, "pr_title": "More efficient use of RoaringBitmap in OnHeapBitmapInvertedIndexCreator and OffHeapBitmapInvertedIndexCreator", "pr_createdAt": "2020-12-04T22:43:34Z", "pr_url": "https://github.com/apache/pinot/pull/6320", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ1ODEyNg==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536458126", "bodyText": "This is a new allocation, but it's offset against the 16KB in stream buffers no longer allocated, and is a lot smaller than the bitmaps being materialised here anyway. This pattern where bitmaps are allocated just to obtain their serialized bytes could probably be supported by roaringbitmap without actually creating the intermediate bitmaps without much complication.", "author": "richardstartin", "createdAt": "2020-12-05T00:21:52Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -181,33 +188,49 @@ public void seal()\n     }\n \n     // Create bitmaps from inverted index buffers and serialize them to file\n-    try (DataOutputStream offsetDataStream = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)));\n-        FileOutputStream bitmapFileStream = new FileOutputStream(_invertedIndexFile);\n-        DataOutputStream bitmapDataStream = new DataOutputStream(new BufferedOutputStream(bitmapFileStream))) {\n-      int bitmapOffset = (_cardinality + 1) * Integer.BYTES;\n-      offsetDataStream.writeInt(bitmapOffset);\n-      bitmapFileStream.getChannel().position(bitmapOffset);\n-\n+    ByteBuffer offsetBuffer = null;\n+    ByteBuffer bitmapBuffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      // map the offsets buffer\n+      final int startOfBitmaps = (_cardinality + 1) * Integer.BYTES;\n+      int bitmapOffset = startOfBitmaps;\n+      offsetBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, bitmapOffset).order(LITTLE_ENDIAN);\n+      offsetBuffer.putInt(reverseBytes(bitmapOffset));\n+      MutableRoaringBitmap[] bitmaps = new MutableRoaringBitmap[_cardinality];", "originalCommit": "0a7af3663939e5d8a9cad3ca81e532631ad523bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUxNzEzOA==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536517138", "bodyText": "I am assuming the choice of LITTLE_ENDIAN comes from the fact that index generation (typically happening on x86 machines) will not require byte swap when writing the index?\nWhen we load the index, we specifically use BIG_ENDIAN byte order because throughout the index generation code we use BIG_ENDIAN. This works with overhead of byte swap for both read and write.\nI am confused how is this change expected to work today for the reader? The reader will load the file specifying the order as BIG_ENDIAN. This means every read operation will swap the bytes on x86. However, with this change index file is generated in LE format which doesn't require any swapping. So swapping bytes during inverted index read will result in incorrect data imo. I am surprised that tests are passing.\nSee the code in index buffer loader. This code doesn't know index file was written in LE format.\n// Backward-compatible: index file is always big-endian\n    PinotDataBuffer buffer;\n    if (readMode == ReadMode.heap) {\n      buffer = PinotDataBuffer.loadFile(indexFile, fromFilePos, size, ByteOrder.BIG_ENDIAN, context);\n    } else {\n      buffer = PinotDataBuffer.mapFile(indexFile, true, fromFilePos, size, ByteOrder.BIG_ENDIAN, context);\n    }", "author": "siddharthteotia", "createdAt": "2020-12-05T05:20:05Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OnHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -19,68 +19,85 @@\n package org.apache.pinot.core.segment.creator.impl.inv;\n \n import com.google.common.base.Preconditions;\n-import java.io.BufferedOutputStream;\n-import java.io.DataOutputStream;\n+\n+\n import java.io.File;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n import org.apache.commons.io.FileUtils;\n import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n import org.apache.pinot.core.segment.creator.impl.V1Constants;\n+import org.apache.pinot.core.util.CleanerUtil;\n+import org.roaringbitmap.RoaringBitmapWriter;\n import org.roaringbitmap.buffer.MutableRoaringBitmap;\n \n+import static java.nio.ByteOrder.LITTLE_ENDIAN;\n+\n \n /**\n  * Implementation of {@link DictionaryBasedInvertedIndexCreator} that uses on-heap memory.\n  */\n public final class OnHeapBitmapInvertedIndexCreator implements DictionaryBasedInvertedIndexCreator {\n   private final File _invertedIndexFile;\n-  private final MutableRoaringBitmap[] _bitmaps;\n+  private final RoaringBitmapWriter<MutableRoaringBitmap>[] _bitmapWriters;\n   private int _nextDocId;\n \n+  @SuppressWarnings(\"unchecked\")\n   public OnHeapBitmapInvertedIndexCreator(File indexDir, String columnName, int cardinality) {\n     _invertedIndexFile = new File(indexDir, columnName + V1Constants.Indexes.BITMAP_INVERTED_INDEX_FILE_EXTENSION);\n-    _bitmaps = new MutableRoaringBitmap[cardinality];\n+    _bitmapWriters = new RoaringBitmapWriter[cardinality];\n     for (int i = 0; i < cardinality; i++) {\n-      _bitmaps[i] = new MutableRoaringBitmap();\n+      _bitmapWriters[i] = RoaringBitmapWriter.bufferWriter().get();\n     }\n   }\n \n   @Override\n   public void add(int dictId) {\n-    _bitmaps[dictId].add(_nextDocId++);\n+    _bitmapWriters[dictId].add(_nextDocId++);\n   }\n \n   @Override\n   public void add(int[] dictIds, int length) {\n     for (int i = 0; i < length; i++) {\n-      _bitmaps[dictIds[i]].add(_nextDocId);\n+      _bitmapWriters[dictIds[i]].add(_nextDocId);\n     }\n     _nextDocId++;\n   }\n \n   @Override\n   public void seal()\n       throws IOException {\n-    try (DataOutputStream out = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)))) {\n+    // calculate file size\n+    int size = (_bitmapWriters.length + 1) * Integer.BYTES;\n+    for (RoaringBitmapWriter<MutableRoaringBitmap> writer : _bitmapWriters) {\n+      size += writer.get().serializedSizeInBytes();\n+      // Check for int overflow\n+      Preconditions.checkState(size > 0, \"Inverted index file: %s exceeds 2GB limit\", _invertedIndexFile);\n+    }\n+    ByteBuffer buffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size).order(LITTLE_ENDIAN);", "originalCommit": "0a7af3663939e5d8a9cad3ca81e532631ad523bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyMDEzNg==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536520136", "bodyText": "Ok, I see you are swapping the bytes below before writing. So, this is writing BE bytes in LE file so that later during index load, read in BE format will work. In this case, why not just choose the BE format for writing as we do today. Does the usage of RoaringBitmapWriter enforce LE format?", "author": "siddharthteotia", "createdAt": "2020-12-05T05:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUxNzEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjU1OTA4MA==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536559080", "bodyText": "I chose little endian because roaring bitmaps are always serialised in little endian byte order anyway, and they make up the bulk of the file. If you serialise to a DataOutput it will reverse every word, and if you serialise to a big endian ByteBuffer, it will just slice the buffer and change the order.", "author": "richardstartin", "createdAt": "2020-12-05T08:32:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUxNzEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkxNTIxNA==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536915214", "bodyText": "Not sure I completely follow. You are writing big endian bytes by doing reverseBytes() anyway. So why not just choose the byte order as BE.", "author": "siddharthteotia", "createdAt": "2020-12-05T23:43:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUxNzEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkxNjAzMA==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536916030", "bodyText": "I was writing big endian bytes to a part of the buffer whereas the bulk of the file is serialised by the roaring bitmap library, which is little endian by specification. So I was doing a little extra work on the offsets, to favour the bitmaps. Does that make sense?", "author": "richardstartin", "createdAt": "2020-12-05T23:49:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUxNzEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkxNzQzMw==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536917433", "bodyText": "In any case, the code in question was changed so that the offsets part of the file is big endian anyway, and a little endian buffer is provided to RoaringBitmap.serialize", "author": "richardstartin", "createdAt": "2020-12-05T23:59:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUxNzEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyMTI3NA==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536521274", "bodyText": "Where exactly is the potential benefit coming from?", "author": "siddharthteotia", "createdAt": "2020-12-05T05:49:34Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -181,33 +188,49 @@ public void seal()\n     }\n \n     // Create bitmaps from inverted index buffers and serialize them to file\n-    try (DataOutputStream offsetDataStream = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)));\n-        FileOutputStream bitmapFileStream = new FileOutputStream(_invertedIndexFile);\n-        DataOutputStream bitmapDataStream = new DataOutputStream(new BufferedOutputStream(bitmapFileStream))) {\n-      int bitmapOffset = (_cardinality + 1) * Integer.BYTES;\n-      offsetDataStream.writeInt(bitmapOffset);\n-      bitmapFileStream.getChannel().position(bitmapOffset);\n-\n+    ByteBuffer offsetBuffer = null;\n+    ByteBuffer bitmapBuffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {", "originalCommit": "0a7af3663939e5d8a9cad3ca81e532631ad523bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjU2NTI4NA==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536565284", "bodyText": "Two places.\n\nWe found that serializing to ByteBuffer could be up to 20x faster than to DataOutput, which was why the API was added.\nIf the bitmaps being materialised prior to serialisation below get reasonably large, using RoaringBitmapWriter improves the efficiency of construction. This is because when you call RoaringBitmap.add, it does a binary search in the high 16 bits of the value to figure out where to put the low 16 bits, but RoaringBitmapWriter assumes all adds are appends and optimises for it.", "author": "richardstartin", "createdAt": "2020-12-05T08:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyMTI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5MDg2Ng==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536890866", "bodyText": "From the code, I feel the benefit of serializing to ByteBuffer is to avoid the reverseBytes caused by BE to LE. How could it cause 20x performance difference? (Or the output stream is not buffered maybe?)", "author": "Jackie-Jiang", "createdAt": "2020-12-05T20:53:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyMTI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkxMjM1OA==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536912358", "bodyText": "I had a hard time believing it when this came up, but did enough profiling to figure out what was going on. The difference is up to 20x, and it depends on the composition of the bitmap: DataOutput penalises dense bitmaps more than others. DataOutput has to do things like manually extract bytes from int, long etc. and this adds up to a lot compared to a simple move instruction. Because of endianness, you get away without reversing the bytes, and with ByteBuffer various bounds checks get eliminated. You can see the difference even with a pre-sized ByteArrayOutputStream, so it's not a question of unbuffered IO.", "author": "richardstartin", "createdAt": "2020-12-05T23:21:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyMTI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4NjYwMg==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536886602", "bodyText": "(nit) same for other places\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (null != offsetBuffer) {\n          \n          \n            \n                    if (offsetBuffer != null) {", "author": "Jackie-Jiang", "createdAt": "2020-12-05T20:24:40Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -181,33 +188,51 @@ public void seal()\n     }\n \n     // Create bitmaps from inverted index buffers and serialize them to file\n-    try (DataOutputStream offsetDataStream = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)));\n-        FileOutputStream bitmapFileStream = new FileOutputStream(_invertedIndexFile);\n-        DataOutputStream bitmapDataStream = new DataOutputStream(new BufferedOutputStream(bitmapFileStream))) {\n-      int bitmapOffset = (_cardinality + 1) * Integer.BYTES;\n-      offsetDataStream.writeInt(bitmapOffset);\n-      bitmapFileStream.getChannel().position(bitmapOffset);\n-\n+    ByteBuffer offsetBuffer = null;\n+    ByteBuffer bitmapBuffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      // map the offsets buffer\n+      final int startOfBitmaps = (_cardinality + 1) * Integer.BYTES;\n+      int bitmapOffset = startOfBitmaps;\n+      offsetBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, bitmapOffset).order(LITTLE_ENDIAN);\n+      offsetBuffer.putInt(reverseBytes(bitmapOffset));\n+      RoaringBitmap[] bitmaps = new RoaringBitmap[_cardinality];\n+      RoaringBitmapWriter<RoaringBitmap> writer = RoaringBitmapWriter.writer()\n+              .initialCapacity(((_nextDocId - 1) >>> 16) / _cardinality).get();\n       int startIndex = 0;\n       for (int dictId = 0; dictId < _cardinality; dictId++) {\n-        MutableRoaringBitmap bitmap = new MutableRoaringBitmap();\n         int endIndex = getInt(_invertedIndexLengthBuffer, dictId);\n         for (int i = startIndex; i < endIndex; i++) {\n-          bitmap.add(getInt(_invertedIndexValueBuffer, i));\n+          writer.add(getInt(_invertedIndexValueBuffer, i));\n         }\n-        startIndex = endIndex;\n-\n-        // Write offset and bitmap into file\n-        bitmapOffset += bitmap.serializedSizeInBytes();\n+        bitmaps[dictId] = writer.get();\n+        writer.reset();\n+        int serializedSize = bitmaps[dictId].serializedSizeInBytes();\n+        bitmapOffset += serializedSize;\n         // Check for int overflow\n         Preconditions.checkState(bitmapOffset > 0, \"Inverted index file: %s exceeds 2GB limit\", _invertedIndexFile);\n-        offsetDataStream.writeInt(bitmapOffset);\n-        bitmap.serialize(bitmapDataStream);\n+        // write offset into file\n+        offsetBuffer.putInt(reverseBytes(bitmapOffset));\n+        startIndex = endIndex;\n+      }\n+      // we know how long the file should be now, so can map it\n+      bitmapBuffer = channel.map(FileChannel.MapMode.READ_WRITE, startOfBitmaps, bitmapOffset - startOfBitmaps);\n+      for (RoaringBitmap bitmap : bitmaps) {\n+        bitmap.serialize(bitmapBuffer);\n       }\n     } catch (Exception e) {\n       FileUtils.deleteQuietly(_invertedIndexFile);\n       throw e;\n+    } finally {\n+      if (CleanerUtil.UNMAP_SUPPORTED) {\n+        CleanerUtil.BufferCleaner cleaner = CleanerUtil.getCleaner();\n+        if (null != offsetBuffer) {", "originalCommit": "60861bc25110b94011091332a70a5e955e38405b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4NzI2OA==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536887268", "bodyText": "The offset buffer does not have to be LE, as all the values are written as BE", "author": "Jackie-Jiang", "createdAt": "2020-12-05T20:29:23Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -181,33 +188,51 @@ public void seal()\n     }\n \n     // Create bitmaps from inverted index buffers and serialize them to file\n-    try (DataOutputStream offsetDataStream = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)));\n-        FileOutputStream bitmapFileStream = new FileOutputStream(_invertedIndexFile);\n-        DataOutputStream bitmapDataStream = new DataOutputStream(new BufferedOutputStream(bitmapFileStream))) {\n-      int bitmapOffset = (_cardinality + 1) * Integer.BYTES;\n-      offsetDataStream.writeInt(bitmapOffset);\n-      bitmapFileStream.getChannel().position(bitmapOffset);\n-\n+    ByteBuffer offsetBuffer = null;\n+    ByteBuffer bitmapBuffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      // map the offsets buffer\n+      final int startOfBitmaps = (_cardinality + 1) * Integer.BYTES;\n+      int bitmapOffset = startOfBitmaps;\n+      offsetBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, bitmapOffset).order(LITTLE_ENDIAN);", "originalCommit": "60861bc25110b94011091332a70a5e955e38405b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4NzMzNw==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536887337", "bodyText": "Don't use static import in production class", "author": "Jackie-Jiang", "createdAt": "2020-12-05T20:29:46Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -19,18 +19,25 @@\n package org.apache.pinot.core.segment.creator.impl.inv;\n \n import com.google.common.base.Preconditions;\n-import java.io.BufferedOutputStream;\n+\n import java.io.Closeable;\n-import java.io.DataOutputStream;\n import java.io.File;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n import org.apache.commons.io.FileUtils;\n import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n import org.apache.pinot.core.segment.creator.impl.V1Constants;\n import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.util.CleanerUtil;\n import org.apache.pinot.spi.data.FieldSpec;\n-import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.RoaringBitmapWriter;\n+\n+import static java.lang.Integer.reverseBytes;", "originalCommit": "60861bc25110b94011091332a70a5e955e38405b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4NzM5MA==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536887390", "bodyText": "(nit) we don't usually use final for local variable", "author": "Jackie-Jiang", "createdAt": "2020-12-05T20:30:11Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -181,33 +188,51 @@ public void seal()\n     }\n \n     // Create bitmaps from inverted index buffers and serialize them to file\n-    try (DataOutputStream offsetDataStream = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)));\n-        FileOutputStream bitmapFileStream = new FileOutputStream(_invertedIndexFile);\n-        DataOutputStream bitmapDataStream = new DataOutputStream(new BufferedOutputStream(bitmapFileStream))) {\n-      int bitmapOffset = (_cardinality + 1) * Integer.BYTES;\n-      offsetDataStream.writeInt(bitmapOffset);\n-      bitmapFileStream.getChannel().position(bitmapOffset);\n-\n+    ByteBuffer offsetBuffer = null;\n+    ByteBuffer bitmapBuffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      // map the offsets buffer\n+      final int startOfBitmaps = (_cardinality + 1) * Integer.BYTES;", "originalCommit": "60861bc25110b94011091332a70a5e955e38405b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4NzYyNQ==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536887625", "bodyText": "Do RoaringBitmap and MutableRoaringBitmap serialize to the same bytes?", "author": "Jackie-Jiang", "createdAt": "2020-12-05T20:31:41Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -181,33 +188,51 @@ public void seal()\n     }\n \n     // Create bitmaps from inverted index buffers and serialize them to file\n-    try (DataOutputStream offsetDataStream = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)));\n-        FileOutputStream bitmapFileStream = new FileOutputStream(_invertedIndexFile);\n-        DataOutputStream bitmapDataStream = new DataOutputStream(new BufferedOutputStream(bitmapFileStream))) {\n-      int bitmapOffset = (_cardinality + 1) * Integer.BYTES;\n-      offsetDataStream.writeInt(bitmapOffset);\n-      bitmapFileStream.getChannel().position(bitmapOffset);\n-\n+    ByteBuffer offsetBuffer = null;\n+    ByteBuffer bitmapBuffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      // map the offsets buffer\n+      final int startOfBitmaps = (_cardinality + 1) * Integer.BYTES;\n+      int bitmapOffset = startOfBitmaps;\n+      offsetBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, bitmapOffset).order(LITTLE_ENDIAN);\n+      offsetBuffer.putInt(reverseBytes(bitmapOffset));\n+      RoaringBitmap[] bitmaps = new RoaringBitmap[_cardinality];", "originalCommit": "60861bc25110b94011091332a70a5e955e38405b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4OTM3OA==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536889378", "bodyText": "For off-heap creator, we don't want to keep all bitmaps on heap. We should try to create and serialize the bitmaps one by one. Not sure about the cost if we map a buffer per bitmap", "author": "Jackie-Jiang", "createdAt": "2020-12-05T20:43:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4NzYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkxMDg1MA==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536910850", "bodyText": "Do RoaringBitmap and MutableRoaringBitmap serialize to the same bytes?\n\nYes, they do.\n\nFor off-heap creator, we don't want to keep all bitmaps on heap. We should try to create and serialize the bitmaps one by one. Not sure about the cost if we map a buffer per bitmap\n\nI can see the incentive not to allocate so much on heap, but the alternative is mapping many times (and it's a relatively costly operation) or mapping too many bytes and truncating the channel. I have done the latter in the past to get round this, but there may be downsides I'm unaware of. I've updated to use this strategy and allocation pressure is indeed reduced.", "author": "richardstartin", "createdAt": "2020-12-05T23:10:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4NzYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4OTgyOQ==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536889829", "bodyText": "Why do you need to divide it with _cardinality? Though this should be .expectedRange(0, _nextDocId)?", "author": "Jackie-Jiang", "createdAt": "2020-12-05T20:46:25Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -181,33 +188,51 @@ public void seal()\n     }\n \n     // Create bitmaps from inverted index buffers and serialize them to file\n-    try (DataOutputStream offsetDataStream = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)));\n-        FileOutputStream bitmapFileStream = new FileOutputStream(_invertedIndexFile);\n-        DataOutputStream bitmapDataStream = new DataOutputStream(new BufferedOutputStream(bitmapFileStream))) {\n-      int bitmapOffset = (_cardinality + 1) * Integer.BYTES;\n-      offsetDataStream.writeInt(bitmapOffset);\n-      bitmapFileStream.getChannel().position(bitmapOffset);\n-\n+    ByteBuffer offsetBuffer = null;\n+    ByteBuffer bitmapBuffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      // map the offsets buffer\n+      final int startOfBitmaps = (_cardinality + 1) * Integer.BYTES;\n+      int bitmapOffset = startOfBitmaps;\n+      offsetBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, bitmapOffset).order(LITTLE_ENDIAN);\n+      offsetBuffer.putInt(reverseBytes(bitmapOffset));\n+      RoaringBitmap[] bitmaps = new RoaringBitmap[_cardinality];\n+      RoaringBitmapWriter<RoaringBitmap> writer = RoaringBitmapWriter.writer()\n+              .initialCapacity(((_nextDocId - 1) >>> 16) / _cardinality).get();", "originalCommit": "60861bc25110b94011091332a70a5e955e38405b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkxMTE2MA==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536911160", "bodyText": "This is just a heuristic that the keys of the bitmap will be evenly distributed across the dictionary ids. It won't always be perfect, but is never that bad. I can provide more justification.", "author": "richardstartin", "createdAt": "2020-12-05T23:12:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4OTgyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyMzI5OA==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r537123298", "bodyText": "From my understanding, this method preallocate the arrays based on the size of the prefix keys. Since we are going to reuse this writer for all the bitmaps, we will always end up using all the prefix keys from (0, _nextDocId), and we should use .expectedRange(0, _nextDocId) to preallocate all of them. Maybe I missed something here?", "author": "Jackie-Jiang", "createdAt": "2020-12-06T21:05:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4OTgyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEzMjcxNQ==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r537132715", "bodyText": "I felt this heuristic was distracting so removed it.\nIn case this comes up in the future, expecting the range to be [0, _nextDocId) would allocate far too much memory for datasets sorted by the indexed dimension, but would be the right choice if the association between row id and dictionary id were uniformly random. Some in-memory metadata could probably be associated with each dictionary id (number of documents, min, max, density?) and would mean these methods could likely be used more effectively, and not in a way that overfits to a benchmark.", "author": "richardstartin", "createdAt": "2020-12-06T21:58:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4OTgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5MDMwNw==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536890307", "bodyText": "Do you need to flush() before getUnderlying()? Or just use get() to retrieve the bitmap?", "author": "Jackie-Jiang", "createdAt": "2020-12-05T20:49:27Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OnHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -19,68 +19,85 @@\n package org.apache.pinot.core.segment.creator.impl.inv;\n \n import com.google.common.base.Preconditions;\n-import java.io.BufferedOutputStream;\n-import java.io.DataOutputStream;\n+\n+\n import java.io.File;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n import org.apache.commons.io.FileUtils;\n import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n import org.apache.pinot.core.segment.creator.impl.V1Constants;\n+import org.apache.pinot.core.util.CleanerUtil;\n+import org.roaringbitmap.RoaringBitmapWriter;\n import org.roaringbitmap.buffer.MutableRoaringBitmap;\n \n+import static java.nio.ByteOrder.LITTLE_ENDIAN;\n+\n \n /**\n  * Implementation of {@link DictionaryBasedInvertedIndexCreator} that uses on-heap memory.\n  */\n public final class OnHeapBitmapInvertedIndexCreator implements DictionaryBasedInvertedIndexCreator {\n   private final File _invertedIndexFile;\n-  private final MutableRoaringBitmap[] _bitmaps;\n+  private final RoaringBitmapWriter<MutableRoaringBitmap>[] _bitmapWriters;\n   private int _nextDocId;\n \n+  @SuppressWarnings(\"unchecked\")\n   public OnHeapBitmapInvertedIndexCreator(File indexDir, String columnName, int cardinality) {\n     _invertedIndexFile = new File(indexDir, columnName + V1Constants.Indexes.BITMAP_INVERTED_INDEX_FILE_EXTENSION);\n-    _bitmaps = new MutableRoaringBitmap[cardinality];\n+    _bitmapWriters = new RoaringBitmapWriter[cardinality];\n     for (int i = 0; i < cardinality; i++) {\n-      _bitmaps[i] = new MutableRoaringBitmap();\n+      _bitmapWriters[i] = RoaringBitmapWriter.bufferWriter().get();\n     }\n   }\n \n   @Override\n   public void add(int dictId) {\n-    _bitmaps[dictId].add(_nextDocId++);\n+    _bitmapWriters[dictId].add(_nextDocId++);\n   }\n \n   @Override\n   public void add(int[] dictIds, int length) {\n     for (int i = 0; i < length; i++) {\n-      _bitmaps[dictIds[i]].add(_nextDocId);\n+      _bitmapWriters[dictIds[i]].add(_nextDocId);\n     }\n     _nextDocId++;\n   }\n \n   @Override\n   public void seal()\n       throws IOException {\n-    try (DataOutputStream out = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)))) {\n+    // calculate file size\n+    int size = (_bitmapWriters.length + 1) * Integer.BYTES;\n+    for (RoaringBitmapWriter<MutableRoaringBitmap> writer : _bitmapWriters) {\n+      size += writer.get().serializedSizeInBytes();\n+      // Check for int overflow\n+      Preconditions.checkState(size > 0, \"Inverted index file: %s exceeds 2GB limit\", _invertedIndexFile);\n+    }\n+    ByteBuffer buffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size).order(LITTLE_ENDIAN);\n       // Write bitmap offsets\n-      int bitmapOffset = (_bitmaps.length + 1) * Integer.BYTES;\n-      out.writeInt(bitmapOffset);\n-      for (MutableRoaringBitmap bitmap : _bitmaps) {\n-        bitmapOffset += bitmap.serializedSizeInBytes();\n-        // Check for int overflow\n-        Preconditions.checkState(bitmapOffset > 0, \"Inverted index file: %s exceeds 2GB limit\", _invertedIndexFile);\n-        out.writeInt(bitmapOffset);\n+      int bitmapOffset = (_bitmapWriters.length + 1) * Integer.BYTES;\n+      buffer.putInt(Integer.reverseBytes(bitmapOffset));\n+      for (RoaringBitmapWriter<MutableRoaringBitmap> writer : _bitmapWriters) {\n+        bitmapOffset += writer.getUnderlying().serializedSizeInBytes();", "originalCommit": "60861bc25110b94011091332a70a5e955e38405b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkxMTM5Nw==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536911397", "bodyText": "This API is a little bit overcomplicated. getUnderlying() gets the bitmap, without flushing. flush() flushes. get() flushes and gets the bitmap. I shouldn't have used getUnderlying() here because it's confusing, perhaps it should be deprecated", "author": "richardstartin", "createdAt": "2020-12-05T23:14:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5MDMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5MDM4MQ==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536890381", "bodyText": "Maybe keeping 2 buffers similar to the off-heap one?", "author": "Jackie-Jiang", "createdAt": "2020-12-05T20:49:59Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OnHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -19,68 +19,85 @@\n package org.apache.pinot.core.segment.creator.impl.inv;\n \n import com.google.common.base.Preconditions;\n-import java.io.BufferedOutputStream;\n-import java.io.DataOutputStream;\n+\n+\n import java.io.File;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n import org.apache.commons.io.FileUtils;\n import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n import org.apache.pinot.core.segment.creator.impl.V1Constants;\n+import org.apache.pinot.core.util.CleanerUtil;\n+import org.roaringbitmap.RoaringBitmapWriter;\n import org.roaringbitmap.buffer.MutableRoaringBitmap;\n \n+import static java.nio.ByteOrder.LITTLE_ENDIAN;\n+\n \n /**\n  * Implementation of {@link DictionaryBasedInvertedIndexCreator} that uses on-heap memory.\n  */\n public final class OnHeapBitmapInvertedIndexCreator implements DictionaryBasedInvertedIndexCreator {\n   private final File _invertedIndexFile;\n-  private final MutableRoaringBitmap[] _bitmaps;\n+  private final RoaringBitmapWriter<MutableRoaringBitmap>[] _bitmapWriters;\n   private int _nextDocId;\n \n+  @SuppressWarnings(\"unchecked\")\n   public OnHeapBitmapInvertedIndexCreator(File indexDir, String columnName, int cardinality) {\n     _invertedIndexFile = new File(indexDir, columnName + V1Constants.Indexes.BITMAP_INVERTED_INDEX_FILE_EXTENSION);\n-    _bitmaps = new MutableRoaringBitmap[cardinality];\n+    _bitmapWriters = new RoaringBitmapWriter[cardinality];\n     for (int i = 0; i < cardinality; i++) {\n-      _bitmaps[i] = new MutableRoaringBitmap();\n+      _bitmapWriters[i] = RoaringBitmapWriter.bufferWriter().get();\n     }\n   }\n \n   @Override\n   public void add(int dictId) {\n-    _bitmaps[dictId].add(_nextDocId++);\n+    _bitmapWriters[dictId].add(_nextDocId++);\n   }\n \n   @Override\n   public void add(int[] dictIds, int length) {\n     for (int i = 0; i < length; i++) {\n-      _bitmaps[dictIds[i]].add(_nextDocId);\n+      _bitmapWriters[dictIds[i]].add(_nextDocId);\n     }\n     _nextDocId++;\n   }\n \n   @Override\n   public void seal()\n       throws IOException {\n-    try (DataOutputStream out = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)))) {\n+    // calculate file size\n+    int size = (_bitmapWriters.length + 1) * Integer.BYTES;\n+    for (RoaringBitmapWriter<MutableRoaringBitmap> writer : _bitmapWriters) {\n+      size += writer.get().serializedSizeInBytes();\n+      // Check for int overflow\n+      Preconditions.checkState(size > 0, \"Inverted index file: %s exceeds 2GB limit\", _invertedIndexFile);\n+    }\n+    ByteBuffer buffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size).order(LITTLE_ENDIAN);", "originalCommit": "60861bc25110b94011091332a70a5e955e38405b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkxMTQwNw==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r536911407", "bodyText": "Yes that's a good idea.", "author": "richardstartin", "createdAt": "2020-12-05T23:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5MDM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyNDYyMQ==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r537124621", "bodyText": "Maybe we can use the same way as the off-heap creator to preallocate a huge buffer then truncate to save the calculation of the serialized size (we calculate that twice for each bitmap)?", "author": "Jackie-Jiang", "createdAt": "2020-12-06T21:13:17Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OnHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -19,68 +19,96 @@\n package org.apache.pinot.core.segment.creator.impl.inv;\n \n import com.google.common.base.Preconditions;\n-import java.io.BufferedOutputStream;\n-import java.io.DataOutputStream;\n+\n+\n import java.io.File;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+\n import org.apache.commons.io.FileUtils;\n import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n import org.apache.pinot.core.segment.creator.impl.V1Constants;\n-import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.apache.pinot.core.util.CleanerUtil;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.RoaringBitmapWriter;\n \n \n /**\n  * Implementation of {@link DictionaryBasedInvertedIndexCreator} that uses on-heap memory.\n  */\n public final class OnHeapBitmapInvertedIndexCreator implements DictionaryBasedInvertedIndexCreator {\n   private final File _invertedIndexFile;\n-  private final MutableRoaringBitmap[] _bitmaps;\n+  private final RoaringBitmapWriter<RoaringBitmap>[] _bitmapWriters;\n   private int _nextDocId;\n \n+  @SuppressWarnings(\"unchecked\")\n   public OnHeapBitmapInvertedIndexCreator(File indexDir, String columnName, int cardinality) {\n     _invertedIndexFile = new File(indexDir, columnName + V1Constants.Indexes.BITMAP_INVERTED_INDEX_FILE_EXTENSION);\n-    _bitmaps = new MutableRoaringBitmap[cardinality];\n+    _bitmapWriters = new RoaringBitmapWriter[cardinality];\n     for (int i = 0; i < cardinality; i++) {\n-      _bitmaps[i] = new MutableRoaringBitmap();\n+      _bitmapWriters[i] = RoaringBitmapWriter.writer().get();\n     }\n   }\n \n   @Override\n   public void add(int dictId) {\n-    _bitmaps[dictId].add(_nextDocId++);\n+    _bitmapWriters[dictId].add(_nextDocId++);\n   }\n \n   @Override\n   public void add(int[] dictIds, int length) {\n     for (int i = 0; i < length; i++) {\n-      _bitmaps[dictIds[i]].add(_nextDocId);\n+      _bitmapWriters[dictIds[i]].add(_nextDocId);\n     }\n     _nextDocId++;\n   }\n \n   @Override\n   public void seal()\n       throws IOException {\n-    try (DataOutputStream out = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)))) {\n+    // calculate file size\n+    int startOfBitmaps = (_bitmapWriters.length + 1) * Integer.BYTES;\n+    int size = 0;\n+    for (RoaringBitmapWriter<RoaringBitmap> writer : _bitmapWriters) {\n+      size += writer.get().serializedSizeInBytes();", "originalCommit": "e3ec220081689a08ff4da20f1f5c2ff5e269882c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEzMjgxNA==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r537132814", "bodyText": "Yes, good suggestion, I applied this change.", "author": "richardstartin", "createdAt": "2020-12-06T21:59:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyNDYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4OTQ1Nw==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r537789457", "bodyText": "Please reformat this file to fix the indentation (should be 2 spaces) for this file", "author": "Jackie-Jiang", "createdAt": "2020-12-07T19:55:39Z", "path": "pinot-perf/src/main/java/org/apache/pinot/perf/BenchmarkOffheapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.pinot.perf;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.segment.creator.impl.inv.OffHeapBitmapInvertedIndexCreator;\n+import org.apache.pinot.spi.data.DimensionFieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.options.ChainedOptionsBuilder;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+@State(Scope.Benchmark)\n+public class BenchmarkOffheapBitmapInvertedIndexCreator {", "originalCommit": "92d995341f68f8c7dbc103efc3897b548dae7c2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyODc0Nw==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r537828747", "bodyText": "Done", "author": "richardstartin", "createdAt": "2020-12-07T20:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4OTQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5Mzg0MA==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r537793840", "bodyText": "I see your point. We won't create bitmap inverted index if the values are sorted (we have another RLE format), so in most cases, the docIds will spread over all the arrays. But for high cardinality case where each bitmap only contain very few values, pre-allocation might end up allocating too many arrays. So agree with letting it grow automatically.", "author": "Jackie-Jiang", "createdAt": "2020-12-07T20:02:28Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OffHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -181,33 +184,45 @@ public void seal()\n     }\n \n     // Create bitmaps from inverted index buffers and serialize them to file\n-    try (DataOutputStream offsetDataStream = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)));\n-        FileOutputStream bitmapFileStream = new FileOutputStream(_invertedIndexFile);\n-        DataOutputStream bitmapDataStream = new DataOutputStream(new BufferedOutputStream(bitmapFileStream))) {\n-      int bitmapOffset = (_cardinality + 1) * Integer.BYTES;\n-      offsetDataStream.writeInt(bitmapOffset);\n-      bitmapFileStream.getChannel().position(bitmapOffset);\n-\n+    ByteBuffer offsetBuffer = null;\n+    ByteBuffer bitmapBuffer = null;\n+    try (FileChannel channel = new RandomAccessFile(_invertedIndexFile, \"rw\").getChannel()) {\n+      // map the offsets buffer\n+      int startOfBitmaps = (_cardinality + 1) * Integer.BYTES;\n+      offsetBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, startOfBitmaps)\n+              .order(ByteOrder.BIG_ENDIAN);\n+      offsetBuffer.putInt(startOfBitmaps);\n+      bitmapBuffer = channel.map(FileChannel.MapMode.READ_WRITE, startOfBitmaps, Integer.MAX_VALUE - startOfBitmaps)\n+              .order(ByteOrder.LITTLE_ENDIAN);\n+      RoaringBitmapWriter<RoaringBitmap> writer = RoaringBitmapWriter.writer().get();", "originalCommit": "92d995341f68f8c7dbc103efc3897b548dae7c2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgxMTA5OQ==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r537811099", "bodyText": "If that's the case, currently this will try to RLE each container when it's appended to the bitmap. Would you prefer I remove that when I reformat the file?", "author": "richardstartin", "createdAt": "2020-12-07T20:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5Mzg0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyODQ2NA==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r537828464", "bodyText": "I disabled run compression, which will save some cycles if this is only used for sparse bitmaps.", "author": "richardstartin", "createdAt": "2020-12-07T20:59:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5Mzg0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0NzY5Mw==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r537847693", "bodyText": "The bitmap could be dense (when cardinality is very low), but won't be contiguous. What is the old behavior? We don't explicitly call runOptimize() on the MutableRoaringBitmap, will it perform RLE automatically? If not, we can disable it here to keep the same behavior and have better performance.", "author": "Jackie-Jiang", "createdAt": "2020-12-07T21:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5Mzg0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg3NDA5MQ==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r537874091", "bodyText": "No run length encoding was being done before", "author": "richardstartin", "createdAt": "2020-12-07T22:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5Mzg0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgzNTI5MQ==", "url": "https://github.com/apache/pinot/pull/6320#discussion_r537835291", "bodyText": "this comment is now misleading, will remove it", "author": "richardstartin", "createdAt": "2020-12-07T21:10:49Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/OnHeapBitmapInvertedIndexCreator.java", "diffHunk": "@@ -18,69 +18,85 @@\n  */\n package org.apache.pinot.core.segment.creator.impl.inv;\n \n-import com.google.common.base.Preconditions;\n-import java.io.BufferedOutputStream;\n-import java.io.DataOutputStream;\n+\n import java.io.File;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+\n import org.apache.commons.io.FileUtils;\n import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n import org.apache.pinot.core.segment.creator.impl.V1Constants;\n-import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.apache.pinot.core.util.CleanerUtil;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.RoaringBitmapWriter;\n \n \n /**\n  * Implementation of {@link DictionaryBasedInvertedIndexCreator} that uses on-heap memory.\n  */\n public final class OnHeapBitmapInvertedIndexCreator implements DictionaryBasedInvertedIndexCreator {\n   private final File _invertedIndexFile;\n-  private final MutableRoaringBitmap[] _bitmaps;\n+  private final RoaringBitmapWriter<RoaringBitmap>[] _bitmapWriters;\n   private int _nextDocId;\n \n+  @SuppressWarnings(\"unchecked\")\n   public OnHeapBitmapInvertedIndexCreator(File indexDir, String columnName, int cardinality) {\n     _invertedIndexFile = new File(indexDir, columnName + V1Constants.Indexes.BITMAP_INVERTED_INDEX_FILE_EXTENSION);\n-    _bitmaps = new MutableRoaringBitmap[cardinality];\n+    _bitmapWriters = new RoaringBitmapWriter[cardinality];\n     for (int i = 0; i < cardinality; i++) {\n-      _bitmaps[i] = new MutableRoaringBitmap();\n+      _bitmapWriters[i] = RoaringBitmapWriter.writer().runCompress(false).get();\n     }\n   }\n \n   @Override\n   public void add(int dictId) {\n-    _bitmaps[dictId].add(_nextDocId++);\n+    _bitmapWriters[dictId].add(_nextDocId++);\n   }\n \n   @Override\n   public void add(int[] dictIds, int length) {\n     for (int i = 0; i < length; i++) {\n-      _bitmaps[dictIds[i]].add(_nextDocId);\n+      _bitmapWriters[dictIds[i]].add(_nextDocId);\n     }\n     _nextDocId++;\n   }\n \n   @Override\n   public void seal()\n       throws IOException {\n-    try (DataOutputStream out = new DataOutputStream(\n-        new BufferedOutputStream(new FileOutputStream(_invertedIndexFile)))) {\n+    // calculate file size", "originalCommit": "72e9d8dc61a3d3b6e04b601afa1b6c6e8b1ff302", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "725e2188de831f53bb1f65364f29320df2142fce", "url": "https://github.com/apache/pinot/commit/725e2188de831f53bb1f65364f29320df2142fce", "message": "use RoaringBitmapWriter and direct to ByteBuffer serialization in BitmapInvertedIndexCreators", "committedDate": "2020-12-07T22:14:51Z", "type": "commit"}]}