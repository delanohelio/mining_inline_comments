{"pr_number": 6004, "pr_title": "Enhance DistinctCountThetaSketchAggregationFunction", "pr_createdAt": "2020-09-11T07:06:01Z", "pr_url": "https://github.com/apache/pinot/pull/6004", "timeline": [{"oid": "51f718ee26d372576607c445ff406c57186f0153", "url": "https://github.com/apache/pinot/commit/51f718ee26d372576607c445ff406c57186f0153", "message": "Add ThetaSketchAggregationFunction", "committedDate": "2020-09-28T18:01:21Z", "type": "commit"}, {"oid": "06155e45364b92ba23edbda5d89bab1dd4539736", "url": "https://github.com/apache/pinot/commit/06155e45364b92ba23edbda5d89bab1dd4539736", "message": "Replace the old DistinctCount(Raw)ThetaSketchAggregationFunction with the new one\n\nAlso fix the issue in BaseBrokerRequestHandler.updateColumnNames()", "committedDate": "2020-09-29T05:18:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NDY0Mg==", "url": "https://github.com/apache/pinot/pull/6004#discussion_r496864642", "bodyText": "Nit: Can a static final be used here (to avoid creating new object)?", "author": "mayankshriv", "createdAt": "2020-09-29T16:15:49Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java", "diffHunk": "@@ -776,6 +783,69 @@ public IdSet deserialize(ByteBuffer byteBuffer) {\n     }\n   };\n \n+  public static final ObjectSerDe<List<Object>> LIST_SER_DE = new ObjectSerDe<List<Object>>() {\n+\n+    @Override\n+    public byte[] serialize(List<Object> list) {\n+      int size = list.size();\n+\n+      // Directly return the size (0) for empty list\n+      if (size == 0) {\n+        return new byte[Integer.BYTES];", "originalCommit": "06155e45364b92ba23edbda5d89bab1dd4539736", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyMjkyNg==", "url": "https://github.com/apache/pinot/pull/6004#discussion_r496922926", "bodyText": "It is safer to not reuse this as we have no control on not modifying it", "author": "Jackie-Jiang", "createdAt": "2020-09-29T17:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NDY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NTIwMg==", "url": "https://github.com/apache/pinot/pull/6004#discussion_r496865202", "bodyText": "Please also add why in the comment.", "author": "mayankshriv", "createdAt": "2020-09-29T16:16:24Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java", "diffHunk": "@@ -776,6 +783,69 @@ public IdSet deserialize(ByteBuffer byteBuffer) {\n     }\n   };\n \n+  public static final ObjectSerDe<List<Object>> LIST_SER_DE = new ObjectSerDe<List<Object>>() {\n+\n+    @Override\n+    public byte[] serialize(List<Object> list) {\n+      int size = list.size();\n+\n+      // Directly return the size (0) for empty list\n+      if (size == 0) {\n+        return new byte[Integer.BYTES];\n+      }\n+\n+      // No need to close these 2 streams", "originalCommit": "06155e45364b92ba23edbda5d89bab1dd4539736", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyMzUyNQ==", "url": "https://github.com/apache/pinot/pull/6004#discussion_r496923525", "bodyText": "Added", "author": "Jackie-Jiang", "createdAt": "2020-09-29T17:42:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NTIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4NzUyOQ==", "url": "https://github.com/apache/pinot/pull/6004#discussion_r496887529", "bodyText": "What about predicates, and post-aggregation expression? Are those arguments not supported?", "author": "mayankshriv", "createdAt": "2020-09-29T16:44:31Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountRawThetaSketchAggregationFunction.java", "diffHunk": "@@ -18,118 +18,529 @@\n  */\n package org.apache.pinot.core.query.aggregation.function;\n \n+import com.google.common.base.Preconditions;\n+import java.util.Base64;\n import java.util.List;\n import java.util.Map;\n-import org.apache.calcite.sql.parser.SqlParseException;\n+import org.apache.datasketches.memory.Memory;\n+import org.apache.datasketches.theta.SetOperationBuilder;\n import org.apache.datasketches.theta.Sketch;\n+import org.apache.datasketches.theta.Union;\n+import org.apache.datasketches.theta.UpdateSketch;\n+import org.apache.datasketches.theta.UpdateSketchBuilder;\n import org.apache.pinot.common.function.AggregationFunctionType;\n-import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n import org.apache.pinot.core.common.BlockValSet;\n import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.function.DistinctCountThetaSketchAggregationFunction.Parameters;\n import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n import org.apache.pinot.core.query.request.context.ExpressionContext;\n-import org.apache.pinot.spi.utils.ByteArray;\n-\n-import static org.apache.pinot.common.utils.DataSchema.ColumnDataType.BYTES;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n \n \n /**\n- * A variation of the {@link DistinctCountThetaSketchAggregationFunction} that returns the serialized bytes\n- * of the theta-sketch, as opposed to the actual distinct value.\n- *\n- * Note: It would have been natural for this class to extend the {@link DistinctCountThetaSketchAggregationFunction},\n- * except that the return type for this class is a String, as opposed to Integer for the former, due to which the\n- * extension is not possible.\n+ * The {@code DistinctCountRawThetaSketchAggregationFunction} collects the values for a given expression (can be\n+ * single-valued or multi-valued) into a {@link Sketch} object, and returns the sketch as a base64 encoded string. It\n+ * treats BYTES expression as serialized sketches.\n+ * <p>The function takes an optional second argument as the parameters for the function. Currently there is only 1", "originalCommit": "06155e45364b92ba23edbda5d89bab1dd4539736", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5MDMxMg==", "url": "https://github.com/apache/pinot/pull/6004#discussion_r496890312", "bodyText": "Why is the raw version not able to re-use the non-raw version of the code as in the previous implementation?", "author": "mayankshriv", "createdAt": "2020-09-29T16:48:36Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountRawThetaSketchAggregationFunction.java", "diffHunk": "@@ -18,118 +18,529 @@\n  */\n package org.apache.pinot.core.query.aggregation.function;\n \n+import com.google.common.base.Preconditions;\n+import java.util.Base64;\n import java.util.List;\n import java.util.Map;\n-import org.apache.calcite.sql.parser.SqlParseException;\n+import org.apache.datasketches.memory.Memory;\n+import org.apache.datasketches.theta.SetOperationBuilder;\n import org.apache.datasketches.theta.Sketch;\n+import org.apache.datasketches.theta.Union;\n+import org.apache.datasketches.theta.UpdateSketch;\n+import org.apache.datasketches.theta.UpdateSketchBuilder;\n import org.apache.pinot.common.function.AggregationFunctionType;\n-import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n import org.apache.pinot.core.common.BlockValSet;\n import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.function.DistinctCountThetaSketchAggregationFunction.Parameters;\n import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n import org.apache.pinot.core.query.request.context.ExpressionContext;\n-import org.apache.pinot.spi.utils.ByteArray;\n-\n-import static org.apache.pinot.common.utils.DataSchema.ColumnDataType.BYTES;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n \n \n /**\n- * A variation of the {@link DistinctCountThetaSketchAggregationFunction} that returns the serialized bytes\n- * of the theta-sketch, as opposed to the actual distinct value.\n- *\n- * Note: It would have been natural for this class to extend the {@link DistinctCountThetaSketchAggregationFunction},\n- * except that the return type for this class is a String, as opposed to Integer for the former, due to which the\n- * extension is not possible.\n+ * The {@code DistinctCountRawThetaSketchAggregationFunction} collects the values for a given expression (can be\n+ * single-valued or multi-valued) into a {@link Sketch} object, and returns the sketch as a base64 encoded string. It\n+ * treats BYTES expression as serialized sketches.\n+ * <p>The function takes an optional second argument as the parameters for the function. Currently there is only 1\n+ * parameter for the function:\n+ * <ul>\n+ *   <li>\n+ *     nominalEntries: The nominal entries used to create the sketch. (Default 4096)\n+ *   </li>\n+ * </ul>\n+ * <p>Example: DISTINCT_COUNT_RAW_THETA_SKETCH(col, 'nominalEntries=8192')\n  */\n-public class DistinctCountRawThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, ByteArray> {\n-  private final DistinctCountThetaSketchAggregationFunction _thetaSketchAggregationFunction;\n+public class DistinctCountRawThetaSketchAggregationFunction extends BaseSingleInputAggregationFunction<Sketch, String> {\n+  private final UpdateSketchBuilder _updateSketchBuilder = new UpdateSketchBuilder();\n+  private final SetOperationBuilder _setOperationBuilder = new SetOperationBuilder();\n+\n+  public DistinctCountRawThetaSketchAggregationFunction(List<ExpressionContext> arguments) {\n+    super(arguments.get(0));\n \n-  public DistinctCountRawThetaSketchAggregationFunction(List<ExpressionContext> arguments)\n-      throws SqlParseException {\n-    _thetaSketchAggregationFunction = new DistinctCountThetaSketchAggregationFunction(arguments);\n+    // Optional second argument for theta-sketch parameters\n+    if (arguments.size() > 1) {\n+      ExpressionContext paramsExpression = arguments.get(1);\n+      Preconditions.checkArgument(paramsExpression.getType() == ExpressionContext.Type.LITERAL,\n+          \"Second argument of DISTINCT_COUNT_RAW_THETA_SKETCH aggregation function must be literal (parameters)\");\n+      Parameters parameters = new Parameters(paramsExpression.getLiteral());\n+      int nominalEntries = parameters.getNominalEntries();\n+      _updateSketchBuilder.setNominalEntries(nominalEntries);\n+      _setOperationBuilder.setNominalEntries(nominalEntries);\n+    }\n   }\n \n   @Override\n   public AggregationFunctionType getType() {\n     return AggregationFunctionType.DISTINCTCOUNTRAWTHETASKETCH;\n   }\n \n-  @Override\n-  public String getColumnName() {\n-    return _thetaSketchAggregationFunction.getColumnName();\n-  }\n-\n-  @Override\n-  public String getResultColumnName() {\n-    return _thetaSketchAggregationFunction.getResultColumnName();\n-  }\n-\n-  @Override\n-  public List<ExpressionContext> getInputExpressions() {\n-    return _thetaSketchAggregationFunction.getInputExpressions();\n-  }\n-\n   @Override\n   public AggregationResultHolder createAggregationResultHolder() {\n-    return _thetaSketchAggregationFunction.createAggregationResultHolder();\n+    return new ObjectAggregationResultHolder();\n   }\n \n   @Override\n   public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n-    return _thetaSketchAggregationFunction.createGroupByResultHolder(initialCapacity, maxCapacity);\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n   }\n \n   @Override\n   public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n       Map<ExpressionContext, BlockValSet> blockValSetMap) {\n-    _thetaSketchAggregationFunction.aggregate(length, aggregationResultHolder, blockValSetMap);\n+    BlockValSet blockValSet = blockValSetMap.get(_expression);", "originalCommit": "06155e45364b92ba23edbda5d89bab1dd4539736", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5MzMyMA==", "url": "https://github.com/apache/pinot/pull/6004#discussion_r496893320", "bodyText": "Use enum for set operations?", "author": "mayankshriv", "createdAt": "2020-09-29T16:53:05Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -19,136 +19,144 @@\n package org.apache.pinot.core.query.aggregation.function;\n \n import com.google.common.base.Preconditions;\n-import com.google.common.collect.ImmutableList;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n import org.apache.calcite.sql.parser.SqlParseException;\n-import org.apache.commons.collections.MapUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.datasketches.Util;\n import org.apache.datasketches.memory.Memory;\n import org.apache.datasketches.theta.AnotB;\n import org.apache.datasketches.theta.Intersection;\n import org.apache.datasketches.theta.SetOperationBuilder;\n import org.apache.datasketches.theta.Sketch;\n import org.apache.datasketches.theta.Union;\n+import org.apache.datasketches.theta.UpdateSketch;\n+import org.apache.datasketches.theta.UpdateSketchBuilder;\n import org.apache.pinot.common.function.AggregationFunctionType;\n-import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n import org.apache.pinot.core.common.BlockValSet;\n import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluator;\n import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluatorProvider;\n import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n-import org.apache.pinot.core.query.aggregation.function.RawThetaSketchAggregationFunction.Parameters;\n import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n import org.apache.pinot.core.query.request.context.ExpressionContext;\n import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.FunctionContext;\n import org.apache.pinot.core.query.request.context.predicate.Predicate;\n import org.apache.pinot.core.query.request.context.utils.QueryContextConverterUtils;\n-import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n import org.apache.pinot.sql.parsers.CalciteSqlParser;\n \n \n /**\n- * Implementation of {@link AggregationFunction} to perform the distinct count aggregation using\n- * Theta Sketches.\n- * <p>TODO: For performance concern, use {@code List<Sketch>} as the intermediate result.\n+ * The {@code DistinctCountThetaSketchAggregationFunction} can be used in 2 modes:\n+ * <ul>\n+ *   <li>\n+ *     Simple union without post-aggregation (1 or 2 arguments): main expression to aggregate on, optional theta-sketch\n+ *     parameters\n+ *     <p>E.g. DISTINCT_COUNT_THETA_SKETCH(col)\n+ *   </li>\n+ *   <li>\n+ *     Union with post-aggregation (at least 4 arguments): main expression to aggregate on, theta-sketch parameters,\n+ *     filter(s), post-aggregation expression\n+ *     <p>E.g. DISTINCT_COUNT_THETA_SKETCH(col, '', 'dimName=''gender'' AND dimValue=''male''',\n+ *     'dimName=''course'' AND dimValue=''math''', 'SET_INTERSECT($1,$2)')\n+ *   </li>\n+ * </ul>\n+ * Currently there is only 1 parameter for the function:\n+ * <ul>\n+ *   <li>\n+ *     nominalEntries: The nominal entries used to create the sketch. (Default 4096)\n+ *   </li>\n+ * </ul>\n+ * <p>E.g. DISTINCT_COUNT_THETA_SKETCH(col, 'nominalEntries=8192')\n  */\n-public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Long> {\n-\n-  public enum MergeFunction {\n-    SET_UNION, SET_INTERSECT, SET_DIFF;\n-\n-    public static final ImmutableList<String> STRING_VALUES =\n-        ImmutableList.of(SET_UNION.name(), SET_INTERSECT.name(), SET_DIFF.name());\n-\n-    public static final String CSV_VALUES = String.join(\",\", STRING_VALUES);\n-\n-    public static boolean isValid(String name) {\n-      return SET_UNION.name().equalsIgnoreCase(name) || SET_INTERSECT.name().equalsIgnoreCase(name) || SET_DIFF.name()\n-          .equalsIgnoreCase(name);\n-    }\n-  }\n-\n-  private static final Pattern ARGUMENT_SUBSTITUTION = Pattern.compile(\"\\\\$(\\\\d+)\");\n-\n-  private final ExpressionContext _thetaSketchColumn;\n-  private final SetOperationBuilder _setOperationBuilder;\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<List<Sketch>, Long> {\n+  private static final String SET_UNION = \"SET_UNION\";", "originalCommit": "06155e45364b92ba23edbda5d89bab1dd4539736", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNTczMQ==", "url": "https://github.com/apache/pinot/pull/6004#discussion_r496925731", "bodyText": "Using string has these 2 benefits over enum:\n\nSave the extra parsing of the enum\nSimplify the handling of invalid operations", "author": "Jackie-Jiang", "createdAt": "2020-09-29T17:46:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5MzMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxNzIzNA==", "url": "https://github.com/apache/pinot/pull/6004#discussion_r496917234", "bodyText": "Just to ensure, we have test for this?", "author": "mayankshriv", "createdAt": "2020-09-29T17:32:02Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -19,136 +19,144 @@\n package org.apache.pinot.core.query.aggregation.function;\n \n import com.google.common.base.Preconditions;\n-import com.google.common.collect.ImmutableList;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n import org.apache.calcite.sql.parser.SqlParseException;\n-import org.apache.commons.collections.MapUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.datasketches.Util;\n import org.apache.datasketches.memory.Memory;\n import org.apache.datasketches.theta.AnotB;\n import org.apache.datasketches.theta.Intersection;\n import org.apache.datasketches.theta.SetOperationBuilder;\n import org.apache.datasketches.theta.Sketch;\n import org.apache.datasketches.theta.Union;\n+import org.apache.datasketches.theta.UpdateSketch;\n+import org.apache.datasketches.theta.UpdateSketchBuilder;\n import org.apache.pinot.common.function.AggregationFunctionType;\n-import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n import org.apache.pinot.core.common.BlockValSet;\n import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluator;\n import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluatorProvider;\n import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n-import org.apache.pinot.core.query.aggregation.function.RawThetaSketchAggregationFunction.Parameters;\n import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n import org.apache.pinot.core.query.request.context.ExpressionContext;\n import org.apache.pinot.core.query.request.context.FilterContext;\n+import org.apache.pinot.core.query.request.context.FunctionContext;\n import org.apache.pinot.core.query.request.context.predicate.Predicate;\n import org.apache.pinot.core.query.request.context.utils.QueryContextConverterUtils;\n-import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n import org.apache.pinot.sql.parsers.CalciteSqlParser;\n \n \n /**\n- * Implementation of {@link AggregationFunction} to perform the distinct count aggregation using\n- * Theta Sketches.\n- * <p>TODO: For performance concern, use {@code List<Sketch>} as the intermediate result.\n+ * The {@code DistinctCountThetaSketchAggregationFunction} can be used in 2 modes:\n+ * <ul>\n+ *   <li>\n+ *     Simple union without post-aggregation (1 or 2 arguments): main expression to aggregate on, optional theta-sketch\n+ *     parameters\n+ *     <p>E.g. DISTINCT_COUNT_THETA_SKETCH(col)\n+ *   </li>\n+ *   <li>\n+ *     Union with post-aggregation (at least 4 arguments): main expression to aggregate on, theta-sketch parameters,\n+ *     filter(s), post-aggregation expression\n+ *     <p>E.g. DISTINCT_COUNT_THETA_SKETCH(col, '', 'dimName=''gender'' AND dimValue=''male''',\n+ *     'dimName=''course'' AND dimValue=''math''', 'SET_INTERSECT($1,$2)')\n+ *   </li>\n+ * </ul>\n+ * Currently there is only 1 parameter for the function:\n+ * <ul>\n+ *   <li>\n+ *     nominalEntries: The nominal entries used to create the sketch. (Default 4096)\n+ *   </li>\n+ * </ul>\n+ * <p>E.g. DISTINCT_COUNT_THETA_SKETCH(col, 'nominalEntries=8192')\n  */\n-public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<Map<String, Sketch>, Long> {\n-\n-  public enum MergeFunction {\n-    SET_UNION, SET_INTERSECT, SET_DIFF;\n-\n-    public static final ImmutableList<String> STRING_VALUES =\n-        ImmutableList.of(SET_UNION.name(), SET_INTERSECT.name(), SET_DIFF.name());\n-\n-    public static final String CSV_VALUES = String.join(\",\", STRING_VALUES);\n-\n-    public static boolean isValid(String name) {\n-      return SET_UNION.name().equalsIgnoreCase(name) || SET_INTERSECT.name().equalsIgnoreCase(name) || SET_DIFF.name()\n-          .equalsIgnoreCase(name);\n-    }\n-  }\n-\n-  private static final Pattern ARGUMENT_SUBSTITUTION = Pattern.compile(\"\\\\$(\\\\d+)\");\n-\n-  private final ExpressionContext _thetaSketchColumn;\n-  private final SetOperationBuilder _setOperationBuilder;\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class DistinctCountThetaSketchAggregationFunction implements AggregationFunction<List<Sketch>, Long> {\n+  private static final String SET_UNION = \"SET_UNION\";\n+  private static final String SET_INTERSECT = \"SET_INTERSECT\";\n+  private static final String SET_DIFF = \"SET_DIFF\";\n+  private static final String DEFAULT_SKETCH_IDENTIFIER = \"$0\";\n+  static final Sketch EMPTY_SKETCH = new UpdateSketchBuilder().build().compact();\n+\n+  private final ExpressionContext _mainExpression;\n   private final List<ExpressionContext> _inputExpressions;\n+  private final boolean _includeDefaultSketch;\n+  private final List<FilterEvaluator> _filterEvaluators;\n   private final ExpressionContext _postAggregationExpression;\n-  private final List<Predicate> _predicates;\n-  private final Map<Predicate, PredicateInfo> _predicateInfoMap;\n+  private final UpdateSketchBuilder _updateSketchBuilder = new UpdateSketchBuilder();\n+  private final SetOperationBuilder _setOperationBuilder = new SetOperationBuilder();\n \n-  /**\n-   * Constructor for the class.\n-   * @param arguments List of parameters as arguments strings. At least three arguments are expected:\n-   *                    <ul>\n-   *                    <li> Required: First expression is interpreted as theta sketch column to aggregate on. </li>\n-   *                    <li> Required: Second argument is the thetaSketchParams. </li>\n-   *                    <li> Optional: Third to penultimate are predicates with LHS and RHS. </li>\n-   *                    <li> Required: Last expression is the one that will be evaluated to compute final result. </li>\n-   *                    </ul>\n-   */\n-  public DistinctCountThetaSketchAggregationFunction(List<ExpressionContext> arguments)\n-      throws SqlParseException {\n+  public DistinctCountThetaSketchAggregationFunction(List<ExpressionContext> arguments) {\n     int numArguments = arguments.size();\n+    _mainExpression = arguments.get(0);\n+\n+    // Initialize the UpdateSketchBuilder and SetOperationBuilder with the parameters\n+    if (numArguments > 1) {\n+      ExpressionContext paramsExpression = arguments.get(1);\n+      Preconditions.checkArgument(paramsExpression.getType() == ExpressionContext.Type.LITERAL,\n+          \"Second argument of DISTINCT_COUNT_THETA_SKETCH aggregation function must be literal (parameters)\");\n+      Parameters parameters = new Parameters(paramsExpression.getLiteral());\n+      int nominalEntries = parameters.getNominalEntries();\n+      _updateSketchBuilder.setNominalEntries(nominalEntries);\n+      _setOperationBuilder.setNominalEntries(nominalEntries);\n+    }\n \n-    // NOTE: This function expects at least 4 arguments: theta-sketch column, nominalEntries, predicate(s), post-aggregation expression.\n-    Preconditions.checkArgument(numArguments > 3,\n-        \"DistinctCountThetaSketch expects at least four arguments (theta-sketch column, parameter(s), post-aggregation expression), got: \",\n-        numArguments);\n-\n-    // Initialize the theta-sketch column\n-    _thetaSketchColumn = arguments.get(0);\n-    Preconditions.checkArgument(_thetaSketchColumn.getType() == ExpressionContext.Type.IDENTIFIER,\n-        \"First argument of DistinctCountThetaSketch must be identifier (theta-sketch column)\");\n-\n-    // Initialize the theta-sketch parameters\n-    ExpressionContext parametersExpression = arguments.get(1);\n-    Preconditions.checkArgument(parametersExpression.getType() == ExpressionContext.Type.LITERAL,\n-        \"Second argument of DistinctCountThetaSketch must be literal (parameters)\");\n-    Parameters parameters = new Parameters(parametersExpression.getLiteral());\n-\n-    // Initialize the theta-sketch set operation builder\n-    _setOperationBuilder = new SetOperationBuilder().setNominalEntries(parameters.getNominalEntries());\n-\n-    // Index of the original input predicates\n-    // This list is zero indexed, whereas argument substitution is 1-indexed: index[0] = $1\n-    _predicates = new ArrayList<>();\n-\n-    // Initialize the input expressions\n-    // NOTE: It is expected to cover the theta-sketch column and the lhs of the predicates.\n-    _inputExpressions = new ArrayList<>();\n-    _inputExpressions.add(_thetaSketchColumn);\n+    if (numArguments < 4) {\n+      // Simple union without post-aggregation\n \n-    // Initialize the post-aggregation expression\n-    // NOTE: It is modeled as a filter\n-    ExpressionContext postAggregationExpression = arguments.get(numArguments - 1);\n-    Preconditions.checkArgument(parametersExpression.getType() == ExpressionContext.Type.LITERAL,\n-        \"Last argument of DistinctCountThetaSketch must be literal (post-aggregation expression)\");\n-    _postAggregationExpression = QueryContextConverterUtils\n-        .getExpression(CalciteSqlParser.compileToExpression(postAggregationExpression.getLiteral()));\n+      _inputExpressions = Collections.singletonList(_mainExpression);\n+      _includeDefaultSketch = true;\n+      _filterEvaluators = Collections.emptyList();\n+      _postAggregationExpression = ExpressionContext.forIdentifier(DEFAULT_SKETCH_IDENTIFIER);\n+    } else {\n+      // Union with post-aggregation", "originalCommit": "06155e45364b92ba23edbda5d89bab1dd4539736", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNjAwOA==", "url": "https://github.com/apache/pinot/pull/6004#discussion_r496926008", "bodyText": "Yes, we have unit test and integration test for this", "author": "Jackie-Jiang", "createdAt": "2020-09-29T17:46:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxNzIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxOTc2Nw==", "url": "https://github.com/apache/pinot/pull/6004#discussion_r496919767", "bodyText": "Are these if/else blocks re-factorable?", "author": "mayankshriv", "createdAt": "2020-09-29T17:36:14Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountThetaSketchAggregationFunction.java", "diffHunk": "@@ -184,346 +192,1063 @@ public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int ma\n   @Override\n   public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n       Map<ExpressionContext, BlockValSet> blockValSetMap) {\n-    Map<Predicate, Union> unionMap = getUnionMap(aggregationResultHolder);\n-\n-    Sketch[] sketches = deserializeSketches(blockValSetMap.get(_thetaSketchColumn).getBytesValuesSV(), length);\n-    for (PredicateInfo predicateInfo : _predicateInfoMap.values()) {\n-      Predicate predicate = predicateInfo.getPredicate();\n-      BlockValSet blockValSet = blockValSetMap.get(predicate.getLhs());\n-      FieldSpec.DataType valueType = blockValSet.getValueType();\n-      PredicateEvaluator predicateEvaluator = predicateInfo.getPredicateEvaluator(valueType);\n-\n-      Union union = unionMap.get(predicate);\n-      switch (valueType) {\n-        case INT:\n-          int[] intValues = blockValSet.getIntValuesSV();\n-          for (int i = 0; i < length; i++) {\n-            if (predicateEvaluator.applySV(intValues[i])) {\n-              union.update(sketches[i]);\n+    int numExpressions = _inputExpressions.size();\n+    boolean[] singleValues = new boolean[numExpressions];\n+    DataType[] valueTypes = new DataType[numExpressions];\n+    Object[] valueArrays = new Object[numExpressions];\n+    extractValues(blockValSetMap, singleValues, valueTypes, valueArrays);\n+    int numFilters = _filterEvaluators.size();\n+\n+    // Main expression is always index 0\n+    if (valueTypes[0] != DataType.BYTES) {\n+      List<UpdateSketch> updateSketches = getUpdateSketches(aggregationResultHolder);\n+      if (singleValues[0]) {", "originalCommit": "06155e45364b92ba23edbda5d89bab1dd4539736", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNzQ2OA==", "url": "https://github.com/apache/pinot/pull/6004#discussion_r496927468", "bodyText": "I tried and don't see a better way to organize the code. We need to have slightly different logic for each primitive type", "author": "Jackie-Jiang", "createdAt": "2020-09-29T17:48:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxOTc2Nw=="}], "type": "inlineReview"}, {"oid": "297874d9427d8fcbfcaefb7e2a6682e032527d87", "url": "https://github.com/apache/pinot/commit/297874d9427d8fcbfcaefb7e2a6682e032527d87", "message": "Replace the old DistinctCount(Raw)ThetaSketchAggregationFunction with the new one\n\nMake `DistinctCountRawThetaSketchAggregationFunction` the same usage as `DistinctCountThetaSketchAggregationFunction` and returns base64 encoded sketch.\nAlso fix the issue in BaseBrokerRequestHandler.updateColumnNames()", "committedDate": "2020-09-29T18:48:23Z", "type": "commit"}, {"oid": "297874d9427d8fcbfcaefb7e2a6682e032527d87", "url": "https://github.com/apache/pinot/commit/297874d9427d8fcbfcaefb7e2a6682e032527d87", "message": "Replace the old DistinctCount(Raw)ThetaSketchAggregationFunction with the new one\n\nMake `DistinctCountRawThetaSketchAggregationFunction` the same usage as `DistinctCountThetaSketchAggregationFunction` and returns base64 encoded sketch.\nAlso fix the issue in BaseBrokerRequestHandler.updateColumnNames()", "committedDate": "2020-09-29T18:48:23Z", "type": "forcePushed"}]}